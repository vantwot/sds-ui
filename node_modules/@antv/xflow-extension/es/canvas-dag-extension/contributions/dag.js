var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { ManaSyringe, DisposableCollection, NsGraph, Disposable, XFlowEdgeCommands, } from '@antv/xflow-core';
import { IGraphCommandFactory, IHookContribution, IModelContribution, IGraphCommandContribution, } from '@antv/xflow-core';
import { HookHub } from '@antv/xflow-hook';
import { XFlowNode } from '../x6-extension/node';
import { XFlowEdge, EDGE_PATH_TYPE } from '../x6-extension/edge';
import { GRAPH_STATUS_INFO } from '../constants';
import { NsGraphStatusCommand } from './command';
export var NsAddEdgeEvent;
(function (NsAddEdgeEvent) {
    NsAddEdgeEvent.EVENT_NAME = 'ADD_EDGE_CMD_EVENT';
})(NsAddEdgeEvent || (NsAddEdgeEvent = {}));
export const ANT_PREFIX = 'ant';
export const dagOptions = {
    keyboard: {
        enabled: true,
    },
    // 点选/框选配置（详细文档：https://X6.antv.vision/zh/docs/tutorial/basic/selection）
    selecting: {
        enabled: true,
        multiple: true,
        selectCellOnMoved: true,
        showNodeSelectionBox: false,
        // 框选可以选中edge
        rubberEdge: true,
        // 框选可以选中node
        rubberNode: true,
        movable: true,
    },
    connecting: {
        //链接桩的位置 https://x6.antv.vision/zh/docs/api/registry/node-anchor
        sourceAnchor: 'bottom',
        //链接桩的位置 https://x6.antv.vision/zh/docs/api/registry/node-anchor
        targetAnchor: 'center',
        connectionPoint: 'anchor',
        snap: { radius: 20 },
        router: { name: 'manhattan' },
        connector: {
            name: EDGE_PATH_TYPE.VERTICAL_NODE,
            args: {
                radius: 15,
            },
        },
        highlight: true,
        dangling: false,
        createEdge() {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            const graph = this;
            const edge = new XFlowEdge({
                attrs: {
                    line: {
                        strokeDasharray: '5 5',
                        stroke: '#888',
                        strokeWidth: 1,
                        targetMarker: {
                            name: 'block',
                            args: {
                                size: '6',
                            },
                        },
                    },
                },
            });
            graph.once('edge:connected', args => {
                const { isNew } = args;
                const edgeCell = args.edge;
                if (isNew && edgeCell.isEdge()) {
                    const portId = edgeCell.getTargetPortId();
                    const targetNode = edgeCell.getTargetCell();
                    if (targetNode && targetNode.isNode()) {
                        targetNode.setPortProp(portId, 'connected', false);
                        edgeCell.attr({
                            line: {
                                strokeDasharray: '',
                                targetMarker: '',
                                stroke: '#d5d5d5',
                            },
                        });
                        const targetPortId = edgeCell.getTargetPortId();
                        const sourcePortId = edgeCell.getSourcePortId();
                        const sourceCellId = edgeCell.getSourceCellId();
                        const targetCellId = edgeCell.getTargetCellId();
                        graph.trigger(NsAddEdgeEvent.EVENT_NAME, {
                            targetPortId,
                            sourcePortId,
                            source: sourceCellId,
                            target: targetCellId,
                            edge: edge,
                        });
                    }
                }
            });
            return edge;
        },
        validateEdge: args => {
            var _a;
            const { edge } = args;
            return !!((_a = edge === null || edge === void 0 ? void 0 : edge.target) === null || _a === void 0 ? void 0 : _a.port);
        },
        // 是否触发交互事件
        validateMagnet({ magnet }) {
            return magnet.getAttribute('port-group') !== NsGraph.AnchorGroup.TOP;
        },
        // 显示可用的链接桩
        validateConnection({ sourceView, targetView, sourceMagnet, targetMagnet }) {
            // 不允许连接到自己
            if (sourceView === targetView) {
                return false;
            }
            // 只能从上游节点的输出链接桩创建连接
            if (!sourceMagnet || sourceMagnet.getAttribute('port-group') === NsGraph.AnchorGroup.TOP) {
                return false;
            }
            // 只能连接到下游节点的输入桩
            if (!targetMagnet || targetMagnet.getAttribute('port-group') !== NsGraph.AnchorGroup.TOP) {
                return false;
            }
            const node = targetView.cell;
            // 判断目标链接桩是否可连接
            const portId = targetMagnet.getAttribute('port');
            const port = node.getPort(portId);
            return !(port && port.connected);
        },
    },
    highlighting: {
        nodeAvailable: {
            name: 'className',
            args: {
                className: 'available',
            },
        },
        magnetAvailable: {
            name: 'className',
            args: {
                className: 'available',
            },
        },
        magnetAdsorbed: {
            name: 'className',
            args: {
                className: 'adsorbed',
            },
        },
    },
    scaling: {
        max: 1.05,
        min: 0.01,
    },
};
/**
 * 内置的hook contribution
 * 处理 config上的runtime的注册项
 */
let DagHooksContribution = class DagHooksContribution {
    constructor() {
        /** 注册Command */
        this.registerGraphCommands = (commands) => {
            commands.registerCommand(NsGraphStatusCommand.command, {
                createCommand: this.commandFactory,
            });
        };
        /** 注册Hub */
        this.toDispose = new DisposableCollection();
        /** 注册Hook */
        this.registerHook = (hooks) => __awaiter(this, void 0, void 0, function* () {
            const toDispose = new DisposableCollection();
            const disposables = [
                hooks.addNode.registerHook({
                    name: 'dag-add-node',
                    handler: (args) => __awaiter(this, void 0, void 0, function* () {
                        const cellFactory = (nodeConfig) => __awaiter(this, void 0, void 0, function* () {
                            const node = new XFlowNode(Object.assign({}, nodeConfig));
                            return node;
                        });
                        args.cellFactory = cellFactory;
                    }),
                }),
                hooks.addEdge.registerHook({
                    name: 'dag-add-edge',
                    handler: (args) => __awaiter(this, void 0, void 0, function* () {
                        const cellFactory = (edgeConfig) => __awaiter(this, void 0, void 0, function* () {
                            const cell = new XFlowEdge({
                                id: edgeConfig.id,
                                source: {
                                    cell: edgeConfig.source,
                                    port: edgeConfig.sourcePortId,
                                    anchor: {
                                        name: 'bottom',
                                    },
                                },
                                target: {
                                    cell: edgeConfig.target,
                                    port: edgeConfig.targetPortId,
                                    anchor: {
                                        name: 'center',
                                    },
                                },
                                attrs: {
                                    line: {
                                        strokeDasharray: '',
                                        targetMarker: '',
                                        stroke: '#d5d5d5',
                                        strokeWidth: 1,
                                    },
                                },
                                data: Object.assign({}, edgeConfig),
                            });
                            return cell;
                        });
                        args.cellFactory = cellFactory;
                    }),
                }),
                hooks.addEdge.registerHook({
                    name: 'after add edge, set target port props',
                    handler: (handlerArgs, handler) => __awaiter(this, void 0, void 0, function* () {
                        const main = (args) => __awaiter(this, void 0, void 0, function* () {
                            const res = yield handler(args);
                            const targetNode = res.edgeCell.getTargetCell();
                            const portId = res.edgeCell.getTargetPortId();
                            targetNode.setPortProp(portId, 'connected', true);
                            return res;
                        });
                        return main;
                    }),
                }),
                hooks.delEdge.registerHook({
                    name: 'afetr del edge, reset target node port props',
                    handler: (args, handler) => __awaiter(this, void 0, void 0, function* () {
                        const newHandler = (handlerArgs) => __awaiter(this, void 0, void 0, function* () {
                            const result = yield handler(handlerArgs);
                            const { targetCell, targetPortId } = result;
                            if (targetCell && targetCell.isNode() && targetPortId) {
                                targetCell.setPortProp(targetPortId, 'connected', false);
                            }
                            return result;
                        });
                        return newHandler;
                    }),
                }),
                hooks.afterGraphInit.registerHook({
                    name: 'call add edge to replace temp edge',
                    handler: (handlerArgs) => __awaiter(this, void 0, void 0, function* () {
                        const { commandService, graph } = handlerArgs;
                        graph.on(NsAddEdgeEvent.EVENT_NAME, (args) => {
                            commandService.executeCommand(XFlowEdgeCommands.ADD_EDGE.id, { edgeConfig: args });
                            args.edge.remove();
                        });
                    }),
                }),
                hooks.graphOptions.registerHook({
                    name: 'dag-extension-x6-options',
                    handler: (args) => __awaiter(this, void 0, void 0, function* () {
                        Object.assign(args, dagOptions);
                    }),
                }),
            ];
            toDispose.pushAll(disposables);
            return Disposable.create(() => { });
        });
        /** 注册Hub */
        this.registerHookHub = (registry) => __awaiter(this, void 0, void 0, function* () {
            return registry.registerHookHub(NsGraphStatusCommand.hookKey, new HookHub());
        });
    }
    /** 扩展Model */
    registerModel(registry) {
        /** node status map */
        registry.registerModel({
            id: GRAPH_STATUS_INFO.id,
            getInitialValue: () => ({
                statusMap: new Map(),
                subscription: new DisposableCollection(),
                graphStatus: GRAPH_STATUS_INFO.StatusEnum.DEFAULT,
            }),
            watchChange: (self) => __awaiter(this, void 0, void 0, function* () {
                const { subscription } = yield self.getValidValue();
                return subscription;
            }),
        });
    }
};
__decorate([
    ManaSyringe.inject(IGraphCommandFactory),
    __metadata("design:type", Function)
], DagHooksContribution.prototype, "commandFactory", void 0);
DagHooksContribution = __decorate([
    ManaSyringe.singleton({
        contrib: [IHookContribution, IModelContribution, IGraphCommandContribution],
    })
], DagHooksContribution);
export { DagHooksContribution };
//# sourceMappingURL=dag.js.map