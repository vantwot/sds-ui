"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.useGraphConfig = exports.NsAddEdgeEvent = void 0;
var react_1 = __importDefault(require("react"));
var antd_1 = require("antd");
var react_dom_1 = __importDefault(require("react-dom"));
var classnames_1 = __importDefault(require("classnames"));
var xflow_core_1 = require("@antv/xflow-core");
var x6_1 = require("@antv/x6");
var flowchart_node_panel_1 = require("../flowchart-node-panel");
var utils_1 = require("./utils");
/** 自定义React节点 */
var ANT_PREFIX = 'ant';
var NsAddEdgeEvent;
(function (NsAddEdgeEvent) {
    NsAddEdgeEvent.EVENT_NAME = 'ADD_FLOWCHART_EDGE_CMD_EVENT';
})(NsAddEdgeEvent = exports.NsAddEdgeEvent || (exports.NsAddEdgeEvent = {}));
var XFlowEdge = x6_1.Shape.Edge.registry.register('xflow', x6_1.Shape.Edge.define({
    zIndex: 1,
    highlight: true,
    shape: 'EDGE1',
    name: 'custom-edge',
    label: '',
    anchor: {
        name: 'midSide',
        args: {
            dx: 10,
        },
    },
    attrs: {
        line: {
            stroke: '#A2B1C3',
            targetMarker: {
                name: 'block',
                width: 12,
                height: 8,
            },
            strokeDasharray: '5 5',
            strokeWidth: 1,
        },
    },
    data: {
        label: '',
    },
}), true);
exports.useGraphConfig = (0, xflow_core_1.createGraphConfig)(function (config, proxy) {
    var _a = proxy.getValue().config, canvasConfig = _a === void 0 ? {} : _a;
    config.setEdgeTypeParser(function (edge) { return edge === null || edge === void 0 ? void 0 : edge.renderKey; });
    (0, flowchart_node_panel_1.setNodeRender)(config);
    (0, flowchart_node_panel_1.setGroupRender)(config);
    /** 这里比较黑，props 共享*/
    (0, utils_1.setProps)(__assign(__assign({}, proxy.getValue()), { graphConfig: config }));
    config.setX6Config(__assign({ grid: true, history: true, resizing: {
            enabled: true,
            minWidth: flowchart_node_panel_1.NODE_HEIGHT,
            minHeight: flowchart_node_panel_1.NODE_HEIGHT,
            preserveAspectRatio: function (shape) {
                var data = shape.data;
                return flowchart_node_panel_1.ASPECTRATIONODE.includes(data.name);
            },
        }, snapline: {
            enabled: true,
        }, connecting: {
            router: 'manhattan',
            connector: {
                name: 'rounded',
                args: {
                    radius: 8,
                },
            },
            anchor: 'center',
            connectionPoint: 'anchor',
            allowBlank: false,
            snap: {
                radius: 20,
            },
            createEdge: function () {
                var _this = this;
                var tempEdge = new XFlowEdge({});
                this.once('edge:connected', function (args) {
                    var edge = args.edge, isNew = args.isNew;
                    if (isNew && edge.isEdge()) {
                        var targetNode = edge.getTargetCell();
                        if (targetNode && targetNode.isNode()) {
                            var targetPortId = edge.getTargetPortId();
                            var sourcePortId = edge.getSourcePortId();
                            var sourceCellId = edge.getSourceCellId();
                            var targetCellId = edge.getTargetCellId();
                            _this.trigger(NsAddEdgeEvent.EVENT_NAME, {
                                targetPortId: targetPortId,
                                sourcePortId: sourcePortId,
                                source: sourceCellId,
                                target: targetCellId,
                                edge: edge,
                            });
                        }
                    }
                });
                return tempEdge;
            },
            validateEdge: function (args) {
                var _a;
                var edge = args.edge;
                return !!((_a = edge === null || edge === void 0 ? void 0 : edge.target) === null || _a === void 0 ? void 0 : _a.port);
            },
            // 是否触发交互事件
            validateMagnet: function () {
                // 所有锚点均可触发
                return true;
            },
            // 显示可用的链接桩
            validateConnection: function (_a) {
                var sourceView = _a.sourceView, targetView = _a.targetView, targetMagnet = _a.targetMagnet;
                // 不允许连接到自己
                if (sourceView === targetView) {
                    return false;
                }
                var node = targetView.cell;
                // 判断目标链接桩是否可连接
                if (targetMagnet) {
                    var portId = targetMagnet.getAttribute('port');
                    var port = node.getPort(portId);
                    return !(port && port.connected);
                }
                return;
            },
        }, highlighting: {
            nodeAvailable: {
                name: 'className',
                args: {
                    className: 'available',
                },
            },
            magnetAvailable: {
                name: 'className',
                args: {
                    className: 'available',
                },
            },
            magnetAdsorbed: {
                name: 'className',
                args: {
                    className: 'adsorbed',
                },
            },
        }, onPortRendered: function (args) {
            var port = args.port;
            var contentSelectors = args.contentSelectors;
            var container = contentSelectors && contentSelectors.content;
            var placement = port.group;
            var clz = (0, classnames_1.default)('xflow-port', { connected: port.connected });
            if (container) {
                react_dom_1.default.render((react_1.default.createElement(antd_1.ConfigProvider, { prefixCls: ANT_PREFIX },
                    react_1.default.createElement(antd_1.Tooltip, { title: port.tooltip, placement: placement },
                        react_1.default.createElement("span", { className: clz })))), container);
            }
        } }, canvasConfig));
    /** 内交互，上层通过实例绑定 */
    config.setEvents([
        {
            eventName: 'node:selected',
            callback: function () {
                (0, utils_1.changePortsVisible)(false);
            },
        },
        {
            eventName: 'edge:dblclick',
            callback: function (e) {
                (0, utils_1.addTools)(e);
            },
        },
        {
            eventName: 'edge:mouseleave',
            callback: function (e, cmds) {
                (0, utils_1.removeTools)(e, cmds);
            },
        },
        {
            eventName: 'node:mouseenter',
            callback: function (e) {
                (0, utils_1.changePortsVisible)(true, e);
            },
        },
        {
            eventName: 'node:mouseleave',
            callback: function (e) {
                (0, utils_1.changePortsVisible)(false, e);
            },
        },
        {
            eventName: 'node:moved',
            callback: function (e, cmds) {
                (0, utils_1.movedNode)(e, cmds);
            },
        },
        {
            eventName: 'node:resized',
            callback: function (e, cmds) {
                (0, utils_1.resizeNode)(e, cmds);
            },
        },
    ]);
});
//# sourceMappingURL=config-graph.js.map