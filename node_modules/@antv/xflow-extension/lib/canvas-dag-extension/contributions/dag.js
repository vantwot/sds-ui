"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.DagHooksContribution = exports.dagOptions = exports.ANT_PREFIX = exports.NsAddEdgeEvent = void 0;
var xflow_core_1 = require("@antv/xflow-core");
var xflow_core_2 = require("@antv/xflow-core");
var xflow_hook_1 = require("@antv/xflow-hook");
var node_1 = require("../x6-extension/node");
var edge_1 = require("../x6-extension/edge");
var constants_1 = require("../constants");
var command_1 = require("./command");
var NsAddEdgeEvent;
(function (NsAddEdgeEvent) {
    NsAddEdgeEvent.EVENT_NAME = 'ADD_EDGE_CMD_EVENT';
})(NsAddEdgeEvent = exports.NsAddEdgeEvent || (exports.NsAddEdgeEvent = {}));
exports.ANT_PREFIX = 'ant';
exports.dagOptions = {
    keyboard: {
        enabled: true,
    },
    // 点选/框选配置（详细文档：https://X6.antv.vision/zh/docs/tutorial/basic/selection）
    selecting: {
        enabled: true,
        multiple: true,
        selectCellOnMoved: true,
        showNodeSelectionBox: false,
        // 框选可以选中edge
        rubberEdge: true,
        // 框选可以选中node
        rubberNode: true,
        movable: true,
    },
    connecting: {
        //链接桩的位置 https://x6.antv.vision/zh/docs/api/registry/node-anchor
        sourceAnchor: 'bottom',
        //链接桩的位置 https://x6.antv.vision/zh/docs/api/registry/node-anchor
        targetAnchor: 'center',
        connectionPoint: 'anchor',
        snap: { radius: 20 },
        router: { name: 'manhattan' },
        connector: {
            name: edge_1.EDGE_PATH_TYPE.VERTICAL_NODE,
            args: {
                radius: 15,
            },
        },
        highlight: true,
        dangling: false,
        createEdge: function () {
            /* eslint-disable-next-line @typescript-eslint/no-this-alias */
            var graph = this;
            var edge = new edge_1.XFlowEdge({
                attrs: {
                    line: {
                        strokeDasharray: '5 5',
                        stroke: '#888',
                        strokeWidth: 1,
                        targetMarker: {
                            name: 'block',
                            args: {
                                size: '6',
                            },
                        },
                    },
                },
            });
            graph.once('edge:connected', function (args) {
                var isNew = args.isNew;
                var edgeCell = args.edge;
                if (isNew && edgeCell.isEdge()) {
                    var portId = edgeCell.getTargetPortId();
                    var targetNode = edgeCell.getTargetCell();
                    if (targetNode && targetNode.isNode()) {
                        targetNode.setPortProp(portId, 'connected', false);
                        edgeCell.attr({
                            line: {
                                strokeDasharray: '',
                                targetMarker: '',
                                stroke: '#d5d5d5',
                            },
                        });
                        var targetPortId = edgeCell.getTargetPortId();
                        var sourcePortId = edgeCell.getSourcePortId();
                        var sourceCellId = edgeCell.getSourceCellId();
                        var targetCellId = edgeCell.getTargetCellId();
                        graph.trigger(NsAddEdgeEvent.EVENT_NAME, {
                            targetPortId: targetPortId,
                            sourcePortId: sourcePortId,
                            source: sourceCellId,
                            target: targetCellId,
                            edge: edge,
                        });
                    }
                }
            });
            return edge;
        },
        validateEdge: function (args) {
            var _a;
            var edge = args.edge;
            return !!((_a = edge === null || edge === void 0 ? void 0 : edge.target) === null || _a === void 0 ? void 0 : _a.port);
        },
        // 是否触发交互事件
        validateMagnet: function (_a) {
            var magnet = _a.magnet;
            return magnet.getAttribute('port-group') !== xflow_core_1.NsGraph.AnchorGroup.TOP;
        },
        // 显示可用的链接桩
        validateConnection: function (_a) {
            var sourceView = _a.sourceView, targetView = _a.targetView, sourceMagnet = _a.sourceMagnet, targetMagnet = _a.targetMagnet;
            // 不允许连接到自己
            if (sourceView === targetView) {
                return false;
            }
            // 只能从上游节点的输出链接桩创建连接
            if (!sourceMagnet || sourceMagnet.getAttribute('port-group') === xflow_core_1.NsGraph.AnchorGroup.TOP) {
                return false;
            }
            // 只能连接到下游节点的输入桩
            if (!targetMagnet || targetMagnet.getAttribute('port-group') !== xflow_core_1.NsGraph.AnchorGroup.TOP) {
                return false;
            }
            var node = targetView.cell;
            // 判断目标链接桩是否可连接
            var portId = targetMagnet.getAttribute('port');
            var port = node.getPort(portId);
            return !(port && port.connected);
        },
    },
    highlighting: {
        nodeAvailable: {
            name: 'className',
            args: {
                className: 'available',
            },
        },
        magnetAvailable: {
            name: 'className',
            args: {
                className: 'available',
            },
        },
        magnetAdsorbed: {
            name: 'className',
            args: {
                className: 'adsorbed',
            },
        },
    },
    scaling: {
        max: 1.05,
        min: 0.01,
    },
};
/**
 * 内置的hook contribution
 * 处理 config上的runtime的注册项
 */
var DagHooksContribution = /** @class */ (function () {
    function DagHooksContribution() {
        var _this = this;
        /** 注册Command */
        this.registerGraphCommands = function (commands) {
            commands.registerCommand(command_1.NsGraphStatusCommand.command, {
                createCommand: _this.commandFactory,
            });
        };
        /** 注册Hub */
        this.toDispose = new xflow_core_1.DisposableCollection();
        /** 注册Hook */
        this.registerHook = function (hooks) { return __awaiter(_this, void 0, void 0, function () {
            var toDispose, disposables;
            var _this = this;
            return __generator(this, function (_a) {
                toDispose = new xflow_core_1.DisposableCollection();
                disposables = [
                    hooks.addNode.registerHook({
                        name: 'dag-add-node',
                        handler: function (args) { return __awaiter(_this, void 0, void 0, function () {
                            var cellFactory;
                            var _this = this;
                            return __generator(this, function (_a) {
                                cellFactory = function (nodeConfig) { return __awaiter(_this, void 0, void 0, function () {
                                    var node;
                                    return __generator(this, function (_a) {
                                        node = new node_1.XFlowNode(__assign({}, nodeConfig));
                                        return [2 /*return*/, node];
                                    });
                                }); };
                                args.cellFactory = cellFactory;
                                return [2 /*return*/];
                            });
                        }); },
                    }),
                    hooks.addEdge.registerHook({
                        name: 'dag-add-edge',
                        handler: function (args) { return __awaiter(_this, void 0, void 0, function () {
                            var cellFactory;
                            var _this = this;
                            return __generator(this, function (_a) {
                                cellFactory = function (edgeConfig) { return __awaiter(_this, void 0, void 0, function () {
                                    var cell;
                                    return __generator(this, function (_a) {
                                        cell = new edge_1.XFlowEdge({
                                            id: edgeConfig.id,
                                            source: {
                                                cell: edgeConfig.source,
                                                port: edgeConfig.sourcePortId,
                                                anchor: {
                                                    name: 'bottom',
                                                },
                                            },
                                            target: {
                                                cell: edgeConfig.target,
                                                port: edgeConfig.targetPortId,
                                                anchor: {
                                                    name: 'center',
                                                },
                                            },
                                            attrs: {
                                                line: {
                                                    strokeDasharray: '',
                                                    targetMarker: '',
                                                    stroke: '#d5d5d5',
                                                    strokeWidth: 1,
                                                },
                                            },
                                            data: __assign({}, edgeConfig),
                                        });
                                        return [2 /*return*/, cell];
                                    });
                                }); };
                                args.cellFactory = cellFactory;
                                return [2 /*return*/];
                            });
                        }); },
                    }),
                    hooks.addEdge.registerHook({
                        name: 'after add edge, set target port props',
                        handler: function (handlerArgs, handler) { return __awaiter(_this, void 0, void 0, function () {
                            var main;
                            var _this = this;
                            return __generator(this, function (_a) {
                                main = function (args) { return __awaiter(_this, void 0, void 0, function () {
                                    var res, targetNode, portId;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, handler(args)];
                                            case 1:
                                                res = _a.sent();
                                                targetNode = res.edgeCell.getTargetCell();
                                                portId = res.edgeCell.getTargetPortId();
                                                targetNode.setPortProp(portId, 'connected', true);
                                                return [2 /*return*/, res];
                                        }
                                    });
                                }); };
                                return [2 /*return*/, main];
                            });
                        }); },
                    }),
                    hooks.delEdge.registerHook({
                        name: 'afetr del edge, reset target node port props',
                        handler: function (args, handler) { return __awaiter(_this, void 0, void 0, function () {
                            var newHandler;
                            var _this = this;
                            return __generator(this, function (_a) {
                                newHandler = function (handlerArgs) { return __awaiter(_this, void 0, void 0, function () {
                                    var result, targetCell, targetPortId;
                                    return __generator(this, function (_a) {
                                        switch (_a.label) {
                                            case 0: return [4 /*yield*/, handler(handlerArgs)];
                                            case 1:
                                                result = _a.sent();
                                                targetCell = result.targetCell, targetPortId = result.targetPortId;
                                                if (targetCell && targetCell.isNode() && targetPortId) {
                                                    targetCell.setPortProp(targetPortId, 'connected', false);
                                                }
                                                return [2 /*return*/, result];
                                        }
                                    });
                                }); };
                                return [2 /*return*/, newHandler];
                            });
                        }); },
                    }),
                    hooks.afterGraphInit.registerHook({
                        name: 'call add edge to replace temp edge',
                        handler: function (handlerArgs) { return __awaiter(_this, void 0, void 0, function () {
                            var commandService, graph;
                            return __generator(this, function (_a) {
                                commandService = handlerArgs.commandService, graph = handlerArgs.graph;
                                graph.on(NsAddEdgeEvent.EVENT_NAME, function (args) {
                                    commandService.executeCommand(xflow_core_1.XFlowEdgeCommands.ADD_EDGE.id, { edgeConfig: args });
                                    args.edge.remove();
                                });
                                return [2 /*return*/];
                            });
                        }); },
                    }),
                    hooks.graphOptions.registerHook({
                        name: 'dag-extension-x6-options',
                        handler: function (args) { return __awaiter(_this, void 0, void 0, function () {
                            return __generator(this, function (_a) {
                                Object.assign(args, exports.dagOptions);
                                return [2 /*return*/];
                            });
                        }); },
                    }),
                ];
                toDispose.pushAll(disposables);
                return [2 /*return*/, xflow_core_1.Disposable.create(function () { })];
            });
        }); };
        /** 注册Hub */
        this.registerHookHub = function (registry) { return __awaiter(_this, void 0, void 0, function () {
            return __generator(this, function (_a) {
                return [2 /*return*/, registry.registerHookHub(command_1.NsGraphStatusCommand.hookKey, new xflow_hook_1.HookHub())];
            });
        }); };
    }
    /** 扩展Model */
    DagHooksContribution.prototype.registerModel = function (registry) {
        var _this = this;
        /** node status map */
        registry.registerModel({
            id: constants_1.GRAPH_STATUS_INFO.id,
            getInitialValue: function () { return ({
                statusMap: new Map(),
                subscription: new xflow_core_1.DisposableCollection(),
                graphStatus: constants_1.GRAPH_STATUS_INFO.StatusEnum.DEFAULT,
            }); },
            watchChange: function (self) { return __awaiter(_this, void 0, void 0, function () {
                var subscription;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, self.getValidValue()];
                        case 1:
                            subscription = (_a.sent()).subscription;
                            return [2 /*return*/, subscription];
                    }
                });
            }); },
        });
    };
    __decorate([
        xflow_core_1.ManaSyringe.inject(xflow_core_2.IGraphCommandFactory),
        __metadata("design:type", Function)
    ], DagHooksContribution.prototype, "commandFactory", void 0);
    DagHooksContribution = __decorate([
        xflow_core_1.ManaSyringe.singleton({
            contrib: [xflow_core_2.IHookContribution, xflow_core_2.IModelContribution, xflow_core_2.IGraphCommandContribution],
        })
    ], DagHooksContribution);
    return DagHooksContribution;
}());
exports.DagHooksContribution = DagHooksContribution;
//# sourceMappingURL=dag.js.map