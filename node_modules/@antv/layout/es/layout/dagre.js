/**
 * @fileOverview random layout
 * @author shiwu.wyy@antfin.com
 */
import dagre from 'dagre';
import { isArray, isNumber } from '../util';
import { Base } from './base';
/**
 * 层次布局
 */
export class DagreLayout extends Base {
    constructor(options) {
        super();
        /** layout 方向, 可选 TB, BT, LR, RL */
        this.rankdir = 'TB';
        /** 节点水平间距(px) */
        this.nodesep = 50;
        /** 每一层节点之间间距 */
        this.ranksep = 50;
        /** 是否保留布局连线的控制点 */
        this.controlPoints = false;
        /** 每层节点是否根据节点数据中的 comboId 进行排序，以放置同层 combo 重叠 */
        this.sortByCombo = false;
        this.updateCfg(options);
    }
    getDefaultCfg() {
        return {
            rankdir: 'TB',
            align: undefined,
            nodeSize: undefined,
            nodesepFunc: undefined,
            ranksepFunc: undefined,
            nodesep: 50,
            ranksep: 50,
            controlPoints: false,
        };
    }
    /**
     * 执行布局
     */
    execute() {
        const self = this;
        const { nodes, nodeSize, rankdir } = self;
        if (!nodes)
            return;
        const edges = self.edges || [];
        const g = new dagre.graphlib.Graph();
        let nodeSizeFunc;
        if (!nodeSize) {
            nodeSizeFunc = (d) => {
                if (d.size) {
                    if (isArray(d.size)) {
                        return d.size;
                    }
                    return [d.size, d.size];
                }
                return [40, 40];
            };
        }
        else if (isArray(nodeSize)) {
            nodeSizeFunc = () => nodeSize;
        }
        else {
            nodeSizeFunc = () => [nodeSize, nodeSize];
        }
        let horisep = getFunc(self.nodesepFunc, self.nodesep, 50);
        let vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);
        if (rankdir === 'LR' || rankdir === 'RL') {
            horisep = getFunc(self.ranksepFunc, self.ranksep, 50);
            vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);
        }
        g.setDefaultEdgeLabel(() => ({}));
        g.setGraph(self);
        nodes.forEach((node) => {
            const size = nodeSizeFunc(node);
            const verti = vertisep(node);
            const hori = horisep(node);
            const width = size[0] + 2 * hori;
            const height = size[1] + 2 * verti;
            g.setNode(node.id, { width, height });
        });
        edges.forEach((edge) => {
            // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout
            g.setEdge(edge.source, edge.target, {
                weight: edge.weight || 1,
            });
        });
        dagre.layout(g);
        let coord;
        g.nodes().forEach((node) => {
            coord = g.node(node);
            const i = nodes.findIndex((it) => it.id === node);
            nodes[i].x = coord.x;
            nodes[i].y = coord.y;
        });
        g.edges().forEach((edge) => {
            coord = g.edge(edge);
            const i = edges.findIndex((it) => it.source === edge.v && it.target === edge.w);
            if (self.controlPoints && edges[i].type !== 'loop') {
                edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);
            }
        });
        if (self.sortByCombo) {
            self.sortLevel('comboId');
        }
        return nodes;
    }
    sortLevel(propertyName) {
        const self = this;
        const nodes = self.nodes;
        const levels = {};
        nodes.forEach((node) => {
            if (!levels[node.y])
                levels[node.y] = { y: node.y, nodes: [] };
            levels[node.y].nodes.push(node);
        });
        Object.keys(levels).forEach((key) => {
            const levelNodes = levels[key].nodes;
            const nodesNum = levelNodes.length;
            const comboCenters = {};
            levelNodes.forEach((lnode) => {
                const lnodeCombo = lnode.comboId;
                if (!comboCenters[lnodeCombo])
                    comboCenters[lnodeCombo] = { x: 0, y: 0, count: 0 };
                comboCenters[lnodeCombo].x += lnode.x;
                comboCenters[lnodeCombo].y += lnode.y;
                comboCenters[lnodeCombo].count++;
            });
            Object.keys(comboCenters).forEach((ckey) => {
                comboCenters[ckey].x /= comboCenters[ckey].count;
                comboCenters[ckey].y /= comboCenters[ckey].count;
            });
            if (nodesNum === 1)
                return;
            const sortedByX = levelNodes.sort((a, b) => {
                return a.x - b.x;
            });
            const minX = sortedByX[0].x;
            const maxX = sortedByX[nodesNum - 1].x;
            const gap = (maxX - minX) / (nodesNum - 1);
            const sortedByCombo = levelNodes.sort((a, b) => {
                const aValue = a[propertyName] || 'undefined';
                const bValue = b[propertyName] || 'undefined';
                if (aValue < bValue) {
                    return -1;
                }
                if (aValue > bValue) {
                    return 1;
                }
                return 0;
            });
            sortedByCombo.forEach((node, i) => {
                node.x = minX + i * gap;
            });
        });
    }
}
function getFunc(func, value, defaultValue) {
    let resultFunc;
    if (func) {
        resultFunc = func;
    }
    else if (isNumber(value)) {
        resultFunc = () => value;
    }
    else {
        resultFunc = () => defaultValue;
    }
    return resultFunc;
}
//# sourceMappingURL=dagre.js.map