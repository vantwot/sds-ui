{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Util } from '../../global';\nimport { FunctionExt } from '../../util';\nimport { Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Graph } from '../../graph/graph';\nexport class Dnd extends View {\n  constructor(options) {\n    super();\n    this.options = Object.assign(Object.assign({}, Dnd.defaults), options);\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container).addClass(this.prefixClassName('widget-dnd'));\n    this.draggingGraph = new Graph(Object.assign(Object.assign({}, this.options.delegateGraphOptions), {\n      container: document.createElement('div'),\n      width: 1,\n      height: 1\n    }));\n    this.$container.append(this.draggingGraph.container);\n  }\n\n  get targetScroller() {\n    const target = this.options.target;\n    return Graph.isGraph(target) ? target.scroller.widget : target;\n  }\n\n  get targetGraph() {\n    const target = this.options.target;\n    return Graph.isGraph(target) ? target : target.graph;\n  }\n\n  get targetModel() {\n    return this.targetGraph.model;\n  }\n\n  get snapline() {\n    return this.targetGraph.snapline.widget;\n  }\n\n  start(node, evt) {\n    const e = evt;\n    e.preventDefault();\n    this.targetModel.startBatch('dnd');\n    this.$container.addClass('dragging').appendTo(this.options.containerParent || document.body);\n    this.sourceNode = node;\n    this.prepareDragging(node, e.clientX, e.clientY);\n    const local = this.updateNodePosition(e.clientX, e.clientY);\n\n    if (this.isSnaplineEnabled()) {\n      this.snapline.captureCursorOffset({\n        e,\n        node,\n        cell: node,\n        view: this.draggingView,\n        x: local.x,\n        y: local.y\n      });\n      this.draggingNode.on('change:position', this.snap, this);\n    }\n\n    this.delegateDocumentEvents(Dnd.documentEvents, e.data);\n  }\n\n  isSnaplineEnabled() {\n    return this.snapline && !this.snapline.disabled;\n  }\n\n  prepareDragging(sourceNode, clientX, clientY) {\n    const draggingGraph = this.draggingGraph;\n    const draggingModel = draggingGraph.model;\n    const draggingNode = this.options.getDragNode(sourceNode, {\n      sourceNode,\n      draggingGraph,\n      targetGraph: this.targetGraph\n    });\n    draggingNode.position(0, 0);\n    let padding = 5;\n\n    if (this.isSnaplineEnabled()) {\n      padding += this.snapline.options.tolerance || 0;\n    }\n\n    if (this.isSnaplineEnabled() || this.options.scaled) {\n      const scale = this.targetGraph.transform.getScale();\n      draggingGraph.scale(scale.sx, scale.sy);\n      padding *= Math.max(scale.sx, scale.sy);\n    } else {\n      draggingGraph.scale(1, 1);\n    }\n\n    this.clearDragging();\n\n    if (this.options.animation) {\n      this.$container.stop(true, true);\n    }\n\n    draggingModel.resetCells([draggingNode]);\n    const delegateView = draggingGraph.findViewByCell(draggingNode);\n    delegateView.undelegateEvents();\n    delegateView.cell.off('changed');\n    draggingGraph.fitToContent({\n      padding,\n      allowNewOrigin: 'any'\n    });\n    const bbox = delegateView.getBBox();\n    this.geometryBBox = delegateView.getBBox({\n      useCellGeometry: true\n    });\n    this.delta = this.geometryBBox.getTopLeft().diff(bbox.getTopLeft());\n    this.draggingNode = draggingNode;\n    this.draggingView = delegateView;\n    this.draggingBBox = draggingNode.getBBox();\n    this.padding = padding;\n    this.originOffset = this.updateGraphPosition(clientX, clientY);\n  }\n\n  updateGraphPosition(clientX, clientY) {\n    const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n    const delta = this.delta;\n    const nodeBBox = this.geometryBBox;\n    const padding = this.padding || 5;\n    const offset = {\n      left: clientX - delta.x - nodeBBox.width / 2 - padding,\n      top: clientY - delta.y - nodeBBox.height / 2 - padding + scrollTop\n    };\n\n    if (this.draggingGraph) {\n      this.$container.offset(offset);\n    }\n\n    return offset;\n  }\n\n  updateNodePosition(x, y) {\n    const local = this.targetGraph.clientToLocal(x, y);\n    const bbox = this.draggingBBox;\n    local.x -= bbox.width / 2;\n    local.y -= bbox.height / 2;\n    this.draggingNode.position(local.x, local.y);\n    return local;\n  }\n\n  snap(_ref) {\n    let {\n      cell,\n      current,\n      options\n    } = _ref;\n    const node = cell;\n\n    if (options.snapped) {\n      const bbox = this.draggingBBox;\n      node.position(bbox.x + options.tx, bbox.y + options.ty, {\n        silent: true\n      });\n      this.draggingView.translate();\n      node.position(current.x, current.y, {\n        silent: true\n      });\n      this.snapOffset = {\n        x: options.tx,\n        y: options.ty\n      };\n    } else {\n      this.snapOffset = null;\n    }\n  }\n\n  onDragging(evt) {\n    const draggingView = this.draggingView;\n\n    if (draggingView) {\n      evt.preventDefault();\n      const e = this.normalizeEvent(evt);\n      const clientX = e.clientX;\n      const clientY = e.clientY;\n      this.updateGraphPosition(clientX, clientY);\n      const local = this.updateNodePosition(clientX, clientY);\n      const embeddingMode = this.targetGraph.options.embedding.enabled;\n      const isValidArea = (embeddingMode || this.isSnaplineEnabled()) && this.isInsideValidArea({\n        x: clientX,\n        y: clientY\n      });\n\n      if (embeddingMode) {\n        draggingView.setEventData(e, {\n          graph: this.targetGraph,\n          candidateEmbedView: this.candidateEmbedView\n        });\n        const data = draggingView.getEventData(e);\n\n        if (isValidArea) {\n          draggingView.processEmbedding(e, data);\n        } else {\n          draggingView.clearEmbedding(data);\n        }\n\n        this.candidateEmbedView = data.candidateEmbedView;\n      } // update snapline\n\n\n      if (this.isSnaplineEnabled()) {\n        if (isValidArea) {\n          this.snapline.snapOnMoving({\n            e,\n            view: draggingView,\n            x: local.x,\n            y: local.y\n          });\n        } else {\n          this.snapline.hide();\n        }\n      }\n    }\n  }\n\n  onDragEnd(evt) {\n    const draggingNode = this.draggingNode;\n\n    if (draggingNode) {\n      const e = this.normalizeEvent(evt);\n      const draggingView = this.draggingView;\n      const draggingBBox = this.draggingBBox;\n      const snapOffset = this.snapOffset;\n      let x = draggingBBox.x;\n      let y = draggingBBox.y;\n\n      if (snapOffset) {\n        x += snapOffset.x;\n        y += snapOffset.y;\n      }\n\n      draggingNode.position(x, y, {\n        silent: true\n      });\n      const ret = this.drop(draggingNode, {\n        x: e.clientX,\n        y: e.clientY\n      });\n\n      const callback = node => {\n        if (node) {\n          this.onDropped(draggingNode);\n\n          if (this.targetGraph.options.embedding.enabled && draggingView) {\n            draggingView.setEventData(e, {\n              cell: node,\n              graph: this.targetGraph,\n              candidateEmbedView: this.candidateEmbedView\n            });\n            draggingView.finalizeEmbedding(e, draggingView.getEventData(e));\n          }\n        } else {\n          this.onDropInvalid();\n        }\n\n        this.candidateEmbedView = null;\n        this.targetModel.stopBatch('dnd');\n      };\n\n      if (FunctionExt.isAsync(ret)) {\n        // stop dragging\n        this.undelegateDocumentEvents();\n        ret.then(callback); // eslint-disable-line\n      } else {\n        callback(ret);\n      }\n    }\n  }\n\n  clearDragging() {\n    if (this.draggingNode) {\n      this.sourceNode = null;\n      this.draggingNode.remove();\n      this.draggingNode = null;\n      this.draggingView = null;\n      this.delta = null;\n      this.padding = null;\n      this.snapOffset = null;\n      this.originOffset = null;\n      this.undelegateDocumentEvents();\n    }\n  }\n\n  onDropped(draggingNode) {\n    if (this.draggingNode === draggingNode) {\n      this.clearDragging();\n      this.$container.removeClass('dragging').remove();\n    }\n  }\n\n  onDropInvalid() {\n    const draggingNode = this.draggingNode;\n\n    if (draggingNode) {\n      const anim = this.options.animation;\n\n      if (anim) {\n        const duration = typeof anim === 'object' && anim.duration || 150;\n        const easing = typeof anim === 'object' && anim.easing || 'swing';\n        this.draggingView = null;\n        this.$container.animate(this.originOffset, duration, easing, () => this.onDropped(draggingNode));\n      } else {\n        this.onDropped(draggingNode);\n      }\n    }\n  }\n\n  isInsideValidArea(p) {\n    let targetRect;\n    const targetGraph = this.targetGraph;\n    const targetScroller = this.targetScroller;\n\n    if (targetScroller) {\n      if (targetScroller.options.autoResize) {\n        targetRect = this.getDropArea(targetScroller.container);\n      } else {\n        const outter = this.getDropArea(targetScroller.container);\n        targetRect = this.getDropArea(targetGraph.container).intersectsWithRect(outter);\n      }\n    } else {\n      targetRect = this.getDropArea(targetGraph.container);\n    }\n\n    return targetRect && targetRect.containsPoint(p);\n  }\n\n  getDropArea(elem) {\n    const $elem = this.$(elem);\n    const offset = $elem.offset();\n    const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n    const scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;\n    return Rectangle.create({\n      x: offset.left + parseInt($elem.css('border-left-width'), 10) - scrollLeft,\n      y: offset.top + parseInt($elem.css('border-top-width'), 10) - scrollTop,\n      width: $elem.innerWidth(),\n      height: $elem.innerHeight()\n    });\n  }\n\n  drop(draggingNode, pos) {\n    if (this.isInsideValidArea(pos)) {\n      const targetGraph = this.targetGraph;\n      const targetModel = targetGraph.model;\n      const local = targetGraph.clientToLocal(pos);\n      const sourceNode = this.sourceNode;\n      const droppingNode = this.options.getDropNode(draggingNode, {\n        sourceNode,\n        draggingNode,\n        targetGraph: this.targetGraph,\n        draggingGraph: this.draggingGraph\n      });\n      const bbox = droppingNode.getBBox();\n      local.x += bbox.x - bbox.width / 2;\n      local.y += bbox.y - bbox.height / 2;\n      const gridSize = this.snapOffset ? 1 : targetGraph.getGridSize();\n      droppingNode.position(Util.snapToGrid(local.x, gridSize), Util.snapToGrid(local.y, gridSize));\n      droppingNode.removeZIndex();\n      const validateNode = this.options.validateNode;\n      const ret = validateNode ? validateNode(droppingNode, {\n        sourceNode,\n        draggingNode,\n        droppingNode,\n        targetGraph,\n        draggingGraph: this.draggingGraph\n      }) : true;\n\n      if (typeof ret === 'boolean') {\n        if (ret) {\n          targetModel.addCell(droppingNode, {\n            stencil: this.cid\n          });\n          return droppingNode;\n        }\n\n        return null;\n      }\n\n      return FunctionExt.toDeferredBoolean(ret).then(valid => {\n        if (valid) {\n          targetModel.addCell(droppingNode, {\n            stencil: this.cid\n          });\n          return droppingNode;\n        }\n\n        return null;\n      });\n    }\n\n    return null;\n  }\n\n  onRemove() {\n    if (this.draggingGraph) {\n      this.draggingGraph.view.remove();\n      this.draggingGraph.dispose();\n    }\n  }\n\n  dispose() {\n    this.remove();\n  }\n\n}\n\n__decorate([View.dispose()], Dnd.prototype, \"dispose\", null);\n\n(function (Dnd) {\n  Dnd.defaults = {\n    animation: false,\n    getDragNode: sourceNode => sourceNode.clone(),\n    getDropNode: draggingNode => draggingNode.clone()\n  };\n  Dnd.documentEvents = {\n    mousemove: 'onDragging',\n    touchmove: 'onDragging',\n    mouseup: 'onDragEnd',\n    touchend: 'onDragEnd',\n    touchcancel: 'onDragEnd'\n  };\n})(Dnd || (Dnd = {}));","map":{"version":3,"sources":["../../../src/addon/dnd/index.ts"],"names":[],"mappings":";;;;;;;;AAAA,SAAS,IAAT,QAAqB,cAArB;AACA,SAAS,WAAT,QAA4B,YAA5B;AACA,SAAS,SAAT,QAAiC,gBAAjC;AAGA,SAAS,IAAT,QAAqB,iBAArB;AAEA,SAAS,KAAT,QAAsB,mBAAtB;AAIA,OAAM,MAAO,GAAP,SAAmB,IAAnB,CAAuB;AAiC3B,EAAA,WAAA,CAAY,OAAZ,EAAwE;AACtE;AAEA,SAAK,OAAL,GAAe,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACV,GAAG,CAAC,QADM,CAAA,EAEV,OAFU,CAAf;AAKA,SAAK,SAAL,GAAiB,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAjB;AACA,SAAK,UAAL,GAAkB,KAAK,CAAL,CAAO,KAAK,SAAZ,EAAuB,QAAvB,CAChB,KAAK,eAAL,CAAqB,YAArB,CADgB,CAAlB;AAIA,SAAK,aAAL,GAAqB,IAAI,KAAJ,CAAS,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACzB,KAAK,OAAL,CAAa,oBADY,CAAA,EACQ;AACpC,MAAA,SAAS,EAAE,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CADyB;AAEpC,MAAA,KAAK,EAAE,CAF6B;AAGpC,MAAA,MAAM,EAAE;AAH4B,KADR,CAAT,CAArB;AAOA,SAAK,UAAL,CAAgB,MAAhB,CAAuB,KAAK,aAAL,CAAmB,SAA1C;AACD;;AAvC2B,MAAd,cAAc,GAAA;AAC1B,UAAM,MAAM,GAAG,KAAK,OAAL,CAAa,MAA5B;AACA,WAAO,KAAK,CAAC,OAAN,CAAc,MAAd,IAAwB,MAAM,CAAC,QAAP,CAAgB,MAAxC,GAAiD,MAAxD;AACD;;AAEwB,MAAX,WAAW,GAAA;AACvB,UAAM,MAAM,GAAG,KAAK,OAAL,CAAa,MAA5B;AACA,WAAO,KAAK,CAAC,OAAN,CAAc,MAAd,IAAwB,MAAxB,GAAiC,MAAM,CAAC,KAA/C;AACD;;AAEwB,MAAX,WAAW,GAAA;AACvB,WAAO,KAAK,WAAL,CAAiB,KAAxB;AACD;;AAEqB,MAAR,QAAQ,GAAA;AACpB,WAAO,KAAK,WAAL,CAAiB,QAAjB,CAA0B,MAAjC;AACD;;AAyBD,EAAA,KAAK,CAAC,IAAD,EAAa,GAAb,EAAoD;AACvD,UAAM,CAAC,GAAG,GAAV;AAEA,IAAA,CAAC,CAAC,cAAF;AAEA,SAAK,WAAL,CAAiB,UAAjB,CAA4B,KAA5B;AACA,SAAK,UAAL,CACG,QADH,CACY,UADZ,EAEG,QAFH,CAEY,KAAK,OAAL,CAAa,eAAb,IAAgC,QAAQ,CAAC,IAFrD;AAIA,SAAK,UAAL,GAAkB,IAAlB;AACA,SAAK,eAAL,CAAqB,IAArB,EAA2B,CAAC,CAAC,OAA7B,EAAsC,CAAC,CAAC,OAAxC;AAEA,UAAM,KAAK,GAAG,KAAK,kBAAL,CAAwB,CAAC,CAAC,OAA1B,EAAmC,CAAC,CAAC,OAArC,CAAd;;AAEA,QAAI,KAAK,iBAAL,EAAJ,EAA8B;AAC5B,WAAK,QAAL,CAAc,mBAAd,CAAkC;AAChC,QAAA,CADgC;AAEhC,QAAA,IAFgC;AAGhC,QAAA,IAAI,EAAE,IAH0B;AAIhC,QAAA,IAAI,EAAE,KAAK,YAJqB;AAKhC,QAAA,CAAC,EAAE,KAAK,CAAC,CALuB;AAMhC,QAAA,CAAC,EAAE,KAAK,CAAC;AANuB,OAAlC;AAQA,WAAK,YAAL,CAAmB,EAAnB,CAAsB,iBAAtB,EAAyC,KAAK,IAA9C,EAAoD,IAApD;AACD;;AAED,SAAK,sBAAL,CAA4B,GAAG,CAAC,cAAhC,EAAgD,CAAC,CAAC,IAAlD;AACD;;AAES,EAAA,iBAAiB,GAAA;AACzB,WAAO,KAAK,QAAL,IAAiB,CAAC,KAAK,QAAL,CAAc,QAAvC;AACD;;AAES,EAAA,eAAe,CACvB,UADuB,EAEvB,OAFuB,EAGvB,OAHuB,EAGR;AAEf,UAAM,aAAa,GAAG,KAAK,aAA3B;AACA,UAAM,aAAa,GAAG,aAAa,CAAC,KAApC;AACA,UAAM,YAAY,GAAG,KAAK,OAAL,CAAa,WAAb,CAAyB,UAAzB,EAAqC;AACxD,MAAA,UADwD;AAExD,MAAA,aAFwD;AAGxD,MAAA,WAAW,EAAE,KAAK;AAHsC,KAArC,CAArB;AAMA,IAAA,YAAY,CAAC,QAAb,CAAsB,CAAtB,EAAyB,CAAzB;AAEA,QAAI,OAAO,GAAG,CAAd;;AACA,QAAI,KAAK,iBAAL,EAAJ,EAA8B;AAC5B,MAAA,OAAO,IAAI,KAAK,QAAL,CAAc,OAAd,CAAsB,SAAtB,IAAmC,CAA9C;AACD;;AAED,QAAI,KAAK,iBAAL,MAA4B,KAAK,OAAL,CAAa,MAA7C,EAAqD;AACnD,YAAM,KAAK,GAAG,KAAK,WAAL,CAAiB,SAAjB,CAA2B,QAA3B,EAAd;AACA,MAAA,aAAa,CAAC,KAAd,CAAoB,KAAK,CAAC,EAA1B,EAA8B,KAAK,CAAC,EAApC;AACA,MAAA,OAAO,IAAI,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,EAAf,EAAmB,KAAK,CAAC,EAAzB,CAAX;AACD,KAJD,MAIO;AACL,MAAA,aAAa,CAAC,KAAd,CAAoB,CAApB,EAAuB,CAAvB;AACD;;AAED,SAAK,aAAL;;AAEA,QAAI,KAAK,OAAL,CAAa,SAAjB,EAA4B;AAC1B,WAAK,UAAL,CAAgB,IAAhB,CAAqB,IAArB,EAA2B,IAA3B;AACD;;AAED,IAAA,aAAa,CAAC,UAAd,CAAyB,CAAC,YAAD,CAAzB;AAEA,UAAM,YAAY,GAAG,aAAa,CAAC,cAAd,CAA6B,YAA7B,CAArB;AACA,IAAA,YAAY,CAAC,gBAAb;AACA,IAAA,YAAY,CAAC,IAAb,CAAkB,GAAlB,CAAsB,SAAtB;AACA,IAAA,aAAa,CAAC,YAAd,CAA2B;AACzB,MAAA,OADyB;AAEzB,MAAA,cAAc,EAAE;AAFS,KAA3B;AAKA,UAAM,IAAI,GAAG,YAAY,CAAC,OAAb,EAAb;AACA,SAAK,YAAL,GAAoB,YAAY,CAAC,OAAb,CAAqB;AAAE,MAAA,eAAe,EAAE;AAAnB,KAArB,CAApB;AACA,SAAK,KAAL,GAAa,KAAK,YAAL,CAAkB,UAAlB,GAA+B,IAA/B,CAAoC,IAAI,CAAC,UAAL,EAApC,CAAb;AACA,SAAK,YAAL,GAAoB,YAApB;AACA,SAAK,YAAL,GAAoB,YAApB;AACA,SAAK,YAAL,GAAoB,YAAY,CAAC,OAAb,EAApB;AACA,SAAK,OAAL,GAAe,OAAf;AACA,SAAK,YAAL,GAAoB,KAAK,mBAAL,CAAyB,OAAzB,EAAkC,OAAlC,CAApB;AACD;;AAES,EAAA,mBAAmB,CAAC,OAAD,EAAkB,OAAlB,EAAiC;AAC5D,UAAM,SAAS,GACb,QAAQ,CAAC,IAAT,CAAc,SAAd,IAA2B,QAAQ,CAAC,eAAT,CAAyB,SADtD;AAEA,UAAM,KAAK,GAAG,KAAK,KAAnB;AACA,UAAM,QAAQ,GAAG,KAAK,YAAtB;AACA,UAAM,OAAO,GAAG,KAAK,OAAL,IAAgB,CAAhC;AACA,UAAM,MAAM,GAAG;AACb,MAAA,IAAI,EAAE,OAAO,GAAG,KAAK,CAAC,CAAhB,GAAoB,QAAQ,CAAC,KAAT,GAAiB,CAArC,GAAyC,OADlC;AAEb,MAAA,GAAG,EAAE,OAAO,GAAG,KAAK,CAAC,CAAhB,GAAoB,QAAQ,CAAC,MAAT,GAAkB,CAAtC,GAA0C,OAA1C,GAAoD;AAF5C,KAAf;;AAKA,QAAI,KAAK,aAAT,EAAwB;AACtB,WAAK,UAAL,CAAgB,MAAhB,CAAuB,MAAvB;AACD;;AAED,WAAO,MAAP;AACD;;AAES,EAAA,kBAAkB,CAAC,CAAD,EAAY,CAAZ,EAAqB;AAC/C,UAAM,KAAK,GAAG,KAAK,WAAL,CAAiB,aAAjB,CAA+B,CAA/B,EAAkC,CAAlC,CAAd;AACA,UAAM,IAAI,GAAG,KAAK,YAAlB;AACA,IAAA,KAAK,CAAC,CAAN,IAAW,IAAI,CAAC,KAAL,GAAa,CAAxB;AACA,IAAA,KAAK,CAAC,CAAN,IAAW,IAAI,CAAC,MAAL,GAAc,CAAzB;AACA,SAAK,YAAL,CAAmB,QAAnB,CAA4B,KAAK,CAAC,CAAlC,EAAqC,KAAK,CAAC,CAA3C;AACA,WAAO,KAAP;AACD;;AAES,EAAA,IAAI,OAIsB;AAAA,QAJrB;AACb,MAAA,IADa;AAEb,MAAA,OAFa;AAGb,MAAA;AAHa,KAIqB;AAClC,UAAM,IAAI,GAAG,IAAb;;AACA,QAAI,OAAO,CAAC,OAAZ,EAAqB;AACnB,YAAM,IAAI,GAAG,KAAK,YAAlB;AACA,MAAA,IAAI,CAAC,QAAL,CAAc,IAAI,CAAC,CAAL,GAAS,OAAO,CAAC,EAA/B,EAAmC,IAAI,CAAC,CAAL,GAAS,OAAO,CAAC,EAApD,EAAwD;AAAE,QAAA,MAAM,EAAE;AAAV,OAAxD;AACA,WAAK,YAAL,CAAmB,SAAnB;AACA,MAAA,IAAI,CAAC,QAAL,CAAc,OAAQ,CAAC,CAAvB,EAA0B,OAAQ,CAAC,CAAnC,EAAsC;AAAE,QAAA,MAAM,EAAE;AAAV,OAAtC;AAEA,WAAK,UAAL,GAAkB;AAChB,QAAA,CAAC,EAAE,OAAO,CAAC,EADK;AAEhB,QAAA,CAAC,EAAE,OAAO,CAAC;AAFK,OAAlB;AAID,KAVD,MAUO;AACL,WAAK,UAAL,GAAkB,IAAlB;AACD;AACF;;AAES,EAAA,UAAU,CAAC,GAAD,EAA2B;AAC7C,UAAM,YAAY,GAAG,KAAK,YAA1B;;AACA,QAAI,YAAJ,EAAkB;AAChB,MAAA,GAAG,CAAC,cAAJ;AACA,YAAM,CAAC,GAAG,KAAK,cAAL,CAAoB,GAApB,CAAV;AACA,YAAM,OAAO,GAAG,CAAC,CAAC,OAAlB;AACA,YAAM,OAAO,GAAG,CAAC,CAAC,OAAlB;AAEA,WAAK,mBAAL,CAAyB,OAAzB,EAAkC,OAAlC;AACA,YAAM,KAAK,GAAG,KAAK,kBAAL,CAAwB,OAAxB,EAAiC,OAAjC,CAAd;AACA,YAAM,aAAa,GAAG,KAAK,WAAL,CAAiB,OAAjB,CAAyB,SAAzB,CAAmC,OAAzD;AACA,YAAM,WAAW,GACf,CAAC,aAAa,IAAI,KAAK,iBAAL,EAAlB,KACA,KAAK,iBAAL,CAAuB;AACrB,QAAA,CAAC,EAAE,OADkB;AAErB,QAAA,CAAC,EAAE;AAFkB,OAAvB,CAFF;;AAOA,UAAI,aAAJ,EAAmB;AACjB,QAAA,YAAY,CAAC,YAAb,CAA0B,CAA1B,EAA6B;AAC3B,UAAA,KAAK,EAAE,KAAK,WADe;AAE3B,UAAA,kBAAkB,EAAE,KAAK;AAFE,SAA7B;AAIA,cAAM,IAAI,GAAG,YAAY,CAAC,YAAb,CAA+B,CAA/B,CAAb;;AACA,YAAI,WAAJ,EAAiB;AACf,UAAA,YAAY,CAAC,gBAAb,CAA8B,CAA9B,EAAiC,IAAjC;AACD,SAFD,MAEO;AACL,UAAA,YAAY,CAAC,cAAb,CAA4B,IAA5B;AACD;;AACD,aAAK,kBAAL,GAA0B,IAAI,CAAC,kBAA/B;AACD,OA5Be,CA8BhB;;;AACA,UAAI,KAAK,iBAAL,EAAJ,EAA8B;AAC5B,YAAI,WAAJ,EAAiB;AACf,eAAK,QAAL,CAAc,YAAd,CAA2B;AACzB,YAAA,CADyB;AAEzB,YAAA,IAAI,EAAE,YAFmB;AAGzB,YAAA,CAAC,EAAE,KAAK,CAAC,CAHgB;AAIzB,YAAA,CAAC,EAAE,KAAK,CAAC;AAJgB,WAA3B;AAMD,SAPD,MAOO;AACL,eAAK,QAAL,CAAc,IAAd;AACD;AACF;AACF;AACF;;AAES,EAAA,SAAS,CAAC,GAAD,EAAyB;AAC1C,UAAM,YAAY,GAAG,KAAK,YAA1B;;AACA,QAAI,YAAJ,EAAkB;AAChB,YAAM,CAAC,GAAG,KAAK,cAAL,CAAoB,GAApB,CAAV;AACA,YAAM,YAAY,GAAG,KAAK,YAA1B;AACA,YAAM,YAAY,GAAG,KAAK,YAA1B;AACA,YAAM,UAAU,GAAG,KAAK,UAAxB;AACA,UAAI,CAAC,GAAG,YAAY,CAAC,CAArB;AACA,UAAI,CAAC,GAAG,YAAY,CAAC,CAArB;;AAEA,UAAI,UAAJ,EAAgB;AACd,QAAA,CAAC,IAAI,UAAU,CAAC,CAAhB;AACA,QAAA,CAAC,IAAI,UAAU,CAAC,CAAhB;AACD;;AAED,MAAA,YAAY,CAAC,QAAb,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B;AAAE,QAAA,MAAM,EAAE;AAAV,OAA5B;AAEA,YAAM,GAAG,GAAG,KAAK,IAAL,CAAU,YAAV,EAAwB;AAAE,QAAA,CAAC,EAAE,CAAC,CAAC,OAAP;AAAgB,QAAA,CAAC,EAAE,CAAC,CAAC;AAArB,OAAxB,CAAZ;;AACA,YAAM,QAAQ,GAAI,IAAD,IAAsB;AACrC,YAAI,IAAJ,EAAU;AACR,eAAK,SAAL,CAAe,YAAf;;AACA,cAAI,KAAK,WAAL,CAAiB,OAAjB,CAAyB,SAAzB,CAAmC,OAAnC,IAA8C,YAAlD,EAAgE;AAC9D,YAAA,YAAY,CAAC,YAAb,CAA0B,CAA1B,EAA6B;AAC3B,cAAA,IAAI,EAAE,IADqB;AAE3B,cAAA,KAAK,EAAE,KAAK,WAFe;AAG3B,cAAA,kBAAkB,EAAE,KAAK;AAHE,aAA7B;AAKA,YAAA,YAAY,CAAC,iBAAb,CAA+B,CAA/B,EAAkC,YAAY,CAAC,YAAb,CAA+B,CAA/B,CAAlC;AACD;AACF,SAVD,MAUO;AACL,eAAK,aAAL;AACD;;AAED,aAAK,kBAAL,GAA0B,IAA1B;AACA,aAAK,WAAL,CAAiB,SAAjB,CAA2B,KAA3B;AACD,OAjBD;;AAmBA,UAAI,WAAW,CAAC,OAAZ,CAAoB,GAApB,CAAJ,EAA8B;AAC5B;AACA,aAAK,wBAAL;AACA,QAAA,GAAG,CAAC,IAAJ,CAAS,QAAT,EAH4B,CAGT;AACpB,OAJD,MAIO;AACL,QAAA,QAAQ,CAAC,GAAD,CAAR;AACD;AACF;AACF;;AAES,EAAA,aAAa,GAAA;AACrB,QAAI,KAAK,YAAT,EAAuB;AACrB,WAAK,UAAL,GAAkB,IAAlB;AACA,WAAK,YAAL,CAAkB,MAAlB;AACA,WAAK,YAAL,GAAoB,IAApB;AACA,WAAK,YAAL,GAAoB,IAApB;AACA,WAAK,KAAL,GAAa,IAAb;AACA,WAAK,OAAL,GAAe,IAAf;AACA,WAAK,UAAL,GAAkB,IAAlB;AACA,WAAK,YAAL,GAAoB,IAApB;AACA,WAAK,wBAAL;AACD;AACF;;AAES,EAAA,SAAS,CAAC,YAAD,EAAmB;AACpC,QAAI,KAAK,YAAL,KAAsB,YAA1B,EAAwC;AACtC,WAAK,aAAL;AACA,WAAK,UAAL,CAAgB,WAAhB,CAA4B,UAA5B,EAAwC,MAAxC;AACD;AACF;;AAES,EAAA,aAAa,GAAA;AACrB,UAAM,YAAY,GAAG,KAAK,YAA1B;;AACA,QAAI,YAAJ,EAAkB;AAChB,YAAM,IAAI,GAAG,KAAK,OAAL,CAAa,SAA1B;;AACA,UAAI,IAAJ,EAAU;AACR,cAAM,QAAQ,GAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,IAAI,CAAC,QAAlC,IAA+C,GAAhE;AACA,cAAM,MAAM,GAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,IAAI,CAAC,MAAlC,IAA6C,OAA5D;AAEA,aAAK,YAAL,GAAoB,IAApB;AAEA,aAAK,UAAL,CAAgB,OAAhB,CAAwB,KAAK,YAA7B,EAA4C,QAA5C,EAAsD,MAAtD,EAA8D,MAC5D,KAAK,SAAL,CAAe,YAAf,CADF;AAGD,OATD,MASO;AACL,aAAK,SAAL,CAAe,YAAf;AACD;AACF;AACF;;AAES,EAAA,iBAAiB,CAAC,CAAD,EAAmB;AAC5C,QAAI,UAAJ;AACA,UAAM,WAAW,GAAG,KAAK,WAAzB;AACA,UAAM,cAAc,GAAG,KAAK,cAA5B;;AAEA,QAAI,cAAJ,EAAoB;AAClB,UAAI,cAAc,CAAC,OAAf,CAAuB,UAA3B,EAAuC;AACrC,QAAA,UAAU,GAAG,KAAK,WAAL,CAAiB,cAAc,CAAC,SAAhC,CAAb;AACD,OAFD,MAEO;AACL,cAAM,MAAM,GAAG,KAAK,WAAL,CAAiB,cAAc,CAAC,SAAhC,CAAf;AACA,QAAA,UAAU,GAAG,KAAK,WAAL,CAAiB,WAAW,CAAC,SAA7B,EAAwC,kBAAxC,CACX,MADW,CAAb;AAGD;AACF,KATD,MASO;AACL,MAAA,UAAU,GAAG,KAAK,WAAL,CAAiB,WAAW,CAAC,SAA7B,CAAb;AACD;;AAED,WAAO,UAAU,IAAI,UAAU,CAAC,aAAX,CAAyB,CAAzB,CAArB;AACD;;AAES,EAAA,WAAW,CAAC,IAAD,EAAc;AACjC,UAAM,KAAK,GAAG,KAAK,CAAL,CAAO,IAAP,CAAd;AACA,UAAM,MAAM,GAAG,KAAK,CAAC,MAAN,EAAf;AACA,UAAM,SAAS,GACb,QAAQ,CAAC,IAAT,CAAc,SAAd,IAA2B,QAAQ,CAAC,eAAT,CAAyB,SADtD;AAEA,UAAM,UAAU,GACd,QAAQ,CAAC,IAAT,CAAc,UAAd,IAA4B,QAAQ,CAAC,eAAT,CAAyB,UADvD;AAGA,WAAO,SAAS,CAAC,MAAV,CAAiB;AACtB,MAAA,CAAC,EACC,MAAM,CAAC,IAAP,GAAc,QAAQ,CAAC,KAAK,CAAC,GAAN,CAAU,mBAAV,CAAD,EAAiC,EAAjC,CAAtB,GAA6D,UAFzC;AAGtB,MAAA,CAAC,EAAE,MAAM,CAAC,GAAP,GAAa,QAAQ,CAAC,KAAK,CAAC,GAAN,CAAU,kBAAV,CAAD,EAAgC,EAAhC,CAArB,GAA2D,SAHxC;AAItB,MAAA,KAAK,EAAE,KAAK,CAAC,UAAN,EAJe;AAKtB,MAAA,MAAM,EAAE,KAAK,CAAC,WAAN;AALc,KAAjB,CAAP;AAOD;;AAES,EAAA,IAAI,CAAC,YAAD,EAAqB,GAArB,EAAyC;AACrD,QAAI,KAAK,iBAAL,CAAuB,GAAvB,CAAJ,EAAiC;AAC/B,YAAM,WAAW,GAAG,KAAK,WAAzB;AACA,YAAM,WAAW,GAAG,WAAW,CAAC,KAAhC;AACA,YAAM,KAAK,GAAG,WAAW,CAAC,aAAZ,CAA0B,GAA1B,CAAd;AACA,YAAM,UAAU,GAAG,KAAK,UAAxB;AACA,YAAM,YAAY,GAAG,KAAK,OAAL,CAAa,WAAb,CAAyB,YAAzB,EAAuC;AAC1D,QAAA,UAD0D;AAE1D,QAAA,YAF0D;AAG1D,QAAA,WAAW,EAAE,KAAK,WAHwC;AAI1D,QAAA,aAAa,EAAE,KAAK;AAJsC,OAAvC,CAArB;AAMA,YAAM,IAAI,GAAG,YAAY,CAAC,OAAb,EAAb;AACA,MAAA,KAAK,CAAC,CAAN,IAAW,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,KAAL,GAAa,CAAjC;AACA,MAAA,KAAK,CAAC,CAAN,IAAW,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,MAAL,GAAc,CAAlC;AACA,YAAM,QAAQ,GAAG,KAAK,UAAL,GAAkB,CAAlB,GAAsB,WAAW,CAAC,WAAZ,EAAvC;AAEA,MAAA,YAAY,CAAC,QAAb,CACE,IAAI,CAAC,UAAL,CAAgB,KAAK,CAAC,CAAtB,EAAyB,QAAzB,CADF,EAEE,IAAI,CAAC,UAAL,CAAgB,KAAK,CAAC,CAAtB,EAAyB,QAAzB,CAFF;AAKA,MAAA,YAAY,CAAC,YAAb;AAEA,YAAM,YAAY,GAAG,KAAK,OAAL,CAAa,YAAlC;AACA,YAAM,GAAG,GAAG,YAAY,GACpB,YAAY,CAAC,YAAD,EAAe;AACzB,QAAA,UADyB;AAEzB,QAAA,YAFyB;AAGzB,QAAA,YAHyB;AAIzB,QAAA,WAJyB;AAKzB,QAAA,aAAa,EAAE,KAAK;AALK,OAAf,CADQ,GAQpB,IARJ;;AAUA,UAAI,OAAO,GAAP,KAAe,SAAnB,EAA8B;AAC5B,YAAI,GAAJ,EAAS;AACP,UAAA,WAAW,CAAC,OAAZ,CAAoB,YAApB,EAAkC;AAAE,YAAA,OAAO,EAAE,KAAK;AAAhB,WAAlC;AACA,iBAAO,YAAP;AACD;;AACD,eAAO,IAAP;AACD;;AAED,aAAO,WAAW,CAAC,iBAAZ,CAA8B,GAA9B,EAAmC,IAAnC,CAAyC,KAAD,IAAU;AACvD,YAAI,KAAJ,EAAW;AACT,UAAA,WAAW,CAAC,OAAZ,CAAoB,YAApB,EAAkC;AAAE,YAAA,OAAO,EAAE,KAAK;AAAhB,WAAlC;AACA,iBAAO,YAAP;AACD;;AACD,eAAO,IAAP;AACD,OANM,CAAP;AAOD;;AAED,WAAO,IAAP;AACD;;AAES,EAAA,QAAQ,GAAA;AAChB,QAAI,KAAK,aAAT,EAAwB;AACtB,WAAK,aAAL,CAAmB,IAAnB,CAAwB,MAAxB;AACA,WAAK,aAAL,CAAmB,OAAnB;AACD;AACF;;AAGD,EAAA,OAAO,GAAA;AACL,SAAK,MAAL;AACD;;AA9a0B;;AA4a3B,UAAA,CAAA,CADC,IAAI,CAAC,OAAL,EACD,CAAA,E,aAAA,E,SAAA,EAEC,IAFD,CAAA;;AAKF,CAAA,UAAiB,GAAjB,EAAoB;AAqCL,EAAA,GAAA,CAAA,QAAA,GAA6B;AACxC,IAAA,SAAS,EAAE,KAD6B;AAExC,IAAA,WAAW,EAAG,UAAD,IAAgB,UAAU,CAAC,KAAX,EAFW;AAGxC,IAAA,WAAW,EAAG,YAAD,IAAkB,YAAY,CAAC,KAAb;AAHS,GAA7B;AAMA,EAAA,GAAA,CAAA,cAAA,GAAiB;AAC5B,IAAA,SAAS,EAAE,YADiB;AAE5B,IAAA,SAAS,EAAE,YAFiB;AAG5B,IAAA,OAAO,EAAE,WAHmB;AAI5B,IAAA,QAAQ,EAAE,WAJkB;AAK5B,IAAA,WAAW,EAAE;AALe,GAAjB;AAOd,CAlDD,EAAiB,GAAG,KAAH,GAAG,GAAA,EAAA,CAApB","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Util } from '../../global';\nimport { FunctionExt } from '../../util';\nimport { Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Graph } from '../../graph/graph';\nexport class Dnd extends View {\n    constructor(options) {\n        super();\n        this.options = Object.assign(Object.assign({}, Dnd.defaults), options);\n        this.container = document.createElement('div');\n        this.$container = this.$(this.container).addClass(this.prefixClassName('widget-dnd'));\n        this.draggingGraph = new Graph(Object.assign(Object.assign({}, this.options.delegateGraphOptions), { container: document.createElement('div'), width: 1, height: 1 }));\n        this.$container.append(this.draggingGraph.container);\n    }\n    get targetScroller() {\n        const target = this.options.target;\n        return Graph.isGraph(target) ? target.scroller.widget : target;\n    }\n    get targetGraph() {\n        const target = this.options.target;\n        return Graph.isGraph(target) ? target : target.graph;\n    }\n    get targetModel() {\n        return this.targetGraph.model;\n    }\n    get snapline() {\n        return this.targetGraph.snapline.widget;\n    }\n    start(node, evt) {\n        const e = evt;\n        e.preventDefault();\n        this.targetModel.startBatch('dnd');\n        this.$container\n            .addClass('dragging')\n            .appendTo(this.options.containerParent || document.body);\n        this.sourceNode = node;\n        this.prepareDragging(node, e.clientX, e.clientY);\n        const local = this.updateNodePosition(e.clientX, e.clientY);\n        if (this.isSnaplineEnabled()) {\n            this.snapline.captureCursorOffset({\n                e,\n                node,\n                cell: node,\n                view: this.draggingView,\n                x: local.x,\n                y: local.y,\n            });\n            this.draggingNode.on('change:position', this.snap, this);\n        }\n        this.delegateDocumentEvents(Dnd.documentEvents, e.data);\n    }\n    isSnaplineEnabled() {\n        return this.snapline && !this.snapline.disabled;\n    }\n    prepareDragging(sourceNode, clientX, clientY) {\n        const draggingGraph = this.draggingGraph;\n        const draggingModel = draggingGraph.model;\n        const draggingNode = this.options.getDragNode(sourceNode, {\n            sourceNode,\n            draggingGraph,\n            targetGraph: this.targetGraph,\n        });\n        draggingNode.position(0, 0);\n        let padding = 5;\n        if (this.isSnaplineEnabled()) {\n            padding += this.snapline.options.tolerance || 0;\n        }\n        if (this.isSnaplineEnabled() || this.options.scaled) {\n            const scale = this.targetGraph.transform.getScale();\n            draggingGraph.scale(scale.sx, scale.sy);\n            padding *= Math.max(scale.sx, scale.sy);\n        }\n        else {\n            draggingGraph.scale(1, 1);\n        }\n        this.clearDragging();\n        if (this.options.animation) {\n            this.$container.stop(true, true);\n        }\n        draggingModel.resetCells([draggingNode]);\n        const delegateView = draggingGraph.findViewByCell(draggingNode);\n        delegateView.undelegateEvents();\n        delegateView.cell.off('changed');\n        draggingGraph.fitToContent({\n            padding,\n            allowNewOrigin: 'any',\n        });\n        const bbox = delegateView.getBBox();\n        this.geometryBBox = delegateView.getBBox({ useCellGeometry: true });\n        this.delta = this.geometryBBox.getTopLeft().diff(bbox.getTopLeft());\n        this.draggingNode = draggingNode;\n        this.draggingView = delegateView;\n        this.draggingBBox = draggingNode.getBBox();\n        this.padding = padding;\n        this.originOffset = this.updateGraphPosition(clientX, clientY);\n    }\n    updateGraphPosition(clientX, clientY) {\n        const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n        const delta = this.delta;\n        const nodeBBox = this.geometryBBox;\n        const padding = this.padding || 5;\n        const offset = {\n            left: clientX - delta.x - nodeBBox.width / 2 - padding,\n            top: clientY - delta.y - nodeBBox.height / 2 - padding + scrollTop,\n        };\n        if (this.draggingGraph) {\n            this.$container.offset(offset);\n        }\n        return offset;\n    }\n    updateNodePosition(x, y) {\n        const local = this.targetGraph.clientToLocal(x, y);\n        const bbox = this.draggingBBox;\n        local.x -= bbox.width / 2;\n        local.y -= bbox.height / 2;\n        this.draggingNode.position(local.x, local.y);\n        return local;\n    }\n    snap({ cell, current, options, }) {\n        const node = cell;\n        if (options.snapped) {\n            const bbox = this.draggingBBox;\n            node.position(bbox.x + options.tx, bbox.y + options.ty, { silent: true });\n            this.draggingView.translate();\n            node.position(current.x, current.y, { silent: true });\n            this.snapOffset = {\n                x: options.tx,\n                y: options.ty,\n            };\n        }\n        else {\n            this.snapOffset = null;\n        }\n    }\n    onDragging(evt) {\n        const draggingView = this.draggingView;\n        if (draggingView) {\n            evt.preventDefault();\n            const e = this.normalizeEvent(evt);\n            const clientX = e.clientX;\n            const clientY = e.clientY;\n            this.updateGraphPosition(clientX, clientY);\n            const local = this.updateNodePosition(clientX, clientY);\n            const embeddingMode = this.targetGraph.options.embedding.enabled;\n            const isValidArea = (embeddingMode || this.isSnaplineEnabled()) &&\n                this.isInsideValidArea({\n                    x: clientX,\n                    y: clientY,\n                });\n            if (embeddingMode) {\n                draggingView.setEventData(e, {\n                    graph: this.targetGraph,\n                    candidateEmbedView: this.candidateEmbedView,\n                });\n                const data = draggingView.getEventData(e);\n                if (isValidArea) {\n                    draggingView.processEmbedding(e, data);\n                }\n                else {\n                    draggingView.clearEmbedding(data);\n                }\n                this.candidateEmbedView = data.candidateEmbedView;\n            }\n            // update snapline\n            if (this.isSnaplineEnabled()) {\n                if (isValidArea) {\n                    this.snapline.snapOnMoving({\n                        e,\n                        view: draggingView,\n                        x: local.x,\n                        y: local.y,\n                    });\n                }\n                else {\n                    this.snapline.hide();\n                }\n            }\n        }\n    }\n    onDragEnd(evt) {\n        const draggingNode = this.draggingNode;\n        if (draggingNode) {\n            const e = this.normalizeEvent(evt);\n            const draggingView = this.draggingView;\n            const draggingBBox = this.draggingBBox;\n            const snapOffset = this.snapOffset;\n            let x = draggingBBox.x;\n            let y = draggingBBox.y;\n            if (snapOffset) {\n                x += snapOffset.x;\n                y += snapOffset.y;\n            }\n            draggingNode.position(x, y, { silent: true });\n            const ret = this.drop(draggingNode, { x: e.clientX, y: e.clientY });\n            const callback = (node) => {\n                if (node) {\n                    this.onDropped(draggingNode);\n                    if (this.targetGraph.options.embedding.enabled && draggingView) {\n                        draggingView.setEventData(e, {\n                            cell: node,\n                            graph: this.targetGraph,\n                            candidateEmbedView: this.candidateEmbedView,\n                        });\n                        draggingView.finalizeEmbedding(e, draggingView.getEventData(e));\n                    }\n                }\n                else {\n                    this.onDropInvalid();\n                }\n                this.candidateEmbedView = null;\n                this.targetModel.stopBatch('dnd');\n            };\n            if (FunctionExt.isAsync(ret)) {\n                // stop dragging\n                this.undelegateDocumentEvents();\n                ret.then(callback); // eslint-disable-line\n            }\n            else {\n                callback(ret);\n            }\n        }\n    }\n    clearDragging() {\n        if (this.draggingNode) {\n            this.sourceNode = null;\n            this.draggingNode.remove();\n            this.draggingNode = null;\n            this.draggingView = null;\n            this.delta = null;\n            this.padding = null;\n            this.snapOffset = null;\n            this.originOffset = null;\n            this.undelegateDocumentEvents();\n        }\n    }\n    onDropped(draggingNode) {\n        if (this.draggingNode === draggingNode) {\n            this.clearDragging();\n            this.$container.removeClass('dragging').remove();\n        }\n    }\n    onDropInvalid() {\n        const draggingNode = this.draggingNode;\n        if (draggingNode) {\n            const anim = this.options.animation;\n            if (anim) {\n                const duration = (typeof anim === 'object' && anim.duration) || 150;\n                const easing = (typeof anim === 'object' && anim.easing) || 'swing';\n                this.draggingView = null;\n                this.$container.animate(this.originOffset, duration, easing, () => this.onDropped(draggingNode));\n            }\n            else {\n                this.onDropped(draggingNode);\n            }\n        }\n    }\n    isInsideValidArea(p) {\n        let targetRect;\n        const targetGraph = this.targetGraph;\n        const targetScroller = this.targetScroller;\n        if (targetScroller) {\n            if (targetScroller.options.autoResize) {\n                targetRect = this.getDropArea(targetScroller.container);\n            }\n            else {\n                const outter = this.getDropArea(targetScroller.container);\n                targetRect = this.getDropArea(targetGraph.container).intersectsWithRect(outter);\n            }\n        }\n        else {\n            targetRect = this.getDropArea(targetGraph.container);\n        }\n        return targetRect && targetRect.containsPoint(p);\n    }\n    getDropArea(elem) {\n        const $elem = this.$(elem);\n        const offset = $elem.offset();\n        const scrollTop = document.body.scrollTop || document.documentElement.scrollTop;\n        const scrollLeft = document.body.scrollLeft || document.documentElement.scrollLeft;\n        return Rectangle.create({\n            x: offset.left + parseInt($elem.css('border-left-width'), 10) - scrollLeft,\n            y: offset.top + parseInt($elem.css('border-top-width'), 10) - scrollTop,\n            width: $elem.innerWidth(),\n            height: $elem.innerHeight(),\n        });\n    }\n    drop(draggingNode, pos) {\n        if (this.isInsideValidArea(pos)) {\n            const targetGraph = this.targetGraph;\n            const targetModel = targetGraph.model;\n            const local = targetGraph.clientToLocal(pos);\n            const sourceNode = this.sourceNode;\n            const droppingNode = this.options.getDropNode(draggingNode, {\n                sourceNode,\n                draggingNode,\n                targetGraph: this.targetGraph,\n                draggingGraph: this.draggingGraph,\n            });\n            const bbox = droppingNode.getBBox();\n            local.x += bbox.x - bbox.width / 2;\n            local.y += bbox.y - bbox.height / 2;\n            const gridSize = this.snapOffset ? 1 : targetGraph.getGridSize();\n            droppingNode.position(Util.snapToGrid(local.x, gridSize), Util.snapToGrid(local.y, gridSize));\n            droppingNode.removeZIndex();\n            const validateNode = this.options.validateNode;\n            const ret = validateNode\n                ? validateNode(droppingNode, {\n                    sourceNode,\n                    draggingNode,\n                    droppingNode,\n                    targetGraph,\n                    draggingGraph: this.draggingGraph,\n                })\n                : true;\n            if (typeof ret === 'boolean') {\n                if (ret) {\n                    targetModel.addCell(droppingNode, { stencil: this.cid });\n                    return droppingNode;\n                }\n                return null;\n            }\n            return FunctionExt.toDeferredBoolean(ret).then((valid) => {\n                if (valid) {\n                    targetModel.addCell(droppingNode, { stencil: this.cid });\n                    return droppingNode;\n                }\n                return null;\n            });\n        }\n        return null;\n    }\n    onRemove() {\n        if (this.draggingGraph) {\n            this.draggingGraph.view.remove();\n            this.draggingGraph.dispose();\n        }\n    }\n    dispose() {\n        this.remove();\n    }\n}\n__decorate([\n    View.dispose()\n], Dnd.prototype, \"dispose\", null);\n(function (Dnd) {\n    Dnd.defaults = {\n        animation: false,\n        getDragNode: (sourceNode) => sourceNode.clone(),\n        getDropNode: (draggingNode) => draggingNode.clone(),\n    };\n    Dnd.documentEvents = {\n        mousemove: 'onDragging',\n        touchmove: 'onDragging',\n        mouseup: 'onDragEnd',\n        touchend: 'onDragEnd',\n        touchcancel: 'onDragEnd',\n    };\n})(Dnd || (Dnd = {}));\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}