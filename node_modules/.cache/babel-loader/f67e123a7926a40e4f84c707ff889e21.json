{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { mat4, vec3 } from 'gl-matrix';\nexport var EARTH_RADIUS = 100;\nexport var EARTH_SEGMENTS = 36;\nexport var EARTH_RADIUS_OUTER = 40;\n\nfunction torad(deg) {\n  return deg / 180 * Math.acos(-1);\n}\n\nexport function lglt2xyz(lnglat) {\n  var lng = torad(lnglat[0]) + Math.PI / 2;\n  var lat = torad(lnglat[1]);\n  var radius = EARTH_RADIUS + Math.random() * 0.4;\n  var z = radius * Math.cos(lat) * Math.cos(lng);\n  var x = radius * Math.cos(lat) * Math.sin(lng);\n  var y = radius * Math.sin(lat);\n  return [x, y, z];\n}\nexport function primitiveSphere(radius, opt) {\n  var matRotY = mat4.create();\n  var matRotZ = mat4.create();\n  var up = vec3.fromValues(0, 1, 0);\n  var tmpVec3 = vec3.fromValues(0, 0, 0);\n  opt = opt || {};\n  radius = typeof radius !== 'undefined' ? radius : 1;\n  var segments = typeof opt.segments !== 'undefined' ? opt.segments : 32;\n  var totalZRotationSteps = 2 + segments;\n  var totalYRotationSteps = 2 * totalZRotationSteps;\n  var indices = [];\n  var indicesArr = [];\n  var positions = [];\n  var positionsArr = [];\n  var normalArr = [];\n  var uvs = [];\n\n  for (var zRotationStep = 0; zRotationStep <= totalZRotationSteps; zRotationStep++) {\n    var normalizedZ = zRotationStep / totalZRotationSteps;\n    var angleZ = normalizedZ * Math.PI;\n\n    for (var yRotationStep = 0; yRotationStep <= totalYRotationSteps; yRotationStep++) {\n      var normalizedY = yRotationStep / totalYRotationSteps;\n      var angleY = normalizedY * Math.PI * 2;\n      mat4.identity(matRotZ);\n      mat4.rotateZ(matRotZ, matRotZ, -angleZ);\n      mat4.identity(matRotY);\n      mat4.rotateY(matRotY, matRotY, angleY);\n      vec3.transformMat4(tmpVec3, up, matRotZ);\n      vec3.transformMat4(tmpVec3, tmpVec3, matRotY);\n      vec3.scale(tmpVec3, tmpVec3, -radius);\n      positions.push(tmpVec3.slice());\n      positionsArr.push.apply(positionsArr, _toConsumableArray(tmpVec3.slice()));\n      vec3.normalize(tmpVec3, tmpVec3);\n      normalArr.push.apply(normalArr, _toConsumableArray(tmpVec3.slice()));\n      uvs.push([normalizedY, 1 - normalizedZ]);\n      positionsArr.push(normalizedY, 1 - normalizedZ);\n    }\n\n    if (zRotationStep > 0) {\n      var verticesCount = positions.length;\n      var firstIndex = verticesCount - 2 * (totalYRotationSteps + 1);\n\n      for (; firstIndex + totalYRotationSteps + 2 < verticesCount; firstIndex++) {\n        indices.push([firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1]);\n        indicesArr.push(firstIndex, firstIndex + 1, firstIndex + totalYRotationSteps + 1);\n        indices.push([firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2]);\n        indicesArr.push(firstIndex + totalYRotationSteps + 1, firstIndex + 1, firstIndex + totalYRotationSteps + 2);\n      }\n    }\n  }\n\n  return {\n    cells: indices,\n    positions: positions,\n    uvs: uvs,\n    positionsArr: positionsArr,\n    indicesArr: indicesArr,\n    normalArr: normalArr\n  };\n}","map":{"version":3,"sources":["../../src/earth/utils.ts"],"names":["EARTH_RADIUS","EARTH_SEGMENTS","EARTH_RADIUS_OUTER","deg","Math","lng","torad","lnglat","lat","radius","z","x","y","matRotY","mat4","matRotZ","up","vec3","tmpVec3","opt","segments","totalZRotationSteps","totalYRotationSteps","indices","indicesArr","positions","positionsArr","normalArr","uvs","zRotationStep","normalizedZ","angleZ","yRotationStep","normalizedY","angleY","verticesCount","firstIndex","cells"],"mappings":"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","sourcesContent":["import { mat4, vec3 } from 'gl-matrix';\n// 该文件专门记录地球模式的数值\n\n// 地球网格半径\nexport const EARTH_RADIUS = 100;\nexport const EARTH_SEGMENTS = 36;\n\nexport const EARTH_RADIUS_OUTER = 40;\n\n/**\n * 角度转弧度\n * @param deg\n * @returns\n */\nfunction torad(deg: number) {\n  return (deg / 180) * Math.acos(-1);\n}\n/**\n * 经纬度转xyz\n * @param longitude 经度\n * @param latitude 纬度\n * @param radius 半径\n */\nexport function lglt2xyz(lnglat: [number, number]) {\n  // TODO: + Math.PI/2 是为了对齐坐标\n  const lng = torad(lnglat[0]) + Math.PI / 2;\n  const lat = torad(lnglat[1]);\n\n  // TODO: 手动增加一些偏移，减轻面的冲突\n  const radius = EARTH_RADIUS + Math.random() * 0.4;\n\n  const z = radius * Math.cos(lat) * Math.cos(lng);\n  const x = radius * Math.cos(lat) * Math.sin(lng);\n  const y = radius * Math.sin(lat);\n  return [x, y, z];\n}\n\n/**\n * 构建地球球体网格\n * @param radius\n * @param opt\n * @returns\n */\nexport function primitiveSphere(\n  radius: number,\n  opt: {\n    segments: number;\n  },\n) {\n  const matRotY = mat4.create();\n  const matRotZ = mat4.create();\n  const up = vec3.fromValues(0, 1, 0);\n  const tmpVec3 = vec3.fromValues(0, 0, 0);\n\n  opt = opt || {};\n  radius = typeof radius !== 'undefined' ? radius : 1;\n  const segments = typeof opt.segments !== 'undefined' ? opt.segments : 32;\n\n  const totalZRotationSteps = 2 + segments;\n  const totalYRotationSteps = 2 * totalZRotationSteps;\n\n  const indices = [];\n  const indicesArr = [];\n  const positions = [];\n  const positionsArr = [];\n  const normalArr = [];\n  const uvs = [];\n\n  for (\n    let zRotationStep = 0;\n    zRotationStep <= totalZRotationSteps;\n    zRotationStep++\n  ) {\n    const normalizedZ = zRotationStep / totalZRotationSteps;\n    const angleZ = normalizedZ * Math.PI;\n\n    for (\n      let yRotationStep = 0;\n      yRotationStep <= totalYRotationSteps;\n      yRotationStep++\n    ) {\n      const normalizedY = yRotationStep / totalYRotationSteps;\n      const angleY = normalizedY * Math.PI * 2;\n\n      mat4.identity(matRotZ);\n      mat4.rotateZ(matRotZ, matRotZ, -angleZ);\n\n      mat4.identity(matRotY);\n      mat4.rotateY(matRotY, matRotY, angleY);\n\n      vec3.transformMat4(tmpVec3, up, matRotZ);\n      vec3.transformMat4(tmpVec3, tmpVec3, matRotY);\n\n      vec3.scale(tmpVec3, tmpVec3, -radius);\n\n      positions.push(tmpVec3.slice());\n      positionsArr.push(...tmpVec3.slice());\n\n      vec3.normalize(tmpVec3, tmpVec3);\n      normalArr.push(...tmpVec3.slice());\n\n      uvs.push([normalizedY, 1 - normalizedZ]);\n\n      // position 和 uv 一起存储\n      positionsArr.push(normalizedY, 1 - normalizedZ);\n    }\n\n    if (zRotationStep > 0) {\n      const verticesCount = positions.length;\n      let firstIndex = verticesCount - 2 * (totalYRotationSteps + 1);\n      for (\n        ;\n        firstIndex + totalYRotationSteps + 2 < verticesCount;\n        firstIndex++\n      ) {\n        indices.push([\n          firstIndex,\n          firstIndex + 1,\n          firstIndex + totalYRotationSteps + 1,\n        ]);\n\n        indicesArr.push(\n          firstIndex,\n          firstIndex + 1,\n          firstIndex + totalYRotationSteps + 1,\n        );\n        indices.push([\n          firstIndex + totalYRotationSteps + 1,\n          firstIndex + 1,\n          firstIndex + totalYRotationSteps + 2,\n        ]);\n        indicesArr.push(\n          firstIndex + totalYRotationSteps + 1,\n          firstIndex + 1,\n          firstIndex + totalYRotationSteps + 2,\n        );\n      }\n    }\n  }\n\n  return {\n    cells: indices,\n    positions,\n    uvs,\n    positionsArr,\n    indicesArr,\n    normalArr,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}