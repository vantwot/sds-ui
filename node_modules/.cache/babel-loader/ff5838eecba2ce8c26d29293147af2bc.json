{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Point } from './point';\nimport { Geometry } from './geometry';\nimport { Rectangle } from './rectangle';\nexport var Line = /*#__PURE__*/function (_Geometry, _Symbol$toStringTag) {\n  _inherits(Line, _Geometry);\n\n  var _super = _createSuper(Line);\n\n  function Line(x1, y1, x2, y2) {\n    var _this;\n\n    _classCallCheck(this, Line);\n\n    _this = _super.call(this);\n\n    if (typeof x1 === 'number' && typeof y1 === 'number') {\n      _this.start = new Point(x1, y1);\n      _this.end = new Point(x2, y2);\n    } else {\n      _this.start = Point.create(x1);\n      _this.end = Point.create(y1);\n    }\n\n    return _this;\n  }\n\n  _createClass(Line, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Line.toStringTag;\n    }\n  }, {\n    key: \"center\",\n    get: function get() {\n      return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      return this.center;\n    }\n    /**\n     * Rounds the line to the given `precision`.\n     */\n\n  }, {\n    key: \"round\",\n    value: function round() {\n      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.start.round(precision);\n      this.end.round(precision);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      if (typeof tx === 'number') {\n        this.start.translate(tx, ty);\n        this.end.translate(tx, ty);\n      } else {\n        this.start.translate(tx);\n        this.end.translate(tx);\n      }\n\n      return this;\n    }\n    /**\n     * Rotate the line by `angle` around `origin`.\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.start.rotate(angle, origin);\n      this.end.rotate(angle, origin);\n      return this;\n    }\n    /**\n     * Scale the line by `sx` and `sy` about the given `origin`. If origin is not\n     * specified, the line is scaled around `0,0`.\n     */\n\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      this.start.scale(sx, sy, origin);\n      this.end.scale(sx, sy, origin);\n      return this;\n    }\n    /**\n     * Returns the length of the line.\n     */\n\n  }, {\n    key: \"length\",\n    value: function length() {\n      return Math.sqrt(this.squaredLength());\n    }\n    /**\n     * Useful for distance comparisons in which real length is not necessary\n     * (saves one `Math.sqrt()` operation).\n     */\n\n  }, {\n    key: \"squaredLength\",\n    value: function squaredLength() {\n      var dx = this.start.x - this.end.x;\n      var dy = this.start.y - this.end.y;\n      return dx * dx + dy * dy;\n    }\n    /**\n     * Scale the line so that it has the requested length. The start point of\n     * the line is preserved.\n     */\n\n  }, {\n    key: \"setLength\",\n    value: function setLength(length) {\n      var total = this.length();\n\n      if (!total) {\n        return this;\n      }\n\n      var scale = length / total;\n      return this.scale(scale, scale, this.start);\n    }\n  }, {\n    key: \"parallel\",\n    value: function parallel(distance) {\n      var line = this.clone();\n\n      if (!line.isDifferentiable()) {\n        return line;\n      }\n\n      var start = line.start,\n          end = line.end;\n      var eRef = start.clone().rotate(270, end);\n      var sRef = end.clone().rotate(90, start);\n      start.move(sRef, distance);\n      end.move(eRef, distance);\n      return line;\n    }\n    /**\n     * Returns the vector of the line with length equal to length of the line.\n     */\n\n  }, {\n    key: \"vector\",\n    value: function vector() {\n      return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    }\n    /**\n     * Returns the angle of incline of the line.\n     *\n     * The function returns `NaN` if the start and end endpoints of the line\n     * both lie at the same coordinates(it is impossible to determine the angle\n     * of incline of a line that appears to be a point). The\n     * `line.isDifferentiable()` function may be used in advance to determine\n     * whether the angle of incline can be computed for a given line.\n     */\n\n  }, {\n    key: \"angle\",\n    value: function angle() {\n      var horizontal = new Point(this.start.x + 1, this.start.y);\n      return this.start.angleBetween(this.end, horizontal);\n    }\n    /**\n     * Returns a rectangle that is the bounding box of the line.\n     */\n\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var left = Math.min(this.start.x, this.end.x);\n      var top = Math.min(this.start.y, this.end.y);\n      var right = Math.max(this.start.x, this.end.x);\n      var bottom = Math.max(this.start.y, this.end.y);\n      return new Rectangle(left, top, right - left, bottom - top);\n    }\n    /**\n     * Returns the bearing (cardinal direction) of the line.\n     *\n     * The return value is one of the following strings:\n     * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.\n     *\n     * The function returns 'N' if the two endpoints of the line are coincident.\n     */\n\n  }, {\n    key: \"bearing\",\n    value: function bearing() {\n      return this.start.bearing(this.end);\n    }\n    /**\n     * Returns the point on the line that lies closest to point `p`.\n     */\n\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      return this.pointAt(this.closestPointNormalizedLength(p));\n    }\n    /**\n     * Returns the length of the line up to the point that lies closest to point `p`.\n     */\n\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      return this.closestPointNormalizedLength(p) * this.length();\n    }\n    /**\n     * Returns a line that is tangent to the line at the point that lies closest\n     * to point `p`.\n     */\n\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      return this.tangentAt(this.closestPointNormalizedLength(p));\n    }\n    /**\n     * Returns the normalized length (distance from the start of the line / total\n     * line length) of the line up to the point that lies closest to point.\n     */\n\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      var product = this.vector().dot(new Line(this.start, p).vector());\n      var normalized = Math.min(1, Math.max(0, product / this.squaredLength())); // normalized returns `NaN` if this line has zero length\n\n      if (Number.isNaN(normalized)) {\n        return 0;\n      }\n\n      return normalized;\n    }\n    /**\n     * Returns a point on the line that lies `rate` (normalized length) away from\n     * the beginning of the line.\n     */\n\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      var start = this.start;\n      var end = this.end;\n\n      if (ratio <= 0) {\n        return start.clone();\n      }\n\n      if (ratio >= 1) {\n        return end.clone();\n      }\n\n      return start.lerp(end, ratio);\n    }\n    /**\n     * Returns a point on the line that lies length away from the beginning of\n     * the line.\n     */\n\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      var start = this.start;\n      var end = this.end;\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false; // start calculation from end point\n\n        length = -length; // eslint-disable-line\n      }\n\n      var total = this.length();\n\n      if (length >= total) {\n        return fromStart ? end.clone() : start.clone();\n      }\n\n      var rate = (fromStart ? length : total - length) / total;\n      return this.pointAt(rate);\n    }\n    /**\n     * Divides the line into two lines at the point that lies `rate` (normalized\n     * length) away from the beginning of the line.\n     */\n\n  }, {\n    key: \"divideAt\",\n    value: function divideAt(ratio) {\n      var dividerPoint = this.pointAt(ratio);\n      return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n    }\n    /**\n     * Divides the line into two lines at the point that lies length away from\n     * the beginning of the line.\n     */\n\n  }, {\n    key: \"divideAtLength\",\n    value: function divideAtLength(length) {\n      var dividerPoint = this.pointAtLength(length);\n      return [new Line(this.start, dividerPoint), new Line(dividerPoint, this.end)];\n    }\n    /**\n     * Returns `true` if the point `p` lies on the line. Return `false` otherwise.\n     */\n\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      var start = this.start;\n      var end = this.end; // cross product of 0 indicates that this line and\n      // the vector to `p` are collinear.\n\n      if (start.cross(p, end) !== 0) {\n        return false;\n      }\n\n      var length = this.length();\n\n      if (new Line(start, p).length() > length) {\n        return false;\n      }\n\n      if (new Line(p, end).length() > length) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"intersect\",\n    value: function intersect(shape, options) {\n      var ret = shape.intersectsWithLine(this, options);\n\n      if (ret) {\n        return Array.isArray(ret) ? ret : [ret];\n      }\n\n      return null;\n    }\n    /**\n     * Returns the intersection point of the line with another line. Returns\n     * `null` if no intersection exists.\n     */\n\n  }, {\n    key: \"intersectsWithLine\",\n    value: function intersectsWithLine(line) {\n      var pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n      var pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n      var det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;\n      var deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n      var alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;\n      var beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;\n\n      if (det === 0 || alpha * det < 0 || beta * det < 0) {\n        return null;\n      }\n\n      if (det > 0) {\n        if (alpha > det || beta > det) {\n          return null;\n        }\n      } else if (alpha < det || beta < det) {\n        return null;\n      }\n\n      return new Point(this.start.x + alpha * pt1Dir.x / det, this.start.y + alpha * pt1Dir.y / det);\n    }\n    /**\n     * Returns `true` if a tangent line can be found for the line.\n     *\n     * Tangents cannot be found if both of the line endpoints are coincident\n     * (the line appears to be a point).\n     */\n\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      return !this.start.equals(this.end);\n    }\n    /**\n     * Returns the perpendicular distance between the line and point. The\n     * distance is positive if the point lies to the right of the line, negative\n     * if the point lies to the left of the line, and `0` if the point lies on\n     * the line.\n     */\n\n  }, {\n    key: \"pointOffset\",\n    value: function pointOffset(p) {\n      var ref = Point.clone(p);\n      var start = this.start;\n      var end = this.end;\n      var determinant = (end.x - start.x) * (ref.y - start.y) - (end.y - start.y) * (ref.x - start.x);\n      return determinant / this.length();\n    }\n  }, {\n    key: \"pointSquaredDistance\",\n    value: function pointSquaredDistance(x, y) {\n      var p = Point.create(x, y);\n      return this.closestPoint(p).squaredDistance(p);\n    }\n  }, {\n    key: \"pointDistance\",\n    value: function pointDistance(x, y) {\n      var p = Point.create(x, y);\n      return this.closestPoint(p).distance(p);\n    }\n    /**\n     * Returns a line tangent to the line at point that lies `rate` (normalized\n     * length) away from the beginning of the line.\n     */\n\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      if (!this.isDifferentiable()) {\n        return null;\n      }\n\n      var start = this.start;\n      var end = this.end;\n      var tangentStart = this.pointAt(ratio);\n      var tangentLine = new Line(start, end);\n      tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);\n      return tangentLine;\n    }\n    /**\n     * Returns a line tangent to the line at point that lies `length` away from\n     * the beginning of the line.\n     */\n\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      if (!this.isDifferentiable()) {\n        return null;\n      }\n\n      var start = this.start;\n      var end = this.end;\n      var tangentStart = this.pointAtLength(length);\n      var tangentLine = new Line(start, end);\n      tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);\n      return tangentLine;\n    }\n  }, {\n    key: \"relativeCcw\",\n    value: function relativeCcw(x, y) {\n      var ref = Point.create(x, y);\n      var dx1 = ref.x - this.start.x;\n      var dy1 = ref.y - this.start.y;\n      var dx2 = this.end.x - this.start.x;\n      var dy2 = this.end.y - this.start.y;\n      var ccw = dx1 * dy2 - dy1 * dx2;\n\n      if (ccw === 0) {\n        ccw = dx1 * dx2 + dy1 * dy2;\n\n        if (ccw > 0.0) {\n          dx1 -= dx2;\n          dy1 -= dy2;\n          ccw = dx1 * dx2 + dy1 * dy2;\n\n          if (ccw < 0.0) {\n            ccw = 0.0;\n          }\n        }\n      }\n\n      return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;\n    }\n    /**\n     * Return `true` if the line equals the other line.\n     */\n\n  }, {\n    key: \"equals\",\n    value: function equals(l) {\n      return l != null && this.start.x === l.start.x && this.start.y === l.start.y && this.end.x === l.end.x && this.end.y === l.end.y;\n    }\n    /**\n     * Returns another line which is a clone of the line.\n     */\n\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Line(this.start, this.end);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        start: this.start.toJSON(),\n        end: this.end.toJSON()\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return [this.start.serialize(), this.end.serialize()].join(' ');\n    }\n  }]);\n\n  return Line;\n}(Geometry, Symbol.toStringTag);\n\n(function (Line) {\n  Line.toStringTag = \"X6.Geometry.\".concat(Line.name);\n\n  function isLine(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Line) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var line = instance;\n\n    if ((tag == null || tag === Line.toStringTag) && Point.isPoint(line.start) && Point.isPoint(line.end) && typeof line.vector === 'function' && typeof line.bearing === 'function' && typeof line.parallel === 'function' && typeof line.intersect === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Line.isLine = isLine;\n})(Line || (Line = {}));","map":{"version":3,"sources":["../../src/geometry/line.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Point } from './point';\nimport { Geometry } from './geometry';\nimport { Rectangle } from './rectangle';\nexport class Line extends Geometry {\n    constructor(x1, y1, x2, y2) {\n        super();\n        if (typeof x1 === 'number' && typeof y1 === 'number') {\n            this.start = new Point(x1, y1);\n            this.end = new Point(x2, y2);\n        }\n        else {\n            this.start = Point.create(x1);\n            this.end = Point.create(y1);\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return Line.toStringTag;\n    }\n    get center() {\n        return new Point((this.start.x + this.end.x) / 2, (this.start.y + this.end.y) / 2);\n    }\n    getCenter() {\n        return this.center;\n    }\n    /**\n     * Rounds the line to the given `precision`.\n     */\n    round(precision = 0) {\n        this.start.round(precision);\n        this.end.round(precision);\n        return this;\n    }\n    translate(tx, ty) {\n        if (typeof tx === 'number') {\n            this.start.translate(tx, ty);\n            this.end.translate(tx, ty);\n        }\n        else {\n            this.start.translate(tx);\n            this.end.translate(tx);\n        }\n        return this;\n    }\n    /**\n     * Rotate the line by `angle` around `origin`.\n     */\n    rotate(angle, origin) {\n        this.start.rotate(angle, origin);\n        this.end.rotate(angle, origin);\n        return this;\n    }\n    /**\n     * Scale the line by `sx` and `sy` about the given `origin`. If origin is not\n     * specified, the line is scaled around `0,0`.\n     */\n    scale(sx, sy, origin) {\n        this.start.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    }\n    /**\n     * Returns the length of the line.\n     */\n    length() {\n        return Math.sqrt(this.squaredLength());\n    }\n    /**\n     * Useful for distance comparisons in which real length is not necessary\n     * (saves one `Math.sqrt()` operation).\n     */\n    squaredLength() {\n        const dx = this.start.x - this.end.x;\n        const dy = this.start.y - this.end.y;\n        return dx * dx + dy * dy;\n    }\n    /**\n     * Scale the line so that it has the requested length. The start point of\n     * the line is preserved.\n     */\n    setLength(length) {\n        const total = this.length();\n        if (!total) {\n            return this;\n        }\n        const scale = length / total;\n        return this.scale(scale, scale, this.start);\n    }\n    parallel(distance) {\n        const line = this.clone();\n        if (!line.isDifferentiable()) {\n            return line;\n        }\n        const { start, end } = line;\n        const eRef = start.clone().rotate(270, end);\n        const sRef = end.clone().rotate(90, start);\n        start.move(sRef, distance);\n        end.move(eRef, distance);\n        return line;\n    }\n    /**\n     * Returns the vector of the line with length equal to length of the line.\n     */\n    vector() {\n        return new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n    }\n    /**\n     * Returns the angle of incline of the line.\n     *\n     * The function returns `NaN` if the start and end endpoints of the line\n     * both lie at the same coordinates(it is impossible to determine the angle\n     * of incline of a line that appears to be a point). The\n     * `line.isDifferentiable()` function may be used in advance to determine\n     * whether the angle of incline can be computed for a given line.\n     */\n    angle() {\n        const horizontal = new Point(this.start.x + 1, this.start.y);\n        return this.start.angleBetween(this.end, horizontal);\n    }\n    /**\n     * Returns a rectangle that is the bounding box of the line.\n     */\n    bbox() {\n        const left = Math.min(this.start.x, this.end.x);\n        const top = Math.min(this.start.y, this.end.y);\n        const right = Math.max(this.start.x, this.end.x);\n        const bottom = Math.max(this.start.y, this.end.y);\n        return new Rectangle(left, top, right - left, bottom - top);\n    }\n    /**\n     * Returns the bearing (cardinal direction) of the line.\n     *\n     * The return value is one of the following strings:\n     * 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW' and 'N'.\n     *\n     * The function returns 'N' if the two endpoints of the line are coincident.\n     */\n    bearing() {\n        return this.start.bearing(this.end);\n    }\n    /**\n     * Returns the point on the line that lies closest to point `p`.\n     */\n    closestPoint(p) {\n        return this.pointAt(this.closestPointNormalizedLength(p));\n    }\n    /**\n     * Returns the length of the line up to the point that lies closest to point `p`.\n     */\n    closestPointLength(p) {\n        return this.closestPointNormalizedLength(p) * this.length();\n    }\n    /**\n     * Returns a line that is tangent to the line at the point that lies closest\n     * to point `p`.\n     */\n    closestPointTangent(p) {\n        return this.tangentAt(this.closestPointNormalizedLength(p));\n    }\n    /**\n     * Returns the normalized length (distance from the start of the line / total\n     * line length) of the line up to the point that lies closest to point.\n     */\n    closestPointNormalizedLength(p) {\n        const product = this.vector().dot(new Line(this.start, p).vector());\n        const normalized = Math.min(1, Math.max(0, product / this.squaredLength()));\n        // normalized returns `NaN` if this line has zero length\n        if (Number.isNaN(normalized)) {\n            return 0;\n        }\n        return normalized;\n    }\n    /**\n     * Returns a point on the line that lies `rate` (normalized length) away from\n     * the beginning of the line.\n     */\n    pointAt(ratio) {\n        const start = this.start;\n        const end = this.end;\n        if (ratio <= 0) {\n            return start.clone();\n        }\n        if (ratio >= 1) {\n            return end.clone();\n        }\n        return start.lerp(end, ratio);\n    }\n    /**\n     * Returns a point on the line that lies length away from the beginning of\n     * the line.\n     */\n    pointAtLength(length) {\n        const start = this.start;\n        const end = this.end;\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false; // start calculation from end point\n            length = -length; // eslint-disable-line\n        }\n        const total = this.length();\n        if (length >= total) {\n            return fromStart ? end.clone() : start.clone();\n        }\n        const rate = (fromStart ? length : total - length) / total;\n        return this.pointAt(rate);\n    }\n    /**\n     * Divides the line into two lines at the point that lies `rate` (normalized\n     * length) away from the beginning of the line.\n     */\n    divideAt(ratio) {\n        const dividerPoint = this.pointAt(ratio);\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end),\n        ];\n    }\n    /**\n     * Divides the line into two lines at the point that lies length away from\n     * the beginning of the line.\n     */\n    divideAtLength(length) {\n        const dividerPoint = this.pointAtLength(length);\n        return [\n            new Line(this.start, dividerPoint),\n            new Line(dividerPoint, this.end),\n        ];\n    }\n    /**\n     * Returns `true` if the point `p` lies on the line. Return `false` otherwise.\n     */\n    containsPoint(p) {\n        const start = this.start;\n        const end = this.end;\n        // cross product of 0 indicates that this line and\n        // the vector to `p` are collinear.\n        if (start.cross(p, end) !== 0) {\n            return false;\n        }\n        const length = this.length();\n        if (new Line(start, p).length() > length) {\n            return false;\n        }\n        if (new Line(p, end).length() > length) {\n            return false;\n        }\n        return true;\n    }\n    intersect(shape, options) {\n        const ret = shape.intersectsWithLine(this, options);\n        if (ret) {\n            return Array.isArray(ret) ? ret : [ret];\n        }\n        return null;\n    }\n    /**\n     * Returns the intersection point of the line with another line. Returns\n     * `null` if no intersection exists.\n     */\n    intersectsWithLine(line) {\n        const pt1Dir = new Point(this.end.x - this.start.x, this.end.y - this.start.y);\n        const pt2Dir = new Point(line.end.x - line.start.x, line.end.y - line.start.y);\n        const det = pt1Dir.x * pt2Dir.y - pt1Dir.y * pt2Dir.x;\n        const deltaPt = new Point(line.start.x - this.start.x, line.start.y - this.start.y);\n        const alpha = deltaPt.x * pt2Dir.y - deltaPt.y * pt2Dir.x;\n        const beta = deltaPt.x * pt1Dir.y - deltaPt.y * pt1Dir.x;\n        if (det === 0 || alpha * det < 0 || beta * det < 0) {\n            return null;\n        }\n        if (det > 0) {\n            if (alpha > det || beta > det) {\n                return null;\n            }\n        }\n        else if (alpha < det || beta < det) {\n            return null;\n        }\n        return new Point(this.start.x + (alpha * pt1Dir.x) / det, this.start.y + (alpha * pt1Dir.y) / det);\n    }\n    /**\n     * Returns `true` if a tangent line can be found for the line.\n     *\n     * Tangents cannot be found if both of the line endpoints are coincident\n     * (the line appears to be a point).\n     */\n    isDifferentiable() {\n        return !this.start.equals(this.end);\n    }\n    /**\n     * Returns the perpendicular distance between the line and point. The\n     * distance is positive if the point lies to the right of the line, negative\n     * if the point lies to the left of the line, and `0` if the point lies on\n     * the line.\n     */\n    pointOffset(p) {\n        const ref = Point.clone(p);\n        const start = this.start;\n        const end = this.end;\n        const determinant = (end.x - start.x) * (ref.y - start.y) -\n            (end.y - start.y) * (ref.x - start.x);\n        return determinant / this.length();\n    }\n    pointSquaredDistance(x, y) {\n        const p = Point.create(x, y);\n        return this.closestPoint(p).squaredDistance(p);\n    }\n    pointDistance(x, y) {\n        const p = Point.create(x, y);\n        return this.closestPoint(p).distance(p);\n    }\n    /**\n     * Returns a line tangent to the line at point that lies `rate` (normalized\n     * length) away from the beginning of the line.\n     */\n    tangentAt(ratio) {\n        if (!this.isDifferentiable()) {\n            return null;\n        }\n        const start = this.start;\n        const end = this.end;\n        const tangentStart = this.pointAt(ratio);\n        const tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);\n        return tangentLine;\n    }\n    /**\n     * Returns a line tangent to the line at point that lies `length` away from\n     * the beginning of the line.\n     */\n    tangentAtLength(length) {\n        if (!this.isDifferentiable()) {\n            return null;\n        }\n        const start = this.start;\n        const end = this.end;\n        const tangentStart = this.pointAtLength(length);\n        const tangentLine = new Line(start, end);\n        tangentLine.translate(tangentStart.x - start.x, tangentStart.y - start.y);\n        return tangentLine;\n    }\n    relativeCcw(x, y) {\n        const ref = Point.create(x, y);\n        let dx1 = ref.x - this.start.x;\n        let dy1 = ref.y - this.start.y;\n        const dx2 = this.end.x - this.start.x;\n        const dy2 = this.end.y - this.start.y;\n        let ccw = dx1 * dy2 - dy1 * dx2;\n        if (ccw === 0) {\n            ccw = dx1 * dx2 + dy1 * dy2;\n            if (ccw > 0.0) {\n                dx1 -= dx2;\n                dy1 -= dy2;\n                ccw = dx1 * dx2 + dy1 * dy2;\n                if (ccw < 0.0) {\n                    ccw = 0.0;\n                }\n            }\n        }\n        return ccw < 0.0 ? -1 : ccw > 0.0 ? 1 : 0;\n    }\n    /**\n     * Return `true` if the line equals the other line.\n     */\n    equals(l) {\n        return (l != null &&\n            this.start.x === l.start.x &&\n            this.start.y === l.start.y &&\n            this.end.x === l.end.x &&\n            this.end.y === l.end.y);\n    }\n    /**\n     * Returns another line which is a clone of the line.\n     */\n    clone() {\n        return new Line(this.start, this.end);\n    }\n    toJSON() {\n        return { start: this.start.toJSON(), end: this.end.toJSON() };\n    }\n    serialize() {\n        return [this.start.serialize(), this.end.serialize()].join(' ');\n    }\n}\n(function (Line) {\n    Line.toStringTag = `X6.Geometry.${Line.name}`;\n    function isLine(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Line) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const line = instance;\n        if ((tag == null || tag === Line.toStringTag) &&\n            Point.isPoint(line.start) &&\n            Point.isPoint(line.end) &&\n            typeof line.vector === 'function' &&\n            typeof line.bearing === 'function' &&\n            typeof line.parallel === 'function' &&\n            typeof line.intersect === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Line.isLine = isLine;\n})(Line || (Line = {}));\n//# sourceMappingURL=line.js.map"]},"metadata":{},"sourceType":"module"}