{"ast":null,"code":"import { ObjectExt, ArrayExt, Dom, FunctionExt, StringExt, Scheduler } from '../util';\nimport { Point } from '../geometry';\nimport { Dictionary } from '../common';\nimport { Attr } from '../registry/attr';\nimport { View } from './view';\nexport class AttrManager {\n  constructor(view) {\n    this.view = view;\n  }\n\n  get cell() {\n    return this.view.cell;\n  }\n\n  getDefinition(attrName) {\n    return this.cell.getAttrDefinition(attrName);\n  }\n\n  processAttrs(elem, raw) {\n    let normal;\n    let set;\n    let offset;\n    let position;\n    let delay;\n    const specials = []; // divide the attributes between normal and special\n\n    Object.keys(raw).forEach(name => {\n      const val = raw[name];\n      const definition = this.getDefinition(name);\n      const isValid = FunctionExt.call(Attr.isValidDefinition, this.view, definition, val, {\n        elem,\n        attrs: raw,\n        cell: this.cell,\n        view: this.view\n      });\n\n      if (definition && isValid) {\n        if (typeof definition === 'string') {\n          if (normal == null) {\n            normal = {};\n          }\n\n          normal[definition] = val;\n        } else if (val !== null) {\n          specials.push({\n            name,\n            definition\n          });\n        }\n      } else {\n        if (normal == null) {\n          normal = {};\n        }\n\n        const normalName = AttrManager.CASE_SENSITIVE_ATTR.includes(name) ? name : StringExt.kebabCase(name);\n        normal[normalName] = val;\n      }\n    });\n    specials.forEach(_ref => {\n      let {\n        name,\n        definition\n      } = _ref;\n      const val = raw[name];\n      const setDefine = definition;\n\n      if (typeof setDefine.set === 'function') {\n        if (!Dom.isHTMLElement(elem) && AttrManager.DELAY_ATTRS.includes(name)) {\n          if (delay == null) {\n            delay = {};\n          }\n\n          delay[name] = val;\n        } else {\n          if (set == null) {\n            set = {};\n          }\n\n          set[name] = val;\n        }\n      }\n\n      const offsetDefine = definition;\n\n      if (typeof offsetDefine.offset === 'function') {\n        if (offset == null) {\n          offset = {};\n        }\n\n        offset[name] = val;\n      }\n\n      const positionDefine = definition;\n\n      if (typeof positionDefine.position === 'function') {\n        if (position == null) {\n          position = {};\n        }\n\n        position[name] = val;\n      }\n    });\n    return {\n      raw,\n      normal,\n      set,\n      offset,\n      position,\n      delay\n    };\n  }\n\n  mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {\n    allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);\n    allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);\n    allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset); // Handle also the special transform property.\n\n    const transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;\n\n    if (transform != null && roProcessedAttrs.normal) {\n      roProcessedAttrs.normal.transform = transform;\n    }\n\n    allProcessedAttrs.normal = roProcessedAttrs.normal;\n  }\n\n  findAttrs(cellAttrs, rootNode, selectorCache, selectors) {\n    const merge = [];\n    const result = new Dictionary();\n    Object.keys(cellAttrs).forEach(selector => {\n      const attrs = cellAttrs[selector];\n\n      if (!ObjectExt.isPlainObject(attrs)) {\n        return;\n      }\n\n      const {\n        isCSSSelector,\n        elems\n      } = View.find(selector, rootNode, selectors);\n      selectorCache[selector] = elems;\n\n      for (let i = 0, l = elems.length; i < l; i += 1) {\n        const elem = elems[i];\n        const unique = selectors && selectors[selector] === elem;\n        const prev = result.get(elem);\n\n        if (prev) {\n          if (!prev.array) {\n            merge.push(elem);\n            prev.array = true;\n            prev.attrs = [prev.attrs];\n            prev.priority = [prev.priority];\n          }\n\n          const attributes = prev.attrs;\n          const selectedLength = prev.priority;\n\n          if (unique) {\n            // node referenced by `selector`\n            attributes.unshift(attrs);\n            selectedLength.unshift(-1);\n          } else {\n            // node referenced by `groupSelector` or CSSSelector\n            const sortIndex = ArrayExt.sortedIndex(selectedLength, isCSSSelector ? -1 : l);\n            attributes.splice(sortIndex, 0, attrs);\n            selectedLength.splice(sortIndex, 0, l);\n          }\n        } else {\n          result.set(elem, {\n            elem,\n            attrs,\n            priority: unique ? -1 : l,\n            array: false\n          });\n        }\n      }\n    });\n    merge.forEach(node => {\n      const item = result.get(node);\n      const arr = item.attrs;\n      item.attrs = arr.reduceRight((memo, attrs) => ObjectExt.merge(memo, attrs), {});\n    });\n    return result;\n  }\n\n  updateRelativeAttrs(elem, processedAttrs, refBBox, options) {\n    const rawAttrs = processedAttrs.raw || {};\n    let nodeAttrs = processedAttrs.normal || {};\n    const setAttrs = processedAttrs.set;\n    const positionAttrs = processedAttrs.position;\n    const offsetAttrs = processedAttrs.offset;\n    const delayAttrs = processedAttrs.delay;\n\n    const getOptions = () => ({\n      elem,\n      cell: this.cell,\n      view: this.view,\n      attrs: rawAttrs,\n      refBBox: refBBox.clone()\n    });\n\n    if (setAttrs != null) {\n      Object.keys(setAttrs).forEach(name => {\n        const val = setAttrs[name];\n        const def = this.getDefinition(name);\n\n        if (def != null) {\n          const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n\n          if (typeof ret === 'object') {\n            nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);\n          } else if (ret != null) {\n            nodeAttrs[name] = ret;\n          }\n        }\n      });\n    }\n\n    if (Dom.isHTMLElement(elem)) {\n      // TODO: setting the `transform` attribute on HTMLElements\n      // via `node.style.transform = 'matrix(...)';` would introduce\n      // a breaking change (e.g. basic.TextBlock).\n      this.view.setAttrs(nodeAttrs, elem);\n      return;\n    } // The final translation of the subelement.\n\n\n    const nodeTransform = nodeAttrs.transform;\n    const transform = nodeTransform ? `${nodeTransform}` : null;\n    const nodeMatrix = Dom.transformStringToMatrix(transform);\n    const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);\n\n    if (nodeTransform) {\n      delete nodeAttrs.transform;\n      nodeMatrix.e = 0;\n      nodeMatrix.f = 0;\n    } // Calculates node scale determined by the scalable group.\n\n\n    let sx = 1;\n    let sy = 1;\n\n    if (positionAttrs || offsetAttrs) {\n      const scale = this.view.getScaleOfElement(elem, options.scalableNode);\n      sx = scale.sx;\n      sy = scale.sy;\n    }\n\n    let positioned = false;\n\n    if (positionAttrs != null) {\n      Object.keys(positionAttrs).forEach(name => {\n        const val = positionAttrs[name];\n        const def = this.getDefinition(name);\n\n        if (def != null) {\n          const ts = FunctionExt.call(def.position, this.view, val, getOptions());\n\n          if (ts != null) {\n            positioned = true;\n            nodePosition.translate(Point.create(ts).scale(sx, sy));\n          }\n        }\n      });\n    } // The node bounding box could depend on the `size`\n    // set from the previous loop.\n\n\n    this.view.setAttrs(nodeAttrs, elem);\n    let offseted = false;\n\n    if (offsetAttrs != null) {\n      // Check if the node is visible\n      const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);\n\n      if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n        const nodeBBox = Dom.transformRectangle(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n        Object.keys(offsetAttrs).forEach(name => {\n          const val = offsetAttrs[name];\n          const def = this.getDefinition(name);\n\n          if (def != null) {\n            const ts = FunctionExt.call(def.offset, this.view, val, {\n              elem,\n              cell: this.cell,\n              view: this.view,\n              attrs: rawAttrs,\n              refBBox: nodeBBox\n            });\n\n            if (ts != null) {\n              offseted = true;\n              nodePosition.translate(Point.create(ts).scale(sx, sy));\n            }\n          }\n        });\n      }\n    }\n\n    if (nodeTransform != null || positioned || offseted) {\n      nodePosition.round(1);\n      nodeMatrix.e = nodePosition.x;\n      nodeMatrix.f = nodePosition.y;\n      elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix));\n    } // delay render\n\n\n    const updateDelayAttrs = () => {\n      if (delayAttrs != null) {\n        Object.keys(delayAttrs).forEach(name => {\n          const val = delayAttrs[name];\n          const def = this.getDefinition(name);\n\n          if (def != null) {\n            const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n\n            if (typeof ret === 'object') {\n              this.view.setAttrs(ret, elem);\n            } else if (ret != null) {\n              this.view.setAttrs({\n                [name]: ret\n              }, elem);\n            }\n          }\n        });\n      }\n    };\n\n    if (options.forceSync) {\n      updateDelayAttrs();\n    } else {\n      Scheduler.scheduleTask(updateDelayAttrs);\n    }\n  }\n\n  update(rootNode, attrs, options) {\n    const selectorCache = {};\n    const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors); // `nodesAttrs` are different from all attributes, when\n    // rendering only attributes sent to this method.\n\n    const nodesAllAttrs = options.attrs ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors) : nodesAttrs;\n    const specialItems = [];\n    nodesAttrs.each(data => {\n      const node = data.elem;\n      const nodeAttrs = data.attrs;\n      const processed = this.processAttrs(node, nodeAttrs);\n\n      if (processed.set == null && processed.position == null && processed.offset == null && processed.delay == null) {\n        this.view.setAttrs(processed.normal, node);\n      } else {\n        const data = nodesAllAttrs.get(node);\n        const nodeAllAttrs = data ? data.attrs : null;\n        const refSelector = nodeAllAttrs && nodeAttrs.ref == null ? nodeAllAttrs.ref : nodeAttrs.ref;\n        let refNode;\n\n        if (refSelector) {\n          refNode = (selectorCache[refSelector] || this.view.find(refSelector, rootNode, options.selectors))[0];\n\n          if (!refNode) {\n            throw new Error(`\"${refSelector}\" reference does not exist.`);\n          }\n        } else {\n          refNode = null;\n        }\n\n        const item = {\n          node,\n          refNode,\n          attributes: nodeAllAttrs,\n          processedAttributes: processed\n        }; // If an element in the list is positioned relative to this one, then\n        // we want to insert this one before it in the list.\n\n        const index = specialItems.findIndex(item => item.refNode === node);\n\n        if (index > -1) {\n          specialItems.splice(index, 0, item);\n        } else {\n          specialItems.push(item);\n        }\n      }\n    });\n    const bboxCache = new Dictionary();\n    let rotatableMatrix;\n    specialItems.forEach(item => {\n      const node = item.node;\n      const refNode = item.refNode;\n      let unrotatedRefBBox;\n      const isRefNodeRotatable = refNode != null && options.rotatableNode != null && Dom.contains(options.rotatableNode, refNode); // Find the reference element bounding box. If no reference was\n      // provided, we use the optional bounding box.\n\n      if (refNode) {\n        unrotatedRefBBox = bboxCache.get(refNode);\n      }\n\n      if (!unrotatedRefBBox) {\n        const target = isRefNodeRotatable ? options.rotatableNode : rootNode;\n        unrotatedRefBBox = refNode ? Dom.getBBox(refNode, {\n          target\n        }) : options.rootBBox;\n\n        if (refNode) {\n          bboxCache.set(refNode, unrotatedRefBBox);\n        }\n      }\n\n      let processedAttrs;\n\n      if (options.attrs && item.attributes) {\n        // If there was a special attribute affecting the position amongst\n        // passed-in attributes we have to merge it with the rest of the\n        // element's attributes as they are necessary to update the position\n        // relatively (i.e `ref-x` && 'ref-dx').\n        processedAttrs = this.processAttrs(node, item.attributes);\n        this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);\n      } else {\n        processedAttrs = item.processedAttributes;\n      }\n\n      let refBBox = unrotatedRefBBox;\n\n      if (isRefNodeRotatable && options.rotatableNode != null && !options.rotatableNode.contains(node)) {\n        // If the referenced node is inside the rotatable group while the\n        // updated node is outside, we need to take the rotatable node\n        // transformation into account.\n        if (!rotatableMatrix) {\n          rotatableMatrix = Dom.transformStringToMatrix(Dom.attr(options.rotatableNode, 'transform'));\n        }\n\n        refBBox = Dom.transformRectangle(unrotatedRefBBox, rotatableMatrix);\n      }\n\n      const caller = specialItems.find(item => item.refNode === node);\n\n      if (caller) {\n        options.forceSync = true;\n      }\n\n      this.updateRelativeAttrs(node, processedAttrs, refBBox, options);\n    });\n  }\n\n}\n\n(function (AttrManager) {\n  AttrManager.CASE_SENSITIVE_ATTR = ['viewBox'];\n  AttrManager.DELAY_ATTRS = ['text', 'textWrap', 'sourceMarker', 'targetMarker'];\n})(AttrManager || (AttrManager = {}));","map":{"version":3,"sources":["../../src/view/attr.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ObjectExt, ArrayExt, Dom, FunctionExt, StringExt, Scheduler, } from '../util';\nimport { Point } from '../geometry';\nimport { Dictionary } from '../common';\nimport { Attr } from '../registry/attr';\nimport { View } from './view';\nexport class AttrManager {\n    constructor(view) {\n        this.view = view;\n    }\n    get cell() {\n        return this.view.cell;\n    }\n    getDefinition(attrName) {\n        return this.cell.getAttrDefinition(attrName);\n    }\n    processAttrs(elem, raw) {\n        let normal;\n        let set;\n        let offset;\n        let position;\n        let delay;\n        const specials = [];\n        // divide the attributes between normal and special\n        Object.keys(raw).forEach((name) => {\n            const val = raw[name];\n            const definition = this.getDefinition(name);\n            const isValid = FunctionExt.call(Attr.isValidDefinition, this.view, definition, val, {\n                elem,\n                attrs: raw,\n                cell: this.cell,\n                view: this.view,\n            });\n            if (definition && isValid) {\n                if (typeof definition === 'string') {\n                    if (normal == null) {\n                        normal = {};\n                    }\n                    normal[definition] = val;\n                }\n                else if (val !== null) {\n                    specials.push({ name, definition });\n                }\n            }\n            else {\n                if (normal == null) {\n                    normal = {};\n                }\n                const normalName = AttrManager.CASE_SENSITIVE_ATTR.includes(name)\n                    ? name\n                    : StringExt.kebabCase(name);\n                normal[normalName] = val;\n            }\n        });\n        specials.forEach(({ name, definition }) => {\n            const val = raw[name];\n            const setDefine = definition;\n            if (typeof setDefine.set === 'function') {\n                if (!Dom.isHTMLElement(elem) &&\n                    AttrManager.DELAY_ATTRS.includes(name)) {\n                    if (delay == null) {\n                        delay = {};\n                    }\n                    delay[name] = val;\n                }\n                else {\n                    if (set == null) {\n                        set = {};\n                    }\n                    set[name] = val;\n                }\n            }\n            const offsetDefine = definition;\n            if (typeof offsetDefine.offset === 'function') {\n                if (offset == null) {\n                    offset = {};\n                }\n                offset[name] = val;\n            }\n            const positionDefine = definition;\n            if (typeof positionDefine.position === 'function') {\n                if (position == null) {\n                    position = {};\n                }\n                position[name] = val;\n            }\n        });\n        return {\n            raw,\n            normal,\n            set,\n            offset,\n            position,\n            delay,\n        };\n    }\n    mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {\n        allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);\n        allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);\n        allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset);\n        // Handle also the special transform property.\n        const transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;\n        if (transform != null && roProcessedAttrs.normal) {\n            roProcessedAttrs.normal.transform = transform;\n        }\n        allProcessedAttrs.normal = roProcessedAttrs.normal;\n    }\n    findAttrs(cellAttrs, rootNode, selectorCache, selectors) {\n        const merge = [];\n        const result = new Dictionary();\n        Object.keys(cellAttrs).forEach((selector) => {\n            const attrs = cellAttrs[selector];\n            if (!ObjectExt.isPlainObject(attrs)) {\n                return;\n            }\n            const { isCSSSelector, elems } = View.find(selector, rootNode, selectors);\n            selectorCache[selector] = elems;\n            for (let i = 0, l = elems.length; i < l; i += 1) {\n                const elem = elems[i];\n                const unique = selectors && selectors[selector] === elem;\n                const prev = result.get(elem);\n                if (prev) {\n                    if (!prev.array) {\n                        merge.push(elem);\n                        prev.array = true;\n                        prev.attrs = [prev.attrs];\n                        prev.priority = [prev.priority];\n                    }\n                    const attributes = prev.attrs;\n                    const selectedLength = prev.priority;\n                    if (unique) {\n                        // node referenced by `selector`\n                        attributes.unshift(attrs);\n                        selectedLength.unshift(-1);\n                    }\n                    else {\n                        // node referenced by `groupSelector` or CSSSelector\n                        const sortIndex = ArrayExt.sortedIndex(selectedLength, isCSSSelector ? -1 : l);\n                        attributes.splice(sortIndex, 0, attrs);\n                        selectedLength.splice(sortIndex, 0, l);\n                    }\n                }\n                else {\n                    result.set(elem, {\n                        elem,\n                        attrs,\n                        priority: unique ? -1 : l,\n                        array: false,\n                    });\n                }\n            }\n        });\n        merge.forEach((node) => {\n            const item = result.get(node);\n            const arr = item.attrs;\n            item.attrs = arr.reduceRight((memo, attrs) => ObjectExt.merge(memo, attrs), {});\n        });\n        return result;\n    }\n    updateRelativeAttrs(elem, processedAttrs, refBBox, options) {\n        const rawAttrs = processedAttrs.raw || {};\n        let nodeAttrs = processedAttrs.normal || {};\n        const setAttrs = processedAttrs.set;\n        const positionAttrs = processedAttrs.position;\n        const offsetAttrs = processedAttrs.offset;\n        const delayAttrs = processedAttrs.delay;\n        const getOptions = () => ({\n            elem,\n            cell: this.cell,\n            view: this.view,\n            attrs: rawAttrs,\n            refBBox: refBBox.clone(),\n        });\n        if (setAttrs != null) {\n            Object.keys(setAttrs).forEach((name) => {\n                const val = setAttrs[name];\n                const def = this.getDefinition(name);\n                if (def != null) {\n                    const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n                    if (typeof ret === 'object') {\n                        nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);\n                    }\n                    else if (ret != null) {\n                        nodeAttrs[name] = ret;\n                    }\n                }\n            });\n        }\n        if (Dom.isHTMLElement(elem)) {\n            // TODO: setting the `transform` attribute on HTMLElements\n            // via `node.style.transform = 'matrix(...)';` would introduce\n            // a breaking change (e.g. basic.TextBlock).\n            this.view.setAttrs(nodeAttrs, elem);\n            return;\n        }\n        // The final translation of the subelement.\n        const nodeTransform = nodeAttrs.transform;\n        const transform = nodeTransform ? `${nodeTransform}` : null;\n        const nodeMatrix = Dom.transformStringToMatrix(transform);\n        const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);\n        if (nodeTransform) {\n            delete nodeAttrs.transform;\n            nodeMatrix.e = 0;\n            nodeMatrix.f = 0;\n        }\n        // Calculates node scale determined by the scalable group.\n        let sx = 1;\n        let sy = 1;\n        if (positionAttrs || offsetAttrs) {\n            const scale = this.view.getScaleOfElement(elem, options.scalableNode);\n            sx = scale.sx;\n            sy = scale.sy;\n        }\n        let positioned = false;\n        if (positionAttrs != null) {\n            Object.keys(positionAttrs).forEach((name) => {\n                const val = positionAttrs[name];\n                const def = this.getDefinition(name);\n                if (def != null) {\n                    const ts = FunctionExt.call(def.position, this.view, val, getOptions());\n                    if (ts != null) {\n                        positioned = true;\n                        nodePosition.translate(Point.create(ts).scale(sx, sy));\n                    }\n                }\n            });\n        }\n        // The node bounding box could depend on the `size`\n        // set from the previous loop.\n        this.view.setAttrs(nodeAttrs, elem);\n        let offseted = false;\n        if (offsetAttrs != null) {\n            // Check if the node is visible\n            const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);\n            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                const nodeBBox = Dom.transformRectangle(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                Object.keys(offsetAttrs).forEach((name) => {\n                    const val = offsetAttrs[name];\n                    const def = this.getDefinition(name);\n                    if (def != null) {\n                        const ts = FunctionExt.call(def.offset, this.view, val, {\n                            elem,\n                            cell: this.cell,\n                            view: this.view,\n                            attrs: rawAttrs,\n                            refBBox: nodeBBox,\n                        });\n                        if (ts != null) {\n                            offseted = true;\n                            nodePosition.translate(Point.create(ts).scale(sx, sy));\n                        }\n                    }\n                });\n            }\n        }\n        if (nodeTransform != null || positioned || offseted) {\n            nodePosition.round(1);\n            nodeMatrix.e = nodePosition.x;\n            nodeMatrix.f = nodePosition.y;\n            elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix));\n        }\n        // delay render\n        const updateDelayAttrs = () => {\n            if (delayAttrs != null) {\n                Object.keys(delayAttrs).forEach((name) => {\n                    const val = delayAttrs[name];\n                    const def = this.getDefinition(name);\n                    if (def != null) {\n                        const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n                        if (typeof ret === 'object') {\n                            this.view.setAttrs(ret, elem);\n                        }\n                        else if (ret != null) {\n                            this.view.setAttrs({\n                                [name]: ret,\n                            }, elem);\n                        }\n                    }\n                });\n            }\n        };\n        if (options.forceSync) {\n            updateDelayAttrs();\n        }\n        else {\n            Scheduler.scheduleTask(updateDelayAttrs);\n        }\n    }\n    update(rootNode, attrs, options) {\n        const selectorCache = {};\n        const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors);\n        // `nodesAttrs` are different from all attributes, when\n        // rendering only attributes sent to this method.\n        const nodesAllAttrs = options.attrs\n            ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors)\n            : nodesAttrs;\n        const specialItems = [];\n        nodesAttrs.each((data) => {\n            const node = data.elem;\n            const nodeAttrs = data.attrs;\n            const processed = this.processAttrs(node, nodeAttrs);\n            if (processed.set == null &&\n                processed.position == null &&\n                processed.offset == null &&\n                processed.delay == null) {\n                this.view.setAttrs(processed.normal, node);\n            }\n            else {\n                const data = nodesAllAttrs.get(node);\n                const nodeAllAttrs = data ? data.attrs : null;\n                const refSelector = nodeAllAttrs && nodeAttrs.ref == null\n                    ? nodeAllAttrs.ref\n                    : nodeAttrs.ref;\n                let refNode;\n                if (refSelector) {\n                    refNode = (selectorCache[refSelector] ||\n                        this.view.find(refSelector, rootNode, options.selectors))[0];\n                    if (!refNode) {\n                        throw new Error(`\"${refSelector}\" reference does not exist.`);\n                    }\n                }\n                else {\n                    refNode = null;\n                }\n                const item = {\n                    node,\n                    refNode,\n                    attributes: nodeAllAttrs,\n                    processedAttributes: processed,\n                };\n                // If an element in the list is positioned relative to this one, then\n                // we want to insert this one before it in the list.\n                const index = specialItems.findIndex((item) => item.refNode === node);\n                if (index > -1) {\n                    specialItems.splice(index, 0, item);\n                }\n                else {\n                    specialItems.push(item);\n                }\n            }\n        });\n        const bboxCache = new Dictionary();\n        let rotatableMatrix;\n        specialItems.forEach((item) => {\n            const node = item.node;\n            const refNode = item.refNode;\n            let unrotatedRefBBox;\n            const isRefNodeRotatable = refNode != null &&\n                options.rotatableNode != null &&\n                Dom.contains(options.rotatableNode, refNode);\n            // Find the reference element bounding box. If no reference was\n            // provided, we use the optional bounding box.\n            if (refNode) {\n                unrotatedRefBBox = bboxCache.get(refNode);\n            }\n            if (!unrotatedRefBBox) {\n                const target = (isRefNodeRotatable ? options.rotatableNode : rootNode);\n                unrotatedRefBBox = refNode\n                    ? Dom.getBBox(refNode, { target })\n                    : options.rootBBox;\n                if (refNode) {\n                    bboxCache.set(refNode, unrotatedRefBBox);\n                }\n            }\n            let processedAttrs;\n            if (options.attrs && item.attributes) {\n                // If there was a special attribute affecting the position amongst\n                // passed-in attributes we have to merge it with the rest of the\n                // element's attributes as they are necessary to update the position\n                // relatively (i.e `ref-x` && 'ref-dx').\n                processedAttrs = this.processAttrs(node, item.attributes);\n                this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);\n            }\n            else {\n                processedAttrs = item.processedAttributes;\n            }\n            let refBBox = unrotatedRefBBox;\n            if (isRefNodeRotatable &&\n                options.rotatableNode != null &&\n                !options.rotatableNode.contains(node)) {\n                // If the referenced node is inside the rotatable group while the\n                // updated node is outside, we need to take the rotatable node\n                // transformation into account.\n                if (!rotatableMatrix) {\n                    rotatableMatrix = Dom.transformStringToMatrix(Dom.attr(options.rotatableNode, 'transform'));\n                }\n                refBBox = Dom.transformRectangle(unrotatedRefBBox, rotatableMatrix);\n            }\n            const caller = specialItems.find((item) => item.refNode === node);\n            if (caller) {\n                options.forceSync = true;\n            }\n            this.updateRelativeAttrs(node, processedAttrs, refBBox, options);\n        });\n    }\n}\n(function (AttrManager) {\n    AttrManager.CASE_SENSITIVE_ATTR = ['viewBox'];\n    AttrManager.DELAY_ATTRS = [\n        'text',\n        'textWrap',\n        'sourceMarker',\n        'targetMarker',\n    ];\n})(AttrManager || (AttrManager = {}));\n//# sourceMappingURL=attr.js.map"]},"metadata":{},"sourceType":"module"}