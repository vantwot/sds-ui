{"ast":null,"code":"\"use strict\";\n\nvar rankUtil = require(\"./util\");\n\nvar longestPath = rankUtil.longestPathWithLayer;\n\nvar feasibleTree = require(\"./feasible-tree\").feasibleTreeWithLayer;\n\nvar networkSimplex = require(\"./network-simplex\");\n\nmodule.exports = rank;\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\n\nfunction rank(g) {\n  switch (g.graph().ranker) {\n    case \"network-simplex\":\n      networkSimplexRanker(g);\n      break;\n\n    case \"tight-tree\":\n      tightTreeRanker(g);\n      break;\n\n    case \"longest-path\":\n      longestPathRanker(g);\n      break;\n    // default: networkSimplexRanker(g);\n\n    default:\n      tightTreeRanker(g);\n  }\n} // A fast and simple ranker, but results are far from optimal.\n\n\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/dagrejs/lib/rank/index.js"],"names":["rankUtil","require","longestPath","longestPathWithLayer","feasibleTree","feasibleTreeWithLayer","networkSimplex","module","exports","rank","g","graph","ranker","networkSimplexRanker","tightTreeRanker","longestPathRanker"],"mappings":"AAAA;;AAEA,IAAIA,QAAQ,GAAGC,OAAO,CAAC,QAAD,CAAtB;;AACA,IAAIC,WAAW,GAAGF,QAAQ,CAACG,oBAA3B;;AACA,IAAIC,YAAY,GAAGH,OAAO,CAAC,iBAAD,CAAP,CAA2BI,qBAA9C;;AACA,IAAIC,cAAc,GAAGL,OAAO,CAAC,mBAAD,CAA5B;;AAEAM,MAAM,CAACC,OAAP,GAAiBC,IAAjB;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASA,IAAT,CAAcC,CAAd,EAAiB;AACf,UAAOA,CAAC,CAACC,KAAF,GAAUC,MAAjB;AACA,SAAK,iBAAL;AAAwBC,MAAAA,oBAAoB,CAACH,CAAD,CAApB;AAAyB;;AACjD,SAAK,YAAL;AAAmBI,MAAAA,eAAe,CAACJ,CAAD,CAAf;AAAoB;;AACvC,SAAK,cAAL;AAAqBK,MAAAA,iBAAiB,CAACL,CAAD,CAAjB;AAAsB;AAC3C;;AACA;AAASI,MAAAA,eAAe,CAACJ,CAAD,CAAf;AALT;AAOD,C,CAED;;;AACA,IAAIK,iBAAiB,GAAGb,WAAxB;;AAEA,SAASY,eAAT,CAAyBJ,CAAzB,EAA4B;AAC1BR,EAAAA,WAAW,CAACQ,CAAD,CAAX;AACAN,EAAAA,YAAY,CAACM,CAAD,CAAZ;AACD;;AAED,SAASG,oBAAT,CAA8BH,CAA9B,EAAiC;AAC/BJ,EAAAA,cAAc,CAACI,CAAD,CAAd;AACD","sourcesContent":["\"use strict\";\n\nvar rankUtil = require(\"./util\");\nvar longestPath = rankUtil.longestPathWithLayer;\nvar feasibleTree = require(\"./feasible-tree\").feasibleTreeWithLayer;\nvar networkSimplex = require(\"./network-simplex\");\n\nmodule.exports = rank;\n\n/*\n * Assigns a rank to each node in the input graph that respects the \"minlen\"\n * constraint specified on edges between nodes.\n *\n * This basic structure is derived from Gansner, et al., \"A Technique for\n * Drawing Directed Graphs.\"\n *\n * Pre-conditions:\n *\n *    1. Graph must be a connected DAG\n *    2. Graph nodes must be objects\n *    3. Graph edges must have \"weight\" and \"minlen\" attributes\n *\n * Post-conditions:\n *\n *    1. Graph nodes will have a \"rank\" attribute based on the results of the\n *       algorithm. Ranks can start at any index (including negative), we'll\n *       fix them up later.\n */\nfunction rank(g) {\n  switch(g.graph().ranker) {\n  case \"network-simplex\": networkSimplexRanker(g); break;\n  case \"tight-tree\": tightTreeRanker(g); break;\n  case \"longest-path\": longestPathRanker(g); break;\n  // default: networkSimplexRanker(g);\n  default: tightTreeRanker(g);\n  }\n}\n\n// A fast and simple ranker, but results are far from optimal.\nvar longestPathRanker = longestPath;\n\nfunction tightTreeRanker(g) {\n  longestPath(g);\n  feasibleTree(g);\n}\n\nfunction networkSimplexRanker(g) {\n  networkSimplex(g);\n}\n"]},"metadata":{},"sourceType":"script"}