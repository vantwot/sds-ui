{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as Registry from '../registry';\nimport { Dom, Vector } from '../util';\nimport { Base } from './base';\nexport var GridManager = /*#__PURE__*/function (_Base) {\n  _inherits(GridManager, _Base);\n\n  var _super = _createSuper(GridManager);\n\n  function GridManager() {\n    _classCallCheck(this, GridManager);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(GridManager, [{\n    key: \"elem\",\n    get: function get() {\n      return this.view.grid;\n    }\n  }, {\n    key: \"grid\",\n    get: function get() {\n      return this.options.grid;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.startListening();\n      this.draw(this.grid);\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      this.graph.on('scale', this.update, this);\n      this.graph.on('translate', this.update, this);\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      this.graph.off('scale', this.update, this);\n      this.graph.off('translate', this.update, this);\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      if (this.grid.visible !== visible) {\n        this.grid.visible = visible;\n        this.update();\n      }\n    }\n  }, {\n    key: \"getGridSize\",\n    value: function getGridSize() {\n      return this.grid.size;\n    }\n  }, {\n    key: \"setGridSize\",\n    value: function setGridSize(size) {\n      this.grid.size = Math.max(size, 1);\n      this.update();\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      this.setVisible(true);\n      this.update();\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      this.setVisible(false);\n      this.update();\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this.elem.style.backgroundImage = '';\n    }\n  }, {\n    key: \"draw\",\n    value: function draw(options) {\n      this.clear();\n      this.instance = null;\n      Object.assign(this.grid, options);\n      this.patterns = this.resolveGrid(options);\n      this.update();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var gridSize = this.grid.size;\n\n      if (gridSize <= 1 || !this.grid.visible) {\n        return this.clear();\n      }\n\n      var ctm = this.graph.matrix();\n      var grid = this.getInstance();\n      var items = Array.isArray(options) ? options : [options];\n      this.patterns.forEach(function (settings, index) {\n        var id = \"pattern_\".concat(index);\n        var sx = ctm.a || 1;\n        var sy = ctm.d || 1;\n\n        var update = settings.update,\n            markup = settings.markup,\n            others = __rest(settings, [\"update\", \"markup\"]);\n\n        var options = Object.assign(Object.assign(Object.assign({}, others), items[index]), {\n          sx: sx,\n          sy: sy,\n          ox: ctm.e || 0,\n          oy: ctm.f || 0,\n          width: gridSize * sx,\n          height: gridSize * sy\n        });\n\n        if (!grid.has(id)) {\n          grid.add(id, Vector.create('pattern', {\n            id: id,\n            patternUnits: 'userSpaceOnUse'\n          }, Vector.createVectors(markup)).node);\n        }\n\n        var patternElem = grid.get(id);\n\n        if (typeof update === 'function') {\n          update(patternElem.childNodes[0], options);\n        }\n\n        var x = options.ox % options.width;\n\n        if (x < 0) {\n          x += options.width;\n        }\n\n        var y = options.oy % options.height;\n\n        if (y < 0) {\n          y += options.height;\n        }\n\n        Dom.attr(patternElem, {\n          x: x,\n          y: y,\n          width: options.width,\n          height: options.height\n        });\n      });\n      var base64 = new XMLSerializer().serializeToString(grid.root);\n      var url = \"url(data:image/svg+xml;base64,\".concat(btoa(base64), \")\");\n      this.elem.style.backgroundImage = url;\n    }\n  }, {\n    key: \"getInstance\",\n    value: function getInstance() {\n      if (!this.instance) {\n        this.instance = new Registry.Grid();\n      }\n\n      return this.instance;\n    }\n  }, {\n    key: \"resolveGrid\",\n    value: function resolveGrid(options) {\n      if (!options) {\n        return [];\n      }\n\n      var type = options.type;\n\n      if (type == null) {\n        return [Object.assign(Object.assign({}, Registry.Grid.presets.dot), options.args)];\n      }\n\n      var items = Registry.Grid.registry.get(type);\n\n      if (items) {\n        var args = options.args || [];\n\n        if (!Array.isArray(args)) {\n          args = [args];\n        }\n\n        return Array.isArray(items) ? items.map(function (item, index) {\n          return Object.assign(Object.assign({}, item), args[index]);\n        }) : [Object.assign(Object.assign({}, items), args[0])];\n      }\n\n      return Registry.Grid.registry.onNotFound(type);\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.stopListening();\n      this.clear();\n    }\n  }]);\n\n  return GridManager;\n}(Base);\n\n__decorate([Base.dispose()], GridManager.prototype, \"dispose\", null);","map":{"version":3,"sources":["../../src/graph/grid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport * as Registry from '../registry';\nimport { Dom, Vector } from '../util';\nimport { Base } from './base';\nexport class GridManager extends Base {\n    get elem() {\n        return this.view.grid;\n    }\n    get grid() {\n        return this.options.grid;\n    }\n    init() {\n        this.startListening();\n        this.draw(this.grid);\n    }\n    startListening() {\n        this.graph.on('scale', this.update, this);\n        this.graph.on('translate', this.update, this);\n    }\n    stopListening() {\n        this.graph.off('scale', this.update, this);\n        this.graph.off('translate', this.update, this);\n    }\n    setVisible(visible) {\n        if (this.grid.visible !== visible) {\n            this.grid.visible = visible;\n            this.update();\n        }\n    }\n    getGridSize() {\n        return this.grid.size;\n    }\n    setGridSize(size) {\n        this.grid.size = Math.max(size, 1);\n        this.update();\n    }\n    show() {\n        this.setVisible(true);\n        this.update();\n    }\n    hide() {\n        this.setVisible(false);\n        this.update();\n    }\n    clear() {\n        this.elem.style.backgroundImage = '';\n    }\n    draw(options) {\n        this.clear();\n        this.instance = null;\n        Object.assign(this.grid, options);\n        this.patterns = this.resolveGrid(options);\n        this.update();\n    }\n    update(options = {}) {\n        const gridSize = this.grid.size;\n        if (gridSize <= 1 || !this.grid.visible) {\n            return this.clear();\n        }\n        const ctm = this.graph.matrix();\n        const grid = this.getInstance();\n        const items = Array.isArray(options) ? options : [options];\n        this.patterns.forEach((settings, index) => {\n            const id = `pattern_${index}`;\n            const sx = ctm.a || 1;\n            const sy = ctm.d || 1;\n            const { update, markup } = settings, others = __rest(settings, [\"update\", \"markup\"]);\n            const options = Object.assign(Object.assign(Object.assign({}, others), items[index]), { sx,\n                sy, ox: ctm.e || 0, oy: ctm.f || 0, width: gridSize * sx, height: gridSize * sy });\n            if (!grid.has(id)) {\n                grid.add(id, Vector.create('pattern', { id, patternUnits: 'userSpaceOnUse' }, Vector.createVectors(markup)).node);\n            }\n            const patternElem = grid.get(id);\n            if (typeof update === 'function') {\n                update(patternElem.childNodes[0], options);\n            }\n            let x = options.ox % options.width;\n            if (x < 0) {\n                x += options.width;\n            }\n            let y = options.oy % options.height;\n            if (y < 0) {\n                y += options.height;\n            }\n            Dom.attr(patternElem, {\n                x,\n                y,\n                width: options.width,\n                height: options.height,\n            });\n        });\n        const base64 = new XMLSerializer().serializeToString(grid.root);\n        const url = `url(data:image/svg+xml;base64,${btoa(base64)})`;\n        this.elem.style.backgroundImage = url;\n    }\n    getInstance() {\n        if (!this.instance) {\n            this.instance = new Registry.Grid();\n        }\n        return this.instance;\n    }\n    resolveGrid(options) {\n        if (!options) {\n            return [];\n        }\n        const type = options.type;\n        if (type == null) {\n            return [\n                Object.assign(Object.assign({}, Registry.Grid.presets.dot), options.args),\n            ];\n        }\n        const items = Registry.Grid.registry.get(type);\n        if (items) {\n            let args = options.args || [];\n            if (!Array.isArray(args)) {\n                args = [args];\n            }\n            return Array.isArray(items)\n                ? items.map((item, index) => (Object.assign(Object.assign({}, item), args[index])))\n                : [Object.assign(Object.assign({}, items), args[0])];\n        }\n        return Registry.Grid.registry.onNotFound(type);\n    }\n    dispose() {\n        this.stopListening();\n        this.clear();\n    }\n}\n__decorate([\n    Base.dispose()\n], GridManager.prototype, \"dispose\", null);\n//# sourceMappingURL=grid.js.map"]},"metadata":{},"sourceType":"module"}