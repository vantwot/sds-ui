{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ArrayExt, FunctionExt } from '../../util';\nimport { Rectangle, Angle } from '../../geometry';\nimport { View } from '../../view/view';\nexport class Snapline extends View {\n  constructor(options) {\n    super();\n\n    const {\n      graph\n    } = options,\n          others = __rest(options, [\"graph\"]);\n\n    this.graph = graph;\n    this.options = Object.assign({\n      tolerance: 10\n    }, others);\n    this.render();\n    this.parseFilter();\n\n    if (!this.disabled) {\n      this.startListening();\n    }\n  }\n\n  get model() {\n    return this.graph.model;\n  }\n\n  get containerClassName() {\n    return this.prefixClassName('widget-snapline');\n  }\n\n  get verticalClassName() {\n    return `${this.containerClassName}-vertical`;\n  }\n\n  get horizontalClassName() {\n    return `${this.containerClassName}-horizontal`;\n  }\n\n  get disabled() {\n    return this.options.enabled !== true || this.graph.options.snapline.enabled !== true;\n  }\n\n  enable() {\n    if (this.disabled) {\n      this.options.enabled = true;\n      this.graph.options.snapline.enabled = true;\n      this.startListening();\n    }\n  }\n\n  disable() {\n    if (!this.disabled) {\n      this.options.enabled = false;\n      this.graph.options.snapline.enabled = false;\n      this.stopListening();\n    }\n  }\n\n  setFilter(filter) {\n    this.options.filter = filter;\n    this.parseFilter();\n  }\n\n  render() {\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container);\n    this.$horizontal = this.$(document.createElement('div')).addClass(this.horizontalClassName);\n    this.$vertical = this.$(document.createElement('div')).addClass(this.verticalClassName);\n    this.$container.hide().addClass(this.containerClassName).append([this.$horizontal, this.$vertical]);\n\n    if (this.options.className) {\n      this.$container.addClass(this.options.className);\n    }\n  }\n\n  startListening() {\n    this.stopListening();\n    this.graph.on('node:mousedown', this.captureCursorOffset, this);\n    this.graph.on('node:mousemove', this.snapOnMoving, this);\n    this.model.on('batch:stop', this.onBatchStop, this);\n    this.delegateDocumentEvents({\n      mouseup: 'hide',\n      touchend: 'hide'\n    });\n  }\n\n  stopListening() {\n    this.graph.off('node:mousedown', this.captureCursorOffset, this);\n    this.graph.off('node:mousemove', this.snapOnMoving, this);\n    this.model.off('batch:stop', this.onBatchStop, this);\n    this.undelegateDocumentEvents();\n  }\n\n  parseFilter() {\n    this.filterShapes = {};\n    this.filterCells = {};\n    this.filterFunction = null;\n    const filter = this.options.filter;\n\n    if (Array.isArray(filter)) {\n      filter.forEach(item => {\n        if (typeof item === 'string') {\n          this.filterShapes[item] = true;\n        } else {\n          this.filterCells[item.id] = true;\n        }\n      });\n    } else if (typeof filter === 'function') {\n      this.filterFunction = filter;\n    }\n  }\n\n  onBatchStop(_ref) {\n    let {\n      name,\n      data\n    } = _ref;\n\n    if (name === 'resize') {\n      this.snapOnResizing(data.cell, data);\n    }\n  }\n\n  captureCursorOffset(_ref2) {\n    let {\n      view,\n      x,\n      y\n    } = _ref2;\n    const targetView = view.getDelegatedView();\n\n    if (targetView && this.isNodeMovable(targetView)) {\n      const pos = view.cell.getPosition();\n      this.offset = {\n        x: x - pos.x,\n        y: y - pos.y\n      };\n    }\n  }\n\n  isNodeMovable(view) {\n    return view && view.cell.isNode() && view.can('nodeMovable');\n  }\n\n  snapOnResizing(node, options) {\n    if (this.options.resizing && !options.snapped && options.ui && options.direction && options.trueDirection) {\n      const view = this.graph.renderer.findViewByCell(node);\n\n      if (view && view.cell.isNode()) {\n        const nodeBbox = node.getBBox();\n        const nodeBBoxRotated = nodeBbox.bbox(node.getAngle());\n        const nodeTopLeft = nodeBBoxRotated.getTopLeft();\n        const nodeBottomRight = nodeBBoxRotated.getBottomRight();\n        const angle = Angle.normalize(node.getAngle());\n        const tolerance = this.options.tolerance || 0;\n        let verticalLeft;\n        let verticalTop;\n        let verticalHeight;\n        let horizontalTop;\n        let horizontalLeft;\n        let horizontalWidth;\n        const snapOrigin = {\n          vertical: 0,\n          horizontal: 0\n        };\n        const direction = options.direction;\n        const trueDirection = options.trueDirection;\n        const relativeDirection = options.relativeDirection;\n\n        if (trueDirection.indexOf('right') !== -1) {\n          snapOrigin.vertical = nodeBottomRight.x;\n        } else {\n          snapOrigin.vertical = nodeTopLeft.x;\n        }\n\n        if (trueDirection.indexOf('bottom') !== -1) {\n          snapOrigin.horizontal = nodeBottomRight.y;\n        } else {\n          snapOrigin.horizontal = nodeTopLeft.y;\n        }\n\n        this.model.getNodes().some(cell => {\n          if (this.isIgnored(node, cell)) {\n            return false;\n          }\n\n          const snapBBox = cell.getBBox().bbox(cell.getAngle());\n          const snapTopLeft = snapBBox.getTopLeft();\n          const snapBottomRight = snapBBox.getBottomRight();\n          const groups = {\n            vertical: [snapTopLeft.x, snapBottomRight.x],\n            horizontal: [snapTopLeft.y, snapBottomRight.y]\n          };\n          const distances = {};\n          Object.keys(groups).forEach(k => {\n            const key = k;\n            const list = groups[key].map(value => ({\n              position: value,\n              distance: Math.abs(value - snapOrigin[key])\n            })).filter(item => item.distance <= tolerance);\n            distances[key] = ArrayExt.sortBy(list, item => item.distance);\n          });\n\n          if (verticalLeft == null && distances.vertical.length > 0) {\n            verticalLeft = distances.vertical[0].position;\n            verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n            verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n          }\n\n          if (horizontalTop == null && distances.horizontal.length > 0) {\n            horizontalTop = distances.horizontal[0].position;\n            horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n            horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n          }\n\n          return verticalLeft != null && horizontalTop != null;\n        });\n        this.hide();\n        let dx = 0;\n        let dy = 0;\n\n        if (horizontalTop != null || verticalLeft != null) {\n          if (verticalLeft != null) {\n            dx = trueDirection.indexOf('right') !== -1 ? verticalLeft - nodeBottomRight.x : nodeTopLeft.x - verticalLeft;\n          }\n\n          if (horizontalTop != null) {\n            dy = trueDirection.indexOf('bottom') !== -1 ? horizontalTop - nodeBottomRight.y : nodeTopLeft.y - horizontalTop;\n          }\n        }\n\n        let dWidth = 0;\n        let dHeight = 0;\n\n        if (angle % 90 === 0) {\n          if (angle === 90 || angle === 270) {\n            dWidth = dy;\n            dHeight = dx;\n          } else {\n            dWidth = dx;\n            dHeight = dy;\n          }\n        } else {\n          const quadrant = angle >= 0 && angle < 90 ? 1 : angle >= 90 && angle < 180 ? 4 : angle >= 180 && angle < 270 ? 3 : 2;\n\n          if (horizontalTop != null && verticalLeft != null) {\n            if (dx < dy) {\n              dy = 0;\n              horizontalTop = undefined;\n            } else {\n              dx = 0;\n              verticalLeft = undefined;\n            }\n          }\n\n          const rad = Angle.toRad(angle % 90);\n\n          if (dx) {\n            dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);\n          }\n\n          if (dy) {\n            dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);\n          }\n\n          const quadrant13 = quadrant === 1 || quadrant === 3;\n\n          switch (relativeDirection) {\n            case 'top':\n            case 'bottom':\n              dHeight = dy ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n              break;\n\n            case 'left':\n            case 'right':\n              dWidth = dx ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n              break;\n\n            default:\n              break;\n          }\n        }\n\n        switch (relativeDirection) {\n          case 'top':\n          case 'bottom':\n            dWidth = 0;\n            break;\n\n          case 'left':\n          case 'right':\n            dHeight = 0;\n            break;\n\n          default:\n            break;\n        }\n\n        const gridSize = this.graph.getGridSize();\n        let newWidth = Math.max(nodeBbox.width + dWidth, gridSize);\n        let newHeight = Math.max(nodeBbox.height + dHeight, gridSize);\n\n        if (options.minWidth && options.minWidth > gridSize) {\n          newWidth = Math.max(newWidth, options.minWidth);\n        }\n\n        if (options.minHeight && options.minHeight > gridSize) {\n          newHeight = Math.max(newHeight, options.minHeight);\n        }\n\n        if (options.maxWidth) {\n          newWidth = Math.min(newWidth, options.maxWidth);\n        }\n\n        if (options.maxHeight) {\n          newHeight = Math.min(newHeight, options.maxHeight);\n        }\n\n        if (options.preserveAspectRatio) {\n          if (dHeight < dWidth) {\n            newHeight = newWidth * (nodeBbox.height / nodeBbox.width);\n          } else {\n            newWidth = newHeight * (nodeBbox.width / nodeBbox.height);\n          }\n        }\n\n        if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {\n          node.resize(newWidth, newHeight, {\n            direction,\n            relativeDirection,\n            trueDirection,\n            snapped: true,\n            snaplines: this.cid,\n            restrict: this.graph.hook.getRestrictArea(view)\n          });\n\n          if (verticalHeight) {\n            verticalHeight += newHeight - nodeBbox.height;\n          }\n\n          if (horizontalWidth) {\n            horizontalWidth += newWidth - nodeBbox.width;\n          }\n        }\n\n        const newRotatedBBox = node.getBBox().bbox(angle);\n\n        if (verticalLeft && Math.abs(newRotatedBBox.x - verticalLeft) > 1 && Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {\n          verticalLeft = undefined;\n        }\n\n        if (horizontalTop && Math.abs(newRotatedBBox.y - horizontalTop) > 1 && Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {\n          horizontalTop = undefined;\n        }\n\n        this.update({\n          verticalLeft,\n          verticalTop,\n          verticalHeight,\n          horizontalTop,\n          horizontalLeft,\n          horizontalWidth\n        });\n      }\n    }\n  }\n\n  snapOnMoving(_ref3) {\n    let {\n      view,\n      e,\n      x,\n      y\n    } = _ref3;\n    const targetView = view.getEventData(e).delegatedView || view;\n\n    if (!this.isNodeMovable(targetView)) {\n      return;\n    }\n\n    const node = targetView.cell;\n    const size = node.getSize();\n    const position = node.getPosition();\n    const cellBBox = new Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);\n    const angle = node.getAngle();\n    const nodeCenter = cellBBox.getCenter();\n    const nodeBBoxRotated = cellBBox.bbox(angle);\n    const nodeTopLeft = nodeBBoxRotated.getTopLeft();\n    const nodeBottomRight = nodeBBoxRotated.getBottomRight();\n    const distance = this.options.tolerance || 0;\n    let verticalLeft;\n    let verticalTop;\n    let verticalHeight;\n    let horizontalTop;\n    let horizontalLeft;\n    let horizontalWidth;\n    let verticalFix = 0;\n    let horizontalFix = 0;\n    this.model.getNodes().some(targetNode => {\n      if (this.isIgnored(node, targetNode)) {\n        return false;\n      }\n\n      const snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());\n      const snapCenter = snapBBox.getCenter();\n      const snapTopLeft = snapBBox.getTopLeft();\n      const snapBottomRight = snapBBox.getBottomRight();\n\n      if (verticalLeft == null) {\n        if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {\n          verticalLeft = snapCenter.x;\n          verticalFix = 0.5;\n        } else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {\n          verticalLeft = snapTopLeft.x;\n          verticalFix = 0;\n        } else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {\n          verticalLeft = snapTopLeft.x;\n          verticalFix = 1;\n        } else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {\n          verticalLeft = snapBottomRight.x;\n          verticalFix = 1;\n        } else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {\n          verticalLeft = snapBottomRight.x;\n        }\n\n        if (verticalLeft != null) {\n          verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n          verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n        }\n      }\n\n      if (horizontalTop == null) {\n        if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {\n          horizontalTop = snapCenter.y;\n          horizontalFix = 0.5;\n        } else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {\n          horizontalTop = snapTopLeft.y;\n        } else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {\n          horizontalTop = snapTopLeft.y;\n          horizontalFix = 1;\n        } else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {\n          horizontalTop = snapBottomRight.y;\n          horizontalFix = 1;\n        } else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {\n          horizontalTop = snapBottomRight.y;\n        }\n\n        if (horizontalTop != null) {\n          horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n          horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n        }\n      }\n\n      return verticalLeft != null && horizontalTop != null;\n    });\n    this.hide();\n\n    if (horizontalTop != null || verticalLeft != null) {\n      if (horizontalTop != null) {\n        nodeBBoxRotated.y = horizontalTop - horizontalFix * nodeBBoxRotated.height;\n      }\n\n      if (verticalLeft != null) {\n        nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;\n      }\n\n      const newCenter = nodeBBoxRotated.getCenter();\n      const newX = newCenter.x - cellBBox.width / 2;\n      const newY = newCenter.y - cellBBox.height / 2;\n      const dx = newX - position.x;\n      const dy = newY - position.y;\n\n      if (dx !== 0 || dy !== 0) {\n        node.translate(dx, dy, {\n          snapped: true,\n          restrict: this.graph.hook.getRestrictArea(targetView)\n        });\n\n        if (horizontalWidth) {\n          horizontalWidth += dx;\n        }\n\n        if (verticalHeight) {\n          verticalHeight += dy;\n        }\n      }\n\n      this.update({\n        verticalLeft,\n        verticalTop,\n        verticalHeight,\n        horizontalTop,\n        horizontalLeft,\n        horizontalWidth\n      });\n    }\n  }\n\n  isIgnored(snapNode, targetNode) {\n    return targetNode.id === snapNode.id || targetNode.isDescendantOf(snapNode) || this.filterShapes[targetNode.shape] || this.filterCells[targetNode.id] || this.filterFunction && FunctionExt.call(this.filterFunction, this.graph, targetNode);\n  }\n\n  update(metadata) {\n    const ctm = this.graph.matrix();\n    const sx = ctm.a;\n    const sy = ctm.d;\n    const tx = ctm.e;\n    const ty = ctm.f;\n    const sharp = this.options.sharp;\n    const hasScroller = this.graph.scroller.widget != null;\n\n    if (metadata.horizontalTop) {\n      this.$horizontal.css({\n        top: metadata.horizontalTop * sy + ty,\n        left: sharp ? metadata.horizontalLeft * sx + tx : hasScroller ? '-300%' : 0,\n        width: sharp ? metadata.horizontalWidth * sx : hasScroller ? '700%' : '100%'\n      }).show();\n    } else {\n      this.$horizontal.hide();\n    }\n\n    if (metadata.verticalLeft) {\n      this.$vertical.css({\n        left: metadata.verticalLeft * sx + tx,\n        top: sharp ? metadata.verticalTop * sy + ty : hasScroller ? '-300%' : 0,\n        height: sharp ? metadata.verticalHeight * sy : hasScroller ? '700%' : '100%'\n      }).show();\n    } else {\n      this.$vertical.hide();\n    }\n\n    this.show();\n  }\n\n  resetTimer() {\n    if (this.timer) {\n      clearTimeout(this.timer);\n      this.timer = null;\n    }\n  }\n\n  show() {\n    this.$container.show();\n    this.resetTimer();\n\n    if (this.container.parentNode == null) {\n      this.graph.container.appendChild(this.container);\n    }\n\n    return this;\n  }\n\n  hide() {\n    this.$container.hide();\n    this.resetTimer();\n    const clean = this.options.clean;\n    const delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;\n\n    if (delay > 0) {\n      this.timer = window.setTimeout(() => {\n        this.unmount();\n      }, delay);\n    }\n\n    return this;\n  }\n\n  onRemove() {\n    this.stopListening();\n    this.hide();\n  }\n\n  dispose() {\n    this.remove();\n  }\n\n}\n\n__decorate([View.dispose()], Snapline.prototype, \"dispose\", null);","map":{"version":3,"sources":["../../../src/addon/snapline/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ArrayExt, FunctionExt } from '../../util';\nimport { Rectangle, Angle } from '../../geometry';\nimport { View } from '../../view/view';\nexport class Snapline extends View {\n    constructor(options) {\n        super();\n        const { graph } = options, others = __rest(options, [\"graph\"]);\n        this.graph = graph;\n        this.options = Object.assign({ tolerance: 10 }, others);\n        this.render();\n        this.parseFilter();\n        if (!this.disabled) {\n            this.startListening();\n        }\n    }\n    get model() {\n        return this.graph.model;\n    }\n    get containerClassName() {\n        return this.prefixClassName('widget-snapline');\n    }\n    get verticalClassName() {\n        return `${this.containerClassName}-vertical`;\n    }\n    get horizontalClassName() {\n        return `${this.containerClassName}-horizontal`;\n    }\n    get disabled() {\n        return (this.options.enabled !== true ||\n            this.graph.options.snapline.enabled !== true);\n    }\n    enable() {\n        if (this.disabled) {\n            this.options.enabled = true;\n            this.graph.options.snapline.enabled = true;\n            this.startListening();\n        }\n    }\n    disable() {\n        if (!this.disabled) {\n            this.options.enabled = false;\n            this.graph.options.snapline.enabled = false;\n            this.stopListening();\n        }\n    }\n    setFilter(filter) {\n        this.options.filter = filter;\n        this.parseFilter();\n    }\n    render() {\n        this.container = document.createElement('div');\n        this.$container = this.$(this.container);\n        this.$horizontal = this.$(document.createElement('div')).addClass(this.horizontalClassName);\n        this.$vertical = this.$(document.createElement('div')).addClass(this.verticalClassName);\n        this.$container\n            .hide()\n            .addClass(this.containerClassName)\n            .append([this.$horizontal, this.$vertical]);\n        if (this.options.className) {\n            this.$container.addClass(this.options.className);\n        }\n    }\n    startListening() {\n        this.stopListening();\n        this.graph.on('node:mousedown', this.captureCursorOffset, this);\n        this.graph.on('node:mousemove', this.snapOnMoving, this);\n        this.model.on('batch:stop', this.onBatchStop, this);\n        this.delegateDocumentEvents({\n            mouseup: 'hide',\n            touchend: 'hide',\n        });\n    }\n    stopListening() {\n        this.graph.off('node:mousedown', this.captureCursorOffset, this);\n        this.graph.off('node:mousemove', this.snapOnMoving, this);\n        this.model.off('batch:stop', this.onBatchStop, this);\n        this.undelegateDocumentEvents();\n    }\n    parseFilter() {\n        this.filterShapes = {};\n        this.filterCells = {};\n        this.filterFunction = null;\n        const filter = this.options.filter;\n        if (Array.isArray(filter)) {\n            filter.forEach((item) => {\n                if (typeof item === 'string') {\n                    this.filterShapes[item] = true;\n                }\n                else {\n                    this.filterCells[item.id] = true;\n                }\n            });\n        }\n        else if (typeof filter === 'function') {\n            this.filterFunction = filter;\n        }\n    }\n    onBatchStop({ name, data }) {\n        if (name === 'resize') {\n            this.snapOnResizing(data.cell, data);\n        }\n    }\n    captureCursorOffset({ view, x, y }) {\n        const targetView = view.getDelegatedView();\n        if (targetView && this.isNodeMovable(targetView)) {\n            const pos = view.cell.getPosition();\n            this.offset = {\n                x: x - pos.x,\n                y: y - pos.y,\n            };\n        }\n    }\n    isNodeMovable(view) {\n        return view && view.cell.isNode() && view.can('nodeMovable');\n    }\n    snapOnResizing(node, options) {\n        if (this.options.resizing &&\n            !options.snapped &&\n            options.ui &&\n            options.direction &&\n            options.trueDirection) {\n            const view = this.graph.renderer.findViewByCell(node);\n            if (view && view.cell.isNode()) {\n                const nodeBbox = node.getBBox();\n                const nodeBBoxRotated = nodeBbox.bbox(node.getAngle());\n                const nodeTopLeft = nodeBBoxRotated.getTopLeft();\n                const nodeBottomRight = nodeBBoxRotated.getBottomRight();\n                const angle = Angle.normalize(node.getAngle());\n                const tolerance = this.options.tolerance || 0;\n                let verticalLeft;\n                let verticalTop;\n                let verticalHeight;\n                let horizontalTop;\n                let horizontalLeft;\n                let horizontalWidth;\n                const snapOrigin = {\n                    vertical: 0,\n                    horizontal: 0,\n                };\n                const direction = options.direction;\n                const trueDirection = options.trueDirection;\n                const relativeDirection = options.relativeDirection;\n                if (trueDirection.indexOf('right') !== -1) {\n                    snapOrigin.vertical = nodeBottomRight.x;\n                }\n                else {\n                    snapOrigin.vertical = nodeTopLeft.x;\n                }\n                if (trueDirection.indexOf('bottom') !== -1) {\n                    snapOrigin.horizontal = nodeBottomRight.y;\n                }\n                else {\n                    snapOrigin.horizontal = nodeTopLeft.y;\n                }\n                this.model.getNodes().some((cell) => {\n                    if (this.isIgnored(node, cell)) {\n                        return false;\n                    }\n                    const snapBBox = cell.getBBox().bbox(cell.getAngle());\n                    const snapTopLeft = snapBBox.getTopLeft();\n                    const snapBottomRight = snapBBox.getBottomRight();\n                    const groups = {\n                        vertical: [snapTopLeft.x, snapBottomRight.x],\n                        horizontal: [snapTopLeft.y, snapBottomRight.y],\n                    };\n                    const distances = {};\n                    Object.keys(groups).forEach((k) => {\n                        const key = k;\n                        const list = groups[key]\n                            .map((value) => ({\n                            position: value,\n                            distance: Math.abs(value - snapOrigin[key]),\n                        }))\n                            .filter((item) => item.distance <= tolerance);\n                        distances[key] = ArrayExt.sortBy(list, (item) => item.distance);\n                    });\n                    if (verticalLeft == null && distances.vertical.length > 0) {\n                        verticalLeft = distances.vertical[0].position;\n                        verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n                        verticalHeight =\n                            Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n                    }\n                    if (horizontalTop == null && distances.horizontal.length > 0) {\n                        horizontalTop = distances.horizontal[0].position;\n                        horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n                        horizontalWidth =\n                            Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n                    }\n                    return verticalLeft != null && horizontalTop != null;\n                });\n                this.hide();\n                let dx = 0;\n                let dy = 0;\n                if (horizontalTop != null || verticalLeft != null) {\n                    if (verticalLeft != null) {\n                        dx =\n                            trueDirection.indexOf('right') !== -1\n                                ? verticalLeft - nodeBottomRight.x\n                                : nodeTopLeft.x - verticalLeft;\n                    }\n                    if (horizontalTop != null) {\n                        dy =\n                            trueDirection.indexOf('bottom') !== -1\n                                ? horizontalTop - nodeBottomRight.y\n                                : nodeTopLeft.y - horizontalTop;\n                    }\n                }\n                let dWidth = 0;\n                let dHeight = 0;\n                if (angle % 90 === 0) {\n                    if (angle === 90 || angle === 270) {\n                        dWidth = dy;\n                        dHeight = dx;\n                    }\n                    else {\n                        dWidth = dx;\n                        dHeight = dy;\n                    }\n                }\n                else {\n                    const quadrant = angle >= 0 && angle < 90\n                        ? 1\n                        : angle >= 90 && angle < 180\n                            ? 4\n                            : angle >= 180 && angle < 270\n                                ? 3\n                                : 2;\n                    if (horizontalTop != null && verticalLeft != null) {\n                        if (dx < dy) {\n                            dy = 0;\n                            horizontalTop = undefined;\n                        }\n                        else {\n                            dx = 0;\n                            verticalLeft = undefined;\n                        }\n                    }\n                    const rad = Angle.toRad(angle % 90);\n                    if (dx) {\n                        dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);\n                    }\n                    if (dy) {\n                        dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);\n                    }\n                    const quadrant13 = quadrant === 1 || quadrant === 3;\n                    switch (relativeDirection) {\n                        case 'top':\n                        case 'bottom':\n                            dHeight = dy\n                                ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad))\n                                : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n                            break;\n                        case 'left':\n                        case 'right':\n                            dWidth = dx\n                                ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad))\n                                : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                switch (relativeDirection) {\n                    case 'top':\n                    case 'bottom':\n                        dWidth = 0;\n                        break;\n                    case 'left':\n                    case 'right':\n                        dHeight = 0;\n                        break;\n                    default:\n                        break;\n                }\n                const gridSize = this.graph.getGridSize();\n                let newWidth = Math.max(nodeBbox.width + dWidth, gridSize);\n                let newHeight = Math.max(nodeBbox.height + dHeight, gridSize);\n                if (options.minWidth && options.minWidth > gridSize) {\n                    newWidth = Math.max(newWidth, options.minWidth);\n                }\n                if (options.minHeight && options.minHeight > gridSize) {\n                    newHeight = Math.max(newHeight, options.minHeight);\n                }\n                if (options.maxWidth) {\n                    newWidth = Math.min(newWidth, options.maxWidth);\n                }\n                if (options.maxHeight) {\n                    newHeight = Math.min(newHeight, options.maxHeight);\n                }\n                if (options.preserveAspectRatio) {\n                    if (dHeight < dWidth) {\n                        newHeight = newWidth * (nodeBbox.height / nodeBbox.width);\n                    }\n                    else {\n                        newWidth = newHeight * (nodeBbox.width / nodeBbox.height);\n                    }\n                }\n                if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {\n                    node.resize(newWidth, newHeight, {\n                        direction,\n                        relativeDirection,\n                        trueDirection,\n                        snapped: true,\n                        snaplines: this.cid,\n                        restrict: this.graph.hook.getRestrictArea(view),\n                    });\n                    if (verticalHeight) {\n                        verticalHeight += newHeight - nodeBbox.height;\n                    }\n                    if (horizontalWidth) {\n                        horizontalWidth += newWidth - nodeBbox.width;\n                    }\n                }\n                const newRotatedBBox = node.getBBox().bbox(angle);\n                if (verticalLeft &&\n                    Math.abs(newRotatedBBox.x - verticalLeft) > 1 &&\n                    Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {\n                    verticalLeft = undefined;\n                }\n                if (horizontalTop &&\n                    Math.abs(newRotatedBBox.y - horizontalTop) > 1 &&\n                    Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {\n                    horizontalTop = undefined;\n                }\n                this.update({\n                    verticalLeft,\n                    verticalTop,\n                    verticalHeight,\n                    horizontalTop,\n                    horizontalLeft,\n                    horizontalWidth,\n                });\n            }\n        }\n    }\n    snapOnMoving({ view, e, x, y }) {\n        const targetView = view.getEventData(e).delegatedView || view;\n        if (!this.isNodeMovable(targetView)) {\n            return;\n        }\n        const node = targetView.cell;\n        const size = node.getSize();\n        const position = node.getPosition();\n        const cellBBox = new Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);\n        const angle = node.getAngle();\n        const nodeCenter = cellBBox.getCenter();\n        const nodeBBoxRotated = cellBBox.bbox(angle);\n        const nodeTopLeft = nodeBBoxRotated.getTopLeft();\n        const nodeBottomRight = nodeBBoxRotated.getBottomRight();\n        const distance = this.options.tolerance || 0;\n        let verticalLeft;\n        let verticalTop;\n        let verticalHeight;\n        let horizontalTop;\n        let horizontalLeft;\n        let horizontalWidth;\n        let verticalFix = 0;\n        let horizontalFix = 0;\n        this.model.getNodes().some((targetNode) => {\n            if (this.isIgnored(node, targetNode)) {\n                return false;\n            }\n            const snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());\n            const snapCenter = snapBBox.getCenter();\n            const snapTopLeft = snapBBox.getTopLeft();\n            const snapBottomRight = snapBBox.getBottomRight();\n            if (verticalLeft == null) {\n                if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {\n                    verticalLeft = snapCenter.x;\n                    verticalFix = 0.5;\n                }\n                else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {\n                    verticalLeft = snapTopLeft.x;\n                    verticalFix = 0;\n                }\n                else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {\n                    verticalLeft = snapTopLeft.x;\n                    verticalFix = 1;\n                }\n                else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {\n                    verticalLeft = snapBottomRight.x;\n                    verticalFix = 1;\n                }\n                else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {\n                    verticalLeft = snapBottomRight.x;\n                }\n                if (verticalLeft != null) {\n                    verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n                    verticalHeight =\n                        Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n                }\n            }\n            if (horizontalTop == null) {\n                if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {\n                    horizontalTop = snapCenter.y;\n                    horizontalFix = 0.5;\n                }\n                else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {\n                    horizontalTop = snapTopLeft.y;\n                }\n                else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {\n                    horizontalTop = snapTopLeft.y;\n                    horizontalFix = 1;\n                }\n                else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {\n                    horizontalTop = snapBottomRight.y;\n                    horizontalFix = 1;\n                }\n                else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {\n                    horizontalTop = snapBottomRight.y;\n                }\n                if (horizontalTop != null) {\n                    horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n                    horizontalWidth =\n                        Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n                }\n            }\n            return verticalLeft != null && horizontalTop != null;\n        });\n        this.hide();\n        if (horizontalTop != null || verticalLeft != null) {\n            if (horizontalTop != null) {\n                nodeBBoxRotated.y =\n                    horizontalTop - horizontalFix * nodeBBoxRotated.height;\n            }\n            if (verticalLeft != null) {\n                nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;\n            }\n            const newCenter = nodeBBoxRotated.getCenter();\n            const newX = newCenter.x - cellBBox.width / 2;\n            const newY = newCenter.y - cellBBox.height / 2;\n            const dx = newX - position.x;\n            const dy = newY - position.y;\n            if (dx !== 0 || dy !== 0) {\n                node.translate(dx, dy, {\n                    snapped: true,\n                    restrict: this.graph.hook.getRestrictArea(targetView),\n                });\n                if (horizontalWidth) {\n                    horizontalWidth += dx;\n                }\n                if (verticalHeight) {\n                    verticalHeight += dy;\n                }\n            }\n            this.update({\n                verticalLeft,\n                verticalTop,\n                verticalHeight,\n                horizontalTop,\n                horizontalLeft,\n                horizontalWidth,\n            });\n        }\n    }\n    isIgnored(snapNode, targetNode) {\n        return (targetNode.id === snapNode.id ||\n            targetNode.isDescendantOf(snapNode) ||\n            this.filterShapes[targetNode.shape] ||\n            this.filterCells[targetNode.id] ||\n            (this.filterFunction &&\n                FunctionExt.call(this.filterFunction, this.graph, targetNode)));\n    }\n    update(metadata) {\n        const ctm = this.graph.matrix();\n        const sx = ctm.a;\n        const sy = ctm.d;\n        const tx = ctm.e;\n        const ty = ctm.f;\n        const sharp = this.options.sharp;\n        const hasScroller = this.graph.scroller.widget != null;\n        if (metadata.horizontalTop) {\n            this.$horizontal\n                .css({\n                top: metadata.horizontalTop * sy + ty,\n                left: sharp\n                    ? metadata.horizontalLeft * sx + tx\n                    : hasScroller\n                        ? '-300%'\n                        : 0,\n                width: sharp\n                    ? metadata.horizontalWidth * sx\n                    : hasScroller\n                        ? '700%'\n                        : '100%',\n            })\n                .show();\n        }\n        else {\n            this.$horizontal.hide();\n        }\n        if (metadata.verticalLeft) {\n            this.$vertical\n                .css({\n                left: metadata.verticalLeft * sx + tx,\n                top: sharp\n                    ? metadata.verticalTop * sy + ty\n                    : hasScroller\n                        ? '-300%'\n                        : 0,\n                height: sharp\n                    ? metadata.verticalHeight * sy\n                    : hasScroller\n                        ? '700%'\n                        : '100%',\n            })\n                .show();\n        }\n        else {\n            this.$vertical.hide();\n        }\n        this.show();\n    }\n    resetTimer() {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    }\n    show() {\n        this.$container.show();\n        this.resetTimer();\n        if (this.container.parentNode == null) {\n            this.graph.container.appendChild(this.container);\n        }\n        return this;\n    }\n    hide() {\n        this.$container.hide();\n        this.resetTimer();\n        const clean = this.options.clean;\n        const delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;\n        if (delay > 0) {\n            this.timer = window.setTimeout(() => {\n                this.unmount();\n            }, delay);\n        }\n        return this;\n    }\n    onRemove() {\n        this.stopListening();\n        this.hide();\n    }\n    dispose() {\n        this.remove();\n    }\n}\n__decorate([\n    View.dispose()\n], Snapline.prototype, \"dispose\", null);\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}