{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport SingleTapRecognizer, { MAX_DIST, MAX_TAP_INTERVAL } from './single_tap_recognizer';\n\nvar TapRecognizer = function () {\n  function TapRecognizer(options) {\n    _classCallCheck(this, TapRecognizer);\n\n    _defineProperty(this, \"singleTap\", void 0);\n\n    _defineProperty(this, \"numTaps\", void 0);\n\n    _defineProperty(this, \"lastTime\", void 0);\n\n    _defineProperty(this, \"lastTap\", void 0);\n\n    _defineProperty(this, \"count\", void 0);\n\n    this.singleTap = new SingleTapRecognizer(options);\n    this.numTaps = options.numTaps;\n    this.reset();\n  }\n\n  _createClass(TapRecognizer, [{\n    key: \"reset\",\n    value: function reset() {\n      this.lastTime = Infinity;\n      delete this.lastTap;\n      this.count = 0;\n      this.singleTap.reset();\n    }\n  }, {\n    key: \"touchstart\",\n    value: function touchstart(e, points, mapTouches) {\n      this.singleTap.touchstart(e, points, mapTouches);\n    }\n  }, {\n    key: \"touchmove\",\n    value: function touchmove(e, points, mapTouches) {\n      this.singleTap.touchmove(e, points, mapTouches);\n    }\n  }, {\n    key: \"touchend\",\n    value: function touchend(e, points, mapTouches) {\n      var tap = this.singleTap.touchend(e, points, mapTouches);\n\n      if (tap) {\n        var soonEnough = e.timeStamp - this.lastTime < MAX_TAP_INTERVAL;\n        var closeEnough = !this.lastTap || this.lastTap.dist(tap) < MAX_DIST;\n\n        if (!soonEnough || !closeEnough) {\n          this.reset();\n        }\n\n        this.count++;\n        this.lastTime = e.timeStamp;\n        this.lastTap = tap;\n\n        if (this.count === this.numTaps) {\n          this.reset();\n          return tap;\n        }\n      }\n    }\n  }]);\n\n  return TapRecognizer;\n}();\n\nexport { TapRecognizer as default };","map":{"version":3,"sources":["../../../src/handler/tap/tap_recognizer.ts"],"names":["TapRecognizer","options","tap","soonEnough","e","closeEnough"],"mappings":";;;AAEA,OAAA,mBAAA,IAAA,QAAA,EAAA,gBAAA,QAAA,yBAAA;;IAKqBA,a;AAOnB,WAAA,aAAA,CAAA,OAAA,EAA8D;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,aAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,WAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,SAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,UAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,SAAA,EAAA,KAAA,CAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,OAAA,EAAA,KAAA,CAAA,CAAA;;AAC5D,SAAA,SAAA,GAAiB,IAAA,mBAAA,CAAjB,OAAiB,CAAjB;AACA,SAAA,OAAA,GAAeC,OAAO,CAAtB,OAAA;AACA,SAAA,KAAA;AACD;;;;WAED,SAAA,KAAA,GAAe;AACb,WAAA,QAAA,GAAA,QAAA;AACA,aAAO,KAAP,OAAA;AACA,WAAA,KAAA,GAAA,CAAA;AACA,WAAA,SAAA,CAAA,KAAA;AACD;;;WAED,SAAA,UAAA,CAAA,CAAA,EAAA,MAAA,EAAA,UAAA,EAAuE;AACrE,WAAA,SAAA,CAAA,UAAA,CAAA,CAAA,EAAA,MAAA,EAAA,UAAA;AACD;;;WAED,SAAA,SAAA,CAAA,CAAA,EAAA,MAAA,EAAA,UAAA,EAAsE;AACpE,WAAA,SAAA,CAAA,SAAA,CAAA,CAAA,EAAA,MAAA,EAAA,UAAA;AACD;;;WAED,SAAA,QAAA,CAAA,CAAA,EAAA,MAAA,EAAA,UAAA,EAAqE;AACnE,UAAMC,GAAG,GAAG,KAAA,SAAA,CAAA,QAAA,CAAA,CAAA,EAAA,MAAA,EAAZ,UAAY,CAAZ;;AACA,UAAA,GAAA,EAAS;AACP,YAAMC,UAAU,GAAGC,CAAC,CAADA,SAAAA,GAAc,KAAdA,QAAAA,GAAnB,gBAAA;AACA,YAAMC,WAAW,GAAG,CAAC,KAAD,OAAA,IAAiB,KAAA,OAAA,CAAA,IAAA,CAAA,GAAA,IAArC,QAAA;;AAEA,YAAI,CAAA,UAAA,IAAe,CAAnB,WAAA,EAAiC;AAC/B,eAAA,KAAA;AACD;;AAED,aAAA,KAAA;AACA,aAAA,QAAA,GAAgBD,CAAC,CAAjB,SAAA;AACA,aAAA,OAAA,GAAA,GAAA;;AAEA,YAAI,KAAA,KAAA,KAAe,KAAnB,OAAA,EAAiC;AAC/B,eAAA,KAAA;AACA,iBAAA,GAAA;AACD;AACF;AACF;;;;;;SA/CkBJ,a","sourcesContent":["// @ts-ignore\nimport Point from '../../geo/point';\nimport SingleTapRecognizer, {\n  MAX_DIST,\n  MAX_TAP_INTERVAL,\n} from './single_tap_recognizer';\n\nexport default class TapRecognizer {\n  public singleTap: SingleTapRecognizer;\n  public numTaps: number;\n  public lastTime: number;\n  public lastTap: Point;\n  public count: number;\n\n  constructor(options: { numTaps: number; numTouches: number }) {\n    this.singleTap = new SingleTapRecognizer(options);\n    this.numTaps = options.numTaps;\n    this.reset();\n  }\n\n  public reset() {\n    this.lastTime = Infinity;\n    delete this.lastTap;\n    this.count = 0;\n    this.singleTap.reset();\n  }\n\n  public touchstart(e: TouchEvent, points: Point[], mapTouches: Touch[]) {\n    this.singleTap.touchstart(e, points, mapTouches);\n  }\n\n  public touchmove(e: TouchEvent, points: Point[], mapTouches: Touch[]) {\n    this.singleTap.touchmove(e, points, mapTouches);\n  }\n\n  public touchend(e: TouchEvent, points: Point[], mapTouches: Touch[]) {\n    const tap = this.singleTap.touchend(e, points, mapTouches);\n    if (tap) {\n      const soonEnough = e.timeStamp - this.lastTime < MAX_TAP_INTERVAL;\n      const closeEnough = !this.lastTap || this.lastTap.dist(tap) < MAX_DIST;\n\n      if (!soonEnough || !closeEnough) {\n        this.reset();\n      }\n\n      this.count++;\n      this.lastTime = e.timeStamp;\n      this.lastTap = tap;\n\n      if (this.count === this.numTaps) {\n        this.reset();\n        return tap;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}