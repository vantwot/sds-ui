{"ast":null,"code":"import * as util from './util';\nimport { Angle } from './angle';\nimport { Geometry } from './geometry';\nexport class Point extends Geometry {\n  constructor(x, y) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n  }\n\n  get [Symbol.toStringTag]() {\n    return Point.toStringTag;\n  }\n  /**\n   * Rounds the point to the given precision.\n   */\n\n\n  round() {\n    let precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.x = util.round(this.x, precision);\n    this.y = util.round(this.y, precision);\n    return this;\n  }\n\n  add(x, y) {\n    const p = Point.create(x, y);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n\n  update(x, y) {\n    const p = Point.create(x, y);\n    this.x = p.x;\n    this.y = p.y;\n    return this;\n  }\n\n  translate(dx, dy) {\n    const t = Point.create(dx, dy);\n    this.x += t.x;\n    this.y += t.y;\n    return this;\n  }\n  /**\n   * Rotate the point by `degree` around `center`.\n   */\n\n\n  rotate(degree, center) {\n    const p = Point.rotate(this, degree, center);\n    this.x = p.x;\n    this.y = p.y;\n    return this;\n  }\n  /**\n   * Scale point by `sx` and `sy` around the given `origin`. If origin is not\n   * specified, the point is scaled around `0,0`.\n   */\n\n\n  scale(sx, sy) {\n    let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    const ref = Point.create(origin);\n    this.x = ref.x + sx * (this.x - ref.x);\n    this.y = ref.y + sy * (this.y - ref.y);\n    return this;\n  }\n  /**\n   * Chooses the point closest to this point from among `points`. If `points`\n   * is an empty array, `null` is returned.\n   */\n\n\n  closest(points) {\n    if (points.length === 1) {\n      return Point.create(points[0]);\n    }\n\n    let ret = null;\n    let min = Infinity;\n    points.forEach(p => {\n      const dist = this.squaredDistance(p);\n\n      if (dist < min) {\n        ret = p;\n        min = dist;\n      }\n    });\n    return ret ? Point.create(ret) : null;\n  }\n  /**\n   * Returns the distance between the point and another point `p`.\n   */\n\n\n  distance(p) {\n    return Math.sqrt(this.squaredDistance(p));\n  }\n  /**\n   * Returns the squared distance between the point and another point `p`.\n   *\n   * Useful for distance comparisons in which real distance is not necessary\n   * (saves one `Math.sqrt()` operation).\n   */\n\n\n  squaredDistance(p) {\n    const ref = Point.create(p);\n    const dx = this.x - ref.x;\n    const dy = this.y - ref.y;\n    return dx * dx + dy * dy;\n  }\n\n  manhattanDistance(p) {\n    const ref = Point.create(p);\n    return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);\n  }\n  /**\n   * Returns the magnitude of the point vector.\n   *\n   * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)\n   */\n\n\n  magnitude() {\n    return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;\n  }\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p` and\n   * the x-axis.\n   */\n\n\n  theta() {\n    let p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Point();\n    const ref = Point.create(p);\n    const y = -(ref.y - this.y); // invert the y-axis.\n\n    const x = ref.x - this.x;\n    let rad = Math.atan2(y, x); // Correction for III. and IV. quadrant.\n\n    if (rad < 0) {\n      rad = 2 * Math.PI + rad;\n    }\n\n    return 180 * rad / Math.PI;\n  }\n  /**\n   * Returns the angle(in degrees) between vector from this point to `p1` and\n   * the vector from this point to `p2`.\n   *\n   * The ordering of points `p1` and `p2` is important.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from `p1` to `p2`) is clockwise, and a value between `180` and\n   * `360` when the angle is counterclockwise.\n   *\n   * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.\n   */\n\n\n  angleBetween(p1, p2) {\n    if (this.equals(p1) || this.equals(p2)) {\n      return NaN;\n    }\n\n    let angle = this.theta(p2) - this.theta(p1);\n\n    if (angle < 0) {\n      angle += 360;\n    }\n\n    return angle;\n  }\n  /**\n   * Returns the angle(in degrees) between the line from `(0,0)` and this point\n   * and the line from `(0,0)` to `p`.\n   *\n   * The function returns a value between `0` and `180` when the angle (in the\n   * direction from this point to `p`) is clockwise, and a value between `180`\n   * and `360` when the angle is counterclockwise. Returns `NaN` if called from\n   * point `(0,0)` or if `p` is `(0,0)`.\n   */\n\n\n  vectorAngle(p) {\n    const zero = new Point(0, 0);\n    return zero.angleBetween(this, p);\n  }\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n\n\n  toPolar(origin) {\n    this.update(Point.toPolar(this, origin));\n    return this;\n  }\n  /**\n   * Returns the change in angle(in degrees) that is the result of moving the\n   * point from its previous position to its current position.\n   *\n   * More specifically, this function computes the angle between the line from\n   * the ref point to the previous position of this point(i.e. current position\n   * `-dx`, `-dy`) and the line from the `ref` point to the current position of\n   * this point.\n   *\n   * The function returns a positive value between `0` and `180` when the angle\n   * (in the direction from previous position of this point to its current\n   * position) is clockwise, and a negative value between `0` and `-180` when\n   * the angle is counterclockwise.\n   *\n   * The function returns `0` if the previous and current positions of this\n   * point are the same (i.e. both `dx` and `dy` are `0`).\n   */\n\n\n  changeInAngle(dx, dy) {\n    let ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    // Revert the translation and measure the change in angle around x-axis.\n    return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);\n  }\n  /**\n   * If the point lies outside the rectangle `rect`, adjust the point so that\n   * it becomes the nearest point on the boundary of `rect`.\n   */\n\n\n  adhereToRect(rect) {\n    if (!util.containsPoint(rect, this)) {\n      this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);\n      this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);\n    }\n\n    return this;\n  }\n  /**\n   * Returns the bearing(cardinal direction) between me and the given point.\n   *\n   * @see https://en.wikipedia.org/wiki/Cardinal_direction\n   */\n\n\n  bearing(p) {\n    const ref = Point.create(p);\n    const lat1 = Angle.toRad(this.y);\n    const lat2 = Angle.toRad(ref.y);\n    const lon1 = this.x;\n    const lon2 = ref.x;\n    const dLon = Angle.toRad(lon2 - lon1);\n    const y = Math.sin(dLon) * Math.cos(lat2);\n    const x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n    const brng = Angle.toDeg(Math.atan2(y, x));\n    const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n    let index = brng - 22.5;\n\n    if (index < 0) {\n      index += 360;\n    }\n\n    index = parseInt(index / 45, 10);\n    return bearings[index];\n  }\n  /**\n   * Returns the cross product of the vector from me to `p1` and the vector\n   * from me to `p2`.\n   *\n   * The left-hand rule is used because the coordinate system is left-handed.\n   */\n\n\n  cross(p1, p2) {\n    if (p1 != null && p2 != null) {\n      const a = Point.create(p1);\n      const b = Point.create(p2);\n      return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);\n    }\n\n    return NaN;\n  }\n  /**\n   * Returns the dot product of this point with given other point.\n   */\n\n\n  dot(p) {\n    const ref = Point.create(p);\n    return this.x * ref.x + this.y * ref.y;\n  }\n\n  diff(dx, dy) {\n    if (typeof dx === 'number') {\n      return new Point(this.x - dx, this.y - dy);\n    }\n\n    const p = Point.create(dx);\n    return new Point(this.x - p.x, this.y - p.y);\n  }\n  /**\n   * Returns an interpolation between me and point `p` for a parametert in\n   * the closed interval `[0, 1]`.\n   */\n\n\n  lerp(p, t) {\n    const ref = Point.create(p);\n    return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);\n  }\n  /**\n   * Normalize the point vector, scale the line segment between `(0, 0)`\n   * and the point in order for it to have the given length. If length is\n   * not specified, it is considered to be `1`; in that case, a unit vector\n   * is computed.\n   */\n\n\n  normalize() {\n    let length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n    const scale = length / this.magnitude();\n    return this.scale(scale, scale);\n  }\n  /**\n   * Moves this point along the line starting from `ref` to this point by a\n   * certain `distance`.\n   */\n\n\n  move(ref, distance) {\n    const p = Point.create(ref);\n    const rad = Angle.toRad(p.theta(this));\n    return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);\n  }\n  /**\n   * Returns a point that is the reflection of me with the center of inversion\n   * in `ref` point.\n   */\n\n\n  reflection(ref) {\n    return Point.create(ref).move(this, this.distance(ref));\n  }\n\n  snapToGrid(gx, gy) {\n    this.x = util.snapToGrid(this.x, gx);\n    this.y = util.snapToGrid(this.y, gy == null ? gx : gy);\n    return this;\n  }\n\n  equals(p) {\n    const ref = Point.create(p);\n    return ref != null && ref.x === this.x && ref.y === this.y;\n  }\n\n  clone() {\n    return Point.clone(this);\n  }\n  /**\n   * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.\n   */\n\n\n  toJSON() {\n    return Point.toJSON(this);\n  }\n\n  serialize() {\n    return `${this.x} ${this.y}`;\n  }\n\n}\n\n(function (Point) {\n  Point.toStringTag = `X6.Geometry.${Point.name}`;\n\n  function isPoint(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Point) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const point = instance;\n\n    if ((tag == null || tag === Point.toStringTag) && typeof point.x === 'number' && typeof point.y === 'number' && typeof point.toPolar === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Point.isPoint = isPoint;\n})(Point || (Point = {}));\n\n(function (Point) {\n  function isPointLike(p) {\n    return p != null && typeof p === 'object' && typeof p.x === 'number' && typeof p.y === 'number';\n  }\n\n  Point.isPointLike = isPointLike;\n\n  function isPointData(p) {\n    return p != null && Array.isArray(p) && p.length === 2 && typeof p[0] === 'number' && typeof p[1] === 'number';\n  }\n\n  Point.isPointData = isPointData;\n})(Point || (Point = {}));\n\n(function (Point) {\n  function create(x, y) {\n    if (x == null || typeof x === 'number') {\n      return new Point(x, y);\n    }\n\n    return clone(x);\n  }\n\n  Point.create = create;\n\n  function clone(p) {\n    if (Point.isPoint(p)) {\n      return new Point(p.x, p.y);\n    }\n\n    if (Array.isArray(p)) {\n      return new Point(p[0], p[1]);\n    }\n\n    return new Point(p.x, p.y);\n  }\n\n  Point.clone = clone;\n\n  function toJSON(p) {\n    if (Point.isPoint(p)) {\n      return {\n        x: p.x,\n        y: p.y\n      };\n    }\n\n    if (Array.isArray(p)) {\n      return {\n        x: p[0],\n        y: p[1]\n      };\n    }\n\n    return {\n      x: p.x,\n      y: p.y\n    };\n  }\n\n  Point.toJSON = toJSON;\n  /**\n   * Returns a new Point object from the given polar coordinates.\n   * @see http://en.wikipedia.org/wiki/Polar_coordinate_system\n   */\n\n  function fromPolar(r, rad) {\n    let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    let x = Math.abs(r * Math.cos(rad));\n    let y = Math.abs(r * Math.sin(rad));\n    const org = clone(origin);\n    const deg = Angle.normalize(Angle.toDeg(rad));\n\n    if (deg < 90) {\n      y = -y;\n    } else if (deg < 180) {\n      x = -x;\n      y = -y;\n    } else if (deg < 270) {\n      x = -x;\n    }\n\n    return new Point(org.x + x, org.y + y);\n  }\n\n  Point.fromPolar = fromPolar;\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n\n  function toPolar(point) {\n    let origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Point();\n    const p = clone(point);\n    const o = clone(origin);\n    const dx = p.x - o.x;\n    const dy = p.y - o.y;\n    return new Point(Math.sqrt(dx * dx + dy * dy), // r\n    Angle.toRad(o.theta(p)));\n  }\n\n  Point.toPolar = toPolar;\n\n  function equals(p1, p2) {\n    if (p1 === p2) {\n      return true;\n    }\n\n    if (p1 != null && p2 != null) {\n      return p1.x === p2.x && p1.y === p2.y;\n    }\n\n    return false;\n  }\n\n  Point.equals = equals;\n\n  function equalPoints(p1, p2) {\n    if (p1 == null && p2 != null || p1 != null && p2 == null || p1 != null && p2 != null && p1.length !== p2.length) {\n      return false;\n    }\n\n    if (p1 != null && p2 != null) {\n      for (let i = 0, ii = p1.length; i < ii; i += 1) {\n        if (!equals(p1[i], p2[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  Point.equalPoints = equalPoints;\n  /**\n   * Returns a point with random coordinates that fall within the range\n   * `[x1, x2]` and `[y1, y2]`.\n   */\n\n  function random(x1, x2, y1, y2) {\n    return new Point(util.random(x1, x2), util.random(y1, y2));\n  }\n\n  Point.random = random;\n\n  function rotate(point, angle, center) {\n    const rad = Angle.toRad(Angle.normalize(-angle));\n    const sin = Math.sin(rad);\n    const cos = Math.cos(rad);\n    return rotateEx(point, cos, sin, center);\n  }\n\n  Point.rotate = rotate;\n\n  function rotateEx(point, cos, sin) {\n    let center = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Point();\n    const source = clone(point);\n    const origin = clone(center);\n    const dx = source.x - origin.x;\n    const dy = source.y - origin.y;\n    const x1 = dx * cos - dy * sin;\n    const y1 = dy * cos + dx * sin;\n    return new Point(x1 + origin.x, y1 + origin.y);\n  }\n\n  Point.rotateEx = rotateEx;\n})(Point || (Point = {}));","map":{"version":3,"sources":["../../src/geometry/point.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as util from './util';\nimport { Angle } from './angle';\nimport { Geometry } from './geometry';\nexport class Point extends Geometry {\n    constructor(x, y) {\n        super();\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n    }\n    get [Symbol.toStringTag]() {\n        return Point.toStringTag;\n    }\n    /**\n     * Rounds the point to the given precision.\n     */\n    round(precision = 0) {\n        this.x = util.round(this.x, precision);\n        this.y = util.round(this.y, precision);\n        return this;\n    }\n    add(x, y) {\n        const p = Point.create(x, y);\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    }\n    update(x, y) {\n        const p = Point.create(x, y);\n        this.x = p.x;\n        this.y = p.y;\n        return this;\n    }\n    translate(dx, dy) {\n        const t = Point.create(dx, dy);\n        this.x += t.x;\n        this.y += t.y;\n        return this;\n    }\n    /**\n     * Rotate the point by `degree` around `center`.\n     */\n    rotate(degree, center) {\n        const p = Point.rotate(this, degree, center);\n        this.x = p.x;\n        this.y = p.y;\n        return this;\n    }\n    /**\n     * Scale point by `sx` and `sy` around the given `origin`. If origin is not\n     * specified, the point is scaled around `0,0`.\n     */\n    scale(sx, sy, origin = new Point()) {\n        const ref = Point.create(origin);\n        this.x = ref.x + sx * (this.x - ref.x);\n        this.y = ref.y + sy * (this.y - ref.y);\n        return this;\n    }\n    /**\n     * Chooses the point closest to this point from among `points`. If `points`\n     * is an empty array, `null` is returned.\n     */\n    closest(points) {\n        if (points.length === 1) {\n            return Point.create(points[0]);\n        }\n        let ret = null;\n        let min = Infinity;\n        points.forEach((p) => {\n            const dist = this.squaredDistance(p);\n            if (dist < min) {\n                ret = p;\n                min = dist;\n            }\n        });\n        return ret ? Point.create(ret) : null;\n    }\n    /**\n     * Returns the distance between the point and another point `p`.\n     */\n    distance(p) {\n        return Math.sqrt(this.squaredDistance(p));\n    }\n    /**\n     * Returns the squared distance between the point and another point `p`.\n     *\n     * Useful for distance comparisons in which real distance is not necessary\n     * (saves one `Math.sqrt()` operation).\n     */\n    squaredDistance(p) {\n        const ref = Point.create(p);\n        const dx = this.x - ref.x;\n        const dy = this.y - ref.y;\n        return dx * dx + dy * dy;\n    }\n    manhattanDistance(p) {\n        const ref = Point.create(p);\n        return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);\n    }\n    /**\n     * Returns the magnitude of the point vector.\n     *\n     * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)\n     */\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;\n    }\n    /**\n     * Returns the angle(in degrees) between vector from this point to `p` and\n     * the x-axis.\n     */\n    theta(p = new Point()) {\n        const ref = Point.create(p);\n        const y = -(ref.y - this.y); // invert the y-axis.\n        const x = ref.x - this.x;\n        let rad = Math.atan2(y, x);\n        // Correction for III. and IV. quadrant.\n        if (rad < 0) {\n            rad = 2 * Math.PI + rad;\n        }\n        return (180 * rad) / Math.PI;\n    }\n    /**\n     * Returns the angle(in degrees) between vector from this point to `p1` and\n     * the vector from this point to `p2`.\n     *\n     * The ordering of points `p1` and `p2` is important.\n     *\n     * The function returns a value between `0` and `180` when the angle (in the\n     * direction from `p1` to `p2`) is clockwise, and a value between `180` and\n     * `360` when the angle is counterclockwise.\n     *\n     * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.\n     */\n    angleBetween(p1, p2) {\n        if (this.equals(p1) || this.equals(p2)) {\n            return NaN;\n        }\n        let angle = this.theta(p2) - this.theta(p1);\n        if (angle < 0) {\n            angle += 360;\n        }\n        return angle;\n    }\n    /**\n     * Returns the angle(in degrees) between the line from `(0,0)` and this point\n     * and the line from `(0,0)` to `p`.\n     *\n     * The function returns a value between `0` and `180` when the angle (in the\n     * direction from this point to `p`) is clockwise, and a value between `180`\n     * and `360` when the angle is counterclockwise. Returns `NaN` if called from\n     * point `(0,0)` or if `p` is `(0,0)`.\n     */\n    vectorAngle(p) {\n        const zero = new Point(0, 0);\n        return zero.angleBetween(this, p);\n    }\n    /**\n     * Converts rectangular to polar coordinates.\n     */\n    toPolar(origin) {\n        this.update(Point.toPolar(this, origin));\n        return this;\n    }\n    /**\n     * Returns the change in angle(in degrees) that is the result of moving the\n     * point from its previous position to its current position.\n     *\n     * More specifically, this function computes the angle between the line from\n     * the ref point to the previous position of this point(i.e. current position\n     * `-dx`, `-dy`) and the line from the `ref` point to the current position of\n     * this point.\n     *\n     * The function returns a positive value between `0` and `180` when the angle\n     * (in the direction from previous position of this point to its current\n     * position) is clockwise, and a negative value between `0` and `-180` when\n     * the angle is counterclockwise.\n     *\n     * The function returns `0` if the previous and current positions of this\n     * point are the same (i.e. both `dx` and `dy` are `0`).\n     */\n    changeInAngle(dx, dy, ref = new Point()) {\n        // Revert the translation and measure the change in angle around x-axis.\n        return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);\n    }\n    /**\n     * If the point lies outside the rectangle `rect`, adjust the point so that\n     * it becomes the nearest point on the boundary of `rect`.\n     */\n    adhereToRect(rect) {\n        if (!util.containsPoint(rect, this)) {\n            this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);\n            this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);\n        }\n        return this;\n    }\n    /**\n     * Returns the bearing(cardinal direction) between me and the given point.\n     *\n     * @see https://en.wikipedia.org/wiki/Cardinal_direction\n     */\n    bearing(p) {\n        const ref = Point.create(p);\n        const lat1 = Angle.toRad(this.y);\n        const lat2 = Angle.toRad(ref.y);\n        const lon1 = this.x;\n        const lon2 = ref.x;\n        const dLon = Angle.toRad(lon2 - lon1);\n        const y = Math.sin(dLon) * Math.cos(lat2);\n        const x = Math.cos(lat1) * Math.sin(lat2) -\n            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n        const brng = Angle.toDeg(Math.atan2(y, x));\n        const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n        let index = brng - 22.5;\n        if (index < 0) {\n            index += 360;\n        }\n        index = parseInt((index / 45), 10);\n        return bearings[index];\n    }\n    /**\n     * Returns the cross product of the vector from me to `p1` and the vector\n     * from me to `p2`.\n     *\n     * The left-hand rule is used because the coordinate system is left-handed.\n     */\n    cross(p1, p2) {\n        if (p1 != null && p2 != null) {\n            const a = Point.create(p1);\n            const b = Point.create(p2);\n            return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);\n        }\n        return NaN;\n    }\n    /**\n     * Returns the dot product of this point with given other point.\n     */\n    dot(p) {\n        const ref = Point.create(p);\n        return this.x * ref.x + this.y * ref.y;\n    }\n    diff(dx, dy) {\n        if (typeof dx === 'number') {\n            return new Point(this.x - dx, this.y - dy);\n        }\n        const p = Point.create(dx);\n        return new Point(this.x - p.x, this.y - p.y);\n    }\n    /**\n     * Returns an interpolation between me and point `p` for a parametert in\n     * the closed interval `[0, 1]`.\n     */\n    lerp(p, t) {\n        const ref = Point.create(p);\n        return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);\n    }\n    /**\n     * Normalize the point vector, scale the line segment between `(0, 0)`\n     * and the point in order for it to have the given length. If length is\n     * not specified, it is considered to be `1`; in that case, a unit vector\n     * is computed.\n     */\n    normalize(length = 1) {\n        const scale = length / this.magnitude();\n        return this.scale(scale, scale);\n    }\n    /**\n     * Moves this point along the line starting from `ref` to this point by a\n     * certain `distance`.\n     */\n    move(ref, distance) {\n        const p = Point.create(ref);\n        const rad = Angle.toRad(p.theta(this));\n        return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);\n    }\n    /**\n     * Returns a point that is the reflection of me with the center of inversion\n     * in `ref` point.\n     */\n    reflection(ref) {\n        return Point.create(ref).move(this, this.distance(ref));\n    }\n    snapToGrid(gx, gy) {\n        this.x = util.snapToGrid(this.x, gx);\n        this.y = util.snapToGrid(this.y, gy == null ? gx : gy);\n        return this;\n    }\n    equals(p) {\n        const ref = Point.create(p);\n        return ref != null && ref.x === this.x && ref.y === this.y;\n    }\n    clone() {\n        return Point.clone(this);\n    }\n    /**\n     * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.\n     */\n    toJSON() {\n        return Point.toJSON(this);\n    }\n    serialize() {\n        return `${this.x} ${this.y}`;\n    }\n}\n(function (Point) {\n    Point.toStringTag = `X6.Geometry.${Point.name}`;\n    function isPoint(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Point) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const point = instance;\n        if ((tag == null || tag === Point.toStringTag) &&\n            typeof point.x === 'number' &&\n            typeof point.y === 'number' &&\n            typeof point.toPolar === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Point.isPoint = isPoint;\n})(Point || (Point = {}));\n(function (Point) {\n    function isPointLike(p) {\n        return (p != null &&\n            typeof p === 'object' &&\n            typeof p.x === 'number' &&\n            typeof p.y === 'number');\n    }\n    Point.isPointLike = isPointLike;\n    function isPointData(p) {\n        return (p != null &&\n            Array.isArray(p) &&\n            p.length === 2 &&\n            typeof p[0] === 'number' &&\n            typeof p[1] === 'number');\n    }\n    Point.isPointData = isPointData;\n})(Point || (Point = {}));\n(function (Point) {\n    function create(x, y) {\n        if (x == null || typeof x === 'number') {\n            return new Point(x, y);\n        }\n        return clone(x);\n    }\n    Point.create = create;\n    function clone(p) {\n        if (Point.isPoint(p)) {\n            return new Point(p.x, p.y);\n        }\n        if (Array.isArray(p)) {\n            return new Point(p[0], p[1]);\n        }\n        return new Point(p.x, p.y);\n    }\n    Point.clone = clone;\n    function toJSON(p) {\n        if (Point.isPoint(p)) {\n            return { x: p.x, y: p.y };\n        }\n        if (Array.isArray(p)) {\n            return { x: p[0], y: p[1] };\n        }\n        return { x: p.x, y: p.y };\n    }\n    Point.toJSON = toJSON;\n    /**\n     * Returns a new Point object from the given polar coordinates.\n     * @see http://en.wikipedia.org/wiki/Polar_coordinate_system\n     */\n    function fromPolar(r, rad, origin = new Point()) {\n        let x = Math.abs(r * Math.cos(rad));\n        let y = Math.abs(r * Math.sin(rad));\n        const org = clone(origin);\n        const deg = Angle.normalize(Angle.toDeg(rad));\n        if (deg < 90) {\n            y = -y;\n        }\n        else if (deg < 180) {\n            x = -x;\n            y = -y;\n        }\n        else if (deg < 270) {\n            x = -x;\n        }\n        return new Point(org.x + x, org.y + y);\n    }\n    Point.fromPolar = fromPolar;\n    /**\n     * Converts rectangular to polar coordinates.\n     */\n    function toPolar(point, origin = new Point()) {\n        const p = clone(point);\n        const o = clone(origin);\n        const dx = p.x - o.x;\n        const dy = p.y - o.y;\n        return new Point(Math.sqrt(dx * dx + dy * dy), // r\n        Angle.toRad(o.theta(p)));\n    }\n    Point.toPolar = toPolar;\n    function equals(p1, p2) {\n        if (p1 === p2) {\n            return true;\n        }\n        if (p1 != null && p2 != null) {\n            return p1.x === p2.x && p1.y === p2.y;\n        }\n        return false;\n    }\n    Point.equals = equals;\n    function equalPoints(p1, p2) {\n        if ((p1 == null && p2 != null) ||\n            (p1 != null && p2 == null) ||\n            (p1 != null && p2 != null && p1.length !== p2.length)) {\n            return false;\n        }\n        if (p1 != null && p2 != null) {\n            for (let i = 0, ii = p1.length; i < ii; i += 1) {\n                if (!equals(p1[i], p2[i])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    Point.equalPoints = equalPoints;\n    /**\n     * Returns a point with random coordinates that fall within the range\n     * `[x1, x2]` and `[y1, y2]`.\n     */\n    function random(x1, x2, y1, y2) {\n        return new Point(util.random(x1, x2), util.random(y1, y2));\n    }\n    Point.random = random;\n    function rotate(point, angle, center) {\n        const rad = Angle.toRad(Angle.normalize(-angle));\n        const sin = Math.sin(rad);\n        const cos = Math.cos(rad);\n        return rotateEx(point, cos, sin, center);\n    }\n    Point.rotate = rotate;\n    function rotateEx(point, cos, sin, center = new Point()) {\n        const source = clone(point);\n        const origin = clone(center);\n        const dx = source.x - origin.x;\n        const dy = source.y - origin.y;\n        const x1 = dx * cos - dy * sin;\n        const y1 = dy * cos + dx * sin;\n        return new Point(x1 + origin.x, y1 + origin.y);\n    }\n    Point.rotateEx = rotateEx;\n})(Point || (Point = {}));\n//# sourceMappingURL=point.js.map"]},"metadata":{},"sourceType":"module"}