{"ast":null,"code":"import { Angle } from '../../geometry';\nimport { resolve } from './util';\n\nconst orthogonal = function (view, magnet, refPoint, options) {\n  const angle = view.cell.getAngle();\n  const bbox = view.getBBoxOfElement(magnet);\n  const result = bbox.getCenter();\n  const topLeft = bbox.getTopLeft();\n  const bottomRight = bbox.getBottomRight();\n  let padding = options.padding;\n\n  if (!Number.isFinite(padding)) {\n    padding = 0;\n  }\n\n  if (topLeft.y + padding <= refPoint.y && refPoint.y <= bottomRight.y - padding) {\n    const dy = refPoint.y - result.y;\n    result.x += angle === 0 || angle === 180 ? 0 : dy * 1 / Math.tan(Angle.toRad(angle));\n    result.y += dy;\n  } else if (topLeft.x + padding <= refPoint.x && refPoint.x <= bottomRight.x - padding) {\n    const dx = refPoint.x - result.x;\n    result.y += angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle));\n    result.x += dx;\n  }\n\n  return result;\n};\n/**\n * Tries to place the anchor of the edge inside the view bbox so that the\n * edge is made orthogonal. The anchor is placed along two line segments\n * inside the view bbox (between the centers of the top and bottom side and\n * between the centers of the left and right sides). If it is not possible\n * to place the anchor so that the edge would be orthogonal, the anchor is\n * placed at the center of the view bbox instead.\n */\n\n\nexport const orth = resolve(orthogonal);","map":{"version":3,"sources":["../../../src/registry/node-anchor/orth.ts"],"names":[],"mappings":"AAAA,SAAS,KAAT,QAAsB,gBAAtB;AACA,SAAyB,OAAzB,QAAwC,QAAxC;;AAOA,MAAM,UAAU,GACd,UAAU,IAAV,EAAgB,MAAhB,EAAwB,QAAxB,EAAkC,OAAlC,EAAyC;AACvC,QAAM,KAAK,GAAG,IAAI,CAAC,IAAL,CAAU,QAAV,EAAd;AACA,QAAM,IAAI,GAAG,IAAI,CAAC,gBAAL,CAAsB,MAAtB,CAAb;AACA,QAAM,MAAM,GAAG,IAAI,CAAC,SAAL,EAAf;AACA,QAAM,OAAO,GAAG,IAAI,CAAC,UAAL,EAAhB;AACA,QAAM,WAAW,GAAG,IAAI,CAAC,cAAL,EAApB;AAEA,MAAI,OAAO,GAAG,OAAO,CAAC,OAAtB;;AACA,MAAI,CAAC,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAAL,EAA+B;AAC7B,IAAA,OAAO,GAAG,CAAV;AACD;;AAED,MACE,OAAO,CAAC,CAAR,GAAY,OAAZ,IAAuB,QAAQ,CAAC,CAAhC,IACA,QAAQ,CAAC,CAAT,IAAc,WAAW,CAAC,CAAZ,GAAgB,OAFhC,EAGE;AACA,UAAM,EAAE,GAAG,QAAQ,CAAC,CAAT,GAAa,MAAM,CAAC,CAA/B;AACA,IAAA,MAAM,CAAC,CAAP,IACE,KAAK,KAAK,CAAV,IAAe,KAAK,KAAK,GAAzB,GACI,CADJ,GAEK,EAAE,GAAG,CAAN,GAAW,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,KAAN,CAAY,KAAZ,CAAT,CAHjB;AAIA,IAAA,MAAM,CAAC,CAAP,IAAY,EAAZ;AACD,GAVD,MAUO,IACL,OAAO,CAAC,CAAR,GAAY,OAAZ,IAAuB,QAAQ,CAAC,CAAhC,IACA,QAAQ,CAAC,CAAT,IAAc,WAAW,CAAC,CAAZ,GAAgB,OAFzB,EAGL;AACA,UAAM,EAAE,GAAG,QAAQ,CAAC,CAAT,GAAa,MAAM,CAAC,CAA/B;AACA,IAAA,MAAM,CAAC,CAAP,IACE,KAAK,KAAK,EAAV,IAAgB,KAAK,KAAK,GAA1B,GAAgC,CAAhC,GAAoC,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,KAAK,CAAC,KAAN,CAAY,KAAZ,CAAT,CAD3C;AAEA,IAAA,MAAM,CAAC,CAAP,IAAY,EAAZ;AACD;;AAED,SAAO,MAAP;AACD,CAlCH;AAoCA;;;;;;;AAOG;;;AACH,OAAO,MAAM,IAAI,GAAG,OAAO,CAGzB,UAHyB,CAApB","sourceRoot":"","sourcesContent":["import { Angle } from '../../geometry';\nimport { resolve } from './util';\nconst orthogonal = function (view, magnet, refPoint, options) {\n    const angle = view.cell.getAngle();\n    const bbox = view.getBBoxOfElement(magnet);\n    const result = bbox.getCenter();\n    const topLeft = bbox.getTopLeft();\n    const bottomRight = bbox.getBottomRight();\n    let padding = options.padding;\n    if (!Number.isFinite(padding)) {\n        padding = 0;\n    }\n    if (topLeft.y + padding <= refPoint.y &&\n        refPoint.y <= bottomRight.y - padding) {\n        const dy = refPoint.y - result.y;\n        result.x +=\n            angle === 0 || angle === 180\n                ? 0\n                : (dy * 1) / Math.tan(Angle.toRad(angle));\n        result.y += dy;\n    }\n    else if (topLeft.x + padding <= refPoint.x &&\n        refPoint.x <= bottomRight.x - padding) {\n        const dx = refPoint.x - result.x;\n        result.y +=\n            angle === 90 || angle === 270 ? 0 : dx * Math.tan(Angle.toRad(angle));\n        result.x += dx;\n    }\n    return result;\n};\n/**\n * Tries to place the anchor of the edge inside the view bbox so that the\n * edge is made orthogonal. The anchor is placed along two line segments\n * inside the view bbox (between the centers of the top and bottom side and\n * between the centers of the left and right sides). If it is not possible\n * to place the anchor so that the edge would be orthogonal, the anchor is\n * placed at the center of the view bbox instead.\n */\nexport const orth = resolve(orthogonal);\n//# sourceMappingURL=orth.js.map"]},"metadata":{},"sourceType":"module"}