{"ast":null,"code":"import { ArrayExt } from '../../../util';\nimport { Point } from '../../../geometry';\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\n\nexport class ObstacleMap {\n  constructor(options) {\n    this.options = options;\n    this.mapGridSize = 100;\n    this.map = {};\n  }\n  /**\n   * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n   * contained in any obstacle?\n   *\n   * A simplified grid search.\n   */\n\n\n  build(model, edge) {\n    const options = this.options; // source or target node could be excluded from set of obstacles\n\n    const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {\n      const terminal = edge[type];\n\n      if (terminal) {\n        const cell = model.getCell(terminal.cell);\n\n        if (cell) {\n          memo.push(cell);\n        }\n      }\n\n      return memo;\n    }, []);\n    let excludedAncestors = [];\n    const source = model.getCell(edge.getSourceCellId());\n\n    if (source) {\n      excludedAncestors = ArrayExt.union(excludedAncestors, source.getAncestors().map(cell => cell.id));\n    }\n\n    const target = model.getCell(edge.getTargetCellId());\n\n    if (target) {\n      excludedAncestors = ArrayExt.union(excludedAncestors, target.getAncestors().map(cell => cell.id));\n    } // The graph is divided into smaller cells, where each holds information\n    // about which node belong to it. When we query whether a point lies\n    // inside an obstacle we don't need to go through all obstacles, we check\n    // only those in a particular cell.\n\n\n    const mapGridSize = this.mapGridSize;\n    model.getNodes().reduce((map, node) => {\n      const shape = node.shape;\n      const excludeShapes = options.excludeShapes;\n      const excType = shape ? excludeShapes.includes(shape) : false;\n      const excTerminal = excludedTerminals.some(cell => cell.id === node.id);\n      const excAncestor = excludedAncestors.includes(node.id);\n      const excHidden = options.excludeHiddenNodes && !node.isVisible();\n      const excluded = excType || excTerminal || excAncestor || excHidden;\n\n      if (!excluded) {\n        const bbox = node.getBBox().moveAndExpand(options.paddingBox);\n        const origin = bbox.getOrigin().snapToGrid(mapGridSize);\n        const corner = bbox.getCorner().snapToGrid(mapGridSize);\n\n        for (let x = origin.x; x <= corner.x; x += mapGridSize) {\n          for (let y = origin.y; y <= corner.y; y += mapGridSize) {\n            const key = new Point(x, y).toString();\n\n            if (map[key] == null) {\n              map[key] = [];\n            }\n\n            map[key].push(bbox);\n          }\n        }\n      }\n\n      return map;\n    }, this.map);\n    return this;\n  }\n\n  isAccessible(point) {\n    const key = point.clone().snapToGrid(this.mapGridSize).toString();\n    const rects = this.map[key];\n    return rects ? rects.every(rect => !rect.containsPoint(point)) : true;\n  }\n\n}","map":{"version":3,"sources":["../../../../src/registry/router/manhattan/obstacle-map.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ArrayExt } from '../../../util';\nimport { Point } from '../../../geometry';\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\nexport class ObstacleMap {\n    constructor(options) {\n        this.options = options;\n        this.mapGridSize = 100;\n        this.map = {};\n    }\n    /**\n     * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n     * contained in any obstacle?\n     *\n     * A simplified grid search.\n     */\n    build(model, edge) {\n        const options = this.options;\n        // source or target node could be excluded from set of obstacles\n        const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {\n            const terminal = edge[type];\n            if (terminal) {\n                const cell = model.getCell(terminal.cell);\n                if (cell) {\n                    memo.push(cell);\n                }\n            }\n            return memo;\n        }, []);\n        let excludedAncestors = [];\n        const source = model.getCell(edge.getSourceCellId());\n        if (source) {\n            excludedAncestors = ArrayExt.union(excludedAncestors, source.getAncestors().map((cell) => cell.id));\n        }\n        const target = model.getCell(edge.getTargetCellId());\n        if (target) {\n            excludedAncestors = ArrayExt.union(excludedAncestors, target.getAncestors().map((cell) => cell.id));\n        }\n        // The graph is divided into smaller cells, where each holds information\n        // about which node belong to it. When we query whether a point lies\n        // inside an obstacle we don't need to go through all obstacles, we check\n        // only those in a particular cell.\n        const mapGridSize = this.mapGridSize;\n        model.getNodes().reduce((map, node) => {\n            const shape = node.shape;\n            const excludeShapes = options.excludeShapes;\n            const excType = shape ? excludeShapes.includes(shape) : false;\n            const excTerminal = excludedTerminals.some((cell) => cell.id === node.id);\n            const excAncestor = excludedAncestors.includes(node.id);\n            const excHidden = options.excludeHiddenNodes && !node.isVisible();\n            const excluded = excType || excTerminal || excAncestor || excHidden;\n            if (!excluded) {\n                const bbox = node.getBBox().moveAndExpand(options.paddingBox);\n                const origin = bbox.getOrigin().snapToGrid(mapGridSize);\n                const corner = bbox.getCorner().snapToGrid(mapGridSize);\n                for (let x = origin.x; x <= corner.x; x += mapGridSize) {\n                    for (let y = origin.y; y <= corner.y; y += mapGridSize) {\n                        const key = new Point(x, y).toString();\n                        if (map[key] == null) {\n                            map[key] = [];\n                        }\n                        map[key].push(bbox);\n                    }\n                }\n            }\n            return map;\n        }, this.map);\n        return this;\n    }\n    isAccessible(point) {\n        const key = point.clone().snapToGrid(this.mapGridSize).toString();\n        const rects = this.map[key];\n        return rects ? rects.every((rect) => !rect.containsPoint(point)) : true;\n    }\n}\n//# sourceMappingURL=obstacle-map.js.map"]},"metadata":{},"sourceType":"module"}