{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { getJudgeFunction } from '../fn';\nimport { requestAnimationFrame } from './animationFrame';\nexport var TouchHandler = /*#__PURE__*/function () {\n  function TouchHandler(options) {\n    var _this = this;\n\n    _classCallCheck(this, TouchHandler);\n\n    this.didTouchMove = function () {\n      // Fire scroll callback based on computed drag delta.\n      // Also track accummulated delta so we can calculate velocity\n      _this.dragAnimationId = null;\n\n      _this.callback(_this.deltaX, _this.deltaY);\n\n      _this.accumulatedDeltaX += _this.deltaX;\n      _this.accumulatedDeltaY += _this.deltaY;\n      _this.deltaX = 0;\n      _this.deltaY = 0;\n    };\n\n    this.track = function () {\n      // Compute velocity based on a weighted average of drag over\n      // last 100ms and previous velocity. Combining into a moving average\n      // results in a smoother scroll.\n      var now = Date.now();\n      var elapsed = now - _this.lastFrameTimestamp;\n      var oldVelocityX = _this.velocityX;\n      var oldVelocityY = _this.velocityY; // We compute velocity using a weighted average of the current\n      // velocity and the previous velocity. If the previous velocity\n      // is 0, put the full weight on the last 100ms\n\n      var weight = 0.8;\n\n      if (elapsed < TouchHandler.TRACKER_TIMEOUT) {\n        weight *= elapsed / TouchHandler.TRACKER_TIMEOUT;\n      }\n\n      if (oldVelocityX === 0 && oldVelocityY === 0) {\n        weight = 1;\n      } // Formula for computing weighted average of velocity\n\n\n      _this.velocityX = weight * (TouchHandler.TRACKER_TIMEOUT * _this.accumulatedDeltaX / (1 + elapsed));\n\n      if (weight < 1) {\n        _this.velocityX += (1 - weight) * oldVelocityX;\n      }\n\n      _this.velocityY = weight * (TouchHandler.TRACKER_TIMEOUT * _this.accumulatedDeltaY / (1 + elapsed));\n\n      if (weight < 1) {\n        _this.velocityY += (1 - weight) * oldVelocityY;\n      }\n\n      _this.accumulatedDeltaX = 0;\n      _this.accumulatedDeltaY = 0;\n      _this.lastFrameTimestamp = now;\n    };\n\n    this.startAutoScroll = function () {\n      // To kick off deceleration / momentum scrolling, handle any\n      // scrolling from a drag which was waiting for an animation\n      // frame. Then update our velocity.\n      // Finally start the momentum scrolling handler (autoScroll)\n      _this.autoScrollTimestamp = Date.now();\n\n      if (_this.deltaX > 0 || _this.deltaY > 0) {\n        _this.didTouchMove();\n      }\n\n      _this.track();\n\n      _this.autoScroll();\n    };\n\n    this.autoScroll = function () {\n      // Compute a scroll delta with an exponential decay based on\n      // time elapsed since drag was released. This is called\n      // recursively on animation frames until the delta is below\n      // a threshold (5 pixels)\n      var elapsed = Date.now() - _this.autoScrollTimestamp;\n\n      var factor = TouchHandler.DECELERATION_AMPLITUDE * Math.exp(-elapsed / TouchHandler.DECELERATION_FACTOR);\n      var deltaX = factor * _this.velocityX;\n      var deltaY = factor * _this.velocityY;\n\n      if (Math.abs(deltaX) <= 5 || !_this.handleScrollX(deltaX, deltaY)) {\n        deltaX = 0;\n      }\n\n      if (Math.abs(deltaY) <= 5 || !_this.handleScrollY(deltaY, deltaX)) {\n        deltaY = 0;\n      }\n\n      if (deltaX !== 0 || deltaY !== 0) {\n        _this.callback(deltaX, deltaY);\n\n        requestAnimationFrame(_this.autoScroll);\n      }\n    };\n\n    this.trackerId = null;\n    this.dragAnimationId = null;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.lastTouchX = 0;\n    this.lastTouchY = 0;\n    this.velocityX = 0;\n    this.velocityY = 0;\n    this.accumulatedDeltaX = 0;\n    this.accumulatedDeltaY = 0;\n    this.lastFrameTimestamp = Date.now();\n    this.autoScrollTimestamp = Date.now();\n    this.callback = options.onTouchScroll;\n    this.handleScrollX = getJudgeFunction(options.shouldHandleScrollX);\n    this.handleScrollY = getJudgeFunction(options.shouldHandleScrollY);\n    this.stopPropagation = getJudgeFunction(options.stopPropagation);\n  }\n\n  _createClass(TouchHandler, [{\n    key: \"onTouchStart\",\n    value: function onTouchStart(e) {\n      this.lastTouchX = e.touches[0].pageX;\n      this.lastTouchY = e.touches[0].pageY;\n      this.velocityX = 0;\n      this.velocityY = 0;\n      this.accumulatedDeltaX = 0;\n      this.accumulatedDeltaY = 0;\n      this.lastFrameTimestamp = Date.now();\n\n      if (this.trackerId != null) {\n        clearInterval(this.trackerId);\n      }\n\n      this.trackerId = window.setInterval(this.track, TouchHandler.TRACKER_TIMEOUT);\n\n      if (this.stopPropagation()) {\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchEnd\",\n    value: function onTouchEnd(e) {\n      this.onTouchCancel(e);\n      requestAnimationFrame(this.startAutoScroll);\n    }\n  }, {\n    key: \"onTouchCancel\",\n    value: function onTouchCancel(e) {\n      if (this.trackerId != null) {\n        clearInterval(this.trackerId);\n        this.trackerId = null;\n      }\n\n      if (this.stopPropagation()) {\n        e.stopPropagation();\n      }\n    }\n  }, {\n    key: \"onTouchMove\",\n    value: function onTouchMove(e) {\n      var moveX = e.touches[0].pageX;\n      var moveY = e.touches[0].pageY; // Compute delta scrolled since last drag\n      // Mobile, scrolling is inverted\n\n      this.deltaX = TouchHandler.MOVE_AMPLITUDE * (this.lastTouchX - moveX);\n      this.deltaY = TouchHandler.MOVE_AMPLITUDE * (this.lastTouchY - moveY);\n      var handleScrollX = this.handleScrollX(this.deltaX, this.deltaY);\n      var handleScrollY = this.handleScrollY(this.deltaY, this.deltaX);\n\n      if (!handleScrollX && !handleScrollY) {\n        return;\n      } // If we can handle scroll update last touch for computing delta\n\n\n      if (handleScrollX) {\n        this.lastTouchX = moveX;\n      } else {\n        this.deltaX = 0;\n      }\n\n      if (handleScrollY) {\n        this.lastTouchY = moveY;\n      } else {\n        this.deltaY = 0;\n      }\n\n      e.preventDefault(); // ensure minimum delta magnitude is met to avoid jitter\n\n      var changed = false;\n\n      if (Math.abs(this.deltaX) > 2 || Math.abs(this.deltaY) > 2) {\n        if (this.stopPropagation()) {\n          e.stopPropagation();\n        }\n\n        changed = true;\n      } // Request animation frame to trigger scroll of computed delta\n\n\n      if (changed && this.dragAnimationId == null) {\n        this.dragAnimationId = requestAnimationFrame(this.didTouchMove);\n      }\n    }\n  }]);\n\n  return TouchHandler;\n}();\n\n(function (TouchHandler) {\n  TouchHandler.MOVE_AMPLITUDE = 1.6;\n  TouchHandler.DECELERATION_AMPLITUDE = 1.6;\n  TouchHandler.DECELERATION_FACTOR = 325;\n  TouchHandler.TRACKER_TIMEOUT = 100;\n})(TouchHandler || (TouchHandler = {}));","map":{"version":3,"sources":["../../../src/util/dom/TouchHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getJudgeFunction } from '../fn';\nimport { requestAnimationFrame } from './animationFrame';\nexport class TouchHandler {\n    constructor(options) {\n        this.didTouchMove = () => {\n            // Fire scroll callback based on computed drag delta.\n            // Also track accummulated delta so we can calculate velocity\n            this.dragAnimationId = null;\n            this.callback(this.deltaX, this.deltaY);\n            this.accumulatedDeltaX += this.deltaX;\n            this.accumulatedDeltaY += this.deltaY;\n            this.deltaX = 0;\n            this.deltaY = 0;\n        };\n        this.track = () => {\n            // Compute velocity based on a weighted average of drag over\n            // last 100ms and previous velocity. Combining into a moving average\n            // results in a smoother scroll.\n            const now = Date.now();\n            const elapsed = now - this.lastFrameTimestamp;\n            const oldVelocityX = this.velocityX;\n            const oldVelocityY = this.velocityY;\n            // We compute velocity using a weighted average of the current\n            // velocity and the previous velocity. If the previous velocity\n            // is 0, put the full weight on the last 100ms\n            let weight = 0.8;\n            if (elapsed < TouchHandler.TRACKER_TIMEOUT) {\n                weight *= elapsed / TouchHandler.TRACKER_TIMEOUT;\n            }\n            if (oldVelocityX === 0 && oldVelocityY === 0) {\n                weight = 1;\n            }\n            // Formula for computing weighted average of velocity\n            this.velocityX =\n                weight *\n                    ((TouchHandler.TRACKER_TIMEOUT * this.accumulatedDeltaX) / (1 + elapsed));\n            if (weight < 1) {\n                this.velocityX += (1 - weight) * oldVelocityX;\n            }\n            this.velocityY =\n                weight *\n                    ((TouchHandler.TRACKER_TIMEOUT * this.accumulatedDeltaY) / (1 + elapsed));\n            if (weight < 1) {\n                this.velocityY += (1 - weight) * oldVelocityY;\n            }\n            this.accumulatedDeltaX = 0;\n            this.accumulatedDeltaY = 0;\n            this.lastFrameTimestamp = now;\n        };\n        this.startAutoScroll = () => {\n            // To kick off deceleration / momentum scrolling, handle any\n            // scrolling from a drag which was waiting for an animation\n            // frame. Then update our velocity.\n            // Finally start the momentum scrolling handler (autoScroll)\n            this.autoScrollTimestamp = Date.now();\n            if (this.deltaX > 0 || this.deltaY > 0) {\n                this.didTouchMove();\n            }\n            this.track();\n            this.autoScroll();\n        };\n        this.autoScroll = () => {\n            // Compute a scroll delta with an exponential decay based on\n            // time elapsed since drag was released. This is called\n            // recursively on animation frames until the delta is below\n            // a threshold (5 pixels)\n            const elapsed = Date.now() - this.autoScrollTimestamp;\n            const factor = TouchHandler.DECELERATION_AMPLITUDE *\n                Math.exp(-elapsed / TouchHandler.DECELERATION_FACTOR);\n            let deltaX = factor * this.velocityX;\n            let deltaY = factor * this.velocityY;\n            if (Math.abs(deltaX) <= 5 || !this.handleScrollX(deltaX, deltaY)) {\n                deltaX = 0;\n            }\n            if (Math.abs(deltaY) <= 5 || !this.handleScrollY(deltaY, deltaX)) {\n                deltaY = 0;\n            }\n            if (deltaX !== 0 || deltaY !== 0) {\n                this.callback(deltaX, deltaY);\n                requestAnimationFrame(this.autoScroll);\n            }\n        };\n        this.trackerId = null;\n        this.dragAnimationId = null;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.lastTouchX = 0;\n        this.lastTouchY = 0;\n        this.velocityX = 0;\n        this.velocityY = 0;\n        this.accumulatedDeltaX = 0;\n        this.accumulatedDeltaY = 0;\n        this.lastFrameTimestamp = Date.now();\n        this.autoScrollTimestamp = Date.now();\n        this.callback = options.onTouchScroll;\n        this.handleScrollX = getJudgeFunction(options.shouldHandleScrollX);\n        this.handleScrollY = getJudgeFunction(options.shouldHandleScrollY);\n        this.stopPropagation = getJudgeFunction(options.stopPropagation);\n    }\n    onTouchStart(e) {\n        this.lastTouchX = e.touches[0].pageX;\n        this.lastTouchY = e.touches[0].pageY;\n        this.velocityX = 0;\n        this.velocityY = 0;\n        this.accumulatedDeltaX = 0;\n        this.accumulatedDeltaY = 0;\n        this.lastFrameTimestamp = Date.now();\n        if (this.trackerId != null) {\n            clearInterval(this.trackerId);\n        }\n        this.trackerId = window.setInterval(this.track, TouchHandler.TRACKER_TIMEOUT);\n        if (this.stopPropagation()) {\n            e.stopPropagation();\n        }\n    }\n    onTouchEnd(e) {\n        this.onTouchCancel(e);\n        requestAnimationFrame(this.startAutoScroll);\n    }\n    onTouchCancel(e) {\n        if (this.trackerId != null) {\n            clearInterval(this.trackerId);\n            this.trackerId = null;\n        }\n        if (this.stopPropagation()) {\n            e.stopPropagation();\n        }\n    }\n    onTouchMove(e) {\n        const moveX = e.touches[0].pageX;\n        const moveY = e.touches[0].pageY;\n        // Compute delta scrolled since last drag\n        // Mobile, scrolling is inverted\n        this.deltaX = TouchHandler.MOVE_AMPLITUDE * (this.lastTouchX - moveX);\n        this.deltaY = TouchHandler.MOVE_AMPLITUDE * (this.lastTouchY - moveY);\n        const handleScrollX = this.handleScrollX(this.deltaX, this.deltaY);\n        const handleScrollY = this.handleScrollY(this.deltaY, this.deltaX);\n        if (!handleScrollX && !handleScrollY) {\n            return;\n        }\n        // If we can handle scroll update last touch for computing delta\n        if (handleScrollX) {\n            this.lastTouchX = moveX;\n        }\n        else {\n            this.deltaX = 0;\n        }\n        if (handleScrollY) {\n            this.lastTouchY = moveY;\n        }\n        else {\n            this.deltaY = 0;\n        }\n        e.preventDefault();\n        // ensure minimum delta magnitude is met to avoid jitter\n        let changed = false;\n        if (Math.abs(this.deltaX) > 2 || Math.abs(this.deltaY) > 2) {\n            if (this.stopPropagation()) {\n                e.stopPropagation();\n            }\n            changed = true;\n        }\n        // Request animation frame to trigger scroll of computed delta\n        if (changed && this.dragAnimationId == null) {\n            this.dragAnimationId = requestAnimationFrame(this.didTouchMove);\n        }\n    }\n}\n(function (TouchHandler) {\n    TouchHandler.MOVE_AMPLITUDE = 1.6;\n    TouchHandler.DECELERATION_AMPLITUDE = 1.6;\n    TouchHandler.DECELERATION_FACTOR = 325;\n    TouchHandler.TRACKER_TIMEOUT = 100;\n})(TouchHandler || (TouchHandler = {}));\n//# sourceMappingURL=TouchHandler.js.map"]},"metadata":{},"sourceType":"module"}