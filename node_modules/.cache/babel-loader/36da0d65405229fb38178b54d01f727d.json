{"ast":null,"code":"import { Path, Point } from '../../geometry';\nexport const loop = function (sourcePoint, targetPoint, routePoints) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const fix = routePoints.length === 3 ? 0 : 1;\n  const p1 = Point.create(routePoints[0 + fix]);\n  const p2 = Point.create(routePoints[2 + fix]);\n  const center = Point.create(routePoints[1 + fix]);\n\n  if (!Point.equals(sourcePoint, targetPoint)) {\n    const middle = new Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);\n    const angle = middle.angleBetween(Point.create(sourcePoint).rotate(90, middle), center);\n\n    if (angle > 1) {\n      p1.rotate(180 - angle, middle);\n      p2.rotate(180 - angle, middle);\n      center.rotate(180 - angle, middle);\n    }\n  }\n\n  const pathData = `\n     M ${sourcePoint.x} ${sourcePoint.y}\n     Q ${p1.x} ${p1.y} ${center.x} ${center.y}\n     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}\n  `;\n  return options.raw ? Path.parse(pathData) : pathData;\n};","map":{"version":3,"sources":["../../../src/registry/connector/loop.ts"],"names":[],"mappings":"AAAA,SAAS,IAAT,EAAe,KAAf,QAA4B,gBAA5B;AAOA,OAAO,MAAM,IAAI,GAA+C,UAC9D,WAD8D,EAE9D,WAF8D,EAG9D,WAH8D,EAIlD;AAAA,MAAZ,OAAY,uEAAF,EAAE;AAEZ,QAAM,GAAG,GAAG,WAAW,CAAC,MAAZ,KAAuB,CAAvB,GAA2B,CAA3B,GAA+B,CAA3C;AACA,QAAM,EAAE,GAAG,KAAK,CAAC,MAAN,CAAa,WAAW,CAAC,IAAI,GAAL,CAAxB,CAAX;AACA,QAAM,EAAE,GAAG,KAAK,CAAC,MAAN,CAAa,WAAW,CAAC,IAAI,GAAL,CAAxB,CAAX;AACA,QAAM,MAAM,GAAG,KAAK,CAAC,MAAN,CAAa,WAAW,CAAC,IAAI,GAAL,CAAxB,CAAf;;AAEA,MAAI,CAAC,KAAK,CAAC,MAAN,CAAa,WAAb,EAA0B,WAA1B,CAAL,EAA6C;AAC3C,UAAM,MAAM,GAAG,IAAI,KAAJ,CACb,CAAC,WAAW,CAAC,CAAZ,GAAgB,WAAW,CAAC,CAA7B,IAAkC,CADrB,EAEb,CAAC,WAAW,CAAC,CAAZ,GAAgB,WAAW,CAAC,CAA7B,IAAkC,CAFrB,CAAf;AAIA,UAAM,KAAK,GAAG,MAAM,CAAC,YAAP,CACZ,KAAK,CAAC,MAAN,CAAa,WAAb,EAA0B,MAA1B,CAAiC,EAAjC,EAAqC,MAArC,CADY,EAEZ,MAFY,CAAd;;AAIA,QAAI,KAAK,GAAG,CAAZ,EAAe;AACb,MAAA,EAAE,CAAC,MAAH,CAAU,MAAM,KAAhB,EAAuB,MAAvB;AACA,MAAA,EAAE,CAAC,MAAH,CAAU,MAAM,KAAhB,EAAuB,MAAvB;AACA,MAAA,MAAM,CAAC,MAAP,CAAc,MAAM,KAApB,EAA2B,MAA3B;AACD;AACF;;AAED,QAAM,QAAQ,GAAG;SACV,WAAW,CAAC,CAAC,IAAI,WAAW,CAAC,CAAC;SAC9B,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC,IAAI,MAAM,CAAC,CAAC;SACpC,EAAE,CAAC,CAAC,IAAI,EAAE,CAAC,CAAC,IAAI,WAAW,CAAC,CAAC,IAAI,WAAW,CAAC,CAAC;AACpD,GAJD;AAMA,SAAO,OAAO,CAAC,GAAR,GAAc,IAAI,CAAC,KAAL,CAAW,QAAX,CAAd,GAAqC,QAA5C;AACD,CAlCM","sourceRoot":"","sourcesContent":["import { Path, Point } from '../../geometry';\nexport const loop = function (sourcePoint, targetPoint, routePoints, options = {}) {\n    const fix = routePoints.length === 3 ? 0 : 1;\n    const p1 = Point.create(routePoints[0 + fix]);\n    const p2 = Point.create(routePoints[2 + fix]);\n    const center = Point.create(routePoints[1 + fix]);\n    if (!Point.equals(sourcePoint, targetPoint)) {\n        const middle = new Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);\n        const angle = middle.angleBetween(Point.create(sourcePoint).rotate(90, middle), center);\n        if (angle > 1) {\n            p1.rotate(180 - angle, middle);\n            p2.rotate(180 - angle, middle);\n            center.rotate(180 - angle, middle);\n        }\n    }\n    const pathData = `\n     M ${sourcePoint.x} ${sourcePoint.y}\n     Q ${p1.x} ${p1.y} ${center.x} ${center.y}\n     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}\n  `;\n    return options.raw ? Path.parse(pathData) : pathData;\n};\n//# sourceMappingURL=loop.js.map"]},"metadata":{},"sourceType":"module"}