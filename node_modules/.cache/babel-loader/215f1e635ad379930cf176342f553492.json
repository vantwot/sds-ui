{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport * as util from './util';\nimport { Angle } from './angle';\nimport { Geometry } from './geometry';\nexport var Point = /*#__PURE__*/function (_Geometry, _Symbol$toStringTag) {\n  _inherits(Point, _Geometry);\n\n  var _super = _createSuper(Point);\n\n  function Point(x, y) {\n    var _this;\n\n    _classCallCheck(this, Point);\n\n    _this = _super.call(this);\n    _this.x = x == null ? 0 : x;\n    _this.y = y == null ? 0 : y;\n    return _this;\n  }\n\n  _createClass(Point, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Point.toStringTag;\n    }\n    /**\n     * Rounds the point to the given precision.\n     */\n\n  }, {\n    key: \"round\",\n    value: function round() {\n      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.x = util.round(this.x, precision);\n      this.y = util.round(this.y, precision);\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(x, y) {\n      var p = Point.create(x, y);\n      this.x += p.x;\n      this.y += p.y;\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update(x, y) {\n      var p = Point.create(x, y);\n      this.x = p.x;\n      this.y = p.y;\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(dx, dy) {\n      var t = Point.create(dx, dy);\n      this.x += t.x;\n      this.y += t.y;\n      return this;\n    }\n    /**\n     * Rotate the point by `degree` around `center`.\n     */\n\n  }, {\n    key: \"rotate\",\n    value: function rotate(degree, center) {\n      var p = Point.rotate(this, degree, center);\n      this.x = p.x;\n      this.y = p.y;\n      return this;\n    }\n    /**\n     * Scale point by `sx` and `sy` around the given `origin`. If origin is not\n     * specified, the point is scaled around `0,0`.\n     */\n\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n      var ref = Point.create(origin);\n      this.x = ref.x + sx * (this.x - ref.x);\n      this.y = ref.y + sy * (this.y - ref.y);\n      return this;\n    }\n    /**\n     * Chooses the point closest to this point from among `points`. If `points`\n     * is an empty array, `null` is returned.\n     */\n\n  }, {\n    key: \"closest\",\n    value: function closest(points) {\n      var _this2 = this;\n\n      if (points.length === 1) {\n        return Point.create(points[0]);\n      }\n\n      var ret = null;\n      var min = Infinity;\n      points.forEach(function (p) {\n        var dist = _this2.squaredDistance(p);\n\n        if (dist < min) {\n          ret = p;\n          min = dist;\n        }\n      });\n      return ret ? Point.create(ret) : null;\n    }\n    /**\n     * Returns the distance between the point and another point `p`.\n     */\n\n  }, {\n    key: \"distance\",\n    value: function distance(p) {\n      return Math.sqrt(this.squaredDistance(p));\n    }\n    /**\n     * Returns the squared distance between the point and another point `p`.\n     *\n     * Useful for distance comparisons in which real distance is not necessary\n     * (saves one `Math.sqrt()` operation).\n     */\n\n  }, {\n    key: \"squaredDistance\",\n    value: function squaredDistance(p) {\n      var ref = Point.create(p);\n      var dx = this.x - ref.x;\n      var dy = this.y - ref.y;\n      return dx * dx + dy * dy;\n    }\n  }, {\n    key: \"manhattanDistance\",\n    value: function manhattanDistance(p) {\n      var ref = Point.create(p);\n      return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);\n    }\n    /**\n     * Returns the magnitude of the point vector.\n     *\n     * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)\n     */\n\n  }, {\n    key: \"magnitude\",\n    value: function magnitude() {\n      return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;\n    }\n    /**\n     * Returns the angle(in degrees) between vector from this point to `p` and\n     * the x-axis.\n     */\n\n  }, {\n    key: \"theta\",\n    value: function theta() {\n      var p = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Point();\n      var ref = Point.create(p);\n      var y = -(ref.y - this.y); // invert the y-axis.\n\n      var x = ref.x - this.x;\n      var rad = Math.atan2(y, x); // Correction for III. and IV. quadrant.\n\n      if (rad < 0) {\n        rad = 2 * Math.PI + rad;\n      }\n\n      return 180 * rad / Math.PI;\n    }\n    /**\n     * Returns the angle(in degrees) between vector from this point to `p1` and\n     * the vector from this point to `p2`.\n     *\n     * The ordering of points `p1` and `p2` is important.\n     *\n     * The function returns a value between `0` and `180` when the angle (in the\n     * direction from `p1` to `p2`) is clockwise, and a value between `180` and\n     * `360` when the angle is counterclockwise.\n     *\n     * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.\n     */\n\n  }, {\n    key: \"angleBetween\",\n    value: function angleBetween(p1, p2) {\n      if (this.equals(p1) || this.equals(p2)) {\n        return NaN;\n      }\n\n      var angle = this.theta(p2) - this.theta(p1);\n\n      if (angle < 0) {\n        angle += 360;\n      }\n\n      return angle;\n    }\n    /**\n     * Returns the angle(in degrees) between the line from `(0,0)` and this point\n     * and the line from `(0,0)` to `p`.\n     *\n     * The function returns a value between `0` and `180` when the angle (in the\n     * direction from this point to `p`) is clockwise, and a value between `180`\n     * and `360` when the angle is counterclockwise. Returns `NaN` if called from\n     * point `(0,0)` or if `p` is `(0,0)`.\n     */\n\n  }, {\n    key: \"vectorAngle\",\n    value: function vectorAngle(p) {\n      var zero = new Point(0, 0);\n      return zero.angleBetween(this, p);\n    }\n    /**\n     * Converts rectangular to polar coordinates.\n     */\n\n  }, {\n    key: \"toPolar\",\n    value: function toPolar(origin) {\n      this.update(Point.toPolar(this, origin));\n      return this;\n    }\n    /**\n     * Returns the change in angle(in degrees) that is the result of moving the\n     * point from its previous position to its current position.\n     *\n     * More specifically, this function computes the angle between the line from\n     * the ref point to the previous position of this point(i.e. current position\n     * `-dx`, `-dy`) and the line from the `ref` point to the current position of\n     * this point.\n     *\n     * The function returns a positive value between `0` and `180` when the angle\n     * (in the direction from previous position of this point to its current\n     * position) is clockwise, and a negative value between `0` and `-180` when\n     * the angle is counterclockwise.\n     *\n     * The function returns `0` if the previous and current positions of this\n     * point are the same (i.e. both `dx` and `dy` are `0`).\n     */\n\n  }, {\n    key: \"changeInAngle\",\n    value: function changeInAngle(dx, dy) {\n      var ref = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n      // Revert the translation and measure the change in angle around x-axis.\n      return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);\n    }\n    /**\n     * If the point lies outside the rectangle `rect`, adjust the point so that\n     * it becomes the nearest point on the boundary of `rect`.\n     */\n\n  }, {\n    key: \"adhereToRect\",\n    value: function adhereToRect(rect) {\n      if (!util.containsPoint(rect, this)) {\n        this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);\n        this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);\n      }\n\n      return this;\n    }\n    /**\n     * Returns the bearing(cardinal direction) between me and the given point.\n     *\n     * @see https://en.wikipedia.org/wiki/Cardinal_direction\n     */\n\n  }, {\n    key: \"bearing\",\n    value: function bearing(p) {\n      var ref = Point.create(p);\n      var lat1 = Angle.toRad(this.y);\n      var lat2 = Angle.toRad(ref.y);\n      var lon1 = this.x;\n      var lon2 = ref.x;\n      var dLon = Angle.toRad(lon2 - lon1);\n      var y = Math.sin(dLon) * Math.cos(lat2);\n      var x = Math.cos(lat1) * Math.sin(lat2) - Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n      var brng = Angle.toDeg(Math.atan2(y, x));\n      var bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n      var index = brng - 22.5;\n\n      if (index < 0) {\n        index += 360;\n      }\n\n      index = parseInt(index / 45, 10);\n      return bearings[index];\n    }\n    /**\n     * Returns the cross product of the vector from me to `p1` and the vector\n     * from me to `p2`.\n     *\n     * The left-hand rule is used because the coordinate system is left-handed.\n     */\n\n  }, {\n    key: \"cross\",\n    value: function cross(p1, p2) {\n      if (p1 != null && p2 != null) {\n        var a = Point.create(p1);\n        var b = Point.create(p2);\n        return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);\n      }\n\n      return NaN;\n    }\n    /**\n     * Returns the dot product of this point with given other point.\n     */\n\n  }, {\n    key: \"dot\",\n    value: function dot(p) {\n      var ref = Point.create(p);\n      return this.x * ref.x + this.y * ref.y;\n    }\n  }, {\n    key: \"diff\",\n    value: function diff(dx, dy) {\n      if (typeof dx === 'number') {\n        return new Point(this.x - dx, this.y - dy);\n      }\n\n      var p = Point.create(dx);\n      return new Point(this.x - p.x, this.y - p.y);\n    }\n    /**\n     * Returns an interpolation between me and point `p` for a parametert in\n     * the closed interval `[0, 1]`.\n     */\n\n  }, {\n    key: \"lerp\",\n    value: function lerp(p, t) {\n      var ref = Point.create(p);\n      return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);\n    }\n    /**\n     * Normalize the point vector, scale the line segment between `(0, 0)`\n     * and the point in order for it to have the given length. If length is\n     * not specified, it is considered to be `1`; in that case, a unit vector\n     * is computed.\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n      var scale = length / this.magnitude();\n      return this.scale(scale, scale);\n    }\n    /**\n     * Moves this point along the line starting from `ref` to this point by a\n     * certain `distance`.\n     */\n\n  }, {\n    key: \"move\",\n    value: function move(ref, distance) {\n      var p = Point.create(ref);\n      var rad = Angle.toRad(p.theta(this));\n      return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);\n    }\n    /**\n     * Returns a point that is the reflection of me with the center of inversion\n     * in `ref` point.\n     */\n\n  }, {\n    key: \"reflection\",\n    value: function reflection(ref) {\n      return Point.create(ref).move(this, this.distance(ref));\n    }\n  }, {\n    key: \"snapToGrid\",\n    value: function snapToGrid(gx, gy) {\n      this.x = util.snapToGrid(this.x, gx);\n      this.y = util.snapToGrid(this.y, gy == null ? gx : gy);\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(p) {\n      var ref = Point.create(p);\n      return ref != null && ref.x === this.x && ref.y === this.y;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return Point.clone(this);\n    }\n    /**\n     * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.\n     */\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return Point.toJSON(this);\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.x, \" \").concat(this.y);\n    }\n  }]);\n\n  return Point;\n}(Geometry, Symbol.toStringTag);\n\n(function (Point) {\n  Point.toStringTag = \"X6.Geometry.\".concat(Point.name);\n\n  function isPoint(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Point) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var point = instance;\n\n    if ((tag == null || tag === Point.toStringTag) && typeof point.x === 'number' && typeof point.y === 'number' && typeof point.toPolar === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Point.isPoint = isPoint;\n})(Point || (Point = {}));\n\n(function (Point) {\n  function isPointLike(p) {\n    return p != null && typeof p === 'object' && typeof p.x === 'number' && typeof p.y === 'number';\n  }\n\n  Point.isPointLike = isPointLike;\n\n  function isPointData(p) {\n    return p != null && Array.isArray(p) && p.length === 2 && typeof p[0] === 'number' && typeof p[1] === 'number';\n  }\n\n  Point.isPointData = isPointData;\n})(Point || (Point = {}));\n\n(function (Point) {\n  function create(x, y) {\n    if (x == null || typeof x === 'number') {\n      return new Point(x, y);\n    }\n\n    return clone(x);\n  }\n\n  Point.create = create;\n\n  function clone(p) {\n    if (Point.isPoint(p)) {\n      return new Point(p.x, p.y);\n    }\n\n    if (Array.isArray(p)) {\n      return new Point(p[0], p[1]);\n    }\n\n    return new Point(p.x, p.y);\n  }\n\n  Point.clone = clone;\n\n  function toJSON(p) {\n    if (Point.isPoint(p)) {\n      return {\n        x: p.x,\n        y: p.y\n      };\n    }\n\n    if (Array.isArray(p)) {\n      return {\n        x: p[0],\n        y: p[1]\n      };\n    }\n\n    return {\n      x: p.x,\n      y: p.y\n    };\n  }\n\n  Point.toJSON = toJSON;\n  /**\n   * Returns a new Point object from the given polar coordinates.\n   * @see http://en.wikipedia.org/wiki/Polar_coordinate_system\n   */\n\n  function fromPolar(r, rad) {\n    var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    var x = Math.abs(r * Math.cos(rad));\n    var y = Math.abs(r * Math.sin(rad));\n    var org = clone(origin);\n    var deg = Angle.normalize(Angle.toDeg(rad));\n\n    if (deg < 90) {\n      y = -y;\n    } else if (deg < 180) {\n      x = -x;\n      y = -y;\n    } else if (deg < 270) {\n      x = -x;\n    }\n\n    return new Point(org.x + x, org.y + y);\n  }\n\n  Point.fromPolar = fromPolar;\n  /**\n   * Converts rectangular to polar coordinates.\n   */\n\n  function toPolar(point) {\n    var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : new Point();\n    var p = clone(point);\n    var o = clone(origin);\n    var dx = p.x - o.x;\n    var dy = p.y - o.y;\n    return new Point(Math.sqrt(dx * dx + dy * dy), // r\n    Angle.toRad(o.theta(p)));\n  }\n\n  Point.toPolar = toPolar;\n\n  function equals(p1, p2) {\n    if (p1 === p2) {\n      return true;\n    }\n\n    if (p1 != null && p2 != null) {\n      return p1.x === p2.x && p1.y === p2.y;\n    }\n\n    return false;\n  }\n\n  Point.equals = equals;\n\n  function equalPoints(p1, p2) {\n    if (p1 == null && p2 != null || p1 != null && p2 == null || p1 != null && p2 != null && p1.length !== p2.length) {\n      return false;\n    }\n\n    if (p1 != null && p2 != null) {\n      for (var i = 0, ii = p1.length; i < ii; i += 1) {\n        if (!equals(p1[i], p2[i])) {\n          return false;\n        }\n      }\n    }\n\n    return true;\n  }\n\n  Point.equalPoints = equalPoints;\n  /**\n   * Returns a point with random coordinates that fall within the range\n   * `[x1, x2]` and `[y1, y2]`.\n   */\n\n  function random(x1, x2, y1, y2) {\n    return new Point(util.random(x1, x2), util.random(y1, y2));\n  }\n\n  Point.random = random;\n\n  function rotate(point, angle, center) {\n    var rad = Angle.toRad(Angle.normalize(-angle));\n    var sin = Math.sin(rad);\n    var cos = Math.cos(rad);\n    return rotateEx(point, cos, sin, center);\n  }\n\n  Point.rotate = rotate;\n\n  function rotateEx(point, cos, sin) {\n    var center = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : new Point();\n    var source = clone(point);\n    var origin = clone(center);\n    var dx = source.x - origin.x;\n    var dy = source.y - origin.y;\n    var x1 = dx * cos - dy * sin;\n    var y1 = dy * cos + dx * sin;\n    return new Point(x1 + origin.x, y1 + origin.y);\n  }\n\n  Point.rotateEx = rotateEx;\n})(Point || (Point = {}));","map":{"version":3,"sources":["../../src/geometry/point.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as util from './util';\nimport { Angle } from './angle';\nimport { Geometry } from './geometry';\nexport class Point extends Geometry {\n    constructor(x, y) {\n        super();\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n    }\n    get [Symbol.toStringTag]() {\n        return Point.toStringTag;\n    }\n    /**\n     * Rounds the point to the given precision.\n     */\n    round(precision = 0) {\n        this.x = util.round(this.x, precision);\n        this.y = util.round(this.y, precision);\n        return this;\n    }\n    add(x, y) {\n        const p = Point.create(x, y);\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    }\n    update(x, y) {\n        const p = Point.create(x, y);\n        this.x = p.x;\n        this.y = p.y;\n        return this;\n    }\n    translate(dx, dy) {\n        const t = Point.create(dx, dy);\n        this.x += t.x;\n        this.y += t.y;\n        return this;\n    }\n    /**\n     * Rotate the point by `degree` around `center`.\n     */\n    rotate(degree, center) {\n        const p = Point.rotate(this, degree, center);\n        this.x = p.x;\n        this.y = p.y;\n        return this;\n    }\n    /**\n     * Scale point by `sx` and `sy` around the given `origin`. If origin is not\n     * specified, the point is scaled around `0,0`.\n     */\n    scale(sx, sy, origin = new Point()) {\n        const ref = Point.create(origin);\n        this.x = ref.x + sx * (this.x - ref.x);\n        this.y = ref.y + sy * (this.y - ref.y);\n        return this;\n    }\n    /**\n     * Chooses the point closest to this point from among `points`. If `points`\n     * is an empty array, `null` is returned.\n     */\n    closest(points) {\n        if (points.length === 1) {\n            return Point.create(points[0]);\n        }\n        let ret = null;\n        let min = Infinity;\n        points.forEach((p) => {\n            const dist = this.squaredDistance(p);\n            if (dist < min) {\n                ret = p;\n                min = dist;\n            }\n        });\n        return ret ? Point.create(ret) : null;\n    }\n    /**\n     * Returns the distance between the point and another point `p`.\n     */\n    distance(p) {\n        return Math.sqrt(this.squaredDistance(p));\n    }\n    /**\n     * Returns the squared distance between the point and another point `p`.\n     *\n     * Useful for distance comparisons in which real distance is not necessary\n     * (saves one `Math.sqrt()` operation).\n     */\n    squaredDistance(p) {\n        const ref = Point.create(p);\n        const dx = this.x - ref.x;\n        const dy = this.y - ref.y;\n        return dx * dx + dy * dy;\n    }\n    manhattanDistance(p) {\n        const ref = Point.create(p);\n        return Math.abs(ref.x - this.x) + Math.abs(ref.y - this.y);\n    }\n    /**\n     * Returns the magnitude of the point vector.\n     *\n     * @see http://en.wikipedia.org/wiki/Magnitude_(mathematics)\n     */\n    magnitude() {\n        return Math.sqrt(this.x * this.x + this.y * this.y) || 0.01;\n    }\n    /**\n     * Returns the angle(in degrees) between vector from this point to `p` and\n     * the x-axis.\n     */\n    theta(p = new Point()) {\n        const ref = Point.create(p);\n        const y = -(ref.y - this.y); // invert the y-axis.\n        const x = ref.x - this.x;\n        let rad = Math.atan2(y, x);\n        // Correction for III. and IV. quadrant.\n        if (rad < 0) {\n            rad = 2 * Math.PI + rad;\n        }\n        return (180 * rad) / Math.PI;\n    }\n    /**\n     * Returns the angle(in degrees) between vector from this point to `p1` and\n     * the vector from this point to `p2`.\n     *\n     * The ordering of points `p1` and `p2` is important.\n     *\n     * The function returns a value between `0` and `180` when the angle (in the\n     * direction from `p1` to `p2`) is clockwise, and a value between `180` and\n     * `360` when the angle is counterclockwise.\n     *\n     * Returns `NaN` if either of the points `p1` and `p2` is equal with this point.\n     */\n    angleBetween(p1, p2) {\n        if (this.equals(p1) || this.equals(p2)) {\n            return NaN;\n        }\n        let angle = this.theta(p2) - this.theta(p1);\n        if (angle < 0) {\n            angle += 360;\n        }\n        return angle;\n    }\n    /**\n     * Returns the angle(in degrees) between the line from `(0,0)` and this point\n     * and the line from `(0,0)` to `p`.\n     *\n     * The function returns a value between `0` and `180` when the angle (in the\n     * direction from this point to `p`) is clockwise, and a value between `180`\n     * and `360` when the angle is counterclockwise. Returns `NaN` if called from\n     * point `(0,0)` or if `p` is `(0,0)`.\n     */\n    vectorAngle(p) {\n        const zero = new Point(0, 0);\n        return zero.angleBetween(this, p);\n    }\n    /**\n     * Converts rectangular to polar coordinates.\n     */\n    toPolar(origin) {\n        this.update(Point.toPolar(this, origin));\n        return this;\n    }\n    /**\n     * Returns the change in angle(in degrees) that is the result of moving the\n     * point from its previous position to its current position.\n     *\n     * More specifically, this function computes the angle between the line from\n     * the ref point to the previous position of this point(i.e. current position\n     * `-dx`, `-dy`) and the line from the `ref` point to the current position of\n     * this point.\n     *\n     * The function returns a positive value between `0` and `180` when the angle\n     * (in the direction from previous position of this point to its current\n     * position) is clockwise, and a negative value between `0` and `-180` when\n     * the angle is counterclockwise.\n     *\n     * The function returns `0` if the previous and current positions of this\n     * point are the same (i.e. both `dx` and `dy` are `0`).\n     */\n    changeInAngle(dx, dy, ref = new Point()) {\n        // Revert the translation and measure the change in angle around x-axis.\n        return this.clone().translate(-dx, -dy).theta(ref) - this.theta(ref);\n    }\n    /**\n     * If the point lies outside the rectangle `rect`, adjust the point so that\n     * it becomes the nearest point on the boundary of `rect`.\n     */\n    adhereToRect(rect) {\n        if (!util.containsPoint(rect, this)) {\n            this.x = Math.min(Math.max(this.x, rect.x), rect.x + rect.width);\n            this.y = Math.min(Math.max(this.y, rect.y), rect.y + rect.height);\n        }\n        return this;\n    }\n    /**\n     * Returns the bearing(cardinal direction) between me and the given point.\n     *\n     * @see https://en.wikipedia.org/wiki/Cardinal_direction\n     */\n    bearing(p) {\n        const ref = Point.create(p);\n        const lat1 = Angle.toRad(this.y);\n        const lat2 = Angle.toRad(ref.y);\n        const lon1 = this.x;\n        const lon2 = ref.x;\n        const dLon = Angle.toRad(lon2 - lon1);\n        const y = Math.sin(dLon) * Math.cos(lat2);\n        const x = Math.cos(lat1) * Math.sin(lat2) -\n            Math.sin(lat1) * Math.cos(lat2) * Math.cos(dLon);\n        const brng = Angle.toDeg(Math.atan2(y, x));\n        const bearings = ['NE', 'E', 'SE', 'S', 'SW', 'W', 'NW', 'N'];\n        let index = brng - 22.5;\n        if (index < 0) {\n            index += 360;\n        }\n        index = parseInt((index / 45), 10);\n        return bearings[index];\n    }\n    /**\n     * Returns the cross product of the vector from me to `p1` and the vector\n     * from me to `p2`.\n     *\n     * The left-hand rule is used because the coordinate system is left-handed.\n     */\n    cross(p1, p2) {\n        if (p1 != null && p2 != null) {\n            const a = Point.create(p1);\n            const b = Point.create(p2);\n            return (b.x - this.x) * (a.y - this.y) - (b.y - this.y) * (a.x - this.x);\n        }\n        return NaN;\n    }\n    /**\n     * Returns the dot product of this point with given other point.\n     */\n    dot(p) {\n        const ref = Point.create(p);\n        return this.x * ref.x + this.y * ref.y;\n    }\n    diff(dx, dy) {\n        if (typeof dx === 'number') {\n            return new Point(this.x - dx, this.y - dy);\n        }\n        const p = Point.create(dx);\n        return new Point(this.x - p.x, this.y - p.y);\n    }\n    /**\n     * Returns an interpolation between me and point `p` for a parametert in\n     * the closed interval `[0, 1]`.\n     */\n    lerp(p, t) {\n        const ref = Point.create(p);\n        return new Point((1 - t) * this.x + t * ref.x, (1 - t) * this.y + t * ref.y);\n    }\n    /**\n     * Normalize the point vector, scale the line segment between `(0, 0)`\n     * and the point in order for it to have the given length. If length is\n     * not specified, it is considered to be `1`; in that case, a unit vector\n     * is computed.\n     */\n    normalize(length = 1) {\n        const scale = length / this.magnitude();\n        return this.scale(scale, scale);\n    }\n    /**\n     * Moves this point along the line starting from `ref` to this point by a\n     * certain `distance`.\n     */\n    move(ref, distance) {\n        const p = Point.create(ref);\n        const rad = Angle.toRad(p.theta(this));\n        return this.translate(Math.cos(rad) * distance, -Math.sin(rad) * distance);\n    }\n    /**\n     * Returns a point that is the reflection of me with the center of inversion\n     * in `ref` point.\n     */\n    reflection(ref) {\n        return Point.create(ref).move(this, this.distance(ref));\n    }\n    snapToGrid(gx, gy) {\n        this.x = util.snapToGrid(this.x, gx);\n        this.y = util.snapToGrid(this.y, gy == null ? gx : gy);\n        return this;\n    }\n    equals(p) {\n        const ref = Point.create(p);\n        return ref != null && ref.x === this.x && ref.y === this.y;\n    }\n    clone() {\n        return Point.clone(this);\n    }\n    /**\n     * Returns the point as a simple JSON object. For example: `{ x: 0, y: 0 }`.\n     */\n    toJSON() {\n        return Point.toJSON(this);\n    }\n    serialize() {\n        return `${this.x} ${this.y}`;\n    }\n}\n(function (Point) {\n    Point.toStringTag = `X6.Geometry.${Point.name}`;\n    function isPoint(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Point) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const point = instance;\n        if ((tag == null || tag === Point.toStringTag) &&\n            typeof point.x === 'number' &&\n            typeof point.y === 'number' &&\n            typeof point.toPolar === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Point.isPoint = isPoint;\n})(Point || (Point = {}));\n(function (Point) {\n    function isPointLike(p) {\n        return (p != null &&\n            typeof p === 'object' &&\n            typeof p.x === 'number' &&\n            typeof p.y === 'number');\n    }\n    Point.isPointLike = isPointLike;\n    function isPointData(p) {\n        return (p != null &&\n            Array.isArray(p) &&\n            p.length === 2 &&\n            typeof p[0] === 'number' &&\n            typeof p[1] === 'number');\n    }\n    Point.isPointData = isPointData;\n})(Point || (Point = {}));\n(function (Point) {\n    function create(x, y) {\n        if (x == null || typeof x === 'number') {\n            return new Point(x, y);\n        }\n        return clone(x);\n    }\n    Point.create = create;\n    function clone(p) {\n        if (Point.isPoint(p)) {\n            return new Point(p.x, p.y);\n        }\n        if (Array.isArray(p)) {\n            return new Point(p[0], p[1]);\n        }\n        return new Point(p.x, p.y);\n    }\n    Point.clone = clone;\n    function toJSON(p) {\n        if (Point.isPoint(p)) {\n            return { x: p.x, y: p.y };\n        }\n        if (Array.isArray(p)) {\n            return { x: p[0], y: p[1] };\n        }\n        return { x: p.x, y: p.y };\n    }\n    Point.toJSON = toJSON;\n    /**\n     * Returns a new Point object from the given polar coordinates.\n     * @see http://en.wikipedia.org/wiki/Polar_coordinate_system\n     */\n    function fromPolar(r, rad, origin = new Point()) {\n        let x = Math.abs(r * Math.cos(rad));\n        let y = Math.abs(r * Math.sin(rad));\n        const org = clone(origin);\n        const deg = Angle.normalize(Angle.toDeg(rad));\n        if (deg < 90) {\n            y = -y;\n        }\n        else if (deg < 180) {\n            x = -x;\n            y = -y;\n        }\n        else if (deg < 270) {\n            x = -x;\n        }\n        return new Point(org.x + x, org.y + y);\n    }\n    Point.fromPolar = fromPolar;\n    /**\n     * Converts rectangular to polar coordinates.\n     */\n    function toPolar(point, origin = new Point()) {\n        const p = clone(point);\n        const o = clone(origin);\n        const dx = p.x - o.x;\n        const dy = p.y - o.y;\n        return new Point(Math.sqrt(dx * dx + dy * dy), // r\n        Angle.toRad(o.theta(p)));\n    }\n    Point.toPolar = toPolar;\n    function equals(p1, p2) {\n        if (p1 === p2) {\n            return true;\n        }\n        if (p1 != null && p2 != null) {\n            return p1.x === p2.x && p1.y === p2.y;\n        }\n        return false;\n    }\n    Point.equals = equals;\n    function equalPoints(p1, p2) {\n        if ((p1 == null && p2 != null) ||\n            (p1 != null && p2 == null) ||\n            (p1 != null && p2 != null && p1.length !== p2.length)) {\n            return false;\n        }\n        if (p1 != null && p2 != null) {\n            for (let i = 0, ii = p1.length; i < ii; i += 1) {\n                if (!equals(p1[i], p2[i])) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n    Point.equalPoints = equalPoints;\n    /**\n     * Returns a point with random coordinates that fall within the range\n     * `[x1, x2]` and `[y1, y2]`.\n     */\n    function random(x1, x2, y1, y2) {\n        return new Point(util.random(x1, x2), util.random(y1, y2));\n    }\n    Point.random = random;\n    function rotate(point, angle, center) {\n        const rad = Angle.toRad(Angle.normalize(-angle));\n        const sin = Math.sin(rad);\n        const cos = Math.cos(rad);\n        return rotateEx(point, cos, sin, center);\n    }\n    Point.rotate = rotate;\n    function rotateEx(point, cos, sin, center = new Point()) {\n        const source = clone(point);\n        const origin = clone(center);\n        const dx = source.x - origin.x;\n        const dy = source.y - origin.y;\n        const x1 = dx * cos - dy * sin;\n        const y1 = dy * cos + dx * sin;\n        return new Point(x1 + origin.x, y1 + origin.y);\n    }\n    Point.rotateEx = rotateEx;\n})(Point || (Point = {}));\n//# sourceMappingURL=point.js.map"]},"metadata":{},"sourceType":"module"}