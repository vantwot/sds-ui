{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport * as util from './util';\nimport { Angle } from './angle';\nimport { Line } from './line';\nimport { Point } from './point';\nimport { Geometry } from './geometry';\nexport var Rectangle = /*#__PURE__*/function (_Geometry, _Symbol$toStringTag) {\n  _inherits(Rectangle, _Geometry);\n\n  var _super = _createSuper(Rectangle);\n\n  function Rectangle(x, y, width, height) {\n    var _this;\n\n    _classCallCheck(this, Rectangle);\n\n    _this = _super.call(this);\n    _this.x = x == null ? 0 : x;\n    _this.y = y == null ? 0 : y;\n    _this.width = width == null ? 0 : width;\n    _this.height = height == null ? 0 : height;\n    return _this;\n  }\n\n  _createClass(Rectangle, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Rectangle.toStringTag;\n    }\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.x;\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.y;\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.x + this.width;\n    }\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.y + this.height;\n    }\n  }, {\n    key: \"origin\",\n    get: function get() {\n      return new Point(this.x, this.y);\n    }\n  }, {\n    key: \"topLeft\",\n    get: function get() {\n      return new Point(this.x, this.y);\n    }\n  }, {\n    key: \"topCenter\",\n    get: function get() {\n      return new Point(this.x + this.width / 2, this.y);\n    }\n  }, {\n    key: \"topRight\",\n    get: function get() {\n      return new Point(this.x + this.width, this.y);\n    }\n  }, {\n    key: \"center\",\n    get: function get() {\n      return new Point(this.x + this.width / 2, this.y + this.height / 2);\n    }\n  }, {\n    key: \"bottomLeft\",\n    get: function get() {\n      return new Point(this.x, this.y + this.height);\n    }\n  }, {\n    key: \"bottomCenter\",\n    get: function get() {\n      return new Point(this.x + this.width / 2, this.y + this.height);\n    }\n  }, {\n    key: \"bottomRight\",\n    get: function get() {\n      return new Point(this.x + this.width, this.y + this.height);\n    }\n  }, {\n    key: \"corner\",\n    get: function get() {\n      return new Point(this.x + this.width, this.y + this.height);\n    }\n  }, {\n    key: \"rightMiddle\",\n    get: function get() {\n      return new Point(this.x + this.width, this.y + this.height / 2);\n    }\n  }, {\n    key: \"leftMiddle\",\n    get: function get() {\n      return new Point(this.x, this.y + this.height / 2);\n    }\n  }, {\n    key: \"topLine\",\n    get: function get() {\n      return new Line(this.topLeft, this.topRight);\n    }\n  }, {\n    key: \"rightLine\",\n    get: function get() {\n      return new Line(this.topRight, this.bottomRight);\n    }\n  }, {\n    key: \"bottomLine\",\n    get: function get() {\n      return new Line(this.bottomLeft, this.bottomRight);\n    }\n  }, {\n    key: \"leftLine\",\n    get: function get() {\n      return new Line(this.topLeft, this.bottomLeft);\n    }\n  }, {\n    key: \"getOrigin\",\n    value: function getOrigin() {\n      return this.origin;\n    }\n  }, {\n    key: \"getTopLeft\",\n    value: function getTopLeft() {\n      return this.topLeft;\n    }\n  }, {\n    key: \"getTopCenter\",\n    value: function getTopCenter() {\n      return this.topCenter;\n    }\n  }, {\n    key: \"getTopRight\",\n    value: function getTopRight() {\n      return this.topRight;\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      return this.center;\n    }\n  }, {\n    key: \"getCenterX\",\n    value: function getCenterX() {\n      return this.x + this.width / 2;\n    }\n  }, {\n    key: \"getCenterY\",\n    value: function getCenterY() {\n      return this.y + this.height / 2;\n    }\n  }, {\n    key: \"getBottomLeft\",\n    value: function getBottomLeft() {\n      return this.bottomLeft;\n    }\n  }, {\n    key: \"getBottomCenter\",\n    value: function getBottomCenter() {\n      return this.bottomCenter;\n    }\n  }, {\n    key: \"getBottomRight\",\n    value: function getBottomRight() {\n      return this.bottomRight;\n    }\n  }, {\n    key: \"getCorner\",\n    value: function getCorner() {\n      return this.corner;\n    }\n  }, {\n    key: \"getRightMiddle\",\n    value: function getRightMiddle() {\n      return this.rightMiddle;\n    }\n  }, {\n    key: \"getLeftMiddle\",\n    value: function getLeftMiddle() {\n      return this.leftMiddle;\n    }\n  }, {\n    key: \"getTopLine\",\n    value: function getTopLine() {\n      return this.topLine;\n    }\n  }, {\n    key: \"getRightLine\",\n    value: function getRightLine() {\n      return this.rightLine;\n    }\n  }, {\n    key: \"getBottomLine\",\n    value: function getBottomLine() {\n      return this.bottomLine;\n    }\n  }, {\n    key: \"getLeftLine\",\n    value: function getLeftLine() {\n      return this.leftLine;\n    }\n    /**\n     * Returns a rectangle that is the bounding box of the rectangle.\n     *\n     * If `angle` is specified, the bounding box calculation will take into\n     * account the rotation of the rectangle by angle degrees around its center.\n     */\n\n  }, {\n    key: \"bbox\",\n    value: function bbox(angle) {\n      if (!angle) {\n        return this.clone();\n      }\n\n      var rad = Angle.toRad(angle);\n      var st = Math.abs(Math.sin(rad));\n      var ct = Math.abs(Math.cos(rad));\n      var w = this.width * ct + this.height * st;\n      var h = this.width * st + this.height * ct;\n      return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n    }\n  }, {\n    key: \"round\",\n    value: function round() {\n      var precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this.x = util.round(this.x, precision);\n      this.y = util.round(this.y, precision);\n      this.width = util.round(this.width, precision);\n      this.height = util.round(this.height, precision);\n      return this;\n    }\n  }, {\n    key: \"add\",\n    value: function add(x, y, width, height) {\n      var rect = Rectangle.create(x, y, width, height);\n      var minX = Math.min(this.x, rect.x);\n      var minY = Math.min(this.y, rect.y);\n      var maxX = Math.max(this.x + this.width, rect.x + rect.width);\n      var maxY = Math.max(this.y + this.height, rect.y + rect.height);\n      this.x = minX;\n      this.y = minY;\n      this.width = maxX - minX;\n      this.height = maxY - minY;\n      return this;\n    }\n  }, {\n    key: \"update\",\n    value: function update(x, y, width, height) {\n      var rect = Rectangle.create(x, y, width, height);\n      this.x = rect.x;\n      this.y = rect.y;\n      this.width = rect.width;\n      this.height = rect.height;\n      return this;\n    }\n  }, {\n    key: \"inflate\",\n    value: function inflate(dx, dy) {\n      var w = dx;\n      var h = dy != null ? dy : dx;\n      this.x -= w;\n      this.y -= h;\n      this.width += 2 * w;\n      this.height += 2 * h;\n      return this;\n    }\n  }, {\n    key: \"snapToGrid\",\n    value: function snapToGrid(gx, gy) {\n      var origin = this.origin.snapToGrid(gx, gy);\n      var corner = this.corner.snapToGrid(gx, gy);\n      this.x = origin.x;\n      this.y = origin.y;\n      this.width = corner.x - origin.x;\n      this.height = corner.y - origin.y;\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      var p = Point.create(tx, ty);\n      this.x += p.x;\n      this.y += p.y;\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n      var pos = this.origin.scale(sx, sy, origin);\n      this.x = pos.x;\n      this.y = pos.y;\n      this.width *= sx;\n      this.height *= sy;\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(degree) {\n      var center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getCenter();\n\n      if (degree !== 0) {\n        var rad = Angle.toRad(degree);\n        var cos = Math.cos(rad);\n        var sin = Math.sin(rad);\n        var p1 = this.getOrigin();\n        var p2 = this.getTopRight();\n        var p3 = this.getBottomRight();\n        var p4 = this.getBottomLeft();\n        p1 = Point.rotateEx(p1, cos, sin, center);\n        p2 = Point.rotateEx(p2, cos, sin, center);\n        p3 = Point.rotateEx(p3, cos, sin, center);\n        p4 = Point.rotateEx(p4, cos, sin, center);\n        var rect = new Rectangle(p1.x, p1.y, 0, 0);\n        rect.add(p2.x, p2.y, 0, 0);\n        rect.add(p3.x, p3.y, 0, 0);\n        rect.add(p4.x, p4.y, 0, 0);\n        this.update(rect);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"rotate90\",\n    value: function rotate90() {\n      var t = (this.width - this.height) / 2;\n      this.x += t;\n      this.y -= t;\n      var tmp = this.width;\n      this.width = this.height;\n      this.height = tmp;\n      return this;\n    }\n    /**\n     * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n     * `rect.width` and `rect.height`.\n     */\n\n  }, {\n    key: \"moveAndExpand\",\n    value: function moveAndExpand(rect) {\n      var ref = Rectangle.clone(rect);\n      this.x += ref.x || 0;\n      this.y += ref.y || 0;\n      this.width += ref.width || 0;\n      this.height += ref.height || 0;\n      return this;\n    }\n    /**\n     * Returns an object where `sx` and `sy` give the maximum scaling that can be\n     * applied to the rectangle so that it would still fit into `limit`. If\n     * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n     * scaled around its center.\n     */\n\n  }, {\n    key: \"getMaxScaleToFit\",\n    value: function getMaxScaleToFit(limit) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.center;\n      var rect = Rectangle.clone(limit);\n      var ox = origin.x;\n      var oy = origin.y; // Find the maximal possible scale for all corners, so when the scale\n      // is applied the point is still inside the rectangle.\n\n      var sx1 = Infinity;\n      var sx2 = Infinity;\n      var sx3 = Infinity;\n      var sx4 = Infinity;\n      var sy1 = Infinity;\n      var sy2 = Infinity;\n      var sy3 = Infinity;\n      var sy4 = Infinity; // Top Left\n\n      var p1 = rect.topLeft;\n\n      if (p1.x < ox) {\n        sx1 = (this.x - ox) / (p1.x - ox);\n      }\n\n      if (p1.y < oy) {\n        sy1 = (this.y - oy) / (p1.y - oy);\n      } // Bottom Right\n\n\n      var p2 = rect.bottomRight;\n\n      if (p2.x > ox) {\n        sx2 = (this.x + this.width - ox) / (p2.x - ox);\n      }\n\n      if (p2.y > oy) {\n        sy2 = (this.y + this.height - oy) / (p2.y - oy);\n      } // Top Right\n\n\n      var p3 = rect.topRight;\n\n      if (p3.x > ox) {\n        sx3 = (this.x + this.width - ox) / (p3.x - ox);\n      }\n\n      if (p3.y < oy) {\n        sy3 = (this.y - oy) / (p3.y - oy);\n      } // Bottom Left\n\n\n      var p4 = rect.bottomLeft;\n\n      if (p4.x < ox) {\n        sx4 = (this.x - ox) / (p4.x - ox);\n      }\n\n      if (p4.y > oy) {\n        sy4 = (this.y + this.height - oy) / (p4.y - oy);\n      }\n\n      return {\n        sx: Math.min(sx1, sx2, sx3, sx4),\n        sy: Math.min(sy1, sy2, sy3, sy4)\n      };\n    }\n    /**\n     * Returns a number that specifies the maximum scaling that can be applied to\n     * the rectangle along both axes so that it would still fit into `limit`. If\n     * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n     * scaled around its center.\n     */\n\n  }, {\n    key: \"getMaxUniformScaleToFit\",\n    value: function getMaxUniformScaleToFit(limit) {\n      var origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.center;\n      var scale = this.getMaxScaleToFit(limit, origin);\n      return Math.min(scale.sx, scale.sy);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(x, y) {\n      return util.containsPoint(this, Point.create(x, y));\n    }\n  }, {\n    key: \"containsRect\",\n    value: function containsRect(x, y, width, height) {\n      var b = Rectangle.create(x, y, width, height);\n      var x1 = this.x;\n      var y1 = this.y;\n      var w1 = this.width;\n      var h1 = this.height;\n      var x2 = b.x;\n      var y2 = b.y;\n      var w2 = b.width;\n      var h2 = b.height; // one of the dimensions is 0\n\n      if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n        return false;\n      }\n\n      return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;\n    }\n    /**\n     * Returns an array of the intersection points of the rectangle and the line.\n     * Return `null` if no intersection exists.\n     */\n\n  }, {\n    key: \"intersectsWithLine\",\n    value: function intersectsWithLine(line) {\n      var rectLines = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n      var points = [];\n      var dedupeArr = [];\n      rectLines.forEach(function (l) {\n        var p = line.intersectsWithLine(l);\n\n        if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n          points.push(p);\n          dedupeArr.push(p.toString());\n        }\n      });\n      return points.length > 0 ? points : null;\n    }\n    /**\n     * Returns the point on the boundary of the rectangle that is the intersection\n     * of the rectangle with a line starting in the center the rectangle ending in\n     * the point `p`.\n     *\n     * If `angle` is specified, the intersection will take into account the\n     * rotation of the rectangle by `angle` degrees around its center.\n     */\n\n  }, {\n    key: \"intersectsWithLineFromCenterToPoint\",\n    value: function intersectsWithLineFromCenterToPoint(p, angle) {\n      var ref = Point.clone(p);\n      var center = this.center;\n      var result = null;\n\n      if (angle != null && angle !== 0) {\n        ref.rotate(angle, center);\n      }\n\n      var sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n      var connector = new Line(center, ref);\n\n      for (var i = sides.length - 1; i >= 0; i -= 1) {\n        var intersection = sides[i].intersectsWithLine(connector);\n\n        if (intersection !== null) {\n          result = intersection;\n          break;\n        }\n      }\n\n      if (result && angle != null && angle !== 0) {\n        result.rotate(-angle, center);\n      }\n\n      return result;\n    }\n  }, {\n    key: \"intersectsWithRect\",\n    value: function intersectsWithRect(x, y, width, height) {\n      var ref = Rectangle.create(x, y, width, height); // no intersection\n\n      if (!this.isIntersectWithRect(ref)) {\n        return null;\n      }\n\n      var myOrigin = this.origin;\n      var myCorner = this.corner;\n      var rOrigin = ref.origin;\n      var rCorner = ref.corner;\n      var xx = Math.max(myOrigin.x, rOrigin.x);\n      var yy = Math.max(myOrigin.y, rOrigin.y);\n      return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);\n    }\n  }, {\n    key: \"isIntersectWithRect\",\n    value: function isIntersectWithRect(x, y, width, height) {\n      var ref = Rectangle.create(x, y, width, height);\n      var myOrigin = this.origin;\n      var myCorner = this.corner;\n      var rOrigin = ref.origin;\n      var rCorner = ref.corner;\n\n      if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) {\n        return false;\n      }\n\n      return true;\n    }\n    /**\n     * Normalize the rectangle, i.e. make it so that it has non-negative\n     * width and height. If width is less than `0`, the function swaps left and\n     * right corners and if height is less than `0`, the top and bottom corners\n     * are swapped.\n     */\n\n  }, {\n    key: \"normalize\",\n    value: function normalize() {\n      var newx = this.x;\n      var newy = this.y;\n      var newwidth = this.width;\n      var newheight = this.height;\n\n      if (this.width < 0) {\n        newx = this.x + this.width;\n        newwidth = -this.width;\n      }\n\n      if (this.height < 0) {\n        newy = this.y + this.height;\n        newheight = -this.height;\n      }\n\n      this.x = newx;\n      this.y = newy;\n      this.width = newwidth;\n      this.height = newheight;\n      return this;\n    }\n    /**\n     * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n     */\n\n  }, {\n    key: \"union\",\n    value: function union(rect) {\n      var ref = Rectangle.clone(rect);\n      var myOrigin = this.origin;\n      var myCorner = this.corner;\n      var rOrigin = ref.origin;\n      var rCorner = ref.corner;\n      var originX = Math.min(myOrigin.x, rOrigin.x);\n      var originY = Math.min(myOrigin.y, rOrigin.y);\n      var cornerX = Math.max(myCorner.x, rCorner.x);\n      var cornerY = Math.max(myCorner.y, rCorner.y);\n      return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);\n    }\n    /**\n     * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n     * the rectangle which is nearest to the point `p`.\n     */\n\n  }, {\n    key: \"getNearestSideToPoint\",\n    value: function getNearestSideToPoint(p) {\n      var ref = Point.clone(p);\n      var distLeft = ref.x - this.x;\n      var distRight = this.x + this.width - ref.x;\n      var distTop = ref.y - this.y;\n      var distBottom = this.y + this.height - ref.y;\n      var closest = distLeft;\n      var side = 'left';\n\n      if (distRight < closest) {\n        closest = distRight;\n        side = 'right';\n      }\n\n      if (distTop < closest) {\n        closest = distTop;\n        side = 'top';\n      }\n\n      if (distBottom < closest) {\n        side = 'bottom';\n      }\n\n      return side;\n    }\n    /**\n     * Returns a point on the boundary of the rectangle nearest to the point `p`.\n     */\n\n  }, {\n    key: \"getNearestPointToPoint\",\n    value: function getNearestPointToPoint(p) {\n      var ref = Point.clone(p);\n\n      if (this.containsPoint(ref)) {\n        var side = this.getNearestSideToPoint(ref);\n\n        switch (side) {\n          case 'right':\n            return new Point(this.x + this.width, ref.y);\n\n          case 'left':\n            return new Point(this.x, ref.y);\n\n          case 'bottom':\n            return new Point(ref.x, this.y + this.height);\n\n          case 'top':\n            return new Point(ref.x, this.y);\n\n          default:\n            break;\n        }\n      }\n\n      return ref.adhereToRect(this);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(rect) {\n      return rect != null && rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        x: this.x,\n        y: this.y,\n        width: this.width,\n        height: this.height\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.x, \" \").concat(this.y, \" \").concat(this.width, \" \").concat(this.height);\n    }\n  }]);\n\n  return Rectangle;\n}(Geometry, Symbol.toStringTag);\n\n(function (Rectangle) {\n  Rectangle.toStringTag = \"X6.Geometry.\".concat(Rectangle.name);\n\n  function isRectangle(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Rectangle) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var rect = instance;\n\n    if ((tag == null || tag === Rectangle.toStringTag) && typeof rect.x === 'number' && typeof rect.y === 'number' && typeof rect.width === 'number' && typeof rect.height === 'number' && typeof rect.inflate === 'function' && typeof rect.moveAndExpand === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Rectangle.isRectangle = isRectangle;\n})(Rectangle || (Rectangle = {}));\n\n(function (Rectangle) {\n  function isRectangleLike(o) {\n    return o != null && typeof o === 'object' && typeof o.x === 'number' && typeof o.y === 'number' && typeof o.width === 'number' && typeof o.height === 'number';\n  }\n\n  Rectangle.isRectangleLike = isRectangleLike;\n})(Rectangle || (Rectangle = {}));\n\n(function (Rectangle) {\n  function create(x, y, width, height) {\n    if (x == null || typeof x === 'number') {\n      return new Rectangle(x, y, width, height);\n    }\n\n    return clone(x);\n  }\n\n  Rectangle.create = create;\n\n  function clone(rect) {\n    if (Rectangle.isRectangle(rect)) {\n      return rect.clone();\n    }\n\n    if (Array.isArray(rect)) {\n      return new Rectangle(rect[0], rect[1], rect[2], rect[3]);\n    }\n\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n  }\n\n  Rectangle.clone = clone;\n\n  function fromSize(size) {\n    return new Rectangle(0, 0, size.width, size.height);\n  }\n\n  Rectangle.fromSize = fromSize;\n\n  function fromPositionAndSize(pos, size) {\n    return new Rectangle(pos.x, pos.y, size.width, size.height);\n  }\n\n  Rectangle.fromPositionAndSize = fromPositionAndSize;\n  /**\n   * Returns a new rectangle from the given ellipse.\n   */\n\n  function fromEllipse(ellipse) {\n    return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);\n  }\n\n  Rectangle.fromEllipse = fromEllipse;\n})(Rectangle || (Rectangle = {}));","map":{"version":3,"sources":["../../src/geometry/rectangle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as util from './util';\nimport { Angle } from './angle';\nimport { Line } from './line';\nimport { Point } from './point';\nimport { Geometry } from './geometry';\nexport class Rectangle extends Geometry {\n    constructor(x, y, width, height) {\n        super();\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n        this.width = width == null ? 0 : width;\n        this.height = height == null ? 0 : height;\n    }\n    get [Symbol.toStringTag]() {\n        return Rectangle.toStringTag;\n    }\n    get left() {\n        return this.x;\n    }\n    get top() {\n        return this.y;\n    }\n    get right() {\n        return this.x + this.width;\n    }\n    get bottom() {\n        return this.y + this.height;\n    }\n    get origin() {\n        return new Point(this.x, this.y);\n    }\n    get topLeft() {\n        return new Point(this.x, this.y);\n    }\n    get topCenter() {\n        return new Point(this.x + this.width / 2, this.y);\n    }\n    get topRight() {\n        return new Point(this.x + this.width, this.y);\n    }\n    get center() {\n        return new Point(this.x + this.width / 2, this.y + this.height / 2);\n    }\n    get bottomLeft() {\n        return new Point(this.x, this.y + this.height);\n    }\n    get bottomCenter() {\n        return new Point(this.x + this.width / 2, this.y + this.height);\n    }\n    get bottomRight() {\n        return new Point(this.x + this.width, this.y + this.height);\n    }\n    get corner() {\n        return new Point(this.x + this.width, this.y + this.height);\n    }\n    get rightMiddle() {\n        return new Point(this.x + this.width, this.y + this.height / 2);\n    }\n    get leftMiddle() {\n        return new Point(this.x, this.y + this.height / 2);\n    }\n    get topLine() {\n        return new Line(this.topLeft, this.topRight);\n    }\n    get rightLine() {\n        return new Line(this.topRight, this.bottomRight);\n    }\n    get bottomLine() {\n        return new Line(this.bottomLeft, this.bottomRight);\n    }\n    get leftLine() {\n        return new Line(this.topLeft, this.bottomLeft);\n    }\n    getOrigin() {\n        return this.origin;\n    }\n    getTopLeft() {\n        return this.topLeft;\n    }\n    getTopCenter() {\n        return this.topCenter;\n    }\n    getTopRight() {\n        return this.topRight;\n    }\n    getCenter() {\n        return this.center;\n    }\n    getCenterX() {\n        return this.x + this.width / 2;\n    }\n    getCenterY() {\n        return this.y + this.height / 2;\n    }\n    getBottomLeft() {\n        return this.bottomLeft;\n    }\n    getBottomCenter() {\n        return this.bottomCenter;\n    }\n    getBottomRight() {\n        return this.bottomRight;\n    }\n    getCorner() {\n        return this.corner;\n    }\n    getRightMiddle() {\n        return this.rightMiddle;\n    }\n    getLeftMiddle() {\n        return this.leftMiddle;\n    }\n    getTopLine() {\n        return this.topLine;\n    }\n    getRightLine() {\n        return this.rightLine;\n    }\n    getBottomLine() {\n        return this.bottomLine;\n    }\n    getLeftLine() {\n        return this.leftLine;\n    }\n    /**\n     * Returns a rectangle that is the bounding box of the rectangle.\n     *\n     * If `angle` is specified, the bounding box calculation will take into\n     * account the rotation of the rectangle by angle degrees around its center.\n     */\n    bbox(angle) {\n        if (!angle) {\n            return this.clone();\n        }\n        const rad = Angle.toRad(angle);\n        const st = Math.abs(Math.sin(rad));\n        const ct = Math.abs(Math.cos(rad));\n        const w = this.width * ct + this.height * st;\n        const h = this.width * st + this.height * ct;\n        return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n    }\n    round(precision = 0) {\n        this.x = util.round(this.x, precision);\n        this.y = util.round(this.y, precision);\n        this.width = util.round(this.width, precision);\n        this.height = util.round(this.height, precision);\n        return this;\n    }\n    add(x, y, width, height) {\n        const rect = Rectangle.create(x, y, width, height);\n        const minX = Math.min(this.x, rect.x);\n        const minY = Math.min(this.y, rect.y);\n        const maxX = Math.max(this.x + this.width, rect.x + rect.width);\n        const maxY = Math.max(this.y + this.height, rect.y + rect.height);\n        this.x = minX;\n        this.y = minY;\n        this.width = maxX - minX;\n        this.height = maxY - minY;\n        return this;\n    }\n    update(x, y, width, height) {\n        const rect = Rectangle.create(x, y, width, height);\n        this.x = rect.x;\n        this.y = rect.y;\n        this.width = rect.width;\n        this.height = rect.height;\n        return this;\n    }\n    inflate(dx, dy) {\n        const w = dx;\n        const h = dy != null ? dy : dx;\n        this.x -= w;\n        this.y -= h;\n        this.width += 2 * w;\n        this.height += 2 * h;\n        return this;\n    }\n    snapToGrid(gx, gy) {\n        const origin = this.origin.snapToGrid(gx, gy);\n        const corner = this.corner.snapToGrid(gx, gy);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width = corner.x - origin.x;\n        this.height = corner.y - origin.y;\n        return this;\n    }\n    translate(tx, ty) {\n        const p = Point.create(tx, ty);\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    }\n    scale(sx, sy, origin = new Point()) {\n        const pos = this.origin.scale(sx, sy, origin);\n        this.x = pos.x;\n        this.y = pos.y;\n        this.width *= sx;\n        this.height *= sy;\n        return this;\n    }\n    rotate(degree, center = this.getCenter()) {\n        if (degree !== 0) {\n            const rad = Angle.toRad(degree);\n            const cos = Math.cos(rad);\n            const sin = Math.sin(rad);\n            let p1 = this.getOrigin();\n            let p2 = this.getTopRight();\n            let p3 = this.getBottomRight();\n            let p4 = this.getBottomLeft();\n            p1 = Point.rotateEx(p1, cos, sin, center);\n            p2 = Point.rotateEx(p2, cos, sin, center);\n            p3 = Point.rotateEx(p3, cos, sin, center);\n            p4 = Point.rotateEx(p4, cos, sin, center);\n            const rect = new Rectangle(p1.x, p1.y, 0, 0);\n            rect.add(p2.x, p2.y, 0, 0);\n            rect.add(p3.x, p3.y, 0, 0);\n            rect.add(p4.x, p4.y, 0, 0);\n            this.update(rect);\n        }\n        return this;\n    }\n    rotate90() {\n        const t = (this.width - this.height) / 2;\n        this.x += t;\n        this.y -= t;\n        const tmp = this.width;\n        this.width = this.height;\n        this.height = tmp;\n        return this;\n    }\n    /**\n     * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n     * `rect.width` and `rect.height`.\n     */\n    moveAndExpand(rect) {\n        const ref = Rectangle.clone(rect);\n        this.x += ref.x || 0;\n        this.y += ref.y || 0;\n        this.width += ref.width || 0;\n        this.height += ref.height || 0;\n        return this;\n    }\n    /**\n     * Returns an object where `sx` and `sy` give the maximum scaling that can be\n     * applied to the rectangle so that it would still fit into `limit`. If\n     * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n     * scaled around its center.\n     */\n    getMaxScaleToFit(limit, origin = this.center) {\n        const rect = Rectangle.clone(limit);\n        const ox = origin.x;\n        const oy = origin.y;\n        // Find the maximal possible scale for all corners, so when the scale\n        // is applied the point is still inside the rectangle.\n        let sx1 = Infinity;\n        let sx2 = Infinity;\n        let sx3 = Infinity;\n        let sx4 = Infinity;\n        let sy1 = Infinity;\n        let sy2 = Infinity;\n        let sy3 = Infinity;\n        let sy4 = Infinity;\n        // Top Left\n        const p1 = rect.topLeft;\n        if (p1.x < ox) {\n            sx1 = (this.x - ox) / (p1.x - ox);\n        }\n        if (p1.y < oy) {\n            sy1 = (this.y - oy) / (p1.y - oy);\n        }\n        // Bottom Right\n        const p2 = rect.bottomRight;\n        if (p2.x > ox) {\n            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n        }\n        if (p2.y > oy) {\n            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n        }\n        // Top Right\n        const p3 = rect.topRight;\n        if (p3.x > ox) {\n            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n        }\n        if (p3.y < oy) {\n            sy3 = (this.y - oy) / (p3.y - oy);\n        }\n        // Bottom Left\n        const p4 = rect.bottomLeft;\n        if (p4.x < ox) {\n            sx4 = (this.x - ox) / (p4.x - ox);\n        }\n        if (p4.y > oy) {\n            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n        }\n        return {\n            sx: Math.min(sx1, sx2, sx3, sx4),\n            sy: Math.min(sy1, sy2, sy3, sy4),\n        };\n    }\n    /**\n     * Returns a number that specifies the maximum scaling that can be applied to\n     * the rectangle along both axes so that it would still fit into `limit`. If\n     * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n     * scaled around its center.\n     */\n    getMaxUniformScaleToFit(limit, origin = this.center) {\n        const scale = this.getMaxScaleToFit(limit, origin);\n        return Math.min(scale.sx, scale.sy);\n    }\n    containsPoint(x, y) {\n        return util.containsPoint(this, Point.create(x, y));\n    }\n    containsRect(x, y, width, height) {\n        const b = Rectangle.create(x, y, width, height);\n        const x1 = this.x;\n        const y1 = this.y;\n        const w1 = this.width;\n        const h1 = this.height;\n        const x2 = b.x;\n        const y2 = b.y;\n        const w2 = b.width;\n        const h2 = b.height;\n        // one of the dimensions is 0\n        if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n            return false;\n        }\n        return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;\n    }\n    /**\n     * Returns an array of the intersection points of the rectangle and the line.\n     * Return `null` if no intersection exists.\n     */\n    intersectsWithLine(line) {\n        const rectLines = [\n            this.topLine,\n            this.rightLine,\n            this.bottomLine,\n            this.leftLine,\n        ];\n        const points = [];\n        const dedupeArr = [];\n        rectLines.forEach((l) => {\n            const p = line.intersectsWithLine(l);\n            if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n                points.push(p);\n                dedupeArr.push(p.toString());\n            }\n        });\n        return points.length > 0 ? points : null;\n    }\n    /**\n     * Returns the point on the boundary of the rectangle that is the intersection\n     * of the rectangle with a line starting in the center the rectangle ending in\n     * the point `p`.\n     *\n     * If `angle` is specified, the intersection will take into account the\n     * rotation of the rectangle by `angle` degrees around its center.\n     */\n    intersectsWithLineFromCenterToPoint(p, angle) {\n        const ref = Point.clone(p);\n        const center = this.center;\n        let result = null;\n        if (angle != null && angle !== 0) {\n            ref.rotate(angle, center);\n        }\n        const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n        const connector = new Line(center, ref);\n        for (let i = sides.length - 1; i >= 0; i -= 1) {\n            const intersection = sides[i].intersectsWithLine(connector);\n            if (intersection !== null) {\n                result = intersection;\n                break;\n            }\n        }\n        if (result && angle != null && angle !== 0) {\n            result.rotate(-angle, center);\n        }\n        return result;\n    }\n    intersectsWithRect(x, y, width, height) {\n        const ref = Rectangle.create(x, y, width, height);\n        // no intersection\n        if (!this.isIntersectWithRect(ref)) {\n            return null;\n        }\n        const myOrigin = this.origin;\n        const myCorner = this.corner;\n        const rOrigin = ref.origin;\n        const rCorner = ref.corner;\n        const xx = Math.max(myOrigin.x, rOrigin.x);\n        const yy = Math.max(myOrigin.y, rOrigin.y);\n        return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);\n    }\n    isIntersectWithRect(x, y, width, height) {\n        const ref = Rectangle.create(x, y, width, height);\n        const myOrigin = this.origin;\n        const myCorner = this.corner;\n        const rOrigin = ref.origin;\n        const rCorner = ref.corner;\n        if (rCorner.x <= myOrigin.x ||\n            rCorner.y <= myOrigin.y ||\n            rOrigin.x >= myCorner.x ||\n            rOrigin.y >= myCorner.y) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Normalize the rectangle, i.e. make it so that it has non-negative\n     * width and height. If width is less than `0`, the function swaps left and\n     * right corners and if height is less than `0`, the top and bottom corners\n     * are swapped.\n     */\n    normalize() {\n        let newx = this.x;\n        let newy = this.y;\n        let newwidth = this.width;\n        let newheight = this.height;\n        if (this.width < 0) {\n            newx = this.x + this.width;\n            newwidth = -this.width;\n        }\n        if (this.height < 0) {\n            newy = this.y + this.height;\n            newheight = -this.height;\n        }\n        this.x = newx;\n        this.y = newy;\n        this.width = newwidth;\n        this.height = newheight;\n        return this;\n    }\n    /**\n     * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n     */\n    union(rect) {\n        const ref = Rectangle.clone(rect);\n        const myOrigin = this.origin;\n        const myCorner = this.corner;\n        const rOrigin = ref.origin;\n        const rCorner = ref.corner;\n        const originX = Math.min(myOrigin.x, rOrigin.x);\n        const originY = Math.min(myOrigin.y, rOrigin.y);\n        const cornerX = Math.max(myCorner.x, rCorner.x);\n        const cornerY = Math.max(myCorner.y, rCorner.y);\n        return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);\n    }\n    /**\n     * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n     * the rectangle which is nearest to the point `p`.\n     */\n    getNearestSideToPoint(p) {\n        const ref = Point.clone(p);\n        const distLeft = ref.x - this.x;\n        const distRight = this.x + this.width - ref.x;\n        const distTop = ref.y - this.y;\n        const distBottom = this.y + this.height - ref.y;\n        let closest = distLeft;\n        let side = 'left';\n        if (distRight < closest) {\n            closest = distRight;\n            side = 'right';\n        }\n        if (distTop < closest) {\n            closest = distTop;\n            side = 'top';\n        }\n        if (distBottom < closest) {\n            side = 'bottom';\n        }\n        return side;\n    }\n    /**\n     * Returns a point on the boundary of the rectangle nearest to the point `p`.\n     */\n    getNearestPointToPoint(p) {\n        const ref = Point.clone(p);\n        if (this.containsPoint(ref)) {\n            const side = this.getNearestSideToPoint(ref);\n            switch (side) {\n                case 'right':\n                    return new Point(this.x + this.width, ref.y);\n                case 'left':\n                    return new Point(this.x, ref.y);\n                case 'bottom':\n                    return new Point(ref.x, this.y + this.height);\n                case 'top':\n                    return new Point(ref.x, this.y);\n                default:\n                    break;\n            }\n        }\n        return ref.adhereToRect(this);\n    }\n    equals(rect) {\n        return (rect != null &&\n            rect.x === this.x &&\n            rect.y === this.y &&\n            rect.width === this.width &&\n            rect.height === this.height);\n    }\n    clone() {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n    toJSON() {\n        return { x: this.x, y: this.y, width: this.width, height: this.height };\n    }\n    serialize() {\n        return `${this.x} ${this.y} ${this.width} ${this.height}`;\n    }\n}\n(function (Rectangle) {\n    Rectangle.toStringTag = `X6.Geometry.${Rectangle.name}`;\n    function isRectangle(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Rectangle) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const rect = instance;\n        if ((tag == null || tag === Rectangle.toStringTag) &&\n            typeof rect.x === 'number' &&\n            typeof rect.y === 'number' &&\n            typeof rect.width === 'number' &&\n            typeof rect.height === 'number' &&\n            typeof rect.inflate === 'function' &&\n            typeof rect.moveAndExpand === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Rectangle.isRectangle = isRectangle;\n})(Rectangle || (Rectangle = {}));\n(function (Rectangle) {\n    function isRectangleLike(o) {\n        return (o != null &&\n            typeof o === 'object' &&\n            typeof o.x === 'number' &&\n            typeof o.y === 'number' &&\n            typeof o.width === 'number' &&\n            typeof o.height === 'number');\n    }\n    Rectangle.isRectangleLike = isRectangleLike;\n})(Rectangle || (Rectangle = {}));\n(function (Rectangle) {\n    function create(x, y, width, height) {\n        if (x == null || typeof x === 'number') {\n            return new Rectangle(x, y, width, height);\n        }\n        return clone(x);\n    }\n    Rectangle.create = create;\n    function clone(rect) {\n        if (Rectangle.isRectangle(rect)) {\n            return rect.clone();\n        }\n        if (Array.isArray(rect)) {\n            return new Rectangle(rect[0], rect[1], rect[2], rect[3]);\n        }\n        return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n    }\n    Rectangle.clone = clone;\n    function fromSize(size) {\n        return new Rectangle(0, 0, size.width, size.height);\n    }\n    Rectangle.fromSize = fromSize;\n    function fromPositionAndSize(pos, size) {\n        return new Rectangle(pos.x, pos.y, size.width, size.height);\n    }\n    Rectangle.fromPositionAndSize = fromPositionAndSize;\n    /**\n     * Returns a new rectangle from the given ellipse.\n     */\n    function fromEllipse(ellipse) {\n        return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);\n    }\n    Rectangle.fromEllipse = fromEllipse;\n})(Rectangle || (Rectangle = {}));\n//# sourceMappingURL=rectangle.js.map"]},"metadata":{},"sourceType":"module"}