{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt, FunctionExt } from '../util';\nimport { Basecoat } from '../common';\nimport { Model } from '../model/model';\nexport class HistoryManager extends Basecoat {\n  constructor(options) {\n    super();\n    this.batchCommands = null;\n    this.batchLevel = 0;\n    this.lastBatchIndex = -1;\n    this.freezed = false;\n    this.handlers = [];\n    this.graph = options.graph;\n    this.model = options.graph.model;\n    this.options = Util.getOptions(options);\n    this.validator = new HistoryManager.Validator({\n      history: this,\n      cancelInvalid: this.options.cancelInvalid\n    });\n    this.clean();\n    this.startListening();\n  }\n\n  get disabled() {\n    return this.options.enabled !== true;\n  }\n\n  enable() {\n    if (this.disabled) {\n      this.options.enabled = true;\n    }\n  }\n\n  disable() {\n    if (!this.disabled) {\n      this.options.enabled = false;\n    }\n  }\n\n  undo() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.disabled) {\n      const cmd = this.undoStack.pop();\n\n      if (cmd) {\n        this.revertCommand(cmd, options);\n        this.redoStack.push(cmd);\n        this.notify('undo', cmd, options);\n      }\n    }\n\n    return this;\n  }\n\n  redo() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.disabled) {\n      const cmd = this.redoStack.pop();\n\n      if (cmd) {\n        this.applyCommand(cmd, options);\n        this.undoStack.push(cmd);\n        this.notify('redo', cmd, options);\n      }\n    }\n\n    return this;\n  }\n  /**\n   * Same as `undo()` but does not store the undo-ed command to the\n   * `redoStack`. Canceled command therefore cannot be redo-ed.\n   */\n\n\n  cancel() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.disabled) {\n      const cmd = this.undoStack.pop();\n\n      if (cmd) {\n        this.revertCommand(cmd, options);\n        this.redoStack = [];\n        this.notify('cancel', cmd, options);\n      }\n    }\n\n    return this;\n  }\n\n  clean() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.undoStack = [];\n    this.redoStack = [];\n    this.notify('clean', null, options);\n    return this;\n  }\n\n  canUndo() {\n    return !this.disabled && this.undoStack.length > 0;\n  }\n\n  canRedo() {\n    return !this.disabled && this.redoStack.length > 0;\n  }\n\n  validate(events) {\n    for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n      callbacks[_key - 1] = arguments[_key];\n    }\n\n    this.validator.validate(events, ...callbacks);\n    return this;\n  }\n\n  dispose() {\n    this.validator.dispose();\n    this.clean();\n    this.stopListening();\n  }\n\n  startListening() {\n    this.model.on('batch:start', this.initBatchCommand, this);\n    this.model.on('batch:stop', this.storeBatchCommand, this);\n\n    if (this.options.eventNames) {\n      this.options.eventNames.forEach((name, index) => {\n        this.handlers[index] = this.addCommand.bind(this, name);\n        this.model.on(name, this.handlers[index]);\n      });\n    }\n\n    this.validator.on('invalid', args => this.trigger('invalid', args));\n  }\n\n  stopListening() {\n    this.model.off('batch:start', this.initBatchCommand, this);\n    this.model.off('batch:stop', this.storeBatchCommand, this);\n\n    if (this.options.eventNames) {\n      this.options.eventNames.forEach((name, index) => {\n        this.model.off(name, this.handlers[index]);\n      });\n      this.handlers.length = 0;\n    }\n\n    this.validator.off('invalid');\n  }\n\n  createCommand(options) {\n    return {\n      batch: options ? options.batch : false,\n      data: {}\n    };\n  }\n\n  revertCommand(cmd, options) {\n    this.freezed = true;\n    const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n\n    for (let i = cmds.length - 1; i >= 0; i -= 1) {\n      const cmd = cmds[i];\n      const localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(cmd.options, this.options.revertOptionsList || []));\n      this.executeCommand(cmd, true, localOptions);\n    }\n\n    this.freezed = false;\n  }\n\n  applyCommand(cmd, options) {\n    this.freezed = true;\n    const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n\n    for (let i = 0; i < cmds.length; i += 1) {\n      const cmd = cmds[i];\n      const localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(cmd.options, this.options.applyOptionsList || []));\n      this.executeCommand(cmd, false, localOptions);\n    }\n\n    this.freezed = false;\n  }\n\n  executeCommand(cmd, revert, options) {\n    const model = this.model; // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)\n\n    const cell = model.getCell(cmd.data.id);\n    const event = cmd.event;\n\n    if (Util.isAddEvent(event) && revert || Util.isRemoveEvent(event) && !revert) {\n      cell.remove(options);\n    } else if (Util.isAddEvent(event) && !revert || Util.isRemoveEvent(event) && revert) {\n      const data = cmd.data;\n\n      if (data.node) {\n        model.addNode(data.props, options);\n      } else if (data.edge) {\n        model.addEdge(data.props, options);\n      }\n    } else if (Util.isChangeEvent(event)) {\n      const data = cmd.data;\n      const key = data.key;\n\n      if (key) {\n        const value = revert ? data.prev[key] : data.next[key];\n        cell.prop(key, value, options);\n      }\n    } else {\n      const executeCommand = this.options.executeCommand;\n\n      if (executeCommand) {\n        FunctionExt.call(executeCommand, this, cmd, revert, options);\n      }\n    }\n  }\n\n  addCommand(event, args) {\n    if (this.freezed || this.disabled) {\n      return;\n    }\n\n    const eventArgs = args;\n    const options = eventArgs.options || {};\n\n    if (options.dryrun) {\n      return;\n    }\n\n    if (Util.isAddEvent(event) && this.options.ignoreAdd || Util.isRemoveEvent(event) && this.options.ignoreRemove || Util.isChangeEvent(event) && this.options.ignoreChange) {\n      return;\n    } // before\n    // ------\n\n\n    const before = this.options.beforeAddCommand;\n\n    if (before != null && FunctionExt.call(before, this, event, args) === false) {\n      return;\n    }\n\n    if (event === 'cell:change:*') {\n      // eslint-disable-next-line\n      event = `cell:change:${eventArgs.key}`;\n    }\n\n    const cell = eventArgs.cell;\n    const isModelChange = Model.isModel(cell);\n    let cmd;\n\n    if (this.batchCommands) {\n      // In most cases we are working with same object, doing\n      // same action etc. translate an object piece by piece.\n      cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)]; // Check if we are start working with new object or performing different\n      // action with it. Note, that command is uninitialized when lastCmdIndex\n      // equals -1. In that case we are done, command we were looking for is\n      // already set\n\n      const diffId = isModelChange && !cmd.modelChange || cmd.data.id !== cell.id;\n      const diffName = cmd.event !== event;\n\n      if (this.lastBatchIndex >= 0 && (diffId || diffName)) {\n        // Trying to find command first, which was performing same\n        // action with the object as we are doing now with cell.\n        const index = this.batchCommands.findIndex(cmd => (isModelChange && cmd.modelChange || cmd.data.id === cell.id) && cmd.event === event);\n\n        if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n          cmd = this.createCommand({\n            batch: true\n          });\n        } else {\n          cmd = this.batchCommands[index];\n          this.batchCommands.splice(index, 1);\n        }\n\n        this.batchCommands.push(cmd);\n        this.lastBatchIndex = this.batchCommands.length - 1;\n      }\n    } else {\n      cmd = this.createCommand({\n        batch: false\n      });\n    } // add & remove\n    // ------------\n\n\n    if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n      const data = cmd.data;\n      cmd.event = event;\n      cmd.options = options;\n      data.id = cell.id;\n      data.props = ObjectExt.cloneDeep(cell.toJSON());\n\n      if (cell.isEdge()) {\n        data.edge = true;\n      } else if (cell.isNode()) {\n        data.node = true;\n      }\n\n      return this.push(cmd, options);\n    } // change:*\n    // --------\n\n\n    if (Util.isChangeEvent(event)) {\n      const key = args.key;\n      const data = cmd.data;\n\n      if (!cmd.batch || !cmd.event) {\n        // Do this only once. Set previous data and action (also\n        // serves as a flag so that we don't repeat this branche).\n        cmd.event = event;\n        cmd.options = options;\n        data.key = key;\n\n        if (data.prev == null) {\n          data.prev = {};\n        }\n\n        data.prev[key] = ObjectExt.clone(cell.previous(key));\n\n        if (isModelChange) {\n          cmd.modelChange = true;\n        } else {\n          data.id = cell.id;\n        }\n      }\n\n      if (data.next == null) {\n        data.next = {};\n      }\n\n      data.next[key] = ObjectExt.clone(cell.prop(key));\n      return this.push(cmd, options);\n    } // others\n    // ------\n\n\n    const afterAddCommand = this.options.afterAddCommand;\n\n    if (afterAddCommand) {\n      FunctionExt.call(afterAddCommand, this, event, args, cmd);\n    }\n\n    this.push(cmd, options);\n  }\n  /**\n   * Gather multiple changes into a single command. These commands could\n   * be reverted with single `undo()` call. From the moment the function\n   * is called every change made on model is not stored into the undoStack.\n   * Changes are temporarily kept until `storeBatchCommand()` is called.\n   */\n  // eslint-disable-next-line\n\n\n  initBatchCommand(options) {\n    if (this.freezed) {\n      return;\n    }\n\n    if (this.batchCommands) {\n      this.batchLevel += 1;\n    } else {\n      this.batchCommands = [this.createCommand({\n        batch: true\n      })];\n      this.batchLevel = 0;\n      this.lastBatchIndex = -1;\n    }\n  }\n  /**\n   * Store changes temporarily kept in the undoStack. You have to call this\n   * function as many times as `initBatchCommand()` been called.\n   */\n\n\n  storeBatchCommand(options) {\n    if (this.freezed) {\n      return;\n    }\n\n    if (this.batchCommands && this.batchLevel <= 0) {\n      const cmds = this.filterBatchCommand(this.batchCommands);\n\n      if (cmds.length > 0) {\n        this.redoStack = [];\n        this.undoStack.push(cmds);\n        this.notify('add', cmds, options);\n      }\n\n      this.batchCommands = null;\n      this.lastBatchIndex = -1;\n      this.batchLevel = 0;\n    } else if (this.batchCommands && this.batchLevel > 0) {\n      this.batchLevel -= 1;\n    }\n  }\n\n  filterBatchCommand(batchCommands) {\n    let cmds = batchCommands.slice();\n    const result = [];\n\n    while (cmds.length > 0) {\n      const cmd = cmds.shift();\n      const evt = cmd.event;\n      const id = cmd.data.id;\n\n      if (evt != null && (id != null || cmd.modelChange)) {\n        if (Util.isAddEvent(evt)) {\n          const index = cmds.findIndex(c => Util.isRemoveEvent(c.event) && c.data.id === id);\n\n          if (index >= 0) {\n            cmds = cmds.filter((c, i) => index < i || c.data.id !== id);\n            continue;\n          }\n        } else if (Util.isRemoveEvent(evt)) {\n          const index = cmds.findIndex(c => Util.isAddEvent(c.event) && c.data.id === id);\n\n          if (index >= 0) {\n            cmds.splice(index, 1);\n            continue;\n          }\n        } else if (Util.isChangeEvent(evt)) {\n          const data = cmd.data;\n\n          if (ObjectExt.isEqual(data.prev, data.next)) {\n            continue;\n          }\n        } else {// pass\n        }\n\n        result.push(cmd);\n      }\n    }\n\n    return result;\n  }\n\n  notify(event, cmd, options) {\n    const cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];\n    this.emit(event, {\n      cmds,\n      options\n    });\n    this.emit('change', {\n      cmds,\n      options\n    });\n  }\n\n  push(cmd, options) {\n    this.redoStack = [];\n\n    if (cmd.batch) {\n      this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);\n      this.emit('batch', {\n        cmd,\n        options\n      });\n    } else {\n      this.undoStack.push(cmd);\n      this.notify('add', cmd, options);\n    }\n  }\n\n}\n\n__decorate([Basecoat.dispose()], HistoryManager.prototype, \"dispose\", null);\n\n(function (HistoryManager) {\n  /**\n   * Runs a set of callbacks to determine if a command is valid. This is\n   * useful for checking if a certain action in your application does\n   * lead to an invalid state of the graph.\n   */\n  class Validator extends Basecoat {\n    constructor(options) {\n      super();\n      this.map = {};\n      this.command = options.history;\n      this.cancelInvalid = options.cancelInvalid !== false;\n      this.command.on('add', this.onCommandAdded, this);\n    }\n\n    onCommandAdded(_ref) {\n      let {\n        cmds\n      } = _ref;\n      return Array.isArray(cmds) ? cmds.every(cmd => this.isValidCommand(cmd)) : this.isValidCommand(cmds);\n    }\n\n    isValidCommand(cmd) {\n      if (cmd.options && cmd.options.validation === false) {\n        return true;\n      }\n\n      const callbacks = cmd.event && this.map[cmd.event] || [];\n      let handoverErr = null;\n      callbacks.forEach(routes => {\n        let i = 0;\n\n        const rollup = err => {\n          const fn = routes[i];\n          i += 1;\n\n          try {\n            if (fn) {\n              fn(err, cmd, rollup);\n            } else {\n              handoverErr = err;\n              return;\n            }\n          } catch (err) {\n            rollup(err);\n          }\n        };\n\n        rollup(handoverErr);\n      });\n\n      if (handoverErr) {\n        if (this.cancelInvalid) {\n          this.command.cancel();\n        }\n\n        this.emit('invalid', {\n          err: handoverErr\n        });\n        return false;\n      }\n\n      return true;\n    }\n\n    validate(events) {\n      for (var _len2 = arguments.length, callbacks = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        callbacks[_key2 - 1] = arguments[_key2];\n      }\n\n      const evts = Array.isArray(events) ? events : events.split(/\\s+/);\n      callbacks.forEach(callback => {\n        if (typeof callback !== 'function') {\n          throw new Error(`${evts.join(' ')} requires callback functions.`);\n        }\n      });\n      evts.forEach(event => {\n        if (this.map[event] == null) {\n          this.map[event] = [];\n        }\n\n        this.map[event].push(callbacks);\n      });\n      return this;\n    }\n\n    dispose() {\n      this.command.off('add', this.onCommandAdded, this);\n    }\n\n  }\n\n  __decorate([Basecoat.dispose()], Validator.prototype, \"dispose\", null);\n\n  HistoryManager.Validator = Validator;\n})(HistoryManager || (HistoryManager = {}));\n\nvar Util;\n\n(function (Util) {\n  function isAddEvent(event) {\n    return event === 'cell:added';\n  }\n\n  Util.isAddEvent = isAddEvent;\n\n  function isRemoveEvent(event) {\n    return event === 'cell:removed';\n  }\n\n  Util.isRemoveEvent = isRemoveEvent;\n\n  function isChangeEvent(event) {\n    return event != null && event.startsWith('cell:change:');\n  }\n\n  Util.isChangeEvent = isChangeEvent;\n\n  function getOptions(options) {\n    const {\n      graph\n    } = options,\n          others = __rest(options, [\"graph\"]);\n\n    const reservedNames = ['cell:added', 'cell:removed', 'cell:change:*'];\n    const batchEvents = ['batch:start', 'batch:stop'];\n    const eventNames = options.eventNames ? options.eventNames.filter(event => !(Util.isChangeEvent(event) || reservedNames.includes(event) || batchEvents.includes(event))) : reservedNames;\n    return Object.assign(Object.assign({}, others), {\n      eventNames,\n      applyOptionsList: options.applyOptionsList || ['propertyPath'],\n      revertOptionsList: options.revertOptionsList || ['propertyPath']\n    });\n  }\n\n  Util.getOptions = getOptions;\n\n  function sortBatchCommands(cmds) {\n    const results = [];\n\n    for (let i = 0, ii = cmds.length; i < ii; i += 1) {\n      const cmd = cmds[i];\n      let index = null;\n\n      if (Util.isAddEvent(cmd.event)) {\n        const id = cmd.data.id;\n\n        for (let j = 0; j < i; j += 1) {\n          if (cmds[j].data.id === id) {\n            index = j;\n            break;\n          }\n        }\n      }\n\n      if (index !== null) {\n        results.splice(index, 0, cmd);\n      } else {\n        results.push(cmd);\n      }\n    }\n\n    return results;\n  }\n\n  Util.sortBatchCommands = sortBatchCommands;\n})(Util || (Util = {}));","map":{"version":3,"sources":["../../src/graph/history.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ObjectExt, FunctionExt } from '../util';\nimport { Basecoat } from '../common';\nimport { Model } from '../model/model';\nexport class HistoryManager extends Basecoat {\n    constructor(options) {\n        super();\n        this.batchCommands = null;\n        this.batchLevel = 0;\n        this.lastBatchIndex = -1;\n        this.freezed = false;\n        this.handlers = [];\n        this.graph = options.graph;\n        this.model = options.graph.model;\n        this.options = Util.getOptions(options);\n        this.validator = new HistoryManager.Validator({\n            history: this,\n            cancelInvalid: this.options.cancelInvalid,\n        });\n        this.clean();\n        this.startListening();\n    }\n    get disabled() {\n        return this.options.enabled !== true;\n    }\n    enable() {\n        if (this.disabled) {\n            this.options.enabled = true;\n        }\n    }\n    disable() {\n        if (!this.disabled) {\n            this.options.enabled = false;\n        }\n    }\n    undo(options = {}) {\n        if (!this.disabled) {\n            const cmd = this.undoStack.pop();\n            if (cmd) {\n                this.revertCommand(cmd, options);\n                this.redoStack.push(cmd);\n                this.notify('undo', cmd, options);\n            }\n        }\n        return this;\n    }\n    redo(options = {}) {\n        if (!this.disabled) {\n            const cmd = this.redoStack.pop();\n            if (cmd) {\n                this.applyCommand(cmd, options);\n                this.undoStack.push(cmd);\n                this.notify('redo', cmd, options);\n            }\n        }\n        return this;\n    }\n    /**\n     * Same as `undo()` but does not store the undo-ed command to the\n     * `redoStack`. Canceled command therefore cannot be redo-ed.\n     */\n    cancel(options = {}) {\n        if (!this.disabled) {\n            const cmd = this.undoStack.pop();\n            if (cmd) {\n                this.revertCommand(cmd, options);\n                this.redoStack = [];\n                this.notify('cancel', cmd, options);\n            }\n        }\n        return this;\n    }\n    clean(options = {}) {\n        this.undoStack = [];\n        this.redoStack = [];\n        this.notify('clean', null, options);\n        return this;\n    }\n    canUndo() {\n        return !this.disabled && this.undoStack.length > 0;\n    }\n    canRedo() {\n        return !this.disabled && this.redoStack.length > 0;\n    }\n    validate(events, ...callbacks) {\n        this.validator.validate(events, ...callbacks);\n        return this;\n    }\n    dispose() {\n        this.validator.dispose();\n        this.clean();\n        this.stopListening();\n    }\n    startListening() {\n        this.model.on('batch:start', this.initBatchCommand, this);\n        this.model.on('batch:stop', this.storeBatchCommand, this);\n        if (this.options.eventNames) {\n            this.options.eventNames.forEach((name, index) => {\n                this.handlers[index] = this.addCommand.bind(this, name);\n                this.model.on(name, this.handlers[index]);\n            });\n        }\n        this.validator.on('invalid', (args) => this.trigger('invalid', args));\n    }\n    stopListening() {\n        this.model.off('batch:start', this.initBatchCommand, this);\n        this.model.off('batch:stop', this.storeBatchCommand, this);\n        if (this.options.eventNames) {\n            this.options.eventNames.forEach((name, index) => {\n                this.model.off(name, this.handlers[index]);\n            });\n            this.handlers.length = 0;\n        }\n        this.validator.off('invalid');\n    }\n    createCommand(options) {\n        return {\n            batch: options ? options.batch : false,\n            data: {},\n        };\n    }\n    revertCommand(cmd, options) {\n        this.freezed = true;\n        const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n        for (let i = cmds.length - 1; i >= 0; i -= 1) {\n            const cmd = cmds[i];\n            const localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(cmd.options, this.options.revertOptionsList || []));\n            this.executeCommand(cmd, true, localOptions);\n        }\n        this.freezed = false;\n    }\n    applyCommand(cmd, options) {\n        this.freezed = true;\n        const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n        for (let i = 0; i < cmds.length; i += 1) {\n            const cmd = cmds[i];\n            const localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(cmd.options, this.options.applyOptionsList || []));\n            this.executeCommand(cmd, false, localOptions);\n        }\n        this.freezed = false;\n    }\n    executeCommand(cmd, revert, options) {\n        const model = this.model;\n        // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)\n        const cell = model.getCell(cmd.data.id);\n        const event = cmd.event;\n        if ((Util.isAddEvent(event) && revert) ||\n            (Util.isRemoveEvent(event) && !revert)) {\n            cell.remove(options);\n        }\n        else if ((Util.isAddEvent(event) && !revert) ||\n            (Util.isRemoveEvent(event) && revert)) {\n            const data = cmd.data;\n            if (data.node) {\n                model.addNode(data.props, options);\n            }\n            else if (data.edge) {\n                model.addEdge(data.props, options);\n            }\n        }\n        else if (Util.isChangeEvent(event)) {\n            const data = cmd.data;\n            const key = data.key;\n            if (key) {\n                const value = revert ? data.prev[key] : data.next[key];\n                cell.prop(key, value, options);\n            }\n        }\n        else {\n            const executeCommand = this.options.executeCommand;\n            if (executeCommand) {\n                FunctionExt.call(executeCommand, this, cmd, revert, options);\n            }\n        }\n    }\n    addCommand(event, args) {\n        if (this.freezed || this.disabled) {\n            return;\n        }\n        const eventArgs = args;\n        const options = eventArgs.options || {};\n        if (options.dryrun) {\n            return;\n        }\n        if ((Util.isAddEvent(event) && this.options.ignoreAdd) ||\n            (Util.isRemoveEvent(event) && this.options.ignoreRemove) ||\n            (Util.isChangeEvent(event) && this.options.ignoreChange)) {\n            return;\n        }\n        // before\n        // ------\n        const before = this.options.beforeAddCommand;\n        if (before != null &&\n            FunctionExt.call(before, this, event, args) === false) {\n            return;\n        }\n        if (event === 'cell:change:*') {\n            // eslint-disable-next-line\n            event = `cell:change:${eventArgs.key}`;\n        }\n        const cell = eventArgs.cell;\n        const isModelChange = Model.isModel(cell);\n        let cmd;\n        if (this.batchCommands) {\n            // In most cases we are working with same object, doing\n            // same action etc. translate an object piece by piece.\n            cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)];\n            // Check if we are start working with new object or performing different\n            // action with it. Note, that command is uninitialized when lastCmdIndex\n            // equals -1. In that case we are done, command we were looking for is\n            // already set\n            const diffId = (isModelChange && !cmd.modelChange) || cmd.data.id !== cell.id;\n            const diffName = cmd.event !== event;\n            if (this.lastBatchIndex >= 0 && (diffId || diffName)) {\n                // Trying to find command first, which was performing same\n                // action with the object as we are doing now with cell.\n                const index = this.batchCommands.findIndex((cmd) => ((isModelChange && cmd.modelChange) || cmd.data.id === cell.id) &&\n                    cmd.event === event);\n                if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n                    cmd = this.createCommand({ batch: true });\n                }\n                else {\n                    cmd = this.batchCommands[index];\n                    this.batchCommands.splice(index, 1);\n                }\n                this.batchCommands.push(cmd);\n                this.lastBatchIndex = this.batchCommands.length - 1;\n            }\n        }\n        else {\n            cmd = this.createCommand({ batch: false });\n        }\n        // add & remove\n        // ------------\n        if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n            const data = cmd.data;\n            cmd.event = event;\n            cmd.options = options;\n            data.id = cell.id;\n            data.props = ObjectExt.cloneDeep(cell.toJSON());\n            if (cell.isEdge()) {\n                data.edge = true;\n            }\n            else if (cell.isNode()) {\n                data.node = true;\n            }\n            return this.push(cmd, options);\n        }\n        // change:*\n        // --------\n        if (Util.isChangeEvent(event)) {\n            const key = args.key;\n            const data = cmd.data;\n            if (!cmd.batch || !cmd.event) {\n                // Do this only once. Set previous data and action (also\n                // serves as a flag so that we don't repeat this branche).\n                cmd.event = event;\n                cmd.options = options;\n                data.key = key;\n                if (data.prev == null) {\n                    data.prev = {};\n                }\n                data.prev[key] = ObjectExt.clone(cell.previous(key));\n                if (isModelChange) {\n                    cmd.modelChange = true;\n                }\n                else {\n                    data.id = cell.id;\n                }\n            }\n            if (data.next == null) {\n                data.next = {};\n            }\n            data.next[key] = ObjectExt.clone(cell.prop(key));\n            return this.push(cmd, options);\n        }\n        // others\n        // ------\n        const afterAddCommand = this.options.afterAddCommand;\n        if (afterAddCommand) {\n            FunctionExt.call(afterAddCommand, this, event, args, cmd);\n        }\n        this.push(cmd, options);\n    }\n    /**\n     * Gather multiple changes into a single command. These commands could\n     * be reverted with single `undo()` call. From the moment the function\n     * is called every change made on model is not stored into the undoStack.\n     * Changes are temporarily kept until `storeBatchCommand()` is called.\n     */\n    // eslint-disable-next-line\n    initBatchCommand(options) {\n        if (this.freezed) {\n            return;\n        }\n        if (this.batchCommands) {\n            this.batchLevel += 1;\n        }\n        else {\n            this.batchCommands = [this.createCommand({ batch: true })];\n            this.batchLevel = 0;\n            this.lastBatchIndex = -1;\n        }\n    }\n    /**\n     * Store changes temporarily kept in the undoStack. You have to call this\n     * function as many times as `initBatchCommand()` been called.\n     */\n    storeBatchCommand(options) {\n        if (this.freezed) {\n            return;\n        }\n        if (this.batchCommands && this.batchLevel <= 0) {\n            const cmds = this.filterBatchCommand(this.batchCommands);\n            if (cmds.length > 0) {\n                this.redoStack = [];\n                this.undoStack.push(cmds);\n                this.notify('add', cmds, options);\n            }\n            this.batchCommands = null;\n            this.lastBatchIndex = -1;\n            this.batchLevel = 0;\n        }\n        else if (this.batchCommands && this.batchLevel > 0) {\n            this.batchLevel -= 1;\n        }\n    }\n    filterBatchCommand(batchCommands) {\n        let cmds = batchCommands.slice();\n        const result = [];\n        while (cmds.length > 0) {\n            const cmd = cmds.shift();\n            const evt = cmd.event;\n            const id = cmd.data.id;\n            if (evt != null && (id != null || cmd.modelChange)) {\n                if (Util.isAddEvent(evt)) {\n                    const index = cmds.findIndex((c) => Util.isRemoveEvent(c.event) && c.data.id === id);\n                    if (index >= 0) {\n                        cmds = cmds.filter((c, i) => index < i || c.data.id !== id);\n                        continue;\n                    }\n                }\n                else if (Util.isRemoveEvent(evt)) {\n                    const index = cmds.findIndex((c) => Util.isAddEvent(c.event) && c.data.id === id);\n                    if (index >= 0) {\n                        cmds.splice(index, 1);\n                        continue;\n                    }\n                }\n                else if (Util.isChangeEvent(evt)) {\n                    const data = cmd.data;\n                    if (ObjectExt.isEqual(data.prev, data.next)) {\n                        continue;\n                    }\n                }\n                else {\n                    // pass\n                }\n                result.push(cmd);\n            }\n        }\n        return result;\n    }\n    notify(event, cmd, options) {\n        const cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];\n        this.emit(event, { cmds, options });\n        this.emit('change', { cmds, options });\n    }\n    push(cmd, options) {\n        this.redoStack = [];\n        if (cmd.batch) {\n            this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);\n            this.emit('batch', { cmd, options });\n        }\n        else {\n            this.undoStack.push(cmd);\n            this.notify('add', cmd, options);\n        }\n    }\n}\n__decorate([\n    Basecoat.dispose()\n], HistoryManager.prototype, \"dispose\", null);\n(function (HistoryManager) {\n    /**\n     * Runs a set of callbacks to determine if a command is valid. This is\n     * useful for checking if a certain action in your application does\n     * lead to an invalid state of the graph.\n     */\n    class Validator extends Basecoat {\n        constructor(options) {\n            super();\n            this.map = {};\n            this.command = options.history;\n            this.cancelInvalid = options.cancelInvalid !== false;\n            this.command.on('add', this.onCommandAdded, this);\n        }\n        onCommandAdded({ cmds }) {\n            return Array.isArray(cmds)\n                ? cmds.every((cmd) => this.isValidCommand(cmd))\n                : this.isValidCommand(cmds);\n        }\n        isValidCommand(cmd) {\n            if (cmd.options && cmd.options.validation === false) {\n                return true;\n            }\n            const callbacks = (cmd.event && this.map[cmd.event]) || [];\n            let handoverErr = null;\n            callbacks.forEach((routes) => {\n                let i = 0;\n                const rollup = (err) => {\n                    const fn = routes[i];\n                    i += 1;\n                    try {\n                        if (fn) {\n                            fn(err, cmd, rollup);\n                        }\n                        else {\n                            handoverErr = err;\n                            return;\n                        }\n                    }\n                    catch (err) {\n                        rollup(err);\n                    }\n                };\n                rollup(handoverErr);\n            });\n            if (handoverErr) {\n                if (this.cancelInvalid) {\n                    this.command.cancel();\n                }\n                this.emit('invalid', { err: handoverErr });\n                return false;\n            }\n            return true;\n        }\n        validate(events, ...callbacks) {\n            const evts = Array.isArray(events) ? events : events.split(/\\s+/);\n            callbacks.forEach((callback) => {\n                if (typeof callback !== 'function') {\n                    throw new Error(`${evts.join(' ')} requires callback functions.`);\n                }\n            });\n            evts.forEach((event) => {\n                if (this.map[event] == null) {\n                    this.map[event] = [];\n                }\n                this.map[event].push(callbacks);\n            });\n            return this;\n        }\n        dispose() {\n            this.command.off('add', this.onCommandAdded, this);\n        }\n    }\n    __decorate([\n        Basecoat.dispose()\n    ], Validator.prototype, \"dispose\", null);\n    HistoryManager.Validator = Validator;\n})(HistoryManager || (HistoryManager = {}));\nvar Util;\n(function (Util) {\n    function isAddEvent(event) {\n        return event === 'cell:added';\n    }\n    Util.isAddEvent = isAddEvent;\n    function isRemoveEvent(event) {\n        return event === 'cell:removed';\n    }\n    Util.isRemoveEvent = isRemoveEvent;\n    function isChangeEvent(event) {\n        return event != null && event.startsWith('cell:change:');\n    }\n    Util.isChangeEvent = isChangeEvent;\n    function getOptions(options) {\n        const { graph } = options, others = __rest(options, [\"graph\"]);\n        const reservedNames = [\n            'cell:added',\n            'cell:removed',\n            'cell:change:*',\n        ];\n        const batchEvents = [\n            'batch:start',\n            'batch:stop',\n        ];\n        const eventNames = options.eventNames\n            ? options.eventNames.filter((event) => !(Util.isChangeEvent(event) ||\n                reservedNames.includes(event) ||\n                batchEvents.includes(event)))\n            : reservedNames;\n        return Object.assign(Object.assign({}, others), { eventNames, applyOptionsList: options.applyOptionsList || ['propertyPath'], revertOptionsList: options.revertOptionsList || ['propertyPath'] });\n    }\n    Util.getOptions = getOptions;\n    function sortBatchCommands(cmds) {\n        const results = [];\n        for (let i = 0, ii = cmds.length; i < ii; i += 1) {\n            const cmd = cmds[i];\n            let index = null;\n            if (Util.isAddEvent(cmd.event)) {\n                const id = cmd.data.id;\n                for (let j = 0; j < i; j += 1) {\n                    if (cmds[j].data.id === id) {\n                        index = j;\n                        break;\n                    }\n                }\n            }\n            if (index !== null) {\n                results.splice(index, 0, cmd);\n            }\n            else {\n                results.push(cmd);\n            }\n        }\n        return results;\n    }\n    Util.sortBatchCommands = sortBatchCommands;\n})(Util || (Util = {}));\n//# sourceMappingURL=history.js.map"]},"metadata":{},"sourceType":"module"}