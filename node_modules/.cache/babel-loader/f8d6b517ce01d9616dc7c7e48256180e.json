{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar LRUCache = function () {\n  function LRUCache() {\n    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    var destroy = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : function () {\n      return '';\n    };\n\n    _classCallCheck(this, LRUCache);\n\n    _defineProperty(this, \"limit\", void 0);\n\n    _defineProperty(this, \"order\", void 0);\n\n    _defineProperty(this, \"cache\", void 0);\n\n    _defineProperty(this, \"destroy\", void 0);\n\n    this.limit = limit;\n    this.destroy = destroy;\n    this.order = [];\n    this.clear();\n  }\n\n  _createClass(LRUCache, [{\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n\n      this.order.forEach(function (key) {\n        _this.delete(key);\n      });\n      this.cache = {};\n      this.order = [];\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var value = this.cache[key];\n\n      if (value) {\n        this.deleteOrder(key);\n        this.appendOrder(key);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      if (!this.cache[key]) {\n        if (Object.keys(this.cache).length === this.limit) {\n          this.delete(this.order[0]);\n        }\n\n        this.cache[key] = value;\n        this.appendOrder(key);\n      } else {\n        this.delete(key);\n        this.cache[key] = value;\n        this.appendOrder(key);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var value = this.cache[key];\n\n      if (value) {\n        this.deleteCache(key);\n        this.deleteOrder(key);\n        this.destroy(value, key);\n      }\n    }\n  }, {\n    key: \"deleteCache\",\n    value: function deleteCache(key) {\n      delete this.cache[key];\n    }\n  }, {\n    key: \"deleteOrder\",\n    value: function deleteOrder(key) {\n      var index = this.order.findIndex(function (o) {\n        return o === key;\n      });\n\n      if (index >= 0) {\n        this.order.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"appendOrder\",\n    value: function appendOrder(key) {\n      this.order.push(key);\n    }\n  }]);\n\n  return LRUCache;\n}();\n\nexport { LRUCache as default };","map":{"version":3,"sources":["../../../src/imagetile/utils/lruCache.ts"],"names":["LRUCache","limit","destroy","value","Object","index","o"],"mappings":"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","sourcesContent":["/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\n\nexport default class LRUCache {\n  public limit: number;\n  public order: any[];\n  public cache: any;\n  public destroy: any;\n  constructor(limit = 50, destroy = () => '') {\n    this.limit = limit;\n    this.destroy = destroy;\n    this.order = [];\n    this.clear();\n  }\n\n  public clear() {\n    this.order.forEach((key: any) => {\n      this.delete(key);\n    });\n    this.cache = {};\n    // access/update order, first item is oldest, last item is newest\n    this.order = [];\n  }\n\n  public get(key: string) {\n    const value = this.cache[key];\n    if (value) {\n      // update order\n      this.deleteOrder(key);\n      this.appendOrder(key);\n    }\n    return value;\n  }\n\n  public set(key: string, value: any) {\n    if (!this.cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this.cache).length === this.limit) {\n        this.delete(this.order[0]);\n      }\n\n      this.cache[key] = value;\n      this.appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this.cache[key] = value;\n      this.appendOrder(key);\n    }\n  }\n\n  public delete(key: string) {\n    const value = this.cache[key];\n    if (value) {\n      this.deleteCache(key);\n      this.deleteOrder(key);\n      this.destroy(value, key);\n    }\n  }\n\n  public deleteCache(key: string) {\n    delete this.cache[key];\n  }\n\n  public deleteOrder(key: string) {\n    const index = this.order.findIndex((o) => o === key);\n    if (index >= 0) {\n      this.order.splice(index, 1);\n    }\n  }\n\n  public appendOrder(key: string) {\n    this.order.push(key);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}