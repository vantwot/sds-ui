{"ast":null,"code":"function max(x) {\n  if (x.length === 0) {\n    throw new Error('max requires at least one data point');\n  }\n\n  var value = x[0];\n\n  for (var i = 1; i < x.length; i++) {\n    if (x[i] > value) {\n      value = x[i];\n    }\n  }\n\n  return value * 1;\n}\n\nfunction min(x) {\n  if (x.length === 0) {\n    throw new Error('min requires at least one data point');\n  }\n\n  var value = x[0];\n\n  for (var i = 1; i < x.length; i++) {\n    if (x[i] < value) {\n      value = x[i];\n    }\n  }\n\n  return value * 1;\n}\n\nfunction sum(x) {\n  if (x.length === 0) {\n    return 0;\n  }\n\n  var sumNum = x[0] * 1;\n\n  for (var i = 1; i < x.length; i++) {\n    sumNum += x[i] * 1;\n  }\n\n  return sumNum;\n}\n\nfunction mean(x) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n\n  return sum(x) / x.length;\n}\n\nfunction mode(x) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n\n  if (x.length < 3) {\n    return x[0];\n  }\n\n  x.sort();\n  var last = x[0];\n  var value = NaN;\n  var maxSeen = 0;\n  var seenThis = 1;\n\n  for (var i = 1; i < x.length + 1; i++) {\n    if (x[i] !== last) {\n      if (seenThis > maxSeen) {\n        maxSeen = seenThis;\n        value = last;\n      }\n\n      seenThis = 1;\n      last = x[i];\n    } else {\n      seenThis++;\n    }\n  }\n\n  return value * 1;\n}\n\nexport { sum, max, min, mean, mode };\nexport var statMap = {\n  min: min,\n  max: max,\n  mean: mean,\n  sum: sum,\n  mode: mode\n};\nexport function getColumn(data, columnName) {\n  return data.map(function (item) {\n    return item[columnName];\n  });\n}\nexport function getSatByColumn(type, column) {\n  return statMap[type](column);\n}","map":{"version":3,"sources":["../src/statistics.ts"],"names":["x","value","i","sumNum","sum","last","maxSeen","seenThis","statMap","min","max","mean","mode","item"],"mappings":"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","sourcesContent":["interface IItemData {\n  [key: string]: any;\n}\nfunction max(x: number[]) {\n  if (x.length === 0) {\n    throw new Error('max requires at least one data point');\n  }\n\n  let value = x[0];\n  for (let i = 1; i < x.length; i++) {\n    // On the first iteration of this loop, max is\n    // undefined and is thus made the maximum element in the array\n    if (x[i] > value) {\n      value = x[i];\n    }\n  }\n  return value * 1;\n}\n\nfunction min(x: number[]) {\n  if (x.length === 0) {\n    throw new Error('min requires at least one data point');\n  }\n\n  let value = x[0];\n  for (let i = 1; i < x.length; i++) {\n    // On the first iteration of this loop, min is\n    // undefined and is thus made the minimum element in the array\n    if (x[i] < value) {\n      value = x[i];\n    }\n  }\n  return value * 1;\n}\n\nfunction sum(x: number[]) {\n  // If the array is empty, we needn't bother computing its sum\n  if (x.length === 0) {\n    return 0;\n  }\n\n  // Initializing the sum as the first number in the array\n  let sumNum = x[0] * 1;\n\n  for (let i = 1; i < x.length; i++) {\n    sumNum += x[i] * 1;\n  }\n\n  // Returning the corrected sum\n  return sumNum;\n}\nfunction mean(x: number[]) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n  return sum(x) / x.length;\n}\n\nfunction mode(x: any[]) {\n  if (x.length === 0) {\n    throw new Error('mean requires at least one data point');\n  }\n  if (x.length < 3) {\n    return x[0];\n  }\n  x.sort();\n  let last = x[0];\n  let value = NaN;\n  let maxSeen = 0;\n  let seenThis = 1;\n\n  for (let i = 1; i < x.length + 1; i++) {\n    if (x[i] !== last) {\n      if (seenThis > maxSeen) {\n        maxSeen = seenThis;\n        value = last;\n      }\n      seenThis = 1;\n      last = x[i];\n    } else {\n      seenThis++;\n    }\n  }\n  return value * 1;\n}\n\nexport { sum, max, min, mean, mode };\nexport const statMap: { [key: string]: any } = {\n  min,\n  max,\n  mean,\n  sum,\n  mode,\n};\nexport function getColumn(data: IItemData[], columnName: string) {\n  return data.map((item: IItemData) => {\n    return item[columnName];\n  });\n}\n\nexport function getSatByColumn(type: string, column: number[]) {\n  return statMap[type](column);\n}\n"]},"metadata":{},"sourceType":"module"}