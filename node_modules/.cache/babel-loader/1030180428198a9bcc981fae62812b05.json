{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport EventTarget from './EventTarget';\nexport var Node = function (_EventTarget) {\n  _inherits(Node, _EventTarget);\n\n  var _super = _createSuper(Node);\n\n  function Node() {\n    var _this;\n\n    _classCallCheck(this, Node);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"childNodes\", void 0);\n\n    _this.childNodes = [];\n    return _this;\n  }\n\n  _createClass(Node, [{\n    key: \"appendChild\",\n    value: function appendChild(node) {\n      this.childNodes.push(node);\n    }\n  }, {\n    key: \"cloneNode\",\n    value: function cloneNode() {\n      var copyNode = Object.create(this);\n      Object.assign(copyNode, this);\n      return copyNode;\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(node) {\n      var index = this.childNodes.findIndex(function (child) {\n        return child === node;\n      });\n\n      if (index > -1) {\n        return this.childNodes.splice(index, 1);\n      }\n\n      return null;\n    }\n  }]);\n\n  return Node;\n}(EventTarget);","map":{"version":3,"sources":["../../src/mini-adapter/Node.ts"],"names":["Node","copyNode","Object","index","child"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAEA,OAAA,WAAA,MAAA,eAAA;AAEA,OAAA,IAAaA,IAAb,GAAA,UAAA,YAAA,EAAA;AAAA,EAAA,SAAA,CAAA,IAAA,EAAA,YAAA,CAAA;;AAAA,MAAA,MAAA,GAAA,YAAA,CAAA,IAAA,CAAA;;AAGE,WAAA,IAAA,GAAc;AAAA,QAAA,KAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,IAAA,CAAA;;AACZ,IAAA,KAAA,GAAA,MAAA,CAAA,IAAA,CAAA,IAAA,CAAA;;AADY,IAAA,eAAA,CAAA,sBAAA,CAAA,KAAA,CAAA,EAAA,YAAA,EAAA,KAAA,CAAA,CAAA;;AAEZ,IAAA,KAAA,CAAA,UAAA,GAAA,EAAA;AAFY,WAAA,KAAA;AAGb;;AANH,EAAA,YAAA,CAAA,IAAA,EAAA,CAAA;AAAA,IAAA,GAAA,EAAA,aAAA;AAAA,IAAA,KAAA,EAQE,SAAA,WAAA,CAAA,IAAA,EAAyB;AACvB,WAAA,UAAA,CAAA,IAAA,CAAA,IAAA;AAMD;AAfH,GAAA,EAAA;AAAA,IAAA,GAAA,EAAA,WAAA;AAAA,IAAA,KAAA,EAiBE,SAAA,SAAA,GAAmB;AACjB,UAAMC,QAAQ,GAAGC,MAAM,CAANA,MAAAA,CAAjB,IAAiBA,CAAjB;AAEAA,MAAAA,MAAM,CAANA,MAAAA,CAAAA,QAAAA,EAAAA,IAAAA;AACA,aAAA,QAAA;AACD;AAtBH,GAAA,EAAA;AAAA,IAAA,GAAA,EAAA,aAAA;AAAA,IAAA,KAAA,EAwBE,SAAA,WAAA,CAAA,IAAA,EAAyB;AACvB,UAAMC,KAAK,GAAG,KAAA,UAAA,CAAA,SAAA,CAA0B,UAAA,KAAA,EAAA;AAAA,eAAWC,KAAK,KAAhB,IAAA;AAAxC,OAAc,CAAd;;AAEA,UAAID,KAAK,GAAG,CAAZ,CAAA,EAAgB;AACd,eAAO,KAAA,UAAA,CAAA,MAAA,CAAA,KAAA,EAAP,CAAO,CAAP;AACD;;AACD,aAAA,IAAA;AACD;AA/BH,GAAA,CAAA,CAAA;;AAAA,SAAA,IAAA;AAAA,CAAA,CAAA,WAAA,CAAA","sourcesContent":["// @ts-nocheck\n// tslint:disable\nimport EventTarget from './EventTarget';\n\nexport class Node extends EventTarget {\n  public childNodes: any[];\n\n  constructor() {\n    super();\n    this.childNodes = [];\n  }\n\n  public appendChild(node) {\n    this.childNodes.push(node);\n    // if (node instanceof Node) {\n    //   this.childNodes.push(node)\n    // } else {\n    //   throw new TypeError('Failed to executed \\'appendChild\\' on \\'Node\\': parameter 1 is not of type \\'Node\\'.')\n    // }\n  }\n\n  public cloneNode() {\n    const copyNode = Object.create(this);\n\n    Object.assign(copyNode, this);\n    return copyNode;\n  }\n\n  public removeChild(node) {\n    const index = this.childNodes.findIndex((child) => child === node);\n\n    if (index > -1) {\n      return this.childNodes.splice(index, 1);\n    }\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}