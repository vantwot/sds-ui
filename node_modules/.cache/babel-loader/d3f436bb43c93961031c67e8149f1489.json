{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Registry } from '../registry';\nimport { Point, Rectangle, Angle } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt } from '../util';\nimport { Markup } from '../view/markup';\nimport { Cell } from './cell';\nimport { ShareRegistry } from './registry';\nimport { PortManager } from './port';\nimport { Interp } from '../common';\nexport class Node extends Cell {\n  constructor() {\n    let metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(metadata);\n    this.initPorts();\n  }\n\n  get [Symbol.toStringTag]() {\n    return Node.toStringTag;\n  }\n\n  preprocess(metadata, ignoreIdCheck) {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = metadata,\n          others = __rest(metadata, [\"x\", \"y\", \"width\", \"height\"]);\n\n    if (x != null || y != null) {\n      const position = others.position;\n      others.position = Object.assign(Object.assign({}, position), {\n        x: x != null ? x : position ? position.x : 0,\n        y: y != null ? y : position ? position.y : 0\n      });\n    }\n\n    if (width != null || height != null) {\n      const size = others.size;\n      others.size = Object.assign(Object.assign({}, size), {\n        width: width != null ? width : size ? size.width : 0,\n        height: height != null ? height : size ? size.height : 0\n      });\n    }\n\n    return super.preprocess(others, ignoreIdCheck);\n  }\n\n  isNode() {\n    return true;\n  }\n\n  size(width, height, options) {\n    if (width === undefined) {\n      return this.getSize();\n    }\n\n    if (typeof width === 'number') {\n      return this.setSize(width, height, options);\n    }\n\n    return this.setSize(width, height);\n  }\n\n  getSize() {\n    const size = this.store.get('size');\n    return size ? Object.assign({}, size) : {\n      width: 1,\n      height: 1\n    };\n  }\n\n  setSize(width, height, options) {\n    if (typeof width === 'object') {\n      this.resize(width.width, width.height, height);\n    } else {\n      this.resize(width, height, options);\n    }\n\n    return this;\n  }\n\n  resize(width, height) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.startBatch('resize', options);\n    const direction = options.direction;\n\n    if (direction) {\n      const currentSize = this.getSize();\n\n      switch (direction) {\n        case 'left':\n        case 'right':\n          // Don't change height when resizing horizontally.\n          height = currentSize.height; // eslint-disable-line\n\n          break;\n\n        case 'top':\n        case 'bottom':\n          // Don't change width when resizing vertically.\n          width = currentSize.width; // eslint-disable-line\n\n          break;\n\n        default:\n          break;\n      }\n\n      const map = {\n        right: 0,\n        'top-right': 0,\n        top: 1,\n        'top-left': 1,\n        left: 2,\n        'bottom-left': 2,\n        bottom: 3,\n        'bottom-right': 3\n      };\n      let quadrant = map[direction];\n      const angle = Angle.normalize(this.getAngle() || 0);\n\n      if (options.absolute) {\n        // We are taking the node's rotation into account\n        quadrant += Math.floor((angle + 45) / 90);\n        quadrant %= 4;\n      } // This is a rectangle in size of the un-rotated node.\n\n\n      const bbox = this.getBBox(); // Pick the corner point on the node, which meant to stay on its\n      // place before and after the rotation.\n\n      let fixedPoint;\n\n      if (quadrant === 0) {\n        fixedPoint = bbox.getBottomLeft();\n      } else if (quadrant === 1) {\n        fixedPoint = bbox.getCorner();\n      } else if (quadrant === 2) {\n        fixedPoint = bbox.getTopRight();\n      } else {\n        fixedPoint = bbox.getOrigin();\n      } // Find an image of the previous indent point. This is the position,\n      // where is the point actually located on the screen.\n\n\n      const imageFixedPoint = fixedPoint.clone().rotate(-angle, bbox.getCenter()); // Every point on the element rotates around a circle with the centre of\n      // rotation in the middle of the element while the whole element is being\n      // rotated. That means that the distance from a point in the corner of\n      // the element (supposed its always rect) to the center of the element\n      // doesn't change during the rotation and therefore it equals to a\n      // distance on un-rotated element.\n      // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n\n      const radius = Math.sqrt(width * width + height * height) / 2; // Now we are looking for an angle between x-axis and the line starting\n      // at image of fixed point and ending at the center of the element.\n      // We call this angle `alpha`.\n      // The image of a fixed point is located in n-th quadrant. For each\n      // quadrant passed going anti-clockwise we have to add 90 degrees.\n      // Note that the first quadrant has index 0.\n      //\n      // 3 | 2\n      // --c-- Quadrant positions around the element's center `c`\n      // 0 | 1\n      //\n\n      let alpha = quadrant * Math.PI / 2; // Add an angle between the beginning of the current quadrant (line\n      // parallel with x-axis or y-axis going through the center of the\n      // element) and line crossing the indent of the fixed point and the\n      // center of the element. This is the angle we need but on the\n      // un-rotated element.\n\n      alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height); // Lastly we have to deduct the original angle the element was rotated\n      // by and that's it.\n\n      alpha -= Angle.toRad(angle); // With this angle and distance we can easily calculate the centre of\n      // the un-rotated element.\n      // Note that fromPolar constructor accepts an angle in radians.\n\n      const center = Point.fromPolar(radius, alpha, imageFixedPoint); // The top left corner on the un-rotated element has to be half a width\n      // on the left and half a height to the top from the center. This will\n      // be the origin of rectangle we were looking for.\n\n      const origin = center.clone().translate(width / -2, height / -2);\n      this.store.set('size', {\n        width,\n        height\n      }, options);\n      this.setPosition(origin.x, origin.y, options);\n    } else {\n      this.store.set('size', {\n        width,\n        height\n      }, options);\n    }\n\n    this.stopBatch('resize', options);\n    return this;\n  }\n\n  scale(sx, sy, origin) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);\n    this.startBatch('scale', options);\n    this.setPosition(scaledBBox.x, scaledBBox.y, options);\n    this.resize(scaledBBox.width, scaledBBox.height, options);\n    this.stopBatch('scale');\n    return this;\n  }\n\n  position(arg0, arg1, arg2) {\n    if (typeof arg0 === 'number') {\n      return this.setPosition(arg0, arg1, arg2);\n    }\n\n    return this.getPosition(arg0);\n  }\n\n  getPosition() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.relative) {\n      const parent = this.getParent();\n\n      if (parent != null && parent.isNode()) {\n        const currentPosition = this.getPosition();\n        const parentPosition = parent.getPosition();\n        return {\n          x: currentPosition.x - parentPosition.x,\n          y: currentPosition.y - parentPosition.y\n        };\n      }\n    }\n\n    const pos = this.store.get('position');\n    return pos ? Object.assign({}, pos) : {\n      x: 0,\n      y: 0\n    };\n  }\n\n  setPosition(arg0, arg1) {\n    let arg2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let x;\n    let y;\n    let options;\n\n    if (typeof arg0 === 'object') {\n      x = arg0.x;\n      y = arg0.y;\n      options = arg1 || {};\n    } else {\n      x = arg0;\n      y = arg1;\n      options = arg2 || {};\n    }\n\n    if (options.relative) {\n      const parent = this.getParent();\n\n      if (parent != null && parent.isNode()) {\n        const parentPosition = parent.getPosition();\n        x += parentPosition.x;\n        y += parentPosition.y;\n      }\n    }\n\n    if (options.deep) {\n      const currentPosition = this.getPosition();\n      this.translate(x - currentPosition.x, y - currentPosition.y, options);\n    } else {\n      this.store.set('position', {\n        x,\n        y\n      }, options);\n    }\n\n    return this;\n  }\n\n  translate() {\n    let tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    let ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (tx === 0 && ty === 0) {\n      return this;\n    } // Pass the initiator of the translation.\n\n\n    options.translateBy = options.translateBy || this.id;\n    const position = this.getPosition();\n\n    if (options.restrict != null && options.translateBy === this.id) {\n      // We are restricting the translation for the element itself only. We get\n      // the bounding box of the element including all its embeds.\n      // All embeds have to be translated the exact same way as the element.\n      const bbox = this.getBBox({\n        deep: true\n      });\n      const ra = options.restrict; // - - - - - - - - - - - - -> ra.x + ra.width\n      // - - - -> position.x      |\n      // -> bbox.x\n      //                ▓▓▓▓▓▓▓   |\n      //         ░░░░░░░▓▓▓▓▓▓▓\n      //         ░░░░░░░░░        |\n      //   ▓▓▓▓▓▓▓▓░░░░░░░\n      //   ▓▓▓▓▓▓▓▓               |\n      //   <-dx->                     | restricted area right border\n      //         <-width->        |   ░ translated element\n      //   <- - bbox.width - ->       ▓ embedded element\n\n      const dx = position.x - bbox.x;\n      const dy = position.y - bbox.y; // Find the maximal/minimal coordinates that the element can be translated\n      // while complies the restrictions.\n\n      const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n      const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty)); // recalculate the translation taking the restrictions into account.\n\n      tx = x - position.x; // eslint-disable-line\n\n      ty = y - position.y; // eslint-disable-line\n    }\n\n    const translatedPosition = {\n      x: position.x + tx,\n      y: position.y + ty\n    }; // To find out by how much an element was translated in event\n    // 'change:position' handlers.\n\n    options.tx = tx;\n    options.ty = ty;\n\n    if (options.transition) {\n      if (typeof options.transition !== 'object') {\n        options.transition = {};\n      }\n\n      this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), {\n        interp: Interp.object\n      }));\n      this.eachChild(child => {\n        var _a;\n\n        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n\n        if (!excluded) {\n          child.translate(tx, ty, options);\n        }\n      });\n    } else {\n      this.startBatch('translate', options);\n      this.store.set('position', translatedPosition, options);\n      this.eachChild(child => {\n        var _a;\n\n        const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n\n        if (!excluded) {\n          child.translate(tx, ty, options);\n        }\n      });\n      this.stopBatch('translate', options);\n    }\n\n    return this;\n  }\n\n  angle(val, options) {\n    if (val == null) {\n      return this.getAngle();\n    }\n\n    return this.rotate(val, options);\n  }\n\n  getAngle() {\n    return this.store.get('angle', 0);\n  }\n\n  rotate(angle) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const currentAngle = this.getAngle();\n\n    if (options.center) {\n      const size = this.getSize();\n      const position = this.getPosition();\n      const center = this.getBBox().getCenter();\n      center.rotate(currentAngle - angle, options.center);\n      const dx = center.x - size.width / 2 - position.x;\n      const dy = center.y - size.height / 2 - position.y;\n      this.startBatch('rotate', {\n        angle,\n        options\n      });\n      this.setPosition(position.x + dx, position.y + dy, options);\n      this.rotate(angle, Object.assign(Object.assign({}, options), {\n        center: null\n      }));\n      this.stopBatch('rotate');\n    } else {\n      this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);\n    }\n\n    return this;\n  } // #endregion\n  // #region common\n\n\n  getBBox() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.deep) {\n      const cells = this.getDescendants({\n        deep: true,\n        breadthFirst: true\n      });\n      cells.push(this);\n      return Cell.getCellsBBox(cells);\n    }\n\n    return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());\n  }\n\n  getConnectionPoint(edge, type) {\n    const bbox = this.getBBox();\n    const center = bbox.getCenter();\n    const terminal = edge.getTerminal(type);\n\n    if (terminal == null) {\n      return center;\n    }\n\n    const portId = terminal.port;\n\n    if (!portId || !this.hasPort(portId)) {\n      return center;\n    }\n\n    const port = this.getPort(portId);\n\n    if (!port || !port.group) {\n      return center;\n    }\n\n    const layouts = this.getPortsPosition(port.group);\n    const position = layouts[portId].position;\n    const portCenter = Point.create(position).translate(bbox.getOrigin());\n    const angle = this.getAngle();\n\n    if (angle) {\n      portCenter.rotate(-angle, center);\n    }\n\n    return portCenter;\n  }\n  /**\n   * Sets cell's size and position based on the children bbox and given padding.\n   */\n\n\n  fit() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const children = this.getChildren() || [];\n    const embeds = children.filter(cell => cell.isNode());\n\n    if (embeds.length === 0) {\n      return this;\n    }\n\n    this.startBatch('fit-embeds', options);\n\n    if (options.deep) {\n      embeds.forEach(cell => cell.fit(options));\n    }\n\n    let {\n      x,\n      y,\n      width,\n      height\n    } = Cell.getCellsBBox(embeds);\n    const padding = NumberExt.normalizeSides(options.padding);\n    x -= padding.left;\n    y -= padding.top;\n    width += padding.left + padding.right;\n    height += padding.bottom + padding.top;\n    this.store.set({\n      position: {\n        x,\n        y\n      },\n      size: {\n        width,\n        height\n      }\n    }, options);\n    this.stopBatch('fit-embeds');\n    return this;\n  } // #endregion\n  // #region ports\n\n\n  get portContainerMarkup() {\n    return this.getPortContainerMarkup();\n  }\n\n  set portContainerMarkup(markup) {\n    this.setPortContainerMarkup(markup);\n  }\n\n  getDefaultPortContainerMarkup() {\n    return this.store.get('defaultPortContainerMarkup') || Markup.getPortContainerMarkup();\n  }\n\n  getPortContainerMarkup() {\n    return this.store.get('portContainerMarkup') || this.getDefaultPortContainerMarkup();\n  }\n\n  setPortContainerMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('portContainerMarkup', Markup.clone(markup), options);\n    return this;\n  }\n\n  get portMarkup() {\n    return this.getPortMarkup();\n  }\n\n  set portMarkup(markup) {\n    this.setPortMarkup(markup);\n  }\n\n  getDefaultPortMarkup() {\n    return this.store.get('defaultPortMarkup') || Markup.getPortMarkup();\n  }\n\n  getPortMarkup() {\n    return this.store.get('portMarkup') || this.getDefaultPortMarkup();\n  }\n\n  setPortMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('portMarkup', Markup.clone(markup), options);\n    return this;\n  }\n\n  get portLabelMarkup() {\n    return this.getPortLabelMarkup();\n  }\n\n  set portLabelMarkup(markup) {\n    this.setPortLabelMarkup(markup);\n  }\n\n  getDefaultPortLabelMarkup() {\n    return this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup();\n  }\n\n  getPortLabelMarkup() {\n    return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();\n  }\n\n  setPortLabelMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('portLabelMarkup', Markup.clone(markup), options);\n    return this;\n  }\n\n  get ports() {\n    const res = this.store.get('ports', {\n      items: []\n    });\n\n    if (res.items == null) {\n      res.items = [];\n    }\n\n    return res;\n  }\n\n  getPorts() {\n    return ObjectExt.cloneDeep(this.ports.items);\n  }\n\n  getPortsByGroup(groupName) {\n    return this.getPorts().filter(port => port.group === groupName);\n  }\n\n  getPort(portId) {\n    return ObjectExt.cloneDeep(this.ports.items.find(port => port.id && port.id === portId));\n  }\n\n  getPortAt(index) {\n    return this.ports.items[index] || null;\n  }\n\n  hasPorts() {\n    return this.ports.items.length > 0;\n  }\n\n  hasPort(portId) {\n    return this.getPortIndex(portId) !== -1;\n  }\n\n  getPortIndex(port) {\n    const portId = typeof port === 'string' ? port : port.id;\n    return portId != null ? this.ports.items.findIndex(item => item.id === portId) : -1;\n  }\n\n  getPortsPosition(groupName) {\n    const size = this.getSize();\n    const layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size.width, size.height));\n    return layouts.reduce((memo, item) => {\n      const layout = item.portLayout;\n      memo[item.portId] = {\n        position: Object.assign({}, layout.position),\n        angle: layout.angle || 0\n      };\n      return memo;\n    }, {});\n  }\n\n  getPortProp(portId, path) {\n    return this.getPropByPath(this.prefixPortPath(portId, path));\n  }\n\n  setPortProp(portId, arg1, arg2, arg3) {\n    if (typeof arg1 === 'string' || Array.isArray(arg1)) {\n      const path = this.prefixPortPath(portId, arg1);\n      const value = arg2;\n      return this.setPropByPath(path, value, arg3);\n    }\n\n    const path = this.prefixPortPath(portId);\n    const value = arg1;\n    return this.setPropByPath(path, value, arg2);\n  }\n\n  removePortProp(portId, path, options) {\n    if (typeof path === 'string' || Array.isArray(path)) {\n      return this.removePropByPath(this.prefixPortPath(portId, path), options);\n    }\n\n    return this.removePropByPath(this.prefixPortPath(portId), path);\n  }\n\n  portProp(portId, path, value, options) {\n    if (path == null) {\n      return this.getPortProp(portId);\n    }\n\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 2) {\n        return this.getPortProp(portId, path);\n      }\n\n      if (value == null) {\n        return this.removePortProp(portId, path, options);\n      }\n\n      return this.setPortProp(portId, path, value, options);\n    }\n\n    return this.setPortProp(portId, path, value);\n  }\n\n  prefixPortPath(portId, path) {\n    const index = this.getPortIndex(portId);\n\n    if (index === -1) {\n      throw new Error(`Unable to find port with id: \"${portId}\"`);\n    }\n\n    if (path == null || path === '') {\n      return ['ports', 'items', `${index}`];\n    }\n\n    if (Array.isArray(path)) {\n      return ['ports', 'items', `${index}`, ...path];\n    }\n\n    return `ports/items/${index}/${path}`;\n  }\n\n  addPort(port, options) {\n    const ports = [...this.ports.items];\n    ports.push(port);\n    this.setPropByPath('ports/items', ports, options);\n    return this;\n  }\n\n  addPorts(ports, options) {\n    this.setPropByPath('ports/items', [...this.ports.items, ...ports], options);\n    return this;\n  }\n\n  removePort(port) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.removePortAt(this.getPortIndex(port), options);\n  }\n\n  removePortAt(index) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (index >= 0) {\n      const ports = [...this.ports.items];\n      ports.splice(index, 1);\n      options.rewrite = true;\n      this.setPropByPath('ports/items', ports, options);\n    }\n\n    return this;\n  }\n\n  removePorts(portsForRemoval, opt) {\n    let options;\n\n    if (Array.isArray(portsForRemoval)) {\n      options = opt || {};\n\n      if (portsForRemoval.length) {\n        options.rewrite = true;\n        const currentPorts = [...this.ports.items];\n        const remainingPorts = currentPorts.filter(cp => !portsForRemoval.some(p => {\n          const id = typeof p === 'string' ? p : p.id;\n          return cp.id === id;\n        }));\n        this.setPropByPath('ports/items', remainingPorts, options);\n      }\n    } else {\n      options = portsForRemoval || {};\n      options.rewrite = true;\n      this.setPropByPath('ports/items', [], options);\n    }\n\n    return this;\n  }\n\n  getParsedPorts() {\n    return this.port.getPorts();\n  }\n\n  getParsedGroups() {\n    return this.port.groups;\n  }\n\n  getPortsLayoutByGroup(groupName, bbox) {\n    return this.port.getPortsLayoutByGroup(groupName, bbox);\n  }\n\n  initPorts() {\n    this.updatePortData();\n    this.on('change:ports', () => {\n      this.processRemovedPort();\n      this.updatePortData();\n    });\n  }\n\n  processRemovedPort() {\n    const current = this.ports;\n    const currentItemsMap = {};\n    current.items.forEach(item => {\n      if (item.id) {\n        currentItemsMap[item.id] = true;\n      }\n    });\n    const removed = {};\n    const previous = this.store.getPrevious('ports') || {\n      items: []\n    };\n    previous.items.forEach(item => {\n      if (item.id && !currentItemsMap[item.id]) {\n        removed[item.id] = true;\n      }\n    });\n    const model = this.model;\n\n    if (model && !ObjectExt.isEmpty(removed)) {\n      const incomings = model.getConnectedEdges(this, {\n        incoming: true\n      });\n      incomings.forEach(edge => {\n        const portId = edge.getTargetPortId();\n\n        if (portId && removed[portId]) {\n          edge.remove();\n        }\n      });\n      const outgoings = model.getConnectedEdges(this, {\n        outgoing: true\n      });\n      outgoings.forEach(edge => {\n        const portId = edge.getSourcePortId();\n\n        if (portId && removed[portId]) {\n          edge.remove();\n        }\n      });\n    }\n  }\n\n  validatePorts() {\n    const ids = {};\n    const errors = [];\n    this.ports.items.forEach(p => {\n      if (typeof p !== 'object') {\n        errors.push(`Invalid port ${p}.`);\n      }\n\n      if (p.id == null) {\n        p.id = this.generatePortId();\n      }\n\n      if (ids[p.id]) {\n        errors.push('Duplicitied port id.');\n      }\n\n      ids[p.id] = true;\n    });\n    return errors;\n  }\n\n  generatePortId() {\n    return StringExt.uuid();\n  }\n\n  updatePortData() {\n    const err = this.validatePorts();\n\n    if (err.length > 0) {\n      this.store.set('ports', this.store.getPrevious('ports'));\n      throw new Error(err.join(' '));\n    }\n\n    const prev = this.port ? this.port.getPorts() : null;\n    this.port = new PortManager(this.ports);\n    const curr = this.port.getPorts();\n    const added = prev ? curr.filter(item => {\n      if (!prev.find(prevPort => prevPort.id === item.id)) {\n        return item;\n      }\n\n      return null;\n    }) : [...curr];\n    const removed = prev ? prev.filter(item => {\n      if (!curr.find(curPort => curPort.id === item.id)) {\n        return item;\n      }\n\n      return null;\n    }) : [];\n\n    if (added.length > 0) {\n      this.notify('ports:added', {\n        added,\n        cell: this,\n        node: this\n      });\n    }\n\n    if (removed.length > 0) {\n      this.notify('ports:removed', {\n        removed,\n        cell: this,\n        node: this\n      });\n    }\n  }\n\n}\nNode.defaults = {\n  angle: 0,\n  position: {\n    x: 0,\n    y: 0\n  },\n  size: {\n    width: 1,\n    height: 1\n  }\n};\n\n(function (Node) {\n  Node.toStringTag = `X6.${Node.name}`;\n\n  function isNode(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Node) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const node = instance;\n\n    if ((tag == null || tag === Node.toStringTag) && typeof node.isNode === 'function' && typeof node.isEdge === 'function' && typeof node.prop === 'function' && typeof node.attr === 'function' && typeof node.size === 'function' && typeof node.position === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Node.isNode = isNode;\n})(Node || (Node = {}));\n\n(function (Node) {\n  Node.config({\n    propHooks(_a) {\n      var {\n        ports\n      } = _a,\n          metadata = __rest(_a, [\"ports\"]);\n\n      if (ports) {\n        metadata.ports = Array.isArray(ports) ? {\n          items: ports\n        } : ports;\n      }\n\n      return metadata;\n    }\n\n  });\n})(Node || (Node = {}));\n\n(function (Node) {\n  Node.registry = Registry.create({\n    type: 'node',\n\n    process(shape, options) {\n      if (ShareRegistry.exist(shape, true)) {\n        throw new Error(`Node with name '${shape}' was registered by anthor Edge`);\n      }\n\n      if (typeof options === 'function') {\n        options.config({\n          shape\n        });\n        return options;\n      }\n\n      let parent = Node;\n\n      const {\n        inherit\n      } = options,\n            config = __rest(options, [\"inherit\"]);\n\n      if (inherit) {\n        if (typeof inherit === 'string') {\n          const base = this.get(inherit);\n\n          if (base == null) {\n            this.onNotFound(inherit, 'inherited');\n          } else {\n            parent = base;\n          }\n        } else {\n          parent = inherit;\n        }\n      }\n\n      if (config.constructorName == null) {\n        config.constructorName = shape;\n      }\n\n      const ctor = parent.define.call(parent, config);\n      ctor.config({\n        shape\n      });\n      return ctor;\n    }\n\n  });\n  ShareRegistry.setNodeRegistry(Node.registry);\n})(Node || (Node = {}));\n\n(function (Node) {\n  let counter = 0;\n\n  function getClassName(name) {\n    if (name) {\n      return StringExt.pascalCase(name);\n    }\n\n    counter += 1;\n    return `CustomNode${counter}`;\n  }\n\n  function define(config) {\n    const {\n      constructorName,\n      overwrite\n    } = config,\n          others = __rest(config, [\"constructorName\", \"overwrite\"]);\n\n    const ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n    ctor.config(others);\n\n    if (others.shape) {\n      Node.registry.register(others.shape, ctor, overwrite);\n    }\n\n    return ctor;\n  }\n\n  Node.define = define;\n\n  function create(options) {\n    const shape = options.shape || 'rect';\n    const Ctor = Node.registry.get(shape);\n\n    if (Ctor) {\n      return new Ctor(options);\n    }\n\n    return Node.registry.onNotFound(shape);\n  }\n\n  Node.create = create;\n})(Node || (Node = {}));","map":{"version":3,"sources":["../../src/model/node.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { Registry } from '../registry';\nimport { Point, Rectangle, Angle } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt } from '../util';\nimport { Markup } from '../view/markup';\nimport { Cell } from './cell';\nimport { ShareRegistry } from './registry';\nimport { PortManager } from './port';\nimport { Interp } from '../common';\nexport class Node extends Cell {\n    constructor(metadata = {}) {\n        super(metadata);\n        this.initPorts();\n    }\n    get [Symbol.toStringTag]() {\n        return Node.toStringTag;\n    }\n    preprocess(metadata, ignoreIdCheck) {\n        const { x, y, width, height } = metadata, others = __rest(metadata, [\"x\", \"y\", \"width\", \"height\"]);\n        if (x != null || y != null) {\n            const position = others.position;\n            others.position = Object.assign(Object.assign({}, position), { x: x != null ? x : position ? position.x : 0, y: y != null ? y : position ? position.y : 0 });\n        }\n        if (width != null || height != null) {\n            const size = others.size;\n            others.size = Object.assign(Object.assign({}, size), { width: width != null ? width : size ? size.width : 0, height: height != null ? height : size ? size.height : 0 });\n        }\n        return super.preprocess(others, ignoreIdCheck);\n    }\n    isNode() {\n        return true;\n    }\n    size(width, height, options) {\n        if (width === undefined) {\n            return this.getSize();\n        }\n        if (typeof width === 'number') {\n            return this.setSize(width, height, options);\n        }\n        return this.setSize(width, height);\n    }\n    getSize() {\n        const size = this.store.get('size');\n        return size ? Object.assign({}, size) : { width: 1, height: 1 };\n    }\n    setSize(width, height, options) {\n        if (typeof width === 'object') {\n            this.resize(width.width, width.height, height);\n        }\n        else {\n            this.resize(width, height, options);\n        }\n        return this;\n    }\n    resize(width, height, options = {}) {\n        this.startBatch('resize', options);\n        const direction = options.direction;\n        if (direction) {\n            const currentSize = this.getSize();\n            switch (direction) {\n                case 'left':\n                case 'right':\n                    // Don't change height when resizing horizontally.\n                    height = currentSize.height; // eslint-disable-line\n                    break;\n                case 'top':\n                case 'bottom':\n                    // Don't change width when resizing vertically.\n                    width = currentSize.width; // eslint-disable-line\n                    break;\n                default:\n                    break;\n            }\n            const map = {\n                right: 0,\n                'top-right': 0,\n                top: 1,\n                'top-left': 1,\n                left: 2,\n                'bottom-left': 2,\n                bottom: 3,\n                'bottom-right': 3,\n            };\n            let quadrant = map[direction];\n            const angle = Angle.normalize(this.getAngle() || 0);\n            if (options.absolute) {\n                // We are taking the node's rotation into account\n                quadrant += Math.floor((angle + 45) / 90);\n                quadrant %= 4;\n            }\n            // This is a rectangle in size of the un-rotated node.\n            const bbox = this.getBBox();\n            // Pick the corner point on the node, which meant to stay on its\n            // place before and after the rotation.\n            let fixedPoint;\n            if (quadrant === 0) {\n                fixedPoint = bbox.getBottomLeft();\n            }\n            else if (quadrant === 1) {\n                fixedPoint = bbox.getCorner();\n            }\n            else if (quadrant === 2) {\n                fixedPoint = bbox.getTopRight();\n            }\n            else {\n                fixedPoint = bbox.getOrigin();\n            }\n            // Find an image of the previous indent point. This is the position,\n            // where is the point actually located on the screen.\n            const imageFixedPoint = fixedPoint\n                .clone()\n                .rotate(-angle, bbox.getCenter());\n            // Every point on the element rotates around a circle with the centre of\n            // rotation in the middle of the element while the whole element is being\n            // rotated. That means that the distance from a point in the corner of\n            // the element (supposed its always rect) to the center of the element\n            // doesn't change during the rotation and therefore it equals to a\n            // distance on un-rotated element.\n            // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n            const radius = Math.sqrt(width * width + height * height) / 2;\n            // Now we are looking for an angle between x-axis and the line starting\n            // at image of fixed point and ending at the center of the element.\n            // We call this angle `alpha`.\n            // The image of a fixed point is located in n-th quadrant. For each\n            // quadrant passed going anti-clockwise we have to add 90 degrees.\n            // Note that the first quadrant has index 0.\n            //\n            // 3 | 2\n            // --c-- Quadrant positions around the element's center `c`\n            // 0 | 1\n            //\n            let alpha = (quadrant * Math.PI) / 2;\n            // Add an angle between the beginning of the current quadrant (line\n            // parallel with x-axis or y-axis going through the center of the\n            // element) and line crossing the indent of the fixed point and the\n            // center of the element. This is the angle we need but on the\n            // un-rotated element.\n            alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height);\n            // Lastly we have to deduct the original angle the element was rotated\n            // by and that's it.\n            alpha -= Angle.toRad(angle);\n            // With this angle and distance we can easily calculate the centre of\n            // the un-rotated element.\n            // Note that fromPolar constructor accepts an angle in radians.\n            const center = Point.fromPolar(radius, alpha, imageFixedPoint);\n            // The top left corner on the un-rotated element has to be half a width\n            // on the left and half a height to the top from the center. This will\n            // be the origin of rectangle we were looking for.\n            const origin = center.clone().translate(width / -2, height / -2);\n            this.store.set('size', { width, height }, options);\n            this.setPosition(origin.x, origin.y, options);\n        }\n        else {\n            this.store.set('size', { width, height }, options);\n        }\n        this.stopBatch('resize', options);\n        return this;\n    }\n    scale(sx, sy, origin, options = {}) {\n        const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);\n        this.startBatch('scale', options);\n        this.setPosition(scaledBBox.x, scaledBBox.y, options);\n        this.resize(scaledBBox.width, scaledBBox.height, options);\n        this.stopBatch('scale');\n        return this;\n    }\n    position(arg0, arg1, arg2) {\n        if (typeof arg0 === 'number') {\n            return this.setPosition(arg0, arg1, arg2);\n        }\n        return this.getPosition(arg0);\n    }\n    getPosition(options = {}) {\n        if (options.relative) {\n            const parent = this.getParent();\n            if (parent != null && parent.isNode()) {\n                const currentPosition = this.getPosition();\n                const parentPosition = parent.getPosition();\n                return {\n                    x: currentPosition.x - parentPosition.x,\n                    y: currentPosition.y - parentPosition.y,\n                };\n            }\n        }\n        const pos = this.store.get('position');\n        return pos ? Object.assign({}, pos) : { x: 0, y: 0 };\n    }\n    setPosition(arg0, arg1, arg2 = {}) {\n        let x;\n        let y;\n        let options;\n        if (typeof arg0 === 'object') {\n            x = arg0.x;\n            y = arg0.y;\n            options = arg1 || {};\n        }\n        else {\n            x = arg0;\n            y = arg1;\n            options = arg2 || {};\n        }\n        if (options.relative) {\n            const parent = this.getParent();\n            if (parent != null && parent.isNode()) {\n                const parentPosition = parent.getPosition();\n                x += parentPosition.x;\n                y += parentPosition.y;\n            }\n        }\n        if (options.deep) {\n            const currentPosition = this.getPosition();\n            this.translate(x - currentPosition.x, y - currentPosition.y, options);\n        }\n        else {\n            this.store.set('position', { x, y }, options);\n        }\n        return this;\n    }\n    translate(tx = 0, ty = 0, options = {}) {\n        if (tx === 0 && ty === 0) {\n            return this;\n        }\n        // Pass the initiator of the translation.\n        options.translateBy = options.translateBy || this.id;\n        const position = this.getPosition();\n        if (options.restrict != null && options.translateBy === this.id) {\n            // We are restricting the translation for the element itself only. We get\n            // the bounding box of the element including all its embeds.\n            // All embeds have to be translated the exact same way as the element.\n            const bbox = this.getBBox({ deep: true });\n            const ra = options.restrict;\n            // - - - - - - - - - - - - -> ra.x + ra.width\n            // - - - -> position.x      |\n            // -> bbox.x\n            //                ▓▓▓▓▓▓▓   |\n            //         ░░░░░░░▓▓▓▓▓▓▓\n            //         ░░░░░░░░░        |\n            //   ▓▓▓▓▓▓▓▓░░░░░░░\n            //   ▓▓▓▓▓▓▓▓               |\n            //   <-dx->                     | restricted area right border\n            //         <-width->        |   ░ translated element\n            //   <- - bbox.width - ->       ▓ embedded element\n            const dx = position.x - bbox.x;\n            const dy = position.y - bbox.y;\n            // Find the maximal/minimal coordinates that the element can be translated\n            // while complies the restrictions.\n            const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n            const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n            // recalculate the translation taking the restrictions into account.\n            tx = x - position.x; // eslint-disable-line\n            ty = y - position.y; // eslint-disable-line\n        }\n        const translatedPosition = {\n            x: position.x + tx,\n            y: position.y + ty,\n        };\n        // To find out by how much an element was translated in event\n        // 'change:position' handlers.\n        options.tx = tx;\n        options.ty = ty;\n        if (options.transition) {\n            if (typeof options.transition !== 'object') {\n                options.transition = {};\n            }\n            this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), { interp: Interp.object }));\n            this.eachChild((child) => {\n                var _a;\n                const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n                if (!excluded) {\n                    child.translate(tx, ty, options);\n                }\n            });\n        }\n        else {\n            this.startBatch('translate', options);\n            this.store.set('position', translatedPosition, options);\n            this.eachChild((child) => {\n                var _a;\n                const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n                if (!excluded) {\n                    child.translate(tx, ty, options);\n                }\n            });\n            this.stopBatch('translate', options);\n        }\n        return this;\n    }\n    angle(val, options) {\n        if (val == null) {\n            return this.getAngle();\n        }\n        return this.rotate(val, options);\n    }\n    getAngle() {\n        return this.store.get('angle', 0);\n    }\n    rotate(angle, options = {}) {\n        const currentAngle = this.getAngle();\n        if (options.center) {\n            const size = this.getSize();\n            const position = this.getPosition();\n            const center = this.getBBox().getCenter();\n            center.rotate(currentAngle - angle, options.center);\n            const dx = center.x - size.width / 2 - position.x;\n            const dy = center.y - size.height / 2 - position.y;\n            this.startBatch('rotate', { angle, options });\n            this.setPosition(position.x + dx, position.y + dy, options);\n            this.rotate(angle, Object.assign(Object.assign({}, options), { center: null }));\n            this.stopBatch('rotate');\n        }\n        else {\n            this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);\n        }\n        return this;\n    }\n    // #endregion\n    // #region common\n    getBBox(options = {}) {\n        if (options.deep) {\n            const cells = this.getDescendants({ deep: true, breadthFirst: true });\n            cells.push(this);\n            return Cell.getCellsBBox(cells);\n        }\n        return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());\n    }\n    getConnectionPoint(edge, type) {\n        const bbox = this.getBBox();\n        const center = bbox.getCenter();\n        const terminal = edge.getTerminal(type);\n        if (terminal == null) {\n            return center;\n        }\n        const portId = terminal.port;\n        if (!portId || !this.hasPort(portId)) {\n            return center;\n        }\n        const port = this.getPort(portId);\n        if (!port || !port.group) {\n            return center;\n        }\n        const layouts = this.getPortsPosition(port.group);\n        const position = layouts[portId].position;\n        const portCenter = Point.create(position).translate(bbox.getOrigin());\n        const angle = this.getAngle();\n        if (angle) {\n            portCenter.rotate(-angle, center);\n        }\n        return portCenter;\n    }\n    /**\n     * Sets cell's size and position based on the children bbox and given padding.\n     */\n    fit(options = {}) {\n        const children = this.getChildren() || [];\n        const embeds = children.filter((cell) => cell.isNode());\n        if (embeds.length === 0) {\n            return this;\n        }\n        this.startBatch('fit-embeds', options);\n        if (options.deep) {\n            embeds.forEach((cell) => cell.fit(options));\n        }\n        let { x, y, width, height } = Cell.getCellsBBox(embeds);\n        const padding = NumberExt.normalizeSides(options.padding);\n        x -= padding.left;\n        y -= padding.top;\n        width += padding.left + padding.right;\n        height += padding.bottom + padding.top;\n        this.store.set({\n            position: { x, y },\n            size: { width, height },\n        }, options);\n        this.stopBatch('fit-embeds');\n        return this;\n    }\n    // #endregion\n    // #region ports\n    get portContainerMarkup() {\n        return this.getPortContainerMarkup();\n    }\n    set portContainerMarkup(markup) {\n        this.setPortContainerMarkup(markup);\n    }\n    getDefaultPortContainerMarkup() {\n        return (this.store.get('defaultPortContainerMarkup') ||\n            Markup.getPortContainerMarkup());\n    }\n    getPortContainerMarkup() {\n        return (this.store.get('portContainerMarkup') ||\n            this.getDefaultPortContainerMarkup());\n    }\n    setPortContainerMarkup(markup, options = {}) {\n        this.store.set('portContainerMarkup', Markup.clone(markup), options);\n        return this;\n    }\n    get portMarkup() {\n        return this.getPortMarkup();\n    }\n    set portMarkup(markup) {\n        this.setPortMarkup(markup);\n    }\n    getDefaultPortMarkup() {\n        return this.store.get('defaultPortMarkup') || Markup.getPortMarkup();\n    }\n    getPortMarkup() {\n        return this.store.get('portMarkup') || this.getDefaultPortMarkup();\n    }\n    setPortMarkup(markup, options = {}) {\n        this.store.set('portMarkup', Markup.clone(markup), options);\n        return this;\n    }\n    get portLabelMarkup() {\n        return this.getPortLabelMarkup();\n    }\n    set portLabelMarkup(markup) {\n        this.setPortLabelMarkup(markup);\n    }\n    getDefaultPortLabelMarkup() {\n        return (this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup());\n    }\n    getPortLabelMarkup() {\n        return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();\n    }\n    setPortLabelMarkup(markup, options = {}) {\n        this.store.set('portLabelMarkup', Markup.clone(markup), options);\n        return this;\n    }\n    get ports() {\n        const res = this.store.get('ports', { items: [] });\n        if (res.items == null) {\n            res.items = [];\n        }\n        return res;\n    }\n    getPorts() {\n        return ObjectExt.cloneDeep(this.ports.items);\n    }\n    getPortsByGroup(groupName) {\n        return this.getPorts().filter((port) => port.group === groupName);\n    }\n    getPort(portId) {\n        return ObjectExt.cloneDeep(this.ports.items.find((port) => port.id && port.id === portId));\n    }\n    getPortAt(index) {\n        return this.ports.items[index] || null;\n    }\n    hasPorts() {\n        return this.ports.items.length > 0;\n    }\n    hasPort(portId) {\n        return this.getPortIndex(portId) !== -1;\n    }\n    getPortIndex(port) {\n        const portId = typeof port === 'string' ? port : port.id;\n        return portId != null\n            ? this.ports.items.findIndex((item) => item.id === portId)\n            : -1;\n    }\n    getPortsPosition(groupName) {\n        const size = this.getSize();\n        const layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size.width, size.height));\n        return layouts.reduce((memo, item) => {\n            const layout = item.portLayout;\n            memo[item.portId] = {\n                position: Object.assign({}, layout.position),\n                angle: layout.angle || 0,\n            };\n            return memo;\n        }, {});\n    }\n    getPortProp(portId, path) {\n        return this.getPropByPath(this.prefixPortPath(portId, path));\n    }\n    setPortProp(portId, arg1, arg2, arg3) {\n        if (typeof arg1 === 'string' || Array.isArray(arg1)) {\n            const path = this.prefixPortPath(portId, arg1);\n            const value = arg2;\n            return this.setPropByPath(path, value, arg3);\n        }\n        const path = this.prefixPortPath(portId);\n        const value = arg1;\n        return this.setPropByPath(path, value, arg2);\n    }\n    removePortProp(portId, path, options) {\n        if (typeof path === 'string' || Array.isArray(path)) {\n            return this.removePropByPath(this.prefixPortPath(portId, path), options);\n        }\n        return this.removePropByPath(this.prefixPortPath(portId), path);\n    }\n    portProp(portId, path, value, options) {\n        if (path == null) {\n            return this.getPortProp(portId);\n        }\n        if (typeof path === 'string' || Array.isArray(path)) {\n            if (arguments.length === 2) {\n                return this.getPortProp(portId, path);\n            }\n            if (value == null) {\n                return this.removePortProp(portId, path, options);\n            }\n            return this.setPortProp(portId, path, value, options);\n        }\n        return this.setPortProp(portId, path, value);\n    }\n    prefixPortPath(portId, path) {\n        const index = this.getPortIndex(portId);\n        if (index === -1) {\n            throw new Error(`Unable to find port with id: \"${portId}\"`);\n        }\n        if (path == null || path === '') {\n            return ['ports', 'items', `${index}`];\n        }\n        if (Array.isArray(path)) {\n            return ['ports', 'items', `${index}`, ...path];\n        }\n        return `ports/items/${index}/${path}`;\n    }\n    addPort(port, options) {\n        const ports = [...this.ports.items];\n        ports.push(port);\n        this.setPropByPath('ports/items', ports, options);\n        return this;\n    }\n    addPorts(ports, options) {\n        this.setPropByPath('ports/items', [...this.ports.items, ...ports], options);\n        return this;\n    }\n    removePort(port, options = {}) {\n        return this.removePortAt(this.getPortIndex(port), options);\n    }\n    removePortAt(index, options = {}) {\n        if (index >= 0) {\n            const ports = [...this.ports.items];\n            ports.splice(index, 1);\n            options.rewrite = true;\n            this.setPropByPath('ports/items', ports, options);\n        }\n        return this;\n    }\n    removePorts(portsForRemoval, opt) {\n        let options;\n        if (Array.isArray(portsForRemoval)) {\n            options = opt || {};\n            if (portsForRemoval.length) {\n                options.rewrite = true;\n                const currentPorts = [...this.ports.items];\n                const remainingPorts = currentPorts.filter((cp) => !portsForRemoval.some((p) => {\n                    const id = typeof p === 'string' ? p : p.id;\n                    return cp.id === id;\n                }));\n                this.setPropByPath('ports/items', remainingPorts, options);\n            }\n        }\n        else {\n            options = portsForRemoval || {};\n            options.rewrite = true;\n            this.setPropByPath('ports/items', [], options);\n        }\n        return this;\n    }\n    getParsedPorts() {\n        return this.port.getPorts();\n    }\n    getParsedGroups() {\n        return this.port.groups;\n    }\n    getPortsLayoutByGroup(groupName, bbox) {\n        return this.port.getPortsLayoutByGroup(groupName, bbox);\n    }\n    initPorts() {\n        this.updatePortData();\n        this.on('change:ports', () => {\n            this.processRemovedPort();\n            this.updatePortData();\n        });\n    }\n    processRemovedPort() {\n        const current = this.ports;\n        const currentItemsMap = {};\n        current.items.forEach((item) => {\n            if (item.id) {\n                currentItemsMap[item.id] = true;\n            }\n        });\n        const removed = {};\n        const previous = this.store.getPrevious('ports') || {\n            items: [],\n        };\n        previous.items.forEach((item) => {\n            if (item.id && !currentItemsMap[item.id]) {\n                removed[item.id] = true;\n            }\n        });\n        const model = this.model;\n        if (model && !ObjectExt.isEmpty(removed)) {\n            const incomings = model.getConnectedEdges(this, { incoming: true });\n            incomings.forEach((edge) => {\n                const portId = edge.getTargetPortId();\n                if (portId && removed[portId]) {\n                    edge.remove();\n                }\n            });\n            const outgoings = model.getConnectedEdges(this, { outgoing: true });\n            outgoings.forEach((edge) => {\n                const portId = edge.getSourcePortId();\n                if (portId && removed[portId]) {\n                    edge.remove();\n                }\n            });\n        }\n    }\n    validatePorts() {\n        const ids = {};\n        const errors = [];\n        this.ports.items.forEach((p) => {\n            if (typeof p !== 'object') {\n                errors.push(`Invalid port ${p}.`);\n            }\n            if (p.id == null) {\n                p.id = this.generatePortId();\n            }\n            if (ids[p.id]) {\n                errors.push('Duplicitied port id.');\n            }\n            ids[p.id] = true;\n        });\n        return errors;\n    }\n    generatePortId() {\n        return StringExt.uuid();\n    }\n    updatePortData() {\n        const err = this.validatePorts();\n        if (err.length > 0) {\n            this.store.set('ports', this.store.getPrevious('ports'));\n            throw new Error(err.join(' '));\n        }\n        const prev = this.port ? this.port.getPorts() : null;\n        this.port = new PortManager(this.ports);\n        const curr = this.port.getPorts();\n        const added = prev\n            ? curr.filter((item) => {\n                if (!prev.find((prevPort) => prevPort.id === item.id)) {\n                    return item;\n                }\n                return null;\n            })\n            : [...curr];\n        const removed = prev\n            ? prev.filter((item) => {\n                if (!curr.find((curPort) => curPort.id === item.id)) {\n                    return item;\n                }\n                return null;\n            })\n            : [];\n        if (added.length > 0) {\n            this.notify('ports:added', { added, cell: this, node: this });\n        }\n        if (removed.length > 0) {\n            this.notify('ports:removed', { removed, cell: this, node: this });\n        }\n    }\n}\nNode.defaults = {\n    angle: 0,\n    position: { x: 0, y: 0 },\n    size: { width: 1, height: 1 },\n};\n(function (Node) {\n    Node.toStringTag = `X6.${Node.name}`;\n    function isNode(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Node) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const node = instance;\n        if ((tag == null || tag === Node.toStringTag) &&\n            typeof node.isNode === 'function' &&\n            typeof node.isEdge === 'function' &&\n            typeof node.prop === 'function' &&\n            typeof node.attr === 'function' &&\n            typeof node.size === 'function' &&\n            typeof node.position === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Node.isNode = isNode;\n})(Node || (Node = {}));\n(function (Node) {\n    Node.config({\n        propHooks(_a) {\n            var { ports } = _a, metadata = __rest(_a, [\"ports\"]);\n            if (ports) {\n                metadata.ports = Array.isArray(ports) ? { items: ports } : ports;\n            }\n            return metadata;\n        },\n    });\n})(Node || (Node = {}));\n(function (Node) {\n    Node.registry = Registry.create({\n        type: 'node',\n        process(shape, options) {\n            if (ShareRegistry.exist(shape, true)) {\n                throw new Error(`Node with name '${shape}' was registered by anthor Edge`);\n            }\n            if (typeof options === 'function') {\n                options.config({ shape });\n                return options;\n            }\n            let parent = Node;\n            const { inherit } = options, config = __rest(options, [\"inherit\"]);\n            if (inherit) {\n                if (typeof inherit === 'string') {\n                    const base = this.get(inherit);\n                    if (base == null) {\n                        this.onNotFound(inherit, 'inherited');\n                    }\n                    else {\n                        parent = base;\n                    }\n                }\n                else {\n                    parent = inherit;\n                }\n            }\n            if (config.constructorName == null) {\n                config.constructorName = shape;\n            }\n            const ctor = parent.define.call(parent, config);\n            ctor.config({ shape });\n            return ctor;\n        },\n    });\n    ShareRegistry.setNodeRegistry(Node.registry);\n})(Node || (Node = {}));\n(function (Node) {\n    let counter = 0;\n    function getClassName(name) {\n        if (name) {\n            return StringExt.pascalCase(name);\n        }\n        counter += 1;\n        return `CustomNode${counter}`;\n    }\n    function define(config) {\n        const { constructorName, overwrite } = config, others = __rest(config, [\"constructorName\", \"overwrite\"]);\n        const ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n        ctor.config(others);\n        if (others.shape) {\n            Node.registry.register(others.shape, ctor, overwrite);\n        }\n        return ctor;\n    }\n    Node.define = define;\n    function create(options) {\n        const shape = options.shape || 'rect';\n        const Ctor = Node.registry.get(shape);\n        if (Ctor) {\n            return new Ctor(options);\n        }\n        return Node.registry.onNotFound(shape);\n    }\n    Node.create = create;\n})(Node || (Node = {}));\n//# sourceMappingURL=node.js.map"]},"metadata":{},"sourceType":"module"}