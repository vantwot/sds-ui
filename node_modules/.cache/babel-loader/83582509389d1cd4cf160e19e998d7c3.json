{"ast":null,"code":"import { Angle, Point, Line } from '../../geometry';\n\nfunction rollup(points, merge) {\n  if (merge != null && merge !== false) {\n    const amount = typeof merge === 'boolean' ? 0 : merge;\n\n    if (amount > 0) {\n      const center1 = Point.create(points[1]).move(points[2], amount);\n      const center2 = Point.create(points[1]).move(points[0], amount);\n      return [center1.toJSON(), ...points, center2.toJSON()];\n    }\n\n    {\n      const center = points[1];\n      return [Object.assign({}, center), ...points, Object.assign({}, center)];\n    }\n  }\n\n  return points;\n}\n\nexport const loop = function (vertices, options, edgeView) {\n  const width = options.width || 50;\n  const height = options.height || 80;\n  const halfHeight = height / 2;\n  const angle = options.angle || 'auto';\n  const sourceAnchor = edgeView.sourceAnchor;\n  const targetAnchor = edgeView.targetAnchor;\n  const sourceBBox = edgeView.sourceBBox;\n  const targetBBox = edgeView.targetBBox;\n\n  if (sourceAnchor.equals(targetAnchor)) {\n    const getVertices = angle => {\n      const rad = Angle.toRad(angle);\n      const sin = Math.sin(rad);\n      const cos = Math.cos(rad);\n      const center = new Point(sourceAnchor.x + cos * width, sourceAnchor.y + sin * width);\n      const ref = new Point(center.x - cos * halfHeight, center.y - sin * halfHeight);\n      const p1 = ref.clone().rotate(-90, center);\n      const p2 = ref.clone().rotate(90, center);\n      return [p1.toJSON(), center.toJSON(), p2.toJSON()];\n    };\n\n    const validate = end => {\n      const start = sourceAnchor.clone().move(end, -1);\n      const line = new Line(start, end);\n      return !sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line);\n    };\n\n    const angles = [0, 90, 180, 270, 45, 135, 225, 315];\n\n    if (typeof angle === 'number') {\n      return rollup(getVertices(angle), options.merge);\n    }\n\n    const center = sourceBBox.getCenter();\n\n    if (center.equals(sourceAnchor)) {\n      return rollup(getVertices(0), options.merge);\n    }\n\n    const deg = center.angleBetween(sourceAnchor, center.clone().translate(1, 0));\n    let ret = getVertices(deg);\n\n    if (validate(ret[1])) {\n      return rollup(ret, options.merge);\n    } // return the best vertices\n\n\n    for (let i = 1, l = angles.length; i < l; i += 1) {\n      ret = getVertices(deg + angles[i]);\n\n      if (validate(ret[1])) {\n        return rollup(ret, options.merge);\n      }\n    }\n\n    return rollup(ret, options.merge);\n  }\n\n  {\n    const line = new Line(sourceAnchor, targetAnchor);\n    let parallel = line.parallel(-width);\n    let center = parallel.getCenter();\n    let p1 = parallel.start.clone().move(parallel.end, halfHeight);\n    let p2 = parallel.end.clone().move(parallel.start, halfHeight);\n    const ref = line.parallel(-1);\n    const line1 = new Line(ref.start, center);\n    const line2 = new Line(ref.end, center);\n\n    if (sourceBBox.containsPoint(center) || targetBBox.containsPoint(center) || sourceBBox.intersectsWithLine(line1) || sourceBBox.intersectsWithLine(line2) || targetBBox.intersectsWithLine(line1) || targetBBox.intersectsWithLine(line2)) {\n      parallel = line.parallel(width);\n      center = parallel.getCenter();\n      p1 = parallel.start.clone().move(parallel.end, halfHeight);\n      p2 = parallel.end.clone().move(parallel.start, halfHeight);\n    }\n\n    if (options.merge) {\n      const line = new Line(sourceAnchor, targetAnchor);\n      const normal = new Line(center, line.center).setLength(Number.MAX_SAFE_INTEGER);\n      const intersects1 = sourceBBox.intersectsWithLine(normal);\n      const intersects2 = targetBBox.intersectsWithLine(normal);\n      const intersects = intersects1 ? Array.isArray(intersects1) ? intersects1 : [intersects1] : [];\n\n      if (intersects2) {\n        if (Array.isArray(intersects2)) {\n          intersects.push(...intersects2);\n        } else {\n          intersects.push(intersects2);\n        }\n      }\n\n      const anchor = line.center.closest(intersects);\n\n      if (anchor) {\n        edgeView.sourceAnchor = anchor.clone();\n        edgeView.targetAnchor = anchor.clone();\n      } else {\n        edgeView.sourceAnchor = line.center.clone();\n        edgeView.targetAnchor = line.center.clone();\n      }\n    }\n\n    return rollup([p1.toJSON(), center.toJSON(), p2.toJSON()], options.merge);\n  }\n};","map":{"version":3,"sources":["../../../src/registry/router/loop.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Angle, Point, Line } from '../../geometry';\nfunction rollup(points, merge) {\n    if (merge != null && merge !== false) {\n        const amount = typeof merge === 'boolean' ? 0 : merge;\n        if (amount > 0) {\n            const center1 = Point.create(points[1]).move(points[2], amount);\n            const center2 = Point.create(points[1]).move(points[0], amount);\n            return [center1.toJSON(), ...points, center2.toJSON()];\n        }\n        {\n            const center = points[1];\n            return [Object.assign({}, center), ...points, Object.assign({}, center)];\n        }\n    }\n    return points;\n}\nexport const loop = function (vertices, options, edgeView) {\n    const width = options.width || 50;\n    const height = options.height || 80;\n    const halfHeight = height / 2;\n    const angle = options.angle || 'auto';\n    const sourceAnchor = edgeView.sourceAnchor;\n    const targetAnchor = edgeView.targetAnchor;\n    const sourceBBox = edgeView.sourceBBox;\n    const targetBBox = edgeView.targetBBox;\n    if (sourceAnchor.equals(targetAnchor)) {\n        const getVertices = (angle) => {\n            const rad = Angle.toRad(angle);\n            const sin = Math.sin(rad);\n            const cos = Math.cos(rad);\n            const center = new Point(sourceAnchor.x + cos * width, sourceAnchor.y + sin * width);\n            const ref = new Point(center.x - cos * halfHeight, center.y - sin * halfHeight);\n            const p1 = ref.clone().rotate(-90, center);\n            const p2 = ref.clone().rotate(90, center);\n            return [p1.toJSON(), center.toJSON(), p2.toJSON()];\n        };\n        const validate = (end) => {\n            const start = sourceAnchor.clone().move(end, -1);\n            const line = new Line(start, end);\n            return (!sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line));\n        };\n        const angles = [0, 90, 180, 270, 45, 135, 225, 315];\n        if (typeof angle === 'number') {\n            return rollup(getVertices(angle), options.merge);\n        }\n        const center = sourceBBox.getCenter();\n        if (center.equals(sourceAnchor)) {\n            return rollup(getVertices(0), options.merge);\n        }\n        const deg = center.angleBetween(sourceAnchor, center.clone().translate(1, 0));\n        let ret = getVertices(deg);\n        if (validate(ret[1])) {\n            return rollup(ret, options.merge);\n        }\n        // return the best vertices\n        for (let i = 1, l = angles.length; i < l; i += 1) {\n            ret = getVertices(deg + angles[i]);\n            if (validate(ret[1])) {\n                return rollup(ret, options.merge);\n            }\n        }\n        return rollup(ret, options.merge);\n    }\n    {\n        const line = new Line(sourceAnchor, targetAnchor);\n        let parallel = line.parallel(-width);\n        let center = parallel.getCenter();\n        let p1 = parallel.start.clone().move(parallel.end, halfHeight);\n        let p2 = parallel.end.clone().move(parallel.start, halfHeight);\n        const ref = line.parallel(-1);\n        const line1 = new Line(ref.start, center);\n        const line2 = new Line(ref.end, center);\n        if (sourceBBox.containsPoint(center) ||\n            targetBBox.containsPoint(center) ||\n            sourceBBox.intersectsWithLine(line1) ||\n            sourceBBox.intersectsWithLine(line2) ||\n            targetBBox.intersectsWithLine(line1) ||\n            targetBBox.intersectsWithLine(line2)) {\n            parallel = line.parallel(width);\n            center = parallel.getCenter();\n            p1 = parallel.start.clone().move(parallel.end, halfHeight);\n            p2 = parallel.end.clone().move(parallel.start, halfHeight);\n        }\n        if (options.merge) {\n            const line = new Line(sourceAnchor, targetAnchor);\n            const normal = new Line(center, line.center).setLength(Number.MAX_SAFE_INTEGER);\n            const intersects1 = sourceBBox.intersectsWithLine(normal);\n            const intersects2 = targetBBox.intersectsWithLine(normal);\n            const intersects = intersects1\n                ? Array.isArray(intersects1)\n                    ? intersects1\n                    : [intersects1]\n                : [];\n            if (intersects2) {\n                if (Array.isArray(intersects2)) {\n                    intersects.push(...intersects2);\n                }\n                else {\n                    intersects.push(intersects2);\n                }\n            }\n            const anchor = line.center.closest(intersects);\n            if (anchor) {\n                edgeView.sourceAnchor = anchor.clone();\n                edgeView.targetAnchor = anchor.clone();\n            }\n            else {\n                edgeView.sourceAnchor = line.center.clone();\n                edgeView.targetAnchor = line.center.clone();\n            }\n        }\n        return rollup([p1.toJSON(), center.toJSON(), p2.toJSON()], options.merge);\n    }\n};\n//# sourceMappingURL=loop.js.map"]},"metadata":{},"sourceType":"module"}