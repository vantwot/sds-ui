{"ast":null,"code":"import { getJudgeFunction } from '../fn';\nimport { requestAnimationFrame } from './animationFrame';\nexport class TouchHandler {\n  constructor(options) {\n    this.didTouchMove = () => {\n      // Fire scroll callback based on computed drag delta.\n      // Also track accummulated delta so we can calculate velocity\n      this.dragAnimationId = null;\n      this.callback(this.deltaX, this.deltaY);\n      this.accumulatedDeltaX += this.deltaX;\n      this.accumulatedDeltaY += this.deltaY;\n      this.deltaX = 0;\n      this.deltaY = 0;\n    };\n\n    this.track = () => {\n      // Compute velocity based on a weighted average of drag over\n      // last 100ms and previous velocity. Combining into a moving average\n      // results in a smoother scroll.\n      const now = Date.now();\n      const elapsed = now - this.lastFrameTimestamp;\n      const oldVelocityX = this.velocityX;\n      const oldVelocityY = this.velocityY; // We compute velocity using a weighted average of the current\n      // velocity and the previous velocity. If the previous velocity\n      // is 0, put the full weight on the last 100ms\n\n      let weight = 0.8;\n\n      if (elapsed < TouchHandler.TRACKER_TIMEOUT) {\n        weight *= elapsed / TouchHandler.TRACKER_TIMEOUT;\n      }\n\n      if (oldVelocityX === 0 && oldVelocityY === 0) {\n        weight = 1;\n      } // Formula for computing weighted average of velocity\n\n\n      this.velocityX = weight * (TouchHandler.TRACKER_TIMEOUT * this.accumulatedDeltaX / (1 + elapsed));\n\n      if (weight < 1) {\n        this.velocityX += (1 - weight) * oldVelocityX;\n      }\n\n      this.velocityY = weight * (TouchHandler.TRACKER_TIMEOUT * this.accumulatedDeltaY / (1 + elapsed));\n\n      if (weight < 1) {\n        this.velocityY += (1 - weight) * oldVelocityY;\n      }\n\n      this.accumulatedDeltaX = 0;\n      this.accumulatedDeltaY = 0;\n      this.lastFrameTimestamp = now;\n    };\n\n    this.startAutoScroll = () => {\n      // To kick off deceleration / momentum scrolling, handle any\n      // scrolling from a drag which was waiting for an animation\n      // frame. Then update our velocity.\n      // Finally start the momentum scrolling handler (autoScroll)\n      this.autoScrollTimestamp = Date.now();\n\n      if (this.deltaX > 0 || this.deltaY > 0) {\n        this.didTouchMove();\n      }\n\n      this.track();\n      this.autoScroll();\n    };\n\n    this.autoScroll = () => {\n      // Compute a scroll delta with an exponential decay based on\n      // time elapsed since drag was released. This is called\n      // recursively on animation frames until the delta is below\n      // a threshold (5 pixels)\n      const elapsed = Date.now() - this.autoScrollTimestamp;\n      const factor = TouchHandler.DECELERATION_AMPLITUDE * Math.exp(-elapsed / TouchHandler.DECELERATION_FACTOR);\n      let deltaX = factor * this.velocityX;\n      let deltaY = factor * this.velocityY;\n\n      if (Math.abs(deltaX) <= 5 || !this.handleScrollX(deltaX, deltaY)) {\n        deltaX = 0;\n      }\n\n      if (Math.abs(deltaY) <= 5 || !this.handleScrollY(deltaY, deltaX)) {\n        deltaY = 0;\n      }\n\n      if (deltaX !== 0 || deltaY !== 0) {\n        this.callback(deltaX, deltaY);\n        requestAnimationFrame(this.autoScroll);\n      }\n    };\n\n    this.trackerId = null;\n    this.dragAnimationId = null;\n    this.deltaX = 0;\n    this.deltaY = 0;\n    this.lastTouchX = 0;\n    this.lastTouchY = 0;\n    this.velocityX = 0;\n    this.velocityY = 0;\n    this.accumulatedDeltaX = 0;\n    this.accumulatedDeltaY = 0;\n    this.lastFrameTimestamp = Date.now();\n    this.autoScrollTimestamp = Date.now();\n    this.callback = options.onTouchScroll;\n    this.handleScrollX = getJudgeFunction(options.shouldHandleScrollX);\n    this.handleScrollY = getJudgeFunction(options.shouldHandleScrollY);\n    this.stopPropagation = getJudgeFunction(options.stopPropagation);\n  }\n\n  onTouchStart(e) {\n    this.lastTouchX = e.touches[0].pageX;\n    this.lastTouchY = e.touches[0].pageY;\n    this.velocityX = 0;\n    this.velocityY = 0;\n    this.accumulatedDeltaX = 0;\n    this.accumulatedDeltaY = 0;\n    this.lastFrameTimestamp = Date.now();\n\n    if (this.trackerId != null) {\n      clearInterval(this.trackerId);\n    }\n\n    this.trackerId = window.setInterval(this.track, TouchHandler.TRACKER_TIMEOUT);\n\n    if (this.stopPropagation()) {\n      e.stopPropagation();\n    }\n  }\n\n  onTouchEnd(e) {\n    this.onTouchCancel(e);\n    requestAnimationFrame(this.startAutoScroll);\n  }\n\n  onTouchCancel(e) {\n    if (this.trackerId != null) {\n      clearInterval(this.trackerId);\n      this.trackerId = null;\n    }\n\n    if (this.stopPropagation()) {\n      e.stopPropagation();\n    }\n  }\n\n  onTouchMove(e) {\n    const moveX = e.touches[0].pageX;\n    const moveY = e.touches[0].pageY; // Compute delta scrolled since last drag\n    // Mobile, scrolling is inverted\n\n    this.deltaX = TouchHandler.MOVE_AMPLITUDE * (this.lastTouchX - moveX);\n    this.deltaY = TouchHandler.MOVE_AMPLITUDE * (this.lastTouchY - moveY);\n    const handleScrollX = this.handleScrollX(this.deltaX, this.deltaY);\n    const handleScrollY = this.handleScrollY(this.deltaY, this.deltaX);\n\n    if (!handleScrollX && !handleScrollY) {\n      return;\n    } // If we can handle scroll update last touch for computing delta\n\n\n    if (handleScrollX) {\n      this.lastTouchX = moveX;\n    } else {\n      this.deltaX = 0;\n    }\n\n    if (handleScrollY) {\n      this.lastTouchY = moveY;\n    } else {\n      this.deltaY = 0;\n    }\n\n    e.preventDefault(); // ensure minimum delta magnitude is met to avoid jitter\n\n    let changed = false;\n\n    if (Math.abs(this.deltaX) > 2 || Math.abs(this.deltaY) > 2) {\n      if (this.stopPropagation()) {\n        e.stopPropagation();\n      }\n\n      changed = true;\n    } // Request animation frame to trigger scroll of computed delta\n\n\n    if (changed && this.dragAnimationId == null) {\n      this.dragAnimationId = requestAnimationFrame(this.didTouchMove);\n    }\n  }\n\n}\n\n(function (TouchHandler) {\n  TouchHandler.MOVE_AMPLITUDE = 1.6;\n  TouchHandler.DECELERATION_AMPLITUDE = 1.6;\n  TouchHandler.DECELERATION_FACTOR = 325;\n  TouchHandler.TRACKER_TIMEOUT = 100;\n})(TouchHandler || (TouchHandler = {}));","map":{"version":3,"sources":["../../../src/util/dom/TouchHandler.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { getJudgeFunction } from '../fn';\nimport { requestAnimationFrame } from './animationFrame';\nexport class TouchHandler {\n    constructor(options) {\n        this.didTouchMove = () => {\n            // Fire scroll callback based on computed drag delta.\n            // Also track accummulated delta so we can calculate velocity\n            this.dragAnimationId = null;\n            this.callback(this.deltaX, this.deltaY);\n            this.accumulatedDeltaX += this.deltaX;\n            this.accumulatedDeltaY += this.deltaY;\n            this.deltaX = 0;\n            this.deltaY = 0;\n        };\n        this.track = () => {\n            // Compute velocity based on a weighted average of drag over\n            // last 100ms and previous velocity. Combining into a moving average\n            // results in a smoother scroll.\n            const now = Date.now();\n            const elapsed = now - this.lastFrameTimestamp;\n            const oldVelocityX = this.velocityX;\n            const oldVelocityY = this.velocityY;\n            // We compute velocity using a weighted average of the current\n            // velocity and the previous velocity. If the previous velocity\n            // is 0, put the full weight on the last 100ms\n            let weight = 0.8;\n            if (elapsed < TouchHandler.TRACKER_TIMEOUT) {\n                weight *= elapsed / TouchHandler.TRACKER_TIMEOUT;\n            }\n            if (oldVelocityX === 0 && oldVelocityY === 0) {\n                weight = 1;\n            }\n            // Formula for computing weighted average of velocity\n            this.velocityX =\n                weight *\n                    ((TouchHandler.TRACKER_TIMEOUT * this.accumulatedDeltaX) / (1 + elapsed));\n            if (weight < 1) {\n                this.velocityX += (1 - weight) * oldVelocityX;\n            }\n            this.velocityY =\n                weight *\n                    ((TouchHandler.TRACKER_TIMEOUT * this.accumulatedDeltaY) / (1 + elapsed));\n            if (weight < 1) {\n                this.velocityY += (1 - weight) * oldVelocityY;\n            }\n            this.accumulatedDeltaX = 0;\n            this.accumulatedDeltaY = 0;\n            this.lastFrameTimestamp = now;\n        };\n        this.startAutoScroll = () => {\n            // To kick off deceleration / momentum scrolling, handle any\n            // scrolling from a drag which was waiting for an animation\n            // frame. Then update our velocity.\n            // Finally start the momentum scrolling handler (autoScroll)\n            this.autoScrollTimestamp = Date.now();\n            if (this.deltaX > 0 || this.deltaY > 0) {\n                this.didTouchMove();\n            }\n            this.track();\n            this.autoScroll();\n        };\n        this.autoScroll = () => {\n            // Compute a scroll delta with an exponential decay based on\n            // time elapsed since drag was released. This is called\n            // recursively on animation frames until the delta is below\n            // a threshold (5 pixels)\n            const elapsed = Date.now() - this.autoScrollTimestamp;\n            const factor = TouchHandler.DECELERATION_AMPLITUDE *\n                Math.exp(-elapsed / TouchHandler.DECELERATION_FACTOR);\n            let deltaX = factor * this.velocityX;\n            let deltaY = factor * this.velocityY;\n            if (Math.abs(deltaX) <= 5 || !this.handleScrollX(deltaX, deltaY)) {\n                deltaX = 0;\n            }\n            if (Math.abs(deltaY) <= 5 || !this.handleScrollY(deltaY, deltaX)) {\n                deltaY = 0;\n            }\n            if (deltaX !== 0 || deltaY !== 0) {\n                this.callback(deltaX, deltaY);\n                requestAnimationFrame(this.autoScroll);\n            }\n        };\n        this.trackerId = null;\n        this.dragAnimationId = null;\n        this.deltaX = 0;\n        this.deltaY = 0;\n        this.lastTouchX = 0;\n        this.lastTouchY = 0;\n        this.velocityX = 0;\n        this.velocityY = 0;\n        this.accumulatedDeltaX = 0;\n        this.accumulatedDeltaY = 0;\n        this.lastFrameTimestamp = Date.now();\n        this.autoScrollTimestamp = Date.now();\n        this.callback = options.onTouchScroll;\n        this.handleScrollX = getJudgeFunction(options.shouldHandleScrollX);\n        this.handleScrollY = getJudgeFunction(options.shouldHandleScrollY);\n        this.stopPropagation = getJudgeFunction(options.stopPropagation);\n    }\n    onTouchStart(e) {\n        this.lastTouchX = e.touches[0].pageX;\n        this.lastTouchY = e.touches[0].pageY;\n        this.velocityX = 0;\n        this.velocityY = 0;\n        this.accumulatedDeltaX = 0;\n        this.accumulatedDeltaY = 0;\n        this.lastFrameTimestamp = Date.now();\n        if (this.trackerId != null) {\n            clearInterval(this.trackerId);\n        }\n        this.trackerId = window.setInterval(this.track, TouchHandler.TRACKER_TIMEOUT);\n        if (this.stopPropagation()) {\n            e.stopPropagation();\n        }\n    }\n    onTouchEnd(e) {\n        this.onTouchCancel(e);\n        requestAnimationFrame(this.startAutoScroll);\n    }\n    onTouchCancel(e) {\n        if (this.trackerId != null) {\n            clearInterval(this.trackerId);\n            this.trackerId = null;\n        }\n        if (this.stopPropagation()) {\n            e.stopPropagation();\n        }\n    }\n    onTouchMove(e) {\n        const moveX = e.touches[0].pageX;\n        const moveY = e.touches[0].pageY;\n        // Compute delta scrolled since last drag\n        // Mobile, scrolling is inverted\n        this.deltaX = TouchHandler.MOVE_AMPLITUDE * (this.lastTouchX - moveX);\n        this.deltaY = TouchHandler.MOVE_AMPLITUDE * (this.lastTouchY - moveY);\n        const handleScrollX = this.handleScrollX(this.deltaX, this.deltaY);\n        const handleScrollY = this.handleScrollY(this.deltaY, this.deltaX);\n        if (!handleScrollX && !handleScrollY) {\n            return;\n        }\n        // If we can handle scroll update last touch for computing delta\n        if (handleScrollX) {\n            this.lastTouchX = moveX;\n        }\n        else {\n            this.deltaX = 0;\n        }\n        if (handleScrollY) {\n            this.lastTouchY = moveY;\n        }\n        else {\n            this.deltaY = 0;\n        }\n        e.preventDefault();\n        // ensure minimum delta magnitude is met to avoid jitter\n        let changed = false;\n        if (Math.abs(this.deltaX) > 2 || Math.abs(this.deltaY) > 2) {\n            if (this.stopPropagation()) {\n                e.stopPropagation();\n            }\n            changed = true;\n        }\n        // Request animation frame to trigger scroll of computed delta\n        if (changed && this.dragAnimationId == null) {\n            this.dragAnimationId = requestAnimationFrame(this.didTouchMove);\n        }\n    }\n}\n(function (TouchHandler) {\n    TouchHandler.MOVE_AMPLITUDE = 1.6;\n    TouchHandler.DECELERATION_AMPLITUDE = 1.6;\n    TouchHandler.DECELERATION_FACTOR = 325;\n    TouchHandler.TRACKER_TIMEOUT = 100;\n})(TouchHandler || (TouchHandler = {}));\n//# sourceMappingURL=TouchHandler.js.map"]},"metadata":{},"sourceType":"module"}