{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport var LineTo = /*#__PURE__*/function (_Segment) {\n  _inherits(LineTo, _Segment);\n\n  var _super = _createSuper(LineTo);\n\n  function LineTo(x, y) {\n    var _this;\n\n    _classCallCheck(this, LineTo);\n\n    _this = _super.call(this);\n\n    if (Line.isLine(x)) {\n      _this.endPoint = x.end.clone().round(2);\n    } else {\n      _this.endPoint = Point.create(x, y).round(2);\n    }\n\n    return _this;\n  }\n\n  _createClass(LineTo, [{\n    key: \"type\",\n    get: function get() {\n      return 'L';\n    }\n  }, {\n    key: \"line\",\n    get: function get() {\n      return new Line(this.start, this.end);\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      return this.line.bbox();\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      return this.line.closestPoint(p);\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      return this.line.closestPointLength(p);\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      return this.line.closestPointNormalizedLength(p);\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      return this.line.closestPointTangent(p);\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      return this.line.length();\n    }\n  }, {\n    key: \"divideAt\",\n    value: function divideAt(ratio) {\n      var divided = this.line.divideAt(ratio);\n      return [new LineTo(divided[0]), new LineTo(divided[1])];\n    }\n  }, {\n    key: \"divideAtLength\",\n    value: function divideAtLength(length) {\n      var divided = this.line.divideAtLength(length);\n      return [new LineTo(divided[0]), new LineTo(divided[1])];\n    }\n  }, {\n    key: \"getSubdivisions\",\n    value: function getSubdivisions() {\n      return [];\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      return this.line.pointAt(ratio);\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      return this.line.pointAtLength(length);\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      return this.line.tangentAt(ratio);\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      return this.line.tangentAtLength(length);\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      if (this.previousSegment == null) {\n        return false;\n      }\n\n      return !this.start.equals(this.end);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new LineTo(this.end);\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      this.end.scale(sx, sy, origin);\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.end.rotate(angle, origin);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      if (typeof tx === 'number') {\n        this.end.translate(tx, ty);\n      } else {\n        this.end.translate(tx);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(s) {\n      return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        type: this.type,\n        start: this.start.toJSON(),\n        end: this.end.toJSON()\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      var end = this.end;\n      return \"\".concat(this.type, \" \").concat(end.x, \" \").concat(end.y);\n    }\n  }]);\n\n  return LineTo;\n}(Segment);\n\n(function (LineTo) {\n  function create() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    var len = args.length;\n    var arg0 = args[0]; // line provided\n\n    if (Line.isLine(arg0)) {\n      return new LineTo(arg0);\n    } // points provided\n\n\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new LineTo(arg0);\n      } // poly-line segment\n\n\n      return args.map(function (arg) {\n        return new LineTo(arg);\n      });\n    } // coordinates provided\n\n\n    if (len === 2) {\n      return new LineTo(+args[0], +args[1]);\n    } // poly-line segment\n\n\n    var segments = [];\n\n    for (var i = 0; i < len; i += 2) {\n      var x = +args[i];\n      var y = +args[i + 1];\n      segments.push(new LineTo(x, y));\n    }\n\n    return segments;\n  }\n\n  LineTo.create = create;\n})(LineTo || (LineTo = {}));","map":{"version":3,"sources":["../../../src/geometry/path/lineto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Line } from '../line';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport class LineTo extends Segment {\n    constructor(x, y) {\n        super();\n        if (Line.isLine(x)) {\n            this.endPoint = x.end.clone().round(2);\n        }\n        else {\n            this.endPoint = Point.create(x, y).round(2);\n        }\n    }\n    get type() {\n        return 'L';\n    }\n    get line() {\n        return new Line(this.start, this.end);\n    }\n    bbox() {\n        return this.line.bbox();\n    }\n    closestPoint(p) {\n        return this.line.closestPoint(p);\n    }\n    closestPointLength(p) {\n        return this.line.closestPointLength(p);\n    }\n    closestPointNormalizedLength(p) {\n        return this.line.closestPointNormalizedLength(p);\n    }\n    closestPointTangent(p) {\n        return this.line.closestPointTangent(p);\n    }\n    length() {\n        return this.line.length();\n    }\n    divideAt(ratio) {\n        const divided = this.line.divideAt(ratio);\n        return [new LineTo(divided[0]), new LineTo(divided[1])];\n    }\n    divideAtLength(length) {\n        const divided = this.line.divideAtLength(length);\n        return [new LineTo(divided[0]), new LineTo(divided[1])];\n    }\n    getSubdivisions() {\n        return [];\n    }\n    pointAt(ratio) {\n        return this.line.pointAt(ratio);\n    }\n    pointAtLength(length) {\n        return this.line.pointAtLength(length);\n    }\n    tangentAt(ratio) {\n        return this.line.tangentAt(ratio);\n    }\n    tangentAtLength(length) {\n        return this.line.tangentAtLength(length);\n    }\n    isDifferentiable() {\n        if (this.previousSegment == null) {\n            return false;\n        }\n        return !this.start.equals(this.end);\n    }\n    clone() {\n        return new LineTo(this.end);\n    }\n    scale(sx, sy, origin) {\n        this.end.scale(sx, sy, origin);\n        return this;\n    }\n    rotate(angle, origin) {\n        this.end.rotate(angle, origin);\n        return this;\n    }\n    translate(tx, ty) {\n        if (typeof tx === 'number') {\n            this.end.translate(tx, ty);\n        }\n        else {\n            this.end.translate(tx);\n        }\n        return this;\n    }\n    equals(s) {\n        return (this.type === s.type &&\n            this.start.equals(s.start) &&\n            this.end.equals(s.end));\n    }\n    toJSON() {\n        return {\n            type: this.type,\n            start: this.start.toJSON(),\n            end: this.end.toJSON(),\n        };\n    }\n    serialize() {\n        const end = this.end;\n        return `${this.type} ${end.x} ${end.y}`;\n    }\n}\n(function (LineTo) {\n    function create(...args) {\n        const len = args.length;\n        const arg0 = args[0];\n        // line provided\n        if (Line.isLine(arg0)) {\n            return new LineTo(arg0);\n        }\n        // points provided\n        if (Point.isPointLike(arg0)) {\n            if (len === 1) {\n                return new LineTo(arg0);\n            }\n            // poly-line segment\n            return args.map((arg) => new LineTo(arg));\n        }\n        // coordinates provided\n        if (len === 2) {\n            return new LineTo(+args[0], +args[1]);\n        }\n        // poly-line segment\n        const segments = [];\n        for (let i = 0; i < len; i += 2) {\n            const x = +args[i];\n            const y = +args[i + 1];\n            segments.push(new LineTo(x, y));\n        }\n        return segments;\n    }\n    LineTo.create = create;\n})(LineTo || (LineTo = {}));\n//# sourceMappingURL=lineto.js.map"]},"metadata":{},"sourceType":"module"}