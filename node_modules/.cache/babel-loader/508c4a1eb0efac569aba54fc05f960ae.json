{"ast":null,"code":"import { isString, isNumber, isArray } from '@antv/util';\nimport { G6GraphEvent } from '../interface/behavior';\nexport var uniqueId = function uniqueId(type) {\n  return type + \"-\" + Math.random() + Date.now();\n};\n/**\n * turn padding into [top, right, bottom, right]\n * @param  {Number|Array} padding input padding\n * @return {array} output\n */\n\nexport var formatPadding = function formatPadding(padding) {\n  if (isArray(padding)) {\n    switch (padding.length) {\n      case 4:\n        return padding;\n\n      case 3:\n        padding.push(padding[1]);\n        return padding;\n\n      case 2:\n        return padding.concat(padding);\n\n      case 1:\n        return [padding[0], padding[0], padding[0], padding[0]];\n\n      default:\n        return [0, 0, 0, 0];\n    }\n  }\n\n  if (isNumber(padding)) {\n    return [padding, padding, padding, padding];\n  } else if (isString(padding)) {\n    var intPadding = parseInt(padding, 10);\n    return [intPadding, intPadding, intPadding, intPadding];\n  }\n\n  return [0, 0, 0, 0];\n};\n/**\n * clone event\n * @param e\n */\n\nexport var cloneEvent = function cloneEvent(e) {\n  var event = new G6GraphEvent(e.type, e);\n  event.clientX = e.clientX;\n  event.clientY = e.clientY;\n  event.x = e.x;\n  event.y = e.y;\n  event.target = e.target;\n  event.currentTarget = e.currentTarget;\n  event.bubbles = true;\n  event.item = e.item;\n  return event;\n};\n/**\n * 判断 viewport 是否改变，通过和单位矩阵对比\n * @param matrix Viewport 的 Matrix\n */\n\nexport var isViewportChanged = function isViewportChanged(matrix) {\n  // matrix 为 null， 则说明没有变化\n  if (!matrix) {\n    return false;\n  }\n\n  var MATRIX_LEN = 9;\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n  for (var i = 0; i < MATRIX_LEN; i++) {\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\nexport var isNaN = function isNaN(input) {\n  return Number.isNaN(Number(input));\n};\n/**\n * 计算一组 Item 的 BBox\n * @param items 选中的一组Item，可以是 node 或 combo\n */\n\nexport var calculationItemsBBox = function calculationItemsBBox(items) {\n  var minx = Infinity;\n  var maxx = -Infinity;\n  var miny = Infinity;\n  var maxy = -Infinity; // 获取已节点的所有最大最小x y值\n\n  for (var i = 0; i < items.length; i++) {\n    var element = items[i];\n    var bbox = element.getBBox();\n    var minX = bbox.minX,\n        minY = bbox.minY,\n        maxX = bbox.maxX,\n        maxY = bbox.maxY;\n\n    if (minX < minx) {\n      minx = minX;\n    }\n\n    if (minY < miny) {\n      miny = minY;\n    }\n\n    if (maxX > maxx) {\n      maxx = maxX;\n    }\n\n    if (maxY > maxy) {\n      maxy = maxY;\n    }\n  }\n\n  var x = Math.floor(minx);\n  var y = Math.floor(miny);\n  var width = Math.ceil(maxx) - Math.floor(minx);\n  var height = Math.ceil(maxy) - Math.floor(miny);\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    minX: minx,\n    minY: miny,\n    maxX: maxx,\n    maxY: maxy\n  };\n};\n/**\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\n * 文档: https://g6.antv.vision/en/docs/api/Util\n * @param edges 边数据集合\n * @param offsetDiff 相邻两边的 offset 之差\n * @param multiEdgeType\n * @param singleEdgeType\n * @param loopEdgeType\n */\n\nexport var processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\n  if (offsetDiff === void 0) {\n    offsetDiff = 15;\n  }\n\n  if (multiEdgeType === void 0) {\n    multiEdgeType = 'quadratic';\n  }\n\n  if (singleEdgeType === void 0) {\n    singleEdgeType = undefined;\n  }\n\n  if (loopEdgeType === void 0) {\n    loopEdgeType = undefined;\n  }\n\n  var len = edges.length;\n  var cod = offsetDiff * 2;\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n  var edgeMap = {};\n  var tags = [];\n  var reverses = {};\n\n  for (var i = 0; i < len; i++) {\n    var edge = edges[i];\n    var source = edge.source,\n        target = edge.target;\n    var sourceTarget = source + \"-\" + target;\n    if (tags[i]) continue;\n\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n\n    for (var j = 0; j < len; j++) {\n      if (i === j) continue;\n      var sedge = edges[j];\n      var src = sedge.source;\n      var dst = sedge.target; // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n\n      if (!tags[j]) {\n        if (source === dst && target === src) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[src + \"|\" + dst + \"|\" + (edgeMap[sourceTarget].length - 1)] = true;\n        } else if (source === src && target === dst) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n\n  for (var key in edgeMap) {\n    var arcEdges = edgeMap[key];\n    var length_1 = arcEdges.length;\n\n    for (var k = 0; k < length_1; k++) {\n      var current = arcEdges[k];\n\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50\n        };\n        continue;\n      }\n\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\n        current.type = singleEdgeType;\n        continue;\n      }\n\n      current.type = multiEdgeType;\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[current.source + \"|\" + current.target + \"|\" + k] ? -1 : 1);\n\n      if (length_1 % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n\n  return edges;\n};","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/@antv/g6-core/es/util/base.js"],"names":["isString","isNumber","isArray","G6GraphEvent","uniqueId","type","Math","random","Date","now","formatPadding","padding","length","push","concat","intPadding","parseInt","cloneEvent","e","event","clientX","clientY","x","y","target","currentTarget","bubbles","item","isViewportChanged","matrix","MATRIX_LEN","ORIGIN_MATRIX","i","isNaN","input","Number","calculationItemsBBox","items","minx","Infinity","maxx","miny","maxy","element","bbox","getBBox","minX","minY","maxX","maxY","floor","width","ceil","height","processParallelEdges","edges","offsetDiff","multiEdgeType","singleEdgeType","loopEdgeType","undefined","len","cod","loopPosition","edgeMap","tags","reverses","edge","source","sourceTarget","j","sedge","src","dst","key","arcEdges","length_1","k","current","loopCfg","position","dist","sign","curveOffset"],"mappings":"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","sourcesContent":["import { isString, isNumber, isArray } from '@antv/util';\nimport { G6GraphEvent } from '../interface/behavior';\nexport var uniqueId = function uniqueId(type) {\n  return type + \"-\" + Math.random() + Date.now();\n};\n/**\n * turn padding into [top, right, bottom, right]\n * @param  {Number|Array} padding input padding\n * @return {array} output\n */\n\nexport var formatPadding = function formatPadding(padding) {\n  if (isArray(padding)) {\n    switch (padding.length) {\n      case 4:\n        return padding;\n\n      case 3:\n        padding.push(padding[1]);\n        return padding;\n\n      case 2:\n        return padding.concat(padding);\n\n      case 1:\n        return [padding[0], padding[0], padding[0], padding[0]];\n\n      default:\n        return [0, 0, 0, 0];\n    }\n  }\n\n  if (isNumber(padding)) {\n    return [padding, padding, padding, padding];\n  } else if (isString(padding)) {\n    var intPadding = parseInt(padding, 10);\n    return [intPadding, intPadding, intPadding, intPadding];\n  }\n\n  return [0, 0, 0, 0];\n};\n/**\n * clone event\n * @param e\n */\n\nexport var cloneEvent = function cloneEvent(e) {\n  var event = new G6GraphEvent(e.type, e);\n  event.clientX = e.clientX;\n  event.clientY = e.clientY;\n  event.x = e.x;\n  event.y = e.y;\n  event.target = e.target;\n  event.currentTarget = e.currentTarget;\n  event.bubbles = true;\n  event.item = e.item;\n  return event;\n};\n/**\n * 判断 viewport 是否改变，通过和单位矩阵对比\n * @param matrix Viewport 的 Matrix\n */\n\nexport var isViewportChanged = function isViewportChanged(matrix) {\n  // matrix 为 null， 则说明没有变化\n  if (!matrix) {\n    return false;\n  }\n\n  var MATRIX_LEN = 9;\n  var ORIGIN_MATRIX = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n\n  for (var i = 0; i < MATRIX_LEN; i++) {\n    if (matrix[i] !== ORIGIN_MATRIX[i]) {\n      return true;\n    }\n  }\n\n  return false;\n};\nexport var isNaN = function isNaN(input) {\n  return Number.isNaN(Number(input));\n};\n/**\n * 计算一组 Item 的 BBox\n * @param items 选中的一组Item，可以是 node 或 combo\n */\n\nexport var calculationItemsBBox = function calculationItemsBBox(items) {\n  var minx = Infinity;\n  var maxx = -Infinity;\n  var miny = Infinity;\n  var maxy = -Infinity; // 获取已节点的所有最大最小x y值\n\n  for (var i = 0; i < items.length; i++) {\n    var element = items[i];\n    var bbox = element.getBBox();\n    var minX = bbox.minX,\n        minY = bbox.minY,\n        maxX = bbox.maxX,\n        maxY = bbox.maxY;\n\n    if (minX < minx) {\n      minx = minX;\n    }\n\n    if (minY < miny) {\n      miny = minY;\n    }\n\n    if (maxX > maxx) {\n      maxx = maxX;\n    }\n\n    if (maxY > maxy) {\n      maxy = maxY;\n    }\n  }\n\n  var x = Math.floor(minx);\n  var y = Math.floor(miny);\n  var width = Math.ceil(maxx) - Math.floor(minx);\n  var height = Math.ceil(maxy) - Math.floor(miny);\n  return {\n    x: x,\n    y: y,\n    width: width,\n    height: height,\n    minX: minx,\n    minY: miny,\n    maxX: maxx,\n    maxY: maxy\n  };\n};\n/**\n * 若 edges 中存在两端点相同的边，使用 quadratic 边并自动计算 curveOffset 使它们不相互重叠\n * 文档: https://g6.antv.vision/en/docs/api/Util\n * @param edges 边数据集合\n * @param offsetDiff 相邻两边的 offset 之差\n * @param multiEdgeType\n * @param singleEdgeType\n * @param loopEdgeType\n */\n\nexport var processParallelEdges = function processParallelEdges(edges, offsetDiff, multiEdgeType, singleEdgeType, loopEdgeType) {\n  if (offsetDiff === void 0) {\n    offsetDiff = 15;\n  }\n\n  if (multiEdgeType === void 0) {\n    multiEdgeType = 'quadratic';\n  }\n\n  if (singleEdgeType === void 0) {\n    singleEdgeType = undefined;\n  }\n\n  if (loopEdgeType === void 0) {\n    loopEdgeType = undefined;\n  }\n\n  var len = edges.length;\n  var cod = offsetDiff * 2;\n  var loopPosition = ['top', 'top-right', 'right', 'bottom-right', 'bottom', 'bottom-left', 'left', 'top-left'];\n  var edgeMap = {};\n  var tags = [];\n  var reverses = {};\n\n  for (var i = 0; i < len; i++) {\n    var edge = edges[i];\n    var source = edge.source,\n        target = edge.target;\n    var sourceTarget = source + \"-\" + target;\n    if (tags[i]) continue;\n\n    if (!edgeMap[sourceTarget]) {\n      edgeMap[sourceTarget] = [];\n    }\n\n    tags[i] = true;\n    edgeMap[sourceTarget].push(edge);\n\n    for (var j = 0; j < len; j++) {\n      if (i === j) continue;\n      var sedge = edges[j];\n      var src = sedge.source;\n      var dst = sedge.target; // 两个节点之间共同的边\n      // 第一条的source = 第二条的target\n      // 第一条的target = 第二条的source\n\n      if (!tags[j]) {\n        if (source === dst && target === src) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n          reverses[src + \"|\" + dst + \"|\" + (edgeMap[sourceTarget].length - 1)] = true;\n        } else if (source === src && target === dst) {\n          edgeMap[sourceTarget].push(sedge);\n          tags[j] = true;\n        }\n      }\n    }\n  }\n\n  for (var key in edgeMap) {\n    var arcEdges = edgeMap[key];\n    var length_1 = arcEdges.length;\n\n    for (var k = 0; k < length_1; k++) {\n      var current = arcEdges[k];\n\n      if (current.source === current.target) {\n        if (loopEdgeType) current.type = loopEdgeType; // 超过8条自环边，则需要重新处理\n\n        current.loopCfg = {\n          position: loopPosition[k % 8],\n          dist: Math.floor(k / 8) * 20 + 50\n        };\n        continue;\n      }\n\n      if (length_1 === 1 && singleEdgeType && current.source !== current.target) {\n        current.type = singleEdgeType;\n        continue;\n      }\n\n      current.type = multiEdgeType;\n      var sign = (k % 2 === 0 ? 1 : -1) * (reverses[current.source + \"|\" + current.target + \"|\" + k] ? -1 : 1);\n\n      if (length_1 % 2 === 1) {\n        current.curveOffset = sign * Math.ceil(k / 2) * cod;\n      } else {\n        current.curveOffset = sign * (Math.floor(k / 2) * cod + offsetDiff);\n      }\n    }\n  }\n\n  return edges;\n};"]},"metadata":{},"sourceType":"module"}