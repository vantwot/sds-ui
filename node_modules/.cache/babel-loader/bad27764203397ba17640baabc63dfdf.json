{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport dagre from 'dagre';\nimport { isArray, isNumber } from '../util';\nimport { Base } from './base';\n/**\n * 层次布局\n */\n\nexport var DagreLayout = /*#__PURE__*/function (_Base) {\n  _inherits(DagreLayout, _Base);\n\n  var _super = _createSuper(DagreLayout);\n\n  function DagreLayout(options) {\n    var _this;\n\n    _classCallCheck(this, DagreLayout);\n\n    _this = _super.call(this);\n    /** layout 方向, 可选 TB, BT, LR, RL */\n\n    _this.rankdir = 'TB';\n    /** 节点水平间距(px) */\n\n    _this.nodesep = 50;\n    /** 每一层节点之间间距 */\n\n    _this.ranksep = 50;\n    /** 是否保留布局连线的控制点 */\n\n    _this.controlPoints = false;\n    /** 每层节点是否根据节点数据中的 comboId 进行排序，以放置同层 combo 重叠 */\n\n    _this.sortByCombo = false;\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(DagreLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        rankdir: 'TB',\n        align: undefined,\n        nodeSize: undefined,\n        nodesepFunc: undefined,\n        ranksepFunc: undefined,\n        nodesep: 50,\n        ranksep: 50,\n        controlPoints: false\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes,\n          nodeSize = self.nodeSize,\n          rankdir = self.rankdir;\n      if (!nodes) return;\n      var edges = self.edges || [];\n      var g = new dagre.graphlib.Graph();\n      var nodeSizeFunc;\n\n      if (!nodeSize) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          if (d.size) {\n            if (isArray(d.size)) {\n              return d.size;\n            }\n\n            return [d.size, d.size];\n          }\n\n          return [40, 40];\n        };\n      } else if (isArray(nodeSize)) {\n        nodeSizeFunc = function nodeSizeFunc() {\n          return nodeSize;\n        };\n      } else {\n        nodeSizeFunc = function nodeSizeFunc() {\n          return [nodeSize, nodeSize];\n        };\n      }\n\n      var horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n      var vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n\n      if (rankdir === 'LR' || rankdir === 'RL') {\n        horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n        vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n      }\n\n      g.setDefaultEdgeLabel(function () {\n        return {};\n      });\n      g.setGraph(self);\n      nodes.forEach(function (node) {\n        var size = nodeSizeFunc(node);\n        var verti = vertisep(node);\n        var hori = horisep(node);\n        var width = size[0] + 2 * hori;\n        var height = size[1] + 2 * verti;\n        g.setNode(node.id, {\n          width: width,\n          height: height\n        });\n      });\n      edges.forEach(function (edge) {\n        // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n        g.setEdge(edge.source, edge.target, {\n          weight: edge.weight || 1\n        });\n      });\n      dagre.layout(g);\n      var coord;\n      g.nodes().forEach(function (node) {\n        coord = g.node(node);\n        var i = nodes.findIndex(function (it) {\n          return it.id === node;\n        });\n        nodes[i].x = coord.x;\n        nodes[i].y = coord.y;\n      });\n      g.edges().forEach(function (edge) {\n        coord = g.edge(edge);\n        var i = edges.findIndex(function (it) {\n          return it.source === edge.v && it.target === edge.w;\n        });\n\n        if (self.controlPoints && edges[i].type !== 'loop') {\n          edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n        }\n      });\n\n      if (self.sortByCombo) {\n        self.sortLevel('comboId');\n      }\n\n      return nodes;\n    }\n  }, {\n    key: \"sortLevel\",\n    value: function sortLevel(propertyName) {\n      var self = this;\n      var nodes = self.nodes;\n      var levels = {};\n      nodes.forEach(function (node) {\n        if (!levels[node.y]) levels[node.y] = {\n          y: node.y,\n          nodes: []\n        };\n        levels[node.y].nodes.push(node);\n      });\n      Object.keys(levels).forEach(function (key) {\n        var levelNodes = levels[key].nodes;\n        var nodesNum = levelNodes.length;\n        var comboCenters = {};\n        levelNodes.forEach(function (lnode) {\n          var lnodeCombo = lnode.comboId;\n          if (!comboCenters[lnodeCombo]) comboCenters[lnodeCombo] = {\n            x: 0,\n            y: 0,\n            count: 0\n          };\n          comboCenters[lnodeCombo].x += lnode.x;\n          comboCenters[lnodeCombo].y += lnode.y;\n          comboCenters[lnodeCombo].count++;\n        });\n        Object.keys(comboCenters).forEach(function (ckey) {\n          comboCenters[ckey].x /= comboCenters[ckey].count;\n          comboCenters[ckey].y /= comboCenters[ckey].count;\n        });\n        if (nodesNum === 1) return;\n        var sortedByX = levelNodes.sort(function (a, b) {\n          return a.x - b.x;\n        });\n        var minX = sortedByX[0].x;\n        var maxX = sortedByX[nodesNum - 1].x;\n        var gap = (maxX - minX) / (nodesNum - 1);\n        var sortedByCombo = levelNodes.sort(function (a, b) {\n          var aValue = a[propertyName] || 'undefined';\n          var bValue = b[propertyName] || 'undefined';\n\n          if (aValue < bValue) {\n            return -1;\n          }\n\n          if (aValue > bValue) {\n            return 1;\n          }\n\n          return 0;\n        });\n        sortedByCombo.forEach(function (node, i) {\n          node.x = minX + i * gap;\n        });\n      });\n    }\n  }]);\n\n  return DagreLayout;\n}(Base);\n\nfunction getFunc(func, value, defaultValue) {\n  var resultFunc;\n\n  if (func) {\n    resultFunc = func;\n  } else if (isNumber(value)) {\n    resultFunc = function resultFunc() {\n      return value;\n    };\n  } else {\n    resultFunc = function resultFunc() {\n      return defaultValue;\n    };\n  }\n\n  return resultFunc;\n}","map":{"version":3,"sources":["../../src/layout/dagre.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport dagre from 'dagre';\nimport { isArray, isNumber } from '../util';\nimport { Base } from './base';\n/**\n * 层次布局\n */\nexport class DagreLayout extends Base {\n    constructor(options) {\n        super();\n        /** layout 方向, 可选 TB, BT, LR, RL */\n        this.rankdir = 'TB';\n        /** 节点水平间距(px) */\n        this.nodesep = 50;\n        /** 每一层节点之间间距 */\n        this.ranksep = 50;\n        /** 是否保留布局连线的控制点 */\n        this.controlPoints = false;\n        /** 每层节点是否根据节点数据中的 comboId 进行排序，以放置同层 combo 重叠 */\n        this.sortByCombo = false;\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            rankdir: 'TB',\n            align: undefined,\n            nodeSize: undefined,\n            nodesepFunc: undefined,\n            ranksepFunc: undefined,\n            nodesep: 50,\n            ranksep: 50,\n            controlPoints: false,\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const { nodes, nodeSize, rankdir } = self;\n        if (!nodes)\n            return;\n        const edges = self.edges || [];\n        const g = new dagre.graphlib.Graph();\n        let nodeSizeFunc;\n        if (!nodeSize) {\n            nodeSizeFunc = (d) => {\n                if (d.size) {\n                    if (isArray(d.size)) {\n                        return d.size;\n                    }\n                    return [d.size, d.size];\n                }\n                return [40, 40];\n            };\n        }\n        else if (isArray(nodeSize)) {\n            nodeSizeFunc = () => nodeSize;\n        }\n        else {\n            nodeSizeFunc = () => [nodeSize, nodeSize];\n        }\n        let horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n        let vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n        if (rankdir === 'LR' || rankdir === 'RL') {\n            horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n            vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n        }\n        g.setDefaultEdgeLabel(() => ({}));\n        g.setGraph(self);\n        nodes.forEach((node) => {\n            const size = nodeSizeFunc(node);\n            const verti = vertisep(node);\n            const hori = horisep(node);\n            const width = size[0] + 2 * hori;\n            const height = size[1] + 2 * verti;\n            g.setNode(node.id, { width, height });\n        });\n        edges.forEach((edge) => {\n            // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n            g.setEdge(edge.source, edge.target, {\n                weight: edge.weight || 1,\n            });\n        });\n        dagre.layout(g);\n        let coord;\n        g.nodes().forEach((node) => {\n            coord = g.node(node);\n            const i = nodes.findIndex((it) => it.id === node);\n            nodes[i].x = coord.x;\n            nodes[i].y = coord.y;\n        });\n        g.edges().forEach((edge) => {\n            coord = g.edge(edge);\n            const i = edges.findIndex((it) => it.source === edge.v && it.target === edge.w);\n            if (self.controlPoints && edges[i].type !== 'loop') {\n                edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n            }\n        });\n        if (self.sortByCombo) {\n            self.sortLevel('comboId');\n        }\n        return nodes;\n    }\n    sortLevel(propertyName) {\n        const self = this;\n        const nodes = self.nodes;\n        const levels = {};\n        nodes.forEach((node) => {\n            if (!levels[node.y])\n                levels[node.y] = { y: node.y, nodes: [] };\n            levels[node.y].nodes.push(node);\n        });\n        Object.keys(levels).forEach((key) => {\n            const levelNodes = levels[key].nodes;\n            const nodesNum = levelNodes.length;\n            const comboCenters = {};\n            levelNodes.forEach((lnode) => {\n                const lnodeCombo = lnode.comboId;\n                if (!comboCenters[lnodeCombo])\n                    comboCenters[lnodeCombo] = { x: 0, y: 0, count: 0 };\n                comboCenters[lnodeCombo].x += lnode.x;\n                comboCenters[lnodeCombo].y += lnode.y;\n                comboCenters[lnodeCombo].count++;\n            });\n            Object.keys(comboCenters).forEach((ckey) => {\n                comboCenters[ckey].x /= comboCenters[ckey].count;\n                comboCenters[ckey].y /= comboCenters[ckey].count;\n            });\n            if (nodesNum === 1)\n                return;\n            const sortedByX = levelNodes.sort((a, b) => {\n                return a.x - b.x;\n            });\n            const minX = sortedByX[0].x;\n            const maxX = sortedByX[nodesNum - 1].x;\n            const gap = (maxX - minX) / (nodesNum - 1);\n            const sortedByCombo = levelNodes.sort((a, b) => {\n                const aValue = a[propertyName] || 'undefined';\n                const bValue = b[propertyName] || 'undefined';\n                if (aValue < bValue) {\n                    return -1;\n                }\n                if (aValue > bValue) {\n                    return 1;\n                }\n                return 0;\n            });\n            sortedByCombo.forEach((node, i) => {\n                node.x = minX + i * gap;\n            });\n        });\n    }\n}\nfunction getFunc(func, value, defaultValue) {\n    let resultFunc;\n    if (func) {\n        resultFunc = func;\n    }\n    else if (isNumber(value)) {\n        resultFunc = () => value;\n    }\n    else {\n        resultFunc = () => defaultValue;\n    }\n    return resultFunc;\n}\n//# sourceMappingURL=dagre.js.map"]},"metadata":{},"sourceType":"module"}