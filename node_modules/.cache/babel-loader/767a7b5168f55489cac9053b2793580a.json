{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { aProjectFlat, Satistics } from '@antv/l7-utils';\nimport { hexbin } from 'd3-hexbin';\nvar R_EARTH = 6378000;\nexport function pointToHexbin(data, option) {\n  var dataArray = data.dataArray;\n  var _option$size = option.size,\n      size = _option$size === void 0 ? 10 : _option$size,\n      _option$method = option.method,\n      method = _option$method === void 0 ? 'sum' : _option$method;\n  var pixlSize = size / (2 * Math.PI * R_EARTH) * (256 << 20) / 2;\n  var screenPoints = dataArray.map(function (point) {\n    var _aProjectFlat = aProjectFlat(point.coordinates),\n        _aProjectFlat2 = _slicedToArray(_aProjectFlat, 2),\n        x = _aProjectFlat2[0],\n        y = _aProjectFlat2[1];\n\n    return _objectSpread(_objectSpread({}, point), {}, {\n      coordinates: [x, y]\n    });\n  });\n  var newHexbin = hexbin().radius(pixlSize).x(function (d) {\n    return d.coordinates[0];\n  }).y(function (d) {\n    return d.coordinates[1];\n  });\n  var hexbinBins = newHexbin(screenPoints);\n  var result = {\n    dataArray: hexbinBins.map(function (hex, index) {\n      var _ref;\n\n      if (option.field && method) {\n        var columns = Satistics.getColumn(hex, option.field);\n        hex[method] = Satistics.statMap[method](columns);\n      }\n\n      return _ref = {}, _defineProperty(_ref, option.method, hex[method]), _defineProperty(_ref, \"count\", hex.length), _defineProperty(_ref, \"rawData\", hex), _defineProperty(_ref, \"coordinates\", [hex.x, hex.y]), _defineProperty(_ref, \"_id\", index), _ref;\n    }),\n    radius: pixlSize,\n    xOffset: pixlSize,\n    yOffset: pixlSize,\n    type: 'hexagon'\n  };\n  return result;\n}","map":{"version":3,"sources":["../../src/transform/hexagon.ts"],"names":["R_EARTH","dataArray","data","size","method","option","pixlSize","Math","screenPoints","x","y","aProjectFlat","point","coordinates","newHexbin","d","hexbinBins","result","columns","Satistics","hex","radius","xOffset","yOffset","type"],"mappings":"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","sourcesContent":["import { aProjectFlat, Satistics } from '@antv/l7-utils';\nimport { hexbin } from 'd3-hexbin';\nconst R_EARTH = 6378000;\nimport {\n  IParseDataItem,\n  IParserData,\n  ISourceCFG,\n  ITransform,\n} from '@antv/l7-core';\ninterface IHexBinItem<T> extends Array<T> {\n  x: number;\n  y: number;\n  [key: string]: any;\n}\ninterface IRawData {\n  coordinates: [number, number];\n  [key: string]: any;\n}\nexport function pointToHexbin(data: IParserData, option: ITransform) {\n  const dataArray = data.dataArray;\n  const { size = 10, method = 'sum' } = option;\n  const pixlSize = ((size / (2 * Math.PI * R_EARTH)) * (256 << 20)) / 2;\n  const screenPoints: IRawData[] = dataArray.map((point: IParseDataItem) => {\n    const [x, y] = aProjectFlat(point.coordinates);\n    return {\n      ...point,\n      coordinates: [x, y],\n    };\n  });\n\n  const newHexbin = hexbin<IRawData>()\n    .radius(pixlSize)\n    .x((d: IRawData) => d.coordinates[0])\n    .y((d: IRawData) => d.coordinates[1]);\n  const hexbinBins = newHexbin(screenPoints);\n  const result: IParserData = {\n    dataArray: hexbinBins.map((hex: IHexBinItem<IRawData>, index: number) => {\n      if (option.field && method) {\n        const columns = Satistics.getColumn(hex, option.field);\n        hex[method] = Satistics.statMap[method](columns);\n      }\n      return {\n        [option.method]: hex[method],\n        count: hex.length,\n        rawData: hex,\n        coordinates: [hex.x, hex.y],\n        _id: index,\n      };\n    }),\n    radius: pixlSize,\n    xOffset: pixlSize,\n    yOffset: pixlSize,\n    type: 'hexagon',\n  };\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}