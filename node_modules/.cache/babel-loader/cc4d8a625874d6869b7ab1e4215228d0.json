{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt, StringExt } from '../util';\nimport { Point, Polyline } from '../geometry';\nimport { Registry } from '../registry';\nimport { Markup } from '../view/markup';\nimport { ShareRegistry } from './registry';\nimport { Cell } from './cell';\nexport class Edge extends Cell {\n  constructor() {\n    let metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super(metadata);\n  }\n\n  get [Symbol.toStringTag]() {\n    return Edge.toStringTag;\n  }\n\n  preprocess(metadata, ignoreIdCheck) {\n    const {\n      source,\n      sourceCell,\n      sourcePort,\n      sourcePoint,\n      target,\n      targetCell,\n      targetPort,\n      targetPoint\n    } = metadata,\n          others = __rest(metadata, [\"source\", \"sourceCell\", \"sourcePort\", \"sourcePoint\", \"target\", \"targetCell\", \"targetPort\", \"targetPoint\"]);\n\n    const data = others;\n\n    const isValidId = val => typeof val === 'string' || typeof val === 'number';\n\n    if (source != null) {\n      if (Cell.isCell(source)) {\n        data.source = {\n          cell: source.id\n        };\n      } else if (isValidId(source)) {\n        data.source = {\n          cell: source\n        };\n      } else if (Point.isPoint(source)) {\n        data.source = source.toJSON();\n      } else if (Array.isArray(source)) {\n        data.source = {\n          x: source[0],\n          y: source[1]\n        };\n      } else {\n        const cell = source.cell;\n\n        if (Cell.isCell(cell)) {\n          data.source = Object.assign(Object.assign({}, source), {\n            cell: cell.id\n          });\n        } else {\n          data.source = source;\n        }\n      }\n    }\n\n    if (sourceCell != null || sourcePort != null) {\n      let terminal = data.source;\n\n      if (sourceCell != null) {\n        const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;\n\n        if (terminal) {\n          terminal.cell = id;\n        } else {\n          terminal = data.source = {\n            cell: id\n          };\n        }\n      }\n\n      if (sourcePort != null && terminal) {\n        terminal.port = sourcePort;\n      }\n    } else if (sourcePoint != null) {\n      data.source = Point.create(sourcePoint).toJSON();\n    }\n\n    if (target != null) {\n      if (Cell.isCell(target)) {\n        data.target = {\n          cell: target.id\n        };\n      } else if (isValidId(target)) {\n        data.target = {\n          cell: target\n        };\n      } else if (Point.isPoint(target)) {\n        data.target = target.toJSON();\n      } else if (Array.isArray(target)) {\n        data.target = {\n          x: target[0],\n          y: target[1]\n        };\n      } else {\n        const cell = target.cell;\n\n        if (Cell.isCell(cell)) {\n          data.target = Object.assign(Object.assign({}, target), {\n            cell: cell.id\n          });\n        } else {\n          data.target = target;\n        }\n      }\n    }\n\n    if (targetCell != null || targetPort != null) {\n      let terminal = data.target;\n\n      if (targetCell != null) {\n        const id = isValidId(targetCell) ? targetCell : targetCell.id;\n\n        if (terminal) {\n          terminal.cell = id;\n        } else {\n          terminal = data.target = {\n            cell: id\n          };\n        }\n      }\n\n      if (targetPort != null && terminal) {\n        terminal.port = targetPort;\n      }\n    } else if (targetPoint != null) {\n      data.target = Point.create(targetPoint).toJSON();\n    }\n\n    return super.preprocess(data, ignoreIdCheck);\n  }\n\n  setup() {\n    super.setup();\n    this.on('change:labels', args => this.onLabelsChanged(args));\n    this.on('change:vertices', args => this.onVertexsChanged(args));\n  }\n\n  isEdge() {\n    return true;\n  } // #region terminal\n\n\n  disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.set({\n      source: {\n        x: 0,\n        y: 0\n      },\n      target: {\n        x: 0,\n        y: 0\n      }\n    }, options);\n    return this;\n  }\n\n  get source() {\n    return this.getSource();\n  }\n\n  set source(data) {\n    this.setSource(data);\n  }\n\n  getSource() {\n    return this.getTerminal('source');\n  }\n\n  getSourceCellId() {\n    return this.source.cell;\n  }\n\n  getSourcePortId() {\n    return this.source.port;\n  }\n\n  setSource(source, args) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.setTerminal('source', source, args, options);\n  }\n\n  get target() {\n    return this.getTarget();\n  }\n\n  set target(data) {\n    this.setTarget(data);\n  }\n\n  getTarget() {\n    return this.getTerminal('target');\n  }\n\n  getTargetCellId() {\n    return this.target.cell;\n  }\n\n  getTargetPortId() {\n    return this.target.port;\n  }\n\n  setTarget(target, args) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    return this.setTerminal('target', target, args, options);\n  }\n\n  getTerminal(type) {\n    return Object.assign({}, this.store.get(type));\n  }\n\n  setTerminal(type, terminal, args) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    // `terminal` is a cell\n    if (Cell.isCell(terminal)) {\n      this.store.set(type, ObjectExt.merge({}, args, {\n        cell: terminal.id\n      }), options);\n      return this;\n    } // `terminal` is a point-like object\n\n\n    const p = terminal;\n\n    if (Point.isPoint(terminal) || p.x != null && p.y != null) {\n      this.store.set(type, ObjectExt.merge({}, args, {\n        x: p.x,\n        y: p.y\n      }), options);\n      return this;\n    } // `terminal` is an object\n\n\n    this.store.set(type, ObjectExt.cloneDeep(terminal), options);\n    return this;\n  }\n\n  getSourcePoint() {\n    return this.getTerminalPoint('source');\n  }\n\n  getTargetPoint() {\n    return this.getTerminalPoint('target');\n  }\n\n  getTerminalPoint(type) {\n    const terminal = this[type];\n\n    if (Point.isPointLike(terminal)) {\n      return Point.create(terminal);\n    }\n\n    const cell = this.getTerminalCell(type);\n\n    if (cell) {\n      return cell.getConnectionPoint(this, type);\n    }\n\n    return new Point();\n  }\n\n  getSourceCell() {\n    return this.getTerminalCell('source');\n  }\n\n  getTargetCell() {\n    return this.getTerminalCell('target');\n  }\n\n  getTerminalCell(type) {\n    if (this.model) {\n      const cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();\n\n      if (cellId) {\n        return this.model.getCell(cellId);\n      }\n    }\n\n    return null;\n  }\n\n  getSourceNode() {\n    return this.getTerminalNode('source');\n  }\n\n  getTargetNode() {\n    return this.getTerminalNode('target');\n  }\n\n  getTerminalNode(type) {\n    let cell = this; // eslint-disable-line\n\n    const visited = {};\n\n    while (cell && cell.isEdge()) {\n      if (visited[cell.id]) {\n        return null;\n      }\n\n      visited[cell.id] = true;\n      cell = cell.getTerminalCell(type);\n    }\n\n    return cell && cell.isNode() ? cell : null;\n  } // #endregion\n  // #region router\n\n\n  get router() {\n    return this.getRouter();\n  }\n\n  set router(data) {\n    if (data == null) {\n      this.removeRouter();\n    } else {\n      this.setRouter(data);\n    }\n  }\n\n  getRouter() {\n    return this.store.get('router');\n  }\n\n  setRouter(name, args, options) {\n    if (typeof name === 'object') {\n      this.store.set('router', name, args);\n    } else {\n      this.store.set('router', {\n        name,\n        args\n      }, options);\n    }\n\n    return this;\n  }\n\n  removeRouter() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('router', options);\n    return this;\n  } // #endregion\n  // #region connector\n\n\n  get connector() {\n    return this.getConnector();\n  }\n\n  set connector(data) {\n    if (data == null) {\n      this.removeConnector();\n    } else {\n      this.setConnector(data);\n    }\n  }\n\n  getConnector() {\n    return this.store.get('connector');\n  }\n\n  setConnector(name, args, options) {\n    if (typeof name === 'object') {\n      this.store.set('connector', name, args);\n    } else {\n      this.store.set('connector', {\n        name,\n        args\n      }, options);\n    }\n\n    return this;\n  }\n\n  removeConnector() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.store.remove('connector', options);\n  } // #endregion\n  // #region strategy\n\n\n  get strategy() {\n    return this.getStrategy();\n  }\n\n  set strategy(data) {\n    if (data == null) {\n      this.removeStrategy();\n    } else {\n      this.setStrategy(data);\n    }\n  }\n\n  getStrategy() {\n    return this.store.get('strategy');\n  }\n\n  setStrategy(name, args, options) {\n    if (typeof name === 'object') {\n      this.store.set('strategy', name, args);\n    } else {\n      this.store.set('strategy', {\n        name,\n        args\n      }, options);\n    }\n\n    return this;\n  }\n\n  removeStrategy() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.store.remove('strategy', options);\n  } // #endregion\n  // #region labels\n\n\n  getDefaultLabel() {\n    const ctor = this.constructor;\n    const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};\n    return ObjectExt.cloneDeep(defaults);\n  }\n\n  get labels() {\n    return this.getLabels();\n  }\n\n  set labels(labels) {\n    this.setLabels(labels);\n  }\n\n  getLabels() {\n    return [...this.store.get('labels', [])].map(item => this.parseLabel(item));\n  }\n\n  setLabels(labels) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);\n    return this;\n  }\n\n  insertLabel(label, index) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const labels = this.getLabels();\n    const len = labels.length;\n    let idx = index != null && Number.isFinite(index) ? index : len;\n\n    if (idx < 0) {\n      idx = len + idx + 1;\n    }\n\n    labels.splice(idx, 0, this.parseLabel(label));\n    return this.setLabels(labels, options);\n  }\n\n  appendLabel(label) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.insertLabel(label, -1, options);\n  }\n\n  getLabelAt(index) {\n    const labels = this.getLabels();\n\n    if (index != null && Number.isFinite(index)) {\n      return this.parseLabel(labels[index]);\n    }\n\n    return null;\n  }\n\n  setLabelAt(index, label) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (index != null && Number.isFinite(index)) {\n      const labels = this.getLabels();\n      labels[index] = this.parseLabel(label);\n      this.setLabels(labels, options);\n    }\n\n    return this;\n  }\n\n  removeLabelAt(index) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const labels = this.getLabels();\n    const idx = index != null && Number.isFinite(index) ? index : -1;\n    const removed = labels.splice(idx, 1);\n    this.setLabels(labels, options);\n    return removed.length ? removed[0] : null;\n  }\n\n  parseLabel(label) {\n    if (typeof label === 'string') {\n      const ctor = this.constructor;\n      return ctor.parseStringLabel(label);\n    }\n\n    return label;\n  }\n\n  onLabelsChanged(_ref) {\n    let {\n      previous,\n      current\n    } = _ref;\n    const added = previous && current ? current.filter(label1 => {\n      if (!previous.find(label2 => label1 === label2 || ObjectExt.isEqual(label1, label2))) {\n        return label1;\n      }\n\n      return null;\n    }) : current ? [...current] : [];\n    const removed = previous && current ? previous.filter(label1 => {\n      if (!current.find(label2 => label1 === label2 || ObjectExt.isEqual(label1, label2))) {\n        return label1;\n      }\n\n      return null;\n    }) : previous ? [...previous] : [];\n\n    if (added.length > 0) {\n      this.notify('labels:added', {\n        added,\n        cell: this,\n        edge: this\n      });\n    }\n\n    if (removed.length > 0) {\n      this.notify('labels:removed', {\n        removed,\n        cell: this,\n        edge: this\n      });\n    }\n  } // #endregion\n  // #region vertices\n\n\n  get vertexMarkup() {\n    return this.getVertexMarkup();\n  }\n\n  set vertexMarkup(markup) {\n    this.setVertexMarkup(markup);\n  }\n\n  getDefaultVertexMarkup() {\n    return this.store.get('defaultVertexMarkup') || Markup.getEdgeVertexMarkup();\n  }\n\n  getVertexMarkup() {\n    return this.store.get('vertexMarkup') || this.getDefaultVertexMarkup();\n  }\n\n  setVertexMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('vertexMarkup', Markup.clone(markup), options);\n    return this;\n  }\n\n  get vertices() {\n    return this.getVertices();\n  }\n\n  set vertices(vertices) {\n    this.setVertices(vertices);\n  }\n\n  getVertices() {\n    return [...this.store.get('vertices', [])];\n  }\n\n  setVertices(vertices) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const points = Array.isArray(vertices) ? vertices : [vertices];\n    this.store.set('vertices', points.map(p => Point.toJSON(p)), options);\n    return this;\n  }\n\n  insertVertex(vertice, index) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    const vertices = this.getVertices();\n    const len = vertices.length;\n    let idx = index != null && Number.isFinite(index) ? index : len;\n\n    if (idx < 0) {\n      idx = len + idx + 1;\n    }\n\n    vertices.splice(idx, 0, Point.toJSON(vertice));\n    return this.setVertices(vertices, options);\n  }\n\n  appendVertex(vertex) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.insertVertex(vertex, -1, options);\n  }\n\n  getVertexAt(index) {\n    if (index != null && Number.isFinite(index)) {\n      const vertices = this.getVertices();\n      return vertices[index];\n    }\n\n    return null;\n  }\n\n  setVertexAt(index, vertice) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (index != null && Number.isFinite(index)) {\n      const vertices = this.getVertices();\n      vertices[index] = vertice;\n      this.setVertices(vertices, options);\n    }\n\n    return this;\n  }\n\n  removeVertexAt(index) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const vertices = this.getVertices();\n    const idx = index != null && Number.isFinite(index) ? index : -1;\n    vertices.splice(idx, 1);\n    return this.setVertices(vertices, options);\n  }\n\n  onVertexsChanged(_ref2) {\n    let {\n      previous,\n      current\n    } = _ref2;\n    const added = previous && current ? current.filter(p1 => {\n      if (!previous.find(p2 => Point.equals(p1, p2))) {\n        return p1;\n      }\n\n      return null;\n    }) : current ? [...current] : [];\n    const removed = previous && current ? previous.filter(p1 => {\n      if (!current.find(p2 => Point.equals(p1, p2))) {\n        return p1;\n      }\n\n      return null;\n    }) : previous ? [...previous] : [];\n\n    if (added.length > 0) {\n      this.notify('vertexs:added', {\n        added,\n        cell: this,\n        edge: this\n      });\n    }\n\n    if (removed.length > 0) {\n      this.notify('vertexs:removed', {\n        removed,\n        cell: this,\n        edge: this\n      });\n    }\n  } // #endregion\n  // #region markup\n\n\n  getDefaultMarkup() {\n    return this.store.get('defaultMarkup') || Markup.getEdgeMarkup();\n  }\n\n  getMarkup() {\n    return super.getMarkup() || this.getDefaultMarkup();\n  } // #endregion\n  // #region toolMarkup\n\n\n  get toolMarkup() {\n    return this.getToolMarkup();\n  }\n\n  set toolMarkup(markup) {\n    this.setToolMarkup(markup);\n  }\n\n  getDefaultToolMarkup() {\n    return this.store.get('defaultToolMarkup') || Markup.getEdgeToolMarkup();\n  }\n\n  getToolMarkup() {\n    return this.store.get('toolMarkup') || this.getDefaultToolMarkup();\n  }\n\n  setToolMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('toolMarkup', markup, options);\n    return this;\n  }\n\n  get doubleToolMarkup() {\n    return this.getDoubleToolMarkup();\n  }\n\n  set doubleToolMarkup(markup) {\n    this.setDoubleToolMarkup(markup);\n  }\n\n  getDefaultDoubleToolMarkup() {\n    return this.store.get('defaultDoubleToolMarkup');\n  }\n\n  getDoubleToolMarkup() {\n    return this.store.get('doubleToolMarkup') || this.getDefaultDoubleToolMarkup();\n  }\n\n  setDoubleToolMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('doubleToolMarkup', markup, options);\n    return this;\n  } // #endregion\n  // #region arrowheadMarkup\n\n\n  get arrowheadMarkup() {\n    return this.getArrowheadMarkup();\n  }\n\n  set arrowheadMarkup(markup) {\n    this.setArrowheadMarkup(markup);\n  }\n\n  getDefaultArrowheadMarkup() {\n    return this.store.get('defaultArrowheadMarkup') || Markup.getEdgeArrowheadMarkup();\n  }\n\n  getArrowheadMarkup() {\n    return this.store.get('arrowheadMarkup') || this.getDefaultArrowheadMarkup();\n  }\n\n  setArrowheadMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('arrowheadMarkup', markup, options);\n    return this;\n  } // #endregion\n  // #region transform\n\n  /**\n   * Translate the edge vertices (and source and target if they are points)\n   * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.\n   */\n\n\n  translate(tx, ty) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    options.translateBy = options.translateBy || this.id;\n    options.tx = tx;\n    options.ty = ty;\n    return this.applyToPoints(p => ({\n      x: (p.x || 0) + tx,\n      y: (p.y || 0) + ty\n    }), options);\n  }\n  /**\n   * Scales the edge's points (vertices) relative to the given origin.\n   */\n\n\n  scale(sx, sy, origin) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    return this.applyToPoints(p => {\n      return Point.create(p).scale(sx, sy, origin).toJSON();\n    }, options);\n  }\n\n  applyToPoints(worker) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const attrs = {};\n    const source = this.getSource();\n    const target = this.getTarget();\n\n    if (Point.isPointLike(source)) {\n      attrs.source = worker(source);\n    }\n\n    if (Point.isPointLike(target)) {\n      attrs.target = worker(target);\n    }\n\n    const vertices = this.getVertices();\n\n    if (vertices.length > 0) {\n      attrs.vertices = vertices.map(worker);\n    }\n\n    this.store.set(attrs, options);\n    return this;\n  } // #endregion\n  // #region common\n\n\n  getBBox() {\n    return this.getPolyline().bbox();\n  }\n\n  getConnectionPoint() {\n    return this.getPolyline().pointAt(0.5);\n  }\n\n  getPolyline() {\n    const points = [this.getSourcePoint(), this.getTargetPoint()];\n    const vertices = this.getVertices();\n    vertices.forEach(p => points.push(Point.create(p)));\n    return new Polyline(points);\n  }\n\n  updateParent(options) {\n    let newParent = null;\n    const source = this.getSourceCell();\n    const target = this.getTargetCell();\n    const prevParent = this.getParent();\n\n    if (source && target) {\n      if (source === target || source.isDescendantOf(target)) {\n        newParent = target;\n      } else if (target.isDescendantOf(source)) {\n        newParent = source;\n      } else {\n        newParent = Cell.getCommonAncestor(source, target);\n      }\n    } // Unembeds the edge if source and target has no common\n    // ancestor or common ancestor changed\n\n\n    if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n      prevParent.unembed(this, options);\n    }\n\n    if (newParent) {\n      newParent.embed(this, options);\n    }\n\n    return newParent;\n  }\n\n  hasLoop() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const source = this.getSource();\n    const target = this.getTarget();\n    const sourceId = source.cell;\n    const targetId = target.cell;\n\n    if (!sourceId || !targetId) {\n      return false;\n    }\n\n    let loop = sourceId === targetId; // Note that there in the deep mode a edge can have a loop,\n    // even if it connects only a parent and its embed.\n    // A loop \"target equals source\" is valid in both shallow and deep mode.\n    // eslint-disable-next-line\n\n    if (!loop && options.deep && this._model) {\n      const sourceCell = this.getSourceCell();\n      const targetCell = this.getTargetCell();\n\n      if (sourceCell && targetCell) {\n        loop = sourceCell.isAncestorOf(targetCell, options) || targetCell.isAncestorOf(sourceCell, options);\n      }\n    }\n\n    return loop;\n  }\n\n  getFragmentAncestor() {\n    const cells = [this, this.getSourceNode(), this.getTargetNode()].filter(item => item != null);\n    return this.getCommonAncestor(...cells);\n  }\n\n  isFragmentDescendantOf(cell) {\n    const ancestor = this.getFragmentAncestor();\n    return !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell));\n  }\n\n}\nEdge.defaults = {};\n\n(function (Edge) {\n  function equalTerminals(a, b) {\n    const a1 = a;\n    const b1 = b;\n\n    if (a1.cell === b1.cell) {\n      return a1.port === b1.port || a1.port == null && b1.port == null;\n    }\n\n    return false;\n  }\n\n  Edge.equalTerminals = equalTerminals;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.defaultLabel = {\n    markup: [{\n      tagName: 'rect',\n      selector: 'body'\n    }, {\n      tagName: 'text',\n      selector: 'label'\n    }],\n    attrs: {\n      text: {\n        fill: '#000',\n        fontSize: 14,\n        textAnchor: 'middle',\n        textVerticalAnchor: 'middle',\n        pointerEvents: 'none'\n      },\n      rect: {\n        ref: 'label',\n        fill: '#fff',\n        rx: 3,\n        ry: 3,\n        refWidth: 1,\n        refHeight: 1,\n        refX: 0,\n        refY: 0\n      }\n    },\n    position: {\n      distance: 0.5\n    }\n  };\n\n  function parseStringLabel(text) {\n    return {\n      attrs: {\n        label: {\n          text\n        }\n      }\n    };\n  }\n\n  Edge.parseStringLabel = parseStringLabel;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.toStringTag = `X6.${Edge.name}`;\n\n  function isEdge(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Edge) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const edge = instance;\n\n    if ((tag == null || tag === Edge.toStringTag) && typeof edge.isNode === 'function' && typeof edge.isEdge === 'function' && typeof edge.prop === 'function' && typeof edge.attr === 'function' && typeof edge.disconnect === 'function' && typeof edge.getSource === 'function' && typeof edge.getTarget === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Edge.isEdge = isEdge;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.registry = Registry.create({\n    type: 'edge',\n\n    process(shape, options) {\n      if (ShareRegistry.exist(shape, false)) {\n        throw new Error(`Edge with name '${shape}' was registered by anthor Node`);\n      }\n\n      if (typeof options === 'function') {\n        options.config({\n          shape\n        });\n        return options;\n      }\n\n      let parent = Edge; // default inherit from 'dege'\n\n      const {\n        inherit = 'edge'\n      } = options,\n            others = __rest(options, [\"inherit\"]);\n\n      if (typeof inherit === 'string') {\n        const base = this.get(inherit || 'edge');\n\n        if (base == null && inherit) {\n          this.onNotFound(inherit, 'inherited');\n        } else {\n          parent = base;\n        }\n      } else {\n        parent = inherit;\n      }\n\n      if (others.constructorName == null) {\n        others.constructorName = shape;\n      }\n\n      const ctor = parent.define.call(parent, others);\n      ctor.config({\n        shape\n      });\n      return ctor;\n    }\n\n  });\n  ShareRegistry.setEdgeRegistry(Edge.registry);\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  let counter = 0;\n\n  function getClassName(name) {\n    if (name) {\n      return StringExt.pascalCase(name);\n    }\n\n    counter += 1;\n    return `CustomEdge${counter}`;\n  }\n\n  function define(config) {\n    const {\n      constructorName,\n      overwrite\n    } = config,\n          others = __rest(config, [\"constructorName\", \"overwrite\"]);\n\n    const ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n    ctor.config(others);\n\n    if (others.shape) {\n      Edge.registry.register(others.shape, ctor, overwrite);\n    }\n\n    return ctor;\n  }\n\n  Edge.define = define;\n\n  function create(options) {\n    const shape = options.shape || 'edge';\n    const Ctor = Edge.registry.get(shape);\n\n    if (Ctor) {\n      return new Ctor(options);\n    }\n\n    return Edge.registry.onNotFound(shape);\n  }\n\n  Edge.create = create;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  const shape = 'basic.edge';\n  Edge.config({\n    shape,\n\n    propHooks(metadata) {\n      const {\n        label,\n        vertices\n      } = metadata,\n            others = __rest(metadata, [\"label\", \"vertices\"]);\n\n      if (label) {\n        if (others.labels == null) {\n          others.labels = [];\n        }\n\n        const formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;\n        others.labels.push(formated);\n      }\n\n      if (vertices) {\n        if (Array.isArray(vertices)) {\n          others.vertices = vertices.map(item => Point.create(item).toJSON());\n        }\n      }\n\n      return others;\n    }\n\n  });\n  Edge.registry.register(shape, Edge);\n})(Edge || (Edge = {}));","map":{"version":3,"sources":["../../src/model/edge.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ObjectExt, StringExt } from '../util';\nimport { Point, Polyline } from '../geometry';\nimport { Registry, } from '../registry';\nimport { Markup } from '../view/markup';\nimport { ShareRegistry } from './registry';\nimport { Cell } from './cell';\nexport class Edge extends Cell {\n    constructor(metadata = {}) {\n        super(metadata);\n    }\n    get [Symbol.toStringTag]() {\n        return Edge.toStringTag;\n    }\n    preprocess(metadata, ignoreIdCheck) {\n        const { source, sourceCell, sourcePort, sourcePoint, target, targetCell, targetPort, targetPoint } = metadata, others = __rest(metadata, [\"source\", \"sourceCell\", \"sourcePort\", \"sourcePoint\", \"target\", \"targetCell\", \"targetPort\", \"targetPoint\"]);\n        const data = others;\n        const isValidId = (val) => typeof val === 'string' || typeof val === 'number';\n        if (source != null) {\n            if (Cell.isCell(source)) {\n                data.source = { cell: source.id };\n            }\n            else if (isValidId(source)) {\n                data.source = { cell: source };\n            }\n            else if (Point.isPoint(source)) {\n                data.source = source.toJSON();\n            }\n            else if (Array.isArray(source)) {\n                data.source = { x: source[0], y: source[1] };\n            }\n            else {\n                const cell = source.cell;\n                if (Cell.isCell(cell)) {\n                    data.source = Object.assign(Object.assign({}, source), { cell: cell.id });\n                }\n                else {\n                    data.source = source;\n                }\n            }\n        }\n        if (sourceCell != null || sourcePort != null) {\n            let terminal = data.source;\n            if (sourceCell != null) {\n                const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;\n                if (terminal) {\n                    terminal.cell = id;\n                }\n                else {\n                    terminal = data.source = { cell: id };\n                }\n            }\n            if (sourcePort != null && terminal) {\n                terminal.port = sourcePort;\n            }\n        }\n        else if (sourcePoint != null) {\n            data.source = Point.create(sourcePoint).toJSON();\n        }\n        if (target != null) {\n            if (Cell.isCell(target)) {\n                data.target = { cell: target.id };\n            }\n            else if (isValidId(target)) {\n                data.target = { cell: target };\n            }\n            else if (Point.isPoint(target)) {\n                data.target = target.toJSON();\n            }\n            else if (Array.isArray(target)) {\n                data.target = { x: target[0], y: target[1] };\n            }\n            else {\n                const cell = target.cell;\n                if (Cell.isCell(cell)) {\n                    data.target = Object.assign(Object.assign({}, target), { cell: cell.id });\n                }\n                else {\n                    data.target = target;\n                }\n            }\n        }\n        if (targetCell != null || targetPort != null) {\n            let terminal = data.target;\n            if (targetCell != null) {\n                const id = isValidId(targetCell) ? targetCell : targetCell.id;\n                if (terminal) {\n                    terminal.cell = id;\n                }\n                else {\n                    terminal = data.target = { cell: id };\n                }\n            }\n            if (targetPort != null && terminal) {\n                terminal.port = targetPort;\n            }\n        }\n        else if (targetPoint != null) {\n            data.target = Point.create(targetPoint).toJSON();\n        }\n        return super.preprocess(data, ignoreIdCheck);\n    }\n    setup() {\n        super.setup();\n        this.on('change:labels', (args) => this.onLabelsChanged(args));\n        this.on('change:vertices', (args) => this.onVertexsChanged(args));\n    }\n    isEdge() {\n        return true;\n    }\n    // #region terminal\n    disconnect(options = {}) {\n        this.store.set({\n            source: { x: 0, y: 0 },\n            target: { x: 0, y: 0 },\n        }, options);\n        return this;\n    }\n    get source() {\n        return this.getSource();\n    }\n    set source(data) {\n        this.setSource(data);\n    }\n    getSource() {\n        return this.getTerminal('source');\n    }\n    getSourceCellId() {\n        return this.source.cell;\n    }\n    getSourcePortId() {\n        return this.source.port;\n    }\n    setSource(source, args, options = {}) {\n        return this.setTerminal('source', source, args, options);\n    }\n    get target() {\n        return this.getTarget();\n    }\n    set target(data) {\n        this.setTarget(data);\n    }\n    getTarget() {\n        return this.getTerminal('target');\n    }\n    getTargetCellId() {\n        return this.target.cell;\n    }\n    getTargetPortId() {\n        return this.target.port;\n    }\n    setTarget(target, args, options = {}) {\n        return this.setTerminal('target', target, args, options);\n    }\n    getTerminal(type) {\n        return Object.assign({}, this.store.get(type));\n    }\n    setTerminal(type, terminal, args, options = {}) {\n        // `terminal` is a cell\n        if (Cell.isCell(terminal)) {\n            this.store.set(type, ObjectExt.merge({}, args, { cell: terminal.id }), options);\n            return this;\n        }\n        // `terminal` is a point-like object\n        const p = terminal;\n        if (Point.isPoint(terminal) || (p.x != null && p.y != null)) {\n            this.store.set(type, ObjectExt.merge({}, args, { x: p.x, y: p.y }), options);\n            return this;\n        }\n        // `terminal` is an object\n        this.store.set(type, ObjectExt.cloneDeep(terminal), options);\n        return this;\n    }\n    getSourcePoint() {\n        return this.getTerminalPoint('source');\n    }\n    getTargetPoint() {\n        return this.getTerminalPoint('target');\n    }\n    getTerminalPoint(type) {\n        const terminal = this[type];\n        if (Point.isPointLike(terminal)) {\n            return Point.create(terminal);\n        }\n        const cell = this.getTerminalCell(type);\n        if (cell) {\n            return cell.getConnectionPoint(this, type);\n        }\n        return new Point();\n    }\n    getSourceCell() {\n        return this.getTerminalCell('source');\n    }\n    getTargetCell() {\n        return this.getTerminalCell('target');\n    }\n    getTerminalCell(type) {\n        if (this.model) {\n            const cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();\n            if (cellId) {\n                return this.model.getCell(cellId);\n            }\n        }\n        return null;\n    }\n    getSourceNode() {\n        return this.getTerminalNode('source');\n    }\n    getTargetNode() {\n        return this.getTerminalNode('target');\n    }\n    getTerminalNode(type) {\n        let cell = this; // eslint-disable-line\n        const visited = {};\n        while (cell && cell.isEdge()) {\n            if (visited[cell.id]) {\n                return null;\n            }\n            visited[cell.id] = true;\n            cell = cell.getTerminalCell(type);\n        }\n        return cell && cell.isNode() ? cell : null;\n    }\n    // #endregion\n    // #region router\n    get router() {\n        return this.getRouter();\n    }\n    set router(data) {\n        if (data == null) {\n            this.removeRouter();\n        }\n        else {\n            this.setRouter(data);\n        }\n    }\n    getRouter() {\n        return this.store.get('router');\n    }\n    setRouter(name, args, options) {\n        if (typeof name === 'object') {\n            this.store.set('router', name, args);\n        }\n        else {\n            this.store.set('router', { name, args }, options);\n        }\n        return this;\n    }\n    removeRouter(options = {}) {\n        this.store.remove('router', options);\n        return this;\n    }\n    // #endregion\n    // #region connector\n    get connector() {\n        return this.getConnector();\n    }\n    set connector(data) {\n        if (data == null) {\n            this.removeConnector();\n        }\n        else {\n            this.setConnector(data);\n        }\n    }\n    getConnector() {\n        return this.store.get('connector');\n    }\n    setConnector(name, args, options) {\n        if (typeof name === 'object') {\n            this.store.set('connector', name, args);\n        }\n        else {\n            this.store.set('connector', { name, args }, options);\n        }\n        return this;\n    }\n    removeConnector(options = {}) {\n        return this.store.remove('connector', options);\n    }\n    // #endregion\n    // #region strategy\n    get strategy() {\n        return this.getStrategy();\n    }\n    set strategy(data) {\n        if (data == null) {\n            this.removeStrategy();\n        }\n        else {\n            this.setStrategy(data);\n        }\n    }\n    getStrategy() {\n        return this.store.get('strategy');\n    }\n    setStrategy(name, args, options) {\n        if (typeof name === 'object') {\n            this.store.set('strategy', name, args);\n        }\n        else {\n            this.store.set('strategy', { name, args }, options);\n        }\n        return this;\n    }\n    removeStrategy(options = {}) {\n        return this.store.remove('strategy', options);\n    }\n    // #endregion\n    // #region labels\n    getDefaultLabel() {\n        const ctor = this.constructor;\n        const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};\n        return ObjectExt.cloneDeep(defaults);\n    }\n    get labels() {\n        return this.getLabels();\n    }\n    set labels(labels) {\n        this.setLabels(labels);\n    }\n    getLabels() {\n        return [...this.store.get('labels', [])].map((item) => this.parseLabel(item));\n    }\n    setLabels(labels, options = {}) {\n        this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);\n        return this;\n    }\n    insertLabel(label, index, options = {}) {\n        const labels = this.getLabels();\n        const len = labels.length;\n        let idx = index != null && Number.isFinite(index) ? index : len;\n        if (idx < 0) {\n            idx = len + idx + 1;\n        }\n        labels.splice(idx, 0, this.parseLabel(label));\n        return this.setLabels(labels, options);\n    }\n    appendLabel(label, options = {}) {\n        return this.insertLabel(label, -1, options);\n    }\n    getLabelAt(index) {\n        const labels = this.getLabels();\n        if (index != null && Number.isFinite(index)) {\n            return this.parseLabel(labels[index]);\n        }\n        return null;\n    }\n    setLabelAt(index, label, options = {}) {\n        if (index != null && Number.isFinite(index)) {\n            const labels = this.getLabels();\n            labels[index] = this.parseLabel(label);\n            this.setLabels(labels, options);\n        }\n        return this;\n    }\n    removeLabelAt(index, options = {}) {\n        const labels = this.getLabels();\n        const idx = index != null && Number.isFinite(index) ? index : -1;\n        const removed = labels.splice(idx, 1);\n        this.setLabels(labels, options);\n        return removed.length ? removed[0] : null;\n    }\n    parseLabel(label) {\n        if (typeof label === 'string') {\n            const ctor = this.constructor;\n            return ctor.parseStringLabel(label);\n        }\n        return label;\n    }\n    onLabelsChanged({ previous, current, }) {\n        const added = previous && current\n            ? current.filter((label1) => {\n                if (!previous.find((label2) => label1 === label2 || ObjectExt.isEqual(label1, label2))) {\n                    return label1;\n                }\n                return null;\n            })\n            : current\n                ? [...current]\n                : [];\n        const removed = previous && current\n            ? previous.filter((label1) => {\n                if (!current.find((label2) => label1 === label2 || ObjectExt.isEqual(label1, label2))) {\n                    return label1;\n                }\n                return null;\n            })\n            : previous\n                ? [...previous]\n                : [];\n        if (added.length > 0) {\n            this.notify('labels:added', { added, cell: this, edge: this });\n        }\n        if (removed.length > 0) {\n            this.notify('labels:removed', { removed, cell: this, edge: this });\n        }\n    }\n    // #endregion\n    // #region vertices\n    get vertexMarkup() {\n        return this.getVertexMarkup();\n    }\n    set vertexMarkup(markup) {\n        this.setVertexMarkup(markup);\n    }\n    getDefaultVertexMarkup() {\n        return this.store.get('defaultVertexMarkup') || Markup.getEdgeVertexMarkup();\n    }\n    getVertexMarkup() {\n        return this.store.get('vertexMarkup') || this.getDefaultVertexMarkup();\n    }\n    setVertexMarkup(markup, options = {}) {\n        this.store.set('vertexMarkup', Markup.clone(markup), options);\n        return this;\n    }\n    get vertices() {\n        return this.getVertices();\n    }\n    set vertices(vertices) {\n        this.setVertices(vertices);\n    }\n    getVertices() {\n        return [...this.store.get('vertices', [])];\n    }\n    setVertices(vertices, options = {}) {\n        const points = Array.isArray(vertices) ? vertices : [vertices];\n        this.store.set('vertices', points.map((p) => Point.toJSON(p)), options);\n        return this;\n    }\n    insertVertex(vertice, index, options = {}) {\n        const vertices = this.getVertices();\n        const len = vertices.length;\n        let idx = index != null && Number.isFinite(index) ? index : len;\n        if (idx < 0) {\n            idx = len + idx + 1;\n        }\n        vertices.splice(idx, 0, Point.toJSON(vertice));\n        return this.setVertices(vertices, options);\n    }\n    appendVertex(vertex, options = {}) {\n        return this.insertVertex(vertex, -1, options);\n    }\n    getVertexAt(index) {\n        if (index != null && Number.isFinite(index)) {\n            const vertices = this.getVertices();\n            return vertices[index];\n        }\n        return null;\n    }\n    setVertexAt(index, vertice, options = {}) {\n        if (index != null && Number.isFinite(index)) {\n            const vertices = this.getVertices();\n            vertices[index] = vertice;\n            this.setVertices(vertices, options);\n        }\n        return this;\n    }\n    removeVertexAt(index, options = {}) {\n        const vertices = this.getVertices();\n        const idx = index != null && Number.isFinite(index) ? index : -1;\n        vertices.splice(idx, 1);\n        return this.setVertices(vertices, options);\n    }\n    onVertexsChanged({ previous, current, }) {\n        const added = previous && current\n            ? current.filter((p1) => {\n                if (!previous.find((p2) => Point.equals(p1, p2))) {\n                    return p1;\n                }\n                return null;\n            })\n            : current\n                ? [...current]\n                : [];\n        const removed = previous && current\n            ? previous.filter((p1) => {\n                if (!current.find((p2) => Point.equals(p1, p2))) {\n                    return p1;\n                }\n                return null;\n            })\n            : previous\n                ? [...previous]\n                : [];\n        if (added.length > 0) {\n            this.notify('vertexs:added', { added, cell: this, edge: this });\n        }\n        if (removed.length > 0) {\n            this.notify('vertexs:removed', { removed, cell: this, edge: this });\n        }\n    }\n    // #endregion\n    // #region markup\n    getDefaultMarkup() {\n        return this.store.get('defaultMarkup') || Markup.getEdgeMarkup();\n    }\n    getMarkup() {\n        return super.getMarkup() || this.getDefaultMarkup();\n    }\n    // #endregion\n    // #region toolMarkup\n    get toolMarkup() {\n        return this.getToolMarkup();\n    }\n    set toolMarkup(markup) {\n        this.setToolMarkup(markup);\n    }\n    getDefaultToolMarkup() {\n        return this.store.get('defaultToolMarkup') || Markup.getEdgeToolMarkup();\n    }\n    getToolMarkup() {\n        return this.store.get('toolMarkup') || this.getDefaultToolMarkup();\n    }\n    setToolMarkup(markup, options = {}) {\n        this.store.set('toolMarkup', markup, options);\n        return this;\n    }\n    get doubleToolMarkup() {\n        return this.getDoubleToolMarkup();\n    }\n    set doubleToolMarkup(markup) {\n        this.setDoubleToolMarkup(markup);\n    }\n    getDefaultDoubleToolMarkup() {\n        return this.store.get('defaultDoubleToolMarkup');\n    }\n    getDoubleToolMarkup() {\n        return (this.store.get('doubleToolMarkup') || this.getDefaultDoubleToolMarkup());\n    }\n    setDoubleToolMarkup(markup, options = {}) {\n        this.store.set('doubleToolMarkup', markup, options);\n        return this;\n    }\n    // #endregion\n    // #region arrowheadMarkup\n    get arrowheadMarkup() {\n        return this.getArrowheadMarkup();\n    }\n    set arrowheadMarkup(markup) {\n        this.setArrowheadMarkup(markup);\n    }\n    getDefaultArrowheadMarkup() {\n        return (this.store.get('defaultArrowheadMarkup') ||\n            Markup.getEdgeArrowheadMarkup());\n    }\n    getArrowheadMarkup() {\n        return this.store.get('arrowheadMarkup') || this.getDefaultArrowheadMarkup();\n    }\n    setArrowheadMarkup(markup, options = {}) {\n        this.store.set('arrowheadMarkup', markup, options);\n        return this;\n    }\n    // #endregion\n    // #region transform\n    /**\n     * Translate the edge vertices (and source and target if they are points)\n     * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.\n     */\n    translate(tx, ty, options = {}) {\n        options.translateBy = options.translateBy || this.id;\n        options.tx = tx;\n        options.ty = ty;\n        return this.applyToPoints((p) => ({\n            x: (p.x || 0) + tx,\n            y: (p.y || 0) + ty,\n        }), options);\n    }\n    /**\n     * Scales the edge's points (vertices) relative to the given origin.\n     */\n    scale(sx, sy, origin, options = {}) {\n        return this.applyToPoints((p) => {\n            return Point.create(p).scale(sx, sy, origin).toJSON();\n        }, options);\n    }\n    applyToPoints(worker, options = {}) {\n        const attrs = {};\n        const source = this.getSource();\n        const target = this.getTarget();\n        if (Point.isPointLike(source)) {\n            attrs.source = worker(source);\n        }\n        if (Point.isPointLike(target)) {\n            attrs.target = worker(target);\n        }\n        const vertices = this.getVertices();\n        if (vertices.length > 0) {\n            attrs.vertices = vertices.map(worker);\n        }\n        this.store.set(attrs, options);\n        return this;\n    }\n    // #endregion\n    // #region common\n    getBBox() {\n        return this.getPolyline().bbox();\n    }\n    getConnectionPoint() {\n        return this.getPolyline().pointAt(0.5);\n    }\n    getPolyline() {\n        const points = [this.getSourcePoint(), this.getTargetPoint()];\n        const vertices = this.getVertices();\n        vertices.forEach((p) => points.push(Point.create(p)));\n        return new Polyline(points);\n    }\n    updateParent(options) {\n        let newParent = null;\n        const source = this.getSourceCell();\n        const target = this.getTargetCell();\n        const prevParent = this.getParent();\n        if (source && target) {\n            if (source === target || source.isDescendantOf(target)) {\n                newParent = target;\n            }\n            else if (target.isDescendantOf(source)) {\n                newParent = source;\n            }\n            else {\n                newParent = Cell.getCommonAncestor(source, target);\n            }\n        }\n        // Unembeds the edge if source and target has no common\n        // ancestor or common ancestor changed\n        if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n            prevParent.unembed(this, options);\n        }\n        if (newParent) {\n            newParent.embed(this, options);\n        }\n        return newParent;\n    }\n    hasLoop(options = {}) {\n        const source = this.getSource();\n        const target = this.getTarget();\n        const sourceId = source.cell;\n        const targetId = target.cell;\n        if (!sourceId || !targetId) {\n            return false;\n        }\n        let loop = sourceId === targetId;\n        // Note that there in the deep mode a edge can have a loop,\n        // even if it connects only a parent and its embed.\n        // A loop \"target equals source\" is valid in both shallow and deep mode.\n        // eslint-disable-next-line\n        if (!loop && options.deep && this._model) {\n            const sourceCell = this.getSourceCell();\n            const targetCell = this.getTargetCell();\n            if (sourceCell && targetCell) {\n                loop =\n                    sourceCell.isAncestorOf(targetCell, options) ||\n                        targetCell.isAncestorOf(sourceCell, options);\n            }\n        }\n        return loop;\n    }\n    getFragmentAncestor() {\n        const cells = [this, this.getSourceNode(), this.getTargetNode()].filter((item) => item != null);\n        return this.getCommonAncestor(...cells);\n    }\n    isFragmentDescendantOf(cell) {\n        const ancestor = this.getFragmentAncestor();\n        return (!!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell)));\n    }\n}\nEdge.defaults = {};\n(function (Edge) {\n    function equalTerminals(a, b) {\n        const a1 = a;\n        const b1 = b;\n        if (a1.cell === b1.cell) {\n            return a1.port === b1.port || (a1.port == null && b1.port == null);\n        }\n        return false;\n    }\n    Edge.equalTerminals = equalTerminals;\n})(Edge || (Edge = {}));\n(function (Edge) {\n    Edge.defaultLabel = {\n        markup: [\n            {\n                tagName: 'rect',\n                selector: 'body',\n            },\n            {\n                tagName: 'text',\n                selector: 'label',\n            },\n        ],\n        attrs: {\n            text: {\n                fill: '#000',\n                fontSize: 14,\n                textAnchor: 'middle',\n                textVerticalAnchor: 'middle',\n                pointerEvents: 'none',\n            },\n            rect: {\n                ref: 'label',\n                fill: '#fff',\n                rx: 3,\n                ry: 3,\n                refWidth: 1,\n                refHeight: 1,\n                refX: 0,\n                refY: 0,\n            },\n        },\n        position: {\n            distance: 0.5,\n        },\n    };\n    function parseStringLabel(text) {\n        return {\n            attrs: { label: { text } },\n        };\n    }\n    Edge.parseStringLabel = parseStringLabel;\n})(Edge || (Edge = {}));\n(function (Edge) {\n    Edge.toStringTag = `X6.${Edge.name}`;\n    function isEdge(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Edge) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const edge = instance;\n        if ((tag == null || tag === Edge.toStringTag) &&\n            typeof edge.isNode === 'function' &&\n            typeof edge.isEdge === 'function' &&\n            typeof edge.prop === 'function' &&\n            typeof edge.attr === 'function' &&\n            typeof edge.disconnect === 'function' &&\n            typeof edge.getSource === 'function' &&\n            typeof edge.getTarget === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Edge.isEdge = isEdge;\n})(Edge || (Edge = {}));\n(function (Edge) {\n    Edge.registry = Registry.create({\n        type: 'edge',\n        process(shape, options) {\n            if (ShareRegistry.exist(shape, false)) {\n                throw new Error(`Edge with name '${shape}' was registered by anthor Node`);\n            }\n            if (typeof options === 'function') {\n                options.config({ shape });\n                return options;\n            }\n            let parent = Edge;\n            // default inherit from 'dege'\n            const { inherit = 'edge' } = options, others = __rest(options, [\"inherit\"]);\n            if (typeof inherit === 'string') {\n                const base = this.get(inherit || 'edge');\n                if (base == null && inherit) {\n                    this.onNotFound(inherit, 'inherited');\n                }\n                else {\n                    parent = base;\n                }\n            }\n            else {\n                parent = inherit;\n            }\n            if (others.constructorName == null) {\n                others.constructorName = shape;\n            }\n            const ctor = parent.define.call(parent, others);\n            ctor.config({ shape });\n            return ctor;\n        },\n    });\n    ShareRegistry.setEdgeRegistry(Edge.registry);\n})(Edge || (Edge = {}));\n(function (Edge) {\n    let counter = 0;\n    function getClassName(name) {\n        if (name) {\n            return StringExt.pascalCase(name);\n        }\n        counter += 1;\n        return `CustomEdge${counter}`;\n    }\n    function define(config) {\n        const { constructorName, overwrite } = config, others = __rest(config, [\"constructorName\", \"overwrite\"]);\n        const ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n        ctor.config(others);\n        if (others.shape) {\n            Edge.registry.register(others.shape, ctor, overwrite);\n        }\n        return ctor;\n    }\n    Edge.define = define;\n    function create(options) {\n        const shape = options.shape || 'edge';\n        const Ctor = Edge.registry.get(shape);\n        if (Ctor) {\n            return new Ctor(options);\n        }\n        return Edge.registry.onNotFound(shape);\n    }\n    Edge.create = create;\n})(Edge || (Edge = {}));\n(function (Edge) {\n    const shape = 'basic.edge';\n    Edge.config({\n        shape,\n        propHooks(metadata) {\n            const { label, vertices } = metadata, others = __rest(metadata, [\"label\", \"vertices\"]);\n            if (label) {\n                if (others.labels == null) {\n                    others.labels = [];\n                }\n                const formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;\n                others.labels.push(formated);\n            }\n            if (vertices) {\n                if (Array.isArray(vertices)) {\n                    others.vertices = vertices.map((item) => Point.create(item).toJSON());\n                }\n            }\n            return others;\n        },\n    });\n    Edge.registry.register(shape, Edge);\n})(Edge || (Edge = {}));\n//# sourceMappingURL=edge.js.map"]},"metadata":{},"sourceType":"module"}