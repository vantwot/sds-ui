{"ast":null,"code":"import _defineProperty from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt } from '../../util';\nimport { Marker } from '../marker';\n\nfunction qualify(value) {\n  return typeof value === 'string' || ObjectExt.isPlainObject(value);\n}\n\nexport var sourceMarker = {\n  qualify: qualify,\n  set: function set(marker, _ref) {\n    var view = _ref.view,\n        attrs = _ref.attrs;\n    return createMarker('marker-start', marker, view, attrs);\n  }\n};\nexport var targetMarker = {\n  qualify: qualify,\n  set: function set(marker, _ref2) {\n    var view = _ref2.view,\n        attrs = _ref2.attrs;\n    return createMarker('marker-end', marker, view, attrs, {\n      transform: 'rotate(180)'\n    });\n  }\n};\nexport var vertexMarker = {\n  qualify: qualify,\n  set: function set(marker, _ref3) {\n    var view = _ref3.view,\n        attrs = _ref3.attrs;\n    return createMarker('marker-mid', marker, view, attrs);\n  }\n};\n\nfunction createMarker(type, marker, view, attrs) {\n  var manual = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var def = typeof marker === 'string' ? {\n    name: marker\n  } : marker;\n\n  var name = def.name,\n      args = def.args,\n      others = __rest(def, [\"name\", \"args\"]);\n\n  var preset = others;\n\n  if (name && typeof name === 'string') {\n    var fn = Marker.registry.get(name);\n\n    if (fn) {\n      preset = fn(Object.assign(Object.assign({}, others), args));\n    } else {\n      return Marker.registry.onNotFound(name);\n    }\n  }\n\n  var options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual), preset);\n  return _defineProperty({}, type, \"url(#\".concat(view.graph.defineMarker(options), \")\"));\n}\n\nfunction normalizeAttr(attr, type) {\n  var result = {}; // The context 'fill' is disregared here. The usual case is to use the\n  // marker with a connection(for which 'fill' attribute is set to 'none').\n\n  var stroke = attr.stroke;\n\n  if (typeof stroke === 'string') {\n    result.stroke = stroke;\n    result.fill = stroke;\n  } // Again the context 'fill-opacity' is ignored.\n\n\n  var strokeOpacity = attr.strokeOpacity;\n\n  if (strokeOpacity == null) {\n    strokeOpacity = attr['stroke-opacity'];\n  }\n\n  if (strokeOpacity == null) {\n    strokeOpacity = attr.opacity;\n  }\n\n  if (strokeOpacity != null) {\n    result['stroke-opacity'] = strokeOpacity;\n    result['fill-opacity'] = strokeOpacity;\n  }\n\n  if (type !== 'marker-mid') {\n    var strokeWidth = parseFloat(attr.strokeWidth || attr['stroke-width']);\n\n    if (Number.isFinite(strokeWidth) && strokeWidth > 1) {\n      var offset = Math.ceil(strokeWidth / 2);\n      result.refX = type === 'marker-start' ? offset : -offset;\n    }\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../../src/registry/attr/marker.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ObjectExt } from '../../util';\nimport { Marker } from '../marker';\nfunction qualify(value) {\n    return typeof value === 'string' || ObjectExt.isPlainObject(value);\n}\nexport const sourceMarker = {\n    qualify,\n    set(marker, { view, attrs }) {\n        return createMarker('marker-start', marker, view, attrs);\n    },\n};\nexport const targetMarker = {\n    qualify,\n    set(marker, { view, attrs }) {\n        return createMarker('marker-end', marker, view, attrs, {\n            transform: 'rotate(180)',\n        });\n    },\n};\nexport const vertexMarker = {\n    qualify,\n    set(marker, { view, attrs }) {\n        return createMarker('marker-mid', marker, view, attrs);\n    },\n};\nfunction createMarker(type, marker, view, attrs, manual = {}) {\n    const def = typeof marker === 'string' ? { name: marker } : marker;\n    const { name, args } = def, others = __rest(def, [\"name\", \"args\"]);\n    let preset = others;\n    if (name && typeof name === 'string') {\n        const fn = Marker.registry.get(name);\n        if (fn) {\n            preset = fn(Object.assign(Object.assign({}, others), args));\n        }\n        else {\n            return Marker.registry.onNotFound(name);\n        }\n    }\n    const options = Object.assign(Object.assign(Object.assign({}, normalizeAttr(attrs, type)), manual), preset);\n    return {\n        [type]: `url(#${view.graph.defineMarker(options)})`,\n    };\n}\nfunction normalizeAttr(attr, type) {\n    const result = {};\n    // The context 'fill' is disregared here. The usual case is to use the\n    // marker with a connection(for which 'fill' attribute is set to 'none').\n    const stroke = attr.stroke;\n    if (typeof stroke === 'string') {\n        result.stroke = stroke;\n        result.fill = stroke;\n    }\n    // Again the context 'fill-opacity' is ignored.\n    let strokeOpacity = attr.strokeOpacity;\n    if (strokeOpacity == null) {\n        strokeOpacity = attr['stroke-opacity'];\n    }\n    if (strokeOpacity == null) {\n        strokeOpacity = attr.opacity;\n    }\n    if (strokeOpacity != null) {\n        result['stroke-opacity'] = strokeOpacity;\n        result['fill-opacity'] = strokeOpacity;\n    }\n    if (type !== 'marker-mid') {\n        const strokeWidth = parseFloat((attr.strokeWidth || attr['stroke-width']));\n        if (Number.isFinite(strokeWidth) && strokeWidth > 1) {\n            const offset = Math.ceil(strokeWidth / 2);\n            result.refX = type === 'marker-start' ? offset : -offset;\n        }\n    }\n    return result;\n}\n//# sourceMappingURL=marker.js.map"]},"metadata":{},"sourceType":"module"}