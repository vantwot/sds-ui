{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nimport { Point, Line, Path } from '../../geometry'; // takes care of math. error for case when jump is too close to end of line\n\nconst CLOSE_PROXIMITY_PADDING = 1;\nconst F13 = 1 / 3;\nconst F23 = 2 / 3;\n\nfunction setupUpdating(view) {\n  let updateList = view.graph._jumpOverUpdateList; // first time setup for this paper\n\n  if (updateList == null) {\n    updateList = view.graph._jumpOverUpdateList = [];\n    /**\n     * Handler for a batch:stop event to force\n     * update of all registered links with jump over connector\n     */\n\n    view.graph.on('cell:mouseup', () => {\n      const list = view.graph._jumpOverUpdateList;\n\n      for (let i = 0; i < list.length; i += 1) {\n        list[i].update();\n      }\n    });\n    view.graph.on('model:reseted', () => {\n      updateList = view.graph._jumpOverUpdateList = [];\n    });\n  } // add this link to a list so it can be updated when some other link is updated\n\n\n  if (updateList.indexOf(view) < 0) {\n    updateList.push(view); // watch for change of connector type or removal of link itself\n    // to remove the link from a list of jump over connectors\n\n    const clean = () => updateList.splice(updateList.indexOf(view), 1);\n\n    view.cell.once('change:connector', clean);\n    view.cell.once('removed', clean);\n  }\n}\n\nfunction createLines(sourcePoint, targetPoint) {\n  let route = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n  const points = [sourcePoint, ...route, targetPoint];\n  const lines = [];\n  points.forEach((point, idx) => {\n    const next = points[idx + 1];\n\n    if (next != null) {\n      lines.push(new Line(point, next));\n    }\n  });\n  return lines;\n}\n\nfunction findLineIntersections(line, crossCheckLines) {\n  const intersections = [];\n  crossCheckLines.forEach(crossCheckLine => {\n    const intersection = line.intersectsWithLine(crossCheckLine);\n\n    if (intersection) {\n      intersections.push(intersection);\n    }\n  });\n  return intersections;\n}\n\nfunction getDistence(p1, p2) {\n  return new Line(p1, p2).squaredLength();\n}\n/**\n * Split input line into multiple based on intersection points.\n */\n\n\nfunction createJumps(line, intersections, jumpSize) {\n  return intersections.reduce((memo, point, idx) => {\n    // skipping points that were merged with the previous line\n    // to make bigger arc over multiple lines that are close to each other\n    if (skippedPoints.includes(point)) {\n      return memo;\n    } // always grab the last line from buffer and modify it\n\n\n    const lastLine = memo.pop() || line; // calculate start and end of jump by moving by a given size of jump\n\n    const jumpStart = Point.create(point).move(lastLine.start, -jumpSize);\n    let jumpEnd = Point.create(point).move(lastLine.start, +jumpSize); // now try to look at the next intersection point\n\n    const nextPoint = intersections[idx + 1];\n\n    if (nextPoint != null) {\n      const distance = jumpEnd.distance(nextPoint);\n\n      if (distance <= jumpSize) {\n        // next point is close enough, move the jump end by this\n        // difference and mark the next point to be skipped\n        jumpEnd = nextPoint.move(lastLine.start, distance);\n        skippedPoints.push(nextPoint);\n      }\n    } else {\n      // this block is inside of `else` as an optimization so the distance is\n      // not calculated when we know there are no other intersection points\n      const endDistance = jumpStart.distance(lastLine.end); // if the end is too close to possible jump, draw remaining line instead of a jump\n\n      if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n        memo.push(lastLine);\n        return memo;\n      }\n    }\n\n    const startDistance = jumpEnd.distance(lastLine.start);\n\n    if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n      // if the start of line is too close to jump, draw that line instead of a jump\n      memo.push(lastLine);\n      return memo;\n    } // finally create a jump line\n\n\n    const jumpLine = new Line(jumpStart, jumpEnd); // it's just simple line but with a `isJump` property\n\n    jumppedLines.push(jumpLine);\n    memo.push(new Line(lastLine.start, jumpStart), jumpLine, new Line(jumpEnd, lastLine.end));\n    return memo;\n  }, []);\n}\n\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n  const path = new Path();\n  let segment; // first move to the start of a first line\n\n  segment = Path.createSegment('M', lines[0].start);\n  path.appendSegment(segment);\n  lines.forEach((line, index) => {\n    if (jumppedLines.includes(line)) {\n      let angle;\n      let diff;\n      let control1;\n      let control2;\n\n      if (jumpType === 'arc') {\n        // approximates semicircle with 2 curves\n        angle = -90; // determine rotation of arc based on difference between points\n\n        diff = line.start.diff(line.end); // make sure the arc always points up (or right)\n\n        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;\n\n        if (xAxisRotate) {\n          angle += 180;\n        }\n\n        const center = line.getCenter();\n        const centerLine = new Line(center, line.end).rotate(angle, center);\n        let halfLine; // first half\n\n        halfLine = new Line(line.start, center);\n        control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start);\n        control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);\n        segment = Path.createSegment('C', control1, control2, centerLine.end);\n        path.appendSegment(segment); // second half\n\n        halfLine = new Line(center, line.end);\n        control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);\n        control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end);\n        segment = Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'gap') {\n        segment = Path.createSegment('M', line.end);\n        path.appendSegment(segment);\n      } else if (jumpType === 'cubic') {\n        // approximates semicircle with 1 curve\n        angle = line.start.theta(line.end);\n        const xOffset = jumpSize * 0.6;\n        let yOffset = jumpSize * 1.35; // determine rotation of arc based on difference between points\n\n        diff = line.start.diff(line.end); // make sure the arc always points up (or right)\n\n        const xAxisRotate = diff.x < 0 || diff.x === 0 && diff.y < 0;\n\n        if (xAxisRotate) {\n          yOffset *= -1;\n        }\n\n        control1 = new Point(line.start.x + xOffset, line.start.y + yOffset).rotate(angle, line.start);\n        control2 = new Point(line.end.x - xOffset, line.end.y + yOffset).rotate(angle, line.end);\n        segment = Path.createSegment('C', control1, control2, line.end);\n        path.appendSegment(segment);\n      }\n    } else {\n      const nextLine = lines[index + 1];\n\n      if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {\n        segment = Path.createSegment('L', line.end);\n        path.appendSegment(segment);\n      } else {\n        buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n      }\n    }\n  });\n  return path;\n}\n\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n  const prevDistance = curr.distance(prev) / 2;\n  const nextDistance = curr.distance(next) / 2;\n  const startMove = -Math.min(offset, prevDistance);\n  const endMove = -Math.min(offset, nextDistance);\n  const roundedStart = curr.clone().move(prev, startMove).round();\n  const roundedEnd = curr.clone().move(next, endMove).round();\n  const control1 = new Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);\n  const control2 = new Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);\n  let segment;\n  segment = Path.createSegment('L', roundedStart);\n  path.appendSegment(segment);\n  segment = Path.createSegment('C', control1, control2, roundedEnd);\n  path.appendSegment(segment);\n}\n\nlet jumppedLines;\nlet skippedPoints;\nexport const jumpover = function (sourcePoint, targetPoint, routePoints) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  jumppedLines = [];\n  skippedPoints = [];\n  setupUpdating(this);\n  const jumpSize = options.size || 5;\n  const jumpType = options.type || 'arc';\n  const radius = options.radius || 0; // list of connector types not to jump over.\n\n  const ignoreConnectors = options.ignoreConnectors || ['smooth'];\n  const graph = this.graph;\n  const model = graph.model;\n  const allLinks = model.getEdges(); // there is just one link, draw it directly\n\n  if (allLinks.length === 1) {\n    return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);\n  }\n\n  const edge = this.cell;\n  const thisIndex = allLinks.indexOf(edge);\n  const defaultConnector = graph.options.connecting.connector || {}; // not all links are meant to be jumped over.\n\n  const edges = allLinks.filter((link, idx) => {\n    const connector = link.getConnector() || defaultConnector; // avoid jumping over links with connector type listed in `ignored connectors`.\n\n    if (ignoreConnectors.includes(connector.name)) {\n      return false;\n    } // filter out links that are above this one and  have the same connector type\n    // otherwise there would double hoops for each intersection\n\n\n    if (idx > thisIndex) {\n      return connector.name !== 'jumpover';\n    }\n\n    return true;\n  }); // find views for all links\n\n  const linkViews = edges.map(edge => {\n    return graph.renderer.findViewByCell(edge);\n  }); // create lines for this link\n\n  const thisLines = createLines(sourcePoint, targetPoint, routePoints); // create lines for all other links\n\n  const linkLines = linkViews.map(linkView => {\n    if (linkView == null) {\n      return [];\n    }\n\n    if (linkView === this) {\n      return thisLines;\n    }\n\n    return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);\n  }); // transform lines for this link by splitting with jump lines at\n  // points of intersection with other links\n\n  const jumpingLines = [];\n  thisLines.forEach(line => {\n    // iterate all links and grab the intersections with this line\n    // these are then sorted by distance so the line can be split more easily\n    const intersections = edges.reduce((memo, link, i) => {\n      // don't intersection with itself\n      if (link !== edge) {\n        const lineIntersections = findLineIntersections(line, linkLines[i]);\n        memo.push(...lineIntersections);\n      }\n\n      return memo;\n    }, []).sort((a, b) => getDistence(line.start, a) - getDistence(line.start, b));\n\n    if (intersections.length > 0) {\n      // split the line based on found intersection points\n      jumpingLines.push(...createJumps(line, intersections, jumpSize));\n    } else {\n      // without any intersection the line goes uninterrupted\n      jumpingLines.push(line);\n    }\n  });\n  const path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n  jumppedLines = [];\n  skippedPoints = [];\n  return options.raw ? path : path.serialize();\n};","map":{"version":3,"sources":["../../../src/registry/connector/jumpover.ts"],"names":[],"mappings":"AAAA;AAEA,SAAS,KAAT,EAAgB,IAAhB,EAAsB,IAAtB,QAAkC,gBAAlC,C,CAKA;;AACA,MAAM,uBAAuB,GAAG,CAAhC;AACA,MAAM,GAAG,GAAG,IAAI,CAAhB;AACA,MAAM,GAAG,GAAG,IAAI,CAAhB;;AAEA,SAAS,aAAT,CAAuB,IAAvB,EAAqC;AACnC,MAAI,UAAU,GAAI,IAAI,CAAC,KAAL,CAAmB,mBAArC,CADmC,CAGnC;;AACA,MAAI,UAAU,IAAI,IAAlB,EAAwB;AACtB,IAAA,UAAU,GAAI,IAAI,CAAC,KAAL,CAAmB,mBAAnB,GAAyC,EAAvD;AAEA;;;AAGG;;AACH,IAAA,IAAI,CAAC,KAAL,CAAW,EAAX,CAAc,cAAd,EAA8B,MAAK;AACjC,YAAM,IAAI,GAAI,IAAI,CAAC,KAAL,CAAmB,mBAAjC;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,IAAI,CAAC,MAAzB,EAAiC,CAAC,IAAI,CAAtC,EAAyC;AACvC,QAAA,IAAI,CAAC,CAAD,CAAJ,CAAQ,MAAR;AACD;AACF,KALD;AAOA,IAAA,IAAI,CAAC,KAAL,CAAW,EAAX,CAAc,eAAd,EAA+B,MAAK;AAClC,MAAA,UAAU,GAAI,IAAI,CAAC,KAAL,CAAmB,mBAAnB,GAAyC,EAAvD;AACD,KAFD;AAGD,GArBkC,CAuBnC;;;AACA,MAAI,UAAU,CAAC,OAAX,CAAmB,IAAnB,IAA2B,CAA/B,EAAkC;AAChC,IAAA,UAAU,CAAC,IAAX,CAAgB,IAAhB,EADgC,CAGhC;AACA;;AACA,UAAM,KAAK,GAAG,MAAM,UAAU,CAAC,MAAX,CAAkB,UAAU,CAAC,OAAX,CAAmB,IAAnB,CAAlB,EAA4C,CAA5C,CAApB;;AACA,IAAA,IAAI,CAAC,IAAL,CAAU,IAAV,CAAe,kBAAf,EAAmC,KAAnC;AACA,IAAA,IAAI,CAAC,IAAL,CAAU,IAAV,CAAe,SAAf,EAA0B,KAA1B;AACD;AACF;;AAED,SAAS,WAAT,CACE,WADF,EAEE,WAFF,EAG+B;AAAA,MAA7B,KAA6B,uEAAF,EAAE;AAE7B,QAAM,MAAM,GAAG,CAAC,WAAD,EAAc,GAAG,KAAjB,EAAwB,WAAxB,CAAf;AACA,QAAM,KAAK,GAAW,EAAtB;AAEA,EAAA,MAAM,CAAC,OAAP,CAAe,CAAC,KAAD,EAAQ,GAAR,KAAe;AAC5B,UAAM,IAAI,GAAG,MAAM,CAAC,GAAG,GAAG,CAAP,CAAnB;;AACA,QAAI,IAAI,IAAI,IAAZ,EAAkB;AAChB,MAAA,KAAK,CAAC,IAAN,CAAW,IAAI,IAAJ,CAAS,KAAT,EAAgB,IAAhB,CAAX;AACD;AACF,GALD;AAOA,SAAO,KAAP;AACD;;AAED,SAAS,qBAAT,CAA+B,IAA/B,EAA2C,eAA3C,EAAkE;AAChE,QAAM,aAAa,GAAY,EAA/B;AACA,EAAA,eAAe,CAAC,OAAhB,CAAyB,cAAD,IAAmB;AACzC,UAAM,YAAY,GAAG,IAAI,CAAC,kBAAL,CAAwB,cAAxB,CAArB;;AACA,QAAI,YAAJ,EAAkB;AAChB,MAAA,aAAa,CAAC,IAAd,CAAmB,YAAnB;AACD;AACF,GALD;AAMA,SAAO,aAAP;AACD;;AAED,SAAS,WAAT,CAAqB,EAArB,EAAgC,EAAhC,EAAyC;AACvC,SAAO,IAAI,IAAJ,CAAS,EAAT,EAAa,EAAb,EAAiB,aAAjB,EAAP;AACD;AAED;;AAEG;;;AACH,SAAS,WAAT,CAAqB,IAArB,EAAiC,aAAjC,EAAyD,QAAzD,EAAyE;AACvE,SAAO,aAAa,CAAC,MAAd,CAA6B,CAAC,IAAD,EAAO,KAAP,EAAc,GAAd,KAAqB;AACvD;AACA;AACA,QAAI,aAAa,CAAC,QAAd,CAAuB,KAAvB,CAAJ,EAAmC;AACjC,aAAO,IAAP;AACD,KALsD,CAOvD;;;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,GAAL,MAAc,IAA/B,CARuD,CAUvD;;AACA,UAAM,SAAS,GAAG,KAAK,CAAC,MAAN,CAAa,KAAb,EAAoB,IAApB,CAAyB,QAAQ,CAAC,KAAlC,EAAyC,CAAC,QAA1C,CAAlB;AACA,QAAI,OAAO,GAAG,KAAK,CAAC,MAAN,CAAa,KAAb,EAAoB,IAApB,CAAyB,QAAQ,CAAC,KAAlC,EAAyC,CAAC,QAA1C,CAAd,CAZuD,CAcvD;;AACA,UAAM,SAAS,GAAG,aAAa,CAAC,GAAG,GAAG,CAAP,CAA/B;;AACA,QAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,YAAM,QAAQ,GAAG,OAAO,CAAC,QAAR,CAAiB,SAAjB,CAAjB;;AACA,UAAI,QAAQ,IAAI,QAAhB,EAA0B;AACxB;AACA;AACA,QAAA,OAAO,GAAG,SAAS,CAAC,IAAV,CAAe,QAAQ,CAAC,KAAxB,EAA+B,QAA/B,CAAV;AACA,QAAA,aAAa,CAAC,IAAd,CAAmB,SAAnB;AACD;AACF,KARD,MAQO;AACL;AACA;AACA,YAAM,WAAW,GAAG,SAAS,CAAC,QAAV,CAAmB,QAAQ,CAAC,GAA5B,CAApB,CAHK,CAIL;;AACA,UAAI,WAAW,GAAG,QAAQ,GAAG,CAAX,GAAe,uBAAjC,EAA0D;AACxD,QAAA,IAAI,CAAC,IAAL,CAAU,QAAV;AACA,eAAO,IAAP;AACD;AACF;;AAED,UAAM,aAAa,GAAG,OAAO,CAAC,QAAR,CAAiB,QAAQ,CAAC,KAA1B,CAAtB;;AACA,QAAI,aAAa,GAAG,QAAQ,GAAG,CAAX,GAAe,uBAAnC,EAA4D;AAC1D;AACA,MAAA,IAAI,CAAC,IAAL,CAAU,QAAV;AACA,aAAO,IAAP;AACD,KAxCsD,CA0CvD;;;AACA,UAAM,QAAQ,GAAG,IAAI,IAAJ,CAAS,SAAT,EAAoB,OAApB,CAAjB,CA3CuD,CA4CvD;;AACA,IAAA,YAAY,CAAC,IAAb,CAAkB,QAAlB;AAEA,IAAA,IAAI,CAAC,IAAL,CACE,IAAI,IAAJ,CAAS,QAAQ,CAAC,KAAlB,EAAyB,SAAzB,CADF,EAEE,QAFF,EAGE,IAAI,IAAJ,CAAS,OAAT,EAAkB,QAAQ,CAAC,GAA3B,CAHF;AAMA,WAAO,IAAP;AACD,GAtDM,EAsDJ,EAtDI,CAAP;AAuDD;;AAED,SAAS,SAAT,CACE,KADF,EAEE,QAFF,EAGE,QAHF,EAIE,MAJF,EAIgB;AAEd,QAAM,IAAI,GAAG,IAAI,IAAJ,EAAb;AACA,MAAI,OAAJ,CAHc,CAKd;;AACA,EAAA,OAAO,GAAG,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,KAAK,CAAC,CAAD,CAAL,CAAS,KAAjC,CAAV;AACA,EAAA,IAAI,CAAC,aAAL,CAAmB,OAAnB;AAEA,EAAA,KAAK,CAAC,OAAN,CAAc,CAAC,IAAD,EAAO,KAAP,KAAgB;AAC5B,QAAI,YAAY,CAAC,QAAb,CAAsB,IAAtB,CAAJ,EAAiC;AAC/B,UAAI,KAAJ;AACA,UAAI,IAAJ;AAEA,UAAI,QAAJ;AACA,UAAI,QAAJ;;AAEA,UAAI,QAAQ,KAAK,KAAjB,EAAwB;AACtB;AACA,QAAA,KAAK,GAAG,CAAC,EAAT,CAFsB,CAGtB;;AACA,QAAA,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,IAAI,CAAC,GAArB,CAAP,CAJsB,CAKtB;;AACA,cAAM,WAAW,GAAG,IAAI,CAAC,CAAL,GAAS,CAAT,IAAe,IAAI,CAAC,CAAL,KAAW,CAAX,IAAgB,IAAI,CAAC,CAAL,GAAS,CAA5D;;AACA,YAAI,WAAJ,EAAiB;AACf,UAAA,KAAK,IAAI,GAAT;AACD;;AAED,cAAM,MAAM,GAAG,IAAI,CAAC,SAAL,EAAf;AACA,cAAM,UAAU,GAAG,IAAI,IAAJ,CAAS,MAAT,EAAiB,IAAI,CAAC,GAAtB,EAA2B,MAA3B,CAAkC,KAAlC,EAAyC,MAAzC,CAAnB;AAEA,YAAI,QAAJ,CAdsB,CAgBtB;;AACA,QAAA,QAAQ,GAAG,IAAI,IAAJ,CAAS,IAAI,CAAC,KAAd,EAAqB,MAArB,CAAX;AACA,QAAA,QAAQ,GAAG,QAAQ,CAAC,OAAT,CAAiB,IAAI,CAArB,EAAwB,MAAxB,CAA+B,KAA/B,EAAsC,IAAI,CAAC,KAA3C,CAAX;AACA,QAAA,QAAQ,GAAG,UAAU,CAAC,OAAX,CAAmB,IAAI,CAAvB,EAA0B,MAA1B,CAAiC,CAAC,KAAlC,EAAyC,UAAU,CAAC,GAApD,CAAX;AAEA,QAAA,OAAO,GAAG,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,QAAxB,EAAkC,QAAlC,EAA4C,UAAU,CAAC,GAAvD,CAAV;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,OAAnB,EAtBsB,CAwBtB;;AACA,QAAA,QAAQ,GAAG,IAAI,IAAJ,CAAS,MAAT,EAAiB,IAAI,CAAC,GAAtB,CAAX;AAEA,QAAA,QAAQ,GAAG,UAAU,CAAC,OAAX,CAAmB,IAAI,CAAvB,EAA0B,MAA1B,CAAiC,KAAjC,EAAwC,UAAU,CAAC,GAAnD,CAAX;AACA,QAAA,QAAQ,GAAG,QAAQ,CAAC,OAAT,CAAiB,IAAI,CAArB,EAAwB,MAAxB,CAA+B,CAAC,KAAhC,EAAuC,IAAI,CAAC,GAA5C,CAAX;AAEA,QAAA,OAAO,GAAG,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,QAAxB,EAAkC,QAAlC,EAA4C,IAAI,CAAC,GAAjD,CAAV;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,OAAnB;AACD,OAhCD,MAgCO,IAAI,QAAQ,KAAK,KAAjB,EAAwB;AAC7B,QAAA,OAAO,GAAG,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,IAAI,CAAC,GAA7B,CAAV;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,OAAnB;AACD,OAHM,MAGA,IAAI,QAAQ,KAAK,OAAjB,EAA0B;AAC/B;AACA,QAAA,KAAK,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,IAAI,CAAC,GAAtB,CAAR;AAEA,cAAM,OAAO,GAAG,QAAQ,GAAG,GAA3B;AACA,YAAI,OAAO,GAAG,QAAQ,GAAG,IAAzB,CAL+B,CAO/B;;AACA,QAAA,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,IAAI,CAAC,GAArB,CAAP,CAR+B,CAS/B;;AACA,cAAM,WAAW,GAAG,IAAI,CAAC,CAAL,GAAS,CAAT,IAAe,IAAI,CAAC,CAAL,KAAW,CAAX,IAAgB,IAAI,CAAC,CAAL,GAAS,CAA5D;;AACA,YAAI,WAAJ,EAAiB;AACf,UAAA,OAAO,IAAI,CAAC,CAAZ;AACD;;AAED,QAAA,QAAQ,GAAG,IAAI,KAAJ,CACT,IAAI,CAAC,KAAL,CAAW,CAAX,GAAe,OADN,EAET,IAAI,CAAC,KAAL,CAAW,CAAX,GAAe,OAFN,EAGT,MAHS,CAGF,KAHE,EAGK,IAAI,CAAC,KAHV,CAAX;AAIA,QAAA,QAAQ,GAAG,IAAI,KAAJ,CAAU,IAAI,CAAC,GAAL,CAAS,CAAT,GAAa,OAAvB,EAAgC,IAAI,CAAC,GAAL,CAAS,CAAT,GAAa,OAA7C,EAAsD,MAAtD,CACT,KADS,EAET,IAAI,CAAC,GAFI,CAAX;AAKA,QAAA,OAAO,GAAG,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,QAAxB,EAAkC,QAAlC,EAA4C,IAAI,CAAC,GAAjD,CAAV;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,OAAnB;AACD;AACF,KArED,MAqEO;AACL,YAAM,QAAQ,GAAG,KAAK,CAAC,KAAK,GAAG,CAAT,CAAtB;;AACA,UAAI,MAAM,KAAK,CAAX,IAAgB,CAAC,QAAjB,IAA6B,YAAY,CAAC,QAAb,CAAsB,QAAtB,CAAjC,EAAkE;AAChE,QAAA,OAAO,GAAG,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,IAAI,CAAC,GAA7B,CAAV;AACA,QAAA,IAAI,CAAC,aAAL,CAAmB,OAAnB;AACD,OAHD,MAGO;AACL,QAAA,mBAAmB,CAAC,MAAD,EAAS,IAAT,EAAe,IAAI,CAAC,GAApB,EAAyB,IAAI,CAAC,KAA9B,EAAqC,QAAQ,CAAC,GAA9C,CAAnB;AACD;AACF;AACF,GA/ED;AAiFA,SAAO,IAAP;AACD;;AAED,SAAS,mBAAT,CACE,MADF,EAEE,IAFF,EAGE,IAHF,EAIE,IAJF,EAKE,IALF,EAKa;AAEX,QAAM,YAAY,GAAG,IAAI,CAAC,QAAL,CAAc,IAAd,IAAsB,CAA3C;AACA,QAAM,YAAY,GAAG,IAAI,CAAC,QAAL,CAAc,IAAd,IAAsB,CAA3C;AAEA,QAAM,SAAS,GAAG,CAAC,IAAI,CAAC,GAAL,CAAS,MAAT,EAAiB,YAAjB,CAAnB;AACA,QAAM,OAAO,GAAG,CAAC,IAAI,CAAC,GAAL,CAAS,MAAT,EAAiB,YAAjB,CAAjB;AAEA,QAAM,YAAY,GAAG,IAAI,CAAC,KAAL,GAAa,IAAb,CAAkB,IAAlB,EAAwB,SAAxB,EAAmC,KAAnC,EAArB;AACA,QAAM,UAAU,GAAG,IAAI,CAAC,KAAL,GAAa,IAAb,CAAkB,IAAlB,EAAwB,OAAxB,EAAiC,KAAjC,EAAnB;AAEA,QAAM,QAAQ,GAAG,IAAI,KAAJ,CACf,GAAG,GAAG,YAAY,CAAC,CAAnB,GAAuB,GAAG,GAAG,IAAI,CAAC,CADnB,EAEf,GAAG,GAAG,IAAI,CAAC,CAAX,GAAe,GAAG,GAAG,YAAY,CAAC,CAFnB,CAAjB;AAIA,QAAM,QAAQ,GAAG,IAAI,KAAJ,CACf,GAAG,GAAG,UAAU,CAAC,CAAjB,GAAqB,GAAG,GAAG,IAAI,CAAC,CADjB,EAEf,GAAG,GAAG,IAAI,CAAC,CAAX,GAAe,GAAG,GAAG,UAAU,CAAC,CAFjB,CAAjB;AAKA,MAAI,OAAJ;AACA,EAAA,OAAO,GAAG,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,YAAxB,CAAV;AACA,EAAA,IAAI,CAAC,aAAL,CAAmB,OAAnB;AAEA,EAAA,OAAO,GAAG,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,QAAxB,EAAkC,QAAlC,EAA4C,UAA5C,CAAV;AACA,EAAA,IAAI,CAAC,aAAL,CAAmB,OAAnB;AACD;;AAWD,IAAI,YAAJ;AACA,IAAI,aAAJ;AAEA,OAAO,MAAM,QAAQ,GACnB,UAAU,WAAV,EAAuB,WAAvB,EAAoC,WAApC,EAA6D;AAAA,MAAZ,OAAY,uEAAF,EAAE;AAC3D,EAAA,YAAY,GAAG,EAAf;AACA,EAAA,aAAa,GAAG,EAAhB;AAEA,EAAA,aAAa,CAAC,IAAD,CAAb;AAEA,QAAM,QAAQ,GAAG,OAAO,CAAC,IAAR,IAAgB,CAAjC;AACA,QAAM,QAAQ,GAAG,OAAO,CAAC,IAAR,IAAgB,KAAjC;AACA,QAAM,MAAM,GAAG,OAAO,CAAC,MAAR,IAAkB,CAAjC,CAR2D,CAS3D;;AACA,QAAM,gBAAgB,GAAG,OAAO,CAAC,gBAAR,IAA4B,CAAC,QAAD,CAArD;AAEA,QAAM,KAAK,GAAG,KAAK,KAAnB;AACA,QAAM,KAAK,GAAG,KAAK,CAAC,KAApB;AACA,QAAM,QAAQ,GAAG,KAAK,CAAC,QAAN,EAAjB,CAd2D,CAgB3D;;AACA,MAAI,QAAQ,CAAC,MAAT,KAAoB,CAAxB,EAA2B;AACzB,WAAO,SAAS,CACd,WAAW,CAAC,WAAD,EAAc,WAAd,EAA2B,WAA3B,CADG,EAEd,QAFc,EAGd,QAHc,EAId,MAJc,CAAhB;AAMD;;AAED,QAAM,IAAI,GAAG,KAAK,IAAlB;AACA,QAAM,SAAS,GAAG,QAAQ,CAAC,OAAT,CAAiB,IAAjB,CAAlB;AACA,QAAM,gBAAgB,GAAG,KAAK,CAAC,OAAN,CAAc,UAAd,CAAyB,SAAzB,IAAsC,EAA/D,CA5B2D,CA8B3D;;AACA,QAAM,KAAK,GAAG,QAAQ,CAAC,MAAT,CAAgB,CAAC,IAAD,EAAO,GAAP,KAAc;AAC1C,UAAM,SAAS,GAAG,IAAI,CAAC,YAAL,MAAwB,gBAA1C,CAD0C,CAG1C;;AACA,QAAI,gBAAgB,CAAC,QAAjB,CAA0B,SAAS,CAAC,IAApC,CAAJ,EAA+C;AAC7C,aAAO,KAAP;AACD,KANyC,CAO1C;AACA;;;AACA,QAAI,GAAG,GAAG,SAAV,EAAqB;AACnB,aAAO,SAAS,CAAC,IAAV,KAAmB,UAA1B;AACD;;AACD,WAAO,IAAP;AACD,GAba,CAAd,CA/B2D,CA8C3D;;AACA,QAAM,SAAS,GAAG,KAAK,CAAC,GAAN,CAAW,IAAD,IAAS;AACnC,WAAO,KAAK,CAAC,QAAN,CAAe,cAAf,CAA8B,IAA9B,CAAP;AACD,GAFiB,CAAlB,CA/C2D,CAmD3D;;AACA,QAAM,SAAS,GAAG,WAAW,CAAC,WAAD,EAAc,WAAd,EAA2B,WAA3B,CAA7B,CApD2D,CAsD3D;;AACA,QAAM,SAAS,GAAG,SAAS,CAAC,GAAV,CAAe,QAAD,IAAa;AAC3C,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAO,EAAP;AACD;;AACD,QAAI,QAAQ,KAAK,IAAjB,EAAuB;AACrB,aAAO,SAAP;AACD;;AACD,WAAO,WAAW,CAChB,QAAQ,CAAC,WADO,EAEhB,QAAQ,CAAC,WAFO,EAGhB,QAAQ,CAAC,WAHO,CAAlB;AAKD,GAZiB,CAAlB,CAvD2D,CAqE3D;AACA;;AACA,QAAM,YAAY,GAAW,EAA7B;AAEA,EAAA,SAAS,CAAC,OAAV,CAAmB,IAAD,IAAS;AACzB;AACA;AAEA,UAAM,aAAa,GAAG,KAAK,CACxB,MADmB,CACH,CAAC,IAAD,EAAO,IAAP,EAAa,CAAb,KAAkB;AACjC;AACA,UAAI,IAAI,KAAK,IAAb,EAAmB;AACjB,cAAM,iBAAiB,GAAG,qBAAqB,CAAC,IAAD,EAAO,SAAS,CAAC,CAAD,CAAhB,CAA/C;AACA,QAAA,IAAI,CAAC,IAAL,CAAU,GAAG,iBAAb;AACD;;AACD,aAAO,IAAP;AACD,KARmB,EAQjB,EARiB,EASnB,IATmB,CASd,CAAC,CAAD,EAAI,CAAJ,KAAU,WAAW,CAAC,IAAI,CAAC,KAAN,EAAa,CAAb,CAAX,GAA6B,WAAW,CAAC,IAAI,CAAC,KAAN,EAAa,CAAb,CATpC,CAAtB;;AAWA,QAAI,aAAa,CAAC,MAAd,GAAuB,CAA3B,EAA8B;AAC5B;AACA,MAAA,YAAY,CAAC,IAAb,CAAkB,GAAG,WAAW,CAAC,IAAD,EAAO,aAAP,EAAsB,QAAtB,CAAhC;AACD,KAHD,MAGO;AACL;AACA,MAAA,YAAY,CAAC,IAAb,CAAkB,IAAlB;AACD;AACF,GAtBD;AAwBA,QAAM,IAAI,GAAG,SAAS,CAAC,YAAD,EAAe,QAAf,EAAyB,QAAzB,EAAmC,MAAnC,CAAtB;AAEA,EAAA,YAAY,GAAG,EAAf;AACA,EAAA,aAAa,GAAG,EAAhB;AAEA,SAAO,OAAO,CAAC,GAAR,GAAc,IAAd,GAAqB,IAAI,CAAC,SAAL,EAA5B;AACD,CAxGI","sourceRoot":"","sourcesContent":["/* eslint-disable no-underscore-dangle */\nimport { Point, Line, Path } from '../../geometry';\n// takes care of math. error for case when jump is too close to end of line\nconst CLOSE_PROXIMITY_PADDING = 1;\nconst F13 = 1 / 3;\nconst F23 = 2 / 3;\nfunction setupUpdating(view) {\n    let updateList = view.graph._jumpOverUpdateList;\n    // first time setup for this paper\n    if (updateList == null) {\n        updateList = view.graph._jumpOverUpdateList = [];\n        /**\n         * Handler for a batch:stop event to force\n         * update of all registered links with jump over connector\n         */\n        view.graph.on('cell:mouseup', () => {\n            const list = view.graph._jumpOverUpdateList;\n            for (let i = 0; i < list.length; i += 1) {\n                list[i].update();\n            }\n        });\n        view.graph.on('model:reseted', () => {\n            updateList = view.graph._jumpOverUpdateList = [];\n        });\n    }\n    // add this link to a list so it can be updated when some other link is updated\n    if (updateList.indexOf(view) < 0) {\n        updateList.push(view);\n        // watch for change of connector type or removal of link itself\n        // to remove the link from a list of jump over connectors\n        const clean = () => updateList.splice(updateList.indexOf(view), 1);\n        view.cell.once('change:connector', clean);\n        view.cell.once('removed', clean);\n    }\n}\nfunction createLines(sourcePoint, targetPoint, route = []) {\n    const points = [sourcePoint, ...route, targetPoint];\n    const lines = [];\n    points.forEach((point, idx) => {\n        const next = points[idx + 1];\n        if (next != null) {\n            lines.push(new Line(point, next));\n        }\n    });\n    return lines;\n}\nfunction findLineIntersections(line, crossCheckLines) {\n    const intersections = [];\n    crossCheckLines.forEach((crossCheckLine) => {\n        const intersection = line.intersectsWithLine(crossCheckLine);\n        if (intersection) {\n            intersections.push(intersection);\n        }\n    });\n    return intersections;\n}\nfunction getDistence(p1, p2) {\n    return new Line(p1, p2).squaredLength();\n}\n/**\n * Split input line into multiple based on intersection points.\n */\nfunction createJumps(line, intersections, jumpSize) {\n    return intersections.reduce((memo, point, idx) => {\n        // skipping points that were merged with the previous line\n        // to make bigger arc over multiple lines that are close to each other\n        if (skippedPoints.includes(point)) {\n            return memo;\n        }\n        // always grab the last line from buffer and modify it\n        const lastLine = memo.pop() || line;\n        // calculate start and end of jump by moving by a given size of jump\n        const jumpStart = Point.create(point).move(lastLine.start, -jumpSize);\n        let jumpEnd = Point.create(point).move(lastLine.start, +jumpSize);\n        // now try to look at the next intersection point\n        const nextPoint = intersections[idx + 1];\n        if (nextPoint != null) {\n            const distance = jumpEnd.distance(nextPoint);\n            if (distance <= jumpSize) {\n                // next point is close enough, move the jump end by this\n                // difference and mark the next point to be skipped\n                jumpEnd = nextPoint.move(lastLine.start, distance);\n                skippedPoints.push(nextPoint);\n            }\n        }\n        else {\n            // this block is inside of `else` as an optimization so the distance is\n            // not calculated when we know there are no other intersection points\n            const endDistance = jumpStart.distance(lastLine.end);\n            // if the end is too close to possible jump, draw remaining line instead of a jump\n            if (endDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n                memo.push(lastLine);\n                return memo;\n            }\n        }\n        const startDistance = jumpEnd.distance(lastLine.start);\n        if (startDistance < jumpSize * 2 + CLOSE_PROXIMITY_PADDING) {\n            // if the start of line is too close to jump, draw that line instead of a jump\n            memo.push(lastLine);\n            return memo;\n        }\n        // finally create a jump line\n        const jumpLine = new Line(jumpStart, jumpEnd);\n        // it's just simple line but with a `isJump` property\n        jumppedLines.push(jumpLine);\n        memo.push(new Line(lastLine.start, jumpStart), jumpLine, new Line(jumpEnd, lastLine.end));\n        return memo;\n    }, []);\n}\nfunction buildPath(lines, jumpSize, jumpType, radius) {\n    const path = new Path();\n    let segment;\n    // first move to the start of a first line\n    segment = Path.createSegment('M', lines[0].start);\n    path.appendSegment(segment);\n    lines.forEach((line, index) => {\n        if (jumppedLines.includes(line)) {\n            let angle;\n            let diff;\n            let control1;\n            let control2;\n            if (jumpType === 'arc') {\n                // approximates semicircle with 2 curves\n                angle = -90;\n                // determine rotation of arc based on difference between points\n                diff = line.start.diff(line.end);\n                // make sure the arc always points up (or right)\n                const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0);\n                if (xAxisRotate) {\n                    angle += 180;\n                }\n                const center = line.getCenter();\n                const centerLine = new Line(center, line.end).rotate(angle, center);\n                let halfLine;\n                // first half\n                halfLine = new Line(line.start, center);\n                control1 = halfLine.pointAt(2 / 3).rotate(angle, line.start);\n                control2 = centerLine.pointAt(1 / 3).rotate(-angle, centerLine.end);\n                segment = Path.createSegment('C', control1, control2, centerLine.end);\n                path.appendSegment(segment);\n                // second half\n                halfLine = new Line(center, line.end);\n                control1 = centerLine.pointAt(1 / 3).rotate(angle, centerLine.end);\n                control2 = halfLine.pointAt(1 / 3).rotate(-angle, line.end);\n                segment = Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n            else if (jumpType === 'gap') {\n                segment = Path.createSegment('M', line.end);\n                path.appendSegment(segment);\n            }\n            else if (jumpType === 'cubic') {\n                // approximates semicircle with 1 curve\n                angle = line.start.theta(line.end);\n                const xOffset = jumpSize * 0.6;\n                let yOffset = jumpSize * 1.35;\n                // determine rotation of arc based on difference between points\n                diff = line.start.diff(line.end);\n                // make sure the arc always points up (or right)\n                const xAxisRotate = diff.x < 0 || (diff.x === 0 && diff.y < 0);\n                if (xAxisRotate) {\n                    yOffset *= -1;\n                }\n                control1 = new Point(line.start.x + xOffset, line.start.y + yOffset).rotate(angle, line.start);\n                control2 = new Point(line.end.x - xOffset, line.end.y + yOffset).rotate(angle, line.end);\n                segment = Path.createSegment('C', control1, control2, line.end);\n                path.appendSegment(segment);\n            }\n        }\n        else {\n            const nextLine = lines[index + 1];\n            if (radius === 0 || !nextLine || jumppedLines.includes(nextLine)) {\n                segment = Path.createSegment('L', line.end);\n                path.appendSegment(segment);\n            }\n            else {\n                buildRoundedSegment(radius, path, line.end, line.start, nextLine.end);\n            }\n        }\n    });\n    return path;\n}\nfunction buildRoundedSegment(offset, path, curr, prev, next) {\n    const prevDistance = curr.distance(prev) / 2;\n    const nextDistance = curr.distance(next) / 2;\n    const startMove = -Math.min(offset, prevDistance);\n    const endMove = -Math.min(offset, nextDistance);\n    const roundedStart = curr.clone().move(prev, startMove).round();\n    const roundedEnd = curr.clone().move(next, endMove).round();\n    const control1 = new Point(F13 * roundedStart.x + F23 * curr.x, F23 * curr.y + F13 * roundedStart.y);\n    const control2 = new Point(F13 * roundedEnd.x + F23 * curr.x, F23 * curr.y + F13 * roundedEnd.y);\n    let segment;\n    segment = Path.createSegment('L', roundedStart);\n    path.appendSegment(segment);\n    segment = Path.createSegment('C', control1, control2, roundedEnd);\n    path.appendSegment(segment);\n}\nlet jumppedLines;\nlet skippedPoints;\nexport const jumpover = function (sourcePoint, targetPoint, routePoints, options = {}) {\n    jumppedLines = [];\n    skippedPoints = [];\n    setupUpdating(this);\n    const jumpSize = options.size || 5;\n    const jumpType = options.type || 'arc';\n    const radius = options.radius || 0;\n    // list of connector types not to jump over.\n    const ignoreConnectors = options.ignoreConnectors || ['smooth'];\n    const graph = this.graph;\n    const model = graph.model;\n    const allLinks = model.getEdges();\n    // there is just one link, draw it directly\n    if (allLinks.length === 1) {\n        return buildPath(createLines(sourcePoint, targetPoint, routePoints), jumpSize, jumpType, radius);\n    }\n    const edge = this.cell;\n    const thisIndex = allLinks.indexOf(edge);\n    const defaultConnector = graph.options.connecting.connector || {};\n    // not all links are meant to be jumped over.\n    const edges = allLinks.filter((link, idx) => {\n        const connector = link.getConnector() || defaultConnector;\n        // avoid jumping over links with connector type listed in `ignored connectors`.\n        if (ignoreConnectors.includes(connector.name)) {\n            return false;\n        }\n        // filter out links that are above this one and  have the same connector type\n        // otherwise there would double hoops for each intersection\n        if (idx > thisIndex) {\n            return connector.name !== 'jumpover';\n        }\n        return true;\n    });\n    // find views for all links\n    const linkViews = edges.map((edge) => {\n        return graph.renderer.findViewByCell(edge);\n    });\n    // create lines for this link\n    const thisLines = createLines(sourcePoint, targetPoint, routePoints);\n    // create lines for all other links\n    const linkLines = linkViews.map((linkView) => {\n        if (linkView == null) {\n            return [];\n        }\n        if (linkView === this) {\n            return thisLines;\n        }\n        return createLines(linkView.sourcePoint, linkView.targetPoint, linkView.routePoints);\n    });\n    // transform lines for this link by splitting with jump lines at\n    // points of intersection with other links\n    const jumpingLines = [];\n    thisLines.forEach((line) => {\n        // iterate all links and grab the intersections with this line\n        // these are then sorted by distance so the line can be split more easily\n        const intersections = edges\n            .reduce((memo, link, i) => {\n            // don't intersection with itself\n            if (link !== edge) {\n                const lineIntersections = findLineIntersections(line, linkLines[i]);\n                memo.push(...lineIntersections);\n            }\n            return memo;\n        }, [])\n            .sort((a, b) => getDistence(line.start, a) - getDistence(line.start, b));\n        if (intersections.length > 0) {\n            // split the line based on found intersection points\n            jumpingLines.push(...createJumps(line, intersections, jumpSize));\n        }\n        else {\n            // without any intersection the line goes uninterrupted\n            jumpingLines.push(line);\n        }\n    });\n    const path = buildPath(jumpingLines, jumpSize, jumpType, radius);\n    jumppedLines = [];\n    skippedPoints = [];\n    return options.raw ? path : path.serialize();\n};\n//# sourceMappingURL=jumpover.js.map"]},"metadata":{},"sourceType":"module"}