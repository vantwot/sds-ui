{"ast":null,"code":"import _defineProperty from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { ObjectExt, ArrayExt, Dom, FunctionExt, StringExt, Scheduler } from '../util';\nimport { Point } from '../geometry';\nimport { Dictionary } from '../common';\nimport { Attr } from '../registry/attr';\nimport { View } from './view';\nexport var AttrManager = /*#__PURE__*/function () {\n  function AttrManager(view) {\n    _classCallCheck(this, AttrManager);\n\n    this.view = view;\n  }\n\n  _createClass(AttrManager, [{\n    key: \"cell\",\n    get: function get() {\n      return this.view.cell;\n    }\n  }, {\n    key: \"getDefinition\",\n    value: function getDefinition(attrName) {\n      return this.cell.getAttrDefinition(attrName);\n    }\n  }, {\n    key: \"processAttrs\",\n    value: function processAttrs(elem, raw) {\n      var _this = this;\n\n      var normal;\n      var set;\n      var offset;\n      var position;\n      var delay;\n      var specials = []; // divide the attributes between normal and special\n\n      Object.keys(raw).forEach(function (name) {\n        var val = raw[name];\n\n        var definition = _this.getDefinition(name);\n\n        var isValid = FunctionExt.call(Attr.isValidDefinition, _this.view, definition, val, {\n          elem: elem,\n          attrs: raw,\n          cell: _this.cell,\n          view: _this.view\n        });\n\n        if (definition && isValid) {\n          if (typeof definition === 'string') {\n            if (normal == null) {\n              normal = {};\n            }\n\n            normal[definition] = val;\n          } else if (val !== null) {\n            specials.push({\n              name: name,\n              definition: definition\n            });\n          }\n        } else {\n          if (normal == null) {\n            normal = {};\n          }\n\n          var normalName = AttrManager.CASE_SENSITIVE_ATTR.includes(name) ? name : StringExt.kebabCase(name);\n          normal[normalName] = val;\n        }\n      });\n      specials.forEach(function (_ref) {\n        var name = _ref.name,\n            definition = _ref.definition;\n        var val = raw[name];\n        var setDefine = definition;\n\n        if (typeof setDefine.set === 'function') {\n          if (!Dom.isHTMLElement(elem) && AttrManager.DELAY_ATTRS.includes(name)) {\n            if (delay == null) {\n              delay = {};\n            }\n\n            delay[name] = val;\n          } else {\n            if (set == null) {\n              set = {};\n            }\n\n            set[name] = val;\n          }\n        }\n\n        var offsetDefine = definition;\n\n        if (typeof offsetDefine.offset === 'function') {\n          if (offset == null) {\n            offset = {};\n          }\n\n          offset[name] = val;\n        }\n\n        var positionDefine = definition;\n\n        if (typeof positionDefine.position === 'function') {\n          if (position == null) {\n            position = {};\n          }\n\n          position[name] = val;\n        }\n      });\n      return {\n        raw: raw,\n        normal: normal,\n        set: set,\n        offset: offset,\n        position: position,\n        delay: delay\n      };\n    }\n  }, {\n    key: \"mergeProcessedAttrs\",\n    value: function mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {\n      allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);\n      allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);\n      allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset); // Handle also the special transform property.\n\n      var transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;\n\n      if (transform != null && roProcessedAttrs.normal) {\n        roProcessedAttrs.normal.transform = transform;\n      }\n\n      allProcessedAttrs.normal = roProcessedAttrs.normal;\n    }\n  }, {\n    key: \"findAttrs\",\n    value: function findAttrs(cellAttrs, rootNode, selectorCache, selectors) {\n      var merge = [];\n      var result = new Dictionary();\n      Object.keys(cellAttrs).forEach(function (selector) {\n        var attrs = cellAttrs[selector];\n\n        if (!ObjectExt.isPlainObject(attrs)) {\n          return;\n        }\n\n        var _View$find = View.find(selector, rootNode, selectors),\n            isCSSSelector = _View$find.isCSSSelector,\n            elems = _View$find.elems;\n\n        selectorCache[selector] = elems;\n\n        for (var i = 0, l = elems.length; i < l; i += 1) {\n          var elem = elems[i];\n          var unique = selectors && selectors[selector] === elem;\n          var prev = result.get(elem);\n\n          if (prev) {\n            if (!prev.array) {\n              merge.push(elem);\n              prev.array = true;\n              prev.attrs = [prev.attrs];\n              prev.priority = [prev.priority];\n            }\n\n            var attributes = prev.attrs;\n            var selectedLength = prev.priority;\n\n            if (unique) {\n              // node referenced by `selector`\n              attributes.unshift(attrs);\n              selectedLength.unshift(-1);\n            } else {\n              // node referenced by `groupSelector` or CSSSelector\n              var sortIndex = ArrayExt.sortedIndex(selectedLength, isCSSSelector ? -1 : l);\n              attributes.splice(sortIndex, 0, attrs);\n              selectedLength.splice(sortIndex, 0, l);\n            }\n          } else {\n            result.set(elem, {\n              elem: elem,\n              attrs: attrs,\n              priority: unique ? -1 : l,\n              array: false\n            });\n          }\n        }\n      });\n      merge.forEach(function (node) {\n        var item = result.get(node);\n        var arr = item.attrs;\n        item.attrs = arr.reduceRight(function (memo, attrs) {\n          return ObjectExt.merge(memo, attrs);\n        }, {});\n      });\n      return result;\n    }\n  }, {\n    key: \"updateRelativeAttrs\",\n    value: function updateRelativeAttrs(elem, processedAttrs, refBBox, options) {\n      var _this2 = this;\n\n      var rawAttrs = processedAttrs.raw || {};\n      var nodeAttrs = processedAttrs.normal || {};\n      var setAttrs = processedAttrs.set;\n      var positionAttrs = processedAttrs.position;\n      var offsetAttrs = processedAttrs.offset;\n      var delayAttrs = processedAttrs.delay;\n\n      var getOptions = function getOptions() {\n        return {\n          elem: elem,\n          cell: _this2.cell,\n          view: _this2.view,\n          attrs: rawAttrs,\n          refBBox: refBBox.clone()\n        };\n      };\n\n      if (setAttrs != null) {\n        Object.keys(setAttrs).forEach(function (name) {\n          var val = setAttrs[name];\n\n          var def = _this2.getDefinition(name);\n\n          if (def != null) {\n            var ret = FunctionExt.call(def.set, _this2.view, val, getOptions());\n\n            if (typeof ret === 'object') {\n              nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);\n            } else if (ret != null) {\n              nodeAttrs[name] = ret;\n            }\n          }\n        });\n      }\n\n      if (Dom.isHTMLElement(elem)) {\n        // TODO: setting the `transform` attribute on HTMLElements\n        // via `node.style.transform = 'matrix(...)';` would introduce\n        // a breaking change (e.g. basic.TextBlock).\n        this.view.setAttrs(nodeAttrs, elem);\n        return;\n      } // The final translation of the subelement.\n\n\n      var nodeTransform = nodeAttrs.transform;\n      var transform = nodeTransform ? \"\".concat(nodeTransform) : null;\n      var nodeMatrix = Dom.transformStringToMatrix(transform);\n      var nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);\n\n      if (nodeTransform) {\n        delete nodeAttrs.transform;\n        nodeMatrix.e = 0;\n        nodeMatrix.f = 0;\n      } // Calculates node scale determined by the scalable group.\n\n\n      var sx = 1;\n      var sy = 1;\n\n      if (positionAttrs || offsetAttrs) {\n        var scale = this.view.getScaleOfElement(elem, options.scalableNode);\n        sx = scale.sx;\n        sy = scale.sy;\n      }\n\n      var positioned = false;\n\n      if (positionAttrs != null) {\n        Object.keys(positionAttrs).forEach(function (name) {\n          var val = positionAttrs[name];\n\n          var def = _this2.getDefinition(name);\n\n          if (def != null) {\n            var ts = FunctionExt.call(def.position, _this2.view, val, getOptions());\n\n            if (ts != null) {\n              positioned = true;\n              nodePosition.translate(Point.create(ts).scale(sx, sy));\n            }\n          }\n        });\n      } // The node bounding box could depend on the `size`\n      // set from the previous loop.\n\n\n      this.view.setAttrs(nodeAttrs, elem);\n      var offseted = false;\n\n      if (offsetAttrs != null) {\n        // Check if the node is visible\n        var nodeBoundingRect = this.view.getBoundingRectOfElement(elem);\n\n        if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n          var nodeBBox = Dom.transformRectangle(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n          Object.keys(offsetAttrs).forEach(function (name) {\n            var val = offsetAttrs[name];\n\n            var def = _this2.getDefinition(name);\n\n            if (def != null) {\n              var ts = FunctionExt.call(def.offset, _this2.view, val, {\n                elem: elem,\n                cell: _this2.cell,\n                view: _this2.view,\n                attrs: rawAttrs,\n                refBBox: nodeBBox\n              });\n\n              if (ts != null) {\n                offseted = true;\n                nodePosition.translate(Point.create(ts).scale(sx, sy));\n              }\n            }\n          });\n        }\n      }\n\n      if (nodeTransform != null || positioned || offseted) {\n        nodePosition.round(1);\n        nodeMatrix.e = nodePosition.x;\n        nodeMatrix.f = nodePosition.y;\n        elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix));\n      } // delay render\n\n\n      var updateDelayAttrs = function updateDelayAttrs() {\n        if (delayAttrs != null) {\n          Object.keys(delayAttrs).forEach(function (name) {\n            var val = delayAttrs[name];\n\n            var def = _this2.getDefinition(name);\n\n            if (def != null) {\n              var ret = FunctionExt.call(def.set, _this2.view, val, getOptions());\n\n              if (typeof ret === 'object') {\n                _this2.view.setAttrs(ret, elem);\n              } else if (ret != null) {\n                _this2.view.setAttrs(_defineProperty({}, name, ret), elem);\n              }\n            }\n          });\n        }\n      };\n\n      if (options.forceSync) {\n        updateDelayAttrs();\n      } else {\n        Scheduler.scheduleTask(updateDelayAttrs);\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update(rootNode, attrs, options) {\n      var _this3 = this;\n\n      var selectorCache = {};\n      var nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors); // `nodesAttrs` are different from all attributes, when\n      // rendering only attributes sent to this method.\n\n      var nodesAllAttrs = options.attrs ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors) : nodesAttrs;\n      var specialItems = [];\n      nodesAttrs.each(function (data) {\n        var node = data.elem;\n        var nodeAttrs = data.attrs;\n\n        var processed = _this3.processAttrs(node, nodeAttrs);\n\n        if (processed.set == null && processed.position == null && processed.offset == null && processed.delay == null) {\n          _this3.view.setAttrs(processed.normal, node);\n        } else {\n          var _data = nodesAllAttrs.get(node);\n\n          var nodeAllAttrs = _data ? _data.attrs : null;\n          var refSelector = nodeAllAttrs && nodeAttrs.ref == null ? nodeAllAttrs.ref : nodeAttrs.ref;\n          var refNode;\n\n          if (refSelector) {\n            refNode = (selectorCache[refSelector] || _this3.view.find(refSelector, rootNode, options.selectors))[0];\n\n            if (!refNode) {\n              throw new Error(\"\\\"\".concat(refSelector, \"\\\" reference does not exist.\"));\n            }\n          } else {\n            refNode = null;\n          }\n\n          var item = {\n            node: node,\n            refNode: refNode,\n            attributes: nodeAllAttrs,\n            processedAttributes: processed\n          }; // If an element in the list is positioned relative to this one, then\n          // we want to insert this one before it in the list.\n\n          var index = specialItems.findIndex(function (item) {\n            return item.refNode === node;\n          });\n\n          if (index > -1) {\n            specialItems.splice(index, 0, item);\n          } else {\n            specialItems.push(item);\n          }\n        }\n      });\n      var bboxCache = new Dictionary();\n      var rotatableMatrix;\n      specialItems.forEach(function (item) {\n        var node = item.node;\n        var refNode = item.refNode;\n        var unrotatedRefBBox;\n        var isRefNodeRotatable = refNode != null && options.rotatableNode != null && Dom.contains(options.rotatableNode, refNode); // Find the reference element bounding box. If no reference was\n        // provided, we use the optional bounding box.\n\n        if (refNode) {\n          unrotatedRefBBox = bboxCache.get(refNode);\n        }\n\n        if (!unrotatedRefBBox) {\n          var target = isRefNodeRotatable ? options.rotatableNode : rootNode;\n          unrotatedRefBBox = refNode ? Dom.getBBox(refNode, {\n            target: target\n          }) : options.rootBBox;\n\n          if (refNode) {\n            bboxCache.set(refNode, unrotatedRefBBox);\n          }\n        }\n\n        var processedAttrs;\n\n        if (options.attrs && item.attributes) {\n          // If there was a special attribute affecting the position amongst\n          // passed-in attributes we have to merge it with the rest of the\n          // element's attributes as they are necessary to update the position\n          // relatively (i.e `ref-x` && 'ref-dx').\n          processedAttrs = _this3.processAttrs(node, item.attributes);\n\n          _this3.mergeProcessedAttrs(processedAttrs, item.processedAttributes);\n        } else {\n          processedAttrs = item.processedAttributes;\n        }\n\n        var refBBox = unrotatedRefBBox;\n\n        if (isRefNodeRotatable && options.rotatableNode != null && !options.rotatableNode.contains(node)) {\n          // If the referenced node is inside the rotatable group while the\n          // updated node is outside, we need to take the rotatable node\n          // transformation into account.\n          if (!rotatableMatrix) {\n            rotatableMatrix = Dom.transformStringToMatrix(Dom.attr(options.rotatableNode, 'transform'));\n          }\n\n          refBBox = Dom.transformRectangle(unrotatedRefBBox, rotatableMatrix);\n        }\n\n        var caller = specialItems.find(function (item) {\n          return item.refNode === node;\n        });\n\n        if (caller) {\n          options.forceSync = true;\n        }\n\n        _this3.updateRelativeAttrs(node, processedAttrs, refBBox, options);\n      });\n    }\n  }]);\n\n  return AttrManager;\n}();\n\n(function (AttrManager) {\n  AttrManager.CASE_SENSITIVE_ATTR = ['viewBox'];\n  AttrManager.DELAY_ATTRS = ['text', 'textWrap', 'sourceMarker', 'targetMarker'];\n})(AttrManager || (AttrManager = {}));","map":{"version":3,"sources":["../../src/view/attr.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ObjectExt, ArrayExt, Dom, FunctionExt, StringExt, Scheduler, } from '../util';\nimport { Point } from '../geometry';\nimport { Dictionary } from '../common';\nimport { Attr } from '../registry/attr';\nimport { View } from './view';\nexport class AttrManager {\n    constructor(view) {\n        this.view = view;\n    }\n    get cell() {\n        return this.view.cell;\n    }\n    getDefinition(attrName) {\n        return this.cell.getAttrDefinition(attrName);\n    }\n    processAttrs(elem, raw) {\n        let normal;\n        let set;\n        let offset;\n        let position;\n        let delay;\n        const specials = [];\n        // divide the attributes between normal and special\n        Object.keys(raw).forEach((name) => {\n            const val = raw[name];\n            const definition = this.getDefinition(name);\n            const isValid = FunctionExt.call(Attr.isValidDefinition, this.view, definition, val, {\n                elem,\n                attrs: raw,\n                cell: this.cell,\n                view: this.view,\n            });\n            if (definition && isValid) {\n                if (typeof definition === 'string') {\n                    if (normal == null) {\n                        normal = {};\n                    }\n                    normal[definition] = val;\n                }\n                else if (val !== null) {\n                    specials.push({ name, definition });\n                }\n            }\n            else {\n                if (normal == null) {\n                    normal = {};\n                }\n                const normalName = AttrManager.CASE_SENSITIVE_ATTR.includes(name)\n                    ? name\n                    : StringExt.kebabCase(name);\n                normal[normalName] = val;\n            }\n        });\n        specials.forEach(({ name, definition }) => {\n            const val = raw[name];\n            const setDefine = definition;\n            if (typeof setDefine.set === 'function') {\n                if (!Dom.isHTMLElement(elem) &&\n                    AttrManager.DELAY_ATTRS.includes(name)) {\n                    if (delay == null) {\n                        delay = {};\n                    }\n                    delay[name] = val;\n                }\n                else {\n                    if (set == null) {\n                        set = {};\n                    }\n                    set[name] = val;\n                }\n            }\n            const offsetDefine = definition;\n            if (typeof offsetDefine.offset === 'function') {\n                if (offset == null) {\n                    offset = {};\n                }\n                offset[name] = val;\n            }\n            const positionDefine = definition;\n            if (typeof positionDefine.position === 'function') {\n                if (position == null) {\n                    position = {};\n                }\n                position[name] = val;\n            }\n        });\n        return {\n            raw,\n            normal,\n            set,\n            offset,\n            position,\n            delay,\n        };\n    }\n    mergeProcessedAttrs(allProcessedAttrs, roProcessedAttrs) {\n        allProcessedAttrs.set = Object.assign(Object.assign({}, allProcessedAttrs.set), roProcessedAttrs.set);\n        allProcessedAttrs.position = Object.assign(Object.assign({}, allProcessedAttrs.position), roProcessedAttrs.position);\n        allProcessedAttrs.offset = Object.assign(Object.assign({}, allProcessedAttrs.offset), roProcessedAttrs.offset);\n        // Handle also the special transform property.\n        const transform = allProcessedAttrs.normal && allProcessedAttrs.normal.transform;\n        if (transform != null && roProcessedAttrs.normal) {\n            roProcessedAttrs.normal.transform = transform;\n        }\n        allProcessedAttrs.normal = roProcessedAttrs.normal;\n    }\n    findAttrs(cellAttrs, rootNode, selectorCache, selectors) {\n        const merge = [];\n        const result = new Dictionary();\n        Object.keys(cellAttrs).forEach((selector) => {\n            const attrs = cellAttrs[selector];\n            if (!ObjectExt.isPlainObject(attrs)) {\n                return;\n            }\n            const { isCSSSelector, elems } = View.find(selector, rootNode, selectors);\n            selectorCache[selector] = elems;\n            for (let i = 0, l = elems.length; i < l; i += 1) {\n                const elem = elems[i];\n                const unique = selectors && selectors[selector] === elem;\n                const prev = result.get(elem);\n                if (prev) {\n                    if (!prev.array) {\n                        merge.push(elem);\n                        prev.array = true;\n                        prev.attrs = [prev.attrs];\n                        prev.priority = [prev.priority];\n                    }\n                    const attributes = prev.attrs;\n                    const selectedLength = prev.priority;\n                    if (unique) {\n                        // node referenced by `selector`\n                        attributes.unshift(attrs);\n                        selectedLength.unshift(-1);\n                    }\n                    else {\n                        // node referenced by `groupSelector` or CSSSelector\n                        const sortIndex = ArrayExt.sortedIndex(selectedLength, isCSSSelector ? -1 : l);\n                        attributes.splice(sortIndex, 0, attrs);\n                        selectedLength.splice(sortIndex, 0, l);\n                    }\n                }\n                else {\n                    result.set(elem, {\n                        elem,\n                        attrs,\n                        priority: unique ? -1 : l,\n                        array: false,\n                    });\n                }\n            }\n        });\n        merge.forEach((node) => {\n            const item = result.get(node);\n            const arr = item.attrs;\n            item.attrs = arr.reduceRight((memo, attrs) => ObjectExt.merge(memo, attrs), {});\n        });\n        return result;\n    }\n    updateRelativeAttrs(elem, processedAttrs, refBBox, options) {\n        const rawAttrs = processedAttrs.raw || {};\n        let nodeAttrs = processedAttrs.normal || {};\n        const setAttrs = processedAttrs.set;\n        const positionAttrs = processedAttrs.position;\n        const offsetAttrs = processedAttrs.offset;\n        const delayAttrs = processedAttrs.delay;\n        const getOptions = () => ({\n            elem,\n            cell: this.cell,\n            view: this.view,\n            attrs: rawAttrs,\n            refBBox: refBBox.clone(),\n        });\n        if (setAttrs != null) {\n            Object.keys(setAttrs).forEach((name) => {\n                const val = setAttrs[name];\n                const def = this.getDefinition(name);\n                if (def != null) {\n                    const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n                    if (typeof ret === 'object') {\n                        nodeAttrs = Object.assign(Object.assign({}, nodeAttrs), ret);\n                    }\n                    else if (ret != null) {\n                        nodeAttrs[name] = ret;\n                    }\n                }\n            });\n        }\n        if (Dom.isHTMLElement(elem)) {\n            // TODO: setting the `transform` attribute on HTMLElements\n            // via `node.style.transform = 'matrix(...)';` would introduce\n            // a breaking change (e.g. basic.TextBlock).\n            this.view.setAttrs(nodeAttrs, elem);\n            return;\n        }\n        // The final translation of the subelement.\n        const nodeTransform = nodeAttrs.transform;\n        const transform = nodeTransform ? `${nodeTransform}` : null;\n        const nodeMatrix = Dom.transformStringToMatrix(transform);\n        const nodePosition = new Point(nodeMatrix.e, nodeMatrix.f);\n        if (nodeTransform) {\n            delete nodeAttrs.transform;\n            nodeMatrix.e = 0;\n            nodeMatrix.f = 0;\n        }\n        // Calculates node scale determined by the scalable group.\n        let sx = 1;\n        let sy = 1;\n        if (positionAttrs || offsetAttrs) {\n            const scale = this.view.getScaleOfElement(elem, options.scalableNode);\n            sx = scale.sx;\n            sy = scale.sy;\n        }\n        let positioned = false;\n        if (positionAttrs != null) {\n            Object.keys(positionAttrs).forEach((name) => {\n                const val = positionAttrs[name];\n                const def = this.getDefinition(name);\n                if (def != null) {\n                    const ts = FunctionExt.call(def.position, this.view, val, getOptions());\n                    if (ts != null) {\n                        positioned = true;\n                        nodePosition.translate(Point.create(ts).scale(sx, sy));\n                    }\n                }\n            });\n        }\n        // The node bounding box could depend on the `size`\n        // set from the previous loop.\n        this.view.setAttrs(nodeAttrs, elem);\n        let offseted = false;\n        if (offsetAttrs != null) {\n            // Check if the node is visible\n            const nodeBoundingRect = this.view.getBoundingRectOfElement(elem);\n            if (nodeBoundingRect.width > 0 && nodeBoundingRect.height > 0) {\n                const nodeBBox = Dom.transformRectangle(nodeBoundingRect, nodeMatrix).scale(1 / sx, 1 / sy);\n                Object.keys(offsetAttrs).forEach((name) => {\n                    const val = offsetAttrs[name];\n                    const def = this.getDefinition(name);\n                    if (def != null) {\n                        const ts = FunctionExt.call(def.offset, this.view, val, {\n                            elem,\n                            cell: this.cell,\n                            view: this.view,\n                            attrs: rawAttrs,\n                            refBBox: nodeBBox,\n                        });\n                        if (ts != null) {\n                            offseted = true;\n                            nodePosition.translate(Point.create(ts).scale(sx, sy));\n                        }\n                    }\n                });\n            }\n        }\n        if (nodeTransform != null || positioned || offseted) {\n            nodePosition.round(1);\n            nodeMatrix.e = nodePosition.x;\n            nodeMatrix.f = nodePosition.y;\n            elem.setAttribute('transform', Dom.matrixToTransformString(nodeMatrix));\n        }\n        // delay render\n        const updateDelayAttrs = () => {\n            if (delayAttrs != null) {\n                Object.keys(delayAttrs).forEach((name) => {\n                    const val = delayAttrs[name];\n                    const def = this.getDefinition(name);\n                    if (def != null) {\n                        const ret = FunctionExt.call(def.set, this.view, val, getOptions());\n                        if (typeof ret === 'object') {\n                            this.view.setAttrs(ret, elem);\n                        }\n                        else if (ret != null) {\n                            this.view.setAttrs({\n                                [name]: ret,\n                            }, elem);\n                        }\n                    }\n                });\n            }\n        };\n        if (options.forceSync) {\n            updateDelayAttrs();\n        }\n        else {\n            Scheduler.scheduleTask(updateDelayAttrs);\n        }\n    }\n    update(rootNode, attrs, options) {\n        const selectorCache = {};\n        const nodesAttrs = this.findAttrs(options.attrs || attrs, rootNode, selectorCache, options.selectors);\n        // `nodesAttrs` are different from all attributes, when\n        // rendering only attributes sent to this method.\n        const nodesAllAttrs = options.attrs\n            ? this.findAttrs(attrs, rootNode, selectorCache, options.selectors)\n            : nodesAttrs;\n        const specialItems = [];\n        nodesAttrs.each((data) => {\n            const node = data.elem;\n            const nodeAttrs = data.attrs;\n            const processed = this.processAttrs(node, nodeAttrs);\n            if (processed.set == null &&\n                processed.position == null &&\n                processed.offset == null &&\n                processed.delay == null) {\n                this.view.setAttrs(processed.normal, node);\n            }\n            else {\n                const data = nodesAllAttrs.get(node);\n                const nodeAllAttrs = data ? data.attrs : null;\n                const refSelector = nodeAllAttrs && nodeAttrs.ref == null\n                    ? nodeAllAttrs.ref\n                    : nodeAttrs.ref;\n                let refNode;\n                if (refSelector) {\n                    refNode = (selectorCache[refSelector] ||\n                        this.view.find(refSelector, rootNode, options.selectors))[0];\n                    if (!refNode) {\n                        throw new Error(`\"${refSelector}\" reference does not exist.`);\n                    }\n                }\n                else {\n                    refNode = null;\n                }\n                const item = {\n                    node,\n                    refNode,\n                    attributes: nodeAllAttrs,\n                    processedAttributes: processed,\n                };\n                // If an element in the list is positioned relative to this one, then\n                // we want to insert this one before it in the list.\n                const index = specialItems.findIndex((item) => item.refNode === node);\n                if (index > -1) {\n                    specialItems.splice(index, 0, item);\n                }\n                else {\n                    specialItems.push(item);\n                }\n            }\n        });\n        const bboxCache = new Dictionary();\n        let rotatableMatrix;\n        specialItems.forEach((item) => {\n            const node = item.node;\n            const refNode = item.refNode;\n            let unrotatedRefBBox;\n            const isRefNodeRotatable = refNode != null &&\n                options.rotatableNode != null &&\n                Dom.contains(options.rotatableNode, refNode);\n            // Find the reference element bounding box. If no reference was\n            // provided, we use the optional bounding box.\n            if (refNode) {\n                unrotatedRefBBox = bboxCache.get(refNode);\n            }\n            if (!unrotatedRefBBox) {\n                const target = (isRefNodeRotatable ? options.rotatableNode : rootNode);\n                unrotatedRefBBox = refNode\n                    ? Dom.getBBox(refNode, { target })\n                    : options.rootBBox;\n                if (refNode) {\n                    bboxCache.set(refNode, unrotatedRefBBox);\n                }\n            }\n            let processedAttrs;\n            if (options.attrs && item.attributes) {\n                // If there was a special attribute affecting the position amongst\n                // passed-in attributes we have to merge it with the rest of the\n                // element's attributes as they are necessary to update the position\n                // relatively (i.e `ref-x` && 'ref-dx').\n                processedAttrs = this.processAttrs(node, item.attributes);\n                this.mergeProcessedAttrs(processedAttrs, item.processedAttributes);\n            }\n            else {\n                processedAttrs = item.processedAttributes;\n            }\n            let refBBox = unrotatedRefBBox;\n            if (isRefNodeRotatable &&\n                options.rotatableNode != null &&\n                !options.rotatableNode.contains(node)) {\n                // If the referenced node is inside the rotatable group while the\n                // updated node is outside, we need to take the rotatable node\n                // transformation into account.\n                if (!rotatableMatrix) {\n                    rotatableMatrix = Dom.transformStringToMatrix(Dom.attr(options.rotatableNode, 'transform'));\n                }\n                refBBox = Dom.transformRectangle(unrotatedRefBBox, rotatableMatrix);\n            }\n            const caller = specialItems.find((item) => item.refNode === node);\n            if (caller) {\n                options.forceSync = true;\n            }\n            this.updateRelativeAttrs(node, processedAttrs, refBBox, options);\n        });\n    }\n}\n(function (AttrManager) {\n    AttrManager.CASE_SENSITIVE_ATTR = ['viewBox'];\n    AttrManager.DELAY_ATTRS = [\n        'text',\n        'textWrap',\n        'sourceMarker',\n        'targetMarker',\n    ];\n})(AttrManager || (AttrManager = {}));\n//# sourceMappingURL=attr.js.map"]},"metadata":{},"sourceType":"module"}