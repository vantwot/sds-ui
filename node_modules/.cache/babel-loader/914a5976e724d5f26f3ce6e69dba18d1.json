{"ast":null,"code":"import { Line } from '../line';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport class LineTo extends Segment {\n  constructor(x, y) {\n    super();\n\n    if (Line.isLine(x)) {\n      this.endPoint = x.end.clone().round(2);\n    } else {\n      this.endPoint = Point.create(x, y).round(2);\n    }\n  }\n\n  get type() {\n    return 'L';\n  }\n\n  get line() {\n    return new Line(this.start, this.end);\n  }\n\n  bbox() {\n    return this.line.bbox();\n  }\n\n  closestPoint(p) {\n    return this.line.closestPoint(p);\n  }\n\n  closestPointLength(p) {\n    return this.line.closestPointLength(p);\n  }\n\n  closestPointNormalizedLength(p) {\n    return this.line.closestPointNormalizedLength(p);\n  }\n\n  closestPointTangent(p) {\n    return this.line.closestPointTangent(p);\n  }\n\n  length() {\n    return this.line.length();\n  }\n\n  divideAt(ratio) {\n    const divided = this.line.divideAt(ratio);\n    return [new LineTo(divided[0]), new LineTo(divided[1])];\n  }\n\n  divideAtLength(length) {\n    const divided = this.line.divideAtLength(length);\n    return [new LineTo(divided[0]), new LineTo(divided[1])];\n  }\n\n  getSubdivisions() {\n    return [];\n  }\n\n  pointAt(ratio) {\n    return this.line.pointAt(ratio);\n  }\n\n  pointAtLength(length) {\n    return this.line.pointAtLength(length);\n  }\n\n  tangentAt(ratio) {\n    return this.line.tangentAt(ratio);\n  }\n\n  tangentAtLength(length) {\n    return this.line.tangentAtLength(length);\n  }\n\n  isDifferentiable() {\n    if (this.previousSegment == null) {\n      return false;\n    }\n\n    return !this.start.equals(this.end);\n  }\n\n  clone() {\n    return new LineTo(this.end);\n  }\n\n  scale(sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.end.rotate(angle, origin);\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.end.translate(tx, ty);\n    } else {\n      this.end.translate(tx);\n    }\n\n    return this;\n  }\n\n  equals(s) {\n    return this.type === s.type && this.start.equals(s.start) && this.end.equals(s.end);\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n\n  serialize() {\n    const end = this.end;\n    return `${this.type} ${end.x} ${end.y}`;\n  }\n\n}\n\n(function (LineTo) {\n  function create() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    const len = args.length;\n    const arg0 = args[0]; // line provided\n\n    if (Line.isLine(arg0)) {\n      return new LineTo(arg0);\n    } // points provided\n\n\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new LineTo(arg0);\n      } // poly-line segment\n\n\n      return args.map(arg => new LineTo(arg));\n    } // coordinates provided\n\n\n    if (len === 2) {\n      return new LineTo(+args[0], +args[1]);\n    } // poly-line segment\n\n\n    const segments = [];\n\n    for (let i = 0; i < len; i += 2) {\n      const x = +args[i];\n      const y = +args[i + 1];\n      segments.push(new LineTo(x, y));\n    }\n\n    return segments;\n  }\n\n  LineTo.create = create;\n})(LineTo || (LineTo = {}));","map":{"version":3,"sources":["../../../src/geometry/path/lineto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Line } from '../line';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport class LineTo extends Segment {\n    constructor(x, y) {\n        super();\n        if (Line.isLine(x)) {\n            this.endPoint = x.end.clone().round(2);\n        }\n        else {\n            this.endPoint = Point.create(x, y).round(2);\n        }\n    }\n    get type() {\n        return 'L';\n    }\n    get line() {\n        return new Line(this.start, this.end);\n    }\n    bbox() {\n        return this.line.bbox();\n    }\n    closestPoint(p) {\n        return this.line.closestPoint(p);\n    }\n    closestPointLength(p) {\n        return this.line.closestPointLength(p);\n    }\n    closestPointNormalizedLength(p) {\n        return this.line.closestPointNormalizedLength(p);\n    }\n    closestPointTangent(p) {\n        return this.line.closestPointTangent(p);\n    }\n    length() {\n        return this.line.length();\n    }\n    divideAt(ratio) {\n        const divided = this.line.divideAt(ratio);\n        return [new LineTo(divided[0]), new LineTo(divided[1])];\n    }\n    divideAtLength(length) {\n        const divided = this.line.divideAtLength(length);\n        return [new LineTo(divided[0]), new LineTo(divided[1])];\n    }\n    getSubdivisions() {\n        return [];\n    }\n    pointAt(ratio) {\n        return this.line.pointAt(ratio);\n    }\n    pointAtLength(length) {\n        return this.line.pointAtLength(length);\n    }\n    tangentAt(ratio) {\n        return this.line.tangentAt(ratio);\n    }\n    tangentAtLength(length) {\n        return this.line.tangentAtLength(length);\n    }\n    isDifferentiable() {\n        if (this.previousSegment == null) {\n            return false;\n        }\n        return !this.start.equals(this.end);\n    }\n    clone() {\n        return new LineTo(this.end);\n    }\n    scale(sx, sy, origin) {\n        this.end.scale(sx, sy, origin);\n        return this;\n    }\n    rotate(angle, origin) {\n        this.end.rotate(angle, origin);\n        return this;\n    }\n    translate(tx, ty) {\n        if (typeof tx === 'number') {\n            this.end.translate(tx, ty);\n        }\n        else {\n            this.end.translate(tx);\n        }\n        return this;\n    }\n    equals(s) {\n        return (this.type === s.type &&\n            this.start.equals(s.start) &&\n            this.end.equals(s.end));\n    }\n    toJSON() {\n        return {\n            type: this.type,\n            start: this.start.toJSON(),\n            end: this.end.toJSON(),\n        };\n    }\n    serialize() {\n        const end = this.end;\n        return `${this.type} ${end.x} ${end.y}`;\n    }\n}\n(function (LineTo) {\n    function create(...args) {\n        const len = args.length;\n        const arg0 = args[0];\n        // line provided\n        if (Line.isLine(arg0)) {\n            return new LineTo(arg0);\n        }\n        // points provided\n        if (Point.isPointLike(arg0)) {\n            if (len === 1) {\n                return new LineTo(arg0);\n            }\n            // poly-line segment\n            return args.map((arg) => new LineTo(arg));\n        }\n        // coordinates provided\n        if (len === 2) {\n            return new LineTo(+args[0], +args[1]);\n        }\n        // poly-line segment\n        const segments = [];\n        for (let i = 0; i < len; i += 2) {\n            const x = +args[i];\n            const y = +args[i + 1];\n            segments.push(new LineTo(x, y));\n        }\n        return segments;\n    }\n    LineTo.create = create;\n})(LineTo || (LineTo = {}));\n//# sourceMappingURL=lineto.js.map"]},"metadata":{},"sourceType":"module"}