{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _util2 = require(\"./util\");\n\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n};\n\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (directed) relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);else relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  prevs[source] = [source]; // 每个节点存可能存在多条最短路径\n\n  var paths = {};\n\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  } // 兼容之前单路径\n\n\n  var path = {};\n\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\n\nvar _default = dijkstra;\nexports.default = _default;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n\n  var paths = [];\n\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if ((0, _util.isArray)(prePath)) paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath), [target]));else paths.push([prePath, target]);\n    }\n  }\n\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/@antv/algorithm/lib/dijkstra.js"],"names":["Object","defineProperty","exports","value","default","_tslib","require","_util","_util2","minVertex","D","nodes","marks","minDis","Infinity","minNode","i","length","nodeId","id","dijkstra","graphData","source","directed","weightPropertyName","_a","_b","edges","nodeIds","prevs","forEach","node","push","nodeNum","_loop_1","minNodeId","relatedEdges","getOutEdgesNodeId","getEdgesByNodeId","edge","edgeTarget","target","edgeSource","w","weight","paths","findAllPaths","path","allPath","_default","foundPaths","_i","prev","prevPaths","prevPaths_1","prePath","isArray","__spreadArray"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _tslib = require(\"tslib\");\n\nvar _util = require(\"@antv/util\");\n\nvar _util2 = require(\"./util\");\n\nvar minVertex = function minVertex(D, nodes, marks) {\n  // 找出最小的点\n  var minDis = Infinity;\n  var minNode;\n\n  for (var i = 0; i < nodes.length; i++) {\n    var nodeId = nodes[i].id;\n\n    if (!marks[nodeId] && D[nodeId] <= minDis) {\n      minDis = D[nodeId];\n      minNode = nodes[i];\n    }\n  }\n\n  return minNode;\n};\n\nvar dijkstra = function dijkstra(graphData, source, directed, weightPropertyName) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeIds = [];\n  var marks = {};\n  var D = {};\n  var prevs = {}; // key: 顶点, value: 顶点的前驱点数组（可能有多条等长的最短路径）\n\n  nodes.forEach(function (node, i) {\n    var id = node.id;\n    nodeIds.push(id);\n    D[id] = Infinity;\n    if (id === source) D[id] = 0;\n  });\n  var nodeNum = nodes.length;\n\n  var _loop_1 = function _loop_1(i) {\n    // Process the vertices\n    var minNode = minVertex(D, nodes, marks);\n    var minNodeId = minNode.id;\n    marks[minNodeId] = true;\n    if (D[minNodeId] === Infinity) return \"continue\"; // Unreachable vertices cannot be the intermediate point\n\n    var relatedEdges = [];\n    if (directed) relatedEdges = (0, _util2.getOutEdgesNodeId)(minNodeId, edges);else relatedEdges = (0, _util2.getEdgesByNodeId)(minNodeId, edges);\n    relatedEdges.forEach(function (edge) {\n      var edgeTarget = edge.target;\n      var edgeSource = edge.source;\n      var w = edgeTarget === minNodeId ? edgeSource : edgeTarget;\n      var weight = weightPropertyName && edge[weightPropertyName] ? edge[weightPropertyName] : 1;\n\n      if (D[w] > D[minNode.id] + weight) {\n        D[w] = D[minNode.id] + weight;\n        prevs[w] = [minNode.id];\n      } else if (D[w] === D[minNode.id] + weight) {\n        prevs[w].push(minNode.id);\n      }\n    });\n  };\n\n  for (var i = 0; i < nodeNum; i++) {\n    _loop_1(i);\n  }\n\n  prevs[source] = [source]; // 每个节点存可能存在多条最短路径\n\n  var paths = {};\n\n  for (var target in D) {\n    if (D[target] !== Infinity) {\n      findAllPaths(source, target, prevs, paths);\n    }\n  } // 兼容之前单路径\n\n\n  var path = {};\n\n  for (var target in paths) {\n    path[target] = paths[target][0];\n  }\n\n  return {\n    length: D,\n    path: path,\n    allPath: paths\n  };\n};\n\nvar _default = dijkstra;\nexports.default = _default;\n\nfunction findAllPaths(source, target, prevs, foundPaths) {\n  if (source === target) {\n    return [source];\n  }\n\n  if (foundPaths[target]) {\n    return foundPaths[target];\n  }\n\n  var paths = [];\n\n  for (var _i = 0, _a = prevs[target]; _i < _a.length; _i++) {\n    var prev = _a[_i];\n    var prevPaths = findAllPaths(source, prev, prevs, foundPaths);\n    if (!prevPaths) return;\n\n    for (var _b = 0, prevPaths_1 = prevPaths; _b < prevPaths_1.length; _b++) {\n      var prePath = prevPaths_1[_b];\n      if ((0, _util.isArray)(prePath)) paths.push((0, _tslib.__spreadArray)((0, _tslib.__spreadArray)([], prePath), [target]));else paths.push([prePath, target]);\n    }\n  }\n\n  foundPaths[target] = paths;\n  return foundPaths[target];\n}"]},"metadata":{},"sourceType":"script"}