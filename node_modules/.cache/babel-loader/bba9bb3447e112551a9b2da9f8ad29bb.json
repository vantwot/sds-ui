{"ast":null,"code":"import { Util } from '../../../global/util';\nimport { Point, Line, Angle } from '../../../geometry';\nexport function getSourceBBox(view, options) {\n  const bbox = view.sourceBBox.clone();\n\n  if (options && options.paddingBox) {\n    return bbox.moveAndExpand(options.paddingBox);\n  }\n\n  return bbox;\n}\nexport function getTargetBBox(view, options) {\n  const bbox = view.targetBBox.clone();\n\n  if (options && options.paddingBox) {\n    return bbox.moveAndExpand(options.paddingBox);\n  }\n\n  return bbox;\n}\nexport function getSourceEndpoint(view, options) {\n  if (view.sourceAnchor) {\n    return view.sourceAnchor;\n  }\n\n  const sourceBBox = getSourceBBox(view, options);\n  return sourceBBox.getCenter();\n}\nexport function getTargetEndpoint(view, options) {\n  if (view.targetAnchor) {\n    return view.targetAnchor;\n  }\n\n  const targetBBox = getTargetBBox(view, options);\n  return targetBBox.getCenter();\n} // returns a direction index from start point to end point\n// corrects for grid deformation between start and end\n\nexport function getDirectionAngle(start, end, directionCount, grid, options) {\n  const quadrant = 360 / directionCount;\n  const angleTheta = start.theta(fixAngleEnd(start, end, grid, options));\n  const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);\n  return quadrant * Math.floor(normalizedAngle / quadrant);\n}\n\nfunction fixAngleEnd(start, end, grid, options) {\n  const step = options.step;\n  const diffX = end.x - start.x;\n  const diffY = end.y - start.y;\n  const gridStepsX = diffX / grid.x;\n  const gridStepsY = diffY / grid.y;\n  const distanceX = gridStepsX * step;\n  const distanceY = gridStepsY * step;\n  return new Point(start.x + distanceX, start.y + distanceY);\n}\n/**\n * Returns the change in direction between two direction angles.\n */\n\n\nexport function getDirectionChange(angle1, angle2) {\n  const change = Math.abs(angle1 - angle2);\n  return change > 180 ? 360 - change : change;\n} // fix direction offsets according to current grid\n\nexport function getGridOffsets(grid, options) {\n  const step = options.step;\n  options.directions.forEach(direction => {\n    direction.gridOffsetX = direction.offsetX / step * grid.x;\n    direction.gridOffsetY = direction.offsetY / step * grid.y;\n  });\n  return options.directions;\n} // get grid size in x and y dimensions, adapted to source and target positions\n\nexport function getGrid(step, source, target) {\n  return {\n    source: source.clone(),\n    x: getGridDimension(target.x - source.x, step),\n    y: getGridDimension(target.y - source.y, step)\n  };\n}\n\nfunction getGridDimension(diff, step) {\n  // return step if diff = 0\n  if (!diff) {\n    return step;\n  }\n\n  const abs = Math.abs(diff);\n  const count = Math.round(abs / step); // return `abs` if less than one step apart\n\n  if (!count) {\n    return abs;\n  } // otherwise, return corrected step\n\n\n  const roundedDiff = count * step;\n  const remainder = abs - roundedDiff;\n  const correction = remainder / count;\n  return step + correction;\n}\n\nfunction snapGrid(point, grid) {\n  const source = grid.source;\n  const x = Util.snapToGrid(point.x - source.x, grid.x) + source.x;\n  const y = Util.snapToGrid(point.y - source.y, grid.y) + source.y;\n  return new Point(x, y);\n}\n\nexport function round(point, precision) {\n  return point.round(precision);\n}\nexport function align(point, grid, precision) {\n  return round(snapGrid(point.clone(), grid), precision);\n}\nexport function getKey(point) {\n  return point.toString();\n}\nexport function normalizePoint(point) {\n  return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n}\nexport function getCost(from, anchors) {\n  let min = Infinity;\n\n  for (let i = 0, len = anchors.length; i < len; i += 1) {\n    const dist = from.manhattanDistance(anchors[i]);\n\n    if (dist < min) {\n      min = dist;\n    }\n  }\n\n  return min;\n} // Find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\n\nexport function getRectPoints(anchor, bbox, directionList, grid, options) {\n  const precision = options.precision;\n  const directionMap = options.directionMap;\n  const centerVector = anchor.diff(bbox.getCenter());\n  const rectPoints = Object.keys(directionMap).reduce((res, key) => {\n    if (directionList.includes(key)) {\n      const direction = directionMap[key]; // Create a line that is guaranteed to intersect the bbox if bbox\n      // is in the direction even if anchor lies outside of bbox.\n\n      const ending = new Point(anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height));\n      const intersectionLine = new Line(anchor, ending); // Get the farther intersection, in case there are two\n      // (that happens if anchor lies next to bbox)\n\n      const intersections = intersectionLine.intersect(bbox) || [];\n      let farthestIntersectionDistance;\n      let farthestIntersection = null;\n\n      for (let i = 0; i < intersections.length; i += 1) {\n        const intersection = intersections[i];\n        const distance = anchor.squaredDistance(intersection);\n\n        if (farthestIntersectionDistance == null || distance > farthestIntersectionDistance) {\n          farthestIntersectionDistance = distance;\n          farthestIntersection = intersection;\n        }\n      } // If an intersection was found in this direction, it is our rectPoint\n\n\n      if (farthestIntersection) {\n        let target = align(farthestIntersection, grid, precision); // If the rectPoint lies inside the bbox, offset it by one more step\n\n        if (bbox.containsPoint(target)) {\n          target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);\n        }\n\n        res.push(target);\n      }\n    }\n\n    return res;\n  }, []); // if anchor lies outside of bbox, add it to the array of points\n\n  if (!bbox.containsPoint(anchor)) {\n    rectPoints.push(align(anchor, grid, precision));\n  }\n\n  return rectPoints;\n} // reconstructs a route by concatenating points with their parents\n\nexport function reconstructRoute(parents, points, tailPoint, from, to) {\n  const route = [];\n  let prevDiff = normalizePoint(to.diff(tailPoint)); // tailPoint is assumed to be aligned already\n\n  let currentKey = getKey(tailPoint);\n  let parent = parents[currentKey];\n  let point;\n\n  while (parent) {\n    // point is assumed to be aligned already\n    point = points[currentKey];\n    const diff = normalizePoint(point.diff(parent));\n\n    if (!diff.equals(prevDiff)) {\n      route.unshift(point);\n      prevDiff = diff;\n    } // parent is assumed to be aligned already\n\n\n    currentKey = getKey(parent);\n    parent = parents[currentKey];\n  } // leadPoint is assumed to be aligned already\n\n\n  const leadPoint = points[currentKey];\n  const fromDiff = normalizePoint(leadPoint.diff(from));\n\n  if (!fromDiff.equals(prevDiff)) {\n    route.unshift(leadPoint);\n  }\n\n  return route;\n}","map":{"version":3,"sources":["../../../../src/registry/router/manhattan/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Util } from '../../../global/util';\nimport { Point, Line, Angle } from '../../../geometry';\nexport function getSourceBBox(view, options) {\n    const bbox = view.sourceBBox.clone();\n    if (options && options.paddingBox) {\n        return bbox.moveAndExpand(options.paddingBox);\n    }\n    return bbox;\n}\nexport function getTargetBBox(view, options) {\n    const bbox = view.targetBBox.clone();\n    if (options && options.paddingBox) {\n        return bbox.moveAndExpand(options.paddingBox);\n    }\n    return bbox;\n}\nexport function getSourceEndpoint(view, options) {\n    if (view.sourceAnchor) {\n        return view.sourceAnchor;\n    }\n    const sourceBBox = getSourceBBox(view, options);\n    return sourceBBox.getCenter();\n}\nexport function getTargetEndpoint(view, options) {\n    if (view.targetAnchor) {\n        return view.targetAnchor;\n    }\n    const targetBBox = getTargetBBox(view, options);\n    return targetBBox.getCenter();\n}\n// returns a direction index from start point to end point\n// corrects for grid deformation between start and end\nexport function getDirectionAngle(start, end, directionCount, grid, options) {\n    const quadrant = 360 / directionCount;\n    const angleTheta = start.theta(fixAngleEnd(start, end, grid, options));\n    const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);\n    return quadrant * Math.floor(normalizedAngle / quadrant);\n}\nfunction fixAngleEnd(start, end, grid, options) {\n    const step = options.step;\n    const diffX = end.x - start.x;\n    const diffY = end.y - start.y;\n    const gridStepsX = diffX / grid.x;\n    const gridStepsY = diffY / grid.y;\n    const distanceX = gridStepsX * step;\n    const distanceY = gridStepsY * step;\n    return new Point(start.x + distanceX, start.y + distanceY);\n}\n/**\n * Returns the change in direction between two direction angles.\n */\nexport function getDirectionChange(angle1, angle2) {\n    const change = Math.abs(angle1 - angle2);\n    return change > 180 ? 360 - change : change;\n}\n// fix direction offsets according to current grid\nexport function getGridOffsets(grid, options) {\n    const step = options.step;\n    options.directions.forEach((direction) => {\n        direction.gridOffsetX = (direction.offsetX / step) * grid.x;\n        direction.gridOffsetY = (direction.offsetY / step) * grid.y;\n    });\n    return options.directions;\n}\n// get grid size in x and y dimensions, adapted to source and target positions\nexport function getGrid(step, source, target) {\n    return {\n        source: source.clone(),\n        x: getGridDimension(target.x - source.x, step),\n        y: getGridDimension(target.y - source.y, step),\n    };\n}\nfunction getGridDimension(diff, step) {\n    // return step if diff = 0\n    if (!diff) {\n        return step;\n    }\n    const abs = Math.abs(diff);\n    const count = Math.round(abs / step);\n    // return `abs` if less than one step apart\n    if (!count) {\n        return abs;\n    }\n    // otherwise, return corrected step\n    const roundedDiff = count * step;\n    const remainder = abs - roundedDiff;\n    const correction = remainder / count;\n    return step + correction;\n}\nfunction snapGrid(point, grid) {\n    const source = grid.source;\n    const x = Util.snapToGrid(point.x - source.x, grid.x) + source.x;\n    const y = Util.snapToGrid(point.y - source.y, grid.y) + source.y;\n    return new Point(x, y);\n}\nexport function round(point, precision) {\n    return point.round(precision);\n}\nexport function align(point, grid, precision) {\n    return round(snapGrid(point.clone(), grid), precision);\n}\nexport function getKey(point) {\n    return point.toString();\n}\nexport function normalizePoint(point) {\n    return new Point(point.x === 0 ? 0 : Math.abs(point.x) / point.x, point.y === 0 ? 0 : Math.abs(point.y) / point.y);\n}\nexport function getCost(from, anchors) {\n    let min = Infinity;\n    for (let i = 0, len = anchors.length; i < len; i += 1) {\n        const dist = from.manhattanDistance(anchors[i]);\n        if (dist < min) {\n            min = dist;\n        }\n    }\n    return min;\n}\n// Find points around the bbox taking given directions into account\n// lines are drawn from anchor in given directions, intersections recorded\n// if anchor is outside bbox, only those directions that intersect get a rect point\n// the anchor itself is returned as rect point (representing some directions)\n// (since those directions are unobstructed by the bbox)\nexport function getRectPoints(anchor, bbox, directionList, grid, options) {\n    const precision = options.precision;\n    const directionMap = options.directionMap;\n    const centerVector = anchor.diff(bbox.getCenter());\n    const rectPoints = Object.keys(directionMap).reduce((res, key) => {\n        if (directionList.includes(key)) {\n            const direction = directionMap[key];\n            // Create a line that is guaranteed to intersect the bbox if bbox\n            // is in the direction even if anchor lies outside of bbox.\n            const ending = new Point(anchor.x + direction.x * (Math.abs(centerVector.x) + bbox.width), anchor.y + direction.y * (Math.abs(centerVector.y) + bbox.height));\n            const intersectionLine = new Line(anchor, ending);\n            // Get the farther intersection, in case there are two\n            // (that happens if anchor lies next to bbox)\n            const intersections = intersectionLine.intersect(bbox) || [];\n            let farthestIntersectionDistance;\n            let farthestIntersection = null;\n            for (let i = 0; i < intersections.length; i += 1) {\n                const intersection = intersections[i];\n                const distance = anchor.squaredDistance(intersection);\n                if (farthestIntersectionDistance == null ||\n                    distance > farthestIntersectionDistance) {\n                    farthestIntersectionDistance = distance;\n                    farthestIntersection = intersection;\n                }\n            }\n            // If an intersection was found in this direction, it is our rectPoint\n            if (farthestIntersection) {\n                let target = align(farthestIntersection, grid, precision);\n                // If the rectPoint lies inside the bbox, offset it by one more step\n                if (bbox.containsPoint(target)) {\n                    target = align(target.translate(direction.x * grid.x, direction.y * grid.y), grid, precision);\n                }\n                res.push(target);\n            }\n        }\n        return res;\n    }, []);\n    // if anchor lies outside of bbox, add it to the array of points\n    if (!bbox.containsPoint(anchor)) {\n        rectPoints.push(align(anchor, grid, precision));\n    }\n    return rectPoints;\n}\n// reconstructs a route by concatenating points with their parents\nexport function reconstructRoute(parents, points, tailPoint, from, to) {\n    const route = [];\n    let prevDiff = normalizePoint(to.diff(tailPoint));\n    // tailPoint is assumed to be aligned already\n    let currentKey = getKey(tailPoint);\n    let parent = parents[currentKey];\n    let point;\n    while (parent) {\n        // point is assumed to be aligned already\n        point = points[currentKey];\n        const diff = normalizePoint(point.diff(parent));\n        if (!diff.equals(prevDiff)) {\n            route.unshift(point);\n            prevDiff = diff;\n        }\n        // parent is assumed to be aligned already\n        currentKey = getKey(parent);\n        parent = parents[currentKey];\n    }\n    // leadPoint is assumed to be aligned already\n    const leadPoint = points[currentKey];\n    const fromDiff = normalizePoint(leadPoint.diff(from));\n    if (!fromDiff.equals(prevDiff)) {\n        route.unshift(leadPoint);\n    }\n    return route;\n}\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}