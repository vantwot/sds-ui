{"ast":null,"code":"export var Scheduler;\n\n(function (Scheduler) {\n  const queue = [];\n  const threshold = 1000 / 60;\n  const unit = [];\n  let deadline = 0;\n\n  const getTime = () => performance.now();\n\n  const peek = queue => queue[0];\n\n  const schedule = cb => unit.push(cb) === 1 && postMessage();\n\n  const postMessage = (() => {\n    const cb = () => unit.splice(0, unit.length).forEach(c => c());\n\n    if (typeof MessageChannel !== 'undefined') {\n      const {\n        port1,\n        port2\n      } = new MessageChannel();\n      port1.onmessage = cb;\n      return () => port2.postMessage(null);\n    }\n\n    return () => setTimeout(cb);\n  })();\n\n  const flushTask = () => {\n    deadline = getTime() + threshold;\n    let job = peek(queue);\n\n    while (job && !Scheduler.shouldYield()) {\n      const {\n        callback,\n        data\n      } = job;\n      job.callback = null;\n      const next = callback && callback(data);\n\n      if (next) {\n        job.callback = next;\n      } else {\n        queue.shift();\n      }\n\n      job = peek(queue);\n    }\n\n    job && schedule(flushTask);\n  };\n\n  Scheduler.scheduleTask = (callback, data) => {\n    const task = {\n      callback,\n      data\n    };\n    queue.push(task);\n    schedule(flushTask);\n  };\n\n  Scheduler.shouldYield = () => {\n    var _a, _b;\n\n    return ((_b = (_a = navigator) === null || _a === void 0 ? void 0 : _a.scheduling) === null || _b === void 0 ? void 0 : _b.isInputPending()) || getTime() >= deadline;\n  };\n})(Scheduler || (Scheduler = {}));","map":{"version":3,"sources":["../../../src/util/scheduler/index.ts"],"names":[],"mappings":"AAAA,OAAM,IAAW,SAAX;;AAAN,CAAA,UAAiB,SAAjB,EAA0B;AASxB,QAAM,KAAK,GAAY,EAAvB;AACA,QAAM,SAAS,GAAW,OAAO,EAAjC;AACA,QAAM,IAAI,GAAkB,EAA5B;AACA,MAAI,QAAQ,GAAG,CAAf;;AAEA,QAAM,OAAO,GAAG,MAAM,WAAW,CAAC,GAAZ,EAAtB;;AACA,QAAM,IAAI,GAAI,KAAD,IAAoB,KAAK,CAAC,CAAD,CAAtC;;AACA,QAAM,QAAQ,GAAI,EAAD,IAAqB,IAAI,CAAC,IAAL,CAAU,EAAV,MAAkB,CAAlB,IAAuB,WAAW,EAAxE;;AAEA,QAAM,WAAW,GAAG,CAAC,MAAK;AACxB,UAAM,EAAE,GAAG,MAAM,IAAI,CAAC,MAAL,CAAY,CAAZ,EAAe,IAAI,CAAC,MAApB,EAA4B,OAA5B,CAAqC,CAAD,IAAO,CAAC,EAA5C,CAAjB;;AACA,QAAI,OAAO,cAAP,KAA0B,WAA9B,EAA2C;AACzC,YAAM;AAAE,QAAA,KAAF;AAAS,QAAA;AAAT,UAAmB,IAAI,cAAJ,EAAzB;AACA,MAAA,KAAK,CAAC,SAAN,GAAkB,EAAlB;AACA,aAAO,MAAM,KAAK,CAAC,WAAN,CAAkB,IAAlB,CAAb;AACD;;AACD,WAAO,MAAM,UAAU,CAAC,EAAD,CAAvB;AACD,GARmB,GAApB;;AAUA,QAAM,SAAS,GAAG,MAAK;AACrB,IAAA,QAAQ,GAAG,OAAO,KAAK,SAAvB;AACA,QAAI,GAAG,GAAG,IAAI,CAAC,KAAD,CAAd;;AACA,WAAO,GAAG,IAAI,CAAC,SAAA,CAAA,WAAA,EAAf,EAA8B;AAC5B,YAAM;AAAE,QAAA,QAAF;AAAY,QAAA;AAAZ,UAAqB,GAA3B;AACA,MAAA,GAAG,CAAC,QAAJ,GAAe,IAAf;AACA,YAAM,IAAI,GAAG,QAAQ,IAAI,QAAQ,CAAC,IAAD,CAAjC;;AACA,UAAI,IAAJ,EAAU;AACR,QAAA,GAAG,CAAC,QAAJ,GAAe,IAAf;AACD,OAFD,MAEO;AACL,QAAA,KAAK,CAAC,KAAN;AACD;;AACD,MAAA,GAAG,GAAG,IAAI,CAAC,KAAD,CAAV;AACD;;AACD,IAAA,GAAG,IAAI,QAAQ,CAAC,SAAD,CAAf;AACD,GAfD;;AAiBa,EAAA,SAAA,CAAA,YAAA,GAAe,CAAC,QAAD,EAA0B,IAA1B,KAAwC;AAClE,UAAM,IAAI,GAAG;AACX,MAAA,QADW;AAEX,MAAA;AAFW,KAAb;AAIA,IAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,IAAA,QAAQ,CAAC,SAAD,CAAR;AACD,GAPY;;AASA,EAAA,SAAA,CAAA,WAAA,GAAc,MAAc;;;AACvC,WACE,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAC,SAAD,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,KAAA,CAAlB,GAAkB,EAAA,CAAE,UAApB,MAA8B,IAA9B,IAA8B,EAAA,KAAA,KAAA,CAA9B,GAA8B,KAAA,CAA9B,GAA8B,EAAA,CAAE,cAAF,EAA9B,KAAoD,OAAO,MAAM,QADnE;AAGD,GAJY;AAKd,CA3DD,EAAiB,SAAS,KAAT,SAAS,GAAA,EAAA,CAA1B","sourceRoot":"","sourcesContent":["export var Scheduler;\n(function (Scheduler) {\n    const queue = [];\n    const threshold = 1000 / 60;\n    const unit = [];\n    let deadline = 0;\n    const getTime = () => performance.now();\n    const peek = (queue) => queue[0];\n    const schedule = (cb) => unit.push(cb) === 1 && postMessage();\n    const postMessage = (() => {\n        const cb = () => unit.splice(0, unit.length).forEach((c) => c());\n        if (typeof MessageChannel !== 'undefined') {\n            const { port1, port2 } = new MessageChannel();\n            port1.onmessage = cb;\n            return () => port2.postMessage(null);\n        }\n        return () => setTimeout(cb);\n    })();\n    const flushTask = () => {\n        deadline = getTime() + threshold;\n        let job = peek(queue);\n        while (job && !Scheduler.shouldYield()) {\n            const { callback, data } = job;\n            job.callback = null;\n            const next = callback && callback(data);\n            if (next) {\n                job.callback = next;\n            }\n            else {\n                queue.shift();\n            }\n            job = peek(queue);\n        }\n        job && schedule(flushTask);\n    };\n    Scheduler.scheduleTask = (callback, data) => {\n        const task = {\n            callback,\n            data,\n        };\n        queue.push(task);\n        schedule(flushTask);\n    };\n    Scheduler.shouldYield = () => {\n        var _a, _b;\n        return (((_b = (_a = navigator) === null || _a === void 0 ? void 0 : _a.scheduling) === null || _b === void 0 ? void 0 : _b.isInputPending()) || getTime() >= deadline);\n    };\n})(Scheduler || (Scheduler = {}));\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}