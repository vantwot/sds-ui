{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport dagre from \"dagrejs\";\nimport { isArray, isNumber, isObject, getEdgeTerminal } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 层次布局\n */\n\nexport var DagreLayout = /*#__PURE__*/function (_Base) {\n  _inherits(DagreLayout, _Base);\n\n  var _super = _createSuper(DagreLayout);\n\n  function DagreLayout(options) {\n    var _this;\n\n    _classCallCheck(this, DagreLayout);\n\n    _this = _super.call(this);\n    /** layout 方向, 可选 TB, BT, LR, RL */\n\n    _this.rankdir = \"TB\";\n    /** 节点水平间距(px) */\n\n    _this.nodesep = 50;\n    /** 每一层节点之间间距 */\n\n    _this.ranksep = 50;\n    /** 是否保留布局连线的控制点 */\n\n    _this.controlPoints = false;\n    /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n\n    _this.sortByCombo = false;\n    /** 是否保留每条边上的dummy node */\n\n    _this.edgeLabelSpace = true;\n    /** 是否按照给定的节点顺序排序 */\n\n    _this.keepNodeOrder = false;\n    _this.nodes = [];\n    _this.edges = [];\n    /** 迭代结束的回调函数 */\n\n    _this.onLayoutEnd = function () {};\n\n    _this.layoutNode = function (nodeId) {\n      var self = _assertThisInitialized(_this);\n\n      var nodes = self.nodes;\n      var node = nodes.find(function (node) {\n        return node.id === nodeId;\n      });\n\n      if (node) {\n        var layout = node.layout !== false;\n        return layout;\n      }\n\n      return true;\n    };\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(DagreLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        rankdir: \"TB\",\n        align: undefined,\n        nodeSize: undefined,\n        nodesepFunc: undefined,\n        ranksepFunc: undefined,\n        nodesep: 50,\n        ranksep: 50,\n        controlPoints: false // 是否保留布局连线的控制点\n\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var _this2 = this;\n\n      var self = this;\n      var nodes = self.nodes,\n          nodeSize = self.nodeSize,\n          rankdir = self.rankdir,\n          combos = self.combos;\n      if (!nodes) return;\n      var edges = self.edges || [];\n      var g = new dagre.graphlib.Graph({\n        multigraph: true,\n        compound: true\n      });\n      var nodeSizeFunc;\n\n      if (!nodeSize) {\n        nodeSizeFunc = function nodeSizeFunc(d) {\n          if (d.size) {\n            if (isArray(d.size)) {\n              return d.size;\n            }\n\n            if (isObject(d.size)) {\n              return [d.size.width || 40, d.size.height || 40];\n            }\n\n            return [d.size, d.size];\n          }\n\n          return [40, 40];\n        };\n      } else if (isArray(nodeSize)) {\n        nodeSizeFunc = function nodeSizeFunc() {\n          return nodeSize;\n        };\n      } else {\n        nodeSizeFunc = function nodeSizeFunc() {\n          return [nodeSize, nodeSize];\n        };\n      }\n\n      var horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n      var vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n\n      if (rankdir === \"LR\" || rankdir === \"RL\") {\n        horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n        vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n      }\n\n      g.setDefaultEdgeLabel(function () {\n        return {};\n      });\n      g.setGraph(self);\n      var comboMap = {};\n      nodes.filter(function (node) {\n        return node.layout !== false;\n      }).forEach(function (node) {\n        var size = nodeSizeFunc(node);\n        var verti = vertisep(node);\n        var hori = horisep(node);\n        var width = size[0] + 2 * hori;\n        var height = size[1] + 2 * verti;\n        var layer = node.layer;\n\n        if (isNumber(layer)) {\n          // 如果有layer属性，加入到node的label中\n          g.setNode(node.id, {\n            width: width,\n            height: height,\n            layer: layer\n          });\n        } else {\n          g.setNode(node.id, {\n            width: width,\n            height: height\n          });\n        }\n\n        if (_this2.sortByCombo && node.comboId) {\n          if (!comboMap[node.comboId]) {\n            comboMap[node.comboId] = true;\n            g.setNode(node.comboId, {});\n          }\n\n          g.setParent(node.id, node.comboId);\n        }\n      });\n\n      if (this.sortByCombo && combos) {\n        combos.forEach(function (combo) {\n          if (!combo.parentId) return;\n\n          if (!comboMap[combo.parentId]) {\n            comboMap[combo.parentId] = true;\n            g.setNode(combo.parentId, {});\n          }\n\n          g.setParent(combo.id, combo.parentId);\n        });\n      }\n\n      edges.forEach(function (edge) {\n        // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n        var source = getEdgeTerminal(edge, 'source');\n        var target = getEdgeTerminal(edge, 'target');\n\n        if (_this2.layoutNode(source) && _this2.layoutNode(target)) {\n          g.setEdge(source, target, {\n            weight: edge.weight || 1\n          });\n        }\n      }); // 考虑增量图中的原始图\n\n      var prevGraph = undefined;\n\n      if (self.preset) {\n        prevGraph = new dagre.graphlib.Graph({\n          multigraph: true,\n          compound: true\n        });\n        self.preset.nodes.forEach(function (node) {\n          prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);\n        });\n      }\n\n      dagre.layout(g, {\n        prevGraph: prevGraph,\n        edgeLabelSpace: self.edgeLabelSpace,\n        keepNodeOrder: self.keepNodeOrder,\n        nodeOrder: self.nodeOrder\n      });\n      var coord;\n      g.nodes().forEach(function (node) {\n        coord = g.node(node);\n        var i = nodes.findIndex(function (it) {\n          return it.id === node;\n        });\n        if (!nodes[i]) return;\n        nodes[i].x = coord.x;\n        nodes[i].y = coord.y; // @ts-ignore: pass layer order to data for increment layout use\n\n        nodes[i]._order = coord._order;\n      });\n      g.edges().forEach(function (edge) {\n        coord = g.edge(edge);\n        var i = edges.findIndex(function (it) {\n          var source = getEdgeTerminal(it, 'source');\n          var target = getEdgeTerminal(it, 'target');\n          return source === edge.v && target === edge.w;\n        });\n\n        if (self.edgeLabelSpace && self.controlPoints && edges[i].type !== \"loop\") {\n          edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n        }\n      });\n      if (self.onLayoutEnd) self.onLayoutEnd();\n      return {\n        nodes: nodes,\n        edges: edges\n      };\n    }\n  }, {\n    key: \"getType\",\n    value: function getType() {\n      return \"dagre\";\n    }\n  }]);\n\n  return DagreLayout;\n}(Base);\n\nfunction getFunc(func, value, defaultValue) {\n  var resultFunc;\n\n  if (func) {\n    resultFunc = func;\n  } else if (isNumber(value)) {\n    resultFunc = function resultFunc() {\n      return value;\n    };\n  } else {\n    resultFunc = function resultFunc() {\n      return defaultValue;\n    };\n  }\n\n  return resultFunc;\n}","map":{"version":3,"sources":["../../src/layout/dagre.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport dagre from \"dagrejs\";\nimport { isArray, isNumber, isObject, getEdgeTerminal } from \"../util\";\nimport { Base } from \"./base\";\n/**\n * 层次布局\n */\nexport class DagreLayout extends Base {\n    constructor(options) {\n        super();\n        /** layout 方向, 可选 TB, BT, LR, RL */\n        this.rankdir = \"TB\";\n        /** 节点水平间距(px) */\n        this.nodesep = 50;\n        /** 每一层节点之间间距 */\n        this.ranksep = 50;\n        /** 是否保留布局连线的控制点 */\n        this.controlPoints = false;\n        /** 每层节点是否根据节点数据中的 comboId 进行排序，以防止同层 combo 重叠 */\n        this.sortByCombo = false;\n        /** 是否保留每条边上的dummy node */\n        this.edgeLabelSpace = true;\n        /** 是否按照给定的节点顺序排序 */\n        this.keepNodeOrder = false;\n        this.nodes = [];\n        this.edges = [];\n        /** 迭代结束的回调函数 */\n        this.onLayoutEnd = () => { };\n        this.layoutNode = (nodeId) => {\n            const self = this;\n            const { nodes } = self;\n            const node = nodes.find(node => node.id === nodeId);\n            if (node) {\n                const layout = node.layout !== false;\n                return layout;\n            }\n            return true;\n        };\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            rankdir: \"TB\",\n            align: undefined,\n            nodeSize: undefined,\n            nodesepFunc: undefined,\n            ranksepFunc: undefined,\n            nodesep: 50,\n            ranksep: 50,\n            controlPoints: false, // 是否保留布局连线的控制点\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const { nodes, nodeSize, rankdir, combos } = self;\n        if (!nodes)\n            return;\n        const edges = self.edges || [];\n        const g = new dagre.graphlib.Graph({\n            multigraph: true,\n            compound: true,\n        });\n        let nodeSizeFunc;\n        if (!nodeSize) {\n            nodeSizeFunc = (d) => {\n                if (d.size) {\n                    if (isArray(d.size)) {\n                        return d.size;\n                    }\n                    if (isObject(d.size)) {\n                        return [d.size.width || 40, d.size.height || 40];\n                    }\n                    return [d.size, d.size];\n                }\n                return [40, 40];\n            };\n        }\n        else if (isArray(nodeSize)) {\n            nodeSizeFunc = () => nodeSize;\n        }\n        else {\n            nodeSizeFunc = () => [nodeSize, nodeSize];\n        }\n        let horisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n        let vertisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n        if (rankdir === \"LR\" || rankdir === \"RL\") {\n            horisep = getFunc(self.ranksepFunc, self.ranksep, 50);\n            vertisep = getFunc(self.nodesepFunc, self.nodesep, 50);\n        }\n        g.setDefaultEdgeLabel(() => ({}));\n        g.setGraph(self);\n        const comboMap = {};\n        nodes.filter((node) => node.layout !== false).forEach((node) => {\n            const size = nodeSizeFunc(node);\n            const verti = vertisep(node);\n            const hori = horisep(node);\n            const width = size[0] + 2 * hori;\n            const height = size[1] + 2 * verti;\n            const layer = node.layer;\n            if (isNumber(layer)) {\n                // 如果有layer属性，加入到node的label中\n                g.setNode(node.id, { width, height, layer });\n            }\n            else {\n                g.setNode(node.id, { width, height });\n            }\n            if (this.sortByCombo && node.comboId) {\n                if (!comboMap[node.comboId]) {\n                    comboMap[node.comboId] = true;\n                    g.setNode(node.comboId, {});\n                }\n                g.setParent(node.id, node.comboId);\n            }\n        });\n        if (this.sortByCombo && combos) {\n            combos.forEach((combo) => {\n                if (!combo.parentId)\n                    return;\n                if (!comboMap[combo.parentId]) {\n                    comboMap[combo.parentId] = true;\n                    g.setNode(combo.parentId, {});\n                }\n                g.setParent(combo.id, combo.parentId);\n            });\n        }\n        edges.forEach((edge) => {\n            // dagrejs Wiki https://github.com/dagrejs/dagre/wiki#configuring-the-layout\n            const source = getEdgeTerminal(edge, 'source');\n            const target = getEdgeTerminal(edge, 'target');\n            if (this.layoutNode(source) && this.layoutNode(target)) {\n                g.setEdge(source, target, {\n                    weight: edge.weight || 1,\n                });\n            }\n        });\n        // 考虑增量图中的原始图\n        let prevGraph = undefined;\n        if (self.preset) {\n            prevGraph = new dagre.graphlib.Graph({\n                multigraph: true,\n                compound: true,\n            });\n            self.preset.nodes.forEach((node) => {\n                prevGraph === null || prevGraph === void 0 ? void 0 : prevGraph.setNode(node.id, node);\n            });\n        }\n        dagre.layout(g, {\n            prevGraph,\n            edgeLabelSpace: self.edgeLabelSpace,\n            keepNodeOrder: self.keepNodeOrder,\n            nodeOrder: self.nodeOrder,\n        });\n        let coord;\n        g.nodes().forEach((node) => {\n            coord = g.node(node);\n            const i = nodes.findIndex((it) => it.id === node);\n            if (!nodes[i])\n                return;\n            nodes[i].x = coord.x;\n            nodes[i].y = coord.y;\n            // @ts-ignore: pass layer order to data for increment layout use\n            nodes[i]._order = coord._order;\n        });\n        g.edges().forEach((edge) => {\n            coord = g.edge(edge);\n            const i = edges.findIndex((it) => {\n                const source = getEdgeTerminal(it, 'source');\n                const target = getEdgeTerminal(it, 'target');\n                return source === edge.v && target === edge.w;\n            });\n            if ((self.edgeLabelSpace) && self.controlPoints && edges[i].type !== \"loop\") {\n                edges[i].controlPoints = coord.points.slice(1, coord.points.length - 1);\n            }\n        });\n        if (self.onLayoutEnd)\n            self.onLayoutEnd();\n        return {\n            nodes,\n            edges,\n        };\n    }\n    getType() {\n        return \"dagre\";\n    }\n}\nfunction getFunc(func, value, defaultValue) {\n    let resultFunc;\n    if (func) {\n        resultFunc = func;\n    }\n    else if (isNumber(value)) {\n        resultFunc = () => value;\n    }\n    else {\n        resultFunc = () => defaultValue;\n    }\n    return resultFunc;\n}\n//# sourceMappingURL=dagre.js.map"]},"metadata":{},"sourceType":"module"}