{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { lngLatToMeters } from '@antv/l7-utils';\nimport earcut from 'earcut';\nimport { vec3 } from 'gl-matrix';\nexport default function extrudePolygon(path) {\n  var p1 = path[0][0];\n  var p2 = path[0][path[0].length - 1];\n\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    path[0] = path[0].slice(0, path[0].length - 1);\n  }\n\n  var n = path[0].length;\n  var flattengeo = earcut.flatten(path);\n  var vertices = flattengeo.vertices,\n      dimensions = flattengeo.dimensions;\n  var positions = [];\n  var indexArray = [];\n\n  for (var j = 0; j < vertices.length / dimensions; j++) {\n    if (dimensions === 2) {\n      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1);\n    } else {\n      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1);\n    }\n  }\n\n  var triangles = earcut(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);\n  indexArray.push.apply(indexArray, _toConsumableArray(triangles));\n\n  var _loop = function _loop(i) {\n    var prePoint = flattengeo.vertices.slice(i * dimensions, (i + 1) * dimensions);\n    var nextPoint = flattengeo.vertices.slice((i + 1) * dimensions, (i + 2) * dimensions);\n\n    if (nextPoint.length === 0) {\n      nextPoint = flattengeo.vertices.slice(0, dimensions);\n    }\n\n    var indexOffset = positions.length / 3;\n    positions.push(prePoint[0], prePoint[1], 1, nextPoint[0], nextPoint[1], 1, prePoint[0], prePoint[1], 0, nextPoint[0], nextPoint[1], 0);\n    indexArray.push.apply(indexArray, _toConsumableArray([0, 2, 1, 2, 3, 1].map(function (v) {\n      return v + indexOffset;\n    })));\n  };\n\n  for (var i = 0; i < n; i++) {\n    _loop(i);\n  }\n\n  return {\n    positions: positions,\n    index: indexArray\n  };\n}\nexport function fillPolygon(points) {\n  var flattengeo = earcut.flatten(points);\n  var triangles = earcut(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);\n  return {\n    positions: flattengeo.vertices,\n    index: triangles\n  };\n}\nexport function extrude_PolygonNormal(path) {\n  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  var p1 = path[0][0];\n  var p2 = path[0][path[0].length - 1];\n\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    path[0] = path[0].slice(0, path[0].length - 1);\n  }\n\n  var n = path[0].length;\n  var flattengeo = earcut.flatten(path);\n  var vertices = flattengeo.vertices,\n      dimensions = flattengeo.dimensions;\n  var positions = [];\n  var indexArray = [];\n  var normals = [];\n\n  for (var j = 0; j < vertices.length / dimensions; j++) {\n    if (dimensions === 2) {\n      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1, -1, -1);\n    } else {\n      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1, -1, -1);\n    }\n\n    normals.push(0, 0, 1);\n  }\n\n  var triangles = earcut(flattengeo.vertices, flattengeo.holes, flattengeo.dimensions);\n  indexArray.push.apply(indexArray, _toConsumableArray(triangles));\n\n  var _loop2 = function _loop2(i) {\n    var prePoint = flattengeo.vertices.slice(i * dimensions, (i + 1) * dimensions);\n    var nextPoint = flattengeo.vertices.slice((i + 1) * dimensions, (i + 2) * dimensions);\n\n    if (nextPoint.length === 0) {\n      nextPoint = flattengeo.vertices.slice(0, dimensions);\n    }\n\n    var indexOffset = positions.length / 5;\n    positions.push(prePoint[0], prePoint[1], 1, 0, 0, nextPoint[0], nextPoint[1], 1, 0.1, 0, prePoint[0], prePoint[1], 0, 0, 0.8, nextPoint[0], nextPoint[1], 0, 0.1, 0.8);\n    var normal = computeVertexNormals([nextPoint[0], nextPoint[1], 1], [prePoint[0], prePoint[1], 0], [prePoint[0], prePoint[1], 1], needFlat);\n    normals.push.apply(normals, _toConsumableArray(normal).concat(_toConsumableArray(normal), _toConsumableArray(normal), _toConsumableArray(normal)));\n    indexArray.push.apply(indexArray, _toConsumableArray([1, 2, 0, 3, 2, 1].map(function (v) {\n      return v + indexOffset;\n    })));\n  };\n\n  for (var i = 0; i < n; i++) {\n    _loop2(i);\n  }\n\n  return {\n    positions: positions,\n    index: indexArray,\n    normals: normals\n  };\n}\n\nfunction computeVertexNormals(p1, p2, p3) {\n  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var cb = vec3.create();\n  var ab = vec3.create();\n  var normal = vec3.create();\n\n  if (needFlat) {\n    p1 = lngLatToMeters(p1);\n    p2 = lngLatToMeters(p2);\n    p3 = lngLatToMeters(p3);\n  }\n\n  var pA = vec3.fromValues.apply(vec3, _toConsumableArray(p1));\n  var pB = vec3.fromValues.apply(vec3, _toConsumableArray(p2));\n  var pC = vec3.fromValues.apply(vec3, _toConsumableArray(p3));\n  vec3.sub(cb, pC, pB);\n  vec3.sub(ab, pA, pB);\n  vec3.cross(normal, cb, ab);\n  var newNormal = vec3.create();\n  vec3.normalize(newNormal, normal);\n  return newNormal;\n}","map":{"version":3,"sources":["../../../src/core/shape/extrude.ts"],"names":["p1","path","p2","n","flattengeo","earcut","vertices","dimensions","positions","indexArray","j","triangles","i","prePoint","nextPoint","indexOffset","v","index","needFlat","normals","normal","computeVertexNormals","cb","vec3","ab","lngLatToMeters","p3","pA","pB","pC","newNormal"],"mappings":"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","sourcesContent":["import { lngLatToMeters } from '@antv/l7-utils';\nimport earcut from 'earcut';\nimport { vec3 } from 'gl-matrix';\nimport { IPath } from './Path';\nexport interface IExtrudeGeomety {\n  positions: number[];\n  index: number[];\n  normals?: number[];\n}\n/**\n * 拉伸多边形顶点，返回拉伸后的顶点信息\n * @param paths 路径数据组\n * @param extrude 是否拉伸\n */\nexport default function extrudePolygon(path: IPath[]): IExtrudeGeomety {\n  const p1 = path[0][0];\n  const p2 = path[0][path[0].length - 1];\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    path[0] = path[0].slice(0, path[0].length - 1);\n  }\n\n  const n = path[0].length;\n  const flattengeo = earcut.flatten(path);\n  const { vertices, dimensions } = flattengeo;\n  const positions = [];\n  const indexArray = [];\n  // 设置顶部z值\n  for (let j = 0; j < vertices.length / dimensions; j++) {\n    if (dimensions === 2) {\n      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1);\n    } else {\n      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1);\n    }\n  }\n  const triangles = earcut(\n    flattengeo.vertices,\n    flattengeo.holes,\n    flattengeo.dimensions,\n  );\n  indexArray.push(...triangles);\n  for (let i = 0; i < n; i++) {\n    const prePoint = flattengeo.vertices.slice(\n      i * dimensions,\n      (i + 1) * dimensions,\n    );\n    let nextPoint = flattengeo.vertices.slice(\n      (i + 1) * dimensions,\n      (i + 2) * dimensions,\n    );\n    if (nextPoint.length === 0) {\n      nextPoint = flattengeo.vertices.slice(0, dimensions);\n    }\n    const indexOffset = positions.length / 3;\n    positions.push(\n      prePoint[0],\n      prePoint[1],\n      1,\n      nextPoint[0],\n      nextPoint[1],\n      1,\n      prePoint[0],\n      prePoint[1],\n      0,\n      nextPoint[0],\n      nextPoint[1],\n      0,\n    );\n    indexArray.push(...[0, 2, 1, 2, 3, 1].map((v) => v + indexOffset));\n  }\n  return {\n    positions,\n    index: indexArray,\n  };\n}\nexport function fillPolygon(points: IPath[]) {\n  const flattengeo = earcut.flatten(points);\n  const triangles = earcut(\n    flattengeo.vertices,\n    flattengeo.holes,\n    flattengeo.dimensions,\n  );\n  return {\n    positions: flattengeo.vertices,\n    index: triangles,\n  };\n}\n\nexport function extrude_PolygonNormal(\n  path: IPath[],\n  needFlat = false, // 是否需要转成平面坐标\n): IExtrudeGeomety {\n  const p1 = path[0][0];\n  const p2 = path[0][path[0].length - 1];\n  if (p1[0] === p2[0] && p1[1] === p2[1]) {\n    path[0] = path[0].slice(0, path[0].length - 1);\n  }\n  const n = path[0].length;\n  const flattengeo = earcut.flatten(path);\n  const { vertices, dimensions } = flattengeo;\n  const positions = [];\n  const indexArray = [];\n  const normals = [];\n  // 设置顶部z值 position uv\n  for (let j = 0; j < vertices.length / dimensions; j++) {\n    if (dimensions === 2) {\n      positions.push(vertices[j * 2], vertices[j * 2 + 1], 1, -1, -1);\n    } else {\n      positions.push(vertices[j * 3], vertices[j * 3 + 1], 1, -1, -1);\n    }\n    normals.push(0, 0, 1);\n  }\n  const triangles = earcut(\n    flattengeo.vertices,\n    flattengeo.holes,\n    flattengeo.dimensions,\n  );\n  indexArray.push(...triangles);\n  for (let i = 0; i < n; i++) {\n    const prePoint = flattengeo.vertices.slice(\n      i * dimensions,\n      (i + 1) * dimensions,\n    );\n    let nextPoint = flattengeo.vertices.slice(\n      (i + 1) * dimensions,\n      (i + 2) * dimensions,\n    );\n    if (nextPoint.length === 0) {\n      nextPoint = flattengeo.vertices.slice(0, dimensions);\n    }\n    const indexOffset = positions.length / 5;\n    positions.push(\n      prePoint[0],\n      prePoint[1],\n      1,\n      0,\n      0,\n      nextPoint[0],\n      nextPoint[1],\n      1,\n      0.1,\n      0,\n      prePoint[0],\n      prePoint[1],\n      0,\n      0,\n      0.8,\n      nextPoint[0],\n      nextPoint[1],\n      0,\n      0.1,\n      0.8,\n    );\n    const normal = computeVertexNormals(\n      [nextPoint[0], nextPoint[1], 1],\n      [prePoint[0], prePoint[1], 0],\n      [prePoint[0], prePoint[1], 1],\n      needFlat,\n    );\n    normals.push(...normal, ...normal, ...normal, ...normal);\n    indexArray.push(...[1, 2, 0, 3, 2, 1].map((v) => v + indexOffset));\n  }\n  return {\n    positions,\n    index: indexArray,\n    normals,\n  };\n}\nfunction computeVertexNormals(\n  p1: [number, number, number],\n  p2: [number, number, number],\n  p3: [number, number, number],\n  needFlat: boolean = false,\n) {\n  const cb = vec3.create();\n  const ab = vec3.create();\n  const normal = vec3.create();\n\n  if (needFlat) {\n    p1 = lngLatToMeters(p1) as [number, number, number];\n    p2 = lngLatToMeters(p2) as [number, number, number];\n    p3 = lngLatToMeters(p3) as [number, number, number];\n  }\n  const pA = vec3.fromValues(...p1);\n  const pB = vec3.fromValues(...p2);\n  const pC = vec3.fromValues(...p3);\n  vec3.sub(cb, pC, pB);\n  vec3.sub(ab, pA, pB);\n  vec3.cross(normal, cb, ab);\n  const newNormal = vec3.create();\n  vec3.normalize(newNormal, normal);\n\n  return newNormal;\n}\n"]},"metadata":{},"sourceType":"module"}