{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { ArrayExt } from '../util';\nimport { Basecoat } from '../common';\nexport var Collection = /*#__PURE__*/function (_Basecoat) {\n  _inherits(Collection, _Basecoat);\n\n  var _super = _createSuper(Collection);\n\n  function Collection(cells) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    _classCallCheck(this, Collection);\n\n    _this = _super.call(this);\n    _this.length = 0;\n    _this.comparator = options.comparator || 'zIndex';\n\n    _this.clean();\n\n    if (cells) {\n      _this.reset(cells, {\n        silent: true\n      });\n    }\n\n    return _this;\n  }\n\n  _createClass(Collection, [{\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.cells.map(function (cell) {\n        return cell.toJSON();\n      });\n    }\n  }, {\n    key: \"add\",\n    value: function add(cells, index, options) {\n      var _this2 = this;\n\n      var localIndex;\n      var localOptions;\n\n      if (typeof index === 'number') {\n        localIndex = index;\n        localOptions = Object.assign({\n          merge: false\n        }, options);\n      } else {\n        localIndex = this.length;\n        localOptions = Object.assign({\n          merge: false\n        }, index);\n      }\n\n      if (localIndex > this.length) {\n        localIndex = this.length;\n      }\n\n      if (localIndex < 0) {\n        localIndex += this.length + 1;\n      }\n\n      var entities = Array.isArray(cells) ? cells : [cells];\n      var sortable = this.comparator && typeof index !== 'number' && localOptions.sort !== false;\n      var sortAttr = this.comparator || null;\n      var sort = false;\n      var added = [];\n      var merged = [];\n      entities.forEach(function (cell) {\n        var existing = _this2.get(cell);\n\n        if (existing) {\n          if (localOptions.merge && !cell.isSameStore(existing)) {\n            existing.setProp(cell.getProp(), options); // merge\n\n            merged.push(existing);\n\n            if (sortable && !sort) {\n              if (sortAttr == null || typeof sortAttr === 'function') {\n                sort = existing.hasChanged();\n              } else if (typeof sortAttr === 'string') {\n                sort = existing.hasChanged(sortAttr);\n              } else {\n                sort = sortAttr.some(function (key) {\n                  return existing.hasChanged(key);\n                });\n              }\n            }\n          }\n        } else {\n          added.push(cell);\n\n          _this2.reference(cell);\n        }\n      });\n\n      if (added.length) {\n        var _this$cells;\n\n        if (sortable) {\n          sort = true;\n        }\n\n        (_this$cells = this.cells).splice.apply(_this$cells, [localIndex, 0].concat(added));\n\n        this.length = this.cells.length;\n      }\n\n      if (sort) {\n        this.sort({\n          silent: true\n        });\n      }\n\n      if (!localOptions.silent) {\n        added.forEach(function (cell, i) {\n          var args = {\n            cell: cell,\n            index: localIndex + i,\n            options: localOptions\n          };\n\n          _this2.trigger('added', args);\n\n          if (!localOptions.dryrun) {\n            cell.notify('added', Object.assign({}, args));\n          }\n        });\n\n        if (sort) {\n          this.trigger('sorted');\n        }\n\n        if (added.length || merged.length) {\n          this.trigger('updated', {\n            added: added,\n            merged: merged,\n            removed: [],\n            options: localOptions\n          });\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(cells) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var arr = Array.isArray(cells) ? cells : [cells];\n      var removed = this.removeCells(arr, options);\n\n      if (!options.silent && removed.length > 0) {\n        this.trigger('updated', {\n          options: options,\n          removed: removed,\n          added: [],\n          merged: []\n        });\n      }\n\n      return Array.isArray(cells) ? removed : removed[0];\n    }\n  }, {\n    key: \"removeCells\",\n    value: function removeCells(cells, options) {\n      var removed = [];\n\n      for (var i = 0; i < cells.length; i += 1) {\n        var cell = this.get(cells[i]);\n\n        if (cell == null) {\n          continue;\n        }\n\n        var index = this.cells.indexOf(cell);\n        this.cells.splice(index, 1);\n        this.length -= 1;\n        delete this.map[cell.id];\n        removed.push(cell);\n        this.unreference(cell);\n\n        if (!options.dryrun) {\n          cell.remove();\n        }\n\n        if (!options.silent) {\n          this.trigger('removed', {\n            cell: cell,\n            index: index,\n            options: options\n          });\n\n          if (!options.dryrun) {\n            cell.notify('removed', {\n              cell: cell,\n              index: index,\n              options: options\n            });\n          }\n        }\n      }\n\n      return removed;\n    }\n  }, {\n    key: \"reset\",\n    value: function reset(cells) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var previous = this.cells.slice();\n      previous.forEach(function (cell) {\n        return _this3.unreference(cell);\n      });\n      this.clean();\n      this.add(cells, Object.assign({\n        silent: true\n      }, options));\n\n      if (!options.silent) {\n        var current = this.cells.slice();\n        this.trigger('reseted', {\n          options: options,\n          previous: previous,\n          current: current\n        });\n        var added = [];\n        var removed = [];\n        current.forEach(function (a) {\n          var exist = previous.some(function (b) {\n            return b.id === a.id;\n          });\n\n          if (!exist) {\n            added.push(a);\n          }\n        });\n        previous.forEach(function (a) {\n          var exist = current.some(function (b) {\n            return b.id === a.id;\n          });\n\n          if (!exist) {\n            removed.push(a);\n          }\n        });\n        this.trigger('updated', {\n          options: options,\n          added: added,\n          removed: removed,\n          merged: []\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"push\",\n    value: function push(cell, options) {\n      return this.add(cell, this.length, options);\n    }\n  }, {\n    key: \"pop\",\n    value: function pop(options) {\n      var cell = this.at(this.length - 1);\n      return this.remove(cell, options);\n    }\n  }, {\n    key: \"unshift\",\n    value: function unshift(cell, options) {\n      return this.add(cell, 0, options);\n    }\n  }, {\n    key: \"shift\",\n    value: function shift(options) {\n      var cell = this.at(0);\n      return this.remove(cell, options);\n    }\n  }, {\n    key: \"get\",\n    value: function get(cell) {\n      if (cell == null) {\n        return null;\n      }\n\n      var id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;\n      return this.map[id] || null;\n    }\n  }, {\n    key: \"has\",\n    value: function has(cell) {\n      return this.get(cell) != null;\n    }\n  }, {\n    key: \"at\",\n    value: function at(index) {\n      if (index < 0) {\n        index += this.length; // eslint-disable-line\n      }\n\n      return this.cells[index] || null;\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.at(0);\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.at(-1);\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(cell) {\n      return this.cells.indexOf(cell);\n    }\n  }, {\n    key: \"toArray\",\n    value: function toArray() {\n      return this.cells.slice();\n    }\n  }, {\n    key: \"sort\",\n    value: function sort() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.comparator != null) {\n        this.cells = ArrayExt.sortBy(this.cells, this.comparator);\n\n        if (!options.silent) {\n          this.trigger('sorted');\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var constructor = this.constructor;\n      return new constructor(this.cells.slice(), {\n        comparator: this.comparator\n      });\n    }\n  }, {\n    key: \"reference\",\n    value: function reference(cell) {\n      this.map[cell.id] = cell;\n      cell.on('*', this.notifyCellEvent, this);\n    }\n  }, {\n    key: \"unreference\",\n    value: function unreference(cell) {\n      cell.off('*', this.notifyCellEvent, this);\n      delete this.map[cell.id];\n    }\n  }, {\n    key: \"notifyCellEvent\",\n    value: function notifyCellEvent(name, args) {\n      var cell = args.cell;\n      this.trigger(\"cell:\".concat(name), args);\n\n      if (cell) {\n        if (cell.isNode()) {\n          this.trigger(\"node:\".concat(name), Object.assign(Object.assign({}, args), {\n            node: cell\n          }));\n        } else if (cell.isEdge()) {\n          this.trigger(\"edge:\".concat(name), Object.assign(Object.assign({}, args), {\n            edge: cell\n          }));\n        }\n      }\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      this.length = 0;\n      this.cells = [];\n      this.map = {};\n    }\n  }]);\n\n  return Collection;\n}(Basecoat);","map":{"version":3,"sources":["../../src/model/collection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ArrayExt } from '../util';\nimport { Basecoat } from '../common';\nexport class Collection extends Basecoat {\n    constructor(cells, options = {}) {\n        super();\n        this.length = 0;\n        this.comparator = options.comparator || 'zIndex';\n        this.clean();\n        if (cells) {\n            this.reset(cells, { silent: true });\n        }\n    }\n    toJSON() {\n        return this.cells.map((cell) => cell.toJSON());\n    }\n    add(cells, index, options) {\n        let localIndex;\n        let localOptions;\n        if (typeof index === 'number') {\n            localIndex = index;\n            localOptions = Object.assign({ merge: false }, options);\n        }\n        else {\n            localIndex = this.length;\n            localOptions = Object.assign({ merge: false }, index);\n        }\n        if (localIndex > this.length) {\n            localIndex = this.length;\n        }\n        if (localIndex < 0) {\n            localIndex += this.length + 1;\n        }\n        const entities = Array.isArray(cells) ? cells : [cells];\n        const sortable = this.comparator &&\n            typeof index !== 'number' &&\n            localOptions.sort !== false;\n        const sortAttr = this.comparator || null;\n        let sort = false;\n        const added = [];\n        const merged = [];\n        entities.forEach((cell) => {\n            const existing = this.get(cell);\n            if (existing) {\n                if (localOptions.merge && !cell.isSameStore(existing)) {\n                    existing.setProp(cell.getProp(), options); // merge\n                    merged.push(existing);\n                    if (sortable && !sort) {\n                        if (sortAttr == null || typeof sortAttr === 'function') {\n                            sort = existing.hasChanged();\n                        }\n                        else if (typeof sortAttr === 'string') {\n                            sort = existing.hasChanged(sortAttr);\n                        }\n                        else {\n                            sort = sortAttr.some((key) => existing.hasChanged(key));\n                        }\n                    }\n                }\n            }\n            else {\n                added.push(cell);\n                this.reference(cell);\n            }\n        });\n        if (added.length) {\n            if (sortable) {\n                sort = true;\n            }\n            this.cells.splice(localIndex, 0, ...added);\n            this.length = this.cells.length;\n        }\n        if (sort) {\n            this.sort({ silent: true });\n        }\n        if (!localOptions.silent) {\n            added.forEach((cell, i) => {\n                const args = {\n                    cell,\n                    index: localIndex + i,\n                    options: localOptions,\n                };\n                this.trigger('added', args);\n                if (!localOptions.dryrun) {\n                    cell.notify('added', Object.assign({}, args));\n                }\n            });\n            if (sort) {\n                this.trigger('sorted');\n            }\n            if (added.length || merged.length) {\n                this.trigger('updated', {\n                    added,\n                    merged,\n                    removed: [],\n                    options: localOptions,\n                });\n            }\n        }\n        return this;\n    }\n    remove(cells, options = {}) {\n        const arr = Array.isArray(cells) ? cells : [cells];\n        const removed = this.removeCells(arr, options);\n        if (!options.silent && removed.length > 0) {\n            this.trigger('updated', {\n                options,\n                removed,\n                added: [],\n                merged: [],\n            });\n        }\n        return Array.isArray(cells) ? removed : removed[0];\n    }\n    removeCells(cells, options) {\n        const removed = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            const cell = this.get(cells[i]);\n            if (cell == null) {\n                continue;\n            }\n            const index = this.cells.indexOf(cell);\n            this.cells.splice(index, 1);\n            this.length -= 1;\n            delete this.map[cell.id];\n            removed.push(cell);\n            this.unreference(cell);\n            if (!options.dryrun) {\n                cell.remove();\n            }\n            if (!options.silent) {\n                this.trigger('removed', { cell, index, options });\n                if (!options.dryrun) {\n                    cell.notify('removed', { cell, index, options });\n                }\n            }\n        }\n        return removed;\n    }\n    reset(cells, options = {}) {\n        const previous = this.cells.slice();\n        previous.forEach((cell) => this.unreference(cell));\n        this.clean();\n        this.add(cells, Object.assign({ silent: true }, options));\n        if (!options.silent) {\n            const current = this.cells.slice();\n            this.trigger('reseted', {\n                options,\n                previous,\n                current,\n            });\n            const added = [];\n            const removed = [];\n            current.forEach((a) => {\n                const exist = previous.some((b) => b.id === a.id);\n                if (!exist) {\n                    added.push(a);\n                }\n            });\n            previous.forEach((a) => {\n                const exist = current.some((b) => b.id === a.id);\n                if (!exist) {\n                    removed.push(a);\n                }\n            });\n            this.trigger('updated', { options, added, removed, merged: [] });\n        }\n        return this;\n    }\n    push(cell, options) {\n        return this.add(cell, this.length, options);\n    }\n    pop(options) {\n        const cell = this.at(this.length - 1);\n        return this.remove(cell, options);\n    }\n    unshift(cell, options) {\n        return this.add(cell, 0, options);\n    }\n    shift(options) {\n        const cell = this.at(0);\n        return this.remove(cell, options);\n    }\n    get(cell) {\n        if (cell == null) {\n            return null;\n        }\n        const id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;\n        return this.map[id] || null;\n    }\n    has(cell) {\n        return this.get(cell) != null;\n    }\n    at(index) {\n        if (index < 0) {\n            index += this.length; // eslint-disable-line\n        }\n        return this.cells[index] || null;\n    }\n    first() {\n        return this.at(0);\n    }\n    last() {\n        return this.at(-1);\n    }\n    indexOf(cell) {\n        return this.cells.indexOf(cell);\n    }\n    toArray() {\n        return this.cells.slice();\n    }\n    sort(options = {}) {\n        if (this.comparator != null) {\n            this.cells = ArrayExt.sortBy(this.cells, this.comparator);\n            if (!options.silent) {\n                this.trigger('sorted');\n            }\n        }\n        return this;\n    }\n    clone() {\n        const constructor = this.constructor;\n        return new constructor(this.cells.slice(), {\n            comparator: this.comparator,\n        });\n    }\n    reference(cell) {\n        this.map[cell.id] = cell;\n        cell.on('*', this.notifyCellEvent, this);\n    }\n    unreference(cell) {\n        cell.off('*', this.notifyCellEvent, this);\n        delete this.map[cell.id];\n    }\n    notifyCellEvent(name, args) {\n        const cell = args.cell;\n        this.trigger(`cell:${name}`, args);\n        if (cell) {\n            if (cell.isNode()) {\n                this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), { node: cell }));\n            }\n            else if (cell.isEdge()) {\n                this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: cell }));\n            }\n        }\n    }\n    clean() {\n        this.length = 0;\n        this.cells = [];\n        this.map = {};\n    }\n}\n//# sourceMappingURL=collection.js.map"]},"metadata":{},"sourceType":"module"}