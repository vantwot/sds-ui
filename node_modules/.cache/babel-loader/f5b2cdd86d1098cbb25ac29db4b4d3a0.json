{"ast":null,"code":"import { ObjectExt, NumberExt, Dom, FunctionExt } from '../../util';\nexport const text = {\n  qualify(text, _ref) {\n    let {\n      attrs\n    } = _ref;\n    return attrs.textWrap == null || !ObjectExt.isPlainObject(attrs.textWrap);\n  },\n\n  set(text, _ref2) {\n    let {\n      view,\n      elem,\n      attrs\n    } = _ref2;\n    const cacheName = 'x6-text';\n    const $elem = view.$(elem);\n    const cache = $elem.data(cacheName);\n\n    const json = str => {\n      try {\n        return JSON.parse(str);\n      } catch (error) {\n        return str;\n      }\n    };\n\n    const options = {\n      x: attrs.x,\n      eol: attrs.eol,\n      annotations: json(attrs.annotations),\n      textPath: json(attrs['text-path'] || attrs.textPath),\n      textVerticalAnchor: attrs['text-vertical-anchor'] || attrs.textVerticalAnchor,\n      displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',\n      lineHeight: attrs['line-height'] || attrs.lineHeight\n    };\n    const fontSize = attrs['font-size'] || attrs.fontSize;\n    const textHash = JSON.stringify([text, options]);\n\n    if (fontSize) {\n      elem.setAttribute('font-size', fontSize);\n    } // Updates the text only if there was a change in the string\n    // or any of its attributes.\n\n\n    if (cache == null || cache !== textHash) {\n      // Text Along Path Selector\n      const textPath = options.textPath;\n\n      if (textPath != null && typeof textPath === 'object') {\n        const selector = textPath.selector;\n\n        if (typeof selector === 'string') {\n          const pathNode = view.find(selector)[0];\n\n          if (pathNode instanceof SVGPathElement) {\n            Dom.ensureId(pathNode);\n            options.textPath = Object.assign({\n              'xlink:href': `#${pathNode.id}`\n            }, textPath);\n          }\n        }\n      }\n\n      Dom.text(elem, `${text}`, options);\n      $elem.data(cacheName, textHash);\n    }\n  }\n\n};\nexport const textWrap = {\n  qualify: ObjectExt.isPlainObject,\n\n  set(val, _ref3) {\n    let {\n      view,\n      elem,\n      attrs,\n      refBBox\n    } = _ref3;\n    const info = val; // option `width`\n\n    const width = info.width || 0;\n\n    if (NumberExt.isPercentage(width)) {\n      refBBox.width *= parseFloat(width) / 100;\n    } else if (width <= 0) {\n      refBBox.width += width;\n    } else {\n      refBBox.width = width;\n    } // option `height`\n\n\n    const height = info.height || 0;\n\n    if (NumberExt.isPercentage(height)) {\n      refBBox.height *= parseFloat(height) / 100;\n    } else if (height <= 0) {\n      refBBox.height += height;\n    } else {\n      refBBox.height = height;\n    } // option `text`\n\n\n    let wrappedText;\n    let txt = info.text;\n\n    if (txt == null) {\n      txt = attrs.text;\n    }\n\n    if (txt != null) {\n      wrappedText = Dom.breakText(`${txt}`, refBBox, {\n        'font-weight': attrs['font-weight'] || attrs.fontWeight,\n        'font-size': attrs['font-size'] || attrs.fontSize,\n        'font-family': attrs['font-family'] || attrs.fontFamily,\n        lineHeight: attrs.lineHeight\n      }, {\n        svgDocument: view.graph.view.svg,\n        ellipsis: info.ellipsis,\n        hyphen: info.hyphen,\n        breakWord: info.breakWord\n      });\n    } else {\n      wrappedText = '';\n    }\n\n    FunctionExt.call(text.set, this, wrappedText, {\n      view,\n      elem,\n      attrs,\n      refBBox,\n      cell: view.cell\n    });\n  }\n\n};\n\nconst isTextInUse = (val, _ref4) => {\n  let {\n    attrs\n  } = _ref4;\n  return attrs.text !== undefined;\n};\n\nexport const lineHeight = {\n  qualify: isTextInUse\n};\nexport const textVerticalAnchor = {\n  qualify: isTextInUse\n};\nexport const textPath = {\n  qualify: isTextInUse\n};\nexport const annotations = {\n  qualify: isTextInUse\n};\nexport const eol = {\n  qualify: isTextInUse\n};\nexport const displayEmpty = {\n  qualify: isTextInUse\n};","map":{"version":3,"sources":["../../../src/registry/attr/text.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ObjectExt, NumberExt, Dom, FunctionExt, } from '../../util';\nexport const text = {\n    qualify(text, { attrs }) {\n        return attrs.textWrap == null || !ObjectExt.isPlainObject(attrs.textWrap);\n    },\n    set(text, { view, elem, attrs }) {\n        const cacheName = 'x6-text';\n        const $elem = view.$(elem);\n        const cache = $elem.data(cacheName);\n        const json = (str) => {\n            try {\n                return JSON.parse(str);\n            }\n            catch (error) {\n                return str;\n            }\n        };\n        const options = {\n            x: attrs.x,\n            eol: attrs.eol,\n            annotations: json(attrs.annotations),\n            textPath: json(attrs['text-path'] || attrs.textPath),\n            textVerticalAnchor: (attrs['text-vertical-anchor'] ||\n                attrs.textVerticalAnchor),\n            displayEmpty: (attrs['display-empty'] || attrs.displayEmpty) === 'true',\n            lineHeight: (attrs['line-height'] || attrs.lineHeight),\n        };\n        const fontSize = (attrs['font-size'] || attrs.fontSize);\n        const textHash = JSON.stringify([text, options]);\n        if (fontSize) {\n            elem.setAttribute('font-size', fontSize);\n        }\n        // Updates the text only if there was a change in the string\n        // or any of its attributes.\n        if (cache == null || cache !== textHash) {\n            // Text Along Path Selector\n            const textPath = options.textPath;\n            if (textPath != null && typeof textPath === 'object') {\n                const selector = textPath.selector;\n                if (typeof selector === 'string') {\n                    const pathNode = view.find(selector)[0];\n                    if (pathNode instanceof SVGPathElement) {\n                        Dom.ensureId(pathNode);\n                        options.textPath = Object.assign({ 'xlink:href': `#${pathNode.id}` }, textPath);\n                    }\n                }\n            }\n            Dom.text(elem, `${text}`, options);\n            $elem.data(cacheName, textHash);\n        }\n    },\n};\nexport const textWrap = {\n    qualify: ObjectExt.isPlainObject,\n    set(val, { view, elem, attrs, refBBox }) {\n        const info = val;\n        // option `width`\n        const width = info.width || 0;\n        if (NumberExt.isPercentage(width)) {\n            refBBox.width *= parseFloat(width) / 100;\n        }\n        else if (width <= 0) {\n            refBBox.width += width;\n        }\n        else {\n            refBBox.width = width;\n        }\n        // option `height`\n        const height = info.height || 0;\n        if (NumberExt.isPercentage(height)) {\n            refBBox.height *= parseFloat(height) / 100;\n        }\n        else if (height <= 0) {\n            refBBox.height += height;\n        }\n        else {\n            refBBox.height = height;\n        }\n        // option `text`\n        let wrappedText;\n        let txt = info.text;\n        if (txt == null) {\n            txt = attrs.text;\n        }\n        if (txt != null) {\n            wrappedText = Dom.breakText(`${txt}`, refBBox, {\n                'font-weight': attrs['font-weight'] || attrs.fontWeight,\n                'font-size': attrs['font-size'] || attrs.fontSize,\n                'font-family': attrs['font-family'] || attrs.fontFamily,\n                lineHeight: attrs.lineHeight,\n            }, {\n                svgDocument: view.graph.view.svg,\n                ellipsis: info.ellipsis,\n                hyphen: info.hyphen,\n                breakWord: info.breakWord,\n            });\n        }\n        else {\n            wrappedText = '';\n        }\n        FunctionExt.call(text.set, this, wrappedText, {\n            view,\n            elem,\n            attrs,\n            refBBox,\n            cell: view.cell,\n        });\n    },\n};\nconst isTextInUse = (val, { attrs }) => {\n    return attrs.text !== undefined;\n};\nexport const lineHeight = {\n    qualify: isTextInUse,\n};\nexport const textVerticalAnchor = {\n    qualify: isTextInUse,\n};\nexport const textPath = {\n    qualify: isTextInUse,\n};\nexport const annotations = {\n    qualify: isTextInUse,\n};\nexport const eol = {\n    qualify: isTextInUse,\n};\nexport const displayEmpty = {\n    qualify: isTextInUse,\n};\n//# sourceMappingURL=text.js.map"]},"metadata":{},"sourceType":"module"}