{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _dec, _class;\n\nimport { TYPES } from '@antv/l7-core';\nimport Source, { DEFAULT_DATA, DEFAULT_PARSER } from '@antv/l7-source';\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\nvar DataSourcePlugin = (_dec = injectable(), _dec(_class = function () {\n  function DataSourcePlugin() {\n    _classCallCheck(this, DataSourcePlugin);\n\n    _defineProperty(this, \"mapService\", void 0);\n  }\n\n  _createClass(DataSourcePlugin, [{\n    key: \"apply\",\n    value: function apply(layer) {\n      var _this = this;\n\n      this.mapService = layer.getContainer().get(TYPES.IMapService);\n      layer.hooks.init.tap('DataSourcePlugin', function () {\n        var source = layer.getSource();\n\n        if (!source) {\n          var _ref = layer.sourceOption || {\n            data: DEFAULT_DATA,\n            options: DEFAULT_PARSER\n          },\n              data = _ref.data,\n              options = _ref.options;\n\n          layer.setSource(new Source(data, options));\n        }\n\n        _this.updateClusterData(layer);\n      });\n      layer.hooks.beforeRenderData.tap('DataSourcePlugin', function () {\n        var neeUpdateCluster = _this.updateClusterData(layer);\n\n        var dataSourceNeedUpdate = layer.dataState.dataSourceNeedUpdate;\n        layer.dataState.dataSourceNeedUpdate = false;\n        return neeUpdateCluster || dataSourceNeedUpdate;\n      });\n    }\n  }, {\n    key: \"updateClusterData\",\n    value: function updateClusterData(layer) {\n      var source = layer.getSource();\n      var cluster = source.cluster;\n      var _source$clusterOption = source.clusterOptions,\n          _source$clusterOption2 = _source$clusterOption.zoom,\n          zoom = _source$clusterOption2 === void 0 ? 0 : _source$clusterOption2,\n          _source$clusterOption3 = _source$clusterOption.maxZoom,\n          maxZoom = _source$clusterOption3 === void 0 ? 16 : _source$clusterOption3;\n      var newZoom = this.mapService.getZoom() - 1;\n      var dataSourceNeedUpdate = layer.dataState.dataSourceNeedUpdate;\n\n      if (cluster && (dataSourceNeedUpdate || Math.abs(zoom - newZoom) > 1) && maxZoom > zoom) {\n        source.updateClusterData(Math.floor(newZoom));\n        return true;\n      }\n\n      return false;\n    }\n  }]);\n\n  return DataSourcePlugin;\n}()) || _class);\nexport { DataSourcePlugin as default };","map":{"version":3,"sources":["../../src/plugins/DataSourcePlugin.ts"],"names":["injectable","DataSourcePlugin","layer","TYPES","source","data","options","DEFAULT_PARSER","neeUpdateCluster","dataSourceNeedUpdate","cluster","zoom","maxZoom","newZoom","Math"],"mappings":";;;;;;AAAA,SAAA,KAAA,QAAA,eAAA;AAOA,OAAA,MAAA,IAAA,YAAA,EAAA,cAAA,QAAA,iBAAA;AACA,SAAA,UAAA,QAAA,WAAA;AACA,OAAA,kBAAA;IAGqBC,gB,WADpBD,UAAU,E;;;;;;;;;WAGT,SAAA,KAAA,CAAA,KAAA,EAA4B;AAAA,UAAA,KAAA,GAAA,IAAA;;AAC1B,WAAA,UAAA,GAAkBE,KAAK,CAALA,YAAAA,GAAAA,GAAAA,CAAsCC,KAAK,CAA7D,WAAkBD,CAAlB;AACAA,MAAAA,KAAK,CAALA,KAAAA,CAAAA,IAAAA,CAAAA,GAAAA,CAAAA,kBAAAA,EAAyC,YAAM;AAC7C,YAAME,MAAM,GAAGF,KAAK,CAApB,SAAeA,EAAf;;AACA,YAAI,CAAJ,MAAA,EAAa;AAEX,cAAA,IAAA,GAA0BA,KAAK,CAALA,YAAAA,IAAsB;AAC9CG,YAAAA,IAAI,EAD0C,YAAA;AAE9CC,YAAAA,OAAO,EAAEC;AAFqC,WAAhD;AAAA,cAAQF,IAAR,GAAA,IAAA,CAAA,IAAA;AAAA,cAAcC,OAAd,GAAA,IAAA,CAAA,OAAA;;AAIAJ,UAAAA,KAAK,CAALA,SAAAA,CAAgB,IAAA,MAAA,CAAA,IAAA,EAAhBA,OAAgB,CAAhBA;AACD;;AAED,QAAA,KAAI,CAAJ,iBAAA,CAAA,KAAA;AAXFA,OAAAA;AAeAA,MAAAA,KAAK,CAALA,KAAAA,CAAAA,gBAAAA,CAAAA,GAAAA,CAAAA,kBAAAA,EAAqD,YAAM;AACzD,YAAMM,gBAAgB,GAAG,KAAI,CAAJ,iBAAA,CAAzB,KAAyB,CAAzB;;AACA,YAAMC,oBAAoB,GAAGP,KAAK,CAALA,SAAAA,CAA7B,oBAAA;AACAA,QAAAA,KAAK,CAALA,SAAAA,CAAAA,oBAAAA,GAAAA,KAAAA;AACA,eAAOM,gBAAgB,IAAvB,oBAAA;AAJFN,OAAAA;AAMD;;;WAED,SAAA,iBAAA,CAAA,KAAA,EAAkD;AAChD,UAAME,MAAM,GAAGF,KAAK,CAApB,SAAeA,EAAf;AACA,UAAMQ,OAAO,GAAGN,MAAM,CAAtB,OAAA;AACA,UAAA,qBAAA,GAAmCA,MAAM,CAAzC,cAAA;AAAA,UAAA,sBAAA,GAAA,qBAAA,CAAA,IAAA;AAAA,UAAQO,IAAR,GAAA,sBAAA,KAAA,KAAA,CAAA,GAAA,CAAA,GAAA,sBAAA;AAAA,UAAA,sBAAA,GAAA,qBAAA,CAAA,OAAA;AAAA,UAAkBC,OAAlB,GAAA,sBAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,sBAAA;AACA,UAAMC,OAAO,GAAG,KAAA,UAAA,CAAA,OAAA,KAAhB,CAAA;AACA,UAAMJ,oBAAoB,GAAGP,KAAK,CAALA,SAAAA,CAA7B,oBAAA;;AAEA,UACEQ,OAAO,KACND,oBAAoB,IAAIK,IAAI,CAAJA,GAAAA,CAASH,IAAI,GAAbG,OAAAA,IADzBJ,CAAO,CAAPA,IAEAE,OAAO,GAHT,IAAA,EAIE;AACAR,QAAAA,MAAM,CAANA,iBAAAA,CAAyBU,IAAI,CAAJA,KAAAA,CAAzBV,OAAyBU,CAAzBV;AACA,eAAA,IAAA;AACD;;AACD,aAAA,KAAA;AACD;;;;;SA3CkBH,gB","sourcesContent":["import {\n  ILayer,\n  ILayerPlugin,\n  ILngLat,\n  IMapService,\n  TYPES,\n} from '@antv/l7-core';\nimport Source, { DEFAULT_DATA, DEFAULT_PARSER } from '@antv/l7-source';\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\n\n@injectable()\nexport default class DataSourcePlugin implements ILayerPlugin {\n  protected mapService: IMapService;\n  public apply(layer: ILayer) {\n    this.mapService = layer.getContainer().get<IMapService>(TYPES.IMapService);\n    layer.hooks.init.tap('DataSourcePlugin', () => {\n      const source = layer.getSource();\n      if (!source) {\n        // TODO: 允许用户不使用 layer 的 source 方法，在这里传入一个默认的替换的默认数据\n        const { data, options } = layer.sourceOption || {\n          data: DEFAULT_DATA,\n          options: DEFAULT_PARSER,\n        };\n        layer.setSource(new Source(data, options));\n      }\n\n      this.updateClusterData(layer);\n    });\n\n    // 检测数据是否需要更新\n    layer.hooks.beforeRenderData.tap('DataSourcePlugin', () => {\n      const neeUpdateCluster = this.updateClusterData(layer);\n      const dataSourceNeedUpdate = layer.dataState.dataSourceNeedUpdate;\n      layer.dataState.dataSourceNeedUpdate = false;\n      return neeUpdateCluster || dataSourceNeedUpdate;\n    });\n  }\n\n  private updateClusterData(layer: ILayer): boolean {\n    const source = layer.getSource();\n    const cluster = source.cluster;\n    const { zoom = 0, maxZoom = 16 } = source.clusterOptions;\n    const newZoom = this.mapService.getZoom() - 1;\n    const dataSourceNeedUpdate = layer.dataState.dataSourceNeedUpdate;\n    // 如果 dataSource 有更新，跳过 zoom 的判断，直接更新一次\n    if (\n      cluster &&\n      (dataSourceNeedUpdate || Math.abs(zoom - newZoom) > 1) &&\n      maxZoom > zoom\n    ) {\n      source.updateClusterData(Math.floor(newZoom));\n      return true;\n    }\n    return false;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}