{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport * as Registry from '../registry';\nimport { Dom, Vector } from '../util';\nimport { Base } from './base';\nexport class GridManager extends Base {\n  get elem() {\n    return this.view.grid;\n  }\n\n  get grid() {\n    return this.options.grid;\n  }\n\n  init() {\n    this.startListening();\n    this.draw(this.grid);\n  }\n\n  startListening() {\n    this.graph.on('scale', this.update, this);\n    this.graph.on('translate', this.update, this);\n  }\n\n  stopListening() {\n    this.graph.off('scale', this.update, this);\n    this.graph.off('translate', this.update, this);\n  }\n\n  setVisible(visible) {\n    if (this.grid.visible !== visible) {\n      this.grid.visible = visible;\n      this.update();\n    }\n  }\n\n  getGridSize() {\n    return this.grid.size;\n  }\n\n  setGridSize(size) {\n    this.grid.size = Math.max(size, 1);\n    this.update();\n  }\n\n  show() {\n    this.setVisible(true);\n    this.update();\n  }\n\n  hide() {\n    this.setVisible(false);\n    this.update();\n  }\n\n  clear() {\n    this.elem.style.backgroundImage = '';\n  }\n\n  draw(options) {\n    this.clear();\n    this.instance = null;\n    Object.assign(this.grid, options);\n    this.patterns = this.resolveGrid(options);\n    this.update();\n  }\n\n  update() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const gridSize = this.grid.size;\n\n    if (gridSize <= 1 || !this.grid.visible) {\n      return this.clear();\n    }\n\n    const ctm = this.graph.matrix();\n    const grid = this.getInstance();\n    const items = Array.isArray(options) ? options : [options];\n    this.patterns.forEach((settings, index) => {\n      const id = `pattern_${index}`;\n      const sx = ctm.a || 1;\n      const sy = ctm.d || 1;\n\n      const {\n        update,\n        markup\n      } = settings,\n            others = __rest(settings, [\"update\", \"markup\"]);\n\n      const options = Object.assign(Object.assign(Object.assign({}, others), items[index]), {\n        sx,\n        sy,\n        ox: ctm.e || 0,\n        oy: ctm.f || 0,\n        width: gridSize * sx,\n        height: gridSize * sy\n      });\n\n      if (!grid.has(id)) {\n        grid.add(id, Vector.create('pattern', {\n          id,\n          patternUnits: 'userSpaceOnUse'\n        }, Vector.createVectors(markup)).node);\n      }\n\n      const patternElem = grid.get(id);\n\n      if (typeof update === 'function') {\n        update(patternElem.childNodes[0], options);\n      }\n\n      let x = options.ox % options.width;\n\n      if (x < 0) {\n        x += options.width;\n      }\n\n      let y = options.oy % options.height;\n\n      if (y < 0) {\n        y += options.height;\n      }\n\n      Dom.attr(patternElem, {\n        x,\n        y,\n        width: options.width,\n        height: options.height\n      });\n    });\n    const base64 = new XMLSerializer().serializeToString(grid.root);\n    const url = `url(data:image/svg+xml;base64,${btoa(base64)})`;\n    this.elem.style.backgroundImage = url;\n  }\n\n  getInstance() {\n    if (!this.instance) {\n      this.instance = new Registry.Grid();\n    }\n\n    return this.instance;\n  }\n\n  resolveGrid(options) {\n    if (!options) {\n      return [];\n    }\n\n    const type = options.type;\n\n    if (type == null) {\n      return [Object.assign(Object.assign({}, Registry.Grid.presets.dot), options.args)];\n    }\n\n    const items = Registry.Grid.registry.get(type);\n\n    if (items) {\n      let args = options.args || [];\n\n      if (!Array.isArray(args)) {\n        args = [args];\n      }\n\n      return Array.isArray(items) ? items.map((item, index) => Object.assign(Object.assign({}, item), args[index])) : [Object.assign(Object.assign({}, items), args[0])];\n    }\n\n    return Registry.Grid.registry.onNotFound(type);\n  }\n\n  dispose() {\n    this.stopListening();\n    this.clear();\n  }\n\n}\n\n__decorate([Base.dispose()], GridManager.prototype, \"dispose\", null);","map":{"version":3,"sources":["../../src/graph/grid.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport * as Registry from '../registry';\nimport { Dom, Vector } from '../util';\nimport { Base } from './base';\nexport class GridManager extends Base {\n    get elem() {\n        return this.view.grid;\n    }\n    get grid() {\n        return this.options.grid;\n    }\n    init() {\n        this.startListening();\n        this.draw(this.grid);\n    }\n    startListening() {\n        this.graph.on('scale', this.update, this);\n        this.graph.on('translate', this.update, this);\n    }\n    stopListening() {\n        this.graph.off('scale', this.update, this);\n        this.graph.off('translate', this.update, this);\n    }\n    setVisible(visible) {\n        if (this.grid.visible !== visible) {\n            this.grid.visible = visible;\n            this.update();\n        }\n    }\n    getGridSize() {\n        return this.grid.size;\n    }\n    setGridSize(size) {\n        this.grid.size = Math.max(size, 1);\n        this.update();\n    }\n    show() {\n        this.setVisible(true);\n        this.update();\n    }\n    hide() {\n        this.setVisible(false);\n        this.update();\n    }\n    clear() {\n        this.elem.style.backgroundImage = '';\n    }\n    draw(options) {\n        this.clear();\n        this.instance = null;\n        Object.assign(this.grid, options);\n        this.patterns = this.resolveGrid(options);\n        this.update();\n    }\n    update(options = {}) {\n        const gridSize = this.grid.size;\n        if (gridSize <= 1 || !this.grid.visible) {\n            return this.clear();\n        }\n        const ctm = this.graph.matrix();\n        const grid = this.getInstance();\n        const items = Array.isArray(options) ? options : [options];\n        this.patterns.forEach((settings, index) => {\n            const id = `pattern_${index}`;\n            const sx = ctm.a || 1;\n            const sy = ctm.d || 1;\n            const { update, markup } = settings, others = __rest(settings, [\"update\", \"markup\"]);\n            const options = Object.assign(Object.assign(Object.assign({}, others), items[index]), { sx,\n                sy, ox: ctm.e || 0, oy: ctm.f || 0, width: gridSize * sx, height: gridSize * sy });\n            if (!grid.has(id)) {\n                grid.add(id, Vector.create('pattern', { id, patternUnits: 'userSpaceOnUse' }, Vector.createVectors(markup)).node);\n            }\n            const patternElem = grid.get(id);\n            if (typeof update === 'function') {\n                update(patternElem.childNodes[0], options);\n            }\n            let x = options.ox % options.width;\n            if (x < 0) {\n                x += options.width;\n            }\n            let y = options.oy % options.height;\n            if (y < 0) {\n                y += options.height;\n            }\n            Dom.attr(patternElem, {\n                x,\n                y,\n                width: options.width,\n                height: options.height,\n            });\n        });\n        const base64 = new XMLSerializer().serializeToString(grid.root);\n        const url = `url(data:image/svg+xml;base64,${btoa(base64)})`;\n        this.elem.style.backgroundImage = url;\n    }\n    getInstance() {\n        if (!this.instance) {\n            this.instance = new Registry.Grid();\n        }\n        return this.instance;\n    }\n    resolveGrid(options) {\n        if (!options) {\n            return [];\n        }\n        const type = options.type;\n        if (type == null) {\n            return [\n                Object.assign(Object.assign({}, Registry.Grid.presets.dot), options.args),\n            ];\n        }\n        const items = Registry.Grid.registry.get(type);\n        if (items) {\n            let args = options.args || [];\n            if (!Array.isArray(args)) {\n                args = [args];\n            }\n            return Array.isArray(items)\n                ? items.map((item, index) => (Object.assign(Object.assign({}, item), args[index])))\n                : [Object.assign(Object.assign({}, items), args[0])];\n        }\n        return Registry.Grid.registry.onNotFound(type);\n    }\n    dispose() {\n        this.stopListening();\n        this.clear();\n    }\n}\n__decorate([\n    Base.dispose()\n], GridManager.prototype, \"dispose\", null);\n//# sourceMappingURL=grid.js.map"]},"metadata":{},"sourceType":"module"}