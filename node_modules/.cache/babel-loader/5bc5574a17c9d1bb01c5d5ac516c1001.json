{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Rectangle, Polyline, Point, Angle, Path, Line } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt, FunctionExt, Dom, Vector } from '../util';\nimport { Router, Connector, NodeAnchor, EdgeAnchor, ConnectionPoint } from '../registry';\nimport { Edge } from '../model/edge';\nimport { Markup } from './markup';\nimport { CellView } from './cell';\nexport class EdgeView extends CellView {\n  constructor() {\n    super(...arguments);\n    this.POINT_ROUNDING = 2;\n    this.markerCache = {}; // #endregion\n    // #endregion\n  }\n\n  get [Symbol.toStringTag]() {\n    return EdgeView.toStringTag;\n  }\n\n  getContainerClassName() {\n    return [super.getContainerClassName(), this.prefixClassName('edge')].join(' ');\n  }\n\n  get sourceBBox() {\n    const sourceView = this.sourceView;\n\n    if (!sourceView) {\n      const sourceDef = this.cell.getSource();\n      return new Rectangle(sourceDef.x, sourceDef.y);\n    }\n\n    const sourceMagnet = this.sourceMagnet;\n\n    if (sourceView.isEdgeElement(sourceMagnet)) {\n      return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);\n    }\n\n    return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);\n  }\n\n  get targetBBox() {\n    const targetView = this.targetView;\n\n    if (!targetView) {\n      const targetDef = this.cell.getTarget();\n      return new Rectangle(targetDef.x, targetDef.y);\n    }\n\n    const targetMagnet = this.targetMagnet;\n\n    if (targetView.isEdgeElement(targetMagnet)) {\n      return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);\n    }\n\n    return targetView.getBBoxOfElement(targetMagnet || targetView.container);\n  }\n\n  isEdgeView() {\n    return true;\n  }\n\n  confirmUpdate(flag) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let ref = flag;\n\n    if (this.hasAction(ref, 'source')) {\n      if (!this.updateTerminalProperties('source')) {\n        return ref;\n      }\n\n      ref = this.removeAction(ref, 'source');\n    }\n\n    if (this.hasAction(ref, 'target')) {\n      if (!this.updateTerminalProperties('target')) {\n        return ref;\n      }\n\n      ref = this.removeAction(ref, 'target');\n    }\n\n    const graph = this.graph;\n    const sourceView = this.sourceView;\n    const targetView = this.targetView;\n\n    if (graph && (sourceView && !graph.renderer.isViewMounted(sourceView) || targetView && !graph.renderer.isViewMounted(targetView))) {\n      // Wait for the sourceView and targetView to be rendered.\n      return ref;\n    }\n\n    if (this.hasAction(ref, 'render')) {\n      this.render();\n      ref = this.removeAction(ref, ['render', 'update', 'vertices', 'labels', 'tools', 'widget']);\n      return ref;\n    }\n\n    ref = this.handleAction(ref, 'vertices', () => this.renderVertexMarkers());\n    ref = this.handleAction(ref, 'update', () => this.update(null, options));\n    ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options));\n    ref = this.handleAction(ref, 'tools', () => {\n      this.renderTools();\n      this.updateToolsPosition();\n    });\n    ref = this.handleAction(ref, 'widget', () => this.renderExternalTools());\n    return ref;\n  }\n\n  onLabelsChange() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    // Note: this optimization works in async=false mode only\n    if (this.shouldRerenderLabels(options)) {\n      this.renderLabels();\n    } else {\n      this.updateLabels();\n    }\n\n    this.updateLabelPositions();\n  }\n\n  shouldRerenderLabels() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const previousLabels = this.cell.previous('labels');\n\n    if (previousLabels == null) {\n      return true;\n    } // Here is an optimization for cases when we know, that change does\n    // not require re-rendering of all labels.\n\n\n    if ('propertyPathArray' in options && 'propertyValue' in options) {\n      // The label is setting by `prop()` method\n      const pathArray = options.propertyPathArray || [];\n      const pathLength = pathArray.length;\n\n      if (pathLength > 1) {\n        // We are changing a single label here e.g. 'labels/0/position'\n        const index = pathArray[1];\n\n        if (previousLabels[index]) {\n          if (pathLength === 2) {\n            // We are changing the entire label. Need to check if the\n            // markup is also being changed.\n            return typeof options.propertyValue === 'object' && ObjectExt.has(options.propertyValue, 'markup');\n          } // We are changing a label property but not the markup\n\n\n          if (pathArray[2] !== 'markup') {\n            return false;\n          }\n        }\n      }\n    }\n\n    return true;\n  }\n\n  render() {\n    this.empty();\n    this.containers = {};\n    this.renderMarkup();\n    this.renderLabels();\n    this.update();\n    return this;\n  }\n\n  renderMarkup() {\n    const markup = this.cell.markup;\n\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.renderStringMarkup(markup);\n      }\n\n      return this.renderJSONMarkup(markup);\n    }\n\n    throw new TypeError('Invalid edge markup.');\n  }\n\n  renderJSONMarkup(markup) {\n    const ret = this.parseJSONMarkup(markup, this.container);\n    this.selectors = ret.selectors;\n    this.container.append(ret.fragment);\n  }\n\n  renderStringMarkup(markup) {\n    const cache = this.containers;\n    const children = Vector.createVectors(markup); // Cache children elements for quicker access.\n\n    children.forEach(child => {\n      const className = child.attr('class');\n\n      if (className) {\n        cache[StringExt.camelCase(className)] = child.node;\n      }\n    });\n    this.renderTools();\n    this.renderVertexMarkers();\n    this.renderArrowheadMarkers();\n    Dom.append(this.container, children.map(child => child.node));\n  }\n\n  renderLabels() {\n    const edge = this.cell;\n    const labels = edge.getLabels();\n    const count = labels.length;\n    let container = this.containers.labels;\n    this.labelCache = {};\n    this.labelSelectors = {};\n\n    if (count <= 0) {\n      if (container && container.parentNode) {\n        container.parentNode.removeChild(container);\n      }\n\n      return this;\n    }\n\n    if (container) {\n      this.empty(container);\n    } else {\n      container = Dom.createSvgElement('g');\n      this.addClass(this.prefixClassName('edge-labels'), container);\n      this.containers.labels = container;\n    }\n\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i];\n      const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));\n      let labelNode;\n      let selectors;\n\n      if (normalized) {\n        labelNode = normalized.node;\n        selectors = normalized.selectors;\n      } else {\n        const defaultLabel = edge.getDefaultLabel();\n        const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));\n        labelNode = normalized.node;\n        selectors = normalized.selectors;\n      }\n\n      labelNode.setAttribute('data-index', `${i}`);\n      container.appendChild(labelNode);\n      const rootSelector = this.rootSelector;\n\n      if (selectors[rootSelector]) {\n        throw new Error('Ambiguous label root selector.');\n      }\n\n      selectors[rootSelector] = labelNode;\n      this.labelCache[i] = labelNode;\n      this.labelSelectors[i] = selectors;\n    }\n\n    if (container.parentNode == null) {\n      this.container.appendChild(container);\n    }\n\n    this.updateLabels();\n    this.customizeLabels();\n    return this;\n  }\n\n  parseLabelMarkup(markup) {\n    if (markup) {\n      if (typeof markup === 'string') {\n        return this.parseLabelStringMarkup(markup);\n      }\n\n      return this.parseJSONMarkup(markup);\n    }\n\n    return null;\n  }\n\n  parseLabelStringMarkup(labelMarkup) {\n    const children = Vector.createVectors(labelMarkup);\n    const fragment = document.createDocumentFragment();\n\n    for (let i = 0, n = children.length; i < n; i += 1) {\n      const currentChild = children[i].node;\n      fragment.appendChild(currentChild);\n    }\n\n    return {\n      fragment,\n      selectors: {}\n    };\n  }\n\n  normalizeLabelMarkup(markup) {\n    if (markup == null) {\n      return;\n    }\n\n    const fragment = markup.fragment;\n\n    if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n      throw new Error('Invalid label markup.');\n    }\n\n    let vel;\n    const childNodes = fragment.childNodes;\n\n    if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n      // default markup fragment is not wrapped in `<g/>`\n      // add a `<g/>` container\n      vel = Vector.create('g').append(fragment);\n    } else {\n      vel = Vector.create(childNodes[0]);\n    }\n\n    vel.addClass(this.prefixClassName('edge-label'));\n    return {\n      node: vel.node,\n      selectors: markup.selectors\n    };\n  }\n\n  updateLabels() {\n    if (this.containers.labels) {\n      const edge = this.cell;\n      const labels = edge.labels;\n      const canLabelMove = this.can('edgeLabelMovable');\n      const defaultLabel = edge.getDefaultLabel();\n\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const elem = this.labelCache[i];\n        const selectors = this.labelSelectors[i];\n        elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n        const label = labels[i];\n        const attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs);\n        this.updateAttrs(elem, attrs, {\n          selectors,\n          rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined\n        });\n      }\n    }\n  }\n\n  mergeLabelAttrs(hasCustomMarkup, labelAttrs, defaultLabelAttrs) {\n    if (labelAttrs === null) {\n      return null;\n    }\n\n    if (labelAttrs === undefined) {\n      if (defaultLabelAttrs === null) {\n        return null;\n      }\n\n      if (defaultLabelAttrs === undefined) {\n        return undefined;\n      }\n\n      if (hasCustomMarkup) {\n        return defaultLabelAttrs;\n      }\n\n      return ObjectExt.merge({}, defaultLabelAttrs);\n    }\n\n    if (hasCustomMarkup) {\n      return ObjectExt.merge({}, defaultLabelAttrs, labelAttrs);\n    }\n  }\n\n  customizeLabels() {\n    if (this.containers.labels) {\n      const edge = this.cell;\n      const labels = edge.labels;\n\n      for (let i = 0, n = labels.length; i < n; i += 1) {\n        const label = labels[i];\n        const container = this.labelCache[i];\n        const selectors = this.labelSelectors[i];\n        this.graph.hook.onEdgeLabelRendered({\n          edge,\n          label,\n          container,\n          selectors\n        });\n      }\n    }\n  }\n\n  renderTools() {\n    const container = this.containers.tools;\n\n    if (container == null) {\n      return this;\n    }\n\n    const markup = this.cell.toolMarkup;\n    const $container = this.$(container).empty();\n\n    if (Markup.isStringMarkup(markup)) {\n      let template = StringExt.template(markup);\n      const tool = Vector.create(template());\n      $container.append(tool.node);\n      this.toolCache = tool.node; // If `doubleTools` is enabled, we render copy of the tools on the\n      // other side of the edge as well but only if the edge is longer\n      // than `longLength`.\n\n      if (this.options.doubleTools) {\n        let tool2;\n        const doubleToolMarkup = this.cell.doubleToolMarkup;\n\n        if (Markup.isStringMarkup(doubleToolMarkup)) {\n          template = StringExt.template(doubleToolMarkup);\n          tool2 = Vector.create(template());\n        } else {\n          tool2 = tool.clone();\n        }\n\n        $container.append(tool2.node);\n        this.tool2Cache = tool2.node;\n      }\n    }\n\n    return this;\n  }\n\n  renderExternalTools() {\n    const tools = this.cell.getTools();\n    this.addTools(tools);\n    return this;\n  }\n\n  renderVertexMarkers() {\n    const container = this.containers.vertices;\n\n    if (container == null) {\n      return this;\n    }\n\n    const markup = this.cell.vertexMarkup;\n    const $container = this.$(container).empty();\n\n    if (Markup.isStringMarkup(markup)) {\n      const template = StringExt.template(markup);\n      this.cell.getVertices().forEach((vertex, index) => {\n        $container.append(Vector.create(template(Object.assign({\n          index\n        }, vertex))).node);\n      });\n    }\n\n    return this;\n  }\n\n  renderArrowheadMarkers() {\n    const container = this.containers.arrowheads;\n\n    if (container == null) {\n      return this;\n    }\n\n    const markup = this.cell.arrowheadMarkup;\n    const $container = this.$(container).empty();\n\n    if (Markup.isStringMarkup(markup)) {\n      const template = StringExt.template(markup);\n      const sourceArrowhead = Vector.create(template({\n        end: 'source'\n      })).node;\n      const targetArrowhead = Vector.create(template({\n        end: 'target'\n      })).node;\n      this.containers.sourceArrowhead = sourceArrowhead;\n      this.containers.targetArrowhead = targetArrowhead;\n      $container.append(sourceArrowhead, targetArrowhead);\n    }\n\n    return this;\n  } // #endregion\n  // #region updating\n\n\n  update(partialAttrs) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.cleanCache();\n    this.updateConnection(options);\n    const attrs = this.cell.getAttrs();\n\n    if (attrs != null) {\n      this.updateAttrs(this.container, attrs, {\n        attrs: partialAttrs === attrs ? null : partialAttrs,\n        selectors: this.selectors\n      });\n    }\n\n    this.updateConnectionPath();\n    this.updateLabelPositions();\n    this.updateToolsPosition();\n    this.updateArrowheadMarkers();\n\n    if (options.toolId == null) {\n      this.renderExternalTools();\n    } else {\n      this.updateTools(options);\n    }\n\n    return this;\n  }\n\n  removeRedundantLinearVertices() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const edge = this.cell;\n    const vertices = edge.getVertices();\n    const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n    const rawCount = routePoints.length; // Puts the route points into a polyline and try to simplify.\n\n    const polyline = new Polyline(routePoints);\n    polyline.simplify({\n      threshold: 0.01\n    });\n    const simplifiedPoints = polyline.points.map(point => point.toJSON());\n    const simplifiedCount = simplifiedPoints.length; // If simplification did not remove any redundant vertices.\n\n    if (rawCount === simplifiedCount) {\n      return 0;\n    } // Sets simplified polyline points as edge vertices.\n    // Removes first and last polyline points again (source/target anchors).\n\n\n    edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);\n    return rawCount - simplifiedCount;\n  }\n\n  updateConnectionPath() {\n    const containers = this.containers;\n\n    if (containers.connection) {\n      const pathData = this.getConnectionPathData();\n      containers.connection.setAttribute('d', pathData);\n    }\n\n    if (containers.connectionWrap) {\n      const pathData = this.getConnectionPathData();\n      containers.connectionWrap.setAttribute('d', pathData);\n    }\n\n    if (containers.sourceMarker && containers.targetMarker) {\n      this.translateAndAutoOrientArrows(containers.sourceMarker, containers.targetMarker);\n    }\n  }\n\n  getTerminalView(type) {\n    switch (type) {\n      case 'source':\n        return this.sourceView || null;\n\n      case 'target':\n        return this.targetView || null;\n\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n\n  getTerminalAnchor(type) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourceAnchor);\n\n      case 'target':\n        return Point.create(this.targetAnchor);\n\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n\n  getTerminalConnectionPoint(type) {\n    switch (type) {\n      case 'source':\n        return Point.create(this.sourcePoint);\n\n      case 'target':\n        return Point.create(this.targetPoint);\n\n      default:\n        throw new Error(`Unknown terminal type '${type}'`);\n    }\n  }\n\n  getTerminalMagnet(type) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    switch (type) {\n      case 'source':\n        {\n          if (options.raw) {\n            return this.sourceMagnet;\n          }\n\n          const sourceView = this.sourceView;\n\n          if (!sourceView) {\n            return null;\n          }\n\n          return this.sourceMagnet || sourceView.container;\n        }\n\n      case 'target':\n        {\n          if (options.raw) {\n            return this.targetMagnet;\n          }\n\n          const targetView = this.targetView;\n\n          if (!targetView) {\n            return null;\n          }\n\n          return this.targetMagnet || targetView.container;\n        }\n\n      default:\n        {\n          throw new Error(`Unknown terminal type '${type}'`);\n        }\n    }\n  }\n\n  updateConnection() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const edge = this.cell; // The edge is being translated by an ancestor that will shift\n    // source, target and vertices by an equal distance.\n\n    if (options.translateBy && edge.isFragmentDescendantOf(options.translateBy)) {\n      const tx = options.tx || 0;\n      const ty = options.ty || 0;\n      this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;\n      this.translateConnectionPoints(tx, ty);\n      this.path.translate(tx, ty);\n    } else {\n      const vertices = edge.getVertices(); // 1. Find anchor points\n\n      const anchors = this.findAnchors(vertices);\n      this.sourceAnchor = anchors.source;\n      this.targetAnchor = anchors.target; // 2. Find route points\n\n      this.routePoints = this.findRoutePoints(vertices); // 3. Find connection points\n\n      const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);\n      this.sourcePoint = connectionPoints.source;\n      this.targetPoint = connectionPoints.target; // 4. Find Marker Connection Point\n\n      const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint); // 5. Make path\n\n      this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);\n    }\n\n    this.cleanCache();\n  }\n\n  findAnchors(vertices) {\n    const edge = this.cell;\n    const source = edge.source;\n    const target = edge.target;\n    const firstVertex = vertices[0];\n    const lastVertex = vertices[vertices.length - 1];\n\n    if (target.priority && !source.priority) {\n      // Reversed order\n      return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n    } // Usual order\n\n\n    return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n  }\n\n  findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {\n    let firstAnchor;\n    let secondAnchor;\n    const edge = this.cell;\n    const firstTerminal = edge[firstType];\n    const secondTerminal = edge[secondType];\n    const firstView = this.getTerminalView(firstType);\n    const secondView = this.getTerminalView(secondType);\n    const firstMagnet = this.getTerminalMagnet(firstType);\n    const secondMagnet = this.getTerminalMagnet(secondType);\n\n    if (firstView) {\n      let firstRef;\n\n      if (firstPoint) {\n        firstRef = Point.create(firstPoint);\n      } else if (secondView) {\n        firstRef = secondMagnet;\n      } else {\n        firstRef = Point.create(secondTerminal);\n      }\n\n      firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);\n    } else {\n      firstAnchor = Point.create(firstTerminal);\n    }\n\n    if (secondView) {\n      const secondRef = Point.create(secondPoint || firstAnchor);\n      secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);\n    } else {\n      secondAnchor = Point.isPointLike(secondTerminal) ? Point.create(secondTerminal) : new Point();\n    }\n\n    return {\n      [firstType]: firstAnchor,\n      [secondType]: secondAnchor\n    };\n  }\n\n  getAnchor(def, cellView, magnet, ref, terminalType) {\n    const isEdge = cellView.isEdgeElement(magnet);\n    const connecting = this.graph.options.connecting;\n    let config = typeof def === 'string' ? {\n      name: def\n    } : def;\n\n    if (!config) {\n      const defaults = isEdge ? (terminalType === 'source' ? connecting.sourceEdgeAnchor : connecting.targetEdgeAnchor) || connecting.edgeAnchor : (terminalType === 'source' ? connecting.sourceAnchor : connecting.targetAnchor) || connecting.anchor;\n      config = typeof defaults === 'string' ? {\n        name: defaults\n      } : defaults;\n    }\n\n    if (!config) {\n      throw new Error(`Anchor should be specified.`);\n    }\n\n    let anchor;\n    const name = config.name;\n\n    if (isEdge) {\n      const fn = EdgeAnchor.registry.get(name);\n\n      if (typeof fn !== 'function') {\n        return EdgeAnchor.registry.onNotFound(name);\n      }\n\n      anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n    } else {\n      const fn = NodeAnchor.registry.get(name);\n\n      if (typeof fn !== 'function') {\n        return NodeAnchor.registry.onNotFound(name);\n      }\n\n      anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n    }\n\n    return anchor ? anchor.round(this.POINT_ROUNDING) : new Point();\n  }\n\n  findRoutePoints() {\n    let vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    const defaultRouter = this.graph.options.connecting.router || Router.presets.normal;\n    const router = this.cell.getRouter() || defaultRouter;\n    let routePoints;\n\n    if (typeof router === 'function') {\n      routePoints = FunctionExt.call(router, this, vertices, {}, this);\n    } else {\n      const name = typeof router === 'string' ? router : router.name;\n      const args = typeof router === 'string' ? {} : router.args || {};\n      const fn = name ? Router.registry.get(name) : Router.presets.normal;\n\n      if (typeof fn !== 'function') {\n        return Router.registry.onNotFound(name);\n      }\n\n      routePoints = FunctionExt.call(fn, this, vertices, args, this);\n    }\n\n    return routePoints == null ? vertices.map(p => Point.create(p)) : routePoints.map(p => Point.create(p));\n  }\n\n  findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {\n    const edge = this.cell;\n    const connecting = this.graph.options.connecting;\n    const sourceTerminal = edge.getSource();\n    const targetTerminal = edge.getTarget();\n    const sourceView = this.sourceView;\n    const targetView = this.targetView;\n    const firstRoutePoint = routePoints[0];\n    const lastRoutePoint = routePoints[routePoints.length - 1]; // source\n\n    let sourcePoint;\n\n    if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n      const sourceMagnet = this.sourceMagnet || sourceView.container;\n      const sourcePointRef = firstRoutePoint || targetAnchor;\n      const sourceLine = new Line(sourcePointRef, sourceAnchor);\n      const connectionPointDef = sourceTerminal.connectionPoint || connecting.sourceConnectionPoint || connecting.connectionPoint;\n      sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n    } else {\n      sourcePoint = sourceAnchor;\n    } // target\n\n\n    let targetPoint;\n\n    if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n      const targetMagnet = this.targetMagnet || targetView.container;\n      const targetConnectionPointDef = targetTerminal.connectionPoint || connecting.targetConnectionPoint || connecting.connectionPoint;\n      const targetPointRef = lastRoutePoint || sourceAnchor;\n      const targetLine = new Line(targetPointRef, targetAnchor);\n      targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n    } else {\n      targetPoint = targetAnchor;\n    }\n\n    return {\n      source: sourcePoint,\n      target: targetPoint\n    };\n  }\n\n  getConnectionPoint(def, view, magnet, line, endType) {\n    const anchor = line.end;\n\n    if (def == null) {\n      return anchor;\n    }\n\n    const name = typeof def === 'string' ? def : def.name;\n    const args = typeof def === 'string' ? {} : def.args;\n    const fn = ConnectionPoint.registry.get(name);\n\n    if (typeof fn !== 'function') {\n      return ConnectionPoint.registry.onNotFound(name);\n    }\n\n    const connectionPoint = FunctionExt.call(fn, this, line, view, magnet, args || {}, endType);\n    return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;\n  }\n\n  updateMarkerAttr(type) {\n    const attrs = this.cell.getAttrs();\n    const key = `.${type}-marker`;\n    const partial = attrs && attrs[key];\n\n    if (partial) {\n      this.updateAttrs(this.container, {}, {\n        attrs: {\n          [key]: partial\n        },\n        selectors: this.selectors\n      });\n    }\n  }\n\n  findMarkerPoints(routePoints, sourcePoint, targetPoint) {\n    const getLineWidth = type => {\n      const attrs = this.cell.getAttrs();\n      const keys = Object.keys(attrs);\n\n      for (let i = 0, l = keys.length; i < l; i += 1) {\n        const attr = attrs[keys[i]];\n\n        if (attr[`${type}Marker`] || attr[`${type}-marker`]) {\n          const strokeWidth = attr.strokeWidth || attr['stroke-width'];\n\n          if (strokeWidth) {\n            return parseFloat(strokeWidth);\n          }\n\n          break;\n        }\n      }\n\n      return null;\n    };\n\n    const firstRoutePoint = routePoints[0];\n    const lastRoutePoint = routePoints[routePoints.length - 1];\n    const sourceMarkerElem = this.containers.sourceMarker;\n    const targetMarkerElem = this.containers.targetMarker;\n    const cache = this.markerCache;\n    let sourceMarkerPoint;\n    let targetMarkerPoint; // Move the source point by the width of the marker taking into\n    // account its scale around x-axis. Note that scale is the only\n    // transform that makes sense to be set in `.marker-source`\n    // attributes object as all other transforms (translate/rotate)\n    // will be replaced by the `translateAndAutoOrient()` function.\n\n    if (sourceMarkerElem) {\n      this.updateMarkerAttr('source'); // support marker connection point registry???\n\n      cache.sourceBBox = cache.sourceBBox || Dom.getBBox(sourceMarkerElem);\n\n      if (cache.sourceBBox.width > 0) {\n        const scale = Dom.scale(sourceMarkerElem);\n        sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, cache.sourceBBox.width * scale.sx * -1);\n      }\n    } else {\n      const strokeWidth = getLineWidth('source');\n\n      if (strokeWidth) {\n        sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, -strokeWidth);\n      }\n    }\n\n    if (targetMarkerElem) {\n      this.updateMarkerAttr('target');\n      cache.targetBBox = cache.targetBBox || Dom.getBBox(targetMarkerElem);\n\n      if (cache.targetBBox.width > 0) {\n        const scale = Dom.scale(targetMarkerElem);\n        targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, cache.targetBBox.width * scale.sx * -1);\n      }\n    } else {\n      const strokeWidth = getLineWidth('target');\n\n      if (strokeWidth) {\n        targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, -strokeWidth);\n      }\n    } // If there was no markup for the marker, use the connection point.\n\n\n    cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n    cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n    return {\n      source: sourceMarkerPoint,\n      target: targetMarkerPoint\n    };\n  }\n\n  findPath(routePoints, sourcePoint, targetPoint) {\n    const def = this.cell.getConnector() || this.graph.options.connecting.connector;\n    let name;\n    let args;\n    let fn;\n\n    if (typeof def === 'string') {\n      name = def;\n    } else {\n      name = def.name;\n      args = def.args;\n    }\n\n    if (name) {\n      const method = Connector.registry.get(name);\n\n      if (typeof method !== 'function') {\n        return Connector.registry.onNotFound(name);\n      }\n\n      fn = method;\n    } else {\n      fn = Connector.presets.normal;\n    }\n\n    const path = FunctionExt.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), {\n      raw: true\n    }), this);\n    return typeof path === 'string' ? Path.parse(path) : path;\n  }\n\n  translateConnectionPoints(tx, ty) {\n    const cache = this.markerCache;\n\n    if (cache.sourcePoint) {\n      cache.sourcePoint.translate(tx, ty);\n    }\n\n    if (cache.targetPoint) {\n      cache.targetPoint.translate(tx, ty);\n    }\n\n    this.sourcePoint.translate(tx, ty);\n    this.targetPoint.translate(tx, ty);\n    this.sourceAnchor.translate(tx, ty);\n    this.targetAnchor.translate(tx, ty);\n  }\n\n  updateLabelPositions() {\n    if (this.containers.labels == null) {\n      return this;\n    }\n\n    const path = this.path;\n\n    if (!path) {\n      return this;\n    }\n\n    const edge = this.cell;\n    const labels = edge.getLabels();\n\n    if (labels.length === 0) {\n      return this;\n    }\n\n    const defaultLabel = edge.getDefaultLabel();\n    const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);\n\n    for (let i = 0, ii = labels.length; i < ii; i += 1) {\n      const label = labels[i];\n      const labelPosition = this.normalizeLabelPosition(label.position);\n      const pos = ObjectExt.merge({}, defaultPosition, labelPosition);\n      const matrix = this.getLabelTransformationMatrix(pos);\n      this.labelCache[i].setAttribute('transform', Dom.matrixToTransformString(matrix));\n    }\n\n    return this;\n  }\n\n  updateToolsPosition() {\n    if (this.containers.tools == null) {\n      return this;\n    } // Move the tools a bit to the target position but don't cover the\n    // `sourceArrowhead` marker. Note that the offset is hardcoded here.\n    // The offset should be always more than the\n    // `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n    // this up all the time would be slow.\n\n\n    let scale = '';\n    let offset = this.options.toolsOffset;\n    const connectionLength = this.getConnectionLength(); // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).\n    // In that case we won't update tools position at all.\n\n    if (connectionLength != null) {\n      // If the edge is too short, make the tools half the\n      // size and the offset twice as low.\n      if (connectionLength < this.options.shortLength) {\n        scale = 'scale(.5)';\n        offset /= 2;\n      }\n\n      let pos = this.getPointAtLength(offset);\n\n      if (pos != null) {\n        Dom.attr(this.toolCache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);\n      }\n\n      if (this.options.doubleTools && connectionLength >= this.options.longLength) {\n        const doubleToolsOffset = this.options.doubleToolsOffset || offset;\n        pos = this.getPointAtLength(connectionLength - doubleToolsOffset);\n\n        if (pos != null) {\n          Dom.attr(this.tool2Cache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);\n        }\n\n        Dom.attr(this.tool2Cache, 'visibility', 'visible');\n      } else if (this.options.doubleTools) {\n        Dom.attr(this.tool2Cache, 'visibility', 'hidden');\n      }\n    }\n\n    return this;\n  }\n\n  updateArrowheadMarkers() {\n    const container = this.containers.arrowheads;\n\n    if (container == null) {\n      return this;\n    }\n\n    if (container.style.display === 'none') {\n      return this;\n    }\n\n    const sourceArrowhead = this.containers.sourceArrowhead;\n    const targetArrowhead = this.containers.targetArrowhead;\n\n    if (sourceArrowhead && targetArrowhead) {\n      const len = this.getConnectionLength() || 0;\n      const sx = len < this.options.shortLength ? 0.5 : 1;\n      Dom.scale(sourceArrowhead, sx);\n      Dom.scale(targetArrowhead, sx);\n      this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead);\n    }\n\n    return this;\n  }\n\n  updateTerminalProperties(type) {\n    const edge = this.cell;\n    const graph = this.graph;\n    const terminal = edge[type];\n    const nodeId = terminal && terminal.cell;\n    const viewKey = `${type}View`; // terminal is a point\n\n    if (!nodeId) {\n      this[viewKey] = null;\n      this.updateTerminalMagnet(type);\n      return true;\n    }\n\n    const terminalCell = graph.getCellById(nodeId);\n\n    if (!terminalCell) {\n      throw new Error(`Edge's ${type} node with id \"${nodeId}\" not exists`);\n    }\n\n    const endView = terminalCell.findView(graph);\n\n    if (!endView) {\n      return false;\n    }\n\n    this[viewKey] = endView;\n    this.updateTerminalMagnet(type);\n    return true;\n  }\n\n  updateTerminalMagnet(type) {\n    const propName = `${type}Magnet`;\n    const terminalView = this.getTerminalView(type);\n\n    if (terminalView) {\n      let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);\n\n      if (magnet === terminalView.container) {\n        magnet = null;\n      }\n\n      this[propName] = magnet;\n    } else {\n      this[propName] = null;\n    }\n  }\n\n  translateAndAutoOrientArrows(sourceArrow, targetArrow) {\n    const route = this.routePoints;\n\n    if (sourceArrow) {\n      Dom.translateAndAutoOrient(sourceArrow, this.sourcePoint, route[0] || this.targetPoint, this.graph.view.stage);\n    }\n\n    if (targetArrow) {\n      Dom.translateAndAutoOrient(targetArrow, this.targetPoint, route[route.length - 1] || this.sourcePoint, this.graph.view.stage);\n    }\n  }\n\n  getLabelPositionAngle(idx) {\n    const label = this.cell.getLabelAt(idx);\n\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.angle || 0;\n    }\n\n    return 0;\n  }\n\n  getLabelPositionArgs(idx) {\n    const label = this.cell.getLabelAt(idx);\n\n    if (label && label.position && typeof label.position === 'object') {\n      return label.position.options;\n    }\n  }\n\n  getDefaultLabelPositionArgs() {\n    const defaultLabel = this.cell.getDefaultLabel();\n\n    if (defaultLabel && defaultLabel.position && typeof defaultLabel.position === 'object') {\n      return defaultLabel.position.options;\n    }\n  } // merge default label position args into label position args\n  // keep `undefined` or `null` because `{}` means something else\n\n\n  mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {\n    if (labelPositionArgs === null) {\n      return null;\n    }\n\n    if (labelPositionArgs === undefined) {\n      if (defaultLabelPositionArgs === null) {\n        return null;\n      }\n\n      return defaultLabelPositionArgs;\n    }\n\n    return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs);\n  }\n\n  addLabel(p1, p2, p3, options) {\n    let localX;\n    let localY;\n    let localAngle = 0;\n    let localOptions;\n\n    if (typeof p1 !== 'number') {\n      localX = p1.x;\n      localY = p1.y;\n\n      if (typeof p2 === 'number') {\n        localAngle = p2;\n        localOptions = p3;\n      } else {\n        localOptions = p2;\n      }\n    } else {\n      localX = p1;\n      localY = p2;\n\n      if (typeof p3 === 'number') {\n        localAngle = p3;\n        localOptions = options;\n      } else {\n        localOptions = p3;\n      }\n    } // merge label position arguments\n\n\n    const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n    const labelPositionArgs = localOptions;\n    const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs); // append label to labels array\n\n    const label = {\n      position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n    };\n    const index = -1;\n    this.cell.insertLabel(label, index, localOptions);\n    return index;\n  }\n\n  addVertex(x, y, options) {\n    const isPoint = typeof x !== 'number';\n    const localX = isPoint ? x.x : x;\n    const localY = isPoint ? x.y : y;\n    const localOptions = isPoint ? y : options;\n    const vertex = {\n      x: localX,\n      y: localY\n    };\n    const index = this.getVertexIndex(localX, localY);\n    this.cell.insertVertex(vertex, index, localOptions);\n    return index;\n  }\n\n  sendToken(token, options, callback) {\n    let duration;\n    let reversed;\n    let selector;\n    let rorate;\n    let timing = 'linear';\n\n    if (typeof options === 'object') {\n      duration = options.duration;\n      reversed = options.reversed === true;\n      selector = options.selector;\n\n      if (options.rotate === false) {\n        rorate = '';\n      } else if (options.rotate === true) {\n        rorate = 'auto';\n      } else if (options.rotate != null) {\n        rorate = `${options.rotate}`;\n      }\n\n      if (options.timing) {\n        timing = options.timing;\n      }\n    } else {\n      duration = options;\n      reversed = false;\n      selector = null;\n    }\n\n    duration = duration || 1000;\n    const attrs = {\n      dur: `${duration}ms`,\n      repeatCount: '1',\n      calcMode: timing,\n      fill: 'freeze'\n    };\n\n    if (rorate) {\n      attrs.rotate = rorate;\n    }\n\n    if (reversed) {\n      attrs.keyPoints = '1;0';\n      attrs.keyTimes = '0;1';\n    }\n\n    if (typeof options === 'object') {\n      const {\n        duration,\n        reversed,\n        selector,\n        rotate,\n        timing\n      } = options,\n            others = __rest(options, [\"duration\", \"reversed\", \"selector\", \"rotate\", \"timing\"]);\n\n      Object.keys(others).forEach(key => {\n        attrs[key] = others[key];\n      });\n    }\n\n    let path;\n\n    if (typeof selector === 'string') {\n      path = this.findOne(selector, this.container, this.selectors);\n    } else {\n      // Select connection path automatically.\n      path = this.containers.connection ? this.containers.connection : this.container.querySelector('path');\n    }\n\n    if (!(path instanceof SVGPathElement)) {\n      throw new Error('Token animation requires a valid connection path.');\n    }\n\n    const target = typeof token === 'string' ? this.findOne(token) : token;\n\n    if (target == null) {\n      throw new Error('Token animation requires a valid token element.');\n    }\n\n    const parent = target.parentNode;\n\n    const revert = () => {\n      if (!parent) {\n        Dom.remove(target);\n      }\n    };\n\n    const vToken = Vector.create(target);\n\n    if (!parent) {\n      vToken.appendTo(this.graph.view.stage);\n    }\n\n    const onComplete = attrs.complete;\n\n    attrs.complete = e => {\n      revert();\n\n      if (callback) {\n        callback();\n      }\n\n      if (onComplete) {\n        onComplete(e);\n      }\n    };\n\n    const stop = vToken.animateAlongPath(attrs, path);\n    return () => {\n      revert();\n      stop();\n    };\n  } // #endregion\n\n\n  getConnection() {\n    return this.path != null ? this.path.clone() : null;\n  }\n\n  getConnectionPathData() {\n    if (this.path == null) {\n      return '';\n    }\n\n    const cache = this.cache.pathCache;\n\n    if (!ObjectExt.has(cache, 'data')) {\n      cache.data = this.path.serialize();\n    }\n\n    return cache.data || '';\n  }\n\n  getConnectionSubdivisions() {\n    if (this.path == null) {\n      return null;\n    }\n\n    const cache = this.cache.pathCache;\n\n    if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n      cache.segmentSubdivisions = this.path.getSegmentSubdivisions();\n    }\n\n    return cache.segmentSubdivisions;\n  }\n\n  getConnectionLength() {\n    if (this.path == null) {\n      return 0;\n    }\n\n    const cache = this.cache.pathCache;\n\n    if (!ObjectExt.has(cache, 'length')) {\n      cache.length = this.path.length({\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n\n    return cache.length;\n  }\n\n  getPointAtLength(length) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.pointAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getPointAtRatio(ratio) {\n    if (this.path == null) {\n      return null;\n    }\n\n    if (NumberExt.isPercentage(ratio)) {\n      // eslint-disable-next-line\n      ratio = parseFloat(ratio) / 100;\n    }\n\n    return this.path.pointAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getTangentAtLength(length) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.tangentAtLength(length, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getTangentAtRatio(ratio) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.tangentAt(ratio, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getClosestPoint(point) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.closestPoint(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getClosestPointLength(point) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.closestPointLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getClosestPointRatio(point) {\n    if (this.path == null) {\n      return null;\n    }\n\n    return this.path.closestPointNormalizedLength(point, {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    });\n  }\n\n  getLabelPosition(x, y, p3, p4) {\n    const pos = {\n      distance: 0\n    }; // normalize data from the two possible signatures\n\n    let angle = 0;\n    let options;\n\n    if (typeof p3 === 'number') {\n      angle = p3;\n      options = p4;\n    } else {\n      options = p3;\n    }\n\n    if (options != null) {\n      pos.options = options;\n    } // identify distance/offset settings\n\n\n    const isOffsetAbsolute = options && options.absoluteOffset;\n    const isDistanceRelative = !(options && options.absoluteDistance);\n    const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance; // find closest point t\n\n    const path = this.path;\n    const pathOptions = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    const labelPoint = new Point(x, y);\n    const t = path.closestPointT(labelPoint, pathOptions); // distance\n\n    const totalLength = this.getConnectionLength() || 0;\n    let labelDistance = path.lengthAtT(t, pathOptions);\n\n    if (isDistanceRelative) {\n      labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;\n    }\n\n    if (isDistanceAbsoluteReverse) {\n      // fix for end point (-0 => 1)\n      labelDistance = -1 * (totalLength - labelDistance) || 1;\n    }\n\n    pos.distance = labelDistance; // offset\n    // use absolute offset if:\n    // - options.absoluteOffset is true,\n    // - options.absoluteOffset is not true but there is no tangent\n\n    let tangent;\n    if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n    let labelOffset;\n\n    if (tangent) {\n      labelOffset = tangent.pointOffset(labelPoint);\n    } else {\n      const closestPoint = path.pointAtT(t);\n      const labelOffsetDiff = labelPoint.diff(closestPoint);\n      labelOffset = {\n        x: labelOffsetDiff.x,\n        y: labelOffsetDiff.y\n      };\n    }\n\n    pos.offset = labelOffset;\n    pos.angle = angle;\n    return pos;\n  }\n\n  normalizeLabelPosition(pos) {\n    if (typeof pos === 'number') {\n      return {\n        distance: pos\n      };\n    }\n\n    return pos;\n  }\n\n  getLabelTransformationMatrix(labelPosition) {\n    const pos = this.normalizeLabelPosition(labelPosition);\n    const options = pos.options || {};\n    const labelAngle = pos.angle || 0;\n    const labelDistance = pos.distance;\n    const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n    let labelOffset = 0;\n    const offsetCoord = {\n      x: 0,\n      y: 0\n    };\n    const offset = pos.offset;\n\n    if (offset) {\n      if (typeof offset === 'number') {\n        labelOffset = offset;\n      } else {\n        if (offset.x != null) {\n          offsetCoord.x = offset.x;\n        }\n\n        if (offset.y != null) {\n          offsetCoord.y = offset.y;\n        }\n      }\n    }\n\n    const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;\n    const isKeepGradient = options.keepGradient;\n    const isEnsureLegibility = options.ensureLegibility;\n    const path = this.path;\n    const pathOpt = {\n      segmentSubdivisions: this.getConnectionSubdivisions()\n    };\n    const distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n    const tangent = path.tangentAtLength(distance, pathOpt);\n    let translation;\n    let angle = labelAngle;\n\n    if (tangent) {\n      if (isOffsetAbsolute) {\n        translation = tangent.start;\n        translation.translate(offsetCoord);\n      } else {\n        const normal = tangent.clone();\n        normal.rotate(-90, tangent.start);\n        normal.setLength(labelOffset);\n        translation = normal.end;\n      }\n\n      if (isKeepGradient) {\n        angle = tangent.angle() + labelAngle;\n\n        if (isEnsureLegibility) {\n          angle = Angle.normalize((angle + 90) % 180 - 90);\n        }\n      }\n    } else {\n      // fallback - the connection has zero length\n      translation = path.start;\n\n      if (isOffsetAbsolute) {\n        translation.translate(offsetCoord);\n      }\n    }\n\n    return Dom.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n  }\n\n  getLabelCoordinates(pos) {\n    const matrix = this.getLabelTransformationMatrix(pos);\n    return new Point(matrix.e, matrix.f);\n  }\n\n  getVertexIndex(x, y) {\n    const edge = this.cell;\n    const vertices = edge.getVertices();\n    const vertexLength = this.getClosestPointLength(new Point(x, y));\n    let index = 0;\n\n    if (vertexLength != null) {\n      for (const ii = vertices.length; index < ii; index += 1) {\n        const currentVertex = vertices[index];\n        const currentLength = this.getClosestPointLength(currentVertex);\n\n        if (currentLength != null && vertexLength < currentLength) {\n          break;\n        }\n      }\n    }\n\n    return index;\n  }\n\n  getEventArgs(e, x, y) {\n    const view = this; // eslint-disable-line\n\n    const edge = view.cell;\n    const cell = edge;\n\n    if (x == null || y == null) {\n      return {\n        e,\n        view,\n        edge,\n        cell\n      };\n    }\n\n    return {\n      e,\n      x,\n      y,\n      view,\n      edge,\n      cell\n    };\n  }\n\n  notifyUnhandledMouseDown(e, x, y) {\n    this.notify('edge:unhandled:mousedown', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell\n    });\n  }\n\n  notifyMouseDown(e, x, y) {\n    super.onMouseDown(e, x, y);\n    this.notify('edge:mousedown', this.getEventArgs(e, x, y));\n  }\n\n  notifyMouseMove(e, x, y) {\n    super.onMouseMove(e, x, y);\n    this.notify('edge:mousemove', this.getEventArgs(e, x, y));\n  }\n\n  notifyMouseUp(e, x, y) {\n    super.onMouseUp(e, x, y);\n    this.notify('edge:mouseup', this.getEventArgs(e, x, y));\n  }\n\n  onClick(e, x, y) {\n    super.onClick(e, x, y);\n    this.notify('edge:click', this.getEventArgs(e, x, y));\n  }\n\n  onDblClick(e, x, y) {\n    super.onDblClick(e, x, y);\n    this.notify('edge:dblclick', this.getEventArgs(e, x, y));\n  }\n\n  onContextMenu(e, x, y) {\n    super.onContextMenu(e, x, y);\n    this.notify('edge:contextmenu', this.getEventArgs(e, x, y));\n  }\n\n  onMouseDown(e, x, y) {\n    this.notifyMouseDown(e, x, y);\n    const className = e.target.getAttribute('class');\n\n    switch (className) {\n      case 'vertex':\n        {\n          this.startVertexDragging(e, x, y);\n          return;\n        }\n\n      case 'vertex-remove':\n      case 'vertex-remove-area':\n        {\n          this.handleVertexRemoving(e, x, y);\n          return;\n        }\n\n      case 'connection':\n      case 'connection-wrap':\n        {\n          this.handleVertexAdding(e, x, y);\n          return;\n        }\n\n      case 'arrowhead':\n        {\n          this.startArrowheadDragging(e, x, y);\n          return;\n        }\n\n      case 'source-marker':\n      case 'target-marker':\n        {\n          this.notifyUnhandledMouseDown(e, x, y);\n          return;\n        }\n\n      default:\n        break;\n    }\n\n    this.startEdgeDragging(e, x, y);\n  }\n\n  onMouseMove(e, x, y) {\n    const data = this.getEventData(e);\n\n    switch (data.action) {\n      case 'drag-vertex':\n        {\n          this.dragVertex(e, x, y);\n          break;\n        }\n\n      case 'drag-label':\n        {\n          this.dragLabel(e, x, y);\n          break;\n        }\n\n      case 'drag-arrowhead':\n        {\n          this.dragArrowhead(e, x, y);\n          break;\n        }\n\n      case 'drag-edge':\n        {\n          this.dragEdge(e, x, y);\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    this.notifyMouseMove(e, x, y);\n    return data;\n  }\n\n  onMouseUp(e, x, y) {\n    const data = this.getEventData(e);\n\n    switch (data.action) {\n      case 'drag-vertex':\n        {\n          this.stopVertexDragging(e, x, y);\n          break;\n        }\n\n      case 'drag-label':\n        {\n          this.stopLabelDragging(e, x, y);\n          break;\n        }\n\n      case 'drag-arrowhead':\n        {\n          this.stopArrowheadDragging(e, x, y);\n          break;\n        }\n\n      case 'drag-edge':\n        {\n          this.stopEdgeDragging(e, x, y);\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    this.notifyMouseUp(e, x, y);\n    this.checkMouseleave(e);\n    return data;\n  }\n\n  onMouseOver(e) {\n    super.onMouseOver(e);\n    this.notify('edge:mouseover', this.getEventArgs(e));\n  }\n\n  onMouseOut(e) {\n    super.onMouseOut(e);\n    this.notify('edge:mouseout', this.getEventArgs(e));\n  }\n\n  onMouseEnter(e) {\n    super.onMouseEnter(e);\n    this.notify('edge:mouseenter', this.getEventArgs(e));\n  }\n\n  onMouseLeave(e) {\n    super.onMouseLeave(e);\n    this.notify('edge:mouseleave', this.getEventArgs(e));\n  }\n\n  onMouseWheel(e, x, y, delta) {\n    super.onMouseWheel(e, x, y, delta);\n    this.notify('edge:mousewheel', Object.assign({\n      delta\n    }, this.getEventArgs(e, x, y)));\n  }\n\n  onCustomEvent(e, name, x, y) {\n    // For default edge tool\n    const tool = Dom.findParentByClass(e.target, 'edge-tool', this.container);\n\n    if (tool) {\n      e.stopPropagation(); // no further action to be executed\n\n      if (this.can('useEdgeTools')) {\n        if (name === 'edge:remove') {\n          this.cell.remove({\n            ui: true\n          });\n          return;\n        }\n\n        this.notify('edge:customevent', Object.assign({\n          name\n        }, this.getEventArgs(e, x, y)));\n      }\n\n      this.notifyMouseDown(e, x, y);\n    } else {\n      this.notify('edge:customevent', Object.assign({\n        name\n      }, this.getEventArgs(e, x, y)));\n      super.onCustomEvent(e, name, x, y);\n    }\n  }\n\n  onLabelMouseDown(e, x, y) {\n    this.notifyMouseDown(e, x, y);\n    this.startLabelDragging(e, x, y);\n    const stopPropagation = this.getEventData(e).stopPropagation;\n\n    if (stopPropagation) {\n      e.stopPropagation();\n    }\n  } // #region drag edge\n\n\n  startEdgeDragging(e, x, y) {\n    if (!this.can('edgeMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n\n    this.setEventData(e, {\n      x,\n      y,\n      moving: false,\n      action: 'drag-edge'\n    });\n  }\n\n  dragEdge(e, x, y) {\n    const data = this.getEventData(e);\n\n    if (!data.moving) {\n      data.moving = true;\n      this.addClass('edge-moving');\n      this.notify('edge:move', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n\n    this.cell.translate(x - data.x, y - data.y, {\n      ui: true\n    });\n    this.setEventData(e, {\n      x,\n      y\n    });\n    this.notify('edge:moving', {\n      e,\n      x,\n      y,\n      view: this,\n      cell: this.cell,\n      edge: this.cell\n    });\n  }\n\n  stopEdgeDragging(e, x, y) {\n    const data = this.getEventData(e);\n\n    if (data.moving) {\n      this.removeClass('edge-moving');\n      this.notify('edge:moved', {\n        e,\n        x,\n        y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n\n    data.moving = false;\n  } // #endregion\n  // #region drag arrowhead\n\n\n  prepareArrowheadDragging(type, options) {\n    const magnet = this.getTerminalMagnet(type);\n    const data = {\n      action: 'drag-arrowhead',\n      x: options.x,\n      y: options.y,\n      isNewEdge: options.isNewEdge === true,\n      terminalType: type,\n      initialMagnet: magnet,\n      initialTerminal: ObjectExt.clone(this.cell[type]),\n      fallbackAction: options.fallbackAction || 'revert',\n      getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n      options: options.options\n    };\n    this.beforeArrowheadDragging(data);\n    return data;\n  }\n\n  createValidateConnectionArgs(type) {\n    const args = [];\n    args[4] = type;\n    args[5] = this;\n    let opposite;\n    let i = 0;\n    let j = 0;\n\n    if (type === 'source') {\n      i = 2;\n      opposite = 'target';\n    } else {\n      j = 2;\n      opposite = 'source';\n    }\n\n    const terminal = this.cell[opposite];\n    const cellId = terminal.cell;\n\n    if (cellId) {\n      let magnet;\n      const view = args[i] = this.graph.renderer.findViewByCell(cellId);\n\n      if (view) {\n        magnet = view.getMagnetFromEdgeTerminal(terminal);\n\n        if (magnet === view.container) {\n          magnet = undefined;\n        }\n      }\n\n      args[i + 1] = magnet;\n    }\n\n    return (cellView, magnet) => {\n      args[j] = cellView;\n      args[j + 1] = cellView.container === magnet ? undefined : magnet;\n      return args;\n    };\n  }\n\n  beforeArrowheadDragging(data) {\n    data.zIndex = this.cell.zIndex;\n    this.cell.toFront();\n    const style = this.container.style;\n    data.pointerEvents = style.pointerEvents;\n    style.pointerEvents = 'none';\n\n    if (this.graph.options.connecting.highlight) {\n      this.highlightAvailableMagnets(data);\n    }\n  }\n\n  afterArrowheadDragging(data) {\n    if (data.zIndex != null) {\n      this.cell.setZIndex(data.zIndex, {\n        ui: true\n      });\n      data.zIndex = null;\n    }\n\n    const container = this.container;\n    container.style.pointerEvents = data.pointerEvents || '';\n\n    if (this.graph.options.connecting.highlight) {\n      this.unhighlightAvailableMagnets(data);\n    }\n  }\n\n  arrowheadDragging(target, x, y, data) {\n    data.x = x;\n    data.y = y; // Checking views right under the pointer\n\n    if (data.currentTarget !== target) {\n      // Unhighlight the previous view under pointer if there was one.\n      if (data.currentMagnet && data.currentView) {\n        data.currentView.unhighlight(data.currentMagnet, {\n          type: 'magnetAdsorbed'\n        });\n      }\n\n      data.currentView = this.graph.renderer.findViewByElem(target);\n\n      if (data.currentView) {\n        // If we found a view that is under the pointer, we need to find\n        // the closest magnet based on the real target element of the event.\n        data.currentMagnet = data.currentView.findMagnet(target);\n\n        if (data.currentMagnet && this.graph.hook.validateConnection(...data.getValidateConnectionArgs(data.currentView, data.currentMagnet), data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType))) {\n          data.currentView.highlight(data.currentMagnet, {\n            type: 'magnetAdsorbed'\n          });\n        } else {\n          // This type of connection is not valid. Disregard this magnet.\n          data.currentMagnet = null;\n        }\n      } else {\n        // Make sure we'll unset previous magnet.\n        data.currentMagnet = null;\n      }\n    }\n\n    data.currentTarget = target;\n    this.cell.prop(data.terminalType, {\n      x,\n      y\n    }, Object.assign(Object.assign({}, data.options), {\n      ui: true\n    }));\n  }\n\n  arrowheadDragged(data, x, y) {\n    const view = data.currentView;\n    const magnet = data.currentMagnet;\n\n    if (!magnet || !view) {\n      return;\n    }\n\n    view.unhighlight(magnet, {\n      type: 'magnetAdsorbed'\n    });\n    const type = data.terminalType;\n    const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);\n    this.cell.setTerminal(type, terminal, {\n      ui: true\n    });\n  }\n\n  snapArrowhead(x, y, data) {\n    const graph = this.graph;\n    const snap = graph.options.connecting.snap;\n    const radius = typeof snap === 'object' && snap.radius || 50;\n    const views = graph.renderer.findViewsInArea({\n      x: x - radius,\n      y: y - radius,\n      width: 2 * radius,\n      height: 2 * radius\n    });\n    const prevView = data.closestView || null;\n    const prevMagnet = data.closestMagnet || null;\n    data.closestView = null;\n    data.closestMagnet = null;\n    let distance;\n    let minDistance = Number.MAX_SAFE_INTEGER;\n    const pos = new Point(x, y);\n    views.forEach(view => {\n      if (view.container.getAttribute('magnet') !== 'false') {\n        // Find distance from the center of the cell to pointer coordinates\n        distance = view.cell.getBBox().getCenter().distance(pos); // the connection is looked up in a circle area by `distance < r`\n\n        if (distance < radius && distance < minDistance) {\n          if (prevMagnet === view.container || graph.hook.validateConnection(...data.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data.terminalType))) {\n            minDistance = distance;\n            data.closestView = view;\n            data.closestMagnet = view.container;\n          }\n        }\n      }\n\n      view.container.querySelectorAll('[magnet]').forEach(magnet => {\n        if (magnet.getAttribute('magnet') !== 'false') {\n          const bbox = view.getBBoxOfElement(magnet);\n          distance = pos.distance(bbox.getCenter());\n\n          if (distance < radius && distance < minDistance) {\n            if (prevMagnet === magnet || graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data.terminalType))) {\n              minDistance = distance;\n              data.closestView = view;\n              data.closestMagnet = magnet;\n            }\n          }\n        }\n      });\n    });\n    let terminal;\n    const type = data.terminalType;\n    const closestView = data.closestView;\n    const closestMagnet = data.closestMagnet;\n    const changed = prevMagnet !== closestMagnet;\n\n    if (prevView && changed) {\n      prevView.unhighlight(prevMagnet, {\n        type: 'magnetAdsorbed'\n      });\n    }\n\n    if (closestView) {\n      if (!changed) {\n        return;\n      }\n\n      closestView.highlight(closestMagnet, {\n        type: 'magnetAdsorbed'\n      });\n      terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);\n    } else {\n      terminal = {\n        x,\n        y\n      };\n    }\n\n    this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), {\n      ui: true\n    }));\n  }\n\n  snapArrowheadEnd(data) {\n    // Finish off link snapping.\n    // Everything except view unhighlighting was already done on pointermove.\n    const closestView = data.closestView;\n    const closestMagnet = data.closestMagnet;\n\n    if (closestView && closestMagnet) {\n      closestView.unhighlight(closestMagnet, {\n        type: 'magnetAdsorbed'\n      });\n      data.currentMagnet = closestView.findMagnet(closestMagnet);\n    }\n\n    data.closestView = null;\n    data.closestMagnet = null;\n  }\n\n  finishEmbedding(data) {\n    // Resets parent of the edge if embedding is enabled\n    if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n      // Make sure we don't reverse to the original 'z' index\n      data.zIndex = null;\n    }\n  }\n\n  fallbackConnection(data) {\n    switch (data.fallbackAction) {\n      case 'remove':\n        this.cell.remove({\n          ui: true\n        });\n        break;\n\n      case 'revert':\n      default:\n        this.cell.prop(data.terminalType, data.initialTerminal, {\n          ui: true\n        });\n        break;\n    }\n  }\n\n  notifyConnectionEvent(data, e) {\n    const terminalType = data.terminalType;\n    const initialTerminal = data.initialTerminal;\n    const currentTerminal = this.cell[terminalType];\n    const changed = currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal);\n\n    if (changed) {\n      const graph = this.graph;\n      const previous = initialTerminal;\n      const previousCell = previous.cell ? graph.getCellById(previous.cell) : null;\n      const previousPort = previous.port;\n      const previousView = previousCell ? graph.findViewByCell(previousCell) : null;\n      const previousPoint = previousCell || data.isNewEdge ? null : Point.create(initialTerminal).toJSON();\n      const current = currentTerminal;\n      const currentCell = current.cell ? graph.getCellById(current.cell) : null;\n      const currentPort = current.port;\n      const currentView = currentCell ? graph.findViewByCell(currentCell) : null;\n      const currentPoint = currentCell ? null : Point.create(currentTerminal).toJSON();\n      this.notify('edge:connected', {\n        e,\n        previousCell,\n        previousPort,\n        previousView,\n        previousPoint,\n        currentCell,\n        currentView,\n        currentPort,\n        currentPoint,\n        previousMagnet: data.initialMagnet,\n        currentMagnet: data.currentMagnet,\n        edge: this.cell,\n        view: this,\n        type: terminalType,\n        isNew: data.isNewEdge\n      });\n    }\n  }\n\n  highlightAvailableMagnets(data) {\n    const graph = this.graph;\n    const cells = graph.model.getCells();\n    data.marked = {};\n\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const view = graph.renderer.findViewByCell(cells[i]);\n\n      if (!view) {\n        continue;\n      }\n\n      const magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));\n\n      if (view.container.getAttribute('magnet') !== 'false') {\n        magnets.push(view.container);\n      }\n\n      const availableMagnets = magnets.filter(magnet => graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data.x, data.y, this.cell, data.terminalType)));\n\n      if (availableMagnets.length > 0) {\n        // highlight all available magnets\n        for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n          view.highlight(availableMagnets[j], {\n            type: 'magnetAvailable'\n          });\n        } // highlight the entire view\n\n\n        view.highlight(null, {\n          type: 'nodeAvailable'\n        });\n        data.marked[view.cell.id] = availableMagnets;\n      }\n    }\n  }\n\n  unhighlightAvailableMagnets(data) {\n    const marked = data.marked || {};\n    Object.keys(marked).forEach(id => {\n      const view = this.graph.renderer.findViewByCell(id);\n\n      if (view) {\n        const magnets = marked[id];\n        magnets.forEach(magnet => {\n          view.unhighlight(magnet, {\n            type: 'magnetAvailable'\n          });\n        });\n        view.unhighlight(null, {\n          type: 'nodeAvailable'\n        });\n      }\n    });\n    data.marked = null;\n  }\n\n  startArrowheadDragging(e, x, y) {\n    if (!this.can('arrowheadMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n\n    const elem = e.target;\n    const type = elem.getAttribute('data-terminal');\n    const data = this.prepareArrowheadDragging(type, {\n      x,\n      y\n    });\n    this.setEventData(e, data);\n  }\n\n  dragArrowhead(e, x, y) {\n    const data = this.getEventData(e);\n\n    if (this.graph.options.connecting.snap) {\n      this.snapArrowhead(x, y, data);\n    } else {\n      this.arrowheadDragging(this.getEventTarget(e), x, y, data);\n    }\n  }\n\n  stopArrowheadDragging(e, x, y) {\n    const graph = this.graph;\n    const data = this.getEventData(e);\n\n    if (graph.options.connecting.snap) {\n      this.snapArrowheadEnd(data);\n    } else {\n      this.arrowheadDragged(data, x, y);\n    }\n\n    const valid = graph.hook.validateEdge(this.cell, data.terminalType, data.initialTerminal);\n\n    if (valid) {\n      this.finishEmbedding(data);\n      this.notifyConnectionEvent(data, e);\n    } else {\n      // If the changed edge is not allowed, revert to its previous state.\n      this.fallbackConnection(data);\n    }\n\n    this.afterArrowheadDragging(data);\n  } // #endregion\n  // #region drag lable\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  startLabelDragging(e, x, y) {\n    if (this.can('edgeLabelMovable')) {\n      const target = e.currentTarget;\n      const index = parseInt(target.getAttribute('data-index'), 10);\n      const positionAngle = this.getLabelPositionAngle(index);\n      const labelPositionArgs = this.getLabelPositionArgs(index);\n      const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n      const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n      this.setEventData(e, {\n        index,\n        positionAngle,\n        positionArgs,\n        stopPropagation: true,\n        action: 'drag-label'\n      });\n    } else {\n      // If labels can't be dragged no default action is triggered.\n      this.setEventData(e, {\n        stopPropagation: true\n      });\n    }\n\n    this.graph.view.delegateDragEvents(e, this);\n  }\n\n  dragLabel(e, x, y) {\n    const data = this.getEventData(e);\n    const originLabel = this.cell.getLabelAt(data.index);\n    const label = ObjectExt.merge({}, originLabel, {\n      position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs)\n    });\n    this.cell.setLabelAt(data.index, label);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  stopLabelDragging(e, x, y) {} // #endregion\n  // #region drag vertex\n\n\n  handleVertexAdding(e, x, y) {\n    if (!this.can('vertexAddable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    } // Store the index at which the new vertex has just been placed.\n    // We'll be update the very same vertex position in `pointermove()`.\n\n\n    const index = this.addVertex({\n      x,\n      y\n    }, {\n      ui: true\n    });\n    this.setEventData(e, {\n      index,\n      action: 'drag-vertex'\n    });\n  }\n\n  handleVertexRemoving(e, x, y) {\n    if (!this.can('vertexDeletable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n\n    const target = e.target;\n    const index = parseInt(target.getAttribute('idx'), 10);\n    this.cell.removeVertexAt(index);\n  }\n\n  startVertexDragging(e, x, y) {\n    if (!this.can('vertexMovable')) {\n      this.notifyUnhandledMouseDown(e, x, y);\n      return;\n    }\n\n    const target = e.target;\n    const index = parseInt(target.getAttribute('idx'), 10);\n    this.setEventData(e, {\n      index,\n      action: 'drag-vertex'\n    });\n  }\n\n  dragVertex(e, x, y) {\n    const data = this.getEventData(e);\n    this.cell.setVertexAt(data.index, {\n      x,\n      y\n    }, {\n      ui: true\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  stopVertexDragging(e, x, y) {}\n\n}\n\n(function (EdgeView) {\n  EdgeView.toStringTag = `X6.${EdgeView.name}`;\n\n  function isEdgeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof EdgeView) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const view = instance;\n\n    if ((tag == null || tag === EdgeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.getConnection === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  EdgeView.isEdgeView = isEdgeView;\n})(EdgeView || (EdgeView = {}));\n\nEdgeView.config({\n  isSvgElement: true,\n  priority: 1,\n  bootstrap: ['render', 'source', 'target'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    source: ['source', 'update'],\n    target: ['target', 'update'],\n    router: ['update'],\n    connector: ['update'],\n    labels: ['labels'],\n    defaultLabel: ['labels'],\n    vertices: ['vertices', 'update'],\n    vertexMarkup: ['vertices'],\n    toolMarkup: ['tools'],\n    tools: ['widget']\n  },\n  shortLength: 105,\n  longLength: 155,\n  toolsOffset: 40,\n  doubleTools: false,\n  doubleToolsOffset: 65,\n  sampleInterval: 50\n});\nEdgeView.registry.register('edge', EdgeView, true);","map":{"version":3,"sources":["../../src/view/edge.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { Rectangle, Polyline, Point, Angle, Path, Line } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt, FunctionExt, Dom, Vector, } from '../util';\nimport { Router, Connector, NodeAnchor, EdgeAnchor, ConnectionPoint, } from '../registry';\nimport { Edge } from '../model/edge';\nimport { Markup } from './markup';\nimport { CellView } from './cell';\nexport class EdgeView extends CellView {\n    constructor() {\n        super(...arguments);\n        this.POINT_ROUNDING = 2;\n        this.markerCache = {};\n        // #endregion\n        // #endregion\n    }\n    get [Symbol.toStringTag]() {\n        return EdgeView.toStringTag;\n    }\n    getContainerClassName() {\n        return [super.getContainerClassName(), this.prefixClassName('edge')].join(' ');\n    }\n    get sourceBBox() {\n        const sourceView = this.sourceView;\n        if (!sourceView) {\n            const sourceDef = this.cell.getSource();\n            return new Rectangle(sourceDef.x, sourceDef.y);\n        }\n        const sourceMagnet = this.sourceMagnet;\n        if (sourceView.isEdgeElement(sourceMagnet)) {\n            return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);\n        }\n        return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);\n    }\n    get targetBBox() {\n        const targetView = this.targetView;\n        if (!targetView) {\n            const targetDef = this.cell.getTarget();\n            return new Rectangle(targetDef.x, targetDef.y);\n        }\n        const targetMagnet = this.targetMagnet;\n        if (targetView.isEdgeElement(targetMagnet)) {\n            return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);\n        }\n        return targetView.getBBoxOfElement(targetMagnet || targetView.container);\n    }\n    isEdgeView() {\n        return true;\n    }\n    confirmUpdate(flag, options = {}) {\n        let ref = flag;\n        if (this.hasAction(ref, 'source')) {\n            if (!this.updateTerminalProperties('source')) {\n                return ref;\n            }\n            ref = this.removeAction(ref, 'source');\n        }\n        if (this.hasAction(ref, 'target')) {\n            if (!this.updateTerminalProperties('target')) {\n                return ref;\n            }\n            ref = this.removeAction(ref, 'target');\n        }\n        const graph = this.graph;\n        const sourceView = this.sourceView;\n        const targetView = this.targetView;\n        if (graph &&\n            ((sourceView && !graph.renderer.isViewMounted(sourceView)) ||\n                (targetView && !graph.renderer.isViewMounted(targetView)))) {\n            // Wait for the sourceView and targetView to be rendered.\n            return ref;\n        }\n        if (this.hasAction(ref, 'render')) {\n            this.render();\n            ref = this.removeAction(ref, [\n                'render',\n                'update',\n                'vertices',\n                'labels',\n                'tools',\n                'widget',\n            ]);\n            return ref;\n        }\n        ref = this.handleAction(ref, 'vertices', () => this.renderVertexMarkers());\n        ref = this.handleAction(ref, 'update', () => this.update(null, options));\n        ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options));\n        ref = this.handleAction(ref, 'tools', () => {\n            this.renderTools();\n            this.updateToolsPosition();\n        });\n        ref = this.handleAction(ref, 'widget', () => this.renderExternalTools());\n        return ref;\n    }\n    onLabelsChange(options = {}) {\n        // Note: this optimization works in async=false mode only\n        if (this.shouldRerenderLabels(options)) {\n            this.renderLabels();\n        }\n        else {\n            this.updateLabels();\n        }\n        this.updateLabelPositions();\n    }\n    shouldRerenderLabels(options = {}) {\n        const previousLabels = this.cell.previous('labels');\n        if (previousLabels == null) {\n            return true;\n        }\n        // Here is an optimization for cases when we know, that change does\n        // not require re-rendering of all labels.\n        if ('propertyPathArray' in options && 'propertyValue' in options) {\n            // The label is setting by `prop()` method\n            const pathArray = options.propertyPathArray || [];\n            const pathLength = pathArray.length;\n            if (pathLength > 1) {\n                // We are changing a single label here e.g. 'labels/0/position'\n                const index = pathArray[1];\n                if (previousLabels[index]) {\n                    if (pathLength === 2) {\n                        // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return (typeof options.propertyValue === 'object' &&\n                            ObjectExt.has(options.propertyValue, 'markup'));\n                    }\n                    // We are changing a label property but not the markup\n                    if (pathArray[2] !== 'markup') {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    render() {\n        this.empty();\n        this.containers = {};\n        this.renderMarkup();\n        this.renderLabels();\n        this.update();\n        return this;\n    }\n    renderMarkup() {\n        const markup = this.cell.markup;\n        if (markup) {\n            if (typeof markup === 'string') {\n                return this.renderStringMarkup(markup);\n            }\n            return this.renderJSONMarkup(markup);\n        }\n        throw new TypeError('Invalid edge markup.');\n    }\n    renderJSONMarkup(markup) {\n        const ret = this.parseJSONMarkup(markup, this.container);\n        this.selectors = ret.selectors;\n        this.container.append(ret.fragment);\n    }\n    renderStringMarkup(markup) {\n        const cache = this.containers;\n        const children = Vector.createVectors(markup);\n        // Cache children elements for quicker access.\n        children.forEach((child) => {\n            const className = child.attr('class');\n            if (className) {\n                cache[StringExt.camelCase(className)] =\n                    child.node;\n            }\n        });\n        this.renderTools();\n        this.renderVertexMarkers();\n        this.renderArrowheadMarkers();\n        Dom.append(this.container, children.map((child) => child.node));\n    }\n    renderLabels() {\n        const edge = this.cell;\n        const labels = edge.getLabels();\n        const count = labels.length;\n        let container = this.containers.labels;\n        this.labelCache = {};\n        this.labelSelectors = {};\n        if (count <= 0) {\n            if (container && container.parentNode) {\n                container.parentNode.removeChild(container);\n            }\n            return this;\n        }\n        if (container) {\n            this.empty(container);\n        }\n        else {\n            container = Dom.createSvgElement('g');\n            this.addClass(this.prefixClassName('edge-labels'), container);\n            this.containers.labels = container;\n        }\n        for (let i = 0, ii = labels.length; i < ii; i += 1) {\n            const label = labels[i];\n            const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));\n            let labelNode;\n            let selectors;\n            if (normalized) {\n                labelNode = normalized.node;\n                selectors = normalized.selectors;\n            }\n            else {\n                const defaultLabel = edge.getDefaultLabel();\n                const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));\n                labelNode = normalized.node;\n                selectors = normalized.selectors;\n            }\n            labelNode.setAttribute('data-index', `${i}`);\n            container.appendChild(labelNode);\n            const rootSelector = this.rootSelector;\n            if (selectors[rootSelector]) {\n                throw new Error('Ambiguous label root selector.');\n            }\n            selectors[rootSelector] = labelNode;\n            this.labelCache[i] = labelNode;\n            this.labelSelectors[i] = selectors;\n        }\n        if (container.parentNode == null) {\n            this.container.appendChild(container);\n        }\n        this.updateLabels();\n        this.customizeLabels();\n        return this;\n    }\n    parseLabelMarkup(markup) {\n        if (markup) {\n            if (typeof markup === 'string') {\n                return this.parseLabelStringMarkup(markup);\n            }\n            return this.parseJSONMarkup(markup);\n        }\n        return null;\n    }\n    parseLabelStringMarkup(labelMarkup) {\n        const children = Vector.createVectors(labelMarkup);\n        const fragment = document.createDocumentFragment();\n        for (let i = 0, n = children.length; i < n; i += 1) {\n            const currentChild = children[i].node;\n            fragment.appendChild(currentChild);\n        }\n        return { fragment, selectors: {} };\n    }\n    normalizeLabelMarkup(markup) {\n        if (markup == null) {\n            return;\n        }\n        const fragment = markup.fragment;\n        if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n            throw new Error('Invalid label markup.');\n        }\n        let vel;\n        const childNodes = fragment.childNodes;\n        if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n            // default markup fragment is not wrapped in `<g/>`\n            // add a `<g/>` container\n            vel = Vector.create('g').append(fragment);\n        }\n        else {\n            vel = Vector.create(childNodes[0]);\n        }\n        vel.addClass(this.prefixClassName('edge-label'));\n        return {\n            node: vel.node,\n            selectors: markup.selectors,\n        };\n    }\n    updateLabels() {\n        if (this.containers.labels) {\n            const edge = this.cell;\n            const labels = edge.labels;\n            const canLabelMove = this.can('edgeLabelMovable');\n            const defaultLabel = edge.getDefaultLabel();\n            for (let i = 0, n = labels.length; i < n; i += 1) {\n                const elem = this.labelCache[i];\n                const selectors = this.labelSelectors[i];\n                elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n                const label = labels[i];\n                const attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs);\n                this.updateAttrs(elem, attrs, {\n                    selectors,\n                    rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined,\n                });\n            }\n        }\n    }\n    mergeLabelAttrs(hasCustomMarkup, labelAttrs, defaultLabelAttrs) {\n        if (labelAttrs === null) {\n            return null;\n        }\n        if (labelAttrs === undefined) {\n            if (defaultLabelAttrs === null) {\n                return null;\n            }\n            if (defaultLabelAttrs === undefined) {\n                return undefined;\n            }\n            if (hasCustomMarkup) {\n                return defaultLabelAttrs;\n            }\n            return ObjectExt.merge({}, defaultLabelAttrs);\n        }\n        if (hasCustomMarkup) {\n            return ObjectExt.merge({}, defaultLabelAttrs, labelAttrs);\n        }\n    }\n    customizeLabels() {\n        if (this.containers.labels) {\n            const edge = this.cell;\n            const labels = edge.labels;\n            for (let i = 0, n = labels.length; i < n; i += 1) {\n                const label = labels[i];\n                const container = this.labelCache[i];\n                const selectors = this.labelSelectors[i];\n                this.graph.hook.onEdgeLabelRendered({\n                    edge,\n                    label,\n                    container,\n                    selectors,\n                });\n            }\n        }\n    }\n    renderTools() {\n        const container = this.containers.tools;\n        if (container == null) {\n            return this;\n        }\n        const markup = this.cell.toolMarkup;\n        const $container = this.$(container).empty();\n        if (Markup.isStringMarkup(markup)) {\n            let template = StringExt.template(markup);\n            const tool = Vector.create(template());\n            $container.append(tool.node);\n            this.toolCache = tool.node;\n            // If `doubleTools` is enabled, we render copy of the tools on the\n            // other side of the edge as well but only if the edge is longer\n            // than `longLength`.\n            if (this.options.doubleTools) {\n                let tool2;\n                const doubleToolMarkup = this.cell.doubleToolMarkup;\n                if (Markup.isStringMarkup(doubleToolMarkup)) {\n                    template = StringExt.template(doubleToolMarkup);\n                    tool2 = Vector.create(template());\n                }\n                else {\n                    tool2 = tool.clone();\n                }\n                $container.append(tool2.node);\n                this.tool2Cache = tool2.node;\n            }\n        }\n        return this;\n    }\n    renderExternalTools() {\n        const tools = this.cell.getTools();\n        this.addTools(tools);\n        return this;\n    }\n    renderVertexMarkers() {\n        const container = this.containers.vertices;\n        if (container == null) {\n            return this;\n        }\n        const markup = this.cell.vertexMarkup;\n        const $container = this.$(container).empty();\n        if (Markup.isStringMarkup(markup)) {\n            const template = StringExt.template(markup);\n            this.cell.getVertices().forEach((vertex, index) => {\n                $container.append(Vector.create(template(Object.assign({ index }, vertex))).node);\n            });\n        }\n        return this;\n    }\n    renderArrowheadMarkers() {\n        const container = this.containers.arrowheads;\n        if (container == null) {\n            return this;\n        }\n        const markup = this.cell.arrowheadMarkup;\n        const $container = this.$(container).empty();\n        if (Markup.isStringMarkup(markup)) {\n            const template = StringExt.template(markup);\n            const sourceArrowhead = Vector.create(template({ end: 'source' })).node;\n            const targetArrowhead = Vector.create(template({ end: 'target' })).node;\n            this.containers.sourceArrowhead = sourceArrowhead;\n            this.containers.targetArrowhead = targetArrowhead;\n            $container.append(sourceArrowhead, targetArrowhead);\n        }\n        return this;\n    }\n    // #endregion\n    // #region updating\n    update(partialAttrs, options = {}) {\n        this.cleanCache();\n        this.updateConnection(options);\n        const attrs = this.cell.getAttrs();\n        if (attrs != null) {\n            this.updateAttrs(this.container, attrs, {\n                attrs: partialAttrs === attrs ? null : partialAttrs,\n                selectors: this.selectors,\n            });\n        }\n        this.updateConnectionPath();\n        this.updateLabelPositions();\n        this.updateToolsPosition();\n        this.updateArrowheadMarkers();\n        if (options.toolId == null) {\n            this.renderExternalTools();\n        }\n        else {\n            this.updateTools(options);\n        }\n        return this;\n    }\n    removeRedundantLinearVertices(options = {}) {\n        const edge = this.cell;\n        const vertices = edge.getVertices();\n        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n        const rawCount = routePoints.length;\n        // Puts the route points into a polyline and try to simplify.\n        const polyline = new Polyline(routePoints);\n        polyline.simplify({ threshold: 0.01 });\n        const simplifiedPoints = polyline.points.map((point) => point.toJSON());\n        const simplifiedCount = simplifiedPoints.length;\n        // If simplification did not remove any redundant vertices.\n        if (rawCount === simplifiedCount) {\n            return 0;\n        }\n        // Sets simplified polyline points as edge vertices.\n        // Removes first and last polyline points again (source/target anchors).\n        edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);\n        return rawCount - simplifiedCount;\n    }\n    updateConnectionPath() {\n        const containers = this.containers;\n        if (containers.connection) {\n            const pathData = this.getConnectionPathData();\n            containers.connection.setAttribute('d', pathData);\n        }\n        if (containers.connectionWrap) {\n            const pathData = this.getConnectionPathData();\n            containers.connectionWrap.setAttribute('d', pathData);\n        }\n        if (containers.sourceMarker && containers.targetMarker) {\n            this.translateAndAutoOrientArrows(containers.sourceMarker, containers.targetMarker);\n        }\n    }\n    getTerminalView(type) {\n        switch (type) {\n            case 'source':\n                return this.sourceView || null;\n            case 'target':\n                return this.targetView || null;\n            default:\n                throw new Error(`Unknown terminal type '${type}'`);\n        }\n    }\n    getTerminalAnchor(type) {\n        switch (type) {\n            case 'source':\n                return Point.create(this.sourceAnchor);\n            case 'target':\n                return Point.create(this.targetAnchor);\n            default:\n                throw new Error(`Unknown terminal type '${type}'`);\n        }\n    }\n    getTerminalConnectionPoint(type) {\n        switch (type) {\n            case 'source':\n                return Point.create(this.sourcePoint);\n            case 'target':\n                return Point.create(this.targetPoint);\n            default:\n                throw new Error(`Unknown terminal type '${type}'`);\n        }\n    }\n    getTerminalMagnet(type, options = {}) {\n        switch (type) {\n            case 'source': {\n                if (options.raw) {\n                    return this.sourceMagnet;\n                }\n                const sourceView = this.sourceView;\n                if (!sourceView) {\n                    return null;\n                }\n                return this.sourceMagnet || sourceView.container;\n            }\n            case 'target': {\n                if (options.raw) {\n                    return this.targetMagnet;\n                }\n                const targetView = this.targetView;\n                if (!targetView) {\n                    return null;\n                }\n                return this.targetMagnet || targetView.container;\n            }\n            default: {\n                throw new Error(`Unknown terminal type '${type}'`);\n            }\n        }\n    }\n    updateConnection(options = {}) {\n        const edge = this.cell;\n        // The edge is being translated by an ancestor that will shift\n        // source, target and vertices by an equal distance.\n        if (options.translateBy &&\n            edge.isFragmentDescendantOf(options.translateBy)) {\n            const tx = options.tx || 0;\n            const ty = options.ty || 0;\n            this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;\n            this.translateConnectionPoints(tx, ty);\n            this.path.translate(tx, ty);\n        }\n        else {\n            const vertices = edge.getVertices();\n            // 1. Find anchor points\n            const anchors = this.findAnchors(vertices);\n            this.sourceAnchor = anchors.source;\n            this.targetAnchor = anchors.target;\n            // 2. Find route points\n            this.routePoints = this.findRoutePoints(vertices);\n            // 3. Find connection points\n            const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);\n            this.sourcePoint = connectionPoints.source;\n            this.targetPoint = connectionPoints.target;\n            // 4. Find Marker Connection Point\n            const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);\n            // 5. Make path\n            this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);\n        }\n        this.cleanCache();\n    }\n    findAnchors(vertices) {\n        const edge = this.cell;\n        const source = edge.source;\n        const target = edge.target;\n        const firstVertex = vertices[0];\n        const lastVertex = vertices[vertices.length - 1];\n        if (target.priority && !source.priority) {\n            // Reversed order\n            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n        }\n        // Usual order\n        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    }\n    findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {\n        let firstAnchor;\n        let secondAnchor;\n        const edge = this.cell;\n        const firstTerminal = edge[firstType];\n        const secondTerminal = edge[secondType];\n        const firstView = this.getTerminalView(firstType);\n        const secondView = this.getTerminalView(secondType);\n        const firstMagnet = this.getTerminalMagnet(firstType);\n        const secondMagnet = this.getTerminalMagnet(secondType);\n        if (firstView) {\n            let firstRef;\n            if (firstPoint) {\n                firstRef = Point.create(firstPoint);\n            }\n            else if (secondView) {\n                firstRef = secondMagnet;\n            }\n            else {\n                firstRef = Point.create(secondTerminal);\n            }\n            firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);\n        }\n        else {\n            firstAnchor = Point.create(firstTerminal);\n        }\n        if (secondView) {\n            const secondRef = Point.create(secondPoint || firstAnchor);\n            secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);\n        }\n        else {\n            secondAnchor = Point.isPointLike(secondTerminal)\n                ? Point.create(secondTerminal)\n                : new Point();\n        }\n        return {\n            [firstType]: firstAnchor,\n            [secondType]: secondAnchor,\n        };\n    }\n    getAnchor(def, cellView, magnet, ref, terminalType) {\n        const isEdge = cellView.isEdgeElement(magnet);\n        const connecting = this.graph.options.connecting;\n        let config = typeof def === 'string' ? { name: def } : def;\n        if (!config) {\n            const defaults = isEdge\n                ? (terminalType === 'source'\n                    ? connecting.sourceEdgeAnchor\n                    : connecting.targetEdgeAnchor) || connecting.edgeAnchor\n                : (terminalType === 'source'\n                    ? connecting.sourceAnchor\n                    : connecting.targetAnchor) || connecting.anchor;\n            config = typeof defaults === 'string' ? { name: defaults } : defaults;\n        }\n        if (!config) {\n            throw new Error(`Anchor should be specified.`);\n        }\n        let anchor;\n        const name = config.name;\n        if (isEdge) {\n            const fn = EdgeAnchor.registry.get(name);\n            if (typeof fn !== 'function') {\n                return EdgeAnchor.registry.onNotFound(name);\n            }\n            anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n        }\n        else {\n            const fn = NodeAnchor.registry.get(name);\n            if (typeof fn !== 'function') {\n                return NodeAnchor.registry.onNotFound(name);\n            }\n            anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n        }\n        return anchor ? anchor.round(this.POINT_ROUNDING) : new Point();\n    }\n    findRoutePoints(vertices = []) {\n        const defaultRouter = this.graph.options.connecting.router || Router.presets.normal;\n        const router = this.cell.getRouter() || defaultRouter;\n        let routePoints;\n        if (typeof router === 'function') {\n            routePoints = FunctionExt.call(router, this, vertices, {}, this);\n        }\n        else {\n            const name = typeof router === 'string' ? router : router.name;\n            const args = typeof router === 'string' ? {} : router.args || {};\n            const fn = name ? Router.registry.get(name) : Router.presets.normal;\n            if (typeof fn !== 'function') {\n                return Router.registry.onNotFound(name);\n            }\n            routePoints = FunctionExt.call(fn, this, vertices, args, this);\n        }\n        return routePoints == null\n            ? vertices.map((p) => Point.create(p))\n            : routePoints.map((p) => Point.create(p));\n    }\n    findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {\n        const edge = this.cell;\n        const connecting = this.graph.options.connecting;\n        const sourceTerminal = edge.getSource();\n        const targetTerminal = edge.getTarget();\n        const sourceView = this.sourceView;\n        const targetView = this.targetView;\n        const firstRoutePoint = routePoints[0];\n        const lastRoutePoint = routePoints[routePoints.length - 1];\n        // source\n        let sourcePoint;\n        if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n            const sourceMagnet = this.sourceMagnet || sourceView.container;\n            const sourcePointRef = firstRoutePoint || targetAnchor;\n            const sourceLine = new Line(sourcePointRef, sourceAnchor);\n            const connectionPointDef = sourceTerminal.connectionPoint ||\n                connecting.sourceConnectionPoint ||\n                connecting.connectionPoint;\n            sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n        }\n        else {\n            sourcePoint = sourceAnchor;\n        }\n        // target\n        let targetPoint;\n        if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n            const targetMagnet = this.targetMagnet || targetView.container;\n            const targetConnectionPointDef = targetTerminal.connectionPoint ||\n                connecting.targetConnectionPoint ||\n                connecting.connectionPoint;\n            const targetPointRef = lastRoutePoint || sourceAnchor;\n            const targetLine = new Line(targetPointRef, targetAnchor);\n            targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n        }\n        else {\n            targetPoint = targetAnchor;\n        }\n        return {\n            source: sourcePoint,\n            target: targetPoint,\n        };\n    }\n    getConnectionPoint(def, view, magnet, line, endType) {\n        const anchor = line.end;\n        if (def == null) {\n            return anchor;\n        }\n        const name = typeof def === 'string' ? def : def.name;\n        const args = typeof def === 'string' ? {} : def.args;\n        const fn = ConnectionPoint.registry.get(name);\n        if (typeof fn !== 'function') {\n            return ConnectionPoint.registry.onNotFound(name);\n        }\n        const connectionPoint = FunctionExt.call(fn, this, line, view, magnet, args || {}, endType);\n        return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;\n    }\n    updateMarkerAttr(type) {\n        const attrs = this.cell.getAttrs();\n        const key = `.${type}-marker`;\n        const partial = attrs && attrs[key];\n        if (partial) {\n            this.updateAttrs(this.container, {}, {\n                attrs: { [key]: partial },\n                selectors: this.selectors,\n            });\n        }\n    }\n    findMarkerPoints(routePoints, sourcePoint, targetPoint) {\n        const getLineWidth = (type) => {\n            const attrs = this.cell.getAttrs();\n            const keys = Object.keys(attrs);\n            for (let i = 0, l = keys.length; i < l; i += 1) {\n                const attr = attrs[keys[i]];\n                if (attr[`${type}Marker`] || attr[`${type}-marker`]) {\n                    const strokeWidth = attr.strokeWidth || attr['stroke-width'];\n                    if (strokeWidth) {\n                        return parseFloat(strokeWidth);\n                    }\n                    break;\n                }\n            }\n            return null;\n        };\n        const firstRoutePoint = routePoints[0];\n        const lastRoutePoint = routePoints[routePoints.length - 1];\n        const sourceMarkerElem = this.containers.sourceMarker;\n        const targetMarkerElem = this.containers.targetMarker;\n        const cache = this.markerCache;\n        let sourceMarkerPoint;\n        let targetMarkerPoint;\n        // Move the source point by the width of the marker taking into\n        // account its scale around x-axis. Note that scale is the only\n        // transform that makes sense to be set in `.marker-source`\n        // attributes object as all other transforms (translate/rotate)\n        // will be replaced by the `translateAndAutoOrient()` function.\n        if (sourceMarkerElem) {\n            this.updateMarkerAttr('source');\n            // support marker connection point registry???\n            cache.sourceBBox = cache.sourceBBox || Dom.getBBox(sourceMarkerElem);\n            if (cache.sourceBBox.width > 0) {\n                const scale = Dom.scale(sourceMarkerElem);\n                sourceMarkerPoint = sourcePoint\n                    .clone()\n                    .move(firstRoutePoint || targetPoint, cache.sourceBBox.width * scale.sx * -1);\n            }\n        }\n        else {\n            const strokeWidth = getLineWidth('source');\n            if (strokeWidth) {\n                sourceMarkerPoint = sourcePoint\n                    .clone()\n                    .move(firstRoutePoint || targetPoint, -strokeWidth);\n            }\n        }\n        if (targetMarkerElem) {\n            this.updateMarkerAttr('target');\n            cache.targetBBox = cache.targetBBox || Dom.getBBox(targetMarkerElem);\n            if (cache.targetBBox.width > 0) {\n                const scale = Dom.scale(targetMarkerElem);\n                targetMarkerPoint = targetPoint\n                    .clone()\n                    .move(lastRoutePoint || sourcePoint, cache.targetBBox.width * scale.sx * -1);\n            }\n        }\n        else {\n            const strokeWidth = getLineWidth('target');\n            if (strokeWidth) {\n                targetMarkerPoint = targetPoint\n                    .clone()\n                    .move(lastRoutePoint || sourcePoint, -strokeWidth);\n            }\n        }\n        // If there was no markup for the marker, use the connection point.\n        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n        cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n        return {\n            source: sourceMarkerPoint,\n            target: targetMarkerPoint,\n        };\n    }\n    findPath(routePoints, sourcePoint, targetPoint) {\n        const def = this.cell.getConnector() || this.graph.options.connecting.connector;\n        let name;\n        let args;\n        let fn;\n        if (typeof def === 'string') {\n            name = def;\n        }\n        else {\n            name = def.name;\n            args = def.args;\n        }\n        if (name) {\n            const method = Connector.registry.get(name);\n            if (typeof method !== 'function') {\n                return Connector.registry.onNotFound(name);\n            }\n            fn = method;\n        }\n        else {\n            fn = Connector.presets.normal;\n        }\n        const path = FunctionExt.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), { raw: true }), this);\n        return typeof path === 'string' ? Path.parse(path) : path;\n    }\n    translateConnectionPoints(tx, ty) {\n        const cache = this.markerCache;\n        if (cache.sourcePoint) {\n            cache.sourcePoint.translate(tx, ty);\n        }\n        if (cache.targetPoint) {\n            cache.targetPoint.translate(tx, ty);\n        }\n        this.sourcePoint.translate(tx, ty);\n        this.targetPoint.translate(tx, ty);\n        this.sourceAnchor.translate(tx, ty);\n        this.targetAnchor.translate(tx, ty);\n    }\n    updateLabelPositions() {\n        if (this.containers.labels == null) {\n            return this;\n        }\n        const path = this.path;\n        if (!path) {\n            return this;\n        }\n        const edge = this.cell;\n        const labels = edge.getLabels();\n        if (labels.length === 0) {\n            return this;\n        }\n        const defaultLabel = edge.getDefaultLabel();\n        const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);\n        for (let i = 0, ii = labels.length; i < ii; i += 1) {\n            const label = labels[i];\n            const labelPosition = this.normalizeLabelPosition(label.position);\n            const pos = ObjectExt.merge({}, defaultPosition, labelPosition);\n            const matrix = this.getLabelTransformationMatrix(pos);\n            this.labelCache[i].setAttribute('transform', Dom.matrixToTransformString(matrix));\n        }\n        return this;\n    }\n    updateToolsPosition() {\n        if (this.containers.tools == null) {\n            return this;\n        }\n        // Move the tools a bit to the target position but don't cover the\n        // `sourceArrowhead` marker. Note that the offset is hardcoded here.\n        // The offset should be always more than the\n        // `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n        // this up all the time would be slow.\n        let scale = '';\n        let offset = this.options.toolsOffset;\n        const connectionLength = this.getConnectionLength();\n        // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).\n        // In that case we won't update tools position at all.\n        if (connectionLength != null) {\n            // If the edge is too short, make the tools half the\n            // size and the offset twice as low.\n            if (connectionLength < this.options.shortLength) {\n                scale = 'scale(.5)';\n                offset /= 2;\n            }\n            let pos = this.getPointAtLength(offset);\n            if (pos != null) {\n                Dom.attr(this.toolCache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);\n            }\n            if (this.options.doubleTools &&\n                connectionLength >= this.options.longLength) {\n                const doubleToolsOffset = this.options.doubleToolsOffset || offset;\n                pos = this.getPointAtLength(connectionLength - doubleToolsOffset);\n                if (pos != null) {\n                    Dom.attr(this.tool2Cache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);\n                }\n                Dom.attr(this.tool2Cache, 'visibility', 'visible');\n            }\n            else if (this.options.doubleTools) {\n                Dom.attr(this.tool2Cache, 'visibility', 'hidden');\n            }\n        }\n        return this;\n    }\n    updateArrowheadMarkers() {\n        const container = this.containers.arrowheads;\n        if (container == null) {\n            return this;\n        }\n        if (container.style.display === 'none') {\n            return this;\n        }\n        const sourceArrowhead = this.containers.sourceArrowhead;\n        const targetArrowhead = this.containers.targetArrowhead;\n        if (sourceArrowhead && targetArrowhead) {\n            const len = this.getConnectionLength() || 0;\n            const sx = len < this.options.shortLength ? 0.5 : 1;\n            Dom.scale(sourceArrowhead, sx);\n            Dom.scale(targetArrowhead, sx);\n            this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead);\n        }\n        return this;\n    }\n    updateTerminalProperties(type) {\n        const edge = this.cell;\n        const graph = this.graph;\n        const terminal = edge[type];\n        const nodeId = terminal && terminal.cell;\n        const viewKey = `${type}View`;\n        // terminal is a point\n        if (!nodeId) {\n            this[viewKey] = null;\n            this.updateTerminalMagnet(type);\n            return true;\n        }\n        const terminalCell = graph.getCellById(nodeId);\n        if (!terminalCell) {\n            throw new Error(`Edge's ${type} node with id \"${nodeId}\" not exists`);\n        }\n        const endView = terminalCell.findView(graph);\n        if (!endView) {\n            return false;\n        }\n        this[viewKey] = endView;\n        this.updateTerminalMagnet(type);\n        return true;\n    }\n    updateTerminalMagnet(type) {\n        const propName = `${type}Magnet`;\n        const terminalView = this.getTerminalView(type);\n        if (terminalView) {\n            let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);\n            if (magnet === terminalView.container) {\n                magnet = null;\n            }\n            this[propName] = magnet;\n        }\n        else {\n            this[propName] = null;\n        }\n    }\n    translateAndAutoOrientArrows(sourceArrow, targetArrow) {\n        const route = this.routePoints;\n        if (sourceArrow) {\n            Dom.translateAndAutoOrient(sourceArrow, this.sourcePoint, route[0] || this.targetPoint, this.graph.view.stage);\n        }\n        if (targetArrow) {\n            Dom.translateAndAutoOrient(targetArrow, this.targetPoint, route[route.length - 1] || this.sourcePoint, this.graph.view.stage);\n        }\n    }\n    getLabelPositionAngle(idx) {\n        const label = this.cell.getLabelAt(idx);\n        if (label && label.position && typeof label.position === 'object') {\n            return label.position.angle || 0;\n        }\n        return 0;\n    }\n    getLabelPositionArgs(idx) {\n        const label = this.cell.getLabelAt(idx);\n        if (label && label.position && typeof label.position === 'object') {\n            return label.position.options;\n        }\n    }\n    getDefaultLabelPositionArgs() {\n        const defaultLabel = this.cell.getDefaultLabel();\n        if (defaultLabel &&\n            defaultLabel.position &&\n            typeof defaultLabel.position === 'object') {\n            return defaultLabel.position.options;\n        }\n    }\n    // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n    mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {\n        if (labelPositionArgs === null) {\n            return null;\n        }\n        if (labelPositionArgs === undefined) {\n            if (defaultLabelPositionArgs === null) {\n                return null;\n            }\n            return defaultLabelPositionArgs;\n        }\n        return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs);\n    }\n    addLabel(p1, p2, p3, options) {\n        let localX;\n        let localY;\n        let localAngle = 0;\n        let localOptions;\n        if (typeof p1 !== 'number') {\n            localX = p1.x;\n            localY = p1.y;\n            if (typeof p2 === 'number') {\n                localAngle = p2;\n                localOptions = p3;\n            }\n            else {\n                localOptions = p2;\n            }\n        }\n        else {\n            localX = p1;\n            localY = p2;\n            if (typeof p3 === 'number') {\n                localAngle = p3;\n                localOptions = options;\n            }\n            else {\n                localOptions = p3;\n            }\n        }\n        // merge label position arguments\n        const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n        const labelPositionArgs = localOptions;\n        const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n        // append label to labels array\n        const label = {\n            position: this.getLabelPosition(localX, localY, localAngle, positionArgs),\n        };\n        const index = -1;\n        this.cell.insertLabel(label, index, localOptions);\n        return index;\n    }\n    addVertex(x, y, options) {\n        const isPoint = typeof x !== 'number';\n        const localX = isPoint ? x.x : x;\n        const localY = isPoint ? x.y : y;\n        const localOptions = isPoint ? y : options;\n        const vertex = { x: localX, y: localY };\n        const index = this.getVertexIndex(localX, localY);\n        this.cell.insertVertex(vertex, index, localOptions);\n        return index;\n    }\n    sendToken(token, options, callback) {\n        let duration;\n        let reversed;\n        let selector;\n        let rorate;\n        let timing = 'linear';\n        if (typeof options === 'object') {\n            duration = options.duration;\n            reversed = options.reversed === true;\n            selector = options.selector;\n            if (options.rotate === false) {\n                rorate = '';\n            }\n            else if (options.rotate === true) {\n                rorate = 'auto';\n            }\n            else if (options.rotate != null) {\n                rorate = `${options.rotate}`;\n            }\n            if (options.timing) {\n                timing = options.timing;\n            }\n        }\n        else {\n            duration = options;\n            reversed = false;\n            selector = null;\n        }\n        duration = duration || 1000;\n        const attrs = {\n            dur: `${duration}ms`,\n            repeatCount: '1',\n            calcMode: timing,\n            fill: 'freeze',\n        };\n        if (rorate) {\n            attrs.rotate = rorate;\n        }\n        if (reversed) {\n            attrs.keyPoints = '1;0';\n            attrs.keyTimes = '0;1';\n        }\n        if (typeof options === 'object') {\n            const { duration, reversed, selector, rotate, timing } = options, others = __rest(options, [\"duration\", \"reversed\", \"selector\", \"rotate\", \"timing\"]);\n            Object.keys(others).forEach((key) => {\n                attrs[key] = others[key];\n            });\n        }\n        let path;\n        if (typeof selector === 'string') {\n            path = this.findOne(selector, this.container, this.selectors);\n        }\n        else {\n            // Select connection path automatically.\n            path = this.containers.connection\n                ? this.containers.connection\n                : this.container.querySelector('path');\n        }\n        if (!(path instanceof SVGPathElement)) {\n            throw new Error('Token animation requires a valid connection path.');\n        }\n        const target = typeof token === 'string' ? this.findOne(token) : token;\n        if (target == null) {\n            throw new Error('Token animation requires a valid token element.');\n        }\n        const parent = target.parentNode;\n        const revert = () => {\n            if (!parent) {\n                Dom.remove(target);\n            }\n        };\n        const vToken = Vector.create(target);\n        if (!parent) {\n            vToken.appendTo(this.graph.view.stage);\n        }\n        const onComplete = attrs.complete;\n        attrs.complete = (e) => {\n            revert();\n            if (callback) {\n                callback();\n            }\n            if (onComplete) {\n                onComplete(e);\n            }\n        };\n        const stop = vToken.animateAlongPath(attrs, path);\n        return () => {\n            revert();\n            stop();\n        };\n    }\n    // #endregion\n    getConnection() {\n        return this.path != null ? this.path.clone() : null;\n    }\n    getConnectionPathData() {\n        if (this.path == null) {\n            return '';\n        }\n        const cache = this.cache.pathCache;\n        if (!ObjectExt.has(cache, 'data')) {\n            cache.data = this.path.serialize();\n        }\n        return cache.data || '';\n    }\n    getConnectionSubdivisions() {\n        if (this.path == null) {\n            return null;\n        }\n        const cache = this.cache.pathCache;\n        if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n            cache.segmentSubdivisions = this.path.getSegmentSubdivisions();\n        }\n        return cache.segmentSubdivisions;\n    }\n    getConnectionLength() {\n        if (this.path == null) {\n            return 0;\n        }\n        const cache = this.cache.pathCache;\n        if (!ObjectExt.has(cache, 'length')) {\n            cache.length = this.path.length({\n                segmentSubdivisions: this.getConnectionSubdivisions(),\n            });\n        }\n        return cache.length;\n    }\n    getPointAtLength(length) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.pointAtLength(length, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getPointAtRatio(ratio) {\n        if (this.path == null) {\n            return null;\n        }\n        if (NumberExt.isPercentage(ratio)) {\n            // eslint-disable-next-line\n            ratio = parseFloat(ratio) / 100;\n        }\n        return this.path.pointAt(ratio, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getTangentAtLength(length) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.tangentAtLength(length, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getTangentAtRatio(ratio) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.tangentAt(ratio, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getClosestPoint(point) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.closestPoint(point, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getClosestPointLength(point) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.closestPointLength(point, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getClosestPointRatio(point) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.closestPointNormalizedLength(point, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getLabelPosition(x, y, p3, p4) {\n        const pos = { distance: 0 };\n        // normalize data from the two possible signatures\n        let angle = 0;\n        let options;\n        if (typeof p3 === 'number') {\n            angle = p3;\n            options = p4;\n        }\n        else {\n            options = p3;\n        }\n        if (options != null) {\n            pos.options = options;\n        }\n        // identify distance/offset settings\n        const isOffsetAbsolute = options && options.absoluteOffset;\n        const isDistanceRelative = !(options && options.absoluteDistance);\n        const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance;\n        // find closest point t\n        const path = this.path;\n        const pathOptions = {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        };\n        const labelPoint = new Point(x, y);\n        const t = path.closestPointT(labelPoint, pathOptions);\n        // distance\n        const totalLength = this.getConnectionLength() || 0;\n        let labelDistance = path.lengthAtT(t, pathOptions);\n        if (isDistanceRelative) {\n            labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;\n        }\n        if (isDistanceAbsoluteReverse) {\n            // fix for end point (-0 => 1)\n            labelDistance = -1 * (totalLength - labelDistance) || 1;\n        }\n        pos.distance = labelDistance;\n        // offset\n        // use absolute offset if:\n        // - options.absoluteOffset is true,\n        // - options.absoluteOffset is not true but there is no tangent\n        let tangent;\n        if (!isOffsetAbsolute)\n            tangent = path.tangentAtT(t);\n        let labelOffset;\n        if (tangent) {\n            labelOffset = tangent.pointOffset(labelPoint);\n        }\n        else {\n            const closestPoint = path.pointAtT(t);\n            const labelOffsetDiff = labelPoint.diff(closestPoint);\n            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n        }\n        pos.offset = labelOffset;\n        pos.angle = angle;\n        return pos;\n    }\n    normalizeLabelPosition(pos) {\n        if (typeof pos === 'number') {\n            return { distance: pos };\n        }\n        return pos;\n    }\n    getLabelTransformationMatrix(labelPosition) {\n        const pos = this.normalizeLabelPosition(labelPosition);\n        const options = pos.options || {};\n        const labelAngle = pos.angle || 0;\n        const labelDistance = pos.distance;\n        const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n        let labelOffset = 0;\n        const offsetCoord = { x: 0, y: 0 };\n        const offset = pos.offset;\n        if (offset) {\n            if (typeof offset === 'number') {\n                labelOffset = offset;\n            }\n            else {\n                if (offset.x != null) {\n                    offsetCoord.x = offset.x;\n                }\n                if (offset.y != null) {\n                    offsetCoord.y = offset.y;\n                }\n            }\n        }\n        const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;\n        const isKeepGradient = options.keepGradient;\n        const isEnsureLegibility = options.ensureLegibility;\n        const path = this.path;\n        const pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n        const distance = isDistanceRelative\n            ? labelDistance * this.getConnectionLength()\n            : labelDistance;\n        const tangent = path.tangentAtLength(distance, pathOpt);\n        let translation;\n        let angle = labelAngle;\n        if (tangent) {\n            if (isOffsetAbsolute) {\n                translation = tangent.start;\n                translation.translate(offsetCoord);\n            }\n            else {\n                const normal = tangent.clone();\n                normal.rotate(-90, tangent.start);\n                normal.setLength(labelOffset);\n                translation = normal.end;\n            }\n            if (isKeepGradient) {\n                angle = tangent.angle() + labelAngle;\n                if (isEnsureLegibility) {\n                    angle = Angle.normalize(((angle + 90) % 180) - 90);\n                }\n            }\n        }\n        else {\n            // fallback - the connection has zero length\n            translation = path.start;\n            if (isOffsetAbsolute) {\n                translation.translate(offsetCoord);\n            }\n        }\n        return Dom.createSVGMatrix()\n            .translate(translation.x, translation.y)\n            .rotate(angle);\n    }\n    getLabelCoordinates(pos) {\n        const matrix = this.getLabelTransformationMatrix(pos);\n        return new Point(matrix.e, matrix.f);\n    }\n    getVertexIndex(x, y) {\n        const edge = this.cell;\n        const vertices = edge.getVertices();\n        const vertexLength = this.getClosestPointLength(new Point(x, y));\n        let index = 0;\n        if (vertexLength != null) {\n            for (const ii = vertices.length; index < ii; index += 1) {\n                const currentVertex = vertices[index];\n                const currentLength = this.getClosestPointLength(currentVertex);\n                if (currentLength != null && vertexLength < currentLength) {\n                    break;\n                }\n            }\n        }\n        return index;\n    }\n    getEventArgs(e, x, y) {\n        const view = this; // eslint-disable-line\n        const edge = view.cell;\n        const cell = edge;\n        if (x == null || y == null) {\n            return { e, view, edge, cell };\n        }\n        return { e, x, y, view, edge, cell };\n    }\n    notifyUnhandledMouseDown(e, x, y) {\n        this.notify('edge:unhandled:mousedown', {\n            e,\n            x,\n            y,\n            view: this,\n            cell: this.cell,\n            edge: this.cell,\n        });\n    }\n    notifyMouseDown(e, x, y) {\n        super.onMouseDown(e, x, y);\n        this.notify('edge:mousedown', this.getEventArgs(e, x, y));\n    }\n    notifyMouseMove(e, x, y) {\n        super.onMouseMove(e, x, y);\n        this.notify('edge:mousemove', this.getEventArgs(e, x, y));\n    }\n    notifyMouseUp(e, x, y) {\n        super.onMouseUp(e, x, y);\n        this.notify('edge:mouseup', this.getEventArgs(e, x, y));\n    }\n    onClick(e, x, y) {\n        super.onClick(e, x, y);\n        this.notify('edge:click', this.getEventArgs(e, x, y));\n    }\n    onDblClick(e, x, y) {\n        super.onDblClick(e, x, y);\n        this.notify('edge:dblclick', this.getEventArgs(e, x, y));\n    }\n    onContextMenu(e, x, y) {\n        super.onContextMenu(e, x, y);\n        this.notify('edge:contextmenu', this.getEventArgs(e, x, y));\n    }\n    onMouseDown(e, x, y) {\n        this.notifyMouseDown(e, x, y);\n        const className = e.target.getAttribute('class');\n        switch (className) {\n            case 'vertex': {\n                this.startVertexDragging(e, x, y);\n                return;\n            }\n            case 'vertex-remove':\n            case 'vertex-remove-area': {\n                this.handleVertexRemoving(e, x, y);\n                return;\n            }\n            case 'connection':\n            case 'connection-wrap': {\n                this.handleVertexAdding(e, x, y);\n                return;\n            }\n            case 'arrowhead': {\n                this.startArrowheadDragging(e, x, y);\n                return;\n            }\n            case 'source-marker':\n            case 'target-marker': {\n                this.notifyUnhandledMouseDown(e, x, y);\n                return;\n            }\n            default:\n                break;\n        }\n        this.startEdgeDragging(e, x, y);\n    }\n    onMouseMove(e, x, y) {\n        const data = this.getEventData(e);\n        switch (data.action) {\n            case 'drag-vertex': {\n                this.dragVertex(e, x, y);\n                break;\n            }\n            case 'drag-label': {\n                this.dragLabel(e, x, y);\n                break;\n            }\n            case 'drag-arrowhead': {\n                this.dragArrowhead(e, x, y);\n                break;\n            }\n            case 'drag-edge': {\n                this.dragEdge(e, x, y);\n                break;\n            }\n            default:\n                break;\n        }\n        this.notifyMouseMove(e, x, y);\n        return data;\n    }\n    onMouseUp(e, x, y) {\n        const data = this.getEventData(e);\n        switch (data.action) {\n            case 'drag-vertex': {\n                this.stopVertexDragging(e, x, y);\n                break;\n            }\n            case 'drag-label': {\n                this.stopLabelDragging(e, x, y);\n                break;\n            }\n            case 'drag-arrowhead': {\n                this.stopArrowheadDragging(e, x, y);\n                break;\n            }\n            case 'drag-edge': {\n                this.stopEdgeDragging(e, x, y);\n                break;\n            }\n            default:\n                break;\n        }\n        this.notifyMouseUp(e, x, y);\n        this.checkMouseleave(e);\n        return data;\n    }\n    onMouseOver(e) {\n        super.onMouseOver(e);\n        this.notify('edge:mouseover', this.getEventArgs(e));\n    }\n    onMouseOut(e) {\n        super.onMouseOut(e);\n        this.notify('edge:mouseout', this.getEventArgs(e));\n    }\n    onMouseEnter(e) {\n        super.onMouseEnter(e);\n        this.notify('edge:mouseenter', this.getEventArgs(e));\n    }\n    onMouseLeave(e) {\n        super.onMouseLeave(e);\n        this.notify('edge:mouseleave', this.getEventArgs(e));\n    }\n    onMouseWheel(e, x, y, delta) {\n        super.onMouseWheel(e, x, y, delta);\n        this.notify('edge:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));\n    }\n    onCustomEvent(e, name, x, y) {\n        // For default edge tool\n        const tool = Dom.findParentByClass(e.target, 'edge-tool', this.container);\n        if (tool) {\n            e.stopPropagation(); // no further action to be executed\n            if (this.can('useEdgeTools')) {\n                if (name === 'edge:remove') {\n                    this.cell.remove({ ui: true });\n                    return;\n                }\n                this.notify('edge:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));\n            }\n            this.notifyMouseDown(e, x, y);\n        }\n        else {\n            this.notify('edge:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));\n            super.onCustomEvent(e, name, x, y);\n        }\n    }\n    onLabelMouseDown(e, x, y) {\n        this.notifyMouseDown(e, x, y);\n        this.startLabelDragging(e, x, y);\n        const stopPropagation = this.getEventData(e).stopPropagation;\n        if (stopPropagation) {\n            e.stopPropagation();\n        }\n    }\n    // #region drag edge\n    startEdgeDragging(e, x, y) {\n        if (!this.can('edgeMovable')) {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n        }\n        this.setEventData(e, {\n            x,\n            y,\n            moving: false,\n            action: 'drag-edge',\n        });\n    }\n    dragEdge(e, x, y) {\n        const data = this.getEventData(e);\n        if (!data.moving) {\n            data.moving = true;\n            this.addClass('edge-moving');\n            this.notify('edge:move', {\n                e,\n                x,\n                y,\n                view: this,\n                cell: this.cell,\n                edge: this.cell,\n            });\n        }\n        this.cell.translate(x - data.x, y - data.y, { ui: true });\n        this.setEventData(e, { x, y });\n        this.notify('edge:moving', {\n            e,\n            x,\n            y,\n            view: this,\n            cell: this.cell,\n            edge: this.cell,\n        });\n    }\n    stopEdgeDragging(e, x, y) {\n        const data = this.getEventData(e);\n        if (data.moving) {\n            this.removeClass('edge-moving');\n            this.notify('edge:moved', {\n                e,\n                x,\n                y,\n                view: this,\n                cell: this.cell,\n                edge: this.cell,\n            });\n        }\n        data.moving = false;\n    }\n    // #endregion\n    // #region drag arrowhead\n    prepareArrowheadDragging(type, options) {\n        const magnet = this.getTerminalMagnet(type);\n        const data = {\n            action: 'drag-arrowhead',\n            x: options.x,\n            y: options.y,\n            isNewEdge: options.isNewEdge === true,\n            terminalType: type,\n            initialMagnet: magnet,\n            initialTerminal: ObjectExt.clone(this.cell[type]),\n            fallbackAction: options.fallbackAction || 'revert',\n            getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n            options: options.options,\n        };\n        this.beforeArrowheadDragging(data);\n        return data;\n    }\n    createValidateConnectionArgs(type) {\n        const args = [];\n        args[4] = type;\n        args[5] = this;\n        let opposite;\n        let i = 0;\n        let j = 0;\n        if (type === 'source') {\n            i = 2;\n            opposite = 'target';\n        }\n        else {\n            j = 2;\n            opposite = 'source';\n        }\n        const terminal = this.cell[opposite];\n        const cellId = terminal.cell;\n        if (cellId) {\n            let magnet;\n            const view = (args[i] = this.graph.renderer.findViewByCell(cellId));\n            if (view) {\n                magnet = view.getMagnetFromEdgeTerminal(terminal);\n                if (magnet === view.container) {\n                    magnet = undefined;\n                }\n            }\n            args[i + 1] = magnet;\n        }\n        return (cellView, magnet) => {\n            args[j] = cellView;\n            args[j + 1] = cellView.container === magnet ? undefined : magnet;\n            return args;\n        };\n    }\n    beforeArrowheadDragging(data) {\n        data.zIndex = this.cell.zIndex;\n        this.cell.toFront();\n        const style = this.container.style;\n        data.pointerEvents = style.pointerEvents;\n        style.pointerEvents = 'none';\n        if (this.graph.options.connecting.highlight) {\n            this.highlightAvailableMagnets(data);\n        }\n    }\n    afterArrowheadDragging(data) {\n        if (data.zIndex != null) {\n            this.cell.setZIndex(data.zIndex, { ui: true });\n            data.zIndex = null;\n        }\n        const container = this.container;\n        container.style.pointerEvents = data.pointerEvents || '';\n        if (this.graph.options.connecting.highlight) {\n            this.unhighlightAvailableMagnets(data);\n        }\n    }\n    arrowheadDragging(target, x, y, data) {\n        data.x = x;\n        data.y = y;\n        // Checking views right under the pointer\n        if (data.currentTarget !== target) {\n            // Unhighlight the previous view under pointer if there was one.\n            if (data.currentMagnet && data.currentView) {\n                data.currentView.unhighlight(data.currentMagnet, {\n                    type: 'magnetAdsorbed',\n                });\n            }\n            data.currentView = this.graph.renderer.findViewByElem(target);\n            if (data.currentView) {\n                // If we found a view that is under the pointer, we need to find\n                // the closest magnet based on the real target element of the event.\n                data.currentMagnet = data.currentView.findMagnet(target);\n                if (data.currentMagnet &&\n                    this.graph.hook.validateConnection(...data.getValidateConnectionArgs(data.currentView, data.currentMagnet), data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType))) {\n                    data.currentView.highlight(data.currentMagnet, {\n                        type: 'magnetAdsorbed',\n                    });\n                }\n                else {\n                    // This type of connection is not valid. Disregard this magnet.\n                    data.currentMagnet = null;\n                }\n            }\n            else {\n                // Make sure we'll unset previous magnet.\n                data.currentMagnet = null;\n            }\n        }\n        data.currentTarget = target;\n        this.cell.prop(data.terminalType, { x, y }, Object.assign(Object.assign({}, data.options), { ui: true }));\n    }\n    arrowheadDragged(data, x, y) {\n        const view = data.currentView;\n        const magnet = data.currentMagnet;\n        if (!magnet || !view) {\n            return;\n        }\n        view.unhighlight(magnet, { type: 'magnetAdsorbed' });\n        const type = data.terminalType;\n        const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);\n        this.cell.setTerminal(type, terminal, { ui: true });\n    }\n    snapArrowhead(x, y, data) {\n        const graph = this.graph;\n        const snap = graph.options.connecting.snap;\n        const radius = (typeof snap === 'object' && snap.radius) || 50;\n        const views = graph.renderer.findViewsInArea({\n            x: x - radius,\n            y: y - radius,\n            width: 2 * radius,\n            height: 2 * radius,\n        });\n        const prevView = data.closestView || null;\n        const prevMagnet = data.closestMagnet || null;\n        data.closestView = null;\n        data.closestMagnet = null;\n        let distance;\n        let minDistance = Number.MAX_SAFE_INTEGER;\n        const pos = new Point(x, y);\n        views.forEach((view) => {\n            if (view.container.getAttribute('magnet') !== 'false') {\n                // Find distance from the center of the cell to pointer coordinates\n                distance = view.cell.getBBox().getCenter().distance(pos);\n                // the connection is looked up in a circle area by `distance < r`\n                if (distance < radius && distance < minDistance) {\n                    if (prevMagnet === view.container ||\n                        graph.hook.validateConnection(...data.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data.terminalType))) {\n                        minDistance = distance;\n                        data.closestView = view;\n                        data.closestMagnet = view.container;\n                    }\n                }\n            }\n            view.container.querySelectorAll('[magnet]').forEach((magnet) => {\n                if (magnet.getAttribute('magnet') !== 'false') {\n                    const bbox = view.getBBoxOfElement(magnet);\n                    distance = pos.distance(bbox.getCenter());\n                    if (distance < radius && distance < minDistance) {\n                        if (prevMagnet === magnet ||\n                            graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data.terminalType))) {\n                            minDistance = distance;\n                            data.closestView = view;\n                            data.closestMagnet = magnet;\n                        }\n                    }\n                }\n            });\n        });\n        let terminal;\n        const type = data.terminalType;\n        const closestView = data.closestView;\n        const closestMagnet = data.closestMagnet;\n        const changed = prevMagnet !== closestMagnet;\n        if (prevView && changed) {\n            prevView.unhighlight(prevMagnet, {\n                type: 'magnetAdsorbed',\n            });\n        }\n        if (closestView) {\n            if (!changed) {\n                return;\n            }\n            closestView.highlight(closestMagnet, {\n                type: 'magnetAdsorbed',\n            });\n            terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);\n        }\n        else {\n            terminal = { x, y };\n        }\n        this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), { ui: true }));\n    }\n    snapArrowheadEnd(data) {\n        // Finish off link snapping.\n        // Everything except view unhighlighting was already done on pointermove.\n        const closestView = data.closestView;\n        const closestMagnet = data.closestMagnet;\n        if (closestView && closestMagnet) {\n            closestView.unhighlight(closestMagnet, {\n                type: 'magnetAdsorbed',\n            });\n            data.currentMagnet = closestView.findMagnet(closestMagnet);\n        }\n        data.closestView = null;\n        data.closestMagnet = null;\n    }\n    finishEmbedding(data) {\n        // Resets parent of the edge if embedding is enabled\n        if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n            // Make sure we don't reverse to the original 'z' index\n            data.zIndex = null;\n        }\n    }\n    fallbackConnection(data) {\n        switch (data.fallbackAction) {\n            case 'remove':\n                this.cell.remove({ ui: true });\n                break;\n            case 'revert':\n            default:\n                this.cell.prop(data.terminalType, data.initialTerminal, {\n                    ui: true,\n                });\n                break;\n        }\n    }\n    notifyConnectionEvent(data, e) {\n        const terminalType = data.terminalType;\n        const initialTerminal = data.initialTerminal;\n        const currentTerminal = this.cell[terminalType];\n        const changed = currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal);\n        if (changed) {\n            const graph = this.graph;\n            const previous = initialTerminal;\n            const previousCell = previous.cell\n                ? graph.getCellById(previous.cell)\n                : null;\n            const previousPort = previous.port;\n            const previousView = previousCell\n                ? graph.findViewByCell(previousCell)\n                : null;\n            const previousPoint = previousCell || data.isNewEdge\n                ? null\n                : Point.create(initialTerminal).toJSON();\n            const current = currentTerminal;\n            const currentCell = current.cell ? graph.getCellById(current.cell) : null;\n            const currentPort = current.port;\n            const currentView = currentCell ? graph.findViewByCell(currentCell) : null;\n            const currentPoint = currentCell\n                ? null\n                : Point.create(currentTerminal).toJSON();\n            this.notify('edge:connected', {\n                e,\n                previousCell,\n                previousPort,\n                previousView,\n                previousPoint,\n                currentCell,\n                currentView,\n                currentPort,\n                currentPoint,\n                previousMagnet: data.initialMagnet,\n                currentMagnet: data.currentMagnet,\n                edge: this.cell,\n                view: this,\n                type: terminalType,\n                isNew: data.isNewEdge,\n            });\n        }\n    }\n    highlightAvailableMagnets(data) {\n        const graph = this.graph;\n        const cells = graph.model.getCells();\n        data.marked = {};\n        for (let i = 0, ii = cells.length; i < ii; i += 1) {\n            const view = graph.renderer.findViewByCell(cells[i]);\n            if (!view) {\n                continue;\n            }\n            const magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));\n            if (view.container.getAttribute('magnet') !== 'false') {\n                magnets.push(view.container);\n            }\n            const availableMagnets = magnets.filter((magnet) => graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data.x, data.y, this.cell, data.terminalType)));\n            if (availableMagnets.length > 0) {\n                // highlight all available magnets\n                for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n                    view.highlight(availableMagnets[j], { type: 'magnetAvailable' });\n                }\n                // highlight the entire view\n                view.highlight(null, { type: 'nodeAvailable' });\n                data.marked[view.cell.id] = availableMagnets;\n            }\n        }\n    }\n    unhighlightAvailableMagnets(data) {\n        const marked = data.marked || {};\n        Object.keys(marked).forEach((id) => {\n            const view = this.graph.renderer.findViewByCell(id);\n            if (view) {\n                const magnets = marked[id];\n                magnets.forEach((magnet) => {\n                    view.unhighlight(magnet, { type: 'magnetAvailable' });\n                });\n                view.unhighlight(null, { type: 'nodeAvailable' });\n            }\n        });\n        data.marked = null;\n    }\n    startArrowheadDragging(e, x, y) {\n        if (!this.can('arrowheadMovable')) {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n        }\n        const elem = e.target;\n        const type = elem.getAttribute('data-terminal');\n        const data = this.prepareArrowheadDragging(type, { x, y });\n        this.setEventData(e, data);\n    }\n    dragArrowhead(e, x, y) {\n        const data = this.getEventData(e);\n        if (this.graph.options.connecting.snap) {\n            this.snapArrowhead(x, y, data);\n        }\n        else {\n            this.arrowheadDragging(this.getEventTarget(e), x, y, data);\n        }\n    }\n    stopArrowheadDragging(e, x, y) {\n        const graph = this.graph;\n        const data = this.getEventData(e);\n        if (graph.options.connecting.snap) {\n            this.snapArrowheadEnd(data);\n        }\n        else {\n            this.arrowheadDragged(data, x, y);\n        }\n        const valid = graph.hook.validateEdge(this.cell, data.terminalType, data.initialTerminal);\n        if (valid) {\n            this.finishEmbedding(data);\n            this.notifyConnectionEvent(data, e);\n        }\n        else {\n            // If the changed edge is not allowed, revert to its previous state.\n            this.fallbackConnection(data);\n        }\n        this.afterArrowheadDragging(data);\n    }\n    // #endregion\n    // #region drag lable\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startLabelDragging(e, x, y) {\n        if (this.can('edgeLabelMovable')) {\n            const target = e.currentTarget;\n            const index = parseInt(target.getAttribute('data-index'), 10);\n            const positionAngle = this.getLabelPositionAngle(index);\n            const labelPositionArgs = this.getLabelPositionArgs(index);\n            const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n            const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n            this.setEventData(e, {\n                index,\n                positionAngle,\n                positionArgs,\n                stopPropagation: true,\n                action: 'drag-label',\n            });\n        }\n        else {\n            // If labels can't be dragged no default action is triggered.\n            this.setEventData(e, { stopPropagation: true });\n        }\n        this.graph.view.delegateDragEvents(e, this);\n    }\n    dragLabel(e, x, y) {\n        const data = this.getEventData(e);\n        const originLabel = this.cell.getLabelAt(data.index);\n        const label = ObjectExt.merge({}, originLabel, {\n            position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs),\n        });\n        this.cell.setLabelAt(data.index, label);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    stopLabelDragging(e, x, y) { }\n    // #endregion\n    // #region drag vertex\n    handleVertexAdding(e, x, y) {\n        if (!this.can('vertexAddable')) {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n        }\n        // Store the index at which the new vertex has just been placed.\n        // We'll be update the very same vertex position in `pointermove()`.\n        const index = this.addVertex({ x, y }, { ui: true });\n        this.setEventData(e, {\n            index,\n            action: 'drag-vertex',\n        });\n    }\n    handleVertexRemoving(e, x, y) {\n        if (!this.can('vertexDeletable')) {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n        }\n        const target = e.target;\n        const index = parseInt(target.getAttribute('idx'), 10);\n        this.cell.removeVertexAt(index);\n    }\n    startVertexDragging(e, x, y) {\n        if (!this.can('vertexMovable')) {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n        }\n        const target = e.target;\n        const index = parseInt(target.getAttribute('idx'), 10);\n        this.setEventData(e, {\n            index,\n            action: 'drag-vertex',\n        });\n    }\n    dragVertex(e, x, y) {\n        const data = this.getEventData(e);\n        this.cell.setVertexAt(data.index, { x, y }, { ui: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    stopVertexDragging(e, x, y) { }\n}\n(function (EdgeView) {\n    EdgeView.toStringTag = `X6.${EdgeView.name}`;\n    function isEdgeView(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof EdgeView) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const view = instance;\n        if ((tag == null || tag === EdgeView.toStringTag) &&\n            typeof view.isNodeView === 'function' &&\n            typeof view.isEdgeView === 'function' &&\n            typeof view.confirmUpdate === 'function' &&\n            typeof view.update === 'function' &&\n            typeof view.getConnection === 'function') {\n            return true;\n        }\n        return false;\n    }\n    EdgeView.isEdgeView = isEdgeView;\n})(EdgeView || (EdgeView = {}));\nEdgeView.config({\n    isSvgElement: true,\n    priority: 1,\n    bootstrap: ['render', 'source', 'target'],\n    actions: {\n        view: ['render'],\n        markup: ['render'],\n        attrs: ['update'],\n        source: ['source', 'update'],\n        target: ['target', 'update'],\n        router: ['update'],\n        connector: ['update'],\n        labels: ['labels'],\n        defaultLabel: ['labels'],\n        vertices: ['vertices', 'update'],\n        vertexMarkup: ['vertices'],\n        toolMarkup: ['tools'],\n        tools: ['widget'],\n    },\n    shortLength: 105,\n    longLength: 155,\n    toolsOffset: 40,\n    doubleTools: false,\n    doubleToolsOffset: 65,\n    sampleInterval: 50,\n});\nEdgeView.registry.register('edge', EdgeView, true);\n//# sourceMappingURL=edge.js.map"]},"metadata":{},"sourceType":"module"}