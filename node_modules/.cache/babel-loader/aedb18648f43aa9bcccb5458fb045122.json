{"ast":null,"code":"import _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/* eslint-disable no-underscore-dangle */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ArrayExt, StringExt, ObjectExt, FunctionExt } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Basecoat } from '../common';\nimport { Attr } from '../registry';\nimport { Animation } from './animation';\nimport { Store } from './store';\nexport var Cell = /*#__PURE__*/function (_Basecoat, _Symbol$toStringTag) {\n  _inherits(Cell, _Basecoat);\n\n  var _super = _createSuper(Cell);\n\n  function Cell() {\n    var _this;\n\n    var metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Cell);\n\n    _this = _super.call(this);\n    var ctor = _this.constructor;\n    var defaults = ctor.getDefaults(true);\n    var props = ObjectExt.merge({}, _this.preprocess(defaults), _this.preprocess(metadata));\n    _this.id = props.id || StringExt.uuid();\n    _this.store = new Store(props);\n    _this.animation = new Animation(_assertThisInitialized(_this));\n\n    _this.setup();\n\n    _this.init();\n\n    _this.postprocess(metadata);\n\n    return _this;\n  }\n\n  _createClass(Cell, [{\n    key: _Symbol$toStringTag,\n    get: // #endregion\n    function get() {\n      return Cell.toStringTag;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {} // #region model\n\n  }, {\n    key: \"model\",\n    get: function get() {\n      return this._model;\n    }\n  }, {\n    key: \"model\",\n    set: function set(model) {\n      if (this._model !== model) {\n        this._model = model;\n      }\n    } // #endregion\n\n  }, {\n    key: \"preprocess\",\n    value: function preprocess(metadata, ignoreIdCheck) {\n      var id = metadata.id;\n      var ctor = this.constructor;\n      var props = ctor.applyPropHooks(this, metadata);\n\n      if (id == null && ignoreIdCheck !== true) {\n        props.id = StringExt.uuid();\n      }\n\n      return props;\n    }\n  }, {\n    key: \"postprocess\",\n    value: function postprocess(metadata) {} // eslint-disable-line\n\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this2 = this;\n\n      this.store.on('change:*', function (metadata) {\n        var key = metadata.key,\n            current = metadata.current,\n            previous = metadata.previous,\n            options = metadata.options;\n\n        _this2.notify('change:*', {\n          key: key,\n          options: options,\n          current: current,\n          previous: previous,\n          cell: _this2\n        });\n\n        _this2.notify(\"change:\".concat(key), {\n          options: options,\n          current: current,\n          previous: previous,\n          cell: _this2\n        });\n\n        var type = key;\n\n        if (type === 'source' || type === 'target') {\n          _this2.notify(\"change:terminal\", {\n            type: type,\n            current: current,\n            previous: previous,\n            options: options,\n            cell: _this2\n          });\n        }\n      });\n      this.store.on('changed', function (_ref) {\n        var options = _ref.options;\n        return _this2.notify('changed', {\n          options: options,\n          cell: _this2\n        });\n      });\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(name, args) {\n      this.trigger(name, args);\n      var model = this.model;\n\n      if (model) {\n        model.notify(\"cell:\".concat(name), args);\n\n        if (this.isNode()) {\n          model.notify(\"node:\".concat(name), Object.assign(Object.assign({}, args), {\n            node: this\n          }));\n        } else if (this.isEdge()) {\n          model.notify(\"edge:\".concat(name), Object.assign(Object.assign({}, args), {\n            edge: this\n          }));\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"isNode\",\n    value: function isNode() {\n      return false;\n    }\n  }, {\n    key: \"isEdge\",\n    value: function isEdge() {\n      return false;\n    }\n  }, {\n    key: \"isSameStore\",\n    value: function isSameStore(cell) {\n      return this.store === cell.store;\n    }\n  }, {\n    key: \"view\",\n    get: function get() {\n      return this.store.get('view');\n    }\n  }, {\n    key: \"shape\",\n    get: function get() {\n      return this.store.get('shape', '');\n    }\n  }, {\n    key: \"getProp\",\n    value: function getProp(key, defaultValue) {\n      if (key == null) {\n        return this.store.get();\n      }\n\n      return this.store.get(key, defaultValue);\n    }\n  }, {\n    key: \"setProp\",\n    value: function setProp(key, value, options) {\n      if (typeof key === 'string') {\n        this.store.set(key, value, options);\n      } else {\n        var props = this.preprocess(key, true);\n        this.store.set(ObjectExt.merge({}, this.getProp(), props), value);\n        this.postprocess(key);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeProp\",\n    value: function removeProp(key, options) {\n      if (typeof key === 'string' || Array.isArray(key)) {\n        this.store.removeByPath(key, options);\n      } else {\n        this.store.remove(options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"hasChanged\",\n    value: function hasChanged(key) {\n      return key == null ? this.store.hasChanged() : this.store.hasChanged(key);\n    }\n  }, {\n    key: \"getPropByPath\",\n    value: function getPropByPath(path) {\n      return this.store.getByPath(path);\n    }\n  }, {\n    key: \"setPropByPath\",\n    value: function setPropByPath(path, value) {\n      var _this3 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (this.model) {\n        // update inner reference\n        if (path === 'children') {\n          this._children = value ? value.map(function (id) {\n            return _this3.model.getCell(id);\n          }).filter(function (child) {\n            return child != null;\n          }) : null;\n        } else if (path === 'parent') {\n          this._parent = value ? this.model.getCell(value) : null;\n        }\n      }\n\n      this.store.setByPath(path, value, options);\n      return this;\n    }\n  }, {\n    key: \"removePropByPath\",\n    value: function removePropByPath(path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var paths = Array.isArray(path) ? path : path.split('/'); // Once a property is removed from the `attrs` the CellView will\n      // recognize a `dirty` flag and re-render itself in order to remove\n      // the attribute from SVGElement.\n\n      if (paths[0] === 'attrs') {\n        options.dirty = true;\n      }\n\n      this.store.removeByPath(paths, options);\n      return this;\n    }\n  }, {\n    key: \"prop\",\n    value: function prop(key, value, options) {\n      if (key == null) {\n        return this.getProp();\n      }\n\n      if (typeof key === 'string' || Array.isArray(key)) {\n        if (arguments.length === 1) {\n          return this.getPropByPath(key);\n        }\n\n        if (value == null) {\n          return this.removePropByPath(key, options || {});\n        }\n\n        return this.setPropByPath(key, value, options || {});\n      }\n\n      return this.setProp(key, value || {});\n    }\n  }, {\n    key: \"previous\",\n    value: function previous(name) {\n      return this.store.getPrevious(name);\n    } // #endregion\n    // #region zIndex\n\n  }, {\n    key: \"zIndex\",\n    get: function get() {\n      return this.getZIndex();\n    }\n  }, {\n    key: \"zIndex\",\n    set: function set(z) {\n      if (z == null) {\n        this.removeZIndex();\n      } else {\n        this.setZIndex(z);\n      }\n    }\n  }, {\n    key: \"getZIndex\",\n    value: function getZIndex() {\n      return this.store.get('zIndex');\n    }\n  }, {\n    key: \"setZIndex\",\n    value: function setZIndex(z) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('zIndex', z, options);\n      return this;\n    }\n  }, {\n    key: \"removeZIndex\",\n    value: function removeZIndex() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('zIndex', options);\n      return this;\n    }\n  }, {\n    key: \"toFront\",\n    value: function toFront() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var model = this.model;\n\n      if (model) {\n        var z = model.getMaxZIndex();\n        var cells;\n\n        if (options.deep) {\n          cells = this.getDescendants({\n            deep: true,\n            breadthFirst: true\n          });\n          cells.unshift(this);\n        } else {\n          cells = [this];\n        }\n\n        z = z - cells.length + 1;\n        var count = model.total();\n        var changed = model.indexOf(this) !== count - cells.length;\n\n        if (!changed) {\n          changed = cells.some(function (cell, index) {\n            return cell.getZIndex() !== z + index;\n          });\n        }\n\n        if (changed) {\n          this.batchUpdate('to-front', function () {\n            z += cells.length;\n            cells.forEach(function (cell, index) {\n              cell.setZIndex(z + index, options);\n            });\n          });\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"toBack\",\n    value: function toBack() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var model = this.model;\n\n      if (model) {\n        var z = model.getMinZIndex();\n        var cells;\n\n        if (options.deep) {\n          cells = this.getDescendants({\n            deep: true,\n            breadthFirst: true\n          });\n          cells.unshift(this);\n        } else {\n          cells = [this];\n        }\n\n        var changed = model.indexOf(this) !== 0;\n\n        if (!changed) {\n          changed = cells.some(function (cell, index) {\n            return cell.getZIndex() !== z + index;\n          });\n        }\n\n        if (changed) {\n          this.batchUpdate('to-back', function () {\n            z -= cells.length;\n            cells.forEach(function (cell, index) {\n              cell.setZIndex(z + index, options);\n            });\n          });\n        }\n      }\n\n      return this;\n    } // #endregion\n    // #region markup\n\n  }, {\n    key: \"markup\",\n    get: function get() {\n      return this.getMarkup();\n    }\n  }, {\n    key: \"markup\",\n    set: function set(value) {\n      if (value == null) {\n        this.removeMarkup();\n      } else {\n        this.setMarkup(value);\n      }\n    }\n  }, {\n    key: \"getMarkup\",\n    value: function getMarkup() {\n      var markup = this.store.get('markup');\n\n      if (markup == null) {\n        var ctor = this.constructor;\n        markup = ctor.getMarkup();\n      }\n\n      return markup;\n    }\n  }, {\n    key: \"setMarkup\",\n    value: function setMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('markup', markup, options);\n      return this;\n    }\n  }, {\n    key: \"removeMarkup\",\n    value: function removeMarkup() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('markup', options);\n      return this;\n    } // #endregion\n    // #region attrs\n\n  }, {\n    key: \"attrs\",\n    get: function get() {\n      return this.getAttrs();\n    }\n  }, {\n    key: \"attrs\",\n    set: function set(value) {\n      if (value == null) {\n        this.removeAttrs();\n      } else {\n        this.setAttrs(value);\n      }\n    }\n  }, {\n    key: \"getAttrs\",\n    value: function getAttrs() {\n      var result = this.store.get('attrs');\n      return result ? Object.assign({}, result) : {};\n    }\n  }, {\n    key: \"setAttrs\",\n    value: function setAttrs(attrs) {\n      var _this4 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (attrs == null) {\n        this.removeAttrs(options);\n      } else {\n        var set = function set(attrs) {\n          return _this4.store.set('attrs', attrs, options);\n        };\n\n        if (options.overwrite === true) {\n          set(attrs);\n        } else {\n          var prev = this.getAttrs();\n\n          if (options.deep === false) {\n            set(Object.assign(Object.assign({}, prev), attrs));\n          } else {\n            set(ObjectExt.merge({}, prev, attrs));\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"replaceAttrs\",\n    value: function replaceAttrs(attrs) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n        overwrite: true\n      }));\n    }\n  }, {\n    key: \"updateAttrs\",\n    value: function updateAttrs(attrs) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n        deep: false\n      }));\n    }\n  }, {\n    key: \"removeAttrs\",\n    value: function removeAttrs() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('attrs', options);\n      return this;\n    }\n  }, {\n    key: \"getAttrDefinition\",\n    value: function getAttrDefinition(attrName) {\n      if (!attrName) {\n        return null;\n      }\n\n      var ctor = this.constructor;\n      var hooks = ctor.getAttrHooks() || {};\n      var definition = hooks[attrName] || Attr.registry.get(attrName);\n\n      if (!definition) {\n        var name = StringExt.camelCase(attrName);\n        definition = hooks[name] || Attr.registry.get(name);\n      }\n\n      return definition || null;\n    }\n  }, {\n    key: \"getAttrByPath\",\n    value: function getAttrByPath(path) {\n      if (path == null || path === '') {\n        return this.getAttrs();\n      }\n\n      return this.getPropByPath(this.prefixAttrPath(path));\n    }\n  }, {\n    key: \"setAttrByPath\",\n    value: function setAttrByPath(path, value) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.setPropByPath(this.prefixAttrPath(path), value, options);\n      return this;\n    }\n  }, {\n    key: \"removeAttrByPath\",\n    value: function removeAttrByPath(path) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.removePropByPath(this.prefixAttrPath(path), options);\n      return this;\n    }\n  }, {\n    key: \"prefixAttrPath\",\n    value: function prefixAttrPath(path) {\n      return Array.isArray(path) ? ['attrs'].concat(path) : \"attrs/\".concat(path);\n    }\n  }, {\n    key: \"attr\",\n    value: function attr(path, value, options) {\n      if (path == null) {\n        return this.getAttrByPath();\n      }\n\n      if (typeof path === 'string' || Array.isArray(path)) {\n        if (arguments.length === 1) {\n          return this.getAttrByPath(path);\n        }\n\n        if (value == null) {\n          return this.removeAttrByPath(path, options || {});\n        }\n\n        return this.setAttrByPath(path, value, options || {});\n      }\n\n      return this.setAttrs(path, value || {});\n    } // #endregion\n    // #region visible\n\n  }, {\n    key: \"visible\",\n    get: function get() {\n      return this.isVisible();\n    }\n  }, {\n    key: \"visible\",\n    set: function set(value) {\n      this.setVisible(value);\n    }\n  }, {\n    key: \"setVisible\",\n    value: function setVisible(visible) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('visible', visible, options);\n      return this;\n    }\n  }, {\n    key: \"isVisible\",\n    value: function isVisible() {\n      return this.store.get('visible') !== false;\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.isVisible()) {\n        this.setVisible(true, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.isVisible()) {\n        this.setVisible(false, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"toggleVisible\",\n    value: function toggleVisible(isVisible) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();\n      var localOptions = typeof isVisible === 'boolean' ? options : isVisible;\n\n      if (visible) {\n        this.show(localOptions);\n      } else {\n        this.hide(localOptions);\n      }\n\n      return this;\n    } // #endregion\n    // #region data\n\n  }, {\n    key: \"data\",\n    get: function get() {\n      return this.getData();\n    }\n  }, {\n    key: \"data\",\n    set: function set(val) {\n      this.setData(val);\n    }\n  }, {\n    key: \"getData\",\n    value: function getData() {\n      return this.store.get('data');\n    }\n  }, {\n    key: \"setData\",\n    value: function setData(data) {\n      var _this5 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (data == null) {\n        this.removeData(options);\n      } else {\n        var set = function set(data) {\n          return _this5.store.set('data', data, options);\n        };\n\n        if (options.overwrite === true) {\n          set(data);\n        } else {\n          var prev = this.getData();\n\n          if (options.deep === false) {\n            set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);\n          } else {\n            set(ObjectExt.merge({}, prev, data));\n          }\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"replaceData\",\n    value: function replaceData(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.setData(data, Object.assign(Object.assign({}, options), {\n        overwrite: true\n      }));\n    }\n  }, {\n    key: \"updateData\",\n    value: function updateData(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.setData(data, Object.assign(Object.assign({}, options), {\n        deep: false\n      }));\n    }\n  }, {\n    key: \"removeData\",\n    value: function removeData() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('data', options);\n      return this;\n    } // #endregion\n    // #region parent children\n\n  }, {\n    key: \"parent\",\n    get: function get() {\n      return this.getParent();\n    }\n  }, {\n    key: \"children\",\n    get: function get() {\n      return this.getChildren();\n    }\n  }, {\n    key: \"getParentId\",\n    value: function getParentId() {\n      return this.store.get('parent');\n    }\n  }, {\n    key: \"getParent\",\n    value: function getParent() {\n      var parent = this._parent;\n\n      if (parent == null && this.store) {\n        var parentId = this.getParentId();\n\n        if (parentId != null && this.model) {\n          parent = this.model.getCell(parentId);\n          this._parent = parent;\n        }\n      }\n\n      return parent;\n    }\n  }, {\n    key: \"getChildren\",\n    value: function getChildren() {\n      var _this6 = this;\n\n      var children = this._children;\n\n      if (children == null) {\n        var childrenIds = this.store.get('children');\n\n        if (childrenIds && childrenIds.length && this.model) {\n          children = childrenIds.map(function (id) {\n            var _a;\n\n            return (_a = _this6.model) === null || _a === void 0 ? void 0 : _a.getCell(id);\n          }).filter(function (cell) {\n            return cell != null;\n          });\n          this._children = children;\n        }\n      }\n\n      return children ? _toConsumableArray(children) : null;\n    }\n  }, {\n    key: \"hasParent\",\n    value: function hasParent() {\n      return this.parent != null;\n    }\n  }, {\n    key: \"isParentOf\",\n    value: function isParentOf(child) {\n      return child != null && child.getParent() === this;\n    }\n  }, {\n    key: \"isChildOf\",\n    value: function isChildOf(parent) {\n      return parent != null && this.getParent() === parent;\n    }\n  }, {\n    key: \"eachChild\",\n    value: function eachChild(iterator, context) {\n      if (this.children) {\n        this.children.forEach(iterator, context);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"filterChild\",\n    value: function filterChild(filter, context) {\n      return this.children ? this.children.filter(filter, context) : [];\n    }\n  }, {\n    key: \"getChildCount\",\n    value: function getChildCount() {\n      return this.children == null ? 0 : this.children.length;\n    }\n  }, {\n    key: \"getChildIndex\",\n    value: function getChildIndex(child) {\n      return this.children == null ? -1 : this.children.indexOf(child);\n    }\n  }, {\n    key: \"getChildAt\",\n    value: function getChildAt(index) {\n      return this.children != null && index >= 0 ? this.children[index] : null;\n    }\n  }, {\n    key: \"getAncestors\",\n    value: function getAncestors() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var ancestors = [];\n      var parent = this.getParent();\n\n      while (parent) {\n        ancestors.push(parent);\n        parent = options.deep !== false ? parent.getParent() : null;\n      }\n\n      return ancestors;\n    }\n  }, {\n    key: \"getDescendants\",\n    value: function getDescendants() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.deep !== false) {\n        // breadth first\n        if (options.breadthFirst) {\n          var cells = [];\n          var queue = this.getChildren() || [];\n\n          while (queue.length > 0) {\n            var parent = queue.shift();\n            var children = parent.getChildren();\n            cells.push(parent);\n\n            if (children) {\n              queue.push.apply(queue, _toConsumableArray(children));\n            }\n          }\n\n          return cells;\n        } // depth first\n\n\n        {\n          var _cells = this.getChildren() || [];\n\n          _cells.forEach(function (cell) {\n            _cells.push.apply(_cells, _toConsumableArray(cell.getDescendants(options)));\n          });\n\n          return _cells;\n        }\n      }\n\n      return this.getChildren() || [];\n    }\n  }, {\n    key: \"isDescendantOf\",\n    value: function isDescendantOf(ancestor) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (ancestor == null) {\n        return false;\n      }\n\n      if (options.deep !== false) {\n        var current = this.getParent();\n\n        while (current) {\n          if (current === ancestor) {\n            return true;\n          }\n\n          current = current.getParent();\n        }\n\n        return false;\n      }\n\n      return this.isChildOf(ancestor);\n    }\n  }, {\n    key: \"isAncestorOf\",\n    value: function isAncestorOf(descendant) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (descendant == null) {\n        return false;\n      }\n\n      return descendant.isDescendantOf(this, options);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(cell) {\n      return this.isAncestorOf(cell);\n    }\n  }, {\n    key: \"getCommonAncestor\",\n    value: function getCommonAncestor() {\n      for (var _len = arguments.length, cells = new Array(_len), _key = 0; _key < _len; _key++) {\n        cells[_key] = arguments[_key];\n      }\n\n      return Cell.getCommonAncestor.apply(Cell, [this].concat(cells));\n    }\n  }, {\n    key: \"setParent\",\n    value: function setParent(parent) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this._parent = parent;\n\n      if (parent) {\n        this.store.set('parent', parent.id, options);\n      } else {\n        this.store.remove('parent', options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setChildren\",\n    value: function setChildren(children) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this._children = children;\n\n      if (children != null) {\n        this.store.set('children', children.map(function (child) {\n          return child.id;\n        }), options);\n      } else {\n        this.store.remove('children', options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"unembed\",\n    value: function unembed(child) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var children = this.children;\n\n      if (children != null && child != null) {\n        var index = this.getChildIndex(child);\n\n        if (index !== -1) {\n          children.splice(index, 1);\n          child.setParent(null, options);\n          this.setChildren(children, options);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"embed\",\n    value: function embed(child) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      child.addTo(this, options);\n      return this;\n    }\n  }, {\n    key: \"addTo\",\n    value: function addTo(target) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Cell.isCell(target)) {\n        target.addChild(this, options);\n      } else {\n        target.addCell(this, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"insertTo\",\n    value: function insertTo(parent, index) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      parent.insertChild(this, index, options);\n      return this;\n    }\n  }, {\n    key: \"addChild\",\n    value: function addChild(child) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.insertChild(child, undefined, options);\n    }\n  }, {\n    key: \"insertChild\",\n    value: function insertChild(child, index) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (child != null && child !== this) {\n        var oldParent = child.getParent();\n        var changed = this !== oldParent;\n        var pos = index;\n\n        if (pos == null) {\n          pos = this.getChildCount();\n\n          if (!changed) {\n            pos -= 1;\n          }\n        } // remove from old parent\n\n\n        if (oldParent) {\n          var _children = oldParent.getChildren();\n\n          if (_children) {\n            var _index = _children.indexOf(child);\n\n            if (_index >= 0) {\n              child.setParent(null, options);\n\n              _children.splice(_index, 1);\n\n              oldParent.setChildren(_children, options);\n            }\n          }\n        }\n\n        var children = this.children;\n\n        if (children == null) {\n          children = [];\n          children.push(child);\n        } else {\n          children.splice(pos, 0, child);\n        }\n\n        child.setParent(this, options);\n        this.setChildren(children, options);\n\n        if (changed && this.model) {\n          var incomings = this.model.getIncomingEdges(this);\n          var outgoings = this.model.getOutgoingEdges(this);\n\n          if (incomings) {\n            incomings.forEach(function (edge) {\n              return edge.updateParent(options);\n            });\n          }\n\n          if (outgoings) {\n            outgoings.forEach(function (edge) {\n              return edge.updateParent(options);\n            });\n          }\n        }\n\n        if (this.model) {\n          this.model.addCell(child, options);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeFromParent\",\n    value: function removeFromParent() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var parent = this.getParent();\n\n      if (parent != null) {\n        var index = parent.getChildIndex(this);\n        parent.removeChildAt(index, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeChild\",\n    value: function removeChild(child) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = this.getChildIndex(child);\n      return this.removeChildAt(index, options);\n    }\n  }, {\n    key: \"removeChildAt\",\n    value: function removeChildAt(index) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var child = this.getChildAt(index);\n      var children = this.children;\n\n      if (children != null && child != null) {\n        this.unembed(child, options);\n        child.remove(options);\n      }\n\n      return child;\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var _this7 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.batchUpdate('remove', function () {\n        var parent = _this7.getParent();\n\n        if (parent) {\n          parent.removeChild(_this7, options);\n        }\n\n        if (options.deep !== false) {\n          _this7.eachChild(function (child) {\n            return child.remove(options);\n          });\n        }\n\n        if (_this7.model) {\n          _this7.model.removeCell(_this7, options);\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"transition\",\n    value: function transition(path, target) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var delim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';\n      return this.animation.start(path, target, options, delim);\n    }\n  }, {\n    key: \"stopTransition\",\n    value: function stopTransition(path, options) {\n      var delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';\n      this.animation.stop(path, options, delim);\n      return this;\n    }\n  }, {\n    key: \"getTransitions\",\n    value: function getTransitions() {\n      return this.animation.get();\n    } // #endregion\n    // #region transform\n    // eslint-disable-next-line\n\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty, options) {\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, // eslint-disable-line\n    sy, // eslint-disable-line\n    origin, // eslint-disable-line\n    options) {\n      return this;\n    }\n  }, {\n    key: \"addTools\",\n    value: function addTools(items, obj, options) {\n      var toolItems = Array.isArray(items) ? items : [items];\n      var name = typeof obj === 'string' ? obj : null;\n      var config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};\n\n      if (config.reset) {\n        return this.setTools({\n          name: name,\n          items: toolItems,\n          local: config.local\n        }, config);\n      }\n\n      var tools = ObjectExt.cloneDeep(this.getTools());\n\n      if (tools == null || name == null || tools.name === name) {\n        if (tools == null) {\n          tools = {};\n        }\n\n        if (!tools.items) {\n          tools.items = [];\n        }\n\n        tools.name = name;\n        tools.items = [].concat(_toConsumableArray(tools.items), _toConsumableArray(toolItems));\n        return this.setTools(Object.assign({}, tools), config);\n      }\n    }\n  }, {\n    key: \"setTools\",\n    value: function setTools(tools) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (tools == null) {\n        this.removeTools();\n      } else {\n        this.store.set('tools', Cell.normalizeTools(tools), options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getTools\",\n    value: function getTools() {\n      return this.store.get('tools');\n    }\n  }, {\n    key: \"removeTools\",\n    value: function removeTools() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('tools', options);\n      return this;\n    }\n  }, {\n    key: \"hasTools\",\n    value: function hasTools(name) {\n      var tools = this.getTools();\n\n      if (tools == null) {\n        return false;\n      }\n\n      if (name == null) {\n        return true;\n      }\n\n      return tools.name === name;\n    }\n  }, {\n    key: \"hasTool\",\n    value: function hasTool(name) {\n      var tools = this.getTools();\n\n      if (tools == null) {\n        return false;\n      }\n\n      return tools.items.some(function (item) {\n        return typeof item === 'string' ? item === name : item.name === name;\n      });\n    }\n  }, {\n    key: \"removeTool\",\n    value: function removeTool(nameOrIndex) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var tools = ObjectExt.cloneDeep(this.getTools());\n\n      if (tools) {\n        var updated = false;\n        var items = tools.items.slice();\n\n        var remove = function remove(index) {\n          items.splice(index, 1);\n          updated = true;\n        };\n\n        if (typeof nameOrIndex === 'number') {\n          remove(nameOrIndex);\n        } else {\n          for (var i = items.length - 1; i >= 0; i -= 1) {\n            var item = items[i];\n            var exist = typeof item === 'string' ? item === nameOrIndex : item.name === nameOrIndex;\n\n            if (exist) {\n              remove(i);\n            }\n          }\n        }\n\n        if (updated) {\n          tools.items = items;\n          this.setTools(tools, options);\n        }\n      }\n\n      return this;\n    } // #endregion\n    // #region common\n    // eslint-disable-next-line\n\n  }, {\n    key: \"getBBox\",\n    value: function getBBox(options) {\n      return new Rectangle();\n    } // eslint-disable-next-line\n\n  }, {\n    key: \"getConnectionPoint\",\n    value: function getConnectionPoint(edge, type) {\n      return new Point();\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var _this8 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var props = Object.assign({}, this.store.get());\n      var toString = Object.prototype.toString;\n      var cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';\n\n      if (!props.shape) {\n        var _ctor = this.constructor;\n        throw new Error(\"Unable to serialize \".concat(cellType, \" missing \\\"shape\\\" prop, check the \").concat(cellType, \" \\\"\").concat(_ctor.name || toString.call(_ctor), \"\\\"\"));\n      }\n\n      var ctor = this.constructor;\n      var diff = options.diff === true;\n      var attrs = props.attrs || {};\n      var presets = ctor.getDefaults(true); // When `options.diff` is `true`, we should process the custom options,\n      // such as `width`, `height` etc. to ensure the comparing work correctly.\n\n      var defaults = diff ? this.preprocess(presets, true) : presets;\n      var defaultAttrs = defaults.attrs || {};\n      var finalAttrs = {};\n      Object.keys(props).forEach(function (key) {\n        var val = props[key];\n\n        if (val != null && !Array.isArray(val) && typeof val === 'object' && !ObjectExt.isPlainObject(val)) {\n          throw new Error(\"Can only serialize \".concat(cellType, \" with plain-object props, but got a \\\"\").concat(toString.call(val), \"\\\" type of key \\\"\").concat(key, \"\\\" on \").concat(cellType, \" \\\"\").concat(_this8.id, \"\\\"\"));\n        }\n\n        if (key !== 'attrs' && key !== 'shape' && diff) {\n          var preset = defaults[key];\n\n          if (ObjectExt.isEqual(val, preset)) {\n            delete props[key];\n          }\n        }\n      });\n      Object.keys(attrs).forEach(function (key) {\n        var attr = attrs[key];\n        var defaultAttr = defaultAttrs[key];\n        Object.keys(attr).forEach(function (name) {\n          var value = attr[name];\n          var defaultValue = defaultAttr ? defaultAttr[name] : null;\n\n          if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n            Object.keys(value).forEach(function (subName) {\n              var subValue = value[subName];\n\n              if (defaultAttr == null || defaultValue == null || !ObjectExt.isObject(defaultValue) || !ObjectExt.isEqual(defaultValue[subName], subValue)) {\n                if (finalAttrs[key] == null) {\n                  finalAttrs[key] = {};\n                }\n\n                if (finalAttrs[key][name] == null) {\n                  finalAttrs[key][name] = {};\n                }\n\n                var tmp = finalAttrs[key][name];\n                tmp[subName] = subValue;\n              }\n            });\n          } else if (defaultAttr == null || !ObjectExt.isEqual(defaultValue, value)) {\n            // `value` is not an object, default attribute with `key` does not\n            // exist or it is different than the attribute value set on the cell.\n            if (finalAttrs[key] == null) {\n              finalAttrs[key] = {};\n            }\n\n            finalAttrs[key][name] = value;\n          }\n        });\n      });\n      var finalProps = Object.assign(Object.assign({}, props), {\n        attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs\n      });\n\n      if (finalProps.attrs == null) {\n        delete finalProps.attrs;\n      }\n\n      var ret = finalProps;\n\n      if (ret.angle === 0) {\n        delete ret.angle;\n      }\n\n      return ObjectExt.cloneDeep(ret);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!options.deep) {\n        var data = Object.assign({}, this.store.get());\n\n        if (!options.keepId) {\n          delete data.id;\n        }\n\n        delete data.parent;\n        delete data.children;\n        var ctor = this.constructor;\n        return new ctor(data); // eslint-disable-line new-cap\n      } // Deep cloning. Clone the cell itself and all its children.\n\n\n      var map = Cell.deepClone(this);\n      return map[this.id];\n    }\n  }, {\n    key: \"findView\",\n    value: function findView(graph) {\n      return graph.renderer.findViewByCell(this);\n    } // #endregion\n    // #region batch\n\n  }, {\n    key: \"startBatch\",\n    value: function startBatch(name) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.model;\n      this.notify('batch:start', {\n        name: name,\n        data: data,\n        cell: this\n      });\n\n      if (model) {\n        model.startBatch(name, Object.assign(Object.assign({}, data), {\n          cell: this\n        }));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"stopBatch\",\n    value: function stopBatch(name) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.model;\n\n      if (model) {\n        model.stopBatch(name, Object.assign(Object.assign({}, data), {\n          cell: this\n        }));\n      }\n\n      this.notify('batch:stop', {\n        name: name,\n        data: data,\n        cell: this\n      });\n      return this;\n    }\n  }, {\n    key: \"batchUpdate\",\n    value: function batchUpdate(name, execute, data) {\n      // The model is null after cell was removed(remove batch).\n      // So we should temp save model to trigger pairing batch event.\n      var model = this.model;\n      this.startBatch(name, data, model);\n      var result = execute();\n      this.stopBatch(name, data, model);\n      return result;\n    } // #endregion\n    // #region IDisposable\n\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.removeFromParent();\n      this.store.dispose();\n    }\n  }], [{\n    key: \"config\",\n    value: function config(presets) {\n      var _this9 = this;\n\n      var markup = presets.markup,\n          propHooks = presets.propHooks,\n          attrHooks = presets.attrHooks,\n          others = __rest(presets, [\"markup\", \"propHooks\", \"attrHooks\"]);\n\n      if (markup != null) {\n        this.markup = markup;\n      }\n\n      if (propHooks) {\n        this.propHooks = this.propHooks.slice();\n\n        if (Array.isArray(propHooks)) {\n          var _this$propHooks;\n\n          (_this$propHooks = this.propHooks).push.apply(_this$propHooks, _toConsumableArray(propHooks));\n        } else if (typeof propHooks === 'function') {\n          this.propHooks.push(propHooks);\n        } else {\n          Object.keys(propHooks).forEach(function (name) {\n            var hook = propHooks[name];\n\n            if (typeof hook === 'function') {\n              _this9.propHooks.push(hook);\n            }\n          });\n        }\n      }\n\n      if (attrHooks) {\n        this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);\n      }\n\n      this.defaults = ObjectExt.merge({}, this.defaults, others);\n    }\n  }, {\n    key: \"getMarkup\",\n    value: function getMarkup() {\n      return this.markup;\n    }\n  }, {\n    key: \"getDefaults\",\n    value: function getDefaults(raw) {\n      return raw ? this.defaults : ObjectExt.cloneDeep(this.defaults);\n    }\n  }, {\n    key: \"getAttrHooks\",\n    value: function getAttrHooks() {\n      return this.attrHooks;\n    }\n  }, {\n    key: \"applyPropHooks\",\n    value: function applyPropHooks(cell, metadata) {\n      return this.propHooks.reduce(function (memo, hook) {\n        return hook ? FunctionExt.call(hook, cell, memo) : memo;\n      }, metadata);\n    }\n  }]);\n\n  return Cell;\n}(Basecoat, Symbol.toStringTag);\nCell.defaults = {};\nCell.attrHooks = {};\nCell.propHooks = [];\n\n__decorate([Basecoat.dispose()], Cell.prototype, \"dispose\", null);\n\n(function (Cell) {\n  function normalizeTools(raw) {\n    if (typeof raw === 'string') {\n      return {\n        items: [raw]\n      };\n    }\n\n    if (Array.isArray(raw)) {\n      return {\n        items: raw\n      };\n    }\n\n    if (raw.items) {\n      return raw;\n    }\n\n    return {\n      items: [raw]\n    };\n  }\n\n  Cell.normalizeTools = normalizeTools;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  Cell.toStringTag = \"X6.\".concat(Cell.name);\n\n  function isCell(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Cell) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var cell = instance;\n\n    if ((tag == null || tag === Cell.toStringTag) && typeof cell.isNode === 'function' && typeof cell.isEdge === 'function' && typeof cell.prop === 'function' && typeof cell.attr === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Cell.isCell = isCell;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  function getCommonAncestor() {\n    for (var _len2 = arguments.length, cells = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      cells[_key2] = arguments[_key2];\n    }\n\n    var ancestors = cells.filter(function (cell) {\n      return cell != null;\n    }).map(function (cell) {\n      return cell.getAncestors();\n    }).sort(function (a, b) {\n      return a.length - b.length;\n    });\n    var first = ancestors.shift();\n    return first.find(function (cell) {\n      return ancestors.every(function (item) {\n        return item.includes(cell);\n      });\n    }) || null;\n  }\n\n  Cell.getCommonAncestor = getCommonAncestor;\n\n  function getCellsBBox(cells) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    var bbox = null;\n\n    for (var i = 0, ii = cells.length; i < ii; i += 1) {\n      var cell = cells[i];\n      var rect = cell.getBBox(options);\n\n      if (rect) {\n        if (cell.isNode()) {\n          var angle = cell.getAngle();\n\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle);\n          }\n        }\n\n        bbox = bbox == null ? rect : bbox.union(rect);\n      }\n    }\n\n    return bbox;\n  }\n\n  Cell.getCellsBBox = getCellsBBox;\n\n  function deepClone(cell) {\n    var cells = [cell].concat(_toConsumableArray(cell.getDescendants({\n      deep: true\n    })));\n    return Cell.cloneCells(cells);\n  }\n\n  Cell.deepClone = deepClone;\n\n  function cloneCells(cells) {\n    var inputs = ArrayExt.uniq(cells);\n    var cloneMap = inputs.reduce(function (map, cell) {\n      map[cell.id] = cell.clone();\n      return map;\n    }, {});\n    inputs.forEach(function (cell) {\n      var clone = cloneMap[cell.id];\n\n      if (clone.isEdge()) {\n        var sourceId = clone.getSourceCellId();\n        var targetId = clone.getTargetCellId();\n\n        if (sourceId && cloneMap[sourceId]) {\n          // Source is a node and the node is among the clones.\n          // Then update the source of the cloned edge.\n          clone.setSource(Object.assign(Object.assign({}, clone.getSource()), {\n            cell: cloneMap[sourceId].id\n          }));\n        }\n\n        if (targetId && cloneMap[targetId]) {\n          // Target is a node and the node is among the clones.\n          // Then update the target of the cloned edge.\n          clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), {\n            cell: cloneMap[targetId].id\n          }));\n        }\n      } // Find the parent of the original cell\n\n\n      var parent = cell.getParent();\n\n      if (parent && cloneMap[parent.id]) {\n        clone.setParent(cloneMap[parent.id]);\n      } // Find the children of the original cell\n\n\n      var children = cell.getChildren();\n\n      if (children && children.length) {\n        var embeds = children.reduce(function (memo, child) {\n          // Embedded cells that are not being cloned can not be carried\n          // over with other embedded cells.\n          if (cloneMap[child.id]) {\n            memo.push(cloneMap[child.id]);\n          }\n\n          return memo;\n        }, []);\n\n        if (embeds.length > 0) {\n          clone.setChildren(embeds);\n        }\n      }\n    });\n    return cloneMap;\n  }\n\n  Cell.cloneCells = cloneCells;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  Cell.config({\n    propHooks: function propHooks(_a) {\n      var tools = _a.tools,\n          metadata = __rest(_a, [\"tools\"]);\n\n      if (tools) {\n        metadata.tools = Cell.normalizeTools(tools);\n      }\n\n      return metadata;\n    }\n  });\n})(Cell || (Cell = {}));","map":{"version":3,"sources":["../../src/model/cell.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* eslint-disable no-underscore-dangle */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ArrayExt, StringExt, ObjectExt, FunctionExt } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Basecoat } from '../common';\nimport { Attr } from '../registry';\nimport { Animation } from './animation';\nimport { Store } from './store';\nexport class Cell extends Basecoat {\n    constructor(metadata = {}) {\n        super();\n        const ctor = this.constructor;\n        const defaults = ctor.getDefaults(true);\n        const props = ObjectExt.merge({}, this.preprocess(defaults), this.preprocess(metadata));\n        this.id = props.id || StringExt.uuid();\n        this.store = new Store(props);\n        this.animation = new Animation(this);\n        this.setup();\n        this.init();\n        this.postprocess(metadata);\n    }\n    static config(presets) {\n        const { markup, propHooks, attrHooks } = presets, others = __rest(presets, [\"markup\", \"propHooks\", \"attrHooks\"]);\n        if (markup != null) {\n            this.markup = markup;\n        }\n        if (propHooks) {\n            this.propHooks = this.propHooks.slice();\n            if (Array.isArray(propHooks)) {\n                this.propHooks.push(...propHooks);\n            }\n            else if (typeof propHooks === 'function') {\n                this.propHooks.push(propHooks);\n            }\n            else {\n                Object.keys(propHooks).forEach((name) => {\n                    const hook = propHooks[name];\n                    if (typeof hook === 'function') {\n                        this.propHooks.push(hook);\n                    }\n                });\n            }\n        }\n        if (attrHooks) {\n            this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);\n        }\n        this.defaults = ObjectExt.merge({}, this.defaults, others);\n    }\n    static getMarkup() {\n        return this.markup;\n    }\n    static getDefaults(raw) {\n        return (raw ? this.defaults : ObjectExt.cloneDeep(this.defaults));\n    }\n    static getAttrHooks() {\n        return this.attrHooks;\n    }\n    static applyPropHooks(cell, metadata) {\n        return this.propHooks.reduce((memo, hook) => {\n            return hook ? FunctionExt.call(hook, cell, memo) : memo;\n        }, metadata);\n    }\n    // #endregion\n    get [Symbol.toStringTag]() {\n        return Cell.toStringTag;\n    }\n    init() { }\n    // #region model\n    get model() {\n        return this._model;\n    }\n    set model(model) {\n        if (this._model !== model) {\n            this._model = model;\n        }\n    }\n    // #endregion\n    preprocess(metadata, ignoreIdCheck) {\n        const id = metadata.id;\n        const ctor = this.constructor;\n        const props = ctor.applyPropHooks(this, metadata);\n        if (id == null && ignoreIdCheck !== true) {\n            props.id = StringExt.uuid();\n        }\n        return props;\n    }\n    postprocess(metadata) { } // eslint-disable-line\n    setup() {\n        this.store.on('change:*', (metadata) => {\n            const { key, current, previous, options } = metadata;\n            this.notify('change:*', {\n                key,\n                options,\n                current,\n                previous,\n                cell: this,\n            });\n            this.notify(`change:${key}`, {\n                options,\n                current,\n                previous,\n                cell: this,\n            });\n            const type = key;\n            if (type === 'source' || type === 'target') {\n                this.notify(`change:terminal`, {\n                    type,\n                    current,\n                    previous,\n                    options,\n                    cell: this,\n                });\n            }\n        });\n        this.store.on('changed', ({ options }) => this.notify('changed', { options, cell: this }));\n    }\n    notify(name, args) {\n        this.trigger(name, args);\n        const model = this.model;\n        if (model) {\n            model.notify(`cell:${name}`, args);\n            if (this.isNode()) {\n                model.notify(`node:${name}`, Object.assign(Object.assign({}, args), { node: this }));\n            }\n            else if (this.isEdge()) {\n                model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: this }));\n            }\n        }\n        return this;\n    }\n    isNode() {\n        return false;\n    }\n    isEdge() {\n        return false;\n    }\n    isSameStore(cell) {\n        return this.store === cell.store;\n    }\n    get view() {\n        return this.store.get('view');\n    }\n    get shape() {\n        return this.store.get('shape', '');\n    }\n    getProp(key, defaultValue) {\n        if (key == null) {\n            return this.store.get();\n        }\n        return this.store.get(key, defaultValue);\n    }\n    setProp(key, value, options) {\n        if (typeof key === 'string') {\n            this.store.set(key, value, options);\n        }\n        else {\n            const props = this.preprocess(key, true);\n            this.store.set(ObjectExt.merge({}, this.getProp(), props), value);\n            this.postprocess(key);\n        }\n        return this;\n    }\n    removeProp(key, options) {\n        if (typeof key === 'string' || Array.isArray(key)) {\n            this.store.removeByPath(key, options);\n        }\n        else {\n            this.store.remove(options);\n        }\n        return this;\n    }\n    hasChanged(key) {\n        return key == null ? this.store.hasChanged() : this.store.hasChanged(key);\n    }\n    getPropByPath(path) {\n        return this.store.getByPath(path);\n    }\n    setPropByPath(path, value, options = {}) {\n        if (this.model) {\n            // update inner reference\n            if (path === 'children') {\n                this._children = value\n                    ? value\n                        .map((id) => this.model.getCell(id))\n                        .filter((child) => child != null)\n                    : null;\n            }\n            else if (path === 'parent') {\n                this._parent = value ? this.model.getCell(value) : null;\n            }\n        }\n        this.store.setByPath(path, value, options);\n        return this;\n    }\n    removePropByPath(path, options = {}) {\n        const paths = Array.isArray(path) ? path : path.split('/');\n        // Once a property is removed from the `attrs` the CellView will\n        // recognize a `dirty` flag and re-render itself in order to remove\n        // the attribute from SVGElement.\n        if (paths[0] === 'attrs') {\n            options.dirty = true;\n        }\n        this.store.removeByPath(paths, options);\n        return this;\n    }\n    prop(key, value, options) {\n        if (key == null) {\n            return this.getProp();\n        }\n        if (typeof key === 'string' || Array.isArray(key)) {\n            if (arguments.length === 1) {\n                return this.getPropByPath(key);\n            }\n            if (value == null) {\n                return this.removePropByPath(key, options || {});\n            }\n            return this.setPropByPath(key, value, options || {});\n        }\n        return this.setProp(key, value || {});\n    }\n    previous(name) {\n        return this.store.getPrevious(name);\n    }\n    // #endregion\n    // #region zIndex\n    get zIndex() {\n        return this.getZIndex();\n    }\n    set zIndex(z) {\n        if (z == null) {\n            this.removeZIndex();\n        }\n        else {\n            this.setZIndex(z);\n        }\n    }\n    getZIndex() {\n        return this.store.get('zIndex');\n    }\n    setZIndex(z, options = {}) {\n        this.store.set('zIndex', z, options);\n        return this;\n    }\n    removeZIndex(options = {}) {\n        this.store.remove('zIndex', options);\n        return this;\n    }\n    toFront(options = {}) {\n        const model = this.model;\n        if (model) {\n            let z = model.getMaxZIndex();\n            let cells;\n            if (options.deep) {\n                cells = this.getDescendants({ deep: true, breadthFirst: true });\n                cells.unshift(this);\n            }\n            else {\n                cells = [this];\n            }\n            z = z - cells.length + 1;\n            const count = model.total();\n            let changed = model.indexOf(this) !== count - cells.length;\n            if (!changed) {\n                changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n            }\n            if (changed) {\n                this.batchUpdate('to-front', () => {\n                    z += cells.length;\n                    cells.forEach((cell, index) => {\n                        cell.setZIndex(z + index, options);\n                    });\n                });\n            }\n        }\n        return this;\n    }\n    toBack(options = {}) {\n        const model = this.model;\n        if (model) {\n            let z = model.getMinZIndex();\n            let cells;\n            if (options.deep) {\n                cells = this.getDescendants({ deep: true, breadthFirst: true });\n                cells.unshift(this);\n            }\n            else {\n                cells = [this];\n            }\n            let changed = model.indexOf(this) !== 0;\n            if (!changed) {\n                changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n            }\n            if (changed) {\n                this.batchUpdate('to-back', () => {\n                    z -= cells.length;\n                    cells.forEach((cell, index) => {\n                        cell.setZIndex(z + index, options);\n                    });\n                });\n            }\n        }\n        return this;\n    }\n    // #endregion\n    // #region markup\n    get markup() {\n        return this.getMarkup();\n    }\n    set markup(value) {\n        if (value == null) {\n            this.removeMarkup();\n        }\n        else {\n            this.setMarkup(value);\n        }\n    }\n    getMarkup() {\n        let markup = this.store.get('markup');\n        if (markup == null) {\n            const ctor = this.constructor;\n            markup = ctor.getMarkup();\n        }\n        return markup;\n    }\n    setMarkup(markup, options = {}) {\n        this.store.set('markup', markup, options);\n        return this;\n    }\n    removeMarkup(options = {}) {\n        this.store.remove('markup', options);\n        return this;\n    }\n    // #endregion\n    // #region attrs\n    get attrs() {\n        return this.getAttrs();\n    }\n    set attrs(value) {\n        if (value == null) {\n            this.removeAttrs();\n        }\n        else {\n            this.setAttrs(value);\n        }\n    }\n    getAttrs() {\n        const result = this.store.get('attrs');\n        return result ? Object.assign({}, result) : {};\n    }\n    setAttrs(attrs, options = {}) {\n        if (attrs == null) {\n            this.removeAttrs(options);\n        }\n        else {\n            const set = (attrs) => this.store.set('attrs', attrs, options);\n            if (options.overwrite === true) {\n                set(attrs);\n            }\n            else {\n                const prev = this.getAttrs();\n                if (options.deep === false) {\n                    set(Object.assign(Object.assign({}, prev), attrs));\n                }\n                else {\n                    set(ObjectExt.merge({}, prev, attrs));\n                }\n            }\n        }\n        return this;\n    }\n    replaceAttrs(attrs, options = {}) {\n        return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { overwrite: true }));\n    }\n    updateAttrs(attrs, options = {}) {\n        return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { deep: false }));\n    }\n    removeAttrs(options = {}) {\n        this.store.remove('attrs', options);\n        return this;\n    }\n    getAttrDefinition(attrName) {\n        if (!attrName) {\n            return null;\n        }\n        const ctor = this.constructor;\n        const hooks = ctor.getAttrHooks() || {};\n        let definition = hooks[attrName] || Attr.registry.get(attrName);\n        if (!definition) {\n            const name = StringExt.camelCase(attrName);\n            definition = hooks[name] || Attr.registry.get(name);\n        }\n        return definition || null;\n    }\n    getAttrByPath(path) {\n        if (path == null || path === '') {\n            return this.getAttrs();\n        }\n        return this.getPropByPath(this.prefixAttrPath(path));\n    }\n    setAttrByPath(path, value, options = {}) {\n        this.setPropByPath(this.prefixAttrPath(path), value, options);\n        return this;\n    }\n    removeAttrByPath(path, options = {}) {\n        this.removePropByPath(this.prefixAttrPath(path), options);\n        return this;\n    }\n    prefixAttrPath(path) {\n        return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`;\n    }\n    attr(path, value, options) {\n        if (path == null) {\n            return this.getAttrByPath();\n        }\n        if (typeof path === 'string' || Array.isArray(path)) {\n            if (arguments.length === 1) {\n                return this.getAttrByPath(path);\n            }\n            if (value == null) {\n                return this.removeAttrByPath(path, options || {});\n            }\n            return this.setAttrByPath(path, value, options || {});\n        }\n        return this.setAttrs(path, (value || {}));\n    }\n    // #endregion\n    // #region visible\n    get visible() {\n        return this.isVisible();\n    }\n    set visible(value) {\n        this.setVisible(value);\n    }\n    setVisible(visible, options = {}) {\n        this.store.set('visible', visible, options);\n        return this;\n    }\n    isVisible() {\n        return this.store.get('visible') !== false;\n    }\n    show(options = {}) {\n        if (!this.isVisible()) {\n            this.setVisible(true, options);\n        }\n        return this;\n    }\n    hide(options = {}) {\n        if (this.isVisible()) {\n            this.setVisible(false, options);\n        }\n        return this;\n    }\n    toggleVisible(isVisible, options = {}) {\n        const visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();\n        const localOptions = typeof isVisible === 'boolean' ? options : isVisible;\n        if (visible) {\n            this.show(localOptions);\n        }\n        else {\n            this.hide(localOptions);\n        }\n        return this;\n    }\n    // #endregion\n    // #region data\n    get data() {\n        return this.getData();\n    }\n    set data(val) {\n        this.setData(val);\n    }\n    getData() {\n        return this.store.get('data');\n    }\n    setData(data, options = {}) {\n        if (data == null) {\n            this.removeData(options);\n        }\n        else {\n            const set = (data) => this.store.set('data', data, options);\n            if (options.overwrite === true) {\n                set(data);\n            }\n            else {\n                const prev = this.getData();\n                if (options.deep === false) {\n                    set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);\n                }\n                else {\n                    set(ObjectExt.merge({}, prev, data));\n                }\n            }\n        }\n        return this;\n    }\n    replaceData(data, options = {}) {\n        return this.setData(data, Object.assign(Object.assign({}, options), { overwrite: true }));\n    }\n    updateData(data, options = {}) {\n        return this.setData(data, Object.assign(Object.assign({}, options), { deep: false }));\n    }\n    removeData(options = {}) {\n        this.store.remove('data', options);\n        return this;\n    }\n    // #endregion\n    // #region parent children\n    get parent() {\n        return this.getParent();\n    }\n    get children() {\n        return this.getChildren();\n    }\n    getParentId() {\n        return this.store.get('parent');\n    }\n    getParent() {\n        let parent = this._parent;\n        if (parent == null && this.store) {\n            const parentId = this.getParentId();\n            if (parentId != null && this.model) {\n                parent = this.model.getCell(parentId);\n                this._parent = parent;\n            }\n        }\n        return parent;\n    }\n    getChildren() {\n        let children = this._children;\n        if (children == null) {\n            const childrenIds = this.store.get('children');\n            if (childrenIds && childrenIds.length && this.model) {\n                children = childrenIds\n                    .map((id) => { var _a; return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id); })\n                    .filter((cell) => cell != null);\n                this._children = children;\n            }\n        }\n        return children ? [...children] : null;\n    }\n    hasParent() {\n        return this.parent != null;\n    }\n    isParentOf(child) {\n        return child != null && child.getParent() === this;\n    }\n    isChildOf(parent) {\n        return parent != null && this.getParent() === parent;\n    }\n    eachChild(iterator, context) {\n        if (this.children) {\n            this.children.forEach(iterator, context);\n        }\n        return this;\n    }\n    filterChild(filter, context) {\n        return this.children ? this.children.filter(filter, context) : [];\n    }\n    getChildCount() {\n        return this.children == null ? 0 : this.children.length;\n    }\n    getChildIndex(child) {\n        return this.children == null ? -1 : this.children.indexOf(child);\n    }\n    getChildAt(index) {\n        return this.children != null && index >= 0 ? this.children[index] : null;\n    }\n    getAncestors(options = {}) {\n        const ancestors = [];\n        let parent = this.getParent();\n        while (parent) {\n            ancestors.push(parent);\n            parent = options.deep !== false ? parent.getParent() : null;\n        }\n        return ancestors;\n    }\n    getDescendants(options = {}) {\n        if (options.deep !== false) {\n            // breadth first\n            if (options.breadthFirst) {\n                const cells = [];\n                const queue = this.getChildren() || [];\n                while (queue.length > 0) {\n                    const parent = queue.shift();\n                    const children = parent.getChildren();\n                    cells.push(parent);\n                    if (children) {\n                        queue.push(...children);\n                    }\n                }\n                return cells;\n            }\n            // depth first\n            {\n                const cells = this.getChildren() || [];\n                cells.forEach((cell) => {\n                    cells.push(...cell.getDescendants(options));\n                });\n                return cells;\n            }\n        }\n        return this.getChildren() || [];\n    }\n    isDescendantOf(ancestor, options = {}) {\n        if (ancestor == null) {\n            return false;\n        }\n        if (options.deep !== false) {\n            let current = this.getParent();\n            while (current) {\n                if (current === ancestor) {\n                    return true;\n                }\n                current = current.getParent();\n            }\n            return false;\n        }\n        return this.isChildOf(ancestor);\n    }\n    isAncestorOf(descendant, options = {}) {\n        if (descendant == null) {\n            return false;\n        }\n        return descendant.isDescendantOf(this, options);\n    }\n    contains(cell) {\n        return this.isAncestorOf(cell);\n    }\n    getCommonAncestor(...cells) {\n        return Cell.getCommonAncestor(this, ...cells);\n    }\n    setParent(parent, options = {}) {\n        this._parent = parent;\n        if (parent) {\n            this.store.set('parent', parent.id, options);\n        }\n        else {\n            this.store.remove('parent', options);\n        }\n        return this;\n    }\n    setChildren(children, options = {}) {\n        this._children = children;\n        if (children != null) {\n            this.store.set('children', children.map((child) => child.id), options);\n        }\n        else {\n            this.store.remove('children', options);\n        }\n        return this;\n    }\n    unembed(child, options = {}) {\n        const children = this.children;\n        if (children != null && child != null) {\n            const index = this.getChildIndex(child);\n            if (index !== -1) {\n                children.splice(index, 1);\n                child.setParent(null, options);\n                this.setChildren(children, options);\n            }\n        }\n        return this;\n    }\n    embed(child, options = {}) {\n        child.addTo(this, options);\n        return this;\n    }\n    addTo(target, options = {}) {\n        if (Cell.isCell(target)) {\n            target.addChild(this, options);\n        }\n        else {\n            target.addCell(this, options);\n        }\n        return this;\n    }\n    insertTo(parent, index, options = {}) {\n        parent.insertChild(this, index, options);\n        return this;\n    }\n    addChild(child, options = {}) {\n        return this.insertChild(child, undefined, options);\n    }\n    insertChild(child, index, options = {}) {\n        if (child != null && child !== this) {\n            const oldParent = child.getParent();\n            const changed = this !== oldParent;\n            let pos = index;\n            if (pos == null) {\n                pos = this.getChildCount();\n                if (!changed) {\n                    pos -= 1;\n                }\n            }\n            // remove from old parent\n            if (oldParent) {\n                const children = oldParent.getChildren();\n                if (children) {\n                    const index = children.indexOf(child);\n                    if (index >= 0) {\n                        child.setParent(null, options);\n                        children.splice(index, 1);\n                        oldParent.setChildren(children, options);\n                    }\n                }\n            }\n            let children = this.children;\n            if (children == null) {\n                children = [];\n                children.push(child);\n            }\n            else {\n                children.splice(pos, 0, child);\n            }\n            child.setParent(this, options);\n            this.setChildren(children, options);\n            if (changed && this.model) {\n                const incomings = this.model.getIncomingEdges(this);\n                const outgoings = this.model.getOutgoingEdges(this);\n                if (incomings) {\n                    incomings.forEach((edge) => edge.updateParent(options));\n                }\n                if (outgoings) {\n                    outgoings.forEach((edge) => edge.updateParent(options));\n                }\n            }\n            if (this.model) {\n                this.model.addCell(child, options);\n            }\n        }\n        return this;\n    }\n    removeFromParent(options = {}) {\n        const parent = this.getParent();\n        if (parent != null) {\n            const index = parent.getChildIndex(this);\n            parent.removeChildAt(index, options);\n        }\n        return this;\n    }\n    removeChild(child, options = {}) {\n        const index = this.getChildIndex(child);\n        return this.removeChildAt(index, options);\n    }\n    removeChildAt(index, options = {}) {\n        const child = this.getChildAt(index);\n        const children = this.children;\n        if (children != null && child != null) {\n            this.unembed(child, options);\n            child.remove(options);\n        }\n        return child;\n    }\n    remove(options = {}) {\n        this.batchUpdate('remove', () => {\n            const parent = this.getParent();\n            if (parent) {\n                parent.removeChild(this, options);\n            }\n            if (options.deep !== false) {\n                this.eachChild((child) => child.remove(options));\n            }\n            if (this.model) {\n                this.model.removeCell(this, options);\n            }\n        });\n        return this;\n    }\n    transition(path, target, options = {}, delim = '/') {\n        return this.animation.start(path, target, options, delim);\n    }\n    stopTransition(path, options, delim = '/') {\n        this.animation.stop(path, options, delim);\n        return this;\n    }\n    getTransitions() {\n        return this.animation.get();\n    }\n    // #endregion\n    // #region transform\n    // eslint-disable-next-line\n    translate(tx, ty, options) {\n        return this;\n    }\n    scale(sx, // eslint-disable-line\n    sy, // eslint-disable-line\n    origin, // eslint-disable-line\n    options) {\n        return this;\n    }\n    addTools(items, obj, options) {\n        const toolItems = Array.isArray(items) ? items : [items];\n        const name = typeof obj === 'string' ? obj : null;\n        const config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};\n        if (config.reset) {\n            return this.setTools({ name, items: toolItems, local: config.local }, config);\n        }\n        let tools = ObjectExt.cloneDeep(this.getTools());\n        if (tools == null || name == null || tools.name === name) {\n            if (tools == null) {\n                tools = {};\n            }\n            if (!tools.items) {\n                tools.items = [];\n            }\n            tools.name = name;\n            tools.items = [...tools.items, ...toolItems];\n            return this.setTools(Object.assign({}, tools), config);\n        }\n    }\n    setTools(tools, options = {}) {\n        if (tools == null) {\n            this.removeTools();\n        }\n        else {\n            this.store.set('tools', Cell.normalizeTools(tools), options);\n        }\n        return this;\n    }\n    getTools() {\n        return this.store.get('tools');\n    }\n    removeTools(options = {}) {\n        this.store.remove('tools', options);\n        return this;\n    }\n    hasTools(name) {\n        const tools = this.getTools();\n        if (tools == null) {\n            return false;\n        }\n        if (name == null) {\n            return true;\n        }\n        return tools.name === name;\n    }\n    hasTool(name) {\n        const tools = this.getTools();\n        if (tools == null) {\n            return false;\n        }\n        return tools.items.some((item) => typeof item === 'string' ? item === name : item.name === name);\n    }\n    removeTool(nameOrIndex, options = {}) {\n        const tools = ObjectExt.cloneDeep(this.getTools());\n        if (tools) {\n            let updated = false;\n            const items = tools.items.slice();\n            const remove = (index) => {\n                items.splice(index, 1);\n                updated = true;\n            };\n            if (typeof nameOrIndex === 'number') {\n                remove(nameOrIndex);\n            }\n            else {\n                for (let i = items.length - 1; i >= 0; i -= 1) {\n                    const item = items[i];\n                    const exist = typeof item === 'string'\n                        ? item === nameOrIndex\n                        : item.name === nameOrIndex;\n                    if (exist) {\n                        remove(i);\n                    }\n                }\n            }\n            if (updated) {\n                tools.items = items;\n                this.setTools(tools, options);\n            }\n        }\n        return this;\n    }\n    // #endregion\n    // #region common\n    // eslint-disable-next-line\n    getBBox(options) {\n        return new Rectangle();\n    }\n    // eslint-disable-next-line\n    getConnectionPoint(edge, type) {\n        return new Point();\n    }\n    toJSON(options = {}) {\n        const props = Object.assign({}, this.store.get());\n        const toString = Object.prototype.toString;\n        const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';\n        if (!props.shape) {\n            const ctor = this.constructor;\n            throw new Error(`Unable to serialize ${cellType} missing \"shape\" prop, check the ${cellType} \"${ctor.name || toString.call(ctor)}\"`);\n        }\n        const ctor = this.constructor;\n        const diff = options.diff === true;\n        const attrs = props.attrs || {};\n        const presets = ctor.getDefaults(true);\n        // When `options.diff` is `true`, we should process the custom options,\n        // such as `width`, `height` etc. to ensure the comparing work correctly.\n        const defaults = diff ? this.preprocess(presets, true) : presets;\n        const defaultAttrs = defaults.attrs || {};\n        const finalAttrs = {};\n        Object.keys(props).forEach((key) => {\n            const val = props[key];\n            if (val != null &&\n                !Array.isArray(val) &&\n                typeof val === 'object' &&\n                !ObjectExt.isPlainObject(val)) {\n                throw new Error(`Can only serialize ${cellType} with plain-object props, but got a \"${toString.call(val)}\" type of key \"${key}\" on ${cellType} \"${this.id}\"`);\n            }\n            if (key !== 'attrs' && key !== 'shape' && diff) {\n                const preset = defaults[key];\n                if (ObjectExt.isEqual(val, preset)) {\n                    delete props[key];\n                }\n            }\n        });\n        Object.keys(attrs).forEach((key) => {\n            const attr = attrs[key];\n            const defaultAttr = defaultAttrs[key];\n            Object.keys(attr).forEach((name) => {\n                const value = attr[name];\n                const defaultValue = defaultAttr ? defaultAttr[name] : null;\n                if (value != null &&\n                    typeof value === 'object' &&\n                    !Array.isArray(value)) {\n                    Object.keys(value).forEach((subName) => {\n                        const subValue = value[subName];\n                        if (defaultAttr == null ||\n                            defaultValue == null ||\n                            !ObjectExt.isObject(defaultValue) ||\n                            !ObjectExt.isEqual(defaultValue[subName], subValue)) {\n                            if (finalAttrs[key] == null) {\n                                finalAttrs[key] = {};\n                            }\n                            if (finalAttrs[key][name] == null) {\n                                finalAttrs[key][name] = {};\n                            }\n                            const tmp = finalAttrs[key][name];\n                            tmp[subName] = subValue;\n                        }\n                    });\n                }\n                else if (defaultAttr == null ||\n                    !ObjectExt.isEqual(defaultValue, value)) {\n                    // `value` is not an object, default attribute with `key` does not\n                    // exist or it is different than the attribute value set on the cell.\n                    if (finalAttrs[key] == null) {\n                        finalAttrs[key] = {};\n                    }\n                    finalAttrs[key][name] = value;\n                }\n            });\n        });\n        const finalProps = Object.assign(Object.assign({}, props), { attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs });\n        if (finalProps.attrs == null) {\n            delete finalProps.attrs;\n        }\n        const ret = finalProps;\n        if (ret.angle === 0) {\n            delete ret.angle;\n        }\n        return ObjectExt.cloneDeep(ret);\n    }\n    clone(options = {}) {\n        if (!options.deep) {\n            const data = Object.assign({}, this.store.get());\n            if (!options.keepId) {\n                delete data.id;\n            }\n            delete data.parent;\n            delete data.children;\n            const ctor = this.constructor;\n            return new ctor(data); // eslint-disable-line new-cap\n        }\n        // Deep cloning. Clone the cell itself and all its children.\n        const map = Cell.deepClone(this);\n        return map[this.id];\n    }\n    findView(graph) {\n        return graph.renderer.findViewByCell(this);\n    }\n    // #endregion\n    // #region batch\n    startBatch(name, data = {}, model = this.model) {\n        this.notify('batch:start', { name, data, cell: this });\n        if (model) {\n            model.startBatch(name, Object.assign(Object.assign({}, data), { cell: this }));\n        }\n        return this;\n    }\n    stopBatch(name, data = {}, model = this.model) {\n        if (model) {\n            model.stopBatch(name, Object.assign(Object.assign({}, data), { cell: this }));\n        }\n        this.notify('batch:stop', { name, data, cell: this });\n        return this;\n    }\n    batchUpdate(name, execute, data) {\n        // The model is null after cell was removed(remove batch).\n        // So we should temp save model to trigger pairing batch event.\n        const model = this.model;\n        this.startBatch(name, data, model);\n        const result = execute();\n        this.stopBatch(name, data, model);\n        return result;\n    }\n    // #endregion\n    // #region IDisposable\n    dispose() {\n        this.removeFromParent();\n        this.store.dispose();\n    }\n}\nCell.defaults = {};\nCell.attrHooks = {};\nCell.propHooks = [];\n__decorate([\n    Basecoat.dispose()\n], Cell.prototype, \"dispose\", null);\n(function (Cell) {\n    function normalizeTools(raw) {\n        if (typeof raw === 'string') {\n            return { items: [raw] };\n        }\n        if (Array.isArray(raw)) {\n            return { items: raw };\n        }\n        if (raw.items) {\n            return raw;\n        }\n        return {\n            items: [raw],\n        };\n    }\n    Cell.normalizeTools = normalizeTools;\n})(Cell || (Cell = {}));\n(function (Cell) {\n    Cell.toStringTag = `X6.${Cell.name}`;\n    function isCell(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Cell) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const cell = instance;\n        if ((tag == null || tag === Cell.toStringTag) &&\n            typeof cell.isNode === 'function' &&\n            typeof cell.isEdge === 'function' &&\n            typeof cell.prop === 'function' &&\n            typeof cell.attr === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Cell.isCell = isCell;\n})(Cell || (Cell = {}));\n(function (Cell) {\n    function getCommonAncestor(...cells) {\n        const ancestors = cells\n            .filter((cell) => cell != null)\n            .map((cell) => cell.getAncestors())\n            .sort((a, b) => {\n            return a.length - b.length;\n        });\n        const first = ancestors.shift();\n        return (first.find((cell) => ancestors.every((item) => item.includes(cell))) ||\n            null);\n    }\n    Cell.getCommonAncestor = getCommonAncestor;\n    function getCellsBBox(cells, options = {}) {\n        let bbox = null;\n        for (let i = 0, ii = cells.length; i < ii; i += 1) {\n            const cell = cells[i];\n            let rect = cell.getBBox(options);\n            if (rect) {\n                if (cell.isNode()) {\n                    const angle = cell.getAngle();\n                    if (angle != null && angle !== 0) {\n                        rect = rect.bbox(angle);\n                    }\n                }\n                bbox = bbox == null ? rect : bbox.union(rect);\n            }\n        }\n        return bbox;\n    }\n    Cell.getCellsBBox = getCellsBBox;\n    function deepClone(cell) {\n        const cells = [cell, ...cell.getDescendants({ deep: true })];\n        return Cell.cloneCells(cells);\n    }\n    Cell.deepClone = deepClone;\n    function cloneCells(cells) {\n        const inputs = ArrayExt.uniq(cells);\n        const cloneMap = inputs.reduce((map, cell) => {\n            map[cell.id] = cell.clone();\n            return map;\n        }, {});\n        inputs.forEach((cell) => {\n            const clone = cloneMap[cell.id];\n            if (clone.isEdge()) {\n                const sourceId = clone.getSourceCellId();\n                const targetId = clone.getTargetCellId();\n                if (sourceId && cloneMap[sourceId]) {\n                    // Source is a node and the node is among the clones.\n                    // Then update the source of the cloned edge.\n                    clone.setSource(Object.assign(Object.assign({}, clone.getSource()), { cell: cloneMap[sourceId].id }));\n                }\n                if (targetId && cloneMap[targetId]) {\n                    // Target is a node and the node is among the clones.\n                    // Then update the target of the cloned edge.\n                    clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), { cell: cloneMap[targetId].id }));\n                }\n            }\n            // Find the parent of the original cell\n            const parent = cell.getParent();\n            if (parent && cloneMap[parent.id]) {\n                clone.setParent(cloneMap[parent.id]);\n            }\n            // Find the children of the original cell\n            const children = cell.getChildren();\n            if (children && children.length) {\n                const embeds = children.reduce((memo, child) => {\n                    // Embedded cells that are not being cloned can not be carried\n                    // over with other embedded cells.\n                    if (cloneMap[child.id]) {\n                        memo.push(cloneMap[child.id]);\n                    }\n                    return memo;\n                }, []);\n                if (embeds.length > 0) {\n                    clone.setChildren(embeds);\n                }\n            }\n        });\n        return cloneMap;\n    }\n    Cell.cloneCells = cloneCells;\n})(Cell || (Cell = {}));\n(function (Cell) {\n    Cell.config({\n        propHooks(_a) {\n            var { tools } = _a, metadata = __rest(_a, [\"tools\"]);\n            if (tools) {\n                metadata.tools = Cell.normalizeTools(tools);\n            }\n            return metadata;\n        },\n    });\n})(Cell || (Cell = {}));\n//# sourceMappingURL=cell.js.map"]},"metadata":{},"sourceType":"module"}