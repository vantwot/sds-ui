{"ast":null,"code":"import _defineProperty from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Rectangle, Polyline, Point, Angle, Path, Line } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt, FunctionExt, Dom, Vector } from '../util';\nimport { Router, Connector, NodeAnchor, EdgeAnchor, ConnectionPoint } from '../registry';\nimport { Edge } from '../model/edge';\nimport { Markup } from './markup';\nimport { CellView } from './cell';\nexport var EdgeView = /*#__PURE__*/function (_CellView, _Symbol$toStringTag) {\n  _inherits(EdgeView, _CellView);\n\n  var _super = _createSuper(EdgeView);\n\n  function EdgeView() {\n    var _this;\n\n    _classCallCheck(this, EdgeView);\n\n    _this = _super.apply(this, arguments);\n    _this.POINT_ROUNDING = 2;\n    _this.markerCache = {}; // #endregion\n    // #endregion\n\n    return _this;\n  }\n\n  _createClass(EdgeView, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return EdgeView.toStringTag;\n    }\n  }, {\n    key: \"getContainerClassName\",\n    value: function getContainerClassName() {\n      return [_get(_getPrototypeOf(EdgeView.prototype), \"getContainerClassName\", this).call(this), this.prefixClassName('edge')].join(' ');\n    }\n  }, {\n    key: \"sourceBBox\",\n    get: function get() {\n      var sourceView = this.sourceView;\n\n      if (!sourceView) {\n        var sourceDef = this.cell.getSource();\n        return new Rectangle(sourceDef.x, sourceDef.y);\n      }\n\n      var sourceMagnet = this.sourceMagnet;\n\n      if (sourceView.isEdgeElement(sourceMagnet)) {\n        return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);\n      }\n\n      return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);\n    }\n  }, {\n    key: \"targetBBox\",\n    get: function get() {\n      var targetView = this.targetView;\n\n      if (!targetView) {\n        var targetDef = this.cell.getTarget();\n        return new Rectangle(targetDef.x, targetDef.y);\n      }\n\n      var targetMagnet = this.targetMagnet;\n\n      if (targetView.isEdgeElement(targetMagnet)) {\n        return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);\n      }\n\n      return targetView.getBBoxOfElement(targetMagnet || targetView.container);\n    }\n  }, {\n    key: \"isEdgeView\",\n    value: function isEdgeView() {\n      return true;\n    }\n  }, {\n    key: \"confirmUpdate\",\n    value: function confirmUpdate(flag) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var ref = flag;\n\n      if (this.hasAction(ref, 'source')) {\n        if (!this.updateTerminalProperties('source')) {\n          return ref;\n        }\n\n        ref = this.removeAction(ref, 'source');\n      }\n\n      if (this.hasAction(ref, 'target')) {\n        if (!this.updateTerminalProperties('target')) {\n          return ref;\n        }\n\n        ref = this.removeAction(ref, 'target');\n      }\n\n      var graph = this.graph;\n      var sourceView = this.sourceView;\n      var targetView = this.targetView;\n\n      if (graph && (sourceView && !graph.renderer.isViewMounted(sourceView) || targetView && !graph.renderer.isViewMounted(targetView))) {\n        // Wait for the sourceView and targetView to be rendered.\n        return ref;\n      }\n\n      if (this.hasAction(ref, 'render')) {\n        this.render();\n        ref = this.removeAction(ref, ['render', 'update', 'vertices', 'labels', 'tools', 'widget']);\n        return ref;\n      }\n\n      ref = this.handleAction(ref, 'vertices', function () {\n        return _this2.renderVertexMarkers();\n      });\n      ref = this.handleAction(ref, 'update', function () {\n        return _this2.update(null, options);\n      });\n      ref = this.handleAction(ref, 'labels', function () {\n        return _this2.onLabelsChange(options);\n      });\n      ref = this.handleAction(ref, 'tools', function () {\n        _this2.renderTools();\n\n        _this2.updateToolsPosition();\n      });\n      ref = this.handleAction(ref, 'widget', function () {\n        return _this2.renderExternalTools();\n      });\n      return ref;\n    }\n  }, {\n    key: \"onLabelsChange\",\n    value: function onLabelsChange() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      // Note: this optimization works in async=false mode only\n      if (this.shouldRerenderLabels(options)) {\n        this.renderLabels();\n      } else {\n        this.updateLabels();\n      }\n\n      this.updateLabelPositions();\n    }\n  }, {\n    key: \"shouldRerenderLabels\",\n    value: function shouldRerenderLabels() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var previousLabels = this.cell.previous('labels');\n\n      if (previousLabels == null) {\n        return true;\n      } // Here is an optimization for cases when we know, that change does\n      // not require re-rendering of all labels.\n\n\n      if ('propertyPathArray' in options && 'propertyValue' in options) {\n        // The label is setting by `prop()` method\n        var pathArray = options.propertyPathArray || [];\n        var pathLength = pathArray.length;\n\n        if (pathLength > 1) {\n          // We are changing a single label here e.g. 'labels/0/position'\n          var index = pathArray[1];\n\n          if (previousLabels[index]) {\n            if (pathLength === 2) {\n              // We are changing the entire label. Need to check if the\n              // markup is also being changed.\n              return typeof options.propertyValue === 'object' && ObjectExt.has(options.propertyValue, 'markup');\n            } // We are changing a label property but not the markup\n\n\n            if (pathArray[2] !== 'markup') {\n              return false;\n            }\n          }\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.empty();\n      this.containers = {};\n      this.renderMarkup();\n      this.renderLabels();\n      this.update();\n      return this;\n    }\n  }, {\n    key: \"renderMarkup\",\n    value: function renderMarkup() {\n      var markup = this.cell.markup;\n\n      if (markup) {\n        if (typeof markup === 'string') {\n          return this.renderStringMarkup(markup);\n        }\n\n        return this.renderJSONMarkup(markup);\n      }\n\n      throw new TypeError('Invalid edge markup.');\n    }\n  }, {\n    key: \"renderJSONMarkup\",\n    value: function renderJSONMarkup(markup) {\n      var ret = this.parseJSONMarkup(markup, this.container);\n      this.selectors = ret.selectors;\n      this.container.append(ret.fragment);\n    }\n  }, {\n    key: \"renderStringMarkup\",\n    value: function renderStringMarkup(markup) {\n      var cache = this.containers;\n      var children = Vector.createVectors(markup); // Cache children elements for quicker access.\n\n      children.forEach(function (child) {\n        var className = child.attr('class');\n\n        if (className) {\n          cache[StringExt.camelCase(className)] = child.node;\n        }\n      });\n      this.renderTools();\n      this.renderVertexMarkers();\n      this.renderArrowheadMarkers();\n      Dom.append(this.container, children.map(function (child) {\n        return child.node;\n      }));\n    }\n  }, {\n    key: \"renderLabels\",\n    value: function renderLabels() {\n      var edge = this.cell;\n      var labels = edge.getLabels();\n      var count = labels.length;\n      var container = this.containers.labels;\n      this.labelCache = {};\n      this.labelSelectors = {};\n\n      if (count <= 0) {\n        if (container && container.parentNode) {\n          container.parentNode.removeChild(container);\n        }\n\n        return this;\n      }\n\n      if (container) {\n        this.empty(container);\n      } else {\n        container = Dom.createSvgElement('g');\n        this.addClass(this.prefixClassName('edge-labels'), container);\n        this.containers.labels = container;\n      }\n\n      for (var i = 0, ii = labels.length; i < ii; i += 1) {\n        var label = labels[i];\n        var normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));\n        var labelNode = void 0;\n        var selectors = void 0;\n\n        if (normalized) {\n          labelNode = normalized.node;\n          selectors = normalized.selectors;\n        } else {\n          var defaultLabel = edge.getDefaultLabel();\n\n          var _normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));\n\n          labelNode = _normalized.node;\n          selectors = _normalized.selectors;\n        }\n\n        labelNode.setAttribute('data-index', \"\".concat(i));\n        container.appendChild(labelNode);\n        var rootSelector = this.rootSelector;\n\n        if (selectors[rootSelector]) {\n          throw new Error('Ambiguous label root selector.');\n        }\n\n        selectors[rootSelector] = labelNode;\n        this.labelCache[i] = labelNode;\n        this.labelSelectors[i] = selectors;\n      }\n\n      if (container.parentNode == null) {\n        this.container.appendChild(container);\n      }\n\n      this.updateLabels();\n      this.customizeLabels();\n      return this;\n    }\n  }, {\n    key: \"parseLabelMarkup\",\n    value: function parseLabelMarkup(markup) {\n      if (markup) {\n        if (typeof markup === 'string') {\n          return this.parseLabelStringMarkup(markup);\n        }\n\n        return this.parseJSONMarkup(markup);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"parseLabelStringMarkup\",\n    value: function parseLabelStringMarkup(labelMarkup) {\n      var children = Vector.createVectors(labelMarkup);\n      var fragment = document.createDocumentFragment();\n\n      for (var i = 0, n = children.length; i < n; i += 1) {\n        var currentChild = children[i].node;\n        fragment.appendChild(currentChild);\n      }\n\n      return {\n        fragment: fragment,\n        selectors: {}\n      };\n    }\n  }, {\n    key: \"normalizeLabelMarkup\",\n    value: function normalizeLabelMarkup(markup) {\n      if (markup == null) {\n        return;\n      }\n\n      var fragment = markup.fragment;\n\n      if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n        throw new Error('Invalid label markup.');\n      }\n\n      var vel;\n      var childNodes = fragment.childNodes;\n\n      if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n        // default markup fragment is not wrapped in `<g/>`\n        // add a `<g/>` container\n        vel = Vector.create('g').append(fragment);\n      } else {\n        vel = Vector.create(childNodes[0]);\n      }\n\n      vel.addClass(this.prefixClassName('edge-label'));\n      return {\n        node: vel.node,\n        selectors: markup.selectors\n      };\n    }\n  }, {\n    key: \"updateLabels\",\n    value: function updateLabels() {\n      if (this.containers.labels) {\n        var edge = this.cell;\n        var labels = edge.labels;\n        var canLabelMove = this.can('edgeLabelMovable');\n        var defaultLabel = edge.getDefaultLabel();\n\n        for (var i = 0, n = labels.length; i < n; i += 1) {\n          var elem = this.labelCache[i];\n          var selectors = this.labelSelectors[i];\n          elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n          var label = labels[i];\n          var attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs);\n          this.updateAttrs(elem, attrs, {\n            selectors: selectors,\n            rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined\n          });\n        }\n      }\n    }\n  }, {\n    key: \"mergeLabelAttrs\",\n    value: function mergeLabelAttrs(hasCustomMarkup, labelAttrs, defaultLabelAttrs) {\n      if (labelAttrs === null) {\n        return null;\n      }\n\n      if (labelAttrs === undefined) {\n        if (defaultLabelAttrs === null) {\n          return null;\n        }\n\n        if (defaultLabelAttrs === undefined) {\n          return undefined;\n        }\n\n        if (hasCustomMarkup) {\n          return defaultLabelAttrs;\n        }\n\n        return ObjectExt.merge({}, defaultLabelAttrs);\n      }\n\n      if (hasCustomMarkup) {\n        return ObjectExt.merge({}, defaultLabelAttrs, labelAttrs);\n      }\n    }\n  }, {\n    key: \"customizeLabels\",\n    value: function customizeLabels() {\n      if (this.containers.labels) {\n        var edge = this.cell;\n        var labels = edge.labels;\n\n        for (var i = 0, n = labels.length; i < n; i += 1) {\n          var label = labels[i];\n          var container = this.labelCache[i];\n          var selectors = this.labelSelectors[i];\n          this.graph.hook.onEdgeLabelRendered({\n            edge: edge,\n            label: label,\n            container: container,\n            selectors: selectors\n          });\n        }\n      }\n    }\n  }, {\n    key: \"renderTools\",\n    value: function renderTools() {\n      var container = this.containers.tools;\n\n      if (container == null) {\n        return this;\n      }\n\n      var markup = this.cell.toolMarkup;\n      var $container = this.$(container).empty();\n\n      if (Markup.isStringMarkup(markup)) {\n        var template = StringExt.template(markup);\n        var tool = Vector.create(template());\n        $container.append(tool.node);\n        this.toolCache = tool.node; // If `doubleTools` is enabled, we render copy of the tools on the\n        // other side of the edge as well but only if the edge is longer\n        // than `longLength`.\n\n        if (this.options.doubleTools) {\n          var tool2;\n          var doubleToolMarkup = this.cell.doubleToolMarkup;\n\n          if (Markup.isStringMarkup(doubleToolMarkup)) {\n            template = StringExt.template(doubleToolMarkup);\n            tool2 = Vector.create(template());\n          } else {\n            tool2 = tool.clone();\n          }\n\n          $container.append(tool2.node);\n          this.tool2Cache = tool2.node;\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"renderExternalTools\",\n    value: function renderExternalTools() {\n      var tools = this.cell.getTools();\n      this.addTools(tools);\n      return this;\n    }\n  }, {\n    key: \"renderVertexMarkers\",\n    value: function renderVertexMarkers() {\n      var container = this.containers.vertices;\n\n      if (container == null) {\n        return this;\n      }\n\n      var markup = this.cell.vertexMarkup;\n      var $container = this.$(container).empty();\n\n      if (Markup.isStringMarkup(markup)) {\n        var template = StringExt.template(markup);\n        this.cell.getVertices().forEach(function (vertex, index) {\n          $container.append(Vector.create(template(Object.assign({\n            index: index\n          }, vertex))).node);\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"renderArrowheadMarkers\",\n    value: function renderArrowheadMarkers() {\n      var container = this.containers.arrowheads;\n\n      if (container == null) {\n        return this;\n      }\n\n      var markup = this.cell.arrowheadMarkup;\n      var $container = this.$(container).empty();\n\n      if (Markup.isStringMarkup(markup)) {\n        var template = StringExt.template(markup);\n        var sourceArrowhead = Vector.create(template({\n          end: 'source'\n        })).node;\n        var targetArrowhead = Vector.create(template({\n          end: 'target'\n        })).node;\n        this.containers.sourceArrowhead = sourceArrowhead;\n        this.containers.targetArrowhead = targetArrowhead;\n        $container.append(sourceArrowhead, targetArrowhead);\n      }\n\n      return this;\n    } // #endregion\n    // #region updating\n\n  }, {\n    key: \"update\",\n    value: function update(partialAttrs) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.cleanCache();\n      this.updateConnection(options);\n      var attrs = this.cell.getAttrs();\n\n      if (attrs != null) {\n        this.updateAttrs(this.container, attrs, {\n          attrs: partialAttrs === attrs ? null : partialAttrs,\n          selectors: this.selectors\n        });\n      }\n\n      this.updateConnectionPath();\n      this.updateLabelPositions();\n      this.updateToolsPosition();\n      this.updateArrowheadMarkers();\n\n      if (options.toolId == null) {\n        this.renderExternalTools();\n      } else {\n        this.updateTools(options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeRedundantLinearVertices\",\n    value: function removeRedundantLinearVertices() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var edge = this.cell;\n      var vertices = edge.getVertices();\n      var routePoints = [this.sourceAnchor].concat(_toConsumableArray(vertices), [this.targetAnchor]);\n      var rawCount = routePoints.length; // Puts the route points into a polyline and try to simplify.\n\n      var polyline = new Polyline(routePoints);\n      polyline.simplify({\n        threshold: 0.01\n      });\n      var simplifiedPoints = polyline.points.map(function (point) {\n        return point.toJSON();\n      });\n      var simplifiedCount = simplifiedPoints.length; // If simplification did not remove any redundant vertices.\n\n      if (rawCount === simplifiedCount) {\n        return 0;\n      } // Sets simplified polyline points as edge vertices.\n      // Removes first and last polyline points again (source/target anchors).\n\n\n      edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);\n      return rawCount - simplifiedCount;\n    }\n  }, {\n    key: \"updateConnectionPath\",\n    value: function updateConnectionPath() {\n      var containers = this.containers;\n\n      if (containers.connection) {\n        var pathData = this.getConnectionPathData();\n        containers.connection.setAttribute('d', pathData);\n      }\n\n      if (containers.connectionWrap) {\n        var _pathData = this.getConnectionPathData();\n\n        containers.connectionWrap.setAttribute('d', _pathData);\n      }\n\n      if (containers.sourceMarker && containers.targetMarker) {\n        this.translateAndAutoOrientArrows(containers.sourceMarker, containers.targetMarker);\n      }\n    }\n  }, {\n    key: \"getTerminalView\",\n    value: function getTerminalView(type) {\n      switch (type) {\n        case 'source':\n          return this.sourceView || null;\n\n        case 'target':\n          return this.targetView || null;\n\n        default:\n          throw new Error(\"Unknown terminal type '\".concat(type, \"'\"));\n      }\n    }\n  }, {\n    key: \"getTerminalAnchor\",\n    value: function getTerminalAnchor(type) {\n      switch (type) {\n        case 'source':\n          return Point.create(this.sourceAnchor);\n\n        case 'target':\n          return Point.create(this.targetAnchor);\n\n        default:\n          throw new Error(\"Unknown terminal type '\".concat(type, \"'\"));\n      }\n    }\n  }, {\n    key: \"getTerminalConnectionPoint\",\n    value: function getTerminalConnectionPoint(type) {\n      switch (type) {\n        case 'source':\n          return Point.create(this.sourcePoint);\n\n        case 'target':\n          return Point.create(this.targetPoint);\n\n        default:\n          throw new Error(\"Unknown terminal type '\".concat(type, \"'\"));\n      }\n    }\n  }, {\n    key: \"getTerminalMagnet\",\n    value: function getTerminalMagnet(type) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      switch (type) {\n        case 'source':\n          {\n            if (options.raw) {\n              return this.sourceMagnet;\n            }\n\n            var sourceView = this.sourceView;\n\n            if (!sourceView) {\n              return null;\n            }\n\n            return this.sourceMagnet || sourceView.container;\n          }\n\n        case 'target':\n          {\n            if (options.raw) {\n              return this.targetMagnet;\n            }\n\n            var targetView = this.targetView;\n\n            if (!targetView) {\n              return null;\n            }\n\n            return this.targetMagnet || targetView.container;\n          }\n\n        default:\n          {\n            throw new Error(\"Unknown terminal type '\".concat(type, \"'\"));\n          }\n      }\n    }\n  }, {\n    key: \"updateConnection\",\n    value: function updateConnection() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var edge = this.cell; // The edge is being translated by an ancestor that will shift\n      // source, target and vertices by an equal distance.\n\n      if (options.translateBy && edge.isFragmentDescendantOf(options.translateBy)) {\n        var tx = options.tx || 0;\n        var ty = options.ty || 0;\n        this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;\n        this.translateConnectionPoints(tx, ty);\n        this.path.translate(tx, ty);\n      } else {\n        var vertices = edge.getVertices(); // 1. Find anchor points\n\n        var anchors = this.findAnchors(vertices);\n        this.sourceAnchor = anchors.source;\n        this.targetAnchor = anchors.target; // 2. Find route points\n\n        this.routePoints = this.findRoutePoints(vertices); // 3. Find connection points\n\n        var connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);\n        this.sourcePoint = connectionPoints.source;\n        this.targetPoint = connectionPoints.target; // 4. Find Marker Connection Point\n\n        var markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint); // 5. Make path\n\n        this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);\n      }\n\n      this.cleanCache();\n    }\n  }, {\n    key: \"findAnchors\",\n    value: function findAnchors(vertices) {\n      var edge = this.cell;\n      var source = edge.source;\n      var target = edge.target;\n      var firstVertex = vertices[0];\n      var lastVertex = vertices[vertices.length - 1];\n\n      if (target.priority && !source.priority) {\n        // Reversed order\n        return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n      } // Usual order\n\n\n      return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    }\n  }, {\n    key: \"findAnchorsOrdered\",\n    value: function findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {\n      var _ref;\n\n      var firstAnchor;\n      var secondAnchor;\n      var edge = this.cell;\n      var firstTerminal = edge[firstType];\n      var secondTerminal = edge[secondType];\n      var firstView = this.getTerminalView(firstType);\n      var secondView = this.getTerminalView(secondType);\n      var firstMagnet = this.getTerminalMagnet(firstType);\n      var secondMagnet = this.getTerminalMagnet(secondType);\n\n      if (firstView) {\n        var firstRef;\n\n        if (firstPoint) {\n          firstRef = Point.create(firstPoint);\n        } else if (secondView) {\n          firstRef = secondMagnet;\n        } else {\n          firstRef = Point.create(secondTerminal);\n        }\n\n        firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);\n      } else {\n        firstAnchor = Point.create(firstTerminal);\n      }\n\n      if (secondView) {\n        var secondRef = Point.create(secondPoint || firstAnchor);\n        secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);\n      } else {\n        secondAnchor = Point.isPointLike(secondTerminal) ? Point.create(secondTerminal) : new Point();\n      }\n\n      return _ref = {}, _defineProperty(_ref, firstType, firstAnchor), _defineProperty(_ref, secondType, secondAnchor), _ref;\n    }\n  }, {\n    key: \"getAnchor\",\n    value: function getAnchor(def, cellView, magnet, ref, terminalType) {\n      var isEdge = cellView.isEdgeElement(magnet);\n      var connecting = this.graph.options.connecting;\n      var config = typeof def === 'string' ? {\n        name: def\n      } : def;\n\n      if (!config) {\n        var defaults = isEdge ? (terminalType === 'source' ? connecting.sourceEdgeAnchor : connecting.targetEdgeAnchor) || connecting.edgeAnchor : (terminalType === 'source' ? connecting.sourceAnchor : connecting.targetAnchor) || connecting.anchor;\n        config = typeof defaults === 'string' ? {\n          name: defaults\n        } : defaults;\n      }\n\n      if (!config) {\n        throw new Error(\"Anchor should be specified.\");\n      }\n\n      var anchor;\n      var name = config.name;\n\n      if (isEdge) {\n        var fn = EdgeAnchor.registry.get(name);\n\n        if (typeof fn !== 'function') {\n          return EdgeAnchor.registry.onNotFound(name);\n        }\n\n        anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n      } else {\n        var _fn = NodeAnchor.registry.get(name);\n\n        if (typeof _fn !== 'function') {\n          return NodeAnchor.registry.onNotFound(name);\n        }\n\n        anchor = FunctionExt.call(_fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n      }\n\n      return anchor ? anchor.round(this.POINT_ROUNDING) : new Point();\n    }\n  }, {\n    key: \"findRoutePoints\",\n    value: function findRoutePoints() {\n      var vertices = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var defaultRouter = this.graph.options.connecting.router || Router.presets.normal;\n      var router = this.cell.getRouter() || defaultRouter;\n      var routePoints;\n\n      if (typeof router === 'function') {\n        routePoints = FunctionExt.call(router, this, vertices, {}, this);\n      } else {\n        var name = typeof router === 'string' ? router : router.name;\n        var args = typeof router === 'string' ? {} : router.args || {};\n        var fn = name ? Router.registry.get(name) : Router.presets.normal;\n\n        if (typeof fn !== 'function') {\n          return Router.registry.onNotFound(name);\n        }\n\n        routePoints = FunctionExt.call(fn, this, vertices, args, this);\n      }\n\n      return routePoints == null ? vertices.map(function (p) {\n        return Point.create(p);\n      }) : routePoints.map(function (p) {\n        return Point.create(p);\n      });\n    }\n  }, {\n    key: \"findConnectionPoints\",\n    value: function findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {\n      var edge = this.cell;\n      var connecting = this.graph.options.connecting;\n      var sourceTerminal = edge.getSource();\n      var targetTerminal = edge.getTarget();\n      var sourceView = this.sourceView;\n      var targetView = this.targetView;\n      var firstRoutePoint = routePoints[0];\n      var lastRoutePoint = routePoints[routePoints.length - 1]; // source\n\n      var sourcePoint;\n\n      if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n        var sourceMagnet = this.sourceMagnet || sourceView.container;\n        var sourcePointRef = firstRoutePoint || targetAnchor;\n        var sourceLine = new Line(sourcePointRef, sourceAnchor);\n        var connectionPointDef = sourceTerminal.connectionPoint || connecting.sourceConnectionPoint || connecting.connectionPoint;\n        sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n      } else {\n        sourcePoint = sourceAnchor;\n      } // target\n\n\n      var targetPoint;\n\n      if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n        var targetMagnet = this.targetMagnet || targetView.container;\n        var targetConnectionPointDef = targetTerminal.connectionPoint || connecting.targetConnectionPoint || connecting.connectionPoint;\n        var targetPointRef = lastRoutePoint || sourceAnchor;\n        var targetLine = new Line(targetPointRef, targetAnchor);\n        targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n      } else {\n        targetPoint = targetAnchor;\n      }\n\n      return {\n        source: sourcePoint,\n        target: targetPoint\n      };\n    }\n  }, {\n    key: \"getConnectionPoint\",\n    value: function getConnectionPoint(def, view, magnet, line, endType) {\n      var anchor = line.end;\n\n      if (def == null) {\n        return anchor;\n      }\n\n      var name = typeof def === 'string' ? def : def.name;\n      var args = typeof def === 'string' ? {} : def.args;\n      var fn = ConnectionPoint.registry.get(name);\n\n      if (typeof fn !== 'function') {\n        return ConnectionPoint.registry.onNotFound(name);\n      }\n\n      var connectionPoint = FunctionExt.call(fn, this, line, view, magnet, args || {}, endType);\n      return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;\n    }\n  }, {\n    key: \"updateMarkerAttr\",\n    value: function updateMarkerAttr(type) {\n      var attrs = this.cell.getAttrs();\n      var key = \".\".concat(type, \"-marker\");\n      var partial = attrs && attrs[key];\n\n      if (partial) {\n        this.updateAttrs(this.container, {}, {\n          attrs: _defineProperty({}, key, partial),\n          selectors: this.selectors\n        });\n      }\n    }\n  }, {\n    key: \"findMarkerPoints\",\n    value: function findMarkerPoints(routePoints, sourcePoint, targetPoint) {\n      var _this3 = this;\n\n      var getLineWidth = function getLineWidth(type) {\n        var attrs = _this3.cell.getAttrs();\n\n        var keys = Object.keys(attrs);\n\n        for (var i = 0, l = keys.length; i < l; i += 1) {\n          var attr = attrs[keys[i]];\n\n          if (attr[\"\".concat(type, \"Marker\")] || attr[\"\".concat(type, \"-marker\")]) {\n            var strokeWidth = attr.strokeWidth || attr['stroke-width'];\n\n            if (strokeWidth) {\n              return parseFloat(strokeWidth);\n            }\n\n            break;\n          }\n        }\n\n        return null;\n      };\n\n      var firstRoutePoint = routePoints[0];\n      var lastRoutePoint = routePoints[routePoints.length - 1];\n      var sourceMarkerElem = this.containers.sourceMarker;\n      var targetMarkerElem = this.containers.targetMarker;\n      var cache = this.markerCache;\n      var sourceMarkerPoint;\n      var targetMarkerPoint; // Move the source point by the width of the marker taking into\n      // account its scale around x-axis. Note that scale is the only\n      // transform that makes sense to be set in `.marker-source`\n      // attributes object as all other transforms (translate/rotate)\n      // will be replaced by the `translateAndAutoOrient()` function.\n\n      if (sourceMarkerElem) {\n        this.updateMarkerAttr('source'); // support marker connection point registry???\n\n        cache.sourceBBox = cache.sourceBBox || Dom.getBBox(sourceMarkerElem);\n\n        if (cache.sourceBBox.width > 0) {\n          var scale = Dom.scale(sourceMarkerElem);\n          sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, cache.sourceBBox.width * scale.sx * -1);\n        }\n      } else {\n        var strokeWidth = getLineWidth('source');\n\n        if (strokeWidth) {\n          sourceMarkerPoint = sourcePoint.clone().move(firstRoutePoint || targetPoint, -strokeWidth);\n        }\n      }\n\n      if (targetMarkerElem) {\n        this.updateMarkerAttr('target');\n        cache.targetBBox = cache.targetBBox || Dom.getBBox(targetMarkerElem);\n\n        if (cache.targetBBox.width > 0) {\n          var _scale = Dom.scale(targetMarkerElem);\n\n          targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, cache.targetBBox.width * _scale.sx * -1);\n        }\n      } else {\n        var _strokeWidth = getLineWidth('target');\n\n        if (_strokeWidth) {\n          targetMarkerPoint = targetPoint.clone().move(lastRoutePoint || sourcePoint, -_strokeWidth);\n        }\n      } // If there was no markup for the marker, use the connection point.\n\n\n      cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n      cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n      return {\n        source: sourceMarkerPoint,\n        target: targetMarkerPoint\n      };\n    }\n  }, {\n    key: \"findPath\",\n    value: function findPath(routePoints, sourcePoint, targetPoint) {\n      var def = this.cell.getConnector() || this.graph.options.connecting.connector;\n      var name;\n      var args;\n      var fn;\n\n      if (typeof def === 'string') {\n        name = def;\n      } else {\n        name = def.name;\n        args = def.args;\n      }\n\n      if (name) {\n        var method = Connector.registry.get(name);\n\n        if (typeof method !== 'function') {\n          return Connector.registry.onNotFound(name);\n        }\n\n        fn = method;\n      } else {\n        fn = Connector.presets.normal;\n      }\n\n      var path = FunctionExt.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), {\n        raw: true\n      }), this);\n      return typeof path === 'string' ? Path.parse(path) : path;\n    }\n  }, {\n    key: \"translateConnectionPoints\",\n    value: function translateConnectionPoints(tx, ty) {\n      var cache = this.markerCache;\n\n      if (cache.sourcePoint) {\n        cache.sourcePoint.translate(tx, ty);\n      }\n\n      if (cache.targetPoint) {\n        cache.targetPoint.translate(tx, ty);\n      }\n\n      this.sourcePoint.translate(tx, ty);\n      this.targetPoint.translate(tx, ty);\n      this.sourceAnchor.translate(tx, ty);\n      this.targetAnchor.translate(tx, ty);\n    }\n  }, {\n    key: \"updateLabelPositions\",\n    value: function updateLabelPositions() {\n      if (this.containers.labels == null) {\n        return this;\n      }\n\n      var path = this.path;\n\n      if (!path) {\n        return this;\n      }\n\n      var edge = this.cell;\n      var labels = edge.getLabels();\n\n      if (labels.length === 0) {\n        return this;\n      }\n\n      var defaultLabel = edge.getDefaultLabel();\n      var defaultPosition = this.normalizeLabelPosition(defaultLabel.position);\n\n      for (var i = 0, ii = labels.length; i < ii; i += 1) {\n        var label = labels[i];\n        var labelPosition = this.normalizeLabelPosition(label.position);\n        var pos = ObjectExt.merge({}, defaultPosition, labelPosition);\n        var matrix = this.getLabelTransformationMatrix(pos);\n        this.labelCache[i].setAttribute('transform', Dom.matrixToTransformString(matrix));\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateToolsPosition\",\n    value: function updateToolsPosition() {\n      if (this.containers.tools == null) {\n        return this;\n      } // Move the tools a bit to the target position but don't cover the\n      // `sourceArrowhead` marker. Note that the offset is hardcoded here.\n      // The offset should be always more than the\n      // `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n      // this up all the time would be slow.\n\n\n      var scale = '';\n      var offset = this.options.toolsOffset;\n      var connectionLength = this.getConnectionLength(); // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).\n      // In that case we won't update tools position at all.\n\n      if (connectionLength != null) {\n        // If the edge is too short, make the tools half the\n        // size and the offset twice as low.\n        if (connectionLength < this.options.shortLength) {\n          scale = 'scale(.5)';\n          offset /= 2;\n        }\n\n        var pos = this.getPointAtLength(offset);\n\n        if (pos != null) {\n          Dom.attr(this.toolCache, 'transform', \"translate(\".concat(pos.x, \",\").concat(pos.y, \") \").concat(scale));\n        }\n\n        if (this.options.doubleTools && connectionLength >= this.options.longLength) {\n          var doubleToolsOffset = this.options.doubleToolsOffset || offset;\n          pos = this.getPointAtLength(connectionLength - doubleToolsOffset);\n\n          if (pos != null) {\n            Dom.attr(this.tool2Cache, 'transform', \"translate(\".concat(pos.x, \",\").concat(pos.y, \") \").concat(scale));\n          }\n\n          Dom.attr(this.tool2Cache, 'visibility', 'visible');\n        } else if (this.options.doubleTools) {\n          Dom.attr(this.tool2Cache, 'visibility', 'hidden');\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateArrowheadMarkers\",\n    value: function updateArrowheadMarkers() {\n      var container = this.containers.arrowheads;\n\n      if (container == null) {\n        return this;\n      }\n\n      if (container.style.display === 'none') {\n        return this;\n      }\n\n      var sourceArrowhead = this.containers.sourceArrowhead;\n      var targetArrowhead = this.containers.targetArrowhead;\n\n      if (sourceArrowhead && targetArrowhead) {\n        var len = this.getConnectionLength() || 0;\n        var sx = len < this.options.shortLength ? 0.5 : 1;\n        Dom.scale(sourceArrowhead, sx);\n        Dom.scale(targetArrowhead, sx);\n        this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"updateTerminalProperties\",\n    value: function updateTerminalProperties(type) {\n      var edge = this.cell;\n      var graph = this.graph;\n      var terminal = edge[type];\n      var nodeId = terminal && terminal.cell;\n      var viewKey = \"\".concat(type, \"View\"); // terminal is a point\n\n      if (!nodeId) {\n        this[viewKey] = null;\n        this.updateTerminalMagnet(type);\n        return true;\n      }\n\n      var terminalCell = graph.getCellById(nodeId);\n\n      if (!terminalCell) {\n        throw new Error(\"Edge's \".concat(type, \" node with id \\\"\").concat(nodeId, \"\\\" not exists\"));\n      }\n\n      var endView = terminalCell.findView(graph);\n\n      if (!endView) {\n        return false;\n      }\n\n      this[viewKey] = endView;\n      this.updateTerminalMagnet(type);\n      return true;\n    }\n  }, {\n    key: \"updateTerminalMagnet\",\n    value: function updateTerminalMagnet(type) {\n      var propName = \"\".concat(type, \"Magnet\");\n      var terminalView = this.getTerminalView(type);\n\n      if (terminalView) {\n        var magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);\n\n        if (magnet === terminalView.container) {\n          magnet = null;\n        }\n\n        this[propName] = magnet;\n      } else {\n        this[propName] = null;\n      }\n    }\n  }, {\n    key: \"translateAndAutoOrientArrows\",\n    value: function translateAndAutoOrientArrows(sourceArrow, targetArrow) {\n      var route = this.routePoints;\n\n      if (sourceArrow) {\n        Dom.translateAndAutoOrient(sourceArrow, this.sourcePoint, route[0] || this.targetPoint, this.graph.view.stage);\n      }\n\n      if (targetArrow) {\n        Dom.translateAndAutoOrient(targetArrow, this.targetPoint, route[route.length - 1] || this.sourcePoint, this.graph.view.stage);\n      }\n    }\n  }, {\n    key: \"getLabelPositionAngle\",\n    value: function getLabelPositionAngle(idx) {\n      var label = this.cell.getLabelAt(idx);\n\n      if (label && label.position && typeof label.position === 'object') {\n        return label.position.angle || 0;\n      }\n\n      return 0;\n    }\n  }, {\n    key: \"getLabelPositionArgs\",\n    value: function getLabelPositionArgs(idx) {\n      var label = this.cell.getLabelAt(idx);\n\n      if (label && label.position && typeof label.position === 'object') {\n        return label.position.options;\n      }\n    }\n  }, {\n    key: \"getDefaultLabelPositionArgs\",\n    value: function getDefaultLabelPositionArgs() {\n      var defaultLabel = this.cell.getDefaultLabel();\n\n      if (defaultLabel && defaultLabel.position && typeof defaultLabel.position === 'object') {\n        return defaultLabel.position.options;\n      }\n    } // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n\n  }, {\n    key: \"mergeLabelPositionArgs\",\n    value: function mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {\n      if (labelPositionArgs === null) {\n        return null;\n      }\n\n      if (labelPositionArgs === undefined) {\n        if (defaultLabelPositionArgs === null) {\n          return null;\n        }\n\n        return defaultLabelPositionArgs;\n      }\n\n      return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs);\n    }\n  }, {\n    key: \"addLabel\",\n    value: function addLabel(p1, p2, p3, options) {\n      var localX;\n      var localY;\n      var localAngle = 0;\n      var localOptions;\n\n      if (typeof p1 !== 'number') {\n        localX = p1.x;\n        localY = p1.y;\n\n        if (typeof p2 === 'number') {\n          localAngle = p2;\n          localOptions = p3;\n        } else {\n          localOptions = p2;\n        }\n      } else {\n        localX = p1;\n        localY = p2;\n\n        if (typeof p3 === 'number') {\n          localAngle = p3;\n          localOptions = options;\n        } else {\n          localOptions = p3;\n        }\n      } // merge label position arguments\n\n\n      var defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n      var labelPositionArgs = localOptions;\n      var positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs); // append label to labels array\n\n      var label = {\n        position: this.getLabelPosition(localX, localY, localAngle, positionArgs)\n      };\n      var index = -1;\n      this.cell.insertLabel(label, index, localOptions);\n      return index;\n    }\n  }, {\n    key: \"addVertex\",\n    value: function addVertex(x, y, options) {\n      var isPoint = typeof x !== 'number';\n      var localX = isPoint ? x.x : x;\n      var localY = isPoint ? x.y : y;\n      var localOptions = isPoint ? y : options;\n      var vertex = {\n        x: localX,\n        y: localY\n      };\n      var index = this.getVertexIndex(localX, localY);\n      this.cell.insertVertex(vertex, index, localOptions);\n      return index;\n    }\n  }, {\n    key: \"sendToken\",\n    value: function sendToken(token, options, callback) {\n      var duration;\n      var reversed;\n      var selector;\n      var rorate;\n      var timing = 'linear';\n\n      if (typeof options === 'object') {\n        duration = options.duration;\n        reversed = options.reversed === true;\n        selector = options.selector;\n\n        if (options.rotate === false) {\n          rorate = '';\n        } else if (options.rotate === true) {\n          rorate = 'auto';\n        } else if (options.rotate != null) {\n          rorate = \"\".concat(options.rotate);\n        }\n\n        if (options.timing) {\n          timing = options.timing;\n        }\n      } else {\n        duration = options;\n        reversed = false;\n        selector = null;\n      }\n\n      duration = duration || 1000;\n      var attrs = {\n        dur: \"\".concat(duration, \"ms\"),\n        repeatCount: '1',\n        calcMode: timing,\n        fill: 'freeze'\n      };\n\n      if (rorate) {\n        attrs.rotate = rorate;\n      }\n\n      if (reversed) {\n        attrs.keyPoints = '1;0';\n        attrs.keyTimes = '0;1';\n      }\n\n      if (typeof options === 'object') {\n        var _duration = options.duration,\n            _reversed = options.reversed,\n            _selector = options.selector,\n            rotate = options.rotate,\n            _timing = options.timing,\n            others = __rest(options, [\"duration\", \"reversed\", \"selector\", \"rotate\", \"timing\"]);\n\n        Object.keys(others).forEach(function (key) {\n          attrs[key] = others[key];\n        });\n      }\n\n      var path;\n\n      if (typeof selector === 'string') {\n        path = this.findOne(selector, this.container, this.selectors);\n      } else {\n        // Select connection path automatically.\n        path = this.containers.connection ? this.containers.connection : this.container.querySelector('path');\n      }\n\n      if (!(path instanceof SVGPathElement)) {\n        throw new Error('Token animation requires a valid connection path.');\n      }\n\n      var target = typeof token === 'string' ? this.findOne(token) : token;\n\n      if (target == null) {\n        throw new Error('Token animation requires a valid token element.');\n      }\n\n      var parent = target.parentNode;\n\n      var revert = function revert() {\n        if (!parent) {\n          Dom.remove(target);\n        }\n      };\n\n      var vToken = Vector.create(target);\n\n      if (!parent) {\n        vToken.appendTo(this.graph.view.stage);\n      }\n\n      var onComplete = attrs.complete;\n\n      attrs.complete = function (e) {\n        revert();\n\n        if (callback) {\n          callback();\n        }\n\n        if (onComplete) {\n          onComplete(e);\n        }\n      };\n\n      var stop = vToken.animateAlongPath(attrs, path);\n      return function () {\n        revert();\n        stop();\n      };\n    } // #endregion\n\n  }, {\n    key: \"getConnection\",\n    value: function getConnection() {\n      return this.path != null ? this.path.clone() : null;\n    }\n  }, {\n    key: \"getConnectionPathData\",\n    value: function getConnectionPathData() {\n      if (this.path == null) {\n        return '';\n      }\n\n      var cache = this.cache.pathCache;\n\n      if (!ObjectExt.has(cache, 'data')) {\n        cache.data = this.path.serialize();\n      }\n\n      return cache.data || '';\n    }\n  }, {\n    key: \"getConnectionSubdivisions\",\n    value: function getConnectionSubdivisions() {\n      if (this.path == null) {\n        return null;\n      }\n\n      var cache = this.cache.pathCache;\n\n      if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n        cache.segmentSubdivisions = this.path.getSegmentSubdivisions();\n      }\n\n      return cache.segmentSubdivisions;\n    }\n  }, {\n    key: \"getConnectionLength\",\n    value: function getConnectionLength() {\n      if (this.path == null) {\n        return 0;\n      }\n\n      var cache = this.cache.pathCache;\n\n      if (!ObjectExt.has(cache, 'length')) {\n        cache.length = this.path.length({\n          segmentSubdivisions: this.getConnectionSubdivisions()\n        });\n      }\n\n      return cache.length;\n    }\n  }, {\n    key: \"getPointAtLength\",\n    value: function getPointAtLength(length) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.pointAtLength(length, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getPointAtRatio\",\n    value: function getPointAtRatio(ratio) {\n      if (this.path == null) {\n        return null;\n      }\n\n      if (NumberExt.isPercentage(ratio)) {\n        // eslint-disable-next-line\n        ratio = parseFloat(ratio) / 100;\n      }\n\n      return this.path.pointAt(ratio, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getTangentAtLength\",\n    value: function getTangentAtLength(length) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.tangentAtLength(length, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getTangentAtRatio\",\n    value: function getTangentAtRatio(ratio) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.tangentAt(ratio, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getClosestPoint\",\n    value: function getClosestPoint(point) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.closestPoint(point, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getClosestPointLength\",\n    value: function getClosestPointLength(point) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.closestPointLength(point, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getClosestPointRatio\",\n    value: function getClosestPointRatio(point) {\n      if (this.path == null) {\n        return null;\n      }\n\n      return this.path.closestPointNormalizedLength(point, {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      });\n    }\n  }, {\n    key: \"getLabelPosition\",\n    value: function getLabelPosition(x, y, p3, p4) {\n      var pos = {\n        distance: 0\n      }; // normalize data from the two possible signatures\n\n      var angle = 0;\n      var options;\n\n      if (typeof p3 === 'number') {\n        angle = p3;\n        options = p4;\n      } else {\n        options = p3;\n      }\n\n      if (options != null) {\n        pos.options = options;\n      } // identify distance/offset settings\n\n\n      var isOffsetAbsolute = options && options.absoluteOffset;\n      var isDistanceRelative = !(options && options.absoluteDistance);\n      var isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance; // find closest point t\n\n      var path = this.path;\n      var pathOptions = {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      };\n      var labelPoint = new Point(x, y);\n      var t = path.closestPointT(labelPoint, pathOptions); // distance\n\n      var totalLength = this.getConnectionLength() || 0;\n      var labelDistance = path.lengthAtT(t, pathOptions);\n\n      if (isDistanceRelative) {\n        labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;\n      }\n\n      if (isDistanceAbsoluteReverse) {\n        // fix for end point (-0 => 1)\n        labelDistance = -1 * (totalLength - labelDistance) || 1;\n      }\n\n      pos.distance = labelDistance; // offset\n      // use absolute offset if:\n      // - options.absoluteOffset is true,\n      // - options.absoluteOffset is not true but there is no tangent\n\n      var tangent;\n      if (!isOffsetAbsolute) tangent = path.tangentAtT(t);\n      var labelOffset;\n\n      if (tangent) {\n        labelOffset = tangent.pointOffset(labelPoint);\n      } else {\n        var closestPoint = path.pointAtT(t);\n        var labelOffsetDiff = labelPoint.diff(closestPoint);\n        labelOffset = {\n          x: labelOffsetDiff.x,\n          y: labelOffsetDiff.y\n        };\n      }\n\n      pos.offset = labelOffset;\n      pos.angle = angle;\n      return pos;\n    }\n  }, {\n    key: \"normalizeLabelPosition\",\n    value: function normalizeLabelPosition(pos) {\n      if (typeof pos === 'number') {\n        return {\n          distance: pos\n        };\n      }\n\n      return pos;\n    }\n  }, {\n    key: \"getLabelTransformationMatrix\",\n    value: function getLabelTransformationMatrix(labelPosition) {\n      var pos = this.normalizeLabelPosition(labelPosition);\n      var options = pos.options || {};\n      var labelAngle = pos.angle || 0;\n      var labelDistance = pos.distance;\n      var isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n      var labelOffset = 0;\n      var offsetCoord = {\n        x: 0,\n        y: 0\n      };\n      var offset = pos.offset;\n\n      if (offset) {\n        if (typeof offset === 'number') {\n          labelOffset = offset;\n        } else {\n          if (offset.x != null) {\n            offsetCoord.x = offset.x;\n          }\n\n          if (offset.y != null) {\n            offsetCoord.y = offset.y;\n          }\n        }\n      }\n\n      var isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;\n      var isKeepGradient = options.keepGradient;\n      var isEnsureLegibility = options.ensureLegibility;\n      var path = this.path;\n      var pathOpt = {\n        segmentSubdivisions: this.getConnectionSubdivisions()\n      };\n      var distance = isDistanceRelative ? labelDistance * this.getConnectionLength() : labelDistance;\n      var tangent = path.tangentAtLength(distance, pathOpt);\n      var translation;\n      var angle = labelAngle;\n\n      if (tangent) {\n        if (isOffsetAbsolute) {\n          translation = tangent.start;\n          translation.translate(offsetCoord);\n        } else {\n          var normal = tangent.clone();\n          normal.rotate(-90, tangent.start);\n          normal.setLength(labelOffset);\n          translation = normal.end;\n        }\n\n        if (isKeepGradient) {\n          angle = tangent.angle() + labelAngle;\n\n          if (isEnsureLegibility) {\n            angle = Angle.normalize((angle + 90) % 180 - 90);\n          }\n        }\n      } else {\n        // fallback - the connection has zero length\n        translation = path.start;\n\n        if (isOffsetAbsolute) {\n          translation.translate(offsetCoord);\n        }\n      }\n\n      return Dom.createSVGMatrix().translate(translation.x, translation.y).rotate(angle);\n    }\n  }, {\n    key: \"getLabelCoordinates\",\n    value: function getLabelCoordinates(pos) {\n      var matrix = this.getLabelTransformationMatrix(pos);\n      return new Point(matrix.e, matrix.f);\n    }\n  }, {\n    key: \"getVertexIndex\",\n    value: function getVertexIndex(x, y) {\n      var edge = this.cell;\n      var vertices = edge.getVertices();\n      var vertexLength = this.getClosestPointLength(new Point(x, y));\n      var index = 0;\n\n      if (vertexLength != null) {\n        for (var ii = vertices.length; index < ii; index += 1) {\n          var currentVertex = vertices[index];\n          var currentLength = this.getClosestPointLength(currentVertex);\n\n          if (currentLength != null && vertexLength < currentLength) {\n            break;\n          }\n        }\n      }\n\n      return index;\n    }\n  }, {\n    key: \"getEventArgs\",\n    value: function getEventArgs(e, x, y) {\n      var view = this; // eslint-disable-line\n\n      var edge = view.cell;\n      var cell = edge;\n\n      if (x == null || y == null) {\n        return {\n          e: e,\n          view: view,\n          edge: edge,\n          cell: cell\n        };\n      }\n\n      return {\n        e: e,\n        x: x,\n        y: y,\n        view: view,\n        edge: edge,\n        cell: cell\n      };\n    }\n  }, {\n    key: \"notifyUnhandledMouseDown\",\n    value: function notifyUnhandledMouseDown(e, x, y) {\n      this.notify('edge:unhandled:mousedown', {\n        e: e,\n        x: x,\n        y: y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n  }, {\n    key: \"notifyMouseDown\",\n    value: function notifyMouseDown(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseDown\", this).call(this, e, x, y);\n\n      this.notify('edge:mousedown', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"notifyMouseMove\",\n    value: function notifyMouseMove(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseMove\", this).call(this, e, x, y);\n\n      this.notify('edge:mousemove', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"notifyMouseUp\",\n    value: function notifyMouseUp(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseUp\", this).call(this, e, x, y);\n\n      this.notify('edge:mouseup', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onClick\",\n    value: function onClick(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onClick\", this).call(this, e, x, y);\n\n      this.notify('edge:click', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onDblClick\",\n    value: function onDblClick(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onDblClick\", this).call(this, e, x, y);\n\n      this.notify('edge:dblclick', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onContextMenu\",\n    value: function onContextMenu(e, x, y) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onContextMenu\", this).call(this, e, x, y);\n\n      this.notify('edge:contextmenu', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(e, x, y) {\n      this.notifyMouseDown(e, x, y);\n      var className = e.target.getAttribute('class');\n\n      switch (className) {\n        case 'vertex':\n          {\n            this.startVertexDragging(e, x, y);\n            return;\n          }\n\n        case 'vertex-remove':\n        case 'vertex-remove-area':\n          {\n            this.handleVertexRemoving(e, x, y);\n            return;\n          }\n\n        case 'connection':\n        case 'connection-wrap':\n          {\n            this.handleVertexAdding(e, x, y);\n            return;\n          }\n\n        case 'arrowhead':\n          {\n            this.startArrowheadDragging(e, x, y);\n            return;\n          }\n\n        case 'source-marker':\n        case 'target-marker':\n          {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n          }\n\n        default:\n          break;\n      }\n\n      this.startEdgeDragging(e, x, y);\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(e, x, y) {\n      var data = this.getEventData(e);\n\n      switch (data.action) {\n        case 'drag-vertex':\n          {\n            this.dragVertex(e, x, y);\n            break;\n          }\n\n        case 'drag-label':\n          {\n            this.dragLabel(e, x, y);\n            break;\n          }\n\n        case 'drag-arrowhead':\n          {\n            this.dragArrowhead(e, x, y);\n            break;\n          }\n\n        case 'drag-edge':\n          {\n            this.dragEdge(e, x, y);\n            break;\n          }\n\n        default:\n          break;\n      }\n\n      this.notifyMouseMove(e, x, y);\n      return data;\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(e, x, y) {\n      var data = this.getEventData(e);\n\n      switch (data.action) {\n        case 'drag-vertex':\n          {\n            this.stopVertexDragging(e, x, y);\n            break;\n          }\n\n        case 'drag-label':\n          {\n            this.stopLabelDragging(e, x, y);\n            break;\n          }\n\n        case 'drag-arrowhead':\n          {\n            this.stopArrowheadDragging(e, x, y);\n            break;\n          }\n\n        case 'drag-edge':\n          {\n            this.stopEdgeDragging(e, x, y);\n            break;\n          }\n\n        default:\n          break;\n      }\n\n      this.notifyMouseUp(e, x, y);\n      this.checkMouseleave(e);\n      return data;\n    }\n  }, {\n    key: \"onMouseOver\",\n    value: function onMouseOver(e) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseOver\", this).call(this, e);\n\n      this.notify('edge:mouseover', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseOut\",\n    value: function onMouseOut(e) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseOut\", this).call(this, e);\n\n      this.notify('edge:mouseout', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseEnter\",\n    value: function onMouseEnter(e) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseEnter\", this).call(this, e);\n\n      this.notify('edge:mouseenter', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave(e) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseLeave\", this).call(this, e);\n\n      this.notify('edge:mouseleave', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseWheel\",\n    value: function onMouseWheel(e, x, y, delta) {\n      _get(_getPrototypeOf(EdgeView.prototype), \"onMouseWheel\", this).call(this, e, x, y, delta);\n\n      this.notify('edge:mousewheel', Object.assign({\n        delta: delta\n      }, this.getEventArgs(e, x, y)));\n    }\n  }, {\n    key: \"onCustomEvent\",\n    value: function onCustomEvent(e, name, x, y) {\n      // For default edge tool\n      var tool = Dom.findParentByClass(e.target, 'edge-tool', this.container);\n\n      if (tool) {\n        e.stopPropagation(); // no further action to be executed\n\n        if (this.can('useEdgeTools')) {\n          if (name === 'edge:remove') {\n            this.cell.remove({\n              ui: true\n            });\n            return;\n          }\n\n          this.notify('edge:customevent', Object.assign({\n            name: name\n          }, this.getEventArgs(e, x, y)));\n        }\n\n        this.notifyMouseDown(e, x, y);\n      } else {\n        this.notify('edge:customevent', Object.assign({\n          name: name\n        }, this.getEventArgs(e, x, y)));\n\n        _get(_getPrototypeOf(EdgeView.prototype), \"onCustomEvent\", this).call(this, e, name, x, y);\n      }\n    }\n  }, {\n    key: \"onLabelMouseDown\",\n    value: function onLabelMouseDown(e, x, y) {\n      this.notifyMouseDown(e, x, y);\n      this.startLabelDragging(e, x, y);\n      var stopPropagation = this.getEventData(e).stopPropagation;\n\n      if (stopPropagation) {\n        e.stopPropagation();\n      }\n    } // #region drag edge\n\n  }, {\n    key: \"startEdgeDragging\",\n    value: function startEdgeDragging(e, x, y) {\n      if (!this.can('edgeMovable')) {\n        this.notifyUnhandledMouseDown(e, x, y);\n        return;\n      }\n\n      this.setEventData(e, {\n        x: x,\n        y: y,\n        moving: false,\n        action: 'drag-edge'\n      });\n    }\n  }, {\n    key: \"dragEdge\",\n    value: function dragEdge(e, x, y) {\n      var data = this.getEventData(e);\n\n      if (!data.moving) {\n        data.moving = true;\n        this.addClass('edge-moving');\n        this.notify('edge:move', {\n          e: e,\n          x: x,\n          y: y,\n          view: this,\n          cell: this.cell,\n          edge: this.cell\n        });\n      }\n\n      this.cell.translate(x - data.x, y - data.y, {\n        ui: true\n      });\n      this.setEventData(e, {\n        x: x,\n        y: y\n      });\n      this.notify('edge:moving', {\n        e: e,\n        x: x,\n        y: y,\n        view: this,\n        cell: this.cell,\n        edge: this.cell\n      });\n    }\n  }, {\n    key: \"stopEdgeDragging\",\n    value: function stopEdgeDragging(e, x, y) {\n      var data = this.getEventData(e);\n\n      if (data.moving) {\n        this.removeClass('edge-moving');\n        this.notify('edge:moved', {\n          e: e,\n          x: x,\n          y: y,\n          view: this,\n          cell: this.cell,\n          edge: this.cell\n        });\n      }\n\n      data.moving = false;\n    } // #endregion\n    // #region drag arrowhead\n\n  }, {\n    key: \"prepareArrowheadDragging\",\n    value: function prepareArrowheadDragging(type, options) {\n      var magnet = this.getTerminalMagnet(type);\n      var data = {\n        action: 'drag-arrowhead',\n        x: options.x,\n        y: options.y,\n        isNewEdge: options.isNewEdge === true,\n        terminalType: type,\n        initialMagnet: magnet,\n        initialTerminal: ObjectExt.clone(this.cell[type]),\n        fallbackAction: options.fallbackAction || 'revert',\n        getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n        options: options.options\n      };\n      this.beforeArrowheadDragging(data);\n      return data;\n    }\n  }, {\n    key: \"createValidateConnectionArgs\",\n    value: function createValidateConnectionArgs(type) {\n      var args = [];\n      args[4] = type;\n      args[5] = this;\n      var opposite;\n      var i = 0;\n      var j = 0;\n\n      if (type === 'source') {\n        i = 2;\n        opposite = 'target';\n      } else {\n        j = 2;\n        opposite = 'source';\n      }\n\n      var terminal = this.cell[opposite];\n      var cellId = terminal.cell;\n\n      if (cellId) {\n        var magnet;\n        var view = args[i] = this.graph.renderer.findViewByCell(cellId);\n\n        if (view) {\n          magnet = view.getMagnetFromEdgeTerminal(terminal);\n\n          if (magnet === view.container) {\n            magnet = undefined;\n          }\n        }\n\n        args[i + 1] = magnet;\n      }\n\n      return function (cellView, magnet) {\n        args[j] = cellView;\n        args[j + 1] = cellView.container === magnet ? undefined : magnet;\n        return args;\n      };\n    }\n  }, {\n    key: \"beforeArrowheadDragging\",\n    value: function beforeArrowheadDragging(data) {\n      data.zIndex = this.cell.zIndex;\n      this.cell.toFront();\n      var style = this.container.style;\n      data.pointerEvents = style.pointerEvents;\n      style.pointerEvents = 'none';\n\n      if (this.graph.options.connecting.highlight) {\n        this.highlightAvailableMagnets(data);\n      }\n    }\n  }, {\n    key: \"afterArrowheadDragging\",\n    value: function afterArrowheadDragging(data) {\n      if (data.zIndex != null) {\n        this.cell.setZIndex(data.zIndex, {\n          ui: true\n        });\n        data.zIndex = null;\n      }\n\n      var container = this.container;\n      container.style.pointerEvents = data.pointerEvents || '';\n\n      if (this.graph.options.connecting.highlight) {\n        this.unhighlightAvailableMagnets(data);\n      }\n    }\n  }, {\n    key: \"arrowheadDragging\",\n    value: function arrowheadDragging(target, x, y, data) {\n      data.x = x;\n      data.y = y; // Checking views right under the pointer\n\n      if (data.currentTarget !== target) {\n        // Unhighlight the previous view under pointer if there was one.\n        if (data.currentMagnet && data.currentView) {\n          data.currentView.unhighlight(data.currentMagnet, {\n            type: 'magnetAdsorbed'\n          });\n        }\n\n        data.currentView = this.graph.renderer.findViewByElem(target);\n\n        if (data.currentView) {\n          var _this$graph$hook;\n\n          // If we found a view that is under the pointer, we need to find\n          // the closest magnet based on the real target element of the event.\n          data.currentMagnet = data.currentView.findMagnet(target);\n\n          if (data.currentMagnet && (_this$graph$hook = this.graph.hook).validateConnection.apply(_this$graph$hook, _toConsumableArray(data.getValidateConnectionArgs(data.currentView, data.currentMagnet)).concat([data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType)]))) {\n            data.currentView.highlight(data.currentMagnet, {\n              type: 'magnetAdsorbed'\n            });\n          } else {\n            // This type of connection is not valid. Disregard this magnet.\n            data.currentMagnet = null;\n          }\n        } else {\n          // Make sure we'll unset previous magnet.\n          data.currentMagnet = null;\n        }\n      }\n\n      data.currentTarget = target;\n      this.cell.prop(data.terminalType, {\n        x: x,\n        y: y\n      }, Object.assign(Object.assign({}, data.options), {\n        ui: true\n      }));\n    }\n  }, {\n    key: \"arrowheadDragged\",\n    value: function arrowheadDragged(data, x, y) {\n      var view = data.currentView;\n      var magnet = data.currentMagnet;\n\n      if (!magnet || !view) {\n        return;\n      }\n\n      view.unhighlight(magnet, {\n        type: 'magnetAdsorbed'\n      });\n      var type = data.terminalType;\n      var terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);\n      this.cell.setTerminal(type, terminal, {\n        ui: true\n      });\n    }\n  }, {\n    key: \"snapArrowhead\",\n    value: function snapArrowhead(x, y, data) {\n      var _this4 = this;\n\n      var graph = this.graph;\n      var snap = graph.options.connecting.snap;\n      var radius = typeof snap === 'object' && snap.radius || 50;\n      var views = graph.renderer.findViewsInArea({\n        x: x - radius,\n        y: y - radius,\n        width: 2 * radius,\n        height: 2 * radius\n      });\n      var prevView = data.closestView || null;\n      var prevMagnet = data.closestMagnet || null;\n      data.closestView = null;\n      data.closestMagnet = null;\n      var distance;\n      var minDistance = Number.MAX_SAFE_INTEGER;\n      var pos = new Point(x, y);\n      views.forEach(function (view) {\n        if (view.container.getAttribute('magnet') !== 'false') {\n          // Find distance from the center of the cell to pointer coordinates\n          distance = view.cell.getBBox().getCenter().distance(pos); // the connection is looked up in a circle area by `distance < r`\n\n          if (distance < radius && distance < minDistance) {\n            var _graph$hook;\n\n            if (prevMagnet === view.container || (_graph$hook = graph.hook).validateConnection.apply(_graph$hook, _toConsumableArray(data.getValidateConnectionArgs(view, null)).concat([view.getEdgeTerminal(view.container, x, y, _this4.cell, data.terminalType)]))) {\n              minDistance = distance;\n              data.closestView = view;\n              data.closestMagnet = view.container;\n            }\n          }\n        }\n\n        view.container.querySelectorAll('[magnet]').forEach(function (magnet) {\n          if (magnet.getAttribute('magnet') !== 'false') {\n            var bbox = view.getBBoxOfElement(magnet);\n            distance = pos.distance(bbox.getCenter());\n\n            if (distance < radius && distance < minDistance) {\n              var _graph$hook2;\n\n              if (prevMagnet === magnet || (_graph$hook2 = graph.hook).validateConnection.apply(_graph$hook2, _toConsumableArray(data.getValidateConnectionArgs(view, magnet)).concat([view.getEdgeTerminal(magnet, x, y, _this4.cell, data.terminalType)]))) {\n                minDistance = distance;\n                data.closestView = view;\n                data.closestMagnet = magnet;\n              }\n            }\n          }\n        });\n      });\n      var terminal;\n      var type = data.terminalType;\n      var closestView = data.closestView;\n      var closestMagnet = data.closestMagnet;\n      var changed = prevMagnet !== closestMagnet;\n\n      if (prevView && changed) {\n        prevView.unhighlight(prevMagnet, {\n          type: 'magnetAdsorbed'\n        });\n      }\n\n      if (closestView) {\n        if (!changed) {\n          return;\n        }\n\n        closestView.highlight(closestMagnet, {\n          type: 'magnetAdsorbed'\n        });\n        terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);\n      } else {\n        terminal = {\n          x: x,\n          y: y\n        };\n      }\n\n      this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), {\n        ui: true\n      }));\n    }\n  }, {\n    key: \"snapArrowheadEnd\",\n    value: function snapArrowheadEnd(data) {\n      // Finish off link snapping.\n      // Everything except view unhighlighting was already done on pointermove.\n      var closestView = data.closestView;\n      var closestMagnet = data.closestMagnet;\n\n      if (closestView && closestMagnet) {\n        closestView.unhighlight(closestMagnet, {\n          type: 'magnetAdsorbed'\n        });\n        data.currentMagnet = closestView.findMagnet(closestMagnet);\n      }\n\n      data.closestView = null;\n      data.closestMagnet = null;\n    }\n  }, {\n    key: \"finishEmbedding\",\n    value: function finishEmbedding(data) {\n      // Resets parent of the edge if embedding is enabled\n      if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n        // Make sure we don't reverse to the original 'z' index\n        data.zIndex = null;\n      }\n    }\n  }, {\n    key: \"fallbackConnection\",\n    value: function fallbackConnection(data) {\n      switch (data.fallbackAction) {\n        case 'remove':\n          this.cell.remove({\n            ui: true\n          });\n          break;\n\n        case 'revert':\n        default:\n          this.cell.prop(data.terminalType, data.initialTerminal, {\n            ui: true\n          });\n          break;\n      }\n    }\n  }, {\n    key: \"notifyConnectionEvent\",\n    value: function notifyConnectionEvent(data, e) {\n      var terminalType = data.terminalType;\n      var initialTerminal = data.initialTerminal;\n      var currentTerminal = this.cell[terminalType];\n      var changed = currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal);\n\n      if (changed) {\n        var graph = this.graph;\n        var previous = initialTerminal;\n        var previousCell = previous.cell ? graph.getCellById(previous.cell) : null;\n        var previousPort = previous.port;\n        var previousView = previousCell ? graph.findViewByCell(previousCell) : null;\n        var previousPoint = previousCell || data.isNewEdge ? null : Point.create(initialTerminal).toJSON();\n        var current = currentTerminal;\n        var currentCell = current.cell ? graph.getCellById(current.cell) : null;\n        var currentPort = current.port;\n        var currentView = currentCell ? graph.findViewByCell(currentCell) : null;\n        var currentPoint = currentCell ? null : Point.create(currentTerminal).toJSON();\n        this.notify('edge:connected', {\n          e: e,\n          previousCell: previousCell,\n          previousPort: previousPort,\n          previousView: previousView,\n          previousPoint: previousPoint,\n          currentCell: currentCell,\n          currentView: currentView,\n          currentPort: currentPort,\n          currentPoint: currentPoint,\n          previousMagnet: data.initialMagnet,\n          currentMagnet: data.currentMagnet,\n          edge: this.cell,\n          view: this,\n          type: terminalType,\n          isNew: data.isNewEdge\n        });\n      }\n    }\n  }, {\n    key: \"highlightAvailableMagnets\",\n    value: function highlightAvailableMagnets(data) {\n      var _this5 = this;\n\n      var graph = this.graph;\n      var cells = graph.model.getCells();\n      data.marked = {};\n\n      var _loop = function _loop(i, ii) {\n        var view = graph.renderer.findViewByCell(cells[i]);\n\n        if (!view) {\n          return \"continue\";\n        }\n\n        var magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));\n\n        if (view.container.getAttribute('magnet') !== 'false') {\n          magnets.push(view.container);\n        }\n\n        var availableMagnets = magnets.filter(function (magnet) {\n          var _graph$hook3;\n\n          return (_graph$hook3 = graph.hook).validateConnection.apply(_graph$hook3, _toConsumableArray(data.getValidateConnectionArgs(view, magnet)).concat([view.getEdgeTerminal(magnet, data.x, data.y, _this5.cell, data.terminalType)]));\n        });\n\n        if (availableMagnets.length > 0) {\n          // highlight all available magnets\n          for (var j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n            view.highlight(availableMagnets[j], {\n              type: 'magnetAvailable'\n            });\n          } // highlight the entire view\n\n\n          view.highlight(null, {\n            type: 'nodeAvailable'\n          });\n          data.marked[view.cell.id] = availableMagnets;\n        }\n      };\n\n      for (var i = 0, ii = cells.length; i < ii; i += 1) {\n        var _ret = _loop(i, ii);\n\n        if (_ret === \"continue\") continue;\n      }\n    }\n  }, {\n    key: \"unhighlightAvailableMagnets\",\n    value: function unhighlightAvailableMagnets(data) {\n      var _this6 = this;\n\n      var marked = data.marked || {};\n      Object.keys(marked).forEach(function (id) {\n        var view = _this6.graph.renderer.findViewByCell(id);\n\n        if (view) {\n          var magnets = marked[id];\n          magnets.forEach(function (magnet) {\n            view.unhighlight(magnet, {\n              type: 'magnetAvailable'\n            });\n          });\n          view.unhighlight(null, {\n            type: 'nodeAvailable'\n          });\n        }\n      });\n      data.marked = null;\n    }\n  }, {\n    key: \"startArrowheadDragging\",\n    value: function startArrowheadDragging(e, x, y) {\n      if (!this.can('arrowheadMovable')) {\n        this.notifyUnhandledMouseDown(e, x, y);\n        return;\n      }\n\n      var elem = e.target;\n      var type = elem.getAttribute('data-terminal');\n      var data = this.prepareArrowheadDragging(type, {\n        x: x,\n        y: y\n      });\n      this.setEventData(e, data);\n    }\n  }, {\n    key: \"dragArrowhead\",\n    value: function dragArrowhead(e, x, y) {\n      var data = this.getEventData(e);\n\n      if (this.graph.options.connecting.snap) {\n        this.snapArrowhead(x, y, data);\n      } else {\n        this.arrowheadDragging(this.getEventTarget(e), x, y, data);\n      }\n    }\n  }, {\n    key: \"stopArrowheadDragging\",\n    value: function stopArrowheadDragging(e, x, y) {\n      var graph = this.graph;\n      var data = this.getEventData(e);\n\n      if (graph.options.connecting.snap) {\n        this.snapArrowheadEnd(data);\n      } else {\n        this.arrowheadDragged(data, x, y);\n      }\n\n      var valid = graph.hook.validateEdge(this.cell, data.terminalType, data.initialTerminal);\n\n      if (valid) {\n        this.finishEmbedding(data);\n        this.notifyConnectionEvent(data, e);\n      } else {\n        // If the changed edge is not allowed, revert to its previous state.\n        this.fallbackConnection(data);\n      }\n\n      this.afterArrowheadDragging(data);\n    } // #endregion\n    // #region drag lable\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"startLabelDragging\",\n    value: function startLabelDragging(e, x, y) {\n      if (this.can('edgeLabelMovable')) {\n        var target = e.currentTarget;\n        var index = parseInt(target.getAttribute('data-index'), 10);\n        var positionAngle = this.getLabelPositionAngle(index);\n        var labelPositionArgs = this.getLabelPositionArgs(index);\n        var defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n        var positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n        this.setEventData(e, {\n          index: index,\n          positionAngle: positionAngle,\n          positionArgs: positionArgs,\n          stopPropagation: true,\n          action: 'drag-label'\n        });\n      } else {\n        // If labels can't be dragged no default action is triggered.\n        this.setEventData(e, {\n          stopPropagation: true\n        });\n      }\n\n      this.graph.view.delegateDragEvents(e, this);\n    }\n  }, {\n    key: \"dragLabel\",\n    value: function dragLabel(e, x, y) {\n      var data = this.getEventData(e);\n      var originLabel = this.cell.getLabelAt(data.index);\n      var label = ObjectExt.merge({}, originLabel, {\n        position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs)\n      });\n      this.cell.setLabelAt(data.index, label);\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"stopLabelDragging\",\n    value: function stopLabelDragging(e, x, y) {} // #endregion\n    // #region drag vertex\n\n  }, {\n    key: \"handleVertexAdding\",\n    value: function handleVertexAdding(e, x, y) {\n      if (!this.can('vertexAddable')) {\n        this.notifyUnhandledMouseDown(e, x, y);\n        return;\n      } // Store the index at which the new vertex has just been placed.\n      // We'll be update the very same vertex position in `pointermove()`.\n\n\n      var index = this.addVertex({\n        x: x,\n        y: y\n      }, {\n        ui: true\n      });\n      this.setEventData(e, {\n        index: index,\n        action: 'drag-vertex'\n      });\n    }\n  }, {\n    key: \"handleVertexRemoving\",\n    value: function handleVertexRemoving(e, x, y) {\n      if (!this.can('vertexDeletable')) {\n        this.notifyUnhandledMouseDown(e, x, y);\n        return;\n      }\n\n      var target = e.target;\n      var index = parseInt(target.getAttribute('idx'), 10);\n      this.cell.removeVertexAt(index);\n    }\n  }, {\n    key: \"startVertexDragging\",\n    value: function startVertexDragging(e, x, y) {\n      if (!this.can('vertexMovable')) {\n        this.notifyUnhandledMouseDown(e, x, y);\n        return;\n      }\n\n      var target = e.target;\n      var index = parseInt(target.getAttribute('idx'), 10);\n      this.setEventData(e, {\n        index: index,\n        action: 'drag-vertex'\n      });\n    }\n  }, {\n    key: \"dragVertex\",\n    value: function dragVertex(e, x, y) {\n      var data = this.getEventData(e);\n      this.cell.setVertexAt(data.index, {\n        x: x,\n        y: y\n      }, {\n        ui: true\n      });\n    } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n  }, {\n    key: \"stopVertexDragging\",\n    value: function stopVertexDragging(e, x, y) {}\n  }]);\n\n  return EdgeView;\n}(CellView, Symbol.toStringTag);\n\n(function (EdgeView) {\n  EdgeView.toStringTag = \"X6.\".concat(EdgeView.name);\n\n  function isEdgeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof EdgeView) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var view = instance;\n\n    if ((tag == null || tag === EdgeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.getConnection === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  EdgeView.isEdgeView = isEdgeView;\n})(EdgeView || (EdgeView = {}));\n\nEdgeView.config({\n  isSvgElement: true,\n  priority: 1,\n  bootstrap: ['render', 'source', 'target'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    source: ['source', 'update'],\n    target: ['target', 'update'],\n    router: ['update'],\n    connector: ['update'],\n    labels: ['labels'],\n    defaultLabel: ['labels'],\n    vertices: ['vertices', 'update'],\n    vertexMarkup: ['vertices'],\n    toolMarkup: ['tools'],\n    tools: ['widget']\n  },\n  shortLength: 105,\n  longLength: 155,\n  toolsOffset: 40,\n  doubleTools: false,\n  doubleToolsOffset: 65,\n  sampleInterval: 50\n});\nEdgeView.registry.register('edge', EdgeView, true);","map":{"version":3,"sources":["../../src/view/edge.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { Rectangle, Polyline, Point, Angle, Path, Line } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt, FunctionExt, Dom, Vector, } from '../util';\nimport { Router, Connector, NodeAnchor, EdgeAnchor, ConnectionPoint, } from '../registry';\nimport { Edge } from '../model/edge';\nimport { Markup } from './markup';\nimport { CellView } from './cell';\nexport class EdgeView extends CellView {\n    constructor() {\n        super(...arguments);\n        this.POINT_ROUNDING = 2;\n        this.markerCache = {};\n        // #endregion\n        // #endregion\n    }\n    get [Symbol.toStringTag]() {\n        return EdgeView.toStringTag;\n    }\n    getContainerClassName() {\n        return [super.getContainerClassName(), this.prefixClassName('edge')].join(' ');\n    }\n    get sourceBBox() {\n        const sourceView = this.sourceView;\n        if (!sourceView) {\n            const sourceDef = this.cell.getSource();\n            return new Rectangle(sourceDef.x, sourceDef.y);\n        }\n        const sourceMagnet = this.sourceMagnet;\n        if (sourceView.isEdgeElement(sourceMagnet)) {\n            return new Rectangle(this.sourceAnchor.x, this.sourceAnchor.y);\n        }\n        return sourceView.getBBoxOfElement(sourceMagnet || sourceView.container);\n    }\n    get targetBBox() {\n        const targetView = this.targetView;\n        if (!targetView) {\n            const targetDef = this.cell.getTarget();\n            return new Rectangle(targetDef.x, targetDef.y);\n        }\n        const targetMagnet = this.targetMagnet;\n        if (targetView.isEdgeElement(targetMagnet)) {\n            return new Rectangle(this.targetAnchor.x, this.targetAnchor.y);\n        }\n        return targetView.getBBoxOfElement(targetMagnet || targetView.container);\n    }\n    isEdgeView() {\n        return true;\n    }\n    confirmUpdate(flag, options = {}) {\n        let ref = flag;\n        if (this.hasAction(ref, 'source')) {\n            if (!this.updateTerminalProperties('source')) {\n                return ref;\n            }\n            ref = this.removeAction(ref, 'source');\n        }\n        if (this.hasAction(ref, 'target')) {\n            if (!this.updateTerminalProperties('target')) {\n                return ref;\n            }\n            ref = this.removeAction(ref, 'target');\n        }\n        const graph = this.graph;\n        const sourceView = this.sourceView;\n        const targetView = this.targetView;\n        if (graph &&\n            ((sourceView && !graph.renderer.isViewMounted(sourceView)) ||\n                (targetView && !graph.renderer.isViewMounted(targetView)))) {\n            // Wait for the sourceView and targetView to be rendered.\n            return ref;\n        }\n        if (this.hasAction(ref, 'render')) {\n            this.render();\n            ref = this.removeAction(ref, [\n                'render',\n                'update',\n                'vertices',\n                'labels',\n                'tools',\n                'widget',\n            ]);\n            return ref;\n        }\n        ref = this.handleAction(ref, 'vertices', () => this.renderVertexMarkers());\n        ref = this.handleAction(ref, 'update', () => this.update(null, options));\n        ref = this.handleAction(ref, 'labels', () => this.onLabelsChange(options));\n        ref = this.handleAction(ref, 'tools', () => {\n            this.renderTools();\n            this.updateToolsPosition();\n        });\n        ref = this.handleAction(ref, 'widget', () => this.renderExternalTools());\n        return ref;\n    }\n    onLabelsChange(options = {}) {\n        // Note: this optimization works in async=false mode only\n        if (this.shouldRerenderLabels(options)) {\n            this.renderLabels();\n        }\n        else {\n            this.updateLabels();\n        }\n        this.updateLabelPositions();\n    }\n    shouldRerenderLabels(options = {}) {\n        const previousLabels = this.cell.previous('labels');\n        if (previousLabels == null) {\n            return true;\n        }\n        // Here is an optimization for cases when we know, that change does\n        // not require re-rendering of all labels.\n        if ('propertyPathArray' in options && 'propertyValue' in options) {\n            // The label is setting by `prop()` method\n            const pathArray = options.propertyPathArray || [];\n            const pathLength = pathArray.length;\n            if (pathLength > 1) {\n                // We are changing a single label here e.g. 'labels/0/position'\n                const index = pathArray[1];\n                if (previousLabels[index]) {\n                    if (pathLength === 2) {\n                        // We are changing the entire label. Need to check if the\n                        // markup is also being changed.\n                        return (typeof options.propertyValue === 'object' &&\n                            ObjectExt.has(options.propertyValue, 'markup'));\n                    }\n                    // We are changing a label property but not the markup\n                    if (pathArray[2] !== 'markup') {\n                        return false;\n                    }\n                }\n            }\n        }\n        return true;\n    }\n    render() {\n        this.empty();\n        this.containers = {};\n        this.renderMarkup();\n        this.renderLabels();\n        this.update();\n        return this;\n    }\n    renderMarkup() {\n        const markup = this.cell.markup;\n        if (markup) {\n            if (typeof markup === 'string') {\n                return this.renderStringMarkup(markup);\n            }\n            return this.renderJSONMarkup(markup);\n        }\n        throw new TypeError('Invalid edge markup.');\n    }\n    renderJSONMarkup(markup) {\n        const ret = this.parseJSONMarkup(markup, this.container);\n        this.selectors = ret.selectors;\n        this.container.append(ret.fragment);\n    }\n    renderStringMarkup(markup) {\n        const cache = this.containers;\n        const children = Vector.createVectors(markup);\n        // Cache children elements for quicker access.\n        children.forEach((child) => {\n            const className = child.attr('class');\n            if (className) {\n                cache[StringExt.camelCase(className)] =\n                    child.node;\n            }\n        });\n        this.renderTools();\n        this.renderVertexMarkers();\n        this.renderArrowheadMarkers();\n        Dom.append(this.container, children.map((child) => child.node));\n    }\n    renderLabels() {\n        const edge = this.cell;\n        const labels = edge.getLabels();\n        const count = labels.length;\n        let container = this.containers.labels;\n        this.labelCache = {};\n        this.labelSelectors = {};\n        if (count <= 0) {\n            if (container && container.parentNode) {\n                container.parentNode.removeChild(container);\n            }\n            return this;\n        }\n        if (container) {\n            this.empty(container);\n        }\n        else {\n            container = Dom.createSvgElement('g');\n            this.addClass(this.prefixClassName('edge-labels'), container);\n            this.containers.labels = container;\n        }\n        for (let i = 0, ii = labels.length; i < ii; i += 1) {\n            const label = labels[i];\n            const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(label.markup));\n            let labelNode;\n            let selectors;\n            if (normalized) {\n                labelNode = normalized.node;\n                selectors = normalized.selectors;\n            }\n            else {\n                const defaultLabel = edge.getDefaultLabel();\n                const normalized = this.normalizeLabelMarkup(this.parseLabelMarkup(defaultLabel.markup));\n                labelNode = normalized.node;\n                selectors = normalized.selectors;\n            }\n            labelNode.setAttribute('data-index', `${i}`);\n            container.appendChild(labelNode);\n            const rootSelector = this.rootSelector;\n            if (selectors[rootSelector]) {\n                throw new Error('Ambiguous label root selector.');\n            }\n            selectors[rootSelector] = labelNode;\n            this.labelCache[i] = labelNode;\n            this.labelSelectors[i] = selectors;\n        }\n        if (container.parentNode == null) {\n            this.container.appendChild(container);\n        }\n        this.updateLabels();\n        this.customizeLabels();\n        return this;\n    }\n    parseLabelMarkup(markup) {\n        if (markup) {\n            if (typeof markup === 'string') {\n                return this.parseLabelStringMarkup(markup);\n            }\n            return this.parseJSONMarkup(markup);\n        }\n        return null;\n    }\n    parseLabelStringMarkup(labelMarkup) {\n        const children = Vector.createVectors(labelMarkup);\n        const fragment = document.createDocumentFragment();\n        for (let i = 0, n = children.length; i < n; i += 1) {\n            const currentChild = children[i].node;\n            fragment.appendChild(currentChild);\n        }\n        return { fragment, selectors: {} };\n    }\n    normalizeLabelMarkup(markup) {\n        if (markup == null) {\n            return;\n        }\n        const fragment = markup.fragment;\n        if (!(fragment instanceof DocumentFragment) || !fragment.hasChildNodes()) {\n            throw new Error('Invalid label markup.');\n        }\n        let vel;\n        const childNodes = fragment.childNodes;\n        if (childNodes.length > 1 || childNodes[0].nodeName.toUpperCase() !== 'G') {\n            // default markup fragment is not wrapped in `<g/>`\n            // add a `<g/>` container\n            vel = Vector.create('g').append(fragment);\n        }\n        else {\n            vel = Vector.create(childNodes[0]);\n        }\n        vel.addClass(this.prefixClassName('edge-label'));\n        return {\n            node: vel.node,\n            selectors: markup.selectors,\n        };\n    }\n    updateLabels() {\n        if (this.containers.labels) {\n            const edge = this.cell;\n            const labels = edge.labels;\n            const canLabelMove = this.can('edgeLabelMovable');\n            const defaultLabel = edge.getDefaultLabel();\n            for (let i = 0, n = labels.length; i < n; i += 1) {\n                const elem = this.labelCache[i];\n                const selectors = this.labelSelectors[i];\n                elem.setAttribute('cursor', canLabelMove ? 'move' : 'default');\n                const label = labels[i];\n                const attrs = ObjectExt.merge({}, defaultLabel.attrs, label.attrs);\n                this.updateAttrs(elem, attrs, {\n                    selectors,\n                    rootBBox: label.size ? Rectangle.fromSize(label.size) : undefined,\n                });\n            }\n        }\n    }\n    mergeLabelAttrs(hasCustomMarkup, labelAttrs, defaultLabelAttrs) {\n        if (labelAttrs === null) {\n            return null;\n        }\n        if (labelAttrs === undefined) {\n            if (defaultLabelAttrs === null) {\n                return null;\n            }\n            if (defaultLabelAttrs === undefined) {\n                return undefined;\n            }\n            if (hasCustomMarkup) {\n                return defaultLabelAttrs;\n            }\n            return ObjectExt.merge({}, defaultLabelAttrs);\n        }\n        if (hasCustomMarkup) {\n            return ObjectExt.merge({}, defaultLabelAttrs, labelAttrs);\n        }\n    }\n    customizeLabels() {\n        if (this.containers.labels) {\n            const edge = this.cell;\n            const labels = edge.labels;\n            for (let i = 0, n = labels.length; i < n; i += 1) {\n                const label = labels[i];\n                const container = this.labelCache[i];\n                const selectors = this.labelSelectors[i];\n                this.graph.hook.onEdgeLabelRendered({\n                    edge,\n                    label,\n                    container,\n                    selectors,\n                });\n            }\n        }\n    }\n    renderTools() {\n        const container = this.containers.tools;\n        if (container == null) {\n            return this;\n        }\n        const markup = this.cell.toolMarkup;\n        const $container = this.$(container).empty();\n        if (Markup.isStringMarkup(markup)) {\n            let template = StringExt.template(markup);\n            const tool = Vector.create(template());\n            $container.append(tool.node);\n            this.toolCache = tool.node;\n            // If `doubleTools` is enabled, we render copy of the tools on the\n            // other side of the edge as well but only if the edge is longer\n            // than `longLength`.\n            if (this.options.doubleTools) {\n                let tool2;\n                const doubleToolMarkup = this.cell.doubleToolMarkup;\n                if (Markup.isStringMarkup(doubleToolMarkup)) {\n                    template = StringExt.template(doubleToolMarkup);\n                    tool2 = Vector.create(template());\n                }\n                else {\n                    tool2 = tool.clone();\n                }\n                $container.append(tool2.node);\n                this.tool2Cache = tool2.node;\n            }\n        }\n        return this;\n    }\n    renderExternalTools() {\n        const tools = this.cell.getTools();\n        this.addTools(tools);\n        return this;\n    }\n    renderVertexMarkers() {\n        const container = this.containers.vertices;\n        if (container == null) {\n            return this;\n        }\n        const markup = this.cell.vertexMarkup;\n        const $container = this.$(container).empty();\n        if (Markup.isStringMarkup(markup)) {\n            const template = StringExt.template(markup);\n            this.cell.getVertices().forEach((vertex, index) => {\n                $container.append(Vector.create(template(Object.assign({ index }, vertex))).node);\n            });\n        }\n        return this;\n    }\n    renderArrowheadMarkers() {\n        const container = this.containers.arrowheads;\n        if (container == null) {\n            return this;\n        }\n        const markup = this.cell.arrowheadMarkup;\n        const $container = this.$(container).empty();\n        if (Markup.isStringMarkup(markup)) {\n            const template = StringExt.template(markup);\n            const sourceArrowhead = Vector.create(template({ end: 'source' })).node;\n            const targetArrowhead = Vector.create(template({ end: 'target' })).node;\n            this.containers.sourceArrowhead = sourceArrowhead;\n            this.containers.targetArrowhead = targetArrowhead;\n            $container.append(sourceArrowhead, targetArrowhead);\n        }\n        return this;\n    }\n    // #endregion\n    // #region updating\n    update(partialAttrs, options = {}) {\n        this.cleanCache();\n        this.updateConnection(options);\n        const attrs = this.cell.getAttrs();\n        if (attrs != null) {\n            this.updateAttrs(this.container, attrs, {\n                attrs: partialAttrs === attrs ? null : partialAttrs,\n                selectors: this.selectors,\n            });\n        }\n        this.updateConnectionPath();\n        this.updateLabelPositions();\n        this.updateToolsPosition();\n        this.updateArrowheadMarkers();\n        if (options.toolId == null) {\n            this.renderExternalTools();\n        }\n        else {\n            this.updateTools(options);\n        }\n        return this;\n    }\n    removeRedundantLinearVertices(options = {}) {\n        const edge = this.cell;\n        const vertices = edge.getVertices();\n        const routePoints = [this.sourceAnchor, ...vertices, this.targetAnchor];\n        const rawCount = routePoints.length;\n        // Puts the route points into a polyline and try to simplify.\n        const polyline = new Polyline(routePoints);\n        polyline.simplify({ threshold: 0.01 });\n        const simplifiedPoints = polyline.points.map((point) => point.toJSON());\n        const simplifiedCount = simplifiedPoints.length;\n        // If simplification did not remove any redundant vertices.\n        if (rawCount === simplifiedCount) {\n            return 0;\n        }\n        // Sets simplified polyline points as edge vertices.\n        // Removes first and last polyline points again (source/target anchors).\n        edge.setVertices(simplifiedPoints.slice(1, simplifiedCount - 1), options);\n        return rawCount - simplifiedCount;\n    }\n    updateConnectionPath() {\n        const containers = this.containers;\n        if (containers.connection) {\n            const pathData = this.getConnectionPathData();\n            containers.connection.setAttribute('d', pathData);\n        }\n        if (containers.connectionWrap) {\n            const pathData = this.getConnectionPathData();\n            containers.connectionWrap.setAttribute('d', pathData);\n        }\n        if (containers.sourceMarker && containers.targetMarker) {\n            this.translateAndAutoOrientArrows(containers.sourceMarker, containers.targetMarker);\n        }\n    }\n    getTerminalView(type) {\n        switch (type) {\n            case 'source':\n                return this.sourceView || null;\n            case 'target':\n                return this.targetView || null;\n            default:\n                throw new Error(`Unknown terminal type '${type}'`);\n        }\n    }\n    getTerminalAnchor(type) {\n        switch (type) {\n            case 'source':\n                return Point.create(this.sourceAnchor);\n            case 'target':\n                return Point.create(this.targetAnchor);\n            default:\n                throw new Error(`Unknown terminal type '${type}'`);\n        }\n    }\n    getTerminalConnectionPoint(type) {\n        switch (type) {\n            case 'source':\n                return Point.create(this.sourcePoint);\n            case 'target':\n                return Point.create(this.targetPoint);\n            default:\n                throw new Error(`Unknown terminal type '${type}'`);\n        }\n    }\n    getTerminalMagnet(type, options = {}) {\n        switch (type) {\n            case 'source': {\n                if (options.raw) {\n                    return this.sourceMagnet;\n                }\n                const sourceView = this.sourceView;\n                if (!sourceView) {\n                    return null;\n                }\n                return this.sourceMagnet || sourceView.container;\n            }\n            case 'target': {\n                if (options.raw) {\n                    return this.targetMagnet;\n                }\n                const targetView = this.targetView;\n                if (!targetView) {\n                    return null;\n                }\n                return this.targetMagnet || targetView.container;\n            }\n            default: {\n                throw new Error(`Unknown terminal type '${type}'`);\n            }\n        }\n    }\n    updateConnection(options = {}) {\n        const edge = this.cell;\n        // The edge is being translated by an ancestor that will shift\n        // source, target and vertices by an equal distance.\n        if (options.translateBy &&\n            edge.isFragmentDescendantOf(options.translateBy)) {\n            const tx = options.tx || 0;\n            const ty = options.ty || 0;\n            this.routePoints = new Polyline(this.routePoints).translate(tx, ty).points;\n            this.translateConnectionPoints(tx, ty);\n            this.path.translate(tx, ty);\n        }\n        else {\n            const vertices = edge.getVertices();\n            // 1. Find anchor points\n            const anchors = this.findAnchors(vertices);\n            this.sourceAnchor = anchors.source;\n            this.targetAnchor = anchors.target;\n            // 2. Find route points\n            this.routePoints = this.findRoutePoints(vertices);\n            // 3. Find connection points\n            const connectionPoints = this.findConnectionPoints(this.routePoints, this.sourceAnchor, this.targetAnchor);\n            this.sourcePoint = connectionPoints.source;\n            this.targetPoint = connectionPoints.target;\n            // 4. Find Marker Connection Point\n            const markerPoints = this.findMarkerPoints(this.routePoints, this.sourcePoint, this.targetPoint);\n            // 5. Make path\n            this.path = this.findPath(this.routePoints, markerPoints.source || this.sourcePoint, markerPoints.target || this.targetPoint);\n        }\n        this.cleanCache();\n    }\n    findAnchors(vertices) {\n        const edge = this.cell;\n        const source = edge.source;\n        const target = edge.target;\n        const firstVertex = vertices[0];\n        const lastVertex = vertices[vertices.length - 1];\n        if (target.priority && !source.priority) {\n            // Reversed order\n            return this.findAnchorsOrdered('target', lastVertex, 'source', firstVertex);\n        }\n        // Usual order\n        return this.findAnchorsOrdered('source', firstVertex, 'target', lastVertex);\n    }\n    findAnchorsOrdered(firstType, firstPoint, secondType, secondPoint) {\n        let firstAnchor;\n        let secondAnchor;\n        const edge = this.cell;\n        const firstTerminal = edge[firstType];\n        const secondTerminal = edge[secondType];\n        const firstView = this.getTerminalView(firstType);\n        const secondView = this.getTerminalView(secondType);\n        const firstMagnet = this.getTerminalMagnet(firstType);\n        const secondMagnet = this.getTerminalMagnet(secondType);\n        if (firstView) {\n            let firstRef;\n            if (firstPoint) {\n                firstRef = Point.create(firstPoint);\n            }\n            else if (secondView) {\n                firstRef = secondMagnet;\n            }\n            else {\n                firstRef = Point.create(secondTerminal);\n            }\n            firstAnchor = this.getAnchor(firstTerminal.anchor, firstView, firstMagnet, firstRef, firstType);\n        }\n        else {\n            firstAnchor = Point.create(firstTerminal);\n        }\n        if (secondView) {\n            const secondRef = Point.create(secondPoint || firstAnchor);\n            secondAnchor = this.getAnchor(secondTerminal.anchor, secondView, secondMagnet, secondRef, secondType);\n        }\n        else {\n            secondAnchor = Point.isPointLike(secondTerminal)\n                ? Point.create(secondTerminal)\n                : new Point();\n        }\n        return {\n            [firstType]: firstAnchor,\n            [secondType]: secondAnchor,\n        };\n    }\n    getAnchor(def, cellView, magnet, ref, terminalType) {\n        const isEdge = cellView.isEdgeElement(magnet);\n        const connecting = this.graph.options.connecting;\n        let config = typeof def === 'string' ? { name: def } : def;\n        if (!config) {\n            const defaults = isEdge\n                ? (terminalType === 'source'\n                    ? connecting.sourceEdgeAnchor\n                    : connecting.targetEdgeAnchor) || connecting.edgeAnchor\n                : (terminalType === 'source'\n                    ? connecting.sourceAnchor\n                    : connecting.targetAnchor) || connecting.anchor;\n            config = typeof defaults === 'string' ? { name: defaults } : defaults;\n        }\n        if (!config) {\n            throw new Error(`Anchor should be specified.`);\n        }\n        let anchor;\n        const name = config.name;\n        if (isEdge) {\n            const fn = EdgeAnchor.registry.get(name);\n            if (typeof fn !== 'function') {\n                return EdgeAnchor.registry.onNotFound(name);\n            }\n            anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n        }\n        else {\n            const fn = NodeAnchor.registry.get(name);\n            if (typeof fn !== 'function') {\n                return NodeAnchor.registry.onNotFound(name);\n            }\n            anchor = FunctionExt.call(fn, this, cellView, magnet, ref, config.args || {}, terminalType);\n        }\n        return anchor ? anchor.round(this.POINT_ROUNDING) : new Point();\n    }\n    findRoutePoints(vertices = []) {\n        const defaultRouter = this.graph.options.connecting.router || Router.presets.normal;\n        const router = this.cell.getRouter() || defaultRouter;\n        let routePoints;\n        if (typeof router === 'function') {\n            routePoints = FunctionExt.call(router, this, vertices, {}, this);\n        }\n        else {\n            const name = typeof router === 'string' ? router : router.name;\n            const args = typeof router === 'string' ? {} : router.args || {};\n            const fn = name ? Router.registry.get(name) : Router.presets.normal;\n            if (typeof fn !== 'function') {\n                return Router.registry.onNotFound(name);\n            }\n            routePoints = FunctionExt.call(fn, this, vertices, args, this);\n        }\n        return routePoints == null\n            ? vertices.map((p) => Point.create(p))\n            : routePoints.map((p) => Point.create(p));\n    }\n    findConnectionPoints(routePoints, sourceAnchor, targetAnchor) {\n        const edge = this.cell;\n        const connecting = this.graph.options.connecting;\n        const sourceTerminal = edge.getSource();\n        const targetTerminal = edge.getTarget();\n        const sourceView = this.sourceView;\n        const targetView = this.targetView;\n        const firstRoutePoint = routePoints[0];\n        const lastRoutePoint = routePoints[routePoints.length - 1];\n        // source\n        let sourcePoint;\n        if (sourceView && !sourceView.isEdgeElement(this.sourceMagnet)) {\n            const sourceMagnet = this.sourceMagnet || sourceView.container;\n            const sourcePointRef = firstRoutePoint || targetAnchor;\n            const sourceLine = new Line(sourcePointRef, sourceAnchor);\n            const connectionPointDef = sourceTerminal.connectionPoint ||\n                connecting.sourceConnectionPoint ||\n                connecting.connectionPoint;\n            sourcePoint = this.getConnectionPoint(connectionPointDef, sourceView, sourceMagnet, sourceLine, 'source');\n        }\n        else {\n            sourcePoint = sourceAnchor;\n        }\n        // target\n        let targetPoint;\n        if (targetView && !targetView.isEdgeElement(this.targetMagnet)) {\n            const targetMagnet = this.targetMagnet || targetView.container;\n            const targetConnectionPointDef = targetTerminal.connectionPoint ||\n                connecting.targetConnectionPoint ||\n                connecting.connectionPoint;\n            const targetPointRef = lastRoutePoint || sourceAnchor;\n            const targetLine = new Line(targetPointRef, targetAnchor);\n            targetPoint = this.getConnectionPoint(targetConnectionPointDef, targetView, targetMagnet, targetLine, 'target');\n        }\n        else {\n            targetPoint = targetAnchor;\n        }\n        return {\n            source: sourcePoint,\n            target: targetPoint,\n        };\n    }\n    getConnectionPoint(def, view, magnet, line, endType) {\n        const anchor = line.end;\n        if (def == null) {\n            return anchor;\n        }\n        const name = typeof def === 'string' ? def : def.name;\n        const args = typeof def === 'string' ? {} : def.args;\n        const fn = ConnectionPoint.registry.get(name);\n        if (typeof fn !== 'function') {\n            return ConnectionPoint.registry.onNotFound(name);\n        }\n        const connectionPoint = FunctionExt.call(fn, this, line, view, magnet, args || {}, endType);\n        return connectionPoint ? connectionPoint.round(this.POINT_ROUNDING) : anchor;\n    }\n    updateMarkerAttr(type) {\n        const attrs = this.cell.getAttrs();\n        const key = `.${type}-marker`;\n        const partial = attrs && attrs[key];\n        if (partial) {\n            this.updateAttrs(this.container, {}, {\n                attrs: { [key]: partial },\n                selectors: this.selectors,\n            });\n        }\n    }\n    findMarkerPoints(routePoints, sourcePoint, targetPoint) {\n        const getLineWidth = (type) => {\n            const attrs = this.cell.getAttrs();\n            const keys = Object.keys(attrs);\n            for (let i = 0, l = keys.length; i < l; i += 1) {\n                const attr = attrs[keys[i]];\n                if (attr[`${type}Marker`] || attr[`${type}-marker`]) {\n                    const strokeWidth = attr.strokeWidth || attr['stroke-width'];\n                    if (strokeWidth) {\n                        return parseFloat(strokeWidth);\n                    }\n                    break;\n                }\n            }\n            return null;\n        };\n        const firstRoutePoint = routePoints[0];\n        const lastRoutePoint = routePoints[routePoints.length - 1];\n        const sourceMarkerElem = this.containers.sourceMarker;\n        const targetMarkerElem = this.containers.targetMarker;\n        const cache = this.markerCache;\n        let sourceMarkerPoint;\n        let targetMarkerPoint;\n        // Move the source point by the width of the marker taking into\n        // account its scale around x-axis. Note that scale is the only\n        // transform that makes sense to be set in `.marker-source`\n        // attributes object as all other transforms (translate/rotate)\n        // will be replaced by the `translateAndAutoOrient()` function.\n        if (sourceMarkerElem) {\n            this.updateMarkerAttr('source');\n            // support marker connection point registry???\n            cache.sourceBBox = cache.sourceBBox || Dom.getBBox(sourceMarkerElem);\n            if (cache.sourceBBox.width > 0) {\n                const scale = Dom.scale(sourceMarkerElem);\n                sourceMarkerPoint = sourcePoint\n                    .clone()\n                    .move(firstRoutePoint || targetPoint, cache.sourceBBox.width * scale.sx * -1);\n            }\n        }\n        else {\n            const strokeWidth = getLineWidth('source');\n            if (strokeWidth) {\n                sourceMarkerPoint = sourcePoint\n                    .clone()\n                    .move(firstRoutePoint || targetPoint, -strokeWidth);\n            }\n        }\n        if (targetMarkerElem) {\n            this.updateMarkerAttr('target');\n            cache.targetBBox = cache.targetBBox || Dom.getBBox(targetMarkerElem);\n            if (cache.targetBBox.width > 0) {\n                const scale = Dom.scale(targetMarkerElem);\n                targetMarkerPoint = targetPoint\n                    .clone()\n                    .move(lastRoutePoint || sourcePoint, cache.targetBBox.width * scale.sx * -1);\n            }\n        }\n        else {\n            const strokeWidth = getLineWidth('target');\n            if (strokeWidth) {\n                targetMarkerPoint = targetPoint\n                    .clone()\n                    .move(lastRoutePoint || sourcePoint, -strokeWidth);\n            }\n        }\n        // If there was no markup for the marker, use the connection point.\n        cache.sourcePoint = sourceMarkerPoint || sourcePoint.clone();\n        cache.targetPoint = targetMarkerPoint || targetPoint.clone();\n        return {\n            source: sourceMarkerPoint,\n            target: targetMarkerPoint,\n        };\n    }\n    findPath(routePoints, sourcePoint, targetPoint) {\n        const def = this.cell.getConnector() || this.graph.options.connecting.connector;\n        let name;\n        let args;\n        let fn;\n        if (typeof def === 'string') {\n            name = def;\n        }\n        else {\n            name = def.name;\n            args = def.args;\n        }\n        if (name) {\n            const method = Connector.registry.get(name);\n            if (typeof method !== 'function') {\n                return Connector.registry.onNotFound(name);\n            }\n            fn = method;\n        }\n        else {\n            fn = Connector.presets.normal;\n        }\n        const path = FunctionExt.call(fn, this, sourcePoint, targetPoint, routePoints, Object.assign(Object.assign({}, args), { raw: true }), this);\n        return typeof path === 'string' ? Path.parse(path) : path;\n    }\n    translateConnectionPoints(tx, ty) {\n        const cache = this.markerCache;\n        if (cache.sourcePoint) {\n            cache.sourcePoint.translate(tx, ty);\n        }\n        if (cache.targetPoint) {\n            cache.targetPoint.translate(tx, ty);\n        }\n        this.sourcePoint.translate(tx, ty);\n        this.targetPoint.translate(tx, ty);\n        this.sourceAnchor.translate(tx, ty);\n        this.targetAnchor.translate(tx, ty);\n    }\n    updateLabelPositions() {\n        if (this.containers.labels == null) {\n            return this;\n        }\n        const path = this.path;\n        if (!path) {\n            return this;\n        }\n        const edge = this.cell;\n        const labels = edge.getLabels();\n        if (labels.length === 0) {\n            return this;\n        }\n        const defaultLabel = edge.getDefaultLabel();\n        const defaultPosition = this.normalizeLabelPosition(defaultLabel.position);\n        for (let i = 0, ii = labels.length; i < ii; i += 1) {\n            const label = labels[i];\n            const labelPosition = this.normalizeLabelPosition(label.position);\n            const pos = ObjectExt.merge({}, defaultPosition, labelPosition);\n            const matrix = this.getLabelTransformationMatrix(pos);\n            this.labelCache[i].setAttribute('transform', Dom.matrixToTransformString(matrix));\n        }\n        return this;\n    }\n    updateToolsPosition() {\n        if (this.containers.tools == null) {\n            return this;\n        }\n        // Move the tools a bit to the target position but don't cover the\n        // `sourceArrowhead` marker. Note that the offset is hardcoded here.\n        // The offset should be always more than the\n        // `this.$('.marker-arrowhead[end=\"source\"]')[0].bbox().width` but looking\n        // this up all the time would be slow.\n        let scale = '';\n        let offset = this.options.toolsOffset;\n        const connectionLength = this.getConnectionLength();\n        // Firefox returns `connectionLength=NaN` in odd cases (for bezier curves).\n        // In that case we won't update tools position at all.\n        if (connectionLength != null) {\n            // If the edge is too short, make the tools half the\n            // size and the offset twice as low.\n            if (connectionLength < this.options.shortLength) {\n                scale = 'scale(.5)';\n                offset /= 2;\n            }\n            let pos = this.getPointAtLength(offset);\n            if (pos != null) {\n                Dom.attr(this.toolCache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);\n            }\n            if (this.options.doubleTools &&\n                connectionLength >= this.options.longLength) {\n                const doubleToolsOffset = this.options.doubleToolsOffset || offset;\n                pos = this.getPointAtLength(connectionLength - doubleToolsOffset);\n                if (pos != null) {\n                    Dom.attr(this.tool2Cache, 'transform', `translate(${pos.x},${pos.y}) ${scale}`);\n                }\n                Dom.attr(this.tool2Cache, 'visibility', 'visible');\n            }\n            else if (this.options.doubleTools) {\n                Dom.attr(this.tool2Cache, 'visibility', 'hidden');\n            }\n        }\n        return this;\n    }\n    updateArrowheadMarkers() {\n        const container = this.containers.arrowheads;\n        if (container == null) {\n            return this;\n        }\n        if (container.style.display === 'none') {\n            return this;\n        }\n        const sourceArrowhead = this.containers.sourceArrowhead;\n        const targetArrowhead = this.containers.targetArrowhead;\n        if (sourceArrowhead && targetArrowhead) {\n            const len = this.getConnectionLength() || 0;\n            const sx = len < this.options.shortLength ? 0.5 : 1;\n            Dom.scale(sourceArrowhead, sx);\n            Dom.scale(targetArrowhead, sx);\n            this.translateAndAutoOrientArrows(sourceArrowhead, targetArrowhead);\n        }\n        return this;\n    }\n    updateTerminalProperties(type) {\n        const edge = this.cell;\n        const graph = this.graph;\n        const terminal = edge[type];\n        const nodeId = terminal && terminal.cell;\n        const viewKey = `${type}View`;\n        // terminal is a point\n        if (!nodeId) {\n            this[viewKey] = null;\n            this.updateTerminalMagnet(type);\n            return true;\n        }\n        const terminalCell = graph.getCellById(nodeId);\n        if (!terminalCell) {\n            throw new Error(`Edge's ${type} node with id \"${nodeId}\" not exists`);\n        }\n        const endView = terminalCell.findView(graph);\n        if (!endView) {\n            return false;\n        }\n        this[viewKey] = endView;\n        this.updateTerminalMagnet(type);\n        return true;\n    }\n    updateTerminalMagnet(type) {\n        const propName = `${type}Magnet`;\n        const terminalView = this.getTerminalView(type);\n        if (terminalView) {\n            let magnet = terminalView.getMagnetFromEdgeTerminal(this.cell[type]);\n            if (magnet === terminalView.container) {\n                magnet = null;\n            }\n            this[propName] = magnet;\n        }\n        else {\n            this[propName] = null;\n        }\n    }\n    translateAndAutoOrientArrows(sourceArrow, targetArrow) {\n        const route = this.routePoints;\n        if (sourceArrow) {\n            Dom.translateAndAutoOrient(sourceArrow, this.sourcePoint, route[0] || this.targetPoint, this.graph.view.stage);\n        }\n        if (targetArrow) {\n            Dom.translateAndAutoOrient(targetArrow, this.targetPoint, route[route.length - 1] || this.sourcePoint, this.graph.view.stage);\n        }\n    }\n    getLabelPositionAngle(idx) {\n        const label = this.cell.getLabelAt(idx);\n        if (label && label.position && typeof label.position === 'object') {\n            return label.position.angle || 0;\n        }\n        return 0;\n    }\n    getLabelPositionArgs(idx) {\n        const label = this.cell.getLabelAt(idx);\n        if (label && label.position && typeof label.position === 'object') {\n            return label.position.options;\n        }\n    }\n    getDefaultLabelPositionArgs() {\n        const defaultLabel = this.cell.getDefaultLabel();\n        if (defaultLabel &&\n            defaultLabel.position &&\n            typeof defaultLabel.position === 'object') {\n            return defaultLabel.position.options;\n        }\n    }\n    // merge default label position args into label position args\n    // keep `undefined` or `null` because `{}` means something else\n    mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs) {\n        if (labelPositionArgs === null) {\n            return null;\n        }\n        if (labelPositionArgs === undefined) {\n            if (defaultLabelPositionArgs === null) {\n                return null;\n            }\n            return defaultLabelPositionArgs;\n        }\n        return ObjectExt.merge({}, defaultLabelPositionArgs, labelPositionArgs);\n    }\n    addLabel(p1, p2, p3, options) {\n        let localX;\n        let localY;\n        let localAngle = 0;\n        let localOptions;\n        if (typeof p1 !== 'number') {\n            localX = p1.x;\n            localY = p1.y;\n            if (typeof p2 === 'number') {\n                localAngle = p2;\n                localOptions = p3;\n            }\n            else {\n                localOptions = p2;\n            }\n        }\n        else {\n            localX = p1;\n            localY = p2;\n            if (typeof p3 === 'number') {\n                localAngle = p3;\n                localOptions = options;\n            }\n            else {\n                localOptions = p3;\n            }\n        }\n        // merge label position arguments\n        const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n        const labelPositionArgs = localOptions;\n        const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n        // append label to labels array\n        const label = {\n            position: this.getLabelPosition(localX, localY, localAngle, positionArgs),\n        };\n        const index = -1;\n        this.cell.insertLabel(label, index, localOptions);\n        return index;\n    }\n    addVertex(x, y, options) {\n        const isPoint = typeof x !== 'number';\n        const localX = isPoint ? x.x : x;\n        const localY = isPoint ? x.y : y;\n        const localOptions = isPoint ? y : options;\n        const vertex = { x: localX, y: localY };\n        const index = this.getVertexIndex(localX, localY);\n        this.cell.insertVertex(vertex, index, localOptions);\n        return index;\n    }\n    sendToken(token, options, callback) {\n        let duration;\n        let reversed;\n        let selector;\n        let rorate;\n        let timing = 'linear';\n        if (typeof options === 'object') {\n            duration = options.duration;\n            reversed = options.reversed === true;\n            selector = options.selector;\n            if (options.rotate === false) {\n                rorate = '';\n            }\n            else if (options.rotate === true) {\n                rorate = 'auto';\n            }\n            else if (options.rotate != null) {\n                rorate = `${options.rotate}`;\n            }\n            if (options.timing) {\n                timing = options.timing;\n            }\n        }\n        else {\n            duration = options;\n            reversed = false;\n            selector = null;\n        }\n        duration = duration || 1000;\n        const attrs = {\n            dur: `${duration}ms`,\n            repeatCount: '1',\n            calcMode: timing,\n            fill: 'freeze',\n        };\n        if (rorate) {\n            attrs.rotate = rorate;\n        }\n        if (reversed) {\n            attrs.keyPoints = '1;0';\n            attrs.keyTimes = '0;1';\n        }\n        if (typeof options === 'object') {\n            const { duration, reversed, selector, rotate, timing } = options, others = __rest(options, [\"duration\", \"reversed\", \"selector\", \"rotate\", \"timing\"]);\n            Object.keys(others).forEach((key) => {\n                attrs[key] = others[key];\n            });\n        }\n        let path;\n        if (typeof selector === 'string') {\n            path = this.findOne(selector, this.container, this.selectors);\n        }\n        else {\n            // Select connection path automatically.\n            path = this.containers.connection\n                ? this.containers.connection\n                : this.container.querySelector('path');\n        }\n        if (!(path instanceof SVGPathElement)) {\n            throw new Error('Token animation requires a valid connection path.');\n        }\n        const target = typeof token === 'string' ? this.findOne(token) : token;\n        if (target == null) {\n            throw new Error('Token animation requires a valid token element.');\n        }\n        const parent = target.parentNode;\n        const revert = () => {\n            if (!parent) {\n                Dom.remove(target);\n            }\n        };\n        const vToken = Vector.create(target);\n        if (!parent) {\n            vToken.appendTo(this.graph.view.stage);\n        }\n        const onComplete = attrs.complete;\n        attrs.complete = (e) => {\n            revert();\n            if (callback) {\n                callback();\n            }\n            if (onComplete) {\n                onComplete(e);\n            }\n        };\n        const stop = vToken.animateAlongPath(attrs, path);\n        return () => {\n            revert();\n            stop();\n        };\n    }\n    // #endregion\n    getConnection() {\n        return this.path != null ? this.path.clone() : null;\n    }\n    getConnectionPathData() {\n        if (this.path == null) {\n            return '';\n        }\n        const cache = this.cache.pathCache;\n        if (!ObjectExt.has(cache, 'data')) {\n            cache.data = this.path.serialize();\n        }\n        return cache.data || '';\n    }\n    getConnectionSubdivisions() {\n        if (this.path == null) {\n            return null;\n        }\n        const cache = this.cache.pathCache;\n        if (!ObjectExt.has(cache, 'segmentSubdivisions')) {\n            cache.segmentSubdivisions = this.path.getSegmentSubdivisions();\n        }\n        return cache.segmentSubdivisions;\n    }\n    getConnectionLength() {\n        if (this.path == null) {\n            return 0;\n        }\n        const cache = this.cache.pathCache;\n        if (!ObjectExt.has(cache, 'length')) {\n            cache.length = this.path.length({\n                segmentSubdivisions: this.getConnectionSubdivisions(),\n            });\n        }\n        return cache.length;\n    }\n    getPointAtLength(length) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.pointAtLength(length, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getPointAtRatio(ratio) {\n        if (this.path == null) {\n            return null;\n        }\n        if (NumberExt.isPercentage(ratio)) {\n            // eslint-disable-next-line\n            ratio = parseFloat(ratio) / 100;\n        }\n        return this.path.pointAt(ratio, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getTangentAtLength(length) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.tangentAtLength(length, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getTangentAtRatio(ratio) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.tangentAt(ratio, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getClosestPoint(point) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.closestPoint(point, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getClosestPointLength(point) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.closestPointLength(point, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getClosestPointRatio(point) {\n        if (this.path == null) {\n            return null;\n        }\n        return this.path.closestPointNormalizedLength(point, {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        });\n    }\n    getLabelPosition(x, y, p3, p4) {\n        const pos = { distance: 0 };\n        // normalize data from the two possible signatures\n        let angle = 0;\n        let options;\n        if (typeof p3 === 'number') {\n            angle = p3;\n            options = p4;\n        }\n        else {\n            options = p3;\n        }\n        if (options != null) {\n            pos.options = options;\n        }\n        // identify distance/offset settings\n        const isOffsetAbsolute = options && options.absoluteOffset;\n        const isDistanceRelative = !(options && options.absoluteDistance);\n        const isDistanceAbsoluteReverse = options && options.absoluteDistance && options.reverseDistance;\n        // find closest point t\n        const path = this.path;\n        const pathOptions = {\n            segmentSubdivisions: this.getConnectionSubdivisions(),\n        };\n        const labelPoint = new Point(x, y);\n        const t = path.closestPointT(labelPoint, pathOptions);\n        // distance\n        const totalLength = this.getConnectionLength() || 0;\n        let labelDistance = path.lengthAtT(t, pathOptions);\n        if (isDistanceRelative) {\n            labelDistance = totalLength > 0 ? labelDistance / totalLength : 0;\n        }\n        if (isDistanceAbsoluteReverse) {\n            // fix for end point (-0 => 1)\n            labelDistance = -1 * (totalLength - labelDistance) || 1;\n        }\n        pos.distance = labelDistance;\n        // offset\n        // use absolute offset if:\n        // - options.absoluteOffset is true,\n        // - options.absoluteOffset is not true but there is no tangent\n        let tangent;\n        if (!isOffsetAbsolute)\n            tangent = path.tangentAtT(t);\n        let labelOffset;\n        if (tangent) {\n            labelOffset = tangent.pointOffset(labelPoint);\n        }\n        else {\n            const closestPoint = path.pointAtT(t);\n            const labelOffsetDiff = labelPoint.diff(closestPoint);\n            labelOffset = { x: labelOffsetDiff.x, y: labelOffsetDiff.y };\n        }\n        pos.offset = labelOffset;\n        pos.angle = angle;\n        return pos;\n    }\n    normalizeLabelPosition(pos) {\n        if (typeof pos === 'number') {\n            return { distance: pos };\n        }\n        return pos;\n    }\n    getLabelTransformationMatrix(labelPosition) {\n        const pos = this.normalizeLabelPosition(labelPosition);\n        const options = pos.options || {};\n        const labelAngle = pos.angle || 0;\n        const labelDistance = pos.distance;\n        const isDistanceRelative = labelDistance > 0 && labelDistance <= 1;\n        let labelOffset = 0;\n        const offsetCoord = { x: 0, y: 0 };\n        const offset = pos.offset;\n        if (offset) {\n            if (typeof offset === 'number') {\n                labelOffset = offset;\n            }\n            else {\n                if (offset.x != null) {\n                    offsetCoord.x = offset.x;\n                }\n                if (offset.y != null) {\n                    offsetCoord.y = offset.y;\n                }\n            }\n        }\n        const isOffsetAbsolute = offsetCoord.x !== 0 || offsetCoord.y !== 0 || labelOffset === 0;\n        const isKeepGradient = options.keepGradient;\n        const isEnsureLegibility = options.ensureLegibility;\n        const path = this.path;\n        const pathOpt = { segmentSubdivisions: this.getConnectionSubdivisions() };\n        const distance = isDistanceRelative\n            ? labelDistance * this.getConnectionLength()\n            : labelDistance;\n        const tangent = path.tangentAtLength(distance, pathOpt);\n        let translation;\n        let angle = labelAngle;\n        if (tangent) {\n            if (isOffsetAbsolute) {\n                translation = tangent.start;\n                translation.translate(offsetCoord);\n            }\n            else {\n                const normal = tangent.clone();\n                normal.rotate(-90, tangent.start);\n                normal.setLength(labelOffset);\n                translation = normal.end;\n            }\n            if (isKeepGradient) {\n                angle = tangent.angle() + labelAngle;\n                if (isEnsureLegibility) {\n                    angle = Angle.normalize(((angle + 90) % 180) - 90);\n                }\n            }\n        }\n        else {\n            // fallback - the connection has zero length\n            translation = path.start;\n            if (isOffsetAbsolute) {\n                translation.translate(offsetCoord);\n            }\n        }\n        return Dom.createSVGMatrix()\n            .translate(translation.x, translation.y)\n            .rotate(angle);\n    }\n    getLabelCoordinates(pos) {\n        const matrix = this.getLabelTransformationMatrix(pos);\n        return new Point(matrix.e, matrix.f);\n    }\n    getVertexIndex(x, y) {\n        const edge = this.cell;\n        const vertices = edge.getVertices();\n        const vertexLength = this.getClosestPointLength(new Point(x, y));\n        let index = 0;\n        if (vertexLength != null) {\n            for (const ii = vertices.length; index < ii; index += 1) {\n                const currentVertex = vertices[index];\n                const currentLength = this.getClosestPointLength(currentVertex);\n                if (currentLength != null && vertexLength < currentLength) {\n                    break;\n                }\n            }\n        }\n        return index;\n    }\n    getEventArgs(e, x, y) {\n        const view = this; // eslint-disable-line\n        const edge = view.cell;\n        const cell = edge;\n        if (x == null || y == null) {\n            return { e, view, edge, cell };\n        }\n        return { e, x, y, view, edge, cell };\n    }\n    notifyUnhandledMouseDown(e, x, y) {\n        this.notify('edge:unhandled:mousedown', {\n            e,\n            x,\n            y,\n            view: this,\n            cell: this.cell,\n            edge: this.cell,\n        });\n    }\n    notifyMouseDown(e, x, y) {\n        super.onMouseDown(e, x, y);\n        this.notify('edge:mousedown', this.getEventArgs(e, x, y));\n    }\n    notifyMouseMove(e, x, y) {\n        super.onMouseMove(e, x, y);\n        this.notify('edge:mousemove', this.getEventArgs(e, x, y));\n    }\n    notifyMouseUp(e, x, y) {\n        super.onMouseUp(e, x, y);\n        this.notify('edge:mouseup', this.getEventArgs(e, x, y));\n    }\n    onClick(e, x, y) {\n        super.onClick(e, x, y);\n        this.notify('edge:click', this.getEventArgs(e, x, y));\n    }\n    onDblClick(e, x, y) {\n        super.onDblClick(e, x, y);\n        this.notify('edge:dblclick', this.getEventArgs(e, x, y));\n    }\n    onContextMenu(e, x, y) {\n        super.onContextMenu(e, x, y);\n        this.notify('edge:contextmenu', this.getEventArgs(e, x, y));\n    }\n    onMouseDown(e, x, y) {\n        this.notifyMouseDown(e, x, y);\n        const className = e.target.getAttribute('class');\n        switch (className) {\n            case 'vertex': {\n                this.startVertexDragging(e, x, y);\n                return;\n            }\n            case 'vertex-remove':\n            case 'vertex-remove-area': {\n                this.handleVertexRemoving(e, x, y);\n                return;\n            }\n            case 'connection':\n            case 'connection-wrap': {\n                this.handleVertexAdding(e, x, y);\n                return;\n            }\n            case 'arrowhead': {\n                this.startArrowheadDragging(e, x, y);\n                return;\n            }\n            case 'source-marker':\n            case 'target-marker': {\n                this.notifyUnhandledMouseDown(e, x, y);\n                return;\n            }\n            default:\n                break;\n        }\n        this.startEdgeDragging(e, x, y);\n    }\n    onMouseMove(e, x, y) {\n        const data = this.getEventData(e);\n        switch (data.action) {\n            case 'drag-vertex': {\n                this.dragVertex(e, x, y);\n                break;\n            }\n            case 'drag-label': {\n                this.dragLabel(e, x, y);\n                break;\n            }\n            case 'drag-arrowhead': {\n                this.dragArrowhead(e, x, y);\n                break;\n            }\n            case 'drag-edge': {\n                this.dragEdge(e, x, y);\n                break;\n            }\n            default:\n                break;\n        }\n        this.notifyMouseMove(e, x, y);\n        return data;\n    }\n    onMouseUp(e, x, y) {\n        const data = this.getEventData(e);\n        switch (data.action) {\n            case 'drag-vertex': {\n                this.stopVertexDragging(e, x, y);\n                break;\n            }\n            case 'drag-label': {\n                this.stopLabelDragging(e, x, y);\n                break;\n            }\n            case 'drag-arrowhead': {\n                this.stopArrowheadDragging(e, x, y);\n                break;\n            }\n            case 'drag-edge': {\n                this.stopEdgeDragging(e, x, y);\n                break;\n            }\n            default:\n                break;\n        }\n        this.notifyMouseUp(e, x, y);\n        this.checkMouseleave(e);\n        return data;\n    }\n    onMouseOver(e) {\n        super.onMouseOver(e);\n        this.notify('edge:mouseover', this.getEventArgs(e));\n    }\n    onMouseOut(e) {\n        super.onMouseOut(e);\n        this.notify('edge:mouseout', this.getEventArgs(e));\n    }\n    onMouseEnter(e) {\n        super.onMouseEnter(e);\n        this.notify('edge:mouseenter', this.getEventArgs(e));\n    }\n    onMouseLeave(e) {\n        super.onMouseLeave(e);\n        this.notify('edge:mouseleave', this.getEventArgs(e));\n    }\n    onMouseWheel(e, x, y, delta) {\n        super.onMouseWheel(e, x, y, delta);\n        this.notify('edge:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));\n    }\n    onCustomEvent(e, name, x, y) {\n        // For default edge tool\n        const tool = Dom.findParentByClass(e.target, 'edge-tool', this.container);\n        if (tool) {\n            e.stopPropagation(); // no further action to be executed\n            if (this.can('useEdgeTools')) {\n                if (name === 'edge:remove') {\n                    this.cell.remove({ ui: true });\n                    return;\n                }\n                this.notify('edge:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));\n            }\n            this.notifyMouseDown(e, x, y);\n        }\n        else {\n            this.notify('edge:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));\n            super.onCustomEvent(e, name, x, y);\n        }\n    }\n    onLabelMouseDown(e, x, y) {\n        this.notifyMouseDown(e, x, y);\n        this.startLabelDragging(e, x, y);\n        const stopPropagation = this.getEventData(e).stopPropagation;\n        if (stopPropagation) {\n            e.stopPropagation();\n        }\n    }\n    // #region drag edge\n    startEdgeDragging(e, x, y) {\n        if (!this.can('edgeMovable')) {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n        }\n        this.setEventData(e, {\n            x,\n            y,\n            moving: false,\n            action: 'drag-edge',\n        });\n    }\n    dragEdge(e, x, y) {\n        const data = this.getEventData(e);\n        if (!data.moving) {\n            data.moving = true;\n            this.addClass('edge-moving');\n            this.notify('edge:move', {\n                e,\n                x,\n                y,\n                view: this,\n                cell: this.cell,\n                edge: this.cell,\n            });\n        }\n        this.cell.translate(x - data.x, y - data.y, { ui: true });\n        this.setEventData(e, { x, y });\n        this.notify('edge:moving', {\n            e,\n            x,\n            y,\n            view: this,\n            cell: this.cell,\n            edge: this.cell,\n        });\n    }\n    stopEdgeDragging(e, x, y) {\n        const data = this.getEventData(e);\n        if (data.moving) {\n            this.removeClass('edge-moving');\n            this.notify('edge:moved', {\n                e,\n                x,\n                y,\n                view: this,\n                cell: this.cell,\n                edge: this.cell,\n            });\n        }\n        data.moving = false;\n    }\n    // #endregion\n    // #region drag arrowhead\n    prepareArrowheadDragging(type, options) {\n        const magnet = this.getTerminalMagnet(type);\n        const data = {\n            action: 'drag-arrowhead',\n            x: options.x,\n            y: options.y,\n            isNewEdge: options.isNewEdge === true,\n            terminalType: type,\n            initialMagnet: magnet,\n            initialTerminal: ObjectExt.clone(this.cell[type]),\n            fallbackAction: options.fallbackAction || 'revert',\n            getValidateConnectionArgs: this.createValidateConnectionArgs(type),\n            options: options.options,\n        };\n        this.beforeArrowheadDragging(data);\n        return data;\n    }\n    createValidateConnectionArgs(type) {\n        const args = [];\n        args[4] = type;\n        args[5] = this;\n        let opposite;\n        let i = 0;\n        let j = 0;\n        if (type === 'source') {\n            i = 2;\n            opposite = 'target';\n        }\n        else {\n            j = 2;\n            opposite = 'source';\n        }\n        const terminal = this.cell[opposite];\n        const cellId = terminal.cell;\n        if (cellId) {\n            let magnet;\n            const view = (args[i] = this.graph.renderer.findViewByCell(cellId));\n            if (view) {\n                magnet = view.getMagnetFromEdgeTerminal(terminal);\n                if (magnet === view.container) {\n                    magnet = undefined;\n                }\n            }\n            args[i + 1] = magnet;\n        }\n        return (cellView, magnet) => {\n            args[j] = cellView;\n            args[j + 1] = cellView.container === magnet ? undefined : magnet;\n            return args;\n        };\n    }\n    beforeArrowheadDragging(data) {\n        data.zIndex = this.cell.zIndex;\n        this.cell.toFront();\n        const style = this.container.style;\n        data.pointerEvents = style.pointerEvents;\n        style.pointerEvents = 'none';\n        if (this.graph.options.connecting.highlight) {\n            this.highlightAvailableMagnets(data);\n        }\n    }\n    afterArrowheadDragging(data) {\n        if (data.zIndex != null) {\n            this.cell.setZIndex(data.zIndex, { ui: true });\n            data.zIndex = null;\n        }\n        const container = this.container;\n        container.style.pointerEvents = data.pointerEvents || '';\n        if (this.graph.options.connecting.highlight) {\n            this.unhighlightAvailableMagnets(data);\n        }\n    }\n    arrowheadDragging(target, x, y, data) {\n        data.x = x;\n        data.y = y;\n        // Checking views right under the pointer\n        if (data.currentTarget !== target) {\n            // Unhighlight the previous view under pointer if there was one.\n            if (data.currentMagnet && data.currentView) {\n                data.currentView.unhighlight(data.currentMagnet, {\n                    type: 'magnetAdsorbed',\n                });\n            }\n            data.currentView = this.graph.renderer.findViewByElem(target);\n            if (data.currentView) {\n                // If we found a view that is under the pointer, we need to find\n                // the closest magnet based on the real target element of the event.\n                data.currentMagnet = data.currentView.findMagnet(target);\n                if (data.currentMagnet &&\n                    this.graph.hook.validateConnection(...data.getValidateConnectionArgs(data.currentView, data.currentMagnet), data.currentView.getEdgeTerminal(data.currentMagnet, x, y, this.cell, data.terminalType))) {\n                    data.currentView.highlight(data.currentMagnet, {\n                        type: 'magnetAdsorbed',\n                    });\n                }\n                else {\n                    // This type of connection is not valid. Disregard this magnet.\n                    data.currentMagnet = null;\n                }\n            }\n            else {\n                // Make sure we'll unset previous magnet.\n                data.currentMagnet = null;\n            }\n        }\n        data.currentTarget = target;\n        this.cell.prop(data.terminalType, { x, y }, Object.assign(Object.assign({}, data.options), { ui: true }));\n    }\n    arrowheadDragged(data, x, y) {\n        const view = data.currentView;\n        const magnet = data.currentMagnet;\n        if (!magnet || !view) {\n            return;\n        }\n        view.unhighlight(magnet, { type: 'magnetAdsorbed' });\n        const type = data.terminalType;\n        const terminal = view.getEdgeTerminal(magnet, x, y, this.cell, type);\n        this.cell.setTerminal(type, terminal, { ui: true });\n    }\n    snapArrowhead(x, y, data) {\n        const graph = this.graph;\n        const snap = graph.options.connecting.snap;\n        const radius = (typeof snap === 'object' && snap.radius) || 50;\n        const views = graph.renderer.findViewsInArea({\n            x: x - radius,\n            y: y - radius,\n            width: 2 * radius,\n            height: 2 * radius,\n        });\n        const prevView = data.closestView || null;\n        const prevMagnet = data.closestMagnet || null;\n        data.closestView = null;\n        data.closestMagnet = null;\n        let distance;\n        let minDistance = Number.MAX_SAFE_INTEGER;\n        const pos = new Point(x, y);\n        views.forEach((view) => {\n            if (view.container.getAttribute('magnet') !== 'false') {\n                // Find distance from the center of the cell to pointer coordinates\n                distance = view.cell.getBBox().getCenter().distance(pos);\n                // the connection is looked up in a circle area by `distance < r`\n                if (distance < radius && distance < minDistance) {\n                    if (prevMagnet === view.container ||\n                        graph.hook.validateConnection(...data.getValidateConnectionArgs(view, null), view.getEdgeTerminal(view.container, x, y, this.cell, data.terminalType))) {\n                        minDistance = distance;\n                        data.closestView = view;\n                        data.closestMagnet = view.container;\n                    }\n                }\n            }\n            view.container.querySelectorAll('[magnet]').forEach((magnet) => {\n                if (magnet.getAttribute('magnet') !== 'false') {\n                    const bbox = view.getBBoxOfElement(magnet);\n                    distance = pos.distance(bbox.getCenter());\n                    if (distance < radius && distance < minDistance) {\n                        if (prevMagnet === magnet ||\n                            graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, x, y, this.cell, data.terminalType))) {\n                            minDistance = distance;\n                            data.closestView = view;\n                            data.closestMagnet = magnet;\n                        }\n                    }\n                }\n            });\n        });\n        let terminal;\n        const type = data.terminalType;\n        const closestView = data.closestView;\n        const closestMagnet = data.closestMagnet;\n        const changed = prevMagnet !== closestMagnet;\n        if (prevView && changed) {\n            prevView.unhighlight(prevMagnet, {\n                type: 'magnetAdsorbed',\n            });\n        }\n        if (closestView) {\n            if (!changed) {\n                return;\n            }\n            closestView.highlight(closestMagnet, {\n                type: 'magnetAdsorbed',\n            });\n            terminal = closestView.getEdgeTerminal(closestMagnet, x, y, this.cell, type);\n        }\n        else {\n            terminal = { x, y };\n        }\n        this.cell.setTerminal(type, terminal, {}, Object.assign(Object.assign({}, data.options), { ui: true }));\n    }\n    snapArrowheadEnd(data) {\n        // Finish off link snapping.\n        // Everything except view unhighlighting was already done on pointermove.\n        const closestView = data.closestView;\n        const closestMagnet = data.closestMagnet;\n        if (closestView && closestMagnet) {\n            closestView.unhighlight(closestMagnet, {\n                type: 'magnetAdsorbed',\n            });\n            data.currentMagnet = closestView.findMagnet(closestMagnet);\n        }\n        data.closestView = null;\n        data.closestMagnet = null;\n    }\n    finishEmbedding(data) {\n        // Resets parent of the edge if embedding is enabled\n        if (this.graph.options.embedding.enabled && this.cell.updateParent()) {\n            // Make sure we don't reverse to the original 'z' index\n            data.zIndex = null;\n        }\n    }\n    fallbackConnection(data) {\n        switch (data.fallbackAction) {\n            case 'remove':\n                this.cell.remove({ ui: true });\n                break;\n            case 'revert':\n            default:\n                this.cell.prop(data.terminalType, data.initialTerminal, {\n                    ui: true,\n                });\n                break;\n        }\n    }\n    notifyConnectionEvent(data, e) {\n        const terminalType = data.terminalType;\n        const initialTerminal = data.initialTerminal;\n        const currentTerminal = this.cell[terminalType];\n        const changed = currentTerminal && !Edge.equalTerminals(initialTerminal, currentTerminal);\n        if (changed) {\n            const graph = this.graph;\n            const previous = initialTerminal;\n            const previousCell = previous.cell\n                ? graph.getCellById(previous.cell)\n                : null;\n            const previousPort = previous.port;\n            const previousView = previousCell\n                ? graph.findViewByCell(previousCell)\n                : null;\n            const previousPoint = previousCell || data.isNewEdge\n                ? null\n                : Point.create(initialTerminal).toJSON();\n            const current = currentTerminal;\n            const currentCell = current.cell ? graph.getCellById(current.cell) : null;\n            const currentPort = current.port;\n            const currentView = currentCell ? graph.findViewByCell(currentCell) : null;\n            const currentPoint = currentCell\n                ? null\n                : Point.create(currentTerminal).toJSON();\n            this.notify('edge:connected', {\n                e,\n                previousCell,\n                previousPort,\n                previousView,\n                previousPoint,\n                currentCell,\n                currentView,\n                currentPort,\n                currentPoint,\n                previousMagnet: data.initialMagnet,\n                currentMagnet: data.currentMagnet,\n                edge: this.cell,\n                view: this,\n                type: terminalType,\n                isNew: data.isNewEdge,\n            });\n        }\n    }\n    highlightAvailableMagnets(data) {\n        const graph = this.graph;\n        const cells = graph.model.getCells();\n        data.marked = {};\n        for (let i = 0, ii = cells.length; i < ii; i += 1) {\n            const view = graph.renderer.findViewByCell(cells[i]);\n            if (!view) {\n                continue;\n            }\n            const magnets = Array.prototype.slice.call(view.container.querySelectorAll('[magnet]'));\n            if (view.container.getAttribute('magnet') !== 'false') {\n                magnets.push(view.container);\n            }\n            const availableMagnets = magnets.filter((magnet) => graph.hook.validateConnection(...data.getValidateConnectionArgs(view, magnet), view.getEdgeTerminal(magnet, data.x, data.y, this.cell, data.terminalType)));\n            if (availableMagnets.length > 0) {\n                // highlight all available magnets\n                for (let j = 0, jj = availableMagnets.length; j < jj; j += 1) {\n                    view.highlight(availableMagnets[j], { type: 'magnetAvailable' });\n                }\n                // highlight the entire view\n                view.highlight(null, { type: 'nodeAvailable' });\n                data.marked[view.cell.id] = availableMagnets;\n            }\n        }\n    }\n    unhighlightAvailableMagnets(data) {\n        const marked = data.marked || {};\n        Object.keys(marked).forEach((id) => {\n            const view = this.graph.renderer.findViewByCell(id);\n            if (view) {\n                const magnets = marked[id];\n                magnets.forEach((magnet) => {\n                    view.unhighlight(magnet, { type: 'magnetAvailable' });\n                });\n                view.unhighlight(null, { type: 'nodeAvailable' });\n            }\n        });\n        data.marked = null;\n    }\n    startArrowheadDragging(e, x, y) {\n        if (!this.can('arrowheadMovable')) {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n        }\n        const elem = e.target;\n        const type = elem.getAttribute('data-terminal');\n        const data = this.prepareArrowheadDragging(type, { x, y });\n        this.setEventData(e, data);\n    }\n    dragArrowhead(e, x, y) {\n        const data = this.getEventData(e);\n        if (this.graph.options.connecting.snap) {\n            this.snapArrowhead(x, y, data);\n        }\n        else {\n            this.arrowheadDragging(this.getEventTarget(e), x, y, data);\n        }\n    }\n    stopArrowheadDragging(e, x, y) {\n        const graph = this.graph;\n        const data = this.getEventData(e);\n        if (graph.options.connecting.snap) {\n            this.snapArrowheadEnd(data);\n        }\n        else {\n            this.arrowheadDragged(data, x, y);\n        }\n        const valid = graph.hook.validateEdge(this.cell, data.terminalType, data.initialTerminal);\n        if (valid) {\n            this.finishEmbedding(data);\n            this.notifyConnectionEvent(data, e);\n        }\n        else {\n            // If the changed edge is not allowed, revert to its previous state.\n            this.fallbackConnection(data);\n        }\n        this.afterArrowheadDragging(data);\n    }\n    // #endregion\n    // #region drag lable\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    startLabelDragging(e, x, y) {\n        if (this.can('edgeLabelMovable')) {\n            const target = e.currentTarget;\n            const index = parseInt(target.getAttribute('data-index'), 10);\n            const positionAngle = this.getLabelPositionAngle(index);\n            const labelPositionArgs = this.getLabelPositionArgs(index);\n            const defaultLabelPositionArgs = this.getDefaultLabelPositionArgs();\n            const positionArgs = this.mergeLabelPositionArgs(labelPositionArgs, defaultLabelPositionArgs);\n            this.setEventData(e, {\n                index,\n                positionAngle,\n                positionArgs,\n                stopPropagation: true,\n                action: 'drag-label',\n            });\n        }\n        else {\n            // If labels can't be dragged no default action is triggered.\n            this.setEventData(e, { stopPropagation: true });\n        }\n        this.graph.view.delegateDragEvents(e, this);\n    }\n    dragLabel(e, x, y) {\n        const data = this.getEventData(e);\n        const originLabel = this.cell.getLabelAt(data.index);\n        const label = ObjectExt.merge({}, originLabel, {\n            position: this.getLabelPosition(x, y, data.positionAngle, data.positionArgs),\n        });\n        this.cell.setLabelAt(data.index, label);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    stopLabelDragging(e, x, y) { }\n    // #endregion\n    // #region drag vertex\n    handleVertexAdding(e, x, y) {\n        if (!this.can('vertexAddable')) {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n        }\n        // Store the index at which the new vertex has just been placed.\n        // We'll be update the very same vertex position in `pointermove()`.\n        const index = this.addVertex({ x, y }, { ui: true });\n        this.setEventData(e, {\n            index,\n            action: 'drag-vertex',\n        });\n    }\n    handleVertexRemoving(e, x, y) {\n        if (!this.can('vertexDeletable')) {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n        }\n        const target = e.target;\n        const index = parseInt(target.getAttribute('idx'), 10);\n        this.cell.removeVertexAt(index);\n    }\n    startVertexDragging(e, x, y) {\n        if (!this.can('vertexMovable')) {\n            this.notifyUnhandledMouseDown(e, x, y);\n            return;\n        }\n        const target = e.target;\n        const index = parseInt(target.getAttribute('idx'), 10);\n        this.setEventData(e, {\n            index,\n            action: 'drag-vertex',\n        });\n    }\n    dragVertex(e, x, y) {\n        const data = this.getEventData(e);\n        this.cell.setVertexAt(data.index, { x, y }, { ui: true });\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    stopVertexDragging(e, x, y) { }\n}\n(function (EdgeView) {\n    EdgeView.toStringTag = `X6.${EdgeView.name}`;\n    function isEdgeView(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof EdgeView) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const view = instance;\n        if ((tag == null || tag === EdgeView.toStringTag) &&\n            typeof view.isNodeView === 'function' &&\n            typeof view.isEdgeView === 'function' &&\n            typeof view.confirmUpdate === 'function' &&\n            typeof view.update === 'function' &&\n            typeof view.getConnection === 'function') {\n            return true;\n        }\n        return false;\n    }\n    EdgeView.isEdgeView = isEdgeView;\n})(EdgeView || (EdgeView = {}));\nEdgeView.config({\n    isSvgElement: true,\n    priority: 1,\n    bootstrap: ['render', 'source', 'target'],\n    actions: {\n        view: ['render'],\n        markup: ['render'],\n        attrs: ['update'],\n        source: ['source', 'update'],\n        target: ['target', 'update'],\n        router: ['update'],\n        connector: ['update'],\n        labels: ['labels'],\n        defaultLabel: ['labels'],\n        vertices: ['vertices', 'update'],\n        vertexMarkup: ['vertices'],\n        toolMarkup: ['tools'],\n        tools: ['widget'],\n    },\n    shortLength: 105,\n    longLength: 155,\n    toolsOffset: 40,\n    doubleTools: false,\n    doubleToolsOffset: 65,\n    sampleInterval: 50,\n});\nEdgeView.registry.register('edge', EdgeView, true);\n//# sourceMappingURL=edge.js.map"]},"metadata":{},"sourceType":"module"}