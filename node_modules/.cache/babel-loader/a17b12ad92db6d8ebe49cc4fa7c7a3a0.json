{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\n/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from './base';\nimport { getDegree, clone } from '../util';\n\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\n  nodes.forEach(function (_, i) {\n    nodes[i].children = [];\n    nodes[i].parent = [];\n  });\n\n  if (directed) {\n    edges.forEach(function (e) {\n      var sourceIdx = 0;\n\n      if (e.source) {\n        sourceIdx = nodeMap[e.source];\n      }\n\n      var targetIdx = 0;\n\n      if (e.target) {\n        targetIdx = nodeMap[e.target];\n      }\n\n      var child = nodes[sourceIdx].children;\n      var parent = nodes[targetIdx].parent;\n      child.push(nodes[targetIdx].id);\n      parent.push(nodes[sourceIdx].id);\n    });\n  } else {\n    edges.forEach(function (e) {\n      var sourceIdx = 0;\n\n      if (e.source) {\n        sourceIdx = nodeMap[e.source];\n      }\n\n      var targetIdx = 0;\n\n      if (e.target) {\n        targetIdx = nodeMap[e.target];\n      }\n\n      var child = nodes[sourceIdx].children;\n      var parent = nodes[targetIdx].parent;\n      child.push(nodes[targetIdx].id);\n      parent.push(nodes[sourceIdx].id);\n    });\n  }\n}\n\nfunction connect(a, b, edges) {\n  var m = edges.length;\n\n  for (var i = 0; i < m; i++) {\n    if (a.id === edges[i].source && b.id === edges[i].target || b.id === edges[i].source && a.id === edges[i].target) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction compareDegree(a, b) {\n  var aDegree = a.degree;\n  var bDegree = b.degree;\n\n  if (aDegree < bDegree) {\n    return -1;\n  }\n\n  if (aDegree > bDegree) {\n    return 1;\n  }\n\n  return 0;\n}\n/**\n * 圆形布局\n */\n\n\nexport var CircularLayout = /*#__PURE__*/function (_Base) {\n  _inherits(CircularLayout, _Base);\n\n  var _super = _createSuper(CircularLayout);\n\n  function CircularLayout(options) {\n    var _this;\n\n    _classCallCheck(this, CircularLayout);\n\n    _this = _super.call(this);\n    /** 布局中心 */\n\n    _this.center = [0, 0];\n    /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n\n    _this.radius = null;\n    /** 起始半径 */\n\n    _this.startRadius = null;\n    /** 终止半径 */\n\n    _this.endRadius = null;\n    /** 起始角度 */\n\n    _this.startAngle = 0;\n    /** 终止角度 */\n\n    _this.endAngle = 2 * Math.PI;\n    /** 是否顺时针 */\n\n    _this.clockwise = true;\n    /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n\n    _this.divisions = 1;\n    /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n\n    _this.ordering = null;\n    /** how many 2*pi from first to last nodes */\n\n    _this.angleRatio = 1;\n    _this.nodes = [];\n    _this.edges = [];\n    _this.nodeMap = {};\n    _this.degrees = [];\n    _this.width = 300;\n    _this.height = 300;\n\n    _this.updateCfg(options);\n\n    return _this;\n  }\n\n  _createClass(CircularLayout, [{\n    key: \"getDefaultCfg\",\n    value: function getDefaultCfg() {\n      return {\n        center: [0, 0],\n        radius: null,\n        startRadius: null,\n        endRadius: null,\n        startAngle: 0,\n        endAngle: 2 * Math.PI,\n        clockwise: true,\n        divisions: 1,\n        ordering: null,\n        angleRatio: 1\n      };\n    }\n    /**\n     * 执行布局\n     */\n\n  }, {\n    key: \"execute\",\n    value: function execute() {\n      var self = this;\n      var nodes = self.nodes;\n      var edges = self.edges;\n      var n = nodes.length;\n      var center = self.center;\n\n      if (n === 0) {\n        return;\n      }\n\n      if (n === 1) {\n        nodes[0].x = center[0];\n        nodes[0].y = center[1];\n        return;\n      }\n\n      var radius = self.radius;\n      var startRadius = self.startRadius;\n      var endRadius = self.endRadius;\n      var divisions = self.divisions;\n      var startAngle = self.startAngle;\n      var endAngle = self.endAngle;\n      var angleStep = (endAngle - startAngle) / n; // layout\n\n      var nodeMap = {};\n      nodes.forEach(function (node, i) {\n        nodeMap[node.id] = i;\n      });\n      self.nodeMap = nodeMap;\n      var degrees = getDegree(nodes.length, nodeMap, edges);\n      self.degrees = degrees;\n\n      if (!self.width && typeof window !== 'undefined') {\n        self.width = window.innerWidth;\n      }\n\n      if (!self.height && typeof window !== 'undefined') {\n        self.height = window.innerHeight;\n      }\n\n      if (!radius && !startRadius && !endRadius) {\n        radius = self.height > self.width ? self.width / 2 : self.height / 2;\n      } else if (!startRadius && endRadius) {\n        startRadius = endRadius;\n      } else if (startRadius && !endRadius) {\n        endRadius = startRadius;\n      }\n\n      var angleRatio = self.angleRatio;\n      var astep = angleStep * angleRatio;\n      var ordering = self.ordering;\n      var layoutNodes = [];\n\n      if (ordering === 'topology') {\n        // layout according to the topology\n        layoutNodes = self.topologyOrdering();\n      } else if (ordering === 'topology-directed') {\n        // layout according to the topology\n        layoutNodes = self.topologyOrdering(true);\n      } else if (ordering === 'degree') {\n        // layout according to the descent order of degrees\n        layoutNodes = self.degreeOrdering();\n      } else {\n        // layout according to the original order in the data.nodes\n        layoutNodes = nodes;\n      }\n\n      var clockwise = self.clockwise;\n      var divN = Math.ceil(n / divisions); // node number in each division\n\n      for (var i = 0; i < n; ++i) {\n        var r = radius;\n\n        if (!r && startRadius !== null && endRadius !== null) {\n          r = startRadius + i * (endRadius - startRadius) / (n - 1);\n        }\n\n        if (!r) {\n          r = 10 + i * 100 / (n - 1);\n        }\n\n        var angle = startAngle + i % divN * astep + 2 * Math.PI / divisions * Math.floor(i / divN);\n\n        if (!clockwise) {\n          angle = endAngle - i % divN * astep - 2 * Math.PI / divisions * Math.floor(i / divN);\n        }\n\n        layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n        layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n        layoutNodes[i].weight = degrees[i];\n      }\n\n      return layoutNodes;\n    }\n    /**\n     * 根据节点的拓扑结构排序\n     * @return {array} orderedNodes 排序后的结果\n     */\n\n  }, {\n    key: \"topologyOrdering\",\n    value: function topologyOrdering() {\n      var directed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n      var self = this;\n      var degrees = self.degrees;\n      var edges = self.edges;\n      var nodes = self.nodes;\n      var cnodes = clone(nodes);\n      var nodeMap = self.nodeMap;\n      var orderedCNodes = [cnodes[0]];\n      var resNodes = [nodes[0]];\n      var pickFlags = [];\n      var n = nodes.length;\n      pickFlags[0] = true;\n      initHierarchy(cnodes, edges, nodeMap, directed);\n      var k = 0;\n      cnodes.forEach(function (cnode, i) {\n        if (i !== 0) {\n          if ((i === n - 1 || degrees[i] !== degrees[i + 1] || connect(orderedCNodes[k], cnode, edges)) && !pickFlags[i]) {\n            orderedCNodes.push(cnode);\n            resNodes.push(nodes[nodeMap[cnode.id]]);\n            pickFlags[i] = true;\n            k++;\n          } else {\n            var children = orderedCNodes[k].children;\n            var foundChild = false;\n\n            for (var j = 0; j < children.length; j++) {\n              var childIdx = nodeMap[children[j]];\n\n              if (degrees[childIdx] === degrees[i] && !pickFlags[childIdx]) {\n                orderedCNodes.push(cnodes[childIdx]);\n                resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n                pickFlags[childIdx] = true;\n                foundChild = true;\n                break;\n              }\n            }\n\n            var ii = 0;\n\n            while (!foundChild) {\n              if (!pickFlags[ii]) {\n                orderedCNodes.push(cnodes[ii]);\n                resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n                pickFlags[ii] = true;\n                foundChild = true;\n              }\n\n              ii++;\n\n              if (ii === n) {\n                break;\n              }\n            }\n          }\n        }\n      });\n      return resNodes;\n    }\n    /**\n     * 根据节点度数大小排序\n     * @return {array} orderedNodes 排序后的结果\n     */\n\n  }, {\n    key: \"degreeOrdering\",\n    value: function degreeOrdering() {\n      var self = this;\n      var nodes = self.nodes;\n      var orderedNodes = [];\n      var degrees = self.degrees;\n      nodes.forEach(function (node, i) {\n        node.degree = degrees[i];\n        orderedNodes.push(node);\n      });\n      orderedNodes.sort(compareDegree);\n      return orderedNodes;\n    }\n  }]);\n\n  return CircularLayout;\n}(Base);","map":{"version":3,"sources":["../../src/layout/circular.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @fileOverview random layout\n * @author shiwu.wyy@antfin.com\n */\nimport { Base } from './base';\nimport { getDegree, clone } from '../util';\nfunction initHierarchy(nodes, edges, nodeMap, directed) {\n    nodes.forEach((_, i) => {\n        nodes[i].children = [];\n        nodes[i].parent = [];\n    });\n    if (directed) {\n        edges.forEach((e) => {\n            let sourceIdx = 0;\n            if (e.source) {\n                sourceIdx = nodeMap[e.source];\n            }\n            let targetIdx = 0;\n            if (e.target) {\n                targetIdx = nodeMap[e.target];\n            }\n            const child = nodes[sourceIdx].children;\n            const parent = nodes[targetIdx].parent;\n            child.push(nodes[targetIdx].id);\n            parent.push(nodes[sourceIdx].id);\n        });\n    }\n    else {\n        edges.forEach((e) => {\n            let sourceIdx = 0;\n            if (e.source) {\n                sourceIdx = nodeMap[e.source];\n            }\n            let targetIdx = 0;\n            if (e.target) {\n                targetIdx = nodeMap[e.target];\n            }\n            const child = nodes[sourceIdx].children;\n            const parent = nodes[targetIdx].parent;\n            child.push(nodes[targetIdx].id);\n            parent.push(nodes[sourceIdx].id);\n        });\n    }\n}\nfunction connect(a, b, edges) {\n    const m = edges.length;\n    for (let i = 0; i < m; i++) {\n        if ((a.id === edges[i].source && b.id === edges[i].target) ||\n            (b.id === edges[i].source && a.id === edges[i].target)) {\n            return true;\n        }\n    }\n    return false;\n}\nfunction compareDegree(a, b) {\n    const aDegree = a.degree;\n    const bDegree = b.degree;\n    if (aDegree < bDegree) {\n        return -1;\n    }\n    if (aDegree > bDegree) {\n        return 1;\n    }\n    return 0;\n}\n/**\n * 圆形布局\n */\nexport class CircularLayout extends Base {\n    constructor(options) {\n        super();\n        /** 布局中心 */\n        this.center = [0, 0];\n        /** 固定半径，若设置了 radius，则 startRadius 与 endRadius 不起效 */\n        this.radius = null;\n        /** 起始半径 */\n        this.startRadius = null;\n        /** 终止半径 */\n        this.endRadius = null;\n        /** 起始角度 */\n        this.startAngle = 0;\n        /** 终止角度 */\n        this.endAngle = 2 * Math.PI;\n        /** 是否顺时针 */\n        this.clockwise = true;\n        /** 节点在环上分成段数（几个段将均匀分布），在 endRadius - startRadius != 0 时生效 */\n        this.divisions = 1;\n        /** 节点在环上排序的依据，可选: 'topology', 'degree', 'null' */\n        this.ordering = null;\n        /** how many 2*pi from first to last nodes */\n        this.angleRatio = 1;\n        this.nodes = [];\n        this.edges = [];\n        this.nodeMap = {};\n        this.degrees = [];\n        this.width = 300;\n        this.height = 300;\n        this.updateCfg(options);\n    }\n    getDefaultCfg() {\n        return {\n            center: [0, 0],\n            radius: null,\n            startRadius: null,\n            endRadius: null,\n            startAngle: 0,\n            endAngle: 2 * Math.PI,\n            clockwise: true,\n            divisions: 1,\n            ordering: null,\n            angleRatio: 1,\n        };\n    }\n    /**\n     * 执行布局\n     */\n    execute() {\n        const self = this;\n        const nodes = self.nodes;\n        const edges = self.edges;\n        const n = nodes.length;\n        const center = self.center;\n        if (n === 0) {\n            return;\n        }\n        if (n === 1) {\n            nodes[0].x = center[0];\n            nodes[0].y = center[1];\n            return;\n        }\n        let radius = self.radius;\n        let startRadius = self.startRadius;\n        let endRadius = self.endRadius;\n        const divisions = self.divisions;\n        const startAngle = self.startAngle;\n        const endAngle = self.endAngle;\n        const angleStep = (endAngle - startAngle) / n;\n        // layout\n        const nodeMap = {};\n        nodes.forEach((node, i) => {\n            nodeMap[node.id] = i;\n        });\n        self.nodeMap = nodeMap;\n        const degrees = getDegree(nodes.length, nodeMap, edges);\n        self.degrees = degrees;\n        if (!self.width && typeof window !== 'undefined') {\n            self.width = window.innerWidth;\n        }\n        if (!self.height && typeof window !== 'undefined') {\n            self.height = window.innerHeight;\n        }\n        if (!radius && !startRadius && !endRadius) {\n            radius = self.height > self.width ? self.width / 2 : self.height / 2;\n        }\n        else if (!startRadius && endRadius) {\n            startRadius = endRadius;\n        }\n        else if (startRadius && !endRadius) {\n            endRadius = startRadius;\n        }\n        const angleRatio = self.angleRatio;\n        const astep = angleStep * angleRatio;\n        const ordering = self.ordering;\n        let layoutNodes = [];\n        if (ordering === 'topology') {\n            // layout according to the topology\n            layoutNodes = self.topologyOrdering();\n        }\n        else if (ordering === 'topology-directed') {\n            // layout according to the topology\n            layoutNodes = self.topologyOrdering(true);\n        }\n        else if (ordering === 'degree') {\n            // layout according to the descent order of degrees\n            layoutNodes = self.degreeOrdering();\n        }\n        else {\n            // layout according to the original order in the data.nodes\n            layoutNodes = nodes;\n        }\n        const clockwise = self.clockwise;\n        const divN = Math.ceil(n / divisions); // node number in each division\n        for (let i = 0; i < n; ++i) {\n            let r = radius;\n            if (!r && startRadius !== null && endRadius !== null) {\n                r = startRadius + (i * (endRadius - startRadius)) / (n - 1);\n            }\n            if (!r) {\n                r = 10 + (i * 100) / (n - 1);\n            }\n            let angle = startAngle +\n                (i % divN) * astep +\n                ((2 * Math.PI) / divisions) * Math.floor(i / divN);\n            if (!clockwise) {\n                angle =\n                    endAngle -\n                        (i % divN) * astep -\n                        ((2 * Math.PI) / divisions) * Math.floor(i / divN);\n            }\n            layoutNodes[i].x = center[0] + Math.cos(angle) * r;\n            layoutNodes[i].y = center[1] + Math.sin(angle) * r;\n            layoutNodes[i].weight = degrees[i];\n        }\n        return layoutNodes;\n    }\n    /**\n     * 根据节点的拓扑结构排序\n     * @return {array} orderedNodes 排序后的结果\n     */\n    topologyOrdering(directed = false) {\n        const self = this;\n        const degrees = self.degrees;\n        const edges = self.edges;\n        const nodes = self.nodes;\n        const cnodes = clone(nodes);\n        const nodeMap = self.nodeMap;\n        const orderedCNodes = [cnodes[0]];\n        const resNodes = [nodes[0]];\n        const pickFlags = [];\n        const n = nodes.length;\n        pickFlags[0] = true;\n        initHierarchy(cnodes, edges, nodeMap, directed);\n        let k = 0;\n        cnodes.forEach((cnode, i) => {\n            if (i !== 0) {\n                if ((i === n - 1 ||\n                    degrees[i] !== degrees[i + 1] ||\n                    connect(orderedCNodes[k], cnode, edges)) &&\n                    !pickFlags[i]) {\n                    orderedCNodes.push(cnode);\n                    resNodes.push(nodes[nodeMap[cnode.id]]);\n                    pickFlags[i] = true;\n                    k++;\n                }\n                else {\n                    const children = orderedCNodes[k].children;\n                    let foundChild = false;\n                    for (let j = 0; j < children.length; j++) {\n                        const childIdx = nodeMap[children[j]];\n                        if (degrees[childIdx] === degrees[i] && !pickFlags[childIdx]) {\n                            orderedCNodes.push(cnodes[childIdx]);\n                            resNodes.push(nodes[nodeMap[cnodes[childIdx].id]]);\n                            pickFlags[childIdx] = true;\n                            foundChild = true;\n                            break;\n                        }\n                    }\n                    let ii = 0;\n                    while (!foundChild) {\n                        if (!pickFlags[ii]) {\n                            orderedCNodes.push(cnodes[ii]);\n                            resNodes.push(nodes[nodeMap[cnodes[ii].id]]);\n                            pickFlags[ii] = true;\n                            foundChild = true;\n                        }\n                        ii++;\n                        if (ii === n) {\n                            break;\n                        }\n                    }\n                }\n            }\n        });\n        return resNodes;\n    }\n    /**\n     * 根据节点度数大小排序\n     * @return {array} orderedNodes 排序后的结果\n     */\n    degreeOrdering() {\n        const self = this;\n        const nodes = self.nodes;\n        const orderedNodes = [];\n        const degrees = self.degrees;\n        nodes.forEach((node, i) => {\n            node.degree = degrees[i];\n            orderedNodes.push(node);\n        });\n        orderedNodes.sort(compareDegree);\n        return orderedNodes;\n    }\n}\n//# sourceMappingURL=circular.js.map"]},"metadata":{},"sourceType":"module"}