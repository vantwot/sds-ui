{"ast":null,"code":"export const getDegree = (n, nodeIdxMap, edges) => {\n  const degrees = [];\n\n  for (let i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  edges.forEach(e => {\n    if (e.source) {\n      degrees[nodeIdxMap[e.source]] += 1;\n    }\n\n    if (e.target) {\n      degrees[nodeIdxMap[e.target]] += 1;\n    }\n  });\n  return degrees;\n};\nexport const floydWarshall = adjMatrix => {\n  // initialize\n  const dist = [];\n  const size = adjMatrix.length;\n\n  for (let i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (let j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (let k = 0; k < size; k += 1) {\n    for (let i = 0; i < size; i += 1) {\n      for (let j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\nexport const getAdjMatrix = (data, directed) => {\n  const {\n    nodes,\n    edges\n  } = data;\n  const matrix = []; // map node with index in data.nodes\n\n  const nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach((node, i) => {\n      nodeMap[node.id] = i;\n      const row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(e => {\n      const {\n        source,\n        target\n      } = e;\n      const sIndex = nodeMap[source];\n      const tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};","map":{"version":3,"sources":["../../src/util/math.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export const getDegree = (n, nodeIdxMap, edges) => {\n    const degrees = [];\n    for (let i = 0; i < n; i++) {\n        degrees[i] = 0;\n    }\n    edges.forEach((e) => {\n        if (e.source) {\n            degrees[nodeIdxMap[e.source]] += 1;\n        }\n        if (e.target) {\n            degrees[nodeIdxMap[e.target]] += 1;\n        }\n    });\n    return degrees;\n};\nexport const floydWarshall = (adjMatrix) => {\n    // initialize\n    const dist = [];\n    const size = adjMatrix.length;\n    for (let i = 0; i < size; i += 1) {\n        dist[i] = [];\n        for (let j = 0; j < size; j += 1) {\n            if (i === j) {\n                dist[i][j] = 0;\n            }\n            else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n                dist[i][j] = Infinity;\n            }\n            else {\n                dist[i][j] = adjMatrix[i][j];\n            }\n        }\n    }\n    // floyd\n    for (let k = 0; k < size; k += 1) {\n        for (let i = 0; i < size; i += 1) {\n            for (let j = 0; j < size; j += 1) {\n                if (dist[i][j] > dist[i][k] + dist[k][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n    return dist;\n};\nexport const getAdjMatrix = (data, directed) => {\n    const { nodes, edges } = data;\n    const matrix = [];\n    // map node with index in data.nodes\n    const nodeMap = {};\n    if (!nodes) {\n        throw new Error('invalid nodes data!');\n    }\n    if (nodes) {\n        nodes.forEach((node, i) => {\n            nodeMap[node.id] = i;\n            const row = [];\n            matrix.push(row);\n        });\n    }\n    if (edges) {\n        edges.forEach((e) => {\n            const { source, target } = e;\n            const sIndex = nodeMap[source];\n            const tIndex = nodeMap[target];\n            matrix[sIndex][tIndex] = 1;\n            if (!directed) {\n                matrix[tIndex][sIndex] = 1;\n            }\n        });\n    }\n    return matrix;\n};\n//# sourceMappingURL=math.js.map"]},"metadata":{},"sourceType":"module"}