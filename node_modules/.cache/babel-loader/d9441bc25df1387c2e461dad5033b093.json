{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { clamp, interpolate as _interpolate } from '../util';\nimport Point from './point';\n\nvar EdgeInsets = function () {\n  function EdgeInsets() {\n    var top = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    var bottom = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    var left = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    var right = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n    _classCallCheck(this, EdgeInsets);\n\n    _defineProperty(this, \"top\", void 0);\n\n    _defineProperty(this, \"bottom\", void 0);\n\n    _defineProperty(this, \"left\", void 0);\n\n    _defineProperty(this, \"right\", void 0);\n\n    if (isNaN(top) || top < 0 || isNaN(bottom) || bottom < 0 || isNaN(left) || left < 0 || isNaN(right) || right < 0) {\n      throw new Error('Invalid value for edge-insets, top, bottom, left and right must all be numbers');\n    }\n\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n  }\n\n  _createClass(EdgeInsets, [{\n    key: \"interpolate\",\n    value: function interpolate(start, target, t) {\n      if (target.top != null && start.top != null) {\n        this.top = _interpolate(start.top, target.top, t);\n      }\n\n      if (target.bottom != null && start.bottom != null) {\n        this.bottom = _interpolate(start.bottom, target.bottom, t);\n      }\n\n      if (target.left != null && start.left != null) {\n        this.left = _interpolate(start.left, target.left, t);\n      }\n\n      if (target.right != null && start.right != null) {\n        this.right = _interpolate(start.right, target.right, t);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getCenter\",\n    value: function getCenter(width, height) {\n      var x = clamp((this.left + width - this.right) / 2, 0, width);\n      var y = clamp((this.top + height - this.bottom) / 2, 0, height);\n      return new Point(x, y);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(other) {\n      return this.top === other.top && this.bottom === other.bottom && this.left === other.left && this.right === other.right;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new EdgeInsets(this.top, this.bottom, this.left, this.right);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        top: this.top,\n        bottom: this.bottom,\n        left: this.left,\n        right: this.right\n      };\n    }\n  }]);\n\n  return EdgeInsets;\n}();\n\nexport { EdgeInsets as default };","map":{"version":3,"sources":["../../src/geo/edge_insets.ts"],"names":["interpolate","EdgeInsets","top","bottom","left","right","isNaN","target","start","x","clamp","y","other"],"mappings":"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","sourcesContent":["// @ts-ignore\nimport { clamp, interpolate } from '../util';\nimport Point from './point';\n\n/**\n * An `EdgeInset` object represents screen space padding applied to the edges of the viewport.\n * This shifts the apprent center or the vanishing point of the map. This is useful for adding floating UI elements\n * on top of the map and having the vanishing point shift as UI elements resize.\n *\n * @param {number} [top=0]\n * @param {number} [bottom=0]\n * @param {number} [left=0]\n * @param {number} [right=0]\n */\nexport default class EdgeInsets {\n  public top: number;\n  public bottom: number;\n  public left: number;\n  public right: number;\n\n  constructor(\n    top: number = 0,\n    bottom: number = 0,\n    left: number = 0,\n    right: number = 0,\n  ) {\n    if (\n      isNaN(top) ||\n      top < 0 ||\n      isNaN(bottom) ||\n      bottom < 0 ||\n      isNaN(left) ||\n      left < 0 ||\n      isNaN(right) ||\n      right < 0\n    ) {\n      throw new Error(\n        'Invalid value for edge-insets, top, bottom, left and right must all be numbers',\n      );\n    }\n\n    this.top = top;\n    this.bottom = bottom;\n    this.left = left;\n    this.right = right;\n  }\n\n  /**\n   * Interpolates the inset in-place.\n   * This maintains the current inset value for any inset not present in `target`.\n   *\n   * @param {PaddingOptions} target\n   * @param {number} t\n   * @returns {EdgeInsets}\n   * @memberof EdgeInsets\n   */\n  public interpolate(\n    start: IPaddingOptions | EdgeInsets,\n    target: IPaddingOptions,\n    t: number,\n  ): EdgeInsets {\n    if (target.top != null && start.top != null) {\n      this.top = interpolate(start.top, target.top, t);\n    }\n    if (target.bottom != null && start.bottom != null) {\n      this.bottom = interpolate(start.bottom, target.bottom, t);\n    }\n    if (target.left != null && start.left != null) {\n      this.left = interpolate(start.left, target.left, t);\n    }\n    if (target.right != null && start.right != null) {\n      this.right = interpolate(start.right, target.right, t);\n    }\n\n    return this;\n  }\n\n  /**\n   * Utility method that computes the new apprent center or vanishing point after applying insets.\n   * This is in pixels and with the top left being (0.0) and +y being downwards.\n   *\n   * @param {number} width\n   * @param {number} height\n   * @returns {Point}\n   * @memberof EdgeInsets\n   */\n  public getCenter(width: number, height: number): Point {\n    // Clamp insets so they never overflow width/height and always calculate a valid center\n    const x = clamp((this.left + width - this.right) / 2, 0, width);\n    const y = clamp((this.top + height - this.bottom) / 2, 0, height);\n\n    return new Point(x, y);\n  }\n\n  public equals(other: IPaddingOptions): boolean {\n    return (\n      this.top === other.top &&\n      this.bottom === other.bottom &&\n      this.left === other.left &&\n      this.right === other.right\n    );\n  }\n\n  public clone(): EdgeInsets {\n    return new EdgeInsets(this.top, this.bottom, this.left, this.right);\n  }\n\n  /**\n   * Returns the current sdtate as json, useful when you want to have a\n   * read-only representation of the inset.\n   *\n   * @returns {PaddingOptions}\n   * @memberof EdgeInsets\n   */\n  public toJSON(): IPaddingOptions {\n    return {\n      top: this.top,\n      bottom: this.bottom,\n      left: this.left,\n      right: this.right,\n    };\n  }\n}\n\nexport interface IPaddingOptions {\n  top?: number;\n  bottom?: number;\n  right?: number;\n  left?: number;\n}\n"]},"metadata":{},"sourceType":"module"}