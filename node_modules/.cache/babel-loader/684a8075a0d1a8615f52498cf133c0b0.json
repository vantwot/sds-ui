{"ast":null,"code":"import { __assign } from \"tslib\";\nimport { deepMix, clone, debounce } from '@antv/util';\nimport Global from '../global';\nexport default {\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      updateEdge: true,\n      delegateStyle: {},\n      // 是否开启delegate\n      enableDelegate: false,\n      // 拖动节点过程中是否只改变 Combo 的大小，而不改变其结构\n      onlyChangeComboSize: false,\n      // 拖动过程中目标 combo 状态样式\n      comboActiveState: '',\n      selectedState: 'selected',\n      enableOptimize: false,\n      enableDebounce: false,\n      enableStack: true\n    };\n  },\n  getEvents: function getEvents() {\n    return {\n      'node:dragstart': 'onDragStart',\n      'node:drag': 'onDrag',\n      'node:dragend': 'onDragEnd',\n      'combo:dragenter': 'onDragEnter',\n      'combo:dragleave': 'onDragLeave',\n      'combo:drop': 'onDropCombo',\n      'node:drop': 'onDropNode',\n      'canvas:drop': 'onDropCanvas',\n      'touchstart': 'onTouchStart',\n      'touchmove': 'onTouchMove',\n      'touchend': 'onDragEnd'\n    };\n  },\n  validationCombo: function validationCombo(item) {\n    if (!this.origin || !item || item.destroyed) {\n      return false;\n    }\n\n    var type = item.getType();\n\n    if (type !== 'combo') {\n      return false;\n    }\n\n    return true;\n  },\n  onTouchStart: function onTouchStart(e) {\n    if (!e.item) return;\n    var self = this;\n\n    try {\n      var touches = e.originalEvent.touches;\n      var event1 = touches[0];\n      var event2 = touches[1];\n\n      if (event1 && event2) {\n        return;\n      }\n\n      e.preventDefault();\n    } catch (e) {\n      console.warn('Touch original event not exist!');\n    }\n\n    self.onDragStart(e);\n  },\n  onTouchMove: function onTouchMove(e) {\n    var self = this;\n\n    try {\n      var touches = e.originalEvent.touches;\n      var event1 = touches[0];\n      var event2 = touches[1];\n\n      if (event1 && event2) {\n        self.onDragEnd(e);\n        return;\n      }\n\n      e.preventDefault();\n    } catch (e) {\n      console.warn('Touch original event not exist!');\n    }\n\n    self.onDrag(e);\n  },\n\n  /**\n   * 开始拖动节点\n   * @param evt\n   */\n  onDragStart: function onDragStart(evt) {\n    var _this = this;\n\n    this.currentShouldEnd = true;\n\n    if (!this.shouldBegin.call(this, evt)) {\n      return;\n    }\n\n    var item = evt.item;\n\n    if (!item || item.destroyed || item.hasLocked()) {\n      return;\n    } // 拖动时，设置拖动元素的 capture 为false，则不拾取拖动的元素\n\n\n    var group = item.getContainer();\n    group.set('capture', false);\n    if (!this.cachedCaptureItems) this.cachedCaptureItems = [];\n    this.cachedCaptureItems.push(item); // 如果拖动的target 是linkPoints / anchorPoints 则不允许拖动\n\n    var target = evt.target;\n\n    if (target) {\n      var isAnchorPoint = target.get('isAnchorPoint');\n\n      if (isAnchorPoint) {\n        return;\n      }\n    }\n\n    var graph = this.graph;\n    this.targets = []; // 将节点拖入到指定的 Combo\n\n    this.targetCombo = null; // 获取所有选中的元素\n\n    var nodes = graph.findAllByState('node', this.selectedState);\n    var currentNodeId = item.get('id'); // 当前拖动的节点是否是选中的节点\n\n    var dragNodes = nodes.filter(function (node) {\n      var nodeId = node.get('id');\n      return currentNodeId === nodeId;\n    }); // 只拖动当前节点\n\n    if (dragNodes.length === 0) {\n      this.targets.push(item);\n    } else if (nodes.length > 1) {\n      // 拖动多个节点\n      nodes.forEach(function (node) {\n        var locked = node.hasLocked();\n\n        if (!locked) {\n          _this.targets.push(node);\n        }\n      });\n    } else {\n      this.targets.push(item);\n    }\n\n    var beforeDragNodes = [];\n    this.targets.forEach(function (t) {\n      beforeDragNodes.push(clone(t.getModel()));\n    });\n    this.set('beforeDragNodes', beforeDragNodes);\n    this.hidenEdge = {};\n\n    if (this.get('updateEdge') && this.enableOptimize && !this.enableDelegate) {\n      this.targets.forEach(function (node) {\n        var edges = node.getEdges();\n        edges.forEach(function (edge) {\n          if (!edge.isVisible()) return;\n          _this.hidenEdge[edge.getID()] = true;\n          edge.hide();\n        });\n      });\n    }\n\n    this.origin = {\n      x: evt.x,\n      y: evt.y\n    };\n    this.point = {};\n    this.originPoint = {};\n  },\n\n  /**\n   * 持续拖动节点\n   * @param evt\n   */\n  onDrag: function onDrag(evt) {\n    var _this = this;\n\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.shouldUpdate.call(this, evt)) {\n      return;\n    }\n\n    if (this.get('enableDelegate')) {\n      this.updateDelegate(evt);\n    } else {\n      if (this.enableDebounce) this.debounceUpdate({\n        targets: this.targets,\n        graph: this.graph,\n        point: this.point,\n        origin: this.origin,\n        evt: evt,\n        updateEdge: this.get('updateEdge')\n      });else this.targets.map(function (target) {\n        _this.update(target, evt);\n      });\n    }\n  },\n\n  /**\n   * 拖动结束，设置拖动元素capture为true，更新元素位置，如果是拖动涉及到 combo，则更新 combo 结构\n   * @param evt\n   */\n  onDragEnd: function onDragEnd(evt) {\n    var _this = this;\n\n    var _a;\n\n    if (!this.origin) {\n      return;\n    } // 拖动结束后，设置拖动元素 group 的 capture 为 true，允许拾取拖动元素\n\n\n    (_a = this.cachedCaptureItems) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {\n      var group = item.getContainer();\n      group.set('capture', true);\n    });\n    this.cachedCaptureItems = [];\n\n    if (this.delegateRect) {\n      this.delegateRect.remove();\n      this.delegateRect = null;\n    }\n\n    if (this.get('updateEdge') && this.enableOptimize && !this.enableDelegate) {\n      this.targets.forEach(function (node) {\n        var edges = node.getEdges();\n        edges.forEach(function (edge) {\n          if (_this.hidenEdge[edge.getID()]) edge.show();\n          edge.refresh();\n        });\n      });\n    }\n\n    this.hidenEdge = {};\n    var graph = this.graph; // 拖动结束后，入栈\n\n    if (graph.get('enabledStack') && this.enableStack) {\n      var stackData_1 = {\n        before: {\n          nodes: [],\n          edges: [],\n          combos: []\n        },\n        after: {\n          nodes: [],\n          edges: [],\n          combos: []\n        }\n      };\n      this.get('beforeDragNodes').forEach(function (model) {\n        stackData_1.before.nodes.push({\n          id: model.id,\n          x: model.x,\n          y: model.y\n        });\n      });\n      this.targets.forEach(function (target) {\n        var targetModel = target.getModel();\n        stackData_1.after.nodes.push({\n          id: targetModel.id,\n          x: targetModel.x,\n          y: targetModel.y\n        });\n      });\n      graph.pushStack('update', clone(stackData_1));\n    } // 拖动结束后emit事件，将当前操作的节点抛出去，目标节点为null\n\n\n    graph.emit('dragnodeend', {\n      items: this.targets,\n      targetItem: null\n    });\n    this.point = {};\n    this.origin = null;\n    this.originPoint = {};\n    this.targets.length = 0;\n    this.targetCombo = null;\n  },\n\n  /**\n   * 拖动过程中将节点放置到 combo 上\n   * @param evt\n   */\n  onDropCombo: function onDropCombo(evt) {\n    var item = evt.item;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, item); // 若不允许结束，则将节点位置设置回初识位置。后面的逻辑仍需要执行\n\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.currentShouldEnd || !this.validationCombo(item)) return;\n    var graph = this.graph;\n\n    if (this.comboActiveState) {\n      graph.setItemState(item, this.comboActiveState, false);\n    }\n\n    this.targetCombo = item; // 拖动结束后是动态改变 Combo 大小还是将节点从 Combo 中删除\n\n    if (this.onlyChangeComboSize) {\n      // 拖动节点结束后，动态改变 Combo 的大小\n      graph.updateCombos();\n    } else {\n      var targetComboModel_1 = item.getModel();\n      this.targets.map(function (node) {\n        var nodeModel = node.getModel();\n\n        if (nodeModel.comboId !== targetComboModel_1.id) {\n          graph.updateComboTree(node, targetComboModel_1.id);\n        }\n      });\n      graph.updateCombo(item);\n    } // 将节点拖动到 combo 上面，emit事件抛出当前操作的节点及目标 combo\n\n\n    graph.emit('dragnodeend', {\n      items: this.targets,\n      targetItem: this.targetCombo\n    });\n  },\n  onDropCanvas: function onDropCanvas(evt) {\n    var graph = this.graph;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, undefined); // 若不允许结束，则将节点位置设置回初识位置。后面的逻辑仍需要执行\n\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.targets || this.targets.length === 0 || !this.currentShouldEnd) return;\n\n    if (this.onlyChangeComboSize) {\n      // 拖动节点结束后，动态改变 Combo 的大小\n      graph.updateCombos();\n    } else {\n      this.targets.map(function (node) {\n        // 拖动的节点有 comboId，即是从其他 combo 中拖出时才处理\n        var model = node.getModel();\n\n        if (model.comboId) {\n          graph.updateComboTree(node);\n        }\n      });\n    }\n  },\n\n  /**\n   * 拖动放置到某个 combo 中的子 node 上\n   * @param evt\n   */\n  onDropNode: function onDropNode(evt) {\n    if (!this.targets || this.targets.length === 0) return;\n    var self = this;\n    var item = evt.item;\n    var graph = self.graph;\n    var comboId = item.getModel().comboId;\n    var newParentCombo = comboId ? graph.findById(comboId) : undefined;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, newParentCombo); // 若不允许结束，则将节点位置设置回初识位置。后面的逻辑仍需要执行\n\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.currentShouldEnd) return;\n\n    if (this.onlyChangeComboSize) {\n      graph.updateCombos();\n    } else if (comboId) {\n      var combo = graph.findById(comboId);\n\n      if (self.comboActiveState) {\n        graph.setItemState(combo, self.comboActiveState, false);\n      }\n\n      this.targets.map(function (node) {\n        var nodeModel = node.getModel();\n\n        if (comboId !== nodeModel.comboId) {\n          graph.updateComboTree(node, comboId);\n        }\n      });\n      graph.updateCombo(combo);\n    } else {\n      this.targets.map(function (node) {\n        var model = node.getModel();\n\n        if (model.comboId) {\n          graph.updateComboTree(node);\n        }\n      });\n    } // 将节点拖动到另外个节点上面，emit 事件抛出当前操作的节点及目标节点\n\n\n    graph.emit('dragnodeend', {\n      items: this.targets,\n      targetItem: item\n    });\n  },\n\n  /**\n   * 将节点拖入到 Combo 中\n   * @param evt\n   */\n  onDragEnter: function onDragEnter(evt) {\n    var item = evt.item;\n    if (!this.validationCombo(item)) return;\n    var graph = this.graph;\n\n    if (this.comboActiveState) {\n      graph.setItemState(item, this.comboActiveState, true);\n    }\n  },\n\n  /**\n   * 将节点从 Combo 中拖出\n   * @param evt\n   */\n  onDragLeave: function onDragLeave(evt) {\n    var item = evt.item;\n    if (!this.validationCombo(item)) return;\n    var graph = this.graph;\n\n    if (this.comboActiveState) {\n      graph.setItemState(item, this.comboActiveState, false);\n    }\n  },\n  updatePositions: function updatePositions(evt, restore) {\n    var _this = this;\n\n    if (!this.targets || this.targets.length === 0) return; // 当开启 delegate 时，拖动结束后需要更新所有已选中节点的位置\n\n    if (this.get('enableDelegate')) {\n      if (this.enableDebounce) this.debounceUpdate({\n        targets: this.targets,\n        graph: this.graph,\n        point: this.point,\n        origin: this.origin,\n        evt: evt,\n        updateEdge: this.get('updateEdge'),\n        updateFunc: this.update\n      });else if (!restore) this.targets.map(function (node) {\n        return _this.update(node, evt);\n      });\n    } else this.targets.map(function (node) {\n      return _this.update(node, evt, restore);\n    });\n  },\n\n  /**\n   * 更新节点\n   * @param item 拖动的节点实例\n   * @param evt\n   */\n  update: function update(item, evt, restore) {\n    var origin = this.origin;\n    var model = item.get('model');\n    var nodeId = item.get('id');\n\n    if (!this.point[nodeId]) {\n      this.point[nodeId] = {\n        x: model.x || 0,\n        y: model.y || 0\n      };\n    }\n\n    var x = evt.x - origin.x + this.point[nodeId].x;\n    var y = evt.y - origin.y + this.point[nodeId].y;\n\n    if (restore) {\n      x += origin.x - evt.x;\n      y += origin.y - evt.y;\n    }\n\n    var pos = {\n      x: x,\n      y: y\n    };\n\n    if (this.get('updateEdge')) {\n      this.graph.updateItem(item, pos, false);\n    } else {\n      item.updatePosition(pos);\n    }\n  },\n\n  /**\n   * 限流更新节点\n   * @param item 拖动的节点实例\n   * @param evt\n   */\n  debounceUpdate: debounce(function (event) {\n    var targets = event.targets,\n        graph = event.graph,\n        point = event.point,\n        origin = event.origin,\n        evt = event.evt,\n        updateEdge = event.updateEdge,\n        updateFunc = event.updateFunc;\n    targets.map(function (item) {\n      var model = item.get('model');\n      var nodeId = item.get('id');\n\n      if (!point[nodeId]) {\n        point[nodeId] = {\n          x: model.x || 0,\n          y: model.y || 0\n        };\n      }\n\n      var x = evt.x - origin.x + point[nodeId].x;\n      var y = evt.y - origin.y + point[nodeId].y;\n      var pos = {\n        x: x,\n        y: y\n      };\n\n      if (updateEdge) {\n        graph.updateItem(item, pos, false);\n      } else {\n        item.updatePosition(pos);\n      }\n    });\n  }, 50, true),\n\n  /**\n   * 更新拖动元素时的delegate\n   * @param {Event} e 事件句柄\n   * @param {number} x 拖动单个元素时候的x坐标\n   * @param {number} y 拖动单个元素时候的y坐标\n   */\n  updateDelegate: function updateDelegate(e) {\n    var graph = this.graph;\n\n    if (!this.delegateRect) {\n      // 拖动多个\n      var parent_1 = graph.get('group');\n      var attrs = deepMix({}, Global.delegateStyle, this.delegateStyle);\n\n      var _a = this.calculationGroupPosition(e),\n          cx = _a.x,\n          cy = _a.y,\n          width = _a.width,\n          height = _a.height,\n          minX = _a.minX,\n          minY = _a.minY;\n\n      this.originPoint = {\n        x: cx,\n        y: cy,\n        width: width,\n        height: height,\n        minX: minX,\n        minY: minY\n      }; // model上的x, y是相对于图形中心的，delegateShape是g实例，x,y是绝对坐标\n\n      this.delegateRect = parent_1.addShape('rect', {\n        attrs: __assign({\n          width: width,\n          height: height,\n          x: cx,\n          y: cy\n        }, attrs),\n        name: 'rect-delegate-shape'\n      });\n      this.delegate = this.delegateRect;\n      this.delegateRect.set('capture', false);\n    } else {\n      var clientX = e.x - this.origin.x + this.originPoint.minX;\n      var clientY = e.y - this.origin.y + this.originPoint.minY;\n      this.delegateRect.attr({\n        x: clientX,\n        y: clientY\n      });\n    }\n  },\n\n  /**\n   * 计算delegate位置，包括左上角左边及宽度和高度\n   * @memberof ItemGroup\n   * @return {object} 计算出来的delegate坐标信息及宽高\n   */\n  calculationGroupPosition: function calculationGroupPosition(evt) {\n    var nodes = this.targets;\n\n    if (nodes.length === 0) {\n      nodes.push(evt.item);\n    }\n\n    var minx = Infinity;\n    var maxx = -Infinity;\n    var miny = Infinity;\n    var maxy = -Infinity; // 获取已节点的所有最大最小x y值\n\n    for (var i = 0; i < nodes.length; i++) {\n      var element = nodes[i];\n      var bbox = element.getBBox();\n      var minX = bbox.minX,\n          minY = bbox.minY,\n          maxX = bbox.maxX,\n          maxY = bbox.maxY;\n\n      if (minX < minx) {\n        minx = minX;\n      }\n\n      if (minY < miny) {\n        miny = minY;\n      }\n\n      if (maxX > maxx) {\n        maxx = maxX;\n      }\n\n      if (maxY > maxy) {\n        maxy = maxY;\n      }\n    }\n\n    var x = Math.floor(minx);\n    var y = Math.floor(miny);\n    var width = Math.ceil(maxx) - Math.floor(minx);\n    var height = Math.ceil(maxy) - Math.floor(miny);\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      minX: minx,\n      minY: miny\n    };\n  }\n};","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/@antv/g6-pc/es/behavior/drag-node.js"],"names":["__assign","deepMix","clone","debounce","Global","getDefaultCfg","updateEdge","delegateStyle","enableDelegate","onlyChangeComboSize","comboActiveState","selectedState","enableOptimize","enableDebounce","enableStack","getEvents","validationCombo","item","origin","destroyed","type","getType","onTouchStart","e","self","touches","originalEvent","event1","event2","preventDefault","console","warn","onDragStart","onTouchMove","onDragEnd","onDrag","evt","_this","currentShouldEnd","shouldBegin","call","hasLocked","group","getContainer","set","cachedCaptureItems","push","target","isAnchorPoint","get","graph","targets","targetCombo","nodes","findAllByState","currentNodeId","dragNodes","filter","node","nodeId","length","forEach","locked","beforeDragNodes","t","getModel","hidenEdge","edges","getEdges","edge","isVisible","getID","hide","x","y","point","originPoint","shouldUpdate","updateDelegate","debounceUpdate","map","update","_a","delegateRect","remove","show","refresh","stackData_1","before","combos","after","model","id","targetModel","pushStack","emit","items","targetItem","onDropCombo","shouldEnd","updatePositions","setItemState","updateCombos","targetComboModel_1","nodeModel","comboId","updateComboTree","updateCombo","onDropCanvas","undefined","onDropNode","newParentCombo","findById","combo","onDragEnter","onDragLeave","restore","updateFunc","pos","updateItem","updatePosition","event","parent_1","attrs","calculationGroupPosition","cx","cy","width","height","minX","minY","addShape","name","delegate","clientX","clientY","attr","minx","Infinity","maxx","miny","maxy","i","element","bbox","getBBox","maxX","maxY","Math","floor","ceil"],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\nimport { deepMix, clone, debounce } from '@antv/util';\nimport Global from '../global';\nexport default {\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      updateEdge: true,\n      delegateStyle: {},\n      // 是否开启delegate\n      enableDelegate: false,\n      // 拖动节点过程中是否只改变 Combo 的大小，而不改变其结构\n      onlyChangeComboSize: false,\n      // 拖动过程中目标 combo 状态样式\n      comboActiveState: '',\n      selectedState: 'selected',\n      enableOptimize: false,\n      enableDebounce: false,\n      enableStack: true\n    };\n  },\n  getEvents: function getEvents() {\n    return {\n      'node:dragstart': 'onDragStart',\n      'node:drag': 'onDrag',\n      'node:dragend': 'onDragEnd',\n      'combo:dragenter': 'onDragEnter',\n      'combo:dragleave': 'onDragLeave',\n      'combo:drop': 'onDropCombo',\n      'node:drop': 'onDropNode',\n      'canvas:drop': 'onDropCanvas',\n      'touchstart': 'onTouchStart',\n      'touchmove': 'onTouchMove',\n      'touchend': 'onDragEnd'\n    };\n  },\n  validationCombo: function validationCombo(item) {\n    if (!this.origin || !item || item.destroyed) {\n      return false;\n    }\n\n    var type = item.getType();\n\n    if (type !== 'combo') {\n      return false;\n    }\n\n    return true;\n  },\n  onTouchStart: function onTouchStart(e) {\n    if (!e.item) return;\n    var self = this;\n\n    try {\n      var touches = e.originalEvent.touches;\n      var event1 = touches[0];\n      var event2 = touches[1];\n\n      if (event1 && event2) {\n        return;\n      }\n\n      e.preventDefault();\n    } catch (e) {\n      console.warn('Touch original event not exist!');\n    }\n\n    self.onDragStart(e);\n  },\n  onTouchMove: function onTouchMove(e) {\n    var self = this;\n\n    try {\n      var touches = e.originalEvent.touches;\n      var event1 = touches[0];\n      var event2 = touches[1];\n\n      if (event1 && event2) {\n        self.onDragEnd(e);\n        return;\n      }\n\n      e.preventDefault();\n    } catch (e) {\n      console.warn('Touch original event not exist!');\n    }\n\n    self.onDrag(e);\n  },\n\n  /**\n   * 开始拖动节点\n   * @param evt\n   */\n  onDragStart: function onDragStart(evt) {\n    var _this = this;\n\n    this.currentShouldEnd = true;\n\n    if (!this.shouldBegin.call(this, evt)) {\n      return;\n    }\n\n    var item = evt.item;\n\n    if (!item || item.destroyed || item.hasLocked()) {\n      return;\n    } // 拖动时，设置拖动元素的 capture 为false，则不拾取拖动的元素\n\n\n    var group = item.getContainer();\n    group.set('capture', false);\n    if (!this.cachedCaptureItems) this.cachedCaptureItems = [];\n    this.cachedCaptureItems.push(item); // 如果拖动的target 是linkPoints / anchorPoints 则不允许拖动\n\n    var target = evt.target;\n\n    if (target) {\n      var isAnchorPoint = target.get('isAnchorPoint');\n\n      if (isAnchorPoint) {\n        return;\n      }\n    }\n\n    var graph = this.graph;\n    this.targets = []; // 将节点拖入到指定的 Combo\n\n    this.targetCombo = null; // 获取所有选中的元素\n\n    var nodes = graph.findAllByState('node', this.selectedState);\n    var currentNodeId = item.get('id'); // 当前拖动的节点是否是选中的节点\n\n    var dragNodes = nodes.filter(function (node) {\n      var nodeId = node.get('id');\n      return currentNodeId === nodeId;\n    }); // 只拖动当前节点\n\n    if (dragNodes.length === 0) {\n      this.targets.push(item);\n    } else if (nodes.length > 1) {\n      // 拖动多个节点\n      nodes.forEach(function (node) {\n        var locked = node.hasLocked();\n\n        if (!locked) {\n          _this.targets.push(node);\n        }\n      });\n    } else {\n      this.targets.push(item);\n    }\n\n    var beforeDragNodes = [];\n    this.targets.forEach(function (t) {\n      beforeDragNodes.push(clone(t.getModel()));\n    });\n    this.set('beforeDragNodes', beforeDragNodes);\n    this.hidenEdge = {};\n\n    if (this.get('updateEdge') && this.enableOptimize && !this.enableDelegate) {\n      this.targets.forEach(function (node) {\n        var edges = node.getEdges();\n        edges.forEach(function (edge) {\n          if (!edge.isVisible()) return;\n          _this.hidenEdge[edge.getID()] = true;\n          edge.hide();\n        });\n      });\n    }\n\n    this.origin = {\n      x: evt.x,\n      y: evt.y\n    };\n    this.point = {};\n    this.originPoint = {};\n  },\n\n  /**\n   * 持续拖动节点\n   * @param evt\n   */\n  onDrag: function onDrag(evt) {\n    var _this = this;\n\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.shouldUpdate.call(this, evt)) {\n      return;\n    }\n\n    if (this.get('enableDelegate')) {\n      this.updateDelegate(evt);\n    } else {\n      if (this.enableDebounce) this.debounceUpdate({\n        targets: this.targets,\n        graph: this.graph,\n        point: this.point,\n        origin: this.origin,\n        evt: evt,\n        updateEdge: this.get('updateEdge')\n      });else this.targets.map(function (target) {\n        _this.update(target, evt);\n      });\n    }\n  },\n\n  /**\n   * 拖动结束，设置拖动元素capture为true，更新元素位置，如果是拖动涉及到 combo，则更新 combo 结构\n   * @param evt\n   */\n  onDragEnd: function onDragEnd(evt) {\n    var _this = this;\n\n    var _a;\n\n    if (!this.origin) {\n      return;\n    } // 拖动结束后，设置拖动元素 group 的 capture 为 true，允许拾取拖动元素\n\n\n    (_a = this.cachedCaptureItems) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {\n      var group = item.getContainer();\n      group.set('capture', true);\n    });\n    this.cachedCaptureItems = [];\n\n    if (this.delegateRect) {\n      this.delegateRect.remove();\n      this.delegateRect = null;\n    }\n\n    if (this.get('updateEdge') && this.enableOptimize && !this.enableDelegate) {\n      this.targets.forEach(function (node) {\n        var edges = node.getEdges();\n        edges.forEach(function (edge) {\n          if (_this.hidenEdge[edge.getID()]) edge.show();\n          edge.refresh();\n        });\n      });\n    }\n\n    this.hidenEdge = {};\n    var graph = this.graph; // 拖动结束后，入栈\n\n    if (graph.get('enabledStack') && this.enableStack) {\n      var stackData_1 = {\n        before: {\n          nodes: [],\n          edges: [],\n          combos: []\n        },\n        after: {\n          nodes: [],\n          edges: [],\n          combos: []\n        }\n      };\n      this.get('beforeDragNodes').forEach(function (model) {\n        stackData_1.before.nodes.push({\n          id: model.id,\n          x: model.x,\n          y: model.y\n        });\n      });\n      this.targets.forEach(function (target) {\n        var targetModel = target.getModel();\n        stackData_1.after.nodes.push({\n          id: targetModel.id,\n          x: targetModel.x,\n          y: targetModel.y\n        });\n      });\n      graph.pushStack('update', clone(stackData_1));\n    } // 拖动结束后emit事件，将当前操作的节点抛出去，目标节点为null\n\n\n    graph.emit('dragnodeend', {\n      items: this.targets,\n      targetItem: null\n    });\n    this.point = {};\n    this.origin = null;\n    this.originPoint = {};\n    this.targets.length = 0;\n    this.targetCombo = null;\n  },\n\n  /**\n   * 拖动过程中将节点放置到 combo 上\n   * @param evt\n   */\n  onDropCombo: function onDropCombo(evt) {\n    var item = evt.item;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, item); // 若不允许结束，则将节点位置设置回初识位置。后面的逻辑仍需要执行\n\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.currentShouldEnd || !this.validationCombo(item)) return;\n    var graph = this.graph;\n\n    if (this.comboActiveState) {\n      graph.setItemState(item, this.comboActiveState, false);\n    }\n\n    this.targetCombo = item; // 拖动结束后是动态改变 Combo 大小还是将节点从 Combo 中删除\n\n    if (this.onlyChangeComboSize) {\n      // 拖动节点结束后，动态改变 Combo 的大小\n      graph.updateCombos();\n    } else {\n      var targetComboModel_1 = item.getModel();\n      this.targets.map(function (node) {\n        var nodeModel = node.getModel();\n\n        if (nodeModel.comboId !== targetComboModel_1.id) {\n          graph.updateComboTree(node, targetComboModel_1.id);\n        }\n      });\n      graph.updateCombo(item);\n    } // 将节点拖动到 combo 上面，emit事件抛出当前操作的节点及目标 combo\n\n\n    graph.emit('dragnodeend', {\n      items: this.targets,\n      targetItem: this.targetCombo\n    });\n  },\n  onDropCanvas: function onDropCanvas(evt) {\n    var graph = this.graph;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, undefined); // 若不允许结束，则将节点位置设置回初识位置。后面的逻辑仍需要执行\n\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.targets || this.targets.length === 0 || !this.currentShouldEnd) return;\n\n    if (this.onlyChangeComboSize) {\n      // 拖动节点结束后，动态改变 Combo 的大小\n      graph.updateCombos();\n    } else {\n      this.targets.map(function (node) {\n        // 拖动的节点有 comboId，即是从其他 combo 中拖出时才处理\n        var model = node.getModel();\n\n        if (model.comboId) {\n          graph.updateComboTree(node);\n        }\n      });\n    }\n  },\n\n  /**\n   * 拖动放置到某个 combo 中的子 node 上\n   * @param evt\n   */\n  onDropNode: function onDropNode(evt) {\n    if (!this.targets || this.targets.length === 0) return;\n    var self = this;\n    var item = evt.item;\n    var graph = self.graph;\n    var comboId = item.getModel().comboId;\n    var newParentCombo = comboId ? graph.findById(comboId) : undefined;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, newParentCombo); // 若不允许结束，则将节点位置设置回初识位置。后面的逻辑仍需要执行\n\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.currentShouldEnd) return;\n\n    if (this.onlyChangeComboSize) {\n      graph.updateCombos();\n    } else if (comboId) {\n      var combo = graph.findById(comboId);\n\n      if (self.comboActiveState) {\n        graph.setItemState(combo, self.comboActiveState, false);\n      }\n\n      this.targets.map(function (node) {\n        var nodeModel = node.getModel();\n\n        if (comboId !== nodeModel.comboId) {\n          graph.updateComboTree(node, comboId);\n        }\n      });\n      graph.updateCombo(combo);\n    } else {\n      this.targets.map(function (node) {\n        var model = node.getModel();\n\n        if (model.comboId) {\n          graph.updateComboTree(node);\n        }\n      });\n    } // 将节点拖动到另外个节点上面，emit 事件抛出当前操作的节点及目标节点\n\n\n    graph.emit('dragnodeend', {\n      items: this.targets,\n      targetItem: item\n    });\n  },\n\n  /**\n   * 将节点拖入到 Combo 中\n   * @param evt\n   */\n  onDragEnter: function onDragEnter(evt) {\n    var item = evt.item;\n    if (!this.validationCombo(item)) return;\n    var graph = this.graph;\n\n    if (this.comboActiveState) {\n      graph.setItemState(item, this.comboActiveState, true);\n    }\n  },\n\n  /**\n   * 将节点从 Combo 中拖出\n   * @param evt\n   */\n  onDragLeave: function onDragLeave(evt) {\n    var item = evt.item;\n    if (!this.validationCombo(item)) return;\n    var graph = this.graph;\n\n    if (this.comboActiveState) {\n      graph.setItemState(item, this.comboActiveState, false);\n    }\n  },\n  updatePositions: function updatePositions(evt, restore) {\n    var _this = this;\n\n    if (!this.targets || this.targets.length === 0) return; // 当开启 delegate 时，拖动结束后需要更新所有已选中节点的位置\n\n    if (this.get('enableDelegate')) {\n      if (this.enableDebounce) this.debounceUpdate({\n        targets: this.targets,\n        graph: this.graph,\n        point: this.point,\n        origin: this.origin,\n        evt: evt,\n        updateEdge: this.get('updateEdge'),\n        updateFunc: this.update\n      });else if (!restore) this.targets.map(function (node) {\n        return _this.update(node, evt);\n      });\n    } else this.targets.map(function (node) {\n      return _this.update(node, evt, restore);\n    });\n  },\n\n  /**\n   * 更新节点\n   * @param item 拖动的节点实例\n   * @param evt\n   */\n  update: function update(item, evt, restore) {\n    var origin = this.origin;\n    var model = item.get('model');\n    var nodeId = item.get('id');\n\n    if (!this.point[nodeId]) {\n      this.point[nodeId] = {\n        x: model.x || 0,\n        y: model.y || 0\n      };\n    }\n\n    var x = evt.x - origin.x + this.point[nodeId].x;\n    var y = evt.y - origin.y + this.point[nodeId].y;\n\n    if (restore) {\n      x += origin.x - evt.x;\n      y += origin.y - evt.y;\n    }\n\n    var pos = {\n      x: x,\n      y: y\n    };\n\n    if (this.get('updateEdge')) {\n      this.graph.updateItem(item, pos, false);\n    } else {\n      item.updatePosition(pos);\n    }\n  },\n\n  /**\n   * 限流更新节点\n   * @param item 拖动的节点实例\n   * @param evt\n   */\n  debounceUpdate: debounce(function (event) {\n    var targets = event.targets,\n        graph = event.graph,\n        point = event.point,\n        origin = event.origin,\n        evt = event.evt,\n        updateEdge = event.updateEdge,\n        updateFunc = event.updateFunc;\n    targets.map(function (item) {\n      var model = item.get('model');\n      var nodeId = item.get('id');\n\n      if (!point[nodeId]) {\n        point[nodeId] = {\n          x: model.x || 0,\n          y: model.y || 0\n        };\n      }\n\n      var x = evt.x - origin.x + point[nodeId].x;\n      var y = evt.y - origin.y + point[nodeId].y;\n      var pos = {\n        x: x,\n        y: y\n      };\n\n      if (updateEdge) {\n        graph.updateItem(item, pos, false);\n      } else {\n        item.updatePosition(pos);\n      }\n    });\n  }, 50, true),\n\n  /**\n   * 更新拖动元素时的delegate\n   * @param {Event} e 事件句柄\n   * @param {number} x 拖动单个元素时候的x坐标\n   * @param {number} y 拖动单个元素时候的y坐标\n   */\n  updateDelegate: function updateDelegate(e) {\n    var graph = this.graph;\n\n    if (!this.delegateRect) {\n      // 拖动多个\n      var parent_1 = graph.get('group');\n      var attrs = deepMix({}, Global.delegateStyle, this.delegateStyle);\n\n      var _a = this.calculationGroupPosition(e),\n          cx = _a.x,\n          cy = _a.y,\n          width = _a.width,\n          height = _a.height,\n          minX = _a.minX,\n          minY = _a.minY;\n\n      this.originPoint = {\n        x: cx,\n        y: cy,\n        width: width,\n        height: height,\n        minX: minX,\n        minY: minY\n      }; // model上的x, y是相对于图形中心的，delegateShape是g实例，x,y是绝对坐标\n\n      this.delegateRect = parent_1.addShape('rect', {\n        attrs: __assign({\n          width: width,\n          height: height,\n          x: cx,\n          y: cy\n        }, attrs),\n        name: 'rect-delegate-shape'\n      });\n      this.delegate = this.delegateRect;\n      this.delegateRect.set('capture', false);\n    } else {\n      var clientX = e.x - this.origin.x + this.originPoint.minX;\n      var clientY = e.y - this.origin.y + this.originPoint.minY;\n      this.delegateRect.attr({\n        x: clientX,\n        y: clientY\n      });\n    }\n  },\n\n  /**\n   * 计算delegate位置，包括左上角左边及宽度和高度\n   * @memberof ItemGroup\n   * @return {object} 计算出来的delegate坐标信息及宽高\n   */\n  calculationGroupPosition: function calculationGroupPosition(evt) {\n    var nodes = this.targets;\n\n    if (nodes.length === 0) {\n      nodes.push(evt.item);\n    }\n\n    var minx = Infinity;\n    var maxx = -Infinity;\n    var miny = Infinity;\n    var maxy = -Infinity; // 获取已节点的所有最大最小x y值\n\n    for (var i = 0; i < nodes.length; i++) {\n      var element = nodes[i];\n      var bbox = element.getBBox();\n      var minX = bbox.minX,\n          minY = bbox.minY,\n          maxX = bbox.maxX,\n          maxY = bbox.maxY;\n\n      if (minX < minx) {\n        minx = minX;\n      }\n\n      if (minY < miny) {\n        miny = minY;\n      }\n\n      if (maxX > maxx) {\n        maxx = maxX;\n      }\n\n      if (maxY > maxy) {\n        maxy = maxY;\n      }\n    }\n\n    var x = Math.floor(minx);\n    var y = Math.floor(miny);\n    var width = Math.ceil(maxx) - Math.floor(minx);\n    var height = Math.ceil(maxy) - Math.floor(miny);\n    return {\n      x: x,\n      y: y,\n      width: width,\n      height: height,\n      minX: minx,\n      minY: miny\n    };\n  }\n};"]},"metadata":{},"sourceType":"module"}