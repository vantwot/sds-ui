{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { HeatmapGridTriangulation } from '../../core/triangulation';\nvar heatmapGridFrag = \"precision highp float;\\nvarying vec4 v_color;\\nuniform float u_opacity: 1;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  gl_FragColor = v_color;\\n  gl_FragColor.a *= u_opacity;\\n\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\nvar heatmapGridVert = \"precision highp float;\\n// \\u591A\\u8FB9\\u5F62\\u9876\\u70B9\\u5750\\u6807\\nattribute vec3 a_Position;\\n// \\u591A\\u8FB9\\u5F62\\u7ECF\\u7EAC\\u5EA6\\u5750\\u6807\\nattribute vec3 a_Pos;\\nattribute float a_Size;\\nattribute vec4 a_Color;\\nuniform vec2 u_radius;\\nuniform float u_coverage: 0.9;\\nuniform float u_angle: 0;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_Mvp;\\nvarying vec4 v_color;\\n\\nuniform vec2 u_SceneCenterMKT;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"project\\\"\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  v_color = a_Color;\\n    \\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\\n  vec2 offset =(vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage));\\n  vec2 lnglat = unProjectFlat(a_Pos.xy + offset);\\n \\n  // vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\\n  // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0., 1.0));\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\n    // gl_Position = u_Mvp * (vec4(project_pos.xy, 0., 1.0));\\n    // gl_Position = u_Mvp * (vec4(a_Pos.xy + offset, 0., 1.0));\\n    vec2 customLnglat = customProject(lnglat) - u_SceneCenterMKT;\\n    vec4 project_pos = project_position(vec4(customLnglat, 0, 1.0));\\n    gl_Position = u_Mvp * vec4(project_pos.xy, 0.0, 1.0);\\n  } else {\\n    vec4 project_pos = project_position(vec4(lnglat, 0, 1.0));\\n    gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy, 0., 1.0));\\n  }\\n  setPickingColor(a_PickingColor);\\n}\\n\";\n\nvar HexagonModel = function (_BaseModel) {\n  _inherits(HexagonModel, _BaseModel);\n\n  var _super = _createSuper(HexagonModel);\n\n  function HexagonModel() {\n    _classCallCheck(this, HexagonModel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(HexagonModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          coverage = _ref.coverage,\n          angle = _ref.angle;\n\n      return {\n        u_opacity: opacity || 1.0,\n        u_coverage: coverage || 0.9,\n        u_angle: angle || 0,\n        u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset]\n      };\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      return this.buildModels();\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return [this.layer.buildLayerModel({\n        moduleName: 'hexagonheatmap',\n        vertexShader: heatmapGridVert,\n        fragmentShader: heatmapGridFrag,\n        triangulation: HeatmapGridTriangulation,\n        depth: {\n          enable: false\n        },\n        primitive: gl.TRIANGLES,\n        blend: this.getBlend()\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'pos',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Pos',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx) {\n            var coordinates = feature.version === 'GAODE2.x' ? feature.originCoordinates : feature.coordinates;\n            return [coordinates[0], coordinates[1], 0];\n          }\n        }\n      });\n    }\n  }]);\n\n  return HexagonModel;\n}(BaseModel);\n\nexport { HexagonModel as default };","map":{"version":3,"sources":["../../../src/heatmap/models/hexagon.ts"],"names":["HexagonModel","BaseModel","opacity","coverage","angle","u_opacity","u_coverage","u_angle","u_radius","moduleName","vertexShader","fragmentShader","triangulation","depth","enable","primitive","gl","blend","name","type","AttributeType","descriptor","buffer","usage","data","FLOAT","size","update","coordinates","feature"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,aAAA,EAAA,EAAA,QAAA,eAAA;AAOA,OAAA,SAAA,MAAA,sBAAA;AACA,SAAA,wBAAA,QAAA,0BAAA;;;;IAUqBA,Y;;;;;;;;;;;;;WACnB,SAAA,YAAA,GAAqC;AACnC,UAAA,IAAA,GAII,KAAA,KAAA,CAJJ,cAII,EAJJ;AAAA,UACEE,OADF,GAAA,IAAA,CAAA,OAAA;AAAA,UAEEC,QAFF,GAAA,IAAA,CAAA,QAAA;AAAA,UAGEC,KAHF,GAAA,IAAA,CAAA,KAAA;;AAKA,aAAO;AACLC,QAAAA,SAAS,EAAEH,OAAO,IADb,GAAA;AAELI,QAAAA,UAAU,EAAEH,QAAQ,IAFf,GAAA;AAGLI,QAAAA,OAAO,EAAEH,KAAK,IAHT,CAAA;AAILI,QAAAA,QAAQ,EAAE,CACR,KAAA,KAAA,CAAA,SAAA,GAAA,IAAA,CADQ,OAAA,EAER,KAAA,KAAA,CAAA,SAAA,GAAA,IAAA,CAFQ,OAAA;AAJL,OAAP;AASD;;;WAED,SAAA,UAAA,GAA8B;AAC5B,aAAO,KAAP,WAAO,EAAP;AACD;;;WAED,SAAA,WAAA,GAA+B;AAC7B,aAAO,CACL,KAAA,KAAA,CAAA,eAAA,CAA2B;AACzBC,QAAAA,UAAU,EADe,gBAAA;AAEzBC,QAAAA,YAAY,EAFa,eAAA;AAGzBC,QAAAA,cAAc,EAHW,eAAA;AAIzBC,QAAAA,aAAa,EAJY,wBAAA;AAKzBC,QAAAA,KAAK,EAAE;AAAEC,UAAAA,MAAM,EAAE;AAAV,SALkB;AAMzBC,QAAAA,SAAS,EAAEC,EAAE,CANY,SAAA;AAOzBC,QAAAA,KAAK,EAAE,KAAA,QAAA;AAPkB,OAA3B,CADK,CAAP;AAWD;;;WACD,SAAA,yBAAA,GAAsC;AACpC,WAAA,qBAAA,CAAA,sBAAA,CAAkD;AAChDC,QAAAA,IAAI,EAD4C,KAAA;AAEhDC,QAAAA,IAAI,EAAEC,aAAa,CAF6B,SAAA;AAGhDC,QAAAA,UAAU,EAAE;AACVH,UAAAA,IAAI,EADM,OAAA;AAEVI,UAAAA,MAAM,EAAE;AAENC,YAAAA,KAAK,EAAEP,EAAE,CAFH,YAAA;AAGNQ,YAAAA,IAAI,EAHE,EAAA;AAINL,YAAAA,IAAI,EAAEH,EAAE,CAACS;AAJH,WAFE;AAQVC,UAAAA,IAAI,EARM,CAAA;AASVC,UAAAA,MAAM,EAAE,SAAA,MAAA,CAAA,OAAA,EAAA,UAAA,EAAiD;AAEvD,gBAAMC,WAAW,GAAIC,OAAO,CAAPA,OAAAA,KAAAA,UAAAA,GACjBA,OAAO,CADUA,iBAAAA,GAEjBA,OAAO,CAFX,WAAA;AAKA,mBAAO,CAACD,WAAW,CAAZ,CAAY,CAAZ,EAAiBA,WAAW,CAA5B,CAA4B,CAA5B,EAAP,CAAO,CAAP;AACD;AAjBS;AAHoC,OAAlD;AAuBD;;;;EA3DuC3B,S;;SAArBD,Y","sourcesContent":["import {\n  AttributeType,\n  gl,\n  IEncodeFeature,\n  IModel,\n  IModelUniform,\n} from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { HeatmapGridTriangulation } from '../../core/triangulation';\nimport heatmapGridFrag from '../shaders/hexagon_frag.glsl';\nimport heatmapGridVert from '../shaders/hexagon_vert.glsl';\n\ninterface IHeatMapLayerStyleOptions {\n  opacity: number;\n  coverage: number;\n  angle: number;\n}\n\nexport default class HexagonModel extends BaseModel {\n  public getUninforms(): IModelUniform {\n    const {\n      opacity,\n      coverage,\n      angle,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n    return {\n      u_opacity: opacity || 1.0,\n      u_coverage: coverage || 0.9,\n      u_angle: angle || 0,\n      u_radius: [\n        this.layer.getSource().data.xOffset,\n        this.layer.getSource().data.yOffset,\n      ],\n    };\n  }\n\n  public initModels(): IModel[] {\n    return this.buildModels();\n  }\n\n  public buildModels(): IModel[] {\n    return [\n      this.layer.buildLayerModel({\n        moduleName: 'hexagonheatmap',\n        vertexShader: heatmapGridVert,\n        fragmentShader: heatmapGridFrag,\n        triangulation: HeatmapGridTriangulation,\n        depth: { enable: false },\n        primitive: gl.TRIANGLES,\n        blend: this.getBlend(),\n      }),\n    ];\n  }\n  protected registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'pos', // 顶点经纬度位置\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Pos',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 3,\n        update: (feature: IEncodeFeature, featureIdx: number) => {\n          // const coordinates = (feature.verison==='GAODE2.x'?feature.originoordinates:feature.coordinates) as number[];\n          const coordinates = (feature.version === 'GAODE2.x'\n            ? feature.originCoordinates\n            : feature.coordinates) as number[];\n          // const coordinates = feature.coordinates as number[];\n          // const coordinates = feature.originCoordinates as number[];\n          return [coordinates[0], coordinates[1], 0];\n        },\n      },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}