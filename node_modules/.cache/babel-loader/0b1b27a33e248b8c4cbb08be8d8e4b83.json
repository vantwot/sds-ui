{"ast":null,"code":"import { FunctionExt } from '../../util';\nimport { Point, Line, Angle } from '../../geometry';\nimport { resolve } from './manhattan/options';\nimport { manhattan } from './manhattan/index';\nconst defaults = {\n  maxDirectionChange: 45,\n\n  // an array of directions to find next points on the route\n  // different from start/end directions\n  directions() {\n    const step = resolve(this.step, this);\n    const cost = resolve(this.cost, this);\n    const diagonalCost = Math.ceil(Math.sqrt(step * step << 1)); // eslint-disable-line no-bitwise\n\n    return [{\n      cost,\n      offsetX: step,\n      offsetY: 0\n    }, {\n      cost: diagonalCost,\n      offsetX: step,\n      offsetY: step\n    }, {\n      cost,\n      offsetX: 0,\n      offsetY: step\n    }, {\n      cost: diagonalCost,\n      offsetX: -step,\n      offsetY: step\n    }, {\n      cost,\n      offsetX: -step,\n      offsetY: 0\n    }, {\n      cost: diagonalCost,\n      offsetX: -step,\n      offsetY: -step\n    }, {\n      cost,\n      offsetX: 0,\n      offsetY: -step\n    }, {\n      cost: diagonalCost,\n      offsetX: step,\n      offsetY: -step\n    }];\n  },\n\n  // a simple route used in situations when main routing method fails\n  // (exceed max number of loop iterations, inaccessible)\n  fallbackRoute(from, to, options) {\n    // Find a route which breaks by 45 degrees ignoring all obstacles.\n    const theta = from.theta(to);\n    const route = [];\n    let a = {\n      x: to.x,\n      y: from.y\n    };\n    let b = {\n      x: from.x,\n      y: to.y\n    };\n\n    if (theta % 180 > 90) {\n      const t = a;\n      a = b;\n      b = t;\n    }\n\n    const p1 = theta % 90 < 45 ? a : b;\n    const l1 = new Line(from, p1);\n    const alpha = 90 * Math.ceil(theta / 90);\n    const p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1);\n    const l2 = new Line(to, p2);\n    const intersectionPoint = l1.intersectsWithLine(l2);\n    const point = intersectionPoint || to;\n    const directionFrom = intersectionPoint ? point : from;\n    const quadrant = 360 / options.directions.length;\n    const angleTheta = directionFrom.theta(to);\n    const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);\n    const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n    options.previousDirectionAngle = directionAngle;\n    if (point) route.push(point.round());\n    route.push(to);\n    return route;\n  }\n\n};\nexport const metro = function (vertices, options, linkView) {\n  return FunctionExt.call(manhattan, this, vertices, Object.assign(Object.assign({}, defaults), options), linkView);\n};","map":{"version":3,"sources":["../../../src/registry/router/metro.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { FunctionExt } from '../../util';\nimport { Point, Line, Angle } from '../../geometry';\nimport { resolve } from './manhattan/options';\nimport { manhattan } from './manhattan/index';\nconst defaults = {\n    maxDirectionChange: 45,\n    // an array of directions to find next points on the route\n    // different from start/end directions\n    directions() {\n        const step = resolve(this.step, this);\n        const cost = resolve(this.cost, this);\n        const diagonalCost = Math.ceil(Math.sqrt((step * step) << 1)); // eslint-disable-line no-bitwise\n        return [\n            { cost, offsetX: step, offsetY: 0 },\n            { cost: diagonalCost, offsetX: step, offsetY: step },\n            { cost, offsetX: 0, offsetY: step },\n            { cost: diagonalCost, offsetX: -step, offsetY: step },\n            { cost, offsetX: -step, offsetY: 0 },\n            { cost: diagonalCost, offsetX: -step, offsetY: -step },\n            { cost, offsetX: 0, offsetY: -step },\n            { cost: diagonalCost, offsetX: step, offsetY: -step },\n        ];\n    },\n    // a simple route used in situations when main routing method fails\n    // (exceed max number of loop iterations, inaccessible)\n    fallbackRoute(from, to, options) {\n        // Find a route which breaks by 45 degrees ignoring all obstacles.\n        const theta = from.theta(to);\n        const route = [];\n        let a = { x: to.x, y: from.y };\n        let b = { x: from.x, y: to.y };\n        if (theta % 180 > 90) {\n            const t = a;\n            a = b;\n            b = t;\n        }\n        const p1 = theta % 90 < 45 ? a : b;\n        const l1 = new Line(from, p1);\n        const alpha = 90 * Math.ceil(theta / 90);\n        const p2 = Point.fromPolar(l1.squaredLength(), Angle.toRad(alpha + 135), p1);\n        const l2 = new Line(to, p2);\n        const intersectionPoint = l1.intersectsWithLine(l2);\n        const point = intersectionPoint || to;\n        const directionFrom = intersectionPoint ? point : from;\n        const quadrant = 360 / options.directions.length;\n        const angleTheta = directionFrom.theta(to);\n        const normalizedAngle = Angle.normalize(angleTheta + quadrant / 2);\n        const directionAngle = quadrant * Math.floor(normalizedAngle / quadrant);\n        options.previousDirectionAngle = directionAngle;\n        if (point)\n            route.push(point.round());\n        route.push(to);\n        return route;\n    },\n};\nexport const metro = function (vertices, options, linkView) {\n    return FunctionExt.call(manhattan, this, vertices, Object.assign(Object.assign({}, defaults), options), linkView);\n};\n//# sourceMappingURL=metro.js.map"]},"metadata":{},"sourceType":"module"}