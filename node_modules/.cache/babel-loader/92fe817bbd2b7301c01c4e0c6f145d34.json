{"ast":null,"code":"var DEGREES_TO_RADIANS = Math.PI / 180;\nvar TILE_SIZE = 512;\nvar EARTH_CIRCUMFERENCE = 40.03e6;\nexport function getDistanceScales(_ref) {\n  var _ref$latitude = _ref.latitude,\n      latitude = _ref$latitude === void 0 ? 0 : _ref$latitude,\n      _ref$zoom = _ref.zoom,\n      zoom = _ref$zoom === void 0 ? 0 : _ref$zoom,\n      scale = _ref.scale,\n      _ref$highPrecision = _ref.highPrecision,\n      highPrecision = _ref$highPrecision === void 0 ? false : _ref$highPrecision,\n      _ref$flipY = _ref.flipY,\n      flipY = _ref$flipY === void 0 ? false : _ref$flipY;\n  scale = scale !== undefined ? scale : Math.pow(2, zoom);\n  var result = {};\n  var worldSize = TILE_SIZE * scale;\n  var latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n  var pixelsPerDegreeX = worldSize / 360;\n  var pixelsPerDegreeY = pixelsPerDegreeX / latCosine;\n  var altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n  result.pixelsPerMeter = [altPixelsPerMeter, -altPixelsPerMeter, altPixelsPerMeter];\n  result.metersPerPixel = [1 / altPixelsPerMeter, -1 / altPixelsPerMeter, 1 / altPixelsPerMeter];\n  result.pixelsPerDegree = [pixelsPerDegreeX, -pixelsPerDegreeY, altPixelsPerMeter];\n  result.degreesPerPixel = [1 / pixelsPerDegreeX, -1 / pixelsPerDegreeY, 1 / altPixelsPerMeter];\n\n  if (highPrecision) {\n    var latCosine2 = DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS) / latCosine;\n    var pixelsPerDegreeY2 = pixelsPerDegreeX * latCosine2 / 2;\n    var altPixelsPerDegree2 = worldSize / EARTH_CIRCUMFERENCE * latCosine2;\n    var altPixelsPerMeter2 = altPixelsPerDegree2 / pixelsPerDegreeY * altPixelsPerMeter;\n    result.pixelsPerDegree2 = [0, -pixelsPerDegreeY2, altPixelsPerDegree2];\n    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];\n\n    if (flipY) {\n      result.pixelsPerDegree2[1] = -result.pixelsPerDegree2[1];\n      result.pixelsPerMeter2[1] = -result.pixelsPerMeter2[1];\n    }\n  }\n\n  if (flipY) {\n    result.pixelsPerMeter[1] = -result.pixelsPerMeter[1];\n    result.metersPerPixel[1] = -result.metersPerPixel[1];\n    result.pixelsPerDegree[1] = -result.pixelsPerDegree[1];\n    result.degreesPerPixel[1] = -result.degreesPerPixel[1];\n  }\n\n  return result;\n}","map":{"version":3,"sources":["../../src/utils/project.ts"],"names":["DEGREES_TO_RADIANS","Math","TILE_SIZE","EARTH_CIRCUMFERENCE","latitude","zoom","scale","highPrecision","flipY","result","worldSize","latCosine","pixelsPerDegreeX","pixelsPerDegreeY","altPixelsPerMeter","latCosine2","pixelsPerDegreeY2","altPixelsPerDegree2","altPixelsPerMeter2"],"mappings":"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","sourcesContent":["const DEGREES_TO_RADIANS = Math.PI / 180;\nconst TILE_SIZE = 512;\n// Average circumference (40075 km equatorial, 40007 km meridional)\nconst EARTH_CIRCUMFERENCE = 40.03e6;\n\ninterface IDistanceScales {\n  pixelsPerMeter: [number, number, number];\n  metersPerPixel: [number, number, number];\n  pixelsPerDegree: [number, number, number];\n  degreesPerPixel: [number, number, number];\n  pixelsPerDegree2: [number, number, number];\n  pixelsPerMeter2: [number, number, number];\n}\n\n/**\n * Calculate distance scales in meters around current lat/lon, both for\n * degrees and pixels.\n * In mercator projection mode, the distance scales vary significantly\n * with latitude.\n */\nexport function getDistanceScales({\n  latitude = 0,\n  zoom = 0,\n  scale,\n  highPrecision = false,\n  flipY = false,\n}: Partial<{\n  latitude: number;\n  zoom: number;\n  scale: number | undefined;\n  highPrecision: boolean;\n  flipY: boolean;\n}>): IDistanceScales {\n  // Calculate scale from zoom if not provided\n  scale = scale !== undefined ? scale : Math.pow(2, zoom);\n\n  // @ts-ignore\n  const result: IDistanceScales = {};\n  const worldSize = TILE_SIZE * scale;\n  const latCosine = Math.cos(latitude * DEGREES_TO_RADIANS);\n\n  /**\n   * Number of pixels occupied by one degree longitude around current lat/lon:\n   *  pixelsPerDegreeX = d(lngLatToWorld([lng, lat])[0])/d(lng)\n   *     = scale * TILE_SIZE * DEGREES_TO_RADIANS / (2 * PI)\n   *   pixelsPerDegreeY = d(lngLatToWorld([lng, lat])[1])/d(lat)\n   *     = -scale * TILE_SIZE * DEGREES_TO_RADIANS / cos(lat * DEGREES_TO_RADIANS)  / (2 * PI)\n   */\n  const pixelsPerDegreeX = worldSize / 360;\n  const pixelsPerDegreeY = pixelsPerDegreeX / latCosine;\n\n  /**\n   * Number of pixels occupied by one meter around current lat/lon:\n   */\n  const altPixelsPerMeter = worldSize / EARTH_CIRCUMFERENCE / latCosine;\n\n  /**\n   * LngLat: longitude -> east and latitude -> north (bottom left)\n   * UTM meter offset: x -> east and y -> north (bottom left)\n   * World space: x -> east and y -> south (top left)\n   *\n   * Y needs to be flipped when converting delta degree/meter to delta pixels\n   */\n  result.pixelsPerMeter = [\n    altPixelsPerMeter,\n    -altPixelsPerMeter,\n    altPixelsPerMeter,\n  ];\n  result.metersPerPixel = [\n    1 / altPixelsPerMeter,\n    -1 / altPixelsPerMeter,\n    1 / altPixelsPerMeter,\n  ];\n\n  result.pixelsPerDegree = [\n    pixelsPerDegreeX,\n    -pixelsPerDegreeY,\n    altPixelsPerMeter,\n  ];\n  result.degreesPerPixel = [\n    1 / pixelsPerDegreeX,\n    -1 / pixelsPerDegreeY,\n    1 / altPixelsPerMeter,\n  ];\n\n  /**\n   * Taylor series 2nd order for 1/latCosine\n   *  f'(a) * (x - a)\n   *     = d(1/cos(lat * DEGREES_TO_RADIANS))/d(lat) * dLat\n   *     = DEGREES_TO_RADIANS * tan(lat * DEGREES_TO_RADIANS) / cos(lat * DEGREES_TO_RADIANS) * dLat\n   */\n  if (highPrecision) {\n    const latCosine2 =\n      (DEGREES_TO_RADIANS * Math.tan(latitude * DEGREES_TO_RADIANS)) /\n      latCosine;\n    const pixelsPerDegreeY2 = (pixelsPerDegreeX * latCosine2) / 2;\n\n    const altPixelsPerDegree2 = (worldSize / EARTH_CIRCUMFERENCE) * latCosine2;\n    const altPixelsPerMeter2 =\n      (altPixelsPerDegree2 / pixelsPerDegreeY) * altPixelsPerMeter;\n\n    result.pixelsPerDegree2 = [0, -pixelsPerDegreeY2, altPixelsPerDegree2];\n    result.pixelsPerMeter2 = [altPixelsPerMeter2, 0, altPixelsPerMeter2];\n\n    if (flipY) {\n      result.pixelsPerDegree2[1] = -result.pixelsPerDegree2[1];\n      result.pixelsPerMeter2[1] = -result.pixelsPerMeter2[1];\n    }\n  }\n\n  if (flipY) {\n    result.pixelsPerMeter[1] = -result.pixelsPerMeter[1];\n    result.metersPerPixel[1] = -result.metersPerPixel[1];\n    result.pixelsPerDegree[1] = -result.pixelsPerDegree[1];\n    result.degreesPerPixel[1] = -result.degreesPerPixel[1];\n  }\n\n  // Main results, used for converting meters to latlng deltas and scaling offsets\n  return result;\n}\n"]},"metadata":{},"sourceType":"module"}