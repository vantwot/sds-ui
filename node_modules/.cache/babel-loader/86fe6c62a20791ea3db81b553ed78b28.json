{"ast":null,"code":"import { Point } from './point';\nimport { Line } from './line';\nimport { Rectangle } from './rectangle';\nimport { Polyline } from './polyline';\nimport { Geometry } from './geometry';\nexport class Curve extends Geometry {\n  constructor(start, controlPoint1, controlPoint2, end) {\n    super();\n    this.PRECISION = 3;\n    this.start = Point.create(start);\n    this.controlPoint1 = Point.create(controlPoint1);\n    this.controlPoint2 = Point.create(controlPoint2);\n    this.end = Point.create(end);\n  }\n\n  get [Symbol.toStringTag]() {\n    return Curve.toStringTag;\n  }\n\n  bbox() {\n    const start = this.start;\n    const controlPoint1 = this.controlPoint1;\n    const controlPoint2 = this.controlPoint2;\n    const end = this.end;\n    const x0 = start.x;\n    const y0 = start.y;\n    const x1 = controlPoint1.x;\n    const y1 = controlPoint1.y;\n    const x2 = controlPoint2.x;\n    const y2 = controlPoint2.y;\n    const x3 = end.x;\n    const y3 = end.y;\n    const points = []; // local extremes\n\n    const tvalues = []; // t values of local extremes\n\n    const bounds = [[], []];\n    let a;\n    let b;\n    let c;\n    let t;\n    let t1;\n    let t2;\n    let b2ac;\n    let sqrtb2ac;\n\n    for (let i = 0; i < 2; i += 1) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue;\n        }\n\n        t = -c / b;\n        if (t > 0 && t < 1) tvalues.push(t);\n        continue;\n      }\n\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = Math.sqrt(b2ac);\n      if (b2ac < 0) continue;\n      t1 = (-b + sqrtb2ac) / (2 * a);\n      if (t1 > 0 && t1 < 1) tvalues.push(t1);\n      t2 = (-b - sqrtb2ac) / (2 * a);\n      if (t2 > 0 && t2 < 1) tvalues.push(t2);\n    }\n\n    let x;\n    let y;\n    let mt;\n    let j = tvalues.length;\n    const jlen = j;\n\n    while (j) {\n      j -= 1;\n      t = tvalues[j];\n      mt = 1 - t;\n      x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[0][j] = x;\n      y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n      bounds[1][j] = y;\n      points[j] = {\n        X: x,\n        Y: y\n      };\n    }\n\n    tvalues[jlen] = 0;\n    tvalues[jlen + 1] = 1;\n    points[jlen] = {\n      X: x0,\n      Y: y0\n    };\n    points[jlen + 1] = {\n      X: x3,\n      Y: y3\n    };\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    tvalues.length = jlen + 2;\n    bounds[0].length = jlen + 2;\n    bounds[1].length = jlen + 2;\n    points.length = jlen + 2;\n    const left = Math.min.apply(null, bounds[0]);\n    const top = Math.min.apply(null, bounds[1]);\n    const right = Math.max.apply(null, bounds[0]);\n    const bottom = Math.max.apply(null, bounds[1]);\n    return new Rectangle(left, top, right - left, bottom - top);\n  }\n\n  closestPoint(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.pointAtT(this.closestPointT(p, options));\n  }\n\n  closestPointLength(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const opts = this.getOptions(options);\n    return this.lengthAtT(this.closestPointT(p, opts), opts);\n  }\n\n  closestPointNormalizedLength(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const opts = this.getOptions(options);\n    const cpLength = this.closestPointLength(p, opts);\n\n    if (!cpLength) {\n      return 0;\n    }\n\n    const length = this.length(opts);\n\n    if (length === 0) {\n      return 0;\n    }\n\n    return cpLength / length;\n  }\n\n  closestPointT(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const precision = this.getPrecision(options);\n    const subdivisions = this.getDivisions(options);\n    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n\n    let investigatedSubdivision = null;\n    let investigatedSubdivisionStartT = 0;\n    let investigatedSubdivisionEndT = 0;\n    let distFromStart = 0;\n    let distFromEnd = 0;\n    let chordLength = 0;\n    let minSumDist = null;\n    const count = subdivisions.length;\n    let piece = count > 0 ? 1 / count : 0;\n    subdivisions.forEach((division, i) => {\n      const startDist = division.start.distance(p);\n      const endDist = division.end.distance(p);\n      const sumDist = startDist + endDist;\n\n      if (minSumDist == null || sumDist < minSumDist) {\n        investigatedSubdivision = division;\n        investigatedSubdivisionStartT = i * piece;\n        investigatedSubdivisionEndT = (i + 1) * piece;\n        distFromStart = startDist;\n        distFromEnd = endDist;\n        minSumDist = sumDist;\n        chordLength = division.endpointDistance();\n      }\n    }); // Recursively divide investigated subdivision, until distance between\n    // baselinePoint and closest path endpoint is within `10^(-precision)`,\n    // then return the closest endpoint of that final subdivision.\n    // eslint-disable-next-line\n\n    while (true) {\n      // check if we have reached at least one required observed precision\n      // - calculated as: the difference in distances from point to start and end divided by the distance\n      // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n      // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n      // - this criterion works well for points lying far away from the curve\n      const startPrecisionRatio = distFromStart ? Math.abs(distFromStart - distFromEnd) / distFromStart : 0;\n      const endPrecisionRatio = distFromEnd != null ? Math.abs(distFromStart - distFromEnd) / distFromEnd : 0;\n      const hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio; // check if we have reached at least one required minimal distance\n      // - calculated as: the subdivision chord length multiplied by precisionRatio\n      // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n      // - this is a backup criterion that works well for points lying \"almost at\" the curve\n\n      const hasMiniStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n      const hasMiniEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n      const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;\n\n      if (hasRequiredPrecision || hasMiniDistance) {\n        return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n      } // otherwise, set up for next iteration\n\n\n      const divided = investigatedSubdivision.divide(0.5);\n      piece /= 2;\n      const startDist1 = divided[0].start.distance(p);\n      const endDist1 = divided[0].end.distance(p);\n      const sumDist1 = startDist1 + endDist1;\n      const startDist2 = divided[1].start.distance(p);\n      const endDist2 = divided[1].end.distance(p);\n      const sumDist2 = startDist2 + endDist2;\n\n      if (sumDist1 <= sumDist2) {\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= piece;\n        distFromStart = startDist1;\n        distFromEnd = endDist1;\n      } else {\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += piece;\n        distFromStart = startDist2;\n        distFromEnd = endDist2;\n      }\n    }\n  }\n\n  closestPointTangent(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.tangentAtT(this.closestPointT(p, options));\n  }\n\n  containsPoint(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const polyline = this.toPolyline(options);\n    return polyline.containsPoint(p);\n  }\n\n  divideAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (ratio <= 0) {\n      return this.divideAtT(0);\n    }\n\n    if (ratio >= 1) {\n      return this.divideAtT(1);\n    }\n\n    const t = this.tAt(ratio, options);\n    return this.divideAtT(t);\n  }\n\n  divideAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const t = this.tAtLength(length, options);\n    return this.divideAtT(t);\n  }\n\n  divide(t) {\n    return this.divideAtT(t);\n  }\n\n  divideAtT(t) {\n    const start = this.start;\n    const controlPoint1 = this.controlPoint1;\n    const controlPoint2 = this.controlPoint2;\n    const end = this.end;\n\n    if (t <= 0) {\n      return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];\n    }\n\n    if (t >= 1) {\n      return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];\n    }\n\n    const dividerPoints = this.getSkeletonPoints(t);\n    const startControl1 = dividerPoints.startControlPoint1;\n    const startControl2 = dividerPoints.startControlPoint2;\n    const divider = dividerPoints.divider;\n    const dividerControl1 = dividerPoints.dividerControlPoint1;\n    const dividerControl2 = dividerPoints.dividerControlPoint2;\n    return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];\n  }\n\n  endpointDistance() {\n    return this.start.distance(this.end);\n  }\n\n  getSkeletonPoints(t) {\n    const start = this.start;\n    const control1 = this.controlPoint1;\n    const control2 = this.controlPoint2;\n    const end = this.end; // shortcuts for `t` values that are out of range\n\n    if (t <= 0) {\n      return {\n        startControlPoint1: start.clone(),\n        startControlPoint2: start.clone(),\n        divider: start.clone(),\n        dividerControlPoint1: control1.clone(),\n        dividerControlPoint2: control2.clone()\n      };\n    }\n\n    if (t >= 1) {\n      return {\n        startControlPoint1: control1.clone(),\n        startControlPoint2: control2.clone(),\n        divider: end.clone(),\n        dividerControlPoint1: end.clone(),\n        dividerControlPoint2: end.clone()\n      };\n    }\n\n    const midpoint1 = new Line(start, control1).pointAt(t);\n    const midpoint2 = new Line(control1, control2).pointAt(t);\n    const midpoint3 = new Line(control2, end).pointAt(t);\n    const subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n    const subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n    const divideLine = new Line(subControl1, subControl2).pointAt(t);\n    return {\n      startControlPoint1: midpoint1,\n      startControlPoint2: subControl1,\n      divider: divideLine,\n      dividerControlPoint1: subControl2,\n      dividerControlPoint2: midpoint3\n    };\n  }\n\n  getSubdivisions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const precision = this.getPrecision(options);\n    let subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n\n    if (precision === 0) {\n      return subdivisions;\n    }\n\n    let previousLength = this.endpointDistance();\n    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n    // Recursively divide curve at `t = 0.5`, until the difference between\n    // observed length at subsequent iterations is lower than precision.\n\n    let iteration = 0; // eslint-disable-next-line\n\n    while (true) {\n      iteration += 1;\n      const divisions = [];\n      subdivisions.forEach(c => {\n        // dividing at t = 0.5 (not at middle length!)\n        const divided = c.divide(0.5);\n        divisions.push(divided[0], divided[1]);\n      }); // measure new length\n\n      const length = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0); // check if we have reached required observed precision\n      // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n      // not a problem for further iterations because cubic curves cannot have more than two local extrema\n      // (i.e. cubic curves cannot intersect the baseline more than once)\n      // therefore two subsequent iterations cannot produce sampling with equal length\n\n      const ratio = length !== 0 ? (length - previousLength) / length : 0;\n\n      if (iteration > 1 && ratio < precisionRatio) {\n        return divisions;\n      }\n\n      subdivisions = divisions;\n      previousLength = length;\n    }\n  }\n\n  length() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const divisions = this.getDivisions(options);\n    return divisions.reduce((memo, c) => {\n      return memo + c.endpointDistance();\n    }, 0);\n  }\n\n  lengthAtT(t) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (t <= 0) {\n      return 0;\n    }\n\n    const precision = options.precision === undefined ? this.PRECISION : options.precision;\n    const subCurve = this.divide(t)[0];\n    return subCurve.length({\n      precision\n    });\n  }\n\n  pointAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (ratio <= 0) {\n      return this.start.clone();\n    }\n\n    if (ratio >= 1) {\n      return this.end.clone();\n    }\n\n    const t = this.tAt(ratio, options);\n    return this.pointAtT(t);\n  }\n\n  pointAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const t = this.tAtLength(length, options);\n    return this.pointAtT(t);\n  }\n\n  pointAtT(t) {\n    if (t <= 0) {\n      return this.start.clone();\n    }\n\n    if (t >= 1) {\n      return this.end.clone();\n    }\n\n    return this.getSkeletonPoints(t).divider;\n  }\n\n  isDifferentiable() {\n    const start = this.start;\n    const control1 = this.controlPoint1;\n    const control2 = this.controlPoint2;\n    const end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  }\n\n  tangentAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    if (!this.isDifferentiable()) return null;\n\n    if (ratio < 0) {\n      ratio = 0; // eslint-disable-line\n    } else if (ratio > 1) {\n      ratio = 1; // eslint-disable-line\n    }\n\n    const t = this.tAt(ratio, options);\n    return this.tangentAtT(t);\n  }\n\n  tangentAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (!this.isDifferentiable()) {\n      return null;\n    }\n\n    const t = this.tAtLength(length, options);\n    return this.tangentAtT(t);\n  }\n\n  tangentAtT(t) {\n    if (!this.isDifferentiable()) {\n      return null;\n    }\n\n    if (t < 0) {\n      t = 0; // eslint-disable-line\n    }\n\n    if (t > 1) {\n      t = 1; // eslint-disable-line\n    }\n\n    const skeletonPoints = this.getSkeletonPoints(t);\n    const p1 = skeletonPoints.startControlPoint2;\n    const p2 = skeletonPoints.dividerControlPoint1;\n    const tangentStart = skeletonPoints.divider;\n    const tangentLine = new Line(p1, p2); // move so that tangent line starts at the point requested\n\n    tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);\n    return tangentLine;\n  }\n\n  getPrecision() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return options.precision == null ? this.PRECISION : options.precision;\n  }\n\n  getDivisions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.subdivisions != null) {\n      return options.subdivisions;\n    }\n\n    const precision = this.getPrecision(options);\n    return this.getSubdivisions({\n      precision\n    });\n  }\n\n  getOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const precision = this.getPrecision(options);\n    const subdivisions = this.getDivisions(options);\n    return {\n      precision,\n      subdivisions\n    };\n  }\n\n  tAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (ratio <= 0) {\n      return 0;\n    }\n\n    if (ratio >= 1) {\n      return 1;\n    }\n\n    const opts = this.getOptions(options);\n    const total = this.length(opts);\n    const length = total * ratio;\n    return this.tAtLength(length, opts);\n  }\n\n  tAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const subdivisions = this.getDivisions(options);\n    const opts = {\n      precision,\n      subdivisions\n    };\n    let investigatedSubdivision = null;\n    let investigatedSubdivisionStartT;\n    let investigatedSubdivisionEndT;\n    let baselinePointDistFromStart = 0;\n    let baselinePointDistFromEnd = 0;\n    let memo = 0;\n    const count = subdivisions.length;\n    let piece = count > 0 ? 1 / count : 0;\n\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i;\n      const division = subdivisions[i];\n      const dist = division.endpointDistance();\n\n      if (length <= memo + dist) {\n        investigatedSubdivision = division;\n        investigatedSubdivisionStartT = index * piece;\n        investigatedSubdivisionEndT = (index + 1) * piece;\n        baselinePointDistFromStart = fromStart ? length - memo : dist + memo - length;\n        baselinePointDistFromEnd = fromStart ? dist + memo - length : length - memo;\n        break;\n      }\n\n      memo += dist;\n    }\n\n    if (investigatedSubdivision == null) {\n      return fromStart ? 1 : 0;\n    } // note that precision affects what length is recorded\n    // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n    // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n\n    const total = this.length(opts);\n    const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n    // recursively divide investigated subdivision:\n    // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n    // then return the closest endpoint of that final subdivision\n    // eslint-disable-next-line\n\n    while (true) {\n      let ratio;\n      ratio = total !== 0 ? baselinePointDistFromStart / total : 0;\n\n      if (ratio < precisionRatio) {\n        return investigatedSubdivisionStartT;\n      }\n\n      ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;\n\n      if (ratio < precisionRatio) {\n        return investigatedSubdivisionEndT;\n      } // otherwise, set up for next iteration\n\n\n      let newBaselinePointDistFromStart;\n      let newBaselinePointDistFromEnd;\n      const divided = investigatedSubdivision.divide(0.5);\n      piece /= 2;\n      const baseline1Length = divided[0].endpointDistance();\n      const baseline2Length = divided[1].endpointDistance();\n\n      if (baselinePointDistFromStart <= baseline1Length) {\n        investigatedSubdivision = divided[0];\n        investigatedSubdivisionEndT -= piece;\n        newBaselinePointDistFromStart = baselinePointDistFromStart;\n        newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n      } else {\n        investigatedSubdivision = divided[1];\n        investigatedSubdivisionStartT += piece;\n        newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n        newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n      }\n\n      baselinePointDistFromStart = newBaselinePointDistFromStart;\n      baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n    }\n  }\n\n  toPoints() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const subdivisions = this.getDivisions(options);\n    const points = [subdivisions[0].start.clone()];\n    subdivisions.forEach(c => points.push(c.end.clone()));\n    return points;\n  }\n\n  toPolyline() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new Polyline(this.toPoints(options));\n  }\n\n  scale(sx, sy, origin) {\n    this.start.scale(sx, sy, origin);\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.start.rotate(angle, origin);\n    this.controlPoint1.rotate(angle, origin);\n    this.controlPoint2.rotate(angle, origin);\n    this.end.rotate(angle, origin);\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.start.translate(tx, ty);\n      this.controlPoint1.translate(tx, ty);\n      this.controlPoint2.translate(tx, ty);\n      this.end.translate(tx, ty);\n    } else {\n      this.start.translate(tx);\n      this.controlPoint1.translate(tx);\n      this.controlPoint2.translate(tx);\n      this.end.translate(tx);\n    }\n\n    return this;\n  }\n\n  equals(c) {\n    return c != null && this.start.equals(c.start) && this.controlPoint1.equals(c.controlPoint1) && this.controlPoint2.equals(c.controlPoint2) && this.end.equals(c.end);\n  }\n\n  clone() {\n    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n  }\n\n  toJSON() {\n    return {\n      start: this.start.toJSON(),\n      controlPoint1: this.controlPoint1.toJSON(),\n      controlPoint2: this.controlPoint2.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n\n  serialize() {\n    return [this.start.serialize(), this.controlPoint1.serialize(), this.controlPoint2.serialize(), this.end.serialize()].join(' ');\n  }\n\n}\n\n(function (Curve) {\n  Curve.toStringTag = `X6.Geometry.${Curve.name}`;\n\n  function isCurve(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Curve) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const curve = instance;\n\n    if ((tag == null || tag === Curve.toStringTag) && Point.isPoint(curve.start) && Point.isPoint(curve.controlPoint1) && Point.isPoint(curve.controlPoint2) && Point.isPoint(curve.end) && typeof curve.toPoints === 'function' && typeof curve.toPolyline === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Curve.isCurve = isCurve;\n})(Curve || (Curve = {}));\n\n(function (Curve) {\n  function getFirstControlPoints(rhs) {\n    const n = rhs.length;\n    const x = []; // `x` is a solution vector.\n\n    const tmp = [];\n    let b = 2.0;\n    x[0] = rhs[0] / b; // Decomposition and forward substitution.\n\n    for (let i = 1; i < n; i += 1) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n\n    for (let i = 1; i < n; i += 1) {\n      // Backsubstitution.\n      x[n - i - 1] -= tmp[n - i] * x[n - i];\n    }\n\n    return x;\n  }\n\n  function getCurveControlPoints(points) {\n    const knots = points.map(p => Point.clone(p));\n    const firstControlPoints = [];\n    const secondControlPoints = [];\n    const n = knots.length - 1; // Special case: Bezier curve should be a straight line.\n\n    if (n === 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3); // P2 = 2P1 – P0\n\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    } // Calculate first Bezier control points.\n    // Right hand side vector.\n\n\n    const rhs = []; // Set right hand side X values.\n\n    for (let i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0; // Get first control points X-values.\n\n    const x = getFirstControlPoints(rhs); // Set right hand side Y values.\n\n    for (let i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n    }\n\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0; // Get first control points Y-values.\n\n    const y = getFirstControlPoints(rhs); // Fill output arrays.\n\n    for (let i = 0; i < n; i += 1) {\n      // First control point.\n      firstControlPoints.push(new Point(x[i], y[i])); // Second control point.\n\n      if (i < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n\n    return [firstControlPoints, secondControlPoints];\n  }\n\n  function throughPoints(points) {\n    if (points == null || Array.isArray(points) && points.length < 2) {\n      throw new Error('At least 2 points are required');\n    }\n\n    const controlPoints = getCurveControlPoints(points);\n    const curves = [];\n\n    for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {\n      const controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n      const controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n    }\n\n    return curves;\n  }\n\n  Curve.throughPoints = throughPoints;\n})(Curve || (Curve = {}));","map":{"version":3,"sources":["../../src/geometry/curve.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Point } from './point';\nimport { Line } from './line';\nimport { Rectangle } from './rectangle';\nimport { Polyline } from './polyline';\nimport { Geometry } from './geometry';\nexport class Curve extends Geometry {\n    constructor(start, controlPoint1, controlPoint2, end) {\n        super();\n        this.PRECISION = 3;\n        this.start = Point.create(start);\n        this.controlPoint1 = Point.create(controlPoint1);\n        this.controlPoint2 = Point.create(controlPoint2);\n        this.end = Point.create(end);\n    }\n    get [Symbol.toStringTag]() {\n        return Curve.toStringTag;\n    }\n    bbox() {\n        const start = this.start;\n        const controlPoint1 = this.controlPoint1;\n        const controlPoint2 = this.controlPoint2;\n        const end = this.end;\n        const x0 = start.x;\n        const y0 = start.y;\n        const x1 = controlPoint1.x;\n        const y1 = controlPoint1.y;\n        const x2 = controlPoint2.x;\n        const y2 = controlPoint2.y;\n        const x3 = end.x;\n        const y3 = end.y;\n        const points = []; // local extremes\n        const tvalues = []; // t values of local extremes\n        const bounds = [[], []];\n        let a;\n        let b;\n        let c;\n        let t;\n        let t1;\n        let t2;\n        let b2ac;\n        let sqrtb2ac;\n        for (let i = 0; i < 2; i += 1) {\n            if (i === 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n            }\n            else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (Math.abs(a) < 1e-12) {\n                if (Math.abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (t > 0 && t < 1)\n                    tvalues.push(t);\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = Math.sqrt(b2ac);\n            if (b2ac < 0)\n                continue;\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (t1 > 0 && t1 < 1)\n                tvalues.push(t1);\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (t2 > 0 && t2 < 1)\n                tvalues.push(t2);\n        }\n        let x;\n        let y;\n        let mt;\n        let j = tvalues.length;\n        const jlen = j;\n        while (j) {\n            j -= 1;\n            t = tvalues[j];\n            mt = 1 - t;\n            x =\n                mt * mt * mt * x0 +\n                    3 * mt * mt * t * x1 +\n                    3 * mt * t * t * x2 +\n                    t * t * t * x3;\n            bounds[0][j] = x;\n            y =\n                mt * mt * mt * y0 +\n                    3 * mt * mt * t * y1 +\n                    3 * mt * t * t * y2 +\n                    t * t * t * y3;\n            bounds[1][j] = y;\n            points[j] = { X: x, Y: y };\n        }\n        tvalues[jlen] = 0;\n        tvalues[jlen + 1] = 1;\n        points[jlen] = { X: x0, Y: y0 };\n        points[jlen + 1] = { X: x3, Y: y3 };\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        tvalues.length = jlen + 2;\n        bounds[0].length = jlen + 2;\n        bounds[1].length = jlen + 2;\n        points.length = jlen + 2;\n        const left = Math.min.apply(null, bounds[0]);\n        const top = Math.min.apply(null, bounds[1]);\n        const right = Math.max.apply(null, bounds[0]);\n        const bottom = Math.max.apply(null, bounds[1]);\n        return new Rectangle(left, top, right - left, bottom - top);\n    }\n    closestPoint(p, options = {}) {\n        return this.pointAtT(this.closestPointT(p, options));\n    }\n    closestPointLength(p, options = {}) {\n        const opts = this.getOptions(options);\n        return this.lengthAtT(this.closestPointT(p, opts), opts);\n    }\n    closestPointNormalizedLength(p, options = {}) {\n        const opts = this.getOptions(options);\n        const cpLength = this.closestPointLength(p, opts);\n        if (!cpLength) {\n            return 0;\n        }\n        const length = this.length(opts);\n        if (length === 0) {\n            return 0;\n        }\n        return cpLength / length;\n    }\n    closestPointT(p, options = {}) {\n        const precision = this.getPrecision(options);\n        const subdivisions = this.getDivisions(options);\n        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n        let investigatedSubdivision = null;\n        let investigatedSubdivisionStartT = 0;\n        let investigatedSubdivisionEndT = 0;\n        let distFromStart = 0;\n        let distFromEnd = 0;\n        let chordLength = 0;\n        let minSumDist = null;\n        const count = subdivisions.length;\n        let piece = count > 0 ? 1 / count : 0;\n        subdivisions.forEach((division, i) => {\n            const startDist = division.start.distance(p);\n            const endDist = division.end.distance(p);\n            const sumDist = startDist + endDist;\n            if (minSumDist == null || sumDist < minSumDist) {\n                investigatedSubdivision = division;\n                investigatedSubdivisionStartT = i * piece;\n                investigatedSubdivisionEndT = (i + 1) * piece;\n                distFromStart = startDist;\n                distFromEnd = endDist;\n                minSumDist = sumDist;\n                chordLength = division.endpointDistance();\n            }\n        });\n        // Recursively divide investigated subdivision, until distance between\n        // baselinePoint and closest path endpoint is within `10^(-precision)`,\n        // then return the closest endpoint of that final subdivision.\n        // eslint-disable-next-line\n        while (true) {\n            // check if we have reached at least one required observed precision\n            // - calculated as: the difference in distances from point to start and end divided by the distance\n            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n            // - this criterion works well for points lying far away from the curve\n            const startPrecisionRatio = distFromStart\n                ? Math.abs(distFromStart - distFromEnd) / distFromStart\n                : 0;\n            const endPrecisionRatio = distFromEnd != null\n                ? Math.abs(distFromStart - distFromEnd) / distFromEnd\n                : 0;\n            const hasRequiredPrecision = startPrecisionRatio < precisionRatio ||\n                endPrecisionRatio < precisionRatio;\n            // check if we have reached at least one required minimal distance\n            // - calculated as: the subdivision chord length multiplied by precisionRatio\n            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n            const hasMiniStartDistance = distFromStart\n                ? distFromStart < chordLength * precisionRatio\n                : true;\n            const hasMiniEndDistance = distFromEnd\n                ? distFromEnd < chordLength * precisionRatio\n                : true;\n            const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;\n            if (hasRequiredPrecision || hasMiniDistance) {\n                return distFromStart <= distFromEnd\n                    ? investigatedSubdivisionStartT\n                    : investigatedSubdivisionEndT;\n            }\n            // otherwise, set up for next iteration\n            const divided = investigatedSubdivision.divide(0.5);\n            piece /= 2;\n            const startDist1 = divided[0].start.distance(p);\n            const endDist1 = divided[0].end.distance(p);\n            const sumDist1 = startDist1 + endDist1;\n            const startDist2 = divided[1].start.distance(p);\n            const endDist2 = divided[1].end.distance(p);\n            const sumDist2 = startDist2 + endDist2;\n            if (sumDist1 <= sumDist2) {\n                investigatedSubdivision = divided[0];\n                investigatedSubdivisionEndT -= piece;\n                distFromStart = startDist1;\n                distFromEnd = endDist1;\n            }\n            else {\n                investigatedSubdivision = divided[1];\n                investigatedSubdivisionStartT += piece;\n                distFromStart = startDist2;\n                distFromEnd = endDist2;\n            }\n        }\n    }\n    closestPointTangent(p, options = {}) {\n        return this.tangentAtT(this.closestPointT(p, options));\n    }\n    containsPoint(p, options = {}) {\n        const polyline = this.toPolyline(options);\n        return polyline.containsPoint(p);\n    }\n    divideAt(ratio, options = {}) {\n        if (ratio <= 0) {\n            return this.divideAtT(0);\n        }\n        if (ratio >= 1) {\n            return this.divideAtT(1);\n        }\n        const t = this.tAt(ratio, options);\n        return this.divideAtT(t);\n    }\n    divideAtLength(length, options = {}) {\n        const t = this.tAtLength(length, options);\n        return this.divideAtT(t);\n    }\n    divide(t) {\n        return this.divideAtT(t);\n    }\n    divideAtT(t) {\n        const start = this.start;\n        const controlPoint1 = this.controlPoint1;\n        const controlPoint2 = this.controlPoint2;\n        const end = this.end;\n        if (t <= 0) {\n            return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end),\n            ];\n        }\n        if (t >= 1) {\n            return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end),\n            ];\n        }\n        const dividerPoints = this.getSkeletonPoints(t);\n        const startControl1 = dividerPoints.startControlPoint1;\n        const startControl2 = dividerPoints.startControlPoint2;\n        const divider = dividerPoints.divider;\n        const dividerControl1 = dividerPoints.dividerControlPoint1;\n        const dividerControl2 = dividerPoints.dividerControlPoint2;\n        return [\n            new Curve(start, startControl1, startControl2, divider),\n            new Curve(divider, dividerControl1, dividerControl2, end),\n        ];\n    }\n    endpointDistance() {\n        return this.start.distance(this.end);\n    }\n    getSkeletonPoints(t) {\n        const start = this.start;\n        const control1 = this.controlPoint1;\n        const control2 = this.controlPoint2;\n        const end = this.end;\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone(),\n            };\n        }\n        if (t >= 1) {\n            return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone(),\n            };\n        }\n        const midpoint1 = new Line(start, control1).pointAt(t);\n        const midpoint2 = new Line(control1, control2).pointAt(t);\n        const midpoint3 = new Line(control2, end).pointAt(t);\n        const subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n        const subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n        const divideLine = new Line(subControl1, subControl2).pointAt(t);\n        return {\n            startControlPoint1: midpoint1,\n            startControlPoint2: subControl1,\n            divider: divideLine,\n            dividerControlPoint1: subControl2,\n            dividerControlPoint2: midpoint3,\n        };\n    }\n    getSubdivisions(options = {}) {\n        const precision = this.getPrecision(options);\n        let subdivisions = [\n            new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end),\n        ];\n        if (precision === 0) {\n            return subdivisions;\n        }\n        let previousLength = this.endpointDistance();\n        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n        // Recursively divide curve at `t = 0.5`, until the difference between\n        // observed length at subsequent iterations is lower than precision.\n        let iteration = 0;\n        // eslint-disable-next-line\n        while (true) {\n            iteration += 1;\n            const divisions = [];\n            subdivisions.forEach((c) => {\n                // dividing at t = 0.5 (not at middle length!)\n                const divided = c.divide(0.5);\n                divisions.push(divided[0], divided[1]);\n            });\n            // measure new length\n            const length = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0);\n            // check if we have reached required observed precision\n            // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n            // not a problem for further iterations because cubic curves cannot have more than two local extrema\n            // (i.e. cubic curves cannot intersect the baseline more than once)\n            // therefore two subsequent iterations cannot produce sampling with equal length\n            const ratio = length !== 0 ? (length - previousLength) / length : 0;\n            if (iteration > 1 && ratio < precisionRatio) {\n                return divisions;\n            }\n            subdivisions = divisions;\n            previousLength = length;\n        }\n    }\n    length(options = {}) {\n        const divisions = this.getDivisions(options);\n        return divisions.reduce((memo, c) => {\n            return memo + c.endpointDistance();\n        }, 0);\n    }\n    lengthAtT(t, options = {}) {\n        if (t <= 0) {\n            return 0;\n        }\n        const precision = options.precision === undefined ? this.PRECISION : options.precision;\n        const subCurve = this.divide(t)[0];\n        return subCurve.length({ precision });\n    }\n    pointAt(ratio, options = {}) {\n        if (ratio <= 0) {\n            return this.start.clone();\n        }\n        if (ratio >= 1) {\n            return this.end.clone();\n        }\n        const t = this.tAt(ratio, options);\n        return this.pointAtT(t);\n    }\n    pointAtLength(length, options = {}) {\n        const t = this.tAtLength(length, options);\n        return this.pointAtT(t);\n    }\n    pointAtT(t) {\n        if (t <= 0) {\n            return this.start.clone();\n        }\n        if (t >= 1) {\n            return this.end.clone();\n        }\n        return this.getSkeletonPoints(t).divider;\n    }\n    isDifferentiable() {\n        const start = this.start;\n        const control1 = this.controlPoint1;\n        const control2 = this.controlPoint2;\n        const end = this.end;\n        return !(start.equals(control1) &&\n            control1.equals(control2) &&\n            control2.equals(end));\n    }\n    tangentAt(ratio, options = {}) {\n        if (!this.isDifferentiable())\n            return null;\n        if (ratio < 0) {\n            ratio = 0; // eslint-disable-line\n        }\n        else if (ratio > 1) {\n            ratio = 1; // eslint-disable-line\n        }\n        const t = this.tAt(ratio, options);\n        return this.tangentAtT(t);\n    }\n    tangentAtLength(length, options = {}) {\n        if (!this.isDifferentiable()) {\n            return null;\n        }\n        const t = this.tAtLength(length, options);\n        return this.tangentAtT(t);\n    }\n    tangentAtT(t) {\n        if (!this.isDifferentiable()) {\n            return null;\n        }\n        if (t < 0) {\n            t = 0; // eslint-disable-line\n        }\n        if (t > 1) {\n            t = 1; // eslint-disable-line\n        }\n        const skeletonPoints = this.getSkeletonPoints(t);\n        const p1 = skeletonPoints.startControlPoint2;\n        const p2 = skeletonPoints.dividerControlPoint1;\n        const tangentStart = skeletonPoints.divider;\n        const tangentLine = new Line(p1, p2);\n        // move so that tangent line starts at the point requested\n        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);\n        return tangentLine;\n    }\n    getPrecision(options = {}) {\n        return options.precision == null ? this.PRECISION : options.precision;\n    }\n    getDivisions(options = {}) {\n        if (options.subdivisions != null) {\n            return options.subdivisions;\n        }\n        const precision = this.getPrecision(options);\n        return this.getSubdivisions({ precision });\n    }\n    getOptions(options = {}) {\n        const precision = this.getPrecision(options);\n        const subdivisions = this.getDivisions(options);\n        return { precision, subdivisions };\n    }\n    tAt(ratio, options = {}) {\n        if (ratio <= 0) {\n            return 0;\n        }\n        if (ratio >= 1) {\n            return 1;\n        }\n        const opts = this.getOptions(options);\n        const total = this.length(opts);\n        const length = total * ratio;\n        return this.tAtLength(length, opts);\n    }\n    tAtLength(length, options = {}) {\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        const precision = this.getPrecision(options);\n        const subdivisions = this.getDivisions(options);\n        const opts = { precision, subdivisions };\n        let investigatedSubdivision = null;\n        let investigatedSubdivisionStartT;\n        let investigatedSubdivisionEndT;\n        let baselinePointDistFromStart = 0;\n        let baselinePointDistFromEnd = 0;\n        let memo = 0;\n        const count = subdivisions.length;\n        let piece = count > 0 ? 1 / count : 0;\n        for (let i = 0; i < count; i += 1) {\n            const index = fromStart ? i : count - 1 - i;\n            const division = subdivisions[i];\n            const dist = division.endpointDistance();\n            if (length <= memo + dist) {\n                investigatedSubdivision = division;\n                investigatedSubdivisionStartT = index * piece;\n                investigatedSubdivisionEndT = (index + 1) * piece;\n                baselinePointDistFromStart = fromStart\n                    ? length - memo\n                    : dist + memo - length;\n                baselinePointDistFromEnd = fromStart\n                    ? dist + memo - length\n                    : length - memo;\n                break;\n            }\n            memo += dist;\n        }\n        if (investigatedSubdivision == null) {\n            return fromStart ? 1 : 0;\n        }\n        // note that precision affects what length is recorded\n        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n        const total = this.length(opts);\n        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        // eslint-disable-next-line\n        while (true) {\n            let ratio;\n            ratio = total !== 0 ? baselinePointDistFromStart / total : 0;\n            if (ratio < precisionRatio) {\n                return investigatedSubdivisionStartT;\n            }\n            ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;\n            if (ratio < precisionRatio) {\n                return investigatedSubdivisionEndT;\n            }\n            // otherwise, set up for next iteration\n            let newBaselinePointDistFromStart;\n            let newBaselinePointDistFromEnd;\n            const divided = investigatedSubdivision.divide(0.5);\n            piece /= 2;\n            const baseline1Length = divided[0].endpointDistance();\n            const baseline2Length = divided[1].endpointDistance();\n            if (baselinePointDistFromStart <= baseline1Length) {\n                investigatedSubdivision = divided[0];\n                investigatedSubdivisionEndT -= piece;\n                newBaselinePointDistFromStart = baselinePointDistFromStart;\n                newBaselinePointDistFromEnd =\n                    baseline1Length - newBaselinePointDistFromStart;\n            }\n            else {\n                investigatedSubdivision = divided[1];\n                investigatedSubdivisionStartT += piece;\n                newBaselinePointDistFromStart =\n                    baselinePointDistFromStart - baseline1Length;\n                newBaselinePointDistFromEnd =\n                    baseline2Length - newBaselinePointDistFromStart;\n            }\n            baselinePointDistFromStart = newBaselinePointDistFromStart;\n            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n        }\n    }\n    toPoints(options = {}) {\n        const subdivisions = this.getDivisions(options);\n        const points = [subdivisions[0].start.clone()];\n        subdivisions.forEach((c) => points.push(c.end.clone()));\n        return points;\n    }\n    toPolyline(options = {}) {\n        return new Polyline(this.toPoints(options));\n    }\n    scale(sx, sy, origin) {\n        this.start.scale(sx, sy, origin);\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    }\n    rotate(angle, origin) {\n        this.start.rotate(angle, origin);\n        this.controlPoint1.rotate(angle, origin);\n        this.controlPoint2.rotate(angle, origin);\n        this.end.rotate(angle, origin);\n        return this;\n    }\n    translate(tx, ty) {\n        if (typeof tx === 'number') {\n            this.start.translate(tx, ty);\n            this.controlPoint1.translate(tx, ty);\n            this.controlPoint2.translate(tx, ty);\n            this.end.translate(tx, ty);\n        }\n        else {\n            this.start.translate(tx);\n            this.controlPoint1.translate(tx);\n            this.controlPoint2.translate(tx);\n            this.end.translate(tx);\n        }\n        return this;\n    }\n    equals(c) {\n        return (c != null &&\n            this.start.equals(c.start) &&\n            this.controlPoint1.equals(c.controlPoint1) &&\n            this.controlPoint2.equals(c.controlPoint2) &&\n            this.end.equals(c.end));\n    }\n    clone() {\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    }\n    toJSON() {\n        return {\n            start: this.start.toJSON(),\n            controlPoint1: this.controlPoint1.toJSON(),\n            controlPoint2: this.controlPoint2.toJSON(),\n            end: this.end.toJSON(),\n        };\n    }\n    serialize() {\n        return [\n            this.start.serialize(),\n            this.controlPoint1.serialize(),\n            this.controlPoint2.serialize(),\n            this.end.serialize(),\n        ].join(' ');\n    }\n}\n(function (Curve) {\n    Curve.toStringTag = `X6.Geometry.${Curve.name}`;\n    function isCurve(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Curve) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const curve = instance;\n        if ((tag == null || tag === Curve.toStringTag) &&\n            Point.isPoint(curve.start) &&\n            Point.isPoint(curve.controlPoint1) &&\n            Point.isPoint(curve.controlPoint2) &&\n            Point.isPoint(curve.end) &&\n            typeof curve.toPoints === 'function' &&\n            typeof curve.toPolyline === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Curve.isCurve = isCurve;\n})(Curve || (Curve = {}));\n(function (Curve) {\n    function getFirstControlPoints(rhs) {\n        const n = rhs.length;\n        const x = []; // `x` is a solution vector.\n        const tmp = [];\n        let b = 2.0;\n        x[0] = rhs[0] / b;\n        // Decomposition and forward substitution.\n        for (let i = 1; i < n; i += 1) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n        for (let i = 1; i < n; i += 1) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n        return x;\n    }\n    function getCurveControlPoints(points) {\n        const knots = points.map((p) => Point.clone(p));\n        const firstControlPoints = [];\n        const secondControlPoints = [];\n        const n = knots.length - 1;\n        // Special case: Bezier curve should be a straight line.\n        if (n === 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n            // P2 = 2P1 – P0\n            secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n            return [firstControlPoints, secondControlPoints];\n        }\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        const rhs = [];\n        // Set right hand side X values.\n        for (let i = 1; i < n - 1; i += 1) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n        // Get first control points X-values.\n        const x = getFirstControlPoints(rhs);\n        // Set right hand side Y values.\n        for (let i = 1; i < n - 1; i += 1) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n        // Get first control points Y-values.\n        const y = getFirstControlPoints(rhs);\n        // Fill output arrays.\n        for (let i = 0; i < n; i += 1) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n            }\n            else {\n                secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n            }\n        }\n        return [firstControlPoints, secondControlPoints];\n    }\n    function throughPoints(points) {\n        if (points == null || (Array.isArray(points) && points.length < 2)) {\n            throw new Error('At least 2 points are required');\n        }\n        const controlPoints = getCurveControlPoints(points);\n        const curves = [];\n        for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {\n            const controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n            const controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n        }\n        return curves;\n    }\n    Curve.throughPoints = throughPoints;\n})(Curve || (Curve = {}));\n//# sourceMappingURL=curve.js.map"]},"metadata":{},"sourceType":"module"}