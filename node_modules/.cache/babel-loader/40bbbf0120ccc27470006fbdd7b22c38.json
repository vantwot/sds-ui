{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _mergeWith from \"lodash/mergeWith\";\nimport _isString from \"lodash/isString\";\nimport _isFunction from \"lodash/isFunction\";\nimport _cloneDeep from \"lodash/cloneDeep\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { SyncHook } from '@antv/async-hook';\nimport { bBoxToBounds, extent, padBounds } from '@antv/l7-utils';\nimport { EventEmitter } from 'eventemitter3';\nimport { getParser, getTransform } from './factory';\nimport { cluster } from './transform/cluster';\nimport { statMap } from './utils/statistics';\nimport { getColumn } from './utils/util';\n\nfunction mergeCustomizer(objValue, srcValue) {\n  if (Array.isArray(srcValue)) {\n    return srcValue;\n  }\n}\n\nvar Source = function (_EventEmitter) {\n  _inherits(Source, _EventEmitter);\n\n  var _super = _createSuper(Source);\n\n  function Source(data, cfg) {\n    var _this;\n\n    _classCallCheck(this, Source);\n\n    _this = _super.call(this);\n\n    _defineProperty(_assertThisInitialized(_this), \"data\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"extent\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"hooks\", {\n      init: new SyncHook()\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"parser\", {\n      type: 'geojson'\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"transforms\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"cluster\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"clusterOptions\", {\n      enable: false,\n      radius: 40,\n      maxZoom: 20,\n      zoom: -99,\n      method: 'count'\n    });\n\n    _defineProperty(_assertThisInitialized(_this), \"mapService\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"invalidExtent\", false);\n\n    _defineProperty(_assertThisInitialized(_this), \"originData\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"rawData\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"cfg\", {});\n\n    _defineProperty(_assertThisInitialized(_this), \"clusterIndex\", void 0);\n\n    _this.originData = data;\n\n    _this.initCfg(cfg);\n\n    _this.hooks.init.tap('parser', function () {\n      _this.excuteParser();\n    });\n\n    _this.hooks.init.tap('cluster', function () {\n      _this.initCluster();\n    });\n\n    _this.hooks.init.tap('transform', function () {\n      _this.executeTrans();\n    });\n\n    _this.init();\n\n    return _this;\n  }\n\n  _createClass(Source, [{\n    key: \"setData\",\n    value: function setData(data, options) {\n      this.rawData = data;\n      this.originData = data;\n      this.initCfg(options);\n      this.init();\n      this.emit('update');\n    }\n  }, {\n    key: \"getClusters\",\n    value: function getClusters(zoom) {\n      return this.clusterIndex.getClusters(this.caculClusterExtent(2), zoom);\n    }\n  }, {\n    key: \"getClustersLeaves\",\n    value: function getClustersLeaves(id) {\n      return this.clusterIndex.getLeaves(id, Infinity);\n    }\n  }, {\n    key: \"updateClusterData\",\n    value: function updateClusterData(zoom) {\n      var _this2 = this;\n\n      var _this$clusterOptions = this.clusterOptions,\n          _this$clusterOptions$ = _this$clusterOptions.method,\n          method = _this$clusterOptions$ === void 0 ? 'sum' : _this$clusterOptions$,\n          field = _this$clusterOptions.field;\n      var data = this.clusterIndex.getClusters(this.caculClusterExtent(2), Math.floor(zoom));\n      this.clusterOptions.zoom = zoom;\n      data.forEach(function (p) {\n        if (!p.id) {\n          p.properties.point_count = 1;\n        }\n      });\n\n      if (field || _isFunction(method)) {\n        data = data.map(function (item) {\n          var id = item.id;\n\n          if (id) {\n            var points = _this2.clusterIndex.getLeaves(id, Infinity);\n\n            var properties = points.map(function (d) {\n              return d.properties;\n            });\n            var statNum;\n\n            if (_isString(method) && field) {\n              var column = getColumn(properties, field);\n              statNum = statMap[method](column);\n            }\n\n            if (_isFunction(method)) {\n              statNum = method(properties);\n            }\n\n            item.properties.stat = statNum;\n          } else {\n            item.properties.point_count = 1;\n          }\n\n          return item;\n        });\n      }\n\n      this.data = getParser('geojson')({\n        type: 'FeatureCollection',\n        features: data\n      });\n      this.executeTrans();\n    }\n  }, {\n    key: \"getFeatureById\",\n    value: function getFeatureById(id) {\n      var _this$parser$type = this.parser.type,\n          type = _this$parser$type === void 0 ? 'geojson' : _this$parser$type;\n\n      if (type === 'geojson' && !this.cluster) {\n        var feature = id < this.originData.features.length ? this.originData.features[id] : 'null';\n\n        var newFeature = _cloneDeep(feature);\n\n        if (this.transforms.length !== 0) {\n          var item = this.data.dataArray.find(function (dataItem) {\n            return dataItem._id === id;\n          });\n          newFeature.properties = item;\n        }\n\n        return newFeature;\n      } else {\n        return id < this.data.dataArray.length ? this.data.dataArray[id] : 'null';\n      }\n    }\n  }, {\n    key: \"getFeatureId\",\n    value: function getFeatureId(field, value) {\n      var feature = this.data.dataArray.find(function (dataItem) {\n        return dataItem[field] === name;\n      });\n      return feature === null || feature === void 0 ? void 0 : feature._id;\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.removeAllListeners();\n      this.originData = null;\n      this.clusterIndex = null;\n      this.data = null;\n    }\n  }, {\n    key: \"caculClusterExtent\",\n    value: function caculClusterExtent(bufferRatio) {\n      var newBounds = [[-Infinity, -Infinity], [Infinity, Infinity]];\n\n      if (!this.invalidExtent) {\n        newBounds = padBounds(bBoxToBounds(this.extent), bufferRatio);\n      }\n\n      return newBounds[0].concat(newBounds[1]);\n    }\n  }, {\n    key: \"initCfg\",\n    value: function initCfg(option) {\n      this.cfg = _mergeWith(this.cfg, option, mergeCustomizer);\n      var cfg = this.cfg;\n\n      if (cfg) {\n        if (cfg.parser) {\n          this.parser = cfg.parser;\n        }\n\n        if (cfg.transforms) {\n          this.transforms = cfg.transforms;\n        }\n\n        this.cluster = cfg.cluster || false;\n\n        if (cfg.clusterOptions) {\n          this.cluster = true;\n          this.clusterOptions = _objectSpread(_objectSpread({}, this.clusterOptions), cfg.clusterOptions);\n        }\n      }\n    }\n  }, {\n    key: \"excuteParser\",\n    value: function excuteParser() {\n      var parser = this.parser;\n      var type = parser.type || 'geojson';\n\n      if (type === 'imagetile') {\n        this.data = {\n          tileurl: this.originData,\n          dataArray: []\n        };\n        return;\n      }\n\n      var sourceParser = getParser(type);\n      this.data = sourceParser(this.originData, parser);\n      this.extent = extent(this.data.dataArray);\n      this.invalidExtent = this.extent[0] === this.extent[2] || this.extent[1] === this.extent[3];\n    }\n  }, {\n    key: \"executeTrans\",\n    value: function executeTrans() {\n      var _this3 = this;\n\n      var trans = this.transforms;\n      trans.forEach(function (tran) {\n        var type = tran.type;\n        var data = getTransform(type)(_this3.data, tran);\n        Object.assign(_this3.data, data);\n      });\n    }\n  }, {\n    key: \"initCluster\",\n    value: function initCluster() {\n      if (!this.cluster) {\n        return;\n      }\n\n      var clusterOptions = this.clusterOptions || {};\n      this.clusterIndex = cluster(this.data, clusterOptions);\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.hooks.init.call(this);\n    }\n  }]);\n\n  return Source;\n}(EventEmitter);\n\nexport { Source as default };","map":{"version":3,"sources":["../src/source.ts"],"names":["Array","Source","EventEmitter","init","type","enable","radius","maxZoom","zoom","method","field","data","Math","p","id","item","points","properties","d","column","getColumn","statNum","statMap","features","feature","newFeature","dataItem","newBounds","padBounds","bBoxToBounds","cfg","parser","tileurl","dataArray","sourceParser","getParser","extent","trans","tran","getTransform","Object","clusterOptions","cluster"],"mappings":"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","sourcesContent":["// @ts-ignore\nimport { SyncHook } from '@antv/async-hook';\nimport {\n  IClusterOptions,\n  IMapService,\n  IParseDataItem,\n  IParserCfg,\n  IParserData,\n  ISource,\n  ISourceCFG,\n  ITransform,\n  lazyInject,\n  TYPES,\n} from '@antv/l7-core';\nimport { bBoxToBounds, extent, padBounds } from '@antv/l7-utils';\nimport {\n  BBox,\n  Feature,\n  FeatureCollection,\n  Geometries,\n  Properties,\n} from '@turf/helpers';\nimport { EventEmitter } from 'eventemitter3';\nimport { cloneDeep, isFunction, isString, mergeWith } from 'lodash';\n// @ts-ignore\n// tslint:disable-next-line:no-submodule-imports\nimport Supercluster from 'supercluster/dist/supercluster';\nimport { getParser, getTransform } from './factory';\nimport { cluster } from './transform/cluster';\nimport { statMap } from './utils/statistics';\nimport { getColumn } from './utils/util';\n\nfunction mergeCustomizer(objValue: any, srcValue: any) {\n  if (Array.isArray(srcValue)) {\n    return srcValue;\n  }\n}\n\nexport default class Source extends EventEmitter implements ISource {\n  public data: IParserData;\n\n  // 数据范围\n  public extent: BBox;\n  // 生命周期钩子\n  public hooks = {\n    init: new SyncHook(),\n  };\n\n  public parser: IParserCfg = { type: 'geojson' };\n  public transforms: ITransform[] = [];\n  public cluster: boolean = false;\n  public clusterOptions: Partial<IClusterOptions> = {\n    enable: false,\n    radius: 40,\n    maxZoom: 20,\n    zoom: -99,\n    method: 'count',\n  };\n  private readonly mapService: IMapService;\n  // 是否有效范围\n  private invalidExtent: boolean = false;\n\n  // 原始数据\n  private originData: any;\n  private rawData: any;\n  private cfg: any = {};\n\n  private clusterIndex: Supercluster;\n\n  constructor(data: any | ISource, cfg?: ISourceCFG) {\n    super();\n    // this.rawData = cloneDeep(data);\n    this.originData = data;\n    this.initCfg(cfg);\n\n    this.hooks.init.tap('parser', () => {\n      this.excuteParser();\n    });\n    this.hooks.init.tap('cluster', () => {\n      this.initCluster();\n    });\n    this.hooks.init.tap('transform', () => {\n      this.executeTrans();\n    });\n    this.init();\n  }\n\n  public setData(data: any, options?: ISourceCFG) {\n    this.rawData = data;\n    this.originData = data;\n    this.initCfg(options);\n    this.init();\n    this.emit('update');\n  }\n  public getClusters(zoom: number): any {\n    return this.clusterIndex.getClusters(this.caculClusterExtent(2), zoom);\n  }\n  public getClustersLeaves(id: number): any {\n    return this.clusterIndex.getLeaves(id, Infinity);\n  }\n  public updateClusterData(zoom: number): void {\n    const { method = 'sum', field } = this.clusterOptions;\n    let data = this.clusterIndex.getClusters(\n      this.caculClusterExtent(2),\n      Math.floor(zoom),\n    );\n    this.clusterOptions.zoom = zoom;\n    data.forEach((p: any) => {\n      if (!p.id) {\n        p.properties.point_count = 1;\n      }\n    });\n    if (field || isFunction(method)) {\n      data = data.map((item: any) => {\n        const id = item.id as number;\n        if (id) {\n          const points = this.clusterIndex.getLeaves(id, Infinity);\n          const properties = points.map((d: any) => d.properties);\n          let statNum;\n          if (isString(method) && field) {\n            const column = getColumn(properties, field);\n            statNum = statMap[method](column);\n          }\n          if (isFunction(method)) {\n            statNum = method(properties);\n          }\n          item.properties.stat = statNum;\n        } else {\n          item.properties.point_count = 1;\n        }\n        return item;\n      });\n    }\n    this.data = getParser('geojson')({\n      type: 'FeatureCollection',\n      features: data,\n    });\n    this.executeTrans();\n  }\n  public getFeatureById(id: number): unknown {\n    const { type = 'geojson' } = this.parser;\n    if (type === 'geojson' && !this.cluster) {\n      const feature =\n        id < this.originData.features.length\n          ? this.originData.features[id]\n          : 'null';\n      const newFeature = cloneDeep(feature);\n      if (this.transforms.length !== 0) {\n        const item = this.data.dataArray.find((dataItem: IParseDataItem) => {\n          return dataItem._id === id;\n        });\n        newFeature.properties = item;\n      }\n      return newFeature;\n    } else {\n      return id < this.data.dataArray.length ? this.data.dataArray[id] : 'null';\n    }\n  }\n\n  public getFeatureId(field: string, value: any): number | undefined {\n    const feature = this.data.dataArray.find((dataItem: IParseDataItem) => {\n      return dataItem[field] === name;\n    });\n    return feature?._id;\n  }\n\n  public destroy() {\n    this.removeAllListeners();\n    this.originData = null;\n    this.clusterIndex = null;\n    // @ts-ignore\n    this.data = null;\n  }\n\n  private caculClusterExtent(bufferRatio: number): any {\n    let newBounds = [\n      [-Infinity, -Infinity],\n      [Infinity, Infinity],\n    ];\n\n    if (!this.invalidExtent) {\n      newBounds = padBounds(bBoxToBounds(this.extent), bufferRatio);\n    }\n    return newBounds[0].concat(newBounds[1]);\n  }\n\n  private initCfg(option?: ISourceCFG) {\n    this.cfg = mergeWith(this.cfg, option, mergeCustomizer);\n    const cfg = this.cfg;\n    if (cfg) {\n      if (cfg.parser) {\n        this.parser = cfg.parser;\n      }\n      if (cfg.transforms) {\n        this.transforms = cfg.transforms;\n      }\n      this.cluster = cfg.cluster || false;\n      if (cfg.clusterOptions) {\n        this.cluster = true;\n        this.clusterOptions = {\n          ...this.clusterOptions,\n          ...cfg.clusterOptions,\n        };\n      }\n    }\n  }\n  private excuteParser(): void {\n    const parser = this.parser;\n    const type: string = parser.type || 'geojson';\n    // TODO: 图片瓦片地图组件只需要使用 url 参数\n    if (type === 'imagetile') {\n      this.data = {\n        tileurl: this.originData,\n        dataArray: [],\n      };\n      return;\n    }\n    const sourceParser = getParser(type);\n    this.data = sourceParser(this.originData, parser);\n    // 计算范围\n    this.extent = extent(this.data.dataArray);\n    this.invalidExtent =\n      this.extent[0] === this.extent[2] || this.extent[1] === this.extent[3];\n  }\n  /**\n   * 数据统计\n   */\n  private executeTrans() {\n    const trans = this.transforms;\n    trans.forEach((tran: ITransform) => {\n      const { type } = tran;\n\n      const data = getTransform(type)(this.data, tran);\n      Object.assign(this.data, data);\n    });\n  }\n\n  private initCluster() {\n    if (!this.cluster) {\n      return;\n    }\n\n    const clusterOptions = this.clusterOptions || {};\n    this.clusterIndex = cluster(this.data, clusterOptions);\n  }\n\n  private init() {\n    this.hooks.init.call(this);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}