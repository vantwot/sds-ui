{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar GridIndex = function () {\n  function GridIndex(width, height, cellSize) {\n    _classCallCheck(this, GridIndex);\n\n    _defineProperty(this, \"boxCells\", []);\n\n    _defineProperty(this, \"xCellCount\", void 0);\n\n    _defineProperty(this, \"yCellCount\", void 0);\n\n    _defineProperty(this, \"boxKeys\", void 0);\n\n    _defineProperty(this, \"bboxes\", void 0);\n\n    _defineProperty(this, \"width\", void 0);\n\n    _defineProperty(this, \"height\", void 0);\n\n    _defineProperty(this, \"xScale\", void 0);\n\n    _defineProperty(this, \"yScale\", void 0);\n\n    _defineProperty(this, \"boxUid\", void 0);\n\n    var boxCells = this.boxCells;\n    this.xCellCount = Math.ceil(width / cellSize);\n    this.yCellCount = Math.ceil(height / cellSize);\n\n    for (var i = 0; i < this.xCellCount * this.yCellCount; i++) {\n      boxCells.push([]);\n    }\n\n    this.boxKeys = [];\n    this.bboxes = [];\n    this.width = width;\n    this.height = height;\n    this.xScale = this.xCellCount / width;\n    this.yScale = this.yCellCount / height;\n    this.boxUid = 0;\n  }\n\n  _createClass(GridIndex, [{\n    key: \"insert\",\n    value: function insert(key, x1, y1, x2, y2) {\n      this.forEachCell(x1, y1, x2, y2, this.insertBoxCell, this.boxUid++);\n      this.boxKeys.push(key);\n      this.bboxes.push(x1);\n      this.bboxes.push(y1);\n      this.bboxes.push(x2);\n      this.bboxes.push(y2);\n    }\n  }, {\n    key: \"query\",\n    value: function query(x1, y1, x2, y2, predicate) {\n      return this.queryHitTest(x1, y1, x2, y2, false, predicate);\n    }\n  }, {\n    key: \"hitTest\",\n    value: function hitTest(x1, y1, x2, y2, predicate) {\n      return this.queryHitTest(x1, y1, x2, y2, true, predicate);\n    }\n  }, {\n    key: \"insertBoxCell\",\n    value: function insertBoxCell(x1, y1, x2, y2, cellIndex, uid) {\n      this.boxCells[cellIndex].push(uid);\n    }\n  }, {\n    key: \"queryHitTest\",\n    value: function queryHitTest(x1, y1, x2, y2, hitTest, predicate) {\n      if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {\n        return hitTest ? false : [];\n      }\n\n      var result = [];\n\n      if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {\n        if (hitTest) {\n          return true;\n        }\n\n        for (var boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {\n          result.push({\n            key: this.boxKeys[boxUid],\n            x1: this.bboxes[boxUid * 4],\n            y1: this.bboxes[boxUid * 4 + 1],\n            x2: this.bboxes[boxUid * 4 + 2],\n            y2: this.bboxes[boxUid * 4 + 3]\n          });\n        }\n\n        return predicate ? result.filter(predicate) : result;\n      }\n\n      var queryArgs = {\n        hitTest: hitTest,\n        seenUids: {\n          box: {},\n          circle: {}\n        }\n      };\n      this.forEachCell(x1, y1, x2, y2, this.queryCell, result, queryArgs, predicate);\n      return hitTest ? result.length > 0 : result;\n    }\n  }, {\n    key: \"queryCell\",\n    value: function queryCell(x1, y1, x2, y2, cellIndex, result, queryArgs, predicate) {\n      var seenUids = queryArgs.seenUids;\n      var boxCell = this.boxCells[cellIndex];\n\n      if (boxCell !== null) {\n        var bboxes = this.bboxes;\n\n        var _iterator = _createForOfIteratorHelper(boxCell),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var boxUid = _step.value;\n\n            if (!seenUids.box[boxUid]) {\n              seenUids.box[boxUid] = true;\n              var offset = boxUid * 4;\n\n              if (x1 <= bboxes[offset + 2] && y1 <= bboxes[offset + 3] && x2 >= bboxes[offset + 0] && y2 >= bboxes[offset + 1] && (!predicate || predicate(this.boxKeys[boxUid]))) {\n                if (queryArgs.hitTest) {\n                  result.push(true);\n                  return true;\n                }\n\n                result.push({\n                  key: this.boxKeys[boxUid],\n                  x1: bboxes[offset],\n                  y1: bboxes[offset + 1],\n                  x2: bboxes[offset + 2],\n                  y2: bboxes[offset + 3]\n                });\n              }\n            }\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"forEachCell\",\n    value: function forEachCell(x1, y1, x2, y2, fn, arg1, arg2, predicate) {\n      var cx1 = this.convertToXCellCoord(x1);\n      var cy1 = this.convertToYCellCoord(y1);\n      var cx2 = this.convertToXCellCoord(x2);\n      var cy2 = this.convertToYCellCoord(y2);\n\n      for (var x = cx1; x <= cx2; x++) {\n        for (var y = cy1; y <= cy2; y++) {\n          var cellIndex = this.xCellCount * y + x;\n\n          if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, predicate)) {\n            return;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"convertToXCellCoord\",\n    value: function convertToXCellCoord(x) {\n      return Math.max(0, Math.min(this.xCellCount - 1, Math.floor(x * this.xScale)));\n    }\n  }, {\n    key: \"convertToYCellCoord\",\n    value: function convertToYCellCoord(y) {\n      return Math.max(0, Math.min(this.yCellCount - 1, Math.floor(y * this.yScale)));\n    }\n  }]);\n\n  return GridIndex;\n}();\n\nexport default GridIndex;","map":{"version":3,"sources":["../../src/utils/grid-index.ts"],"names":["GridIndex","boxCells","Math","width","height","i","x2","x1","y2","y1","hitTest","result","boxUid","key","predicate","queryArgs","seenUids","box","circle","boxCell","bboxes","offset","cx1","cy1","cx2","cy2","x","y","cellIndex","fn"],"mappings":"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","sourcesContent":["interface IQueryArgs {\n  hitTest: boolean;\n  seenUids: { box: any; circle: any };\n}\ntype CallBack = (...args: any[]) => any;\n/**\n * 网格索引，相比 @mapbox/grid-index，在简单计算碰撞检测结果时效率更高\n * @see https://zhuanlan.zhihu.com/p/74373214\n */\nclass GridIndex {\n  private boxCells: number[][] = [];\n  private xCellCount: number;\n  private yCellCount: number;\n  private boxKeys: string[];\n  private bboxes: number[];\n  private width: number;\n  private height: number;\n  private xScale: number;\n  private yScale: number;\n  private boxUid: number;\n\n  constructor(width: number, height: number, cellSize: number) {\n    const boxCells = this.boxCells;\n\n    this.xCellCount = Math.ceil(width / cellSize);\n    this.yCellCount = Math.ceil(height / cellSize);\n\n    for (let i = 0; i < this.xCellCount * this.yCellCount; i++) {\n      boxCells.push([]);\n    }\n    this.boxKeys = [];\n    this.bboxes = [];\n\n    this.width = width;\n    this.height = height;\n    this.xScale = this.xCellCount / width;\n    this.yScale = this.yCellCount / height;\n    this.boxUid = 0;\n  }\n\n  public insert(key: any, x1: number, y1: number, x2: number, y2: number) {\n    this.forEachCell(x1, y1, x2, y2, this.insertBoxCell, this.boxUid++);\n    this.boxKeys.push(key);\n    this.bboxes.push(x1);\n    this.bboxes.push(y1);\n    this.bboxes.push(x2);\n    this.bboxes.push(y2);\n  }\n\n  public query(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    predicate?: CallBack,\n  ) {\n    return this.queryHitTest(x1, y1, x2, y2, false, predicate);\n  }\n\n  public hitTest(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    predicate?: CallBack,\n  ) {\n    return this.queryHitTest(x1, y1, x2, y2, true, predicate);\n  }\n\n  private insertBoxCell(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    cellIndex: number,\n    uid: number,\n  ) {\n    this.boxCells[cellIndex].push(uid);\n  }\n\n  private queryHitTest(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    hitTest: boolean,\n    predicate?: CallBack,\n  ) {\n    if (x2 < 0 || x1 > this.width || y2 < 0 || y1 > this.height) {\n      return hitTest ? false : [];\n    }\n    const result: any[] = [];\n    if (x1 <= 0 && y1 <= 0 && this.width <= x2 && this.height <= y2) {\n      // 这一步是高效的关键，后续精确碰撞检测结果在计算文本可见性时并不需要\n      if (hitTest) {\n        return true;\n      }\n      for (let boxUid = 0; boxUid < this.boxKeys.length; boxUid++) {\n        result.push({\n          key: this.boxKeys[boxUid],\n          x1: this.bboxes[boxUid * 4],\n          y1: this.bboxes[boxUid * 4 + 1],\n          x2: this.bboxes[boxUid * 4 + 2],\n          y2: this.bboxes[boxUid * 4 + 3],\n        });\n      }\n      return predicate ? result.filter(predicate) : result;\n    }\n\n    const queryArgs = {\n      hitTest,\n      seenUids: { box: {}, circle: {} },\n    };\n    this.forEachCell(\n      x1,\n      y1,\n      x2,\n      y2,\n      this.queryCell,\n      result,\n      queryArgs,\n      predicate,\n    );\n    return hitTest ? result.length > 0 : result;\n  }\n\n  private queryCell(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    cellIndex: number,\n    result: any[],\n    queryArgs?: any,\n    predicate?: CallBack,\n  ) {\n    const seenUids = queryArgs.seenUids;\n    const boxCell = this.boxCells[cellIndex];\n    if (boxCell !== null) {\n      const bboxes = this.bboxes;\n      for (const boxUid of boxCell) {\n        if (!seenUids.box[boxUid]) {\n          seenUids.box[boxUid] = true;\n          const offset = boxUid * 4;\n          if (\n            x1 <= bboxes[offset + 2] &&\n            y1 <= bboxes[offset + 3] &&\n            x2 >= bboxes[offset + 0] &&\n            y2 >= bboxes[offset + 1] &&\n            (!predicate || predicate(this.boxKeys[boxUid]))\n          ) {\n            if (queryArgs.hitTest) {\n              result.push(true);\n              return true;\n            }\n            result.push({\n              key: this.boxKeys[boxUid],\n              x1: bboxes[offset],\n              y1: bboxes[offset + 1],\n              x2: bboxes[offset + 2],\n              y2: bboxes[offset + 3],\n            });\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  private forEachCell(\n    x1: number,\n    y1: number,\n    x2: number,\n    y2: number,\n    fn: CallBack,\n    arg1: any[] | number,\n    arg2?: IQueryArgs,\n    predicate?: CallBack,\n  ) {\n    const cx1 = this.convertToXCellCoord(x1);\n    const cy1 = this.convertToYCellCoord(y1);\n    const cx2 = this.convertToXCellCoord(x2);\n    const cy2 = this.convertToYCellCoord(y2);\n\n    for (let x = cx1; x <= cx2; x++) {\n      for (let y = cy1; y <= cy2; y++) {\n        const cellIndex = this.xCellCount * y + x;\n        if (fn.call(this, x1, y1, x2, y2, cellIndex, arg1, arg2, predicate)) {\n          return;\n        }\n      }\n    }\n  }\n\n  private convertToXCellCoord(x: number) {\n    return Math.max(\n      0,\n      Math.min(this.xCellCount - 1, Math.floor(x * this.xScale)),\n    );\n  }\n\n  private convertToYCellCoord(y: number) {\n    return Math.max(\n      0,\n      Math.min(this.yCellCount - 1, Math.floor(y * this.yScale)),\n    );\n  }\n}\n\nexport default GridIndex;\n"]},"metadata":{},"sourceType":"module"}