{"ast":null,"code":"import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Geometry } from './geometry';\nexport class Ellipse extends Geometry {\n  constructor(x, y, a, b) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n    this.a = a == null ? 0 : a;\n    this.b = b == null ? 0 : b;\n  }\n\n  get [Symbol.toStringTag]() {\n    return Ellipse.toStringTag;\n  }\n\n  get center() {\n    return new Point(this.x, this.y);\n  }\n  /**\n   * Returns a rectangle that is the bounding box of the ellipse.\n   */\n\n\n  bbox() {\n    return Rectangle.fromEllipse(this);\n  }\n  /**\n   * Returns a point that is the center of the ellipse.\n   */\n\n\n  getCenter() {\n    return this.center;\n  }\n\n  inflate(dx, dy) {\n    const w = dx;\n    const h = dy != null ? dy : dx;\n    this.a += 2 * w;\n    this.b += 2 * h;\n    return this;\n  }\n\n  normalizedDistance(x, y) {\n    const ref = Point.create(x, y);\n    const dx = ref.x - this.x;\n    const dy = ref.y - this.y;\n    const a = this.a;\n    const b = this.b;\n    return dx * dx / (a * a) + dy * dy / (b * b);\n  }\n\n  containsPoint(x, y) {\n    return this.normalizedDistance(x, y) <= 1;\n  }\n  /**\n   * Returns an array of the intersection points of the ellipse and the line.\n   * Returns `null` if no intersection exists.\n   */\n\n\n  intersectsWithLine(line) {\n    const intersections = [];\n    const rx = this.a;\n    const ry = this.b;\n    const a1 = line.start;\n    const a2 = line.end;\n    const dir = line.vector();\n    const diff = a1.diff(new Point(this.x, this.y));\n    const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n    const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n    const a = dir.dot(mDir);\n    const b = dir.dot(mDiff);\n    const c = diff.dot(mDiff) - 1.0;\n    const d = b * b - a * c;\n\n    if (d < 0) {\n      return null;\n    }\n\n    if (d > 0) {\n      const root = Math.sqrt(d);\n      const ta = (-b - root) / a;\n      const tb = (-b + root) / a;\n\n      if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n        // outside\n        return null;\n      }\n\n      if (ta >= 0 && ta <= 1) {\n        intersections.push(a1.lerp(a2, ta));\n      }\n\n      if (tb >= 0 && tb <= 1) {\n        intersections.push(a1.lerp(a2, tb));\n      }\n    } else {\n      const t = -b / a;\n\n      if (t >= 0 && t <= 1) {\n        intersections.push(a1.lerp(a2, t));\n      } else {\n        // outside\n        return null;\n      }\n    }\n\n    return intersections;\n  }\n  /**\n   * Returns the point on the boundary of the ellipse that is the\n   * intersection of the ellipse with a line starting in the center\n   * of the ellipse ending in the point `p`.\n   *\n   * If angle is specified, the intersection will take into account\n   * the rotation of the ellipse by angle degrees around its center.\n   */\n\n\n  intersectsWithLineFromCenterToPoint(p) {\n    let angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    const ref = Point.clone(p);\n\n    if (angle) {\n      ref.rotate(angle, this.getCenter());\n    }\n\n    const dx = ref.x - this.x;\n    const dy = ref.y - this.y;\n    let result;\n\n    if (dx === 0) {\n      result = this.bbox().getNearestPointToPoint(ref);\n\n      if (angle) {\n        return result.rotate(-angle, this.getCenter());\n      }\n\n      return result;\n    }\n\n    const m = dy / dx;\n    const mSquared = m * m;\n    const aSquared = this.a * this.a;\n    const bSquared = this.b * this.b;\n    let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));\n    x = dx < 0 ? -x : x;\n    const y = m * x;\n    result = new Point(this.x + x, this.y + y);\n\n    if (angle) {\n      return result.rotate(-angle, this.getCenter());\n    }\n\n    return result;\n  }\n  /**\n   * Returns the angle between the x-axis and the tangent from a point. It is\n   * valid for points lying on the ellipse boundary only.\n   */\n\n\n  tangentTheta(p) {\n    const ref = Point.clone(p);\n    const x0 = ref.x;\n    const y0 = ref.y;\n    const a = this.a;\n    const b = this.b;\n    const center = this.bbox().center;\n    const cx = center.x;\n    const cy = center.y;\n    const refPointDelta = 30;\n    const q1 = x0 > center.x + a / 2;\n    const q3 = x0 < center.x - a / 2;\n    let x;\n    let y;\n\n    if (q1 || q3) {\n      y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n      x = a * a / (x0 - cx) - a * a * (y0 - cy) * (y - cy) / (b * b * (x0 - cx)) + cx;\n    } else {\n      x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n      y = b * b / (y0 - cy) - b * b * (x0 - cx) * (x - cx) / (a * a * (y0 - cy)) + cy;\n    }\n\n    return new Point(x, y).theta(ref);\n  }\n\n  scale(sx, sy) {\n    this.a *= sx;\n    this.b *= sy;\n    return this;\n  }\n\n  rotate(angle, origin) {\n    const rect = Rectangle.fromEllipse(this);\n    rect.rotate(angle, origin);\n    const ellipse = Ellipse.fromRect(rect);\n    this.a = ellipse.a;\n    this.b = ellipse.b;\n    this.x = ellipse.x;\n    this.y = ellipse.y;\n    return this;\n  }\n\n  translate(dx, dy) {\n    const p = Point.create(dx, dy);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n\n  equals(ellipse) {\n    return ellipse != null && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n  }\n\n  clone() {\n    return new Ellipse(this.x, this.y, this.a, this.b);\n  }\n\n  toJSON() {\n    return {\n      x: this.x,\n      y: this.y,\n      a: this.a,\n      b: this.b\n    };\n  }\n\n  serialize() {\n    return `${this.x} ${this.y} ${this.a} ${this.b}`;\n  }\n\n}\n\n(function (Ellipse) {\n  Ellipse.toStringTag = `X6.Geometry.${Ellipse.name}`;\n\n  function isEllipse(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Ellipse) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const ellipse = instance;\n\n    if ((tag == null || tag === Ellipse.toStringTag) && typeof ellipse.x === 'number' && typeof ellipse.y === 'number' && typeof ellipse.a === 'number' && typeof ellipse.b === 'number' && typeof ellipse.inflate === 'function' && typeof ellipse.normalizedDistance === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Ellipse.isEllipse = isEllipse;\n})(Ellipse || (Ellipse = {}));\n\n(function (Ellipse) {\n  function create(x, y, a, b) {\n    if (x == null || typeof x === 'number') {\n      return new Ellipse(x, y, a, b);\n    }\n\n    return parse(x);\n  }\n\n  Ellipse.create = create;\n\n  function parse(e) {\n    if (Ellipse.isEllipse(e)) {\n      return e.clone();\n    }\n\n    if (Array.isArray(e)) {\n      return new Ellipse(e[0], e[1], e[2], e[3]);\n    }\n\n    return new Ellipse(e.x, e.y, e.a, e.b);\n  }\n\n  Ellipse.parse = parse;\n\n  function fromRect(rect) {\n    const center = rect.center;\n    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);\n  }\n\n  Ellipse.fromRect = fromRect;\n})(Ellipse || (Ellipse = {}));","map":{"version":3,"sources":["../../src/geometry/ellipse.ts"],"names":[],"mappings":"AAAA,SAAS,KAAT,QAAsB,SAAtB;AAEA,SAAS,SAAT,QAA0B,aAA1B;AACA,SAAS,QAAT,QAAyB,YAAzB;AAEA,OAAM,MAAO,OAAP,SAAuB,QAAvB,CAA+B;AAcnC,EAAA,WAAA,CAAY,CAAZ,EAAwB,CAAxB,EAAoC,CAApC,EAAgD,CAAhD,EAA0D;AACxD;AACA,SAAK,CAAL,GAAS,CAAC,IAAI,IAAL,GAAY,CAAZ,GAAgB,CAAzB;AACA,SAAK,CAAL,GAAS,CAAC,IAAI,IAAL,GAAY,CAAZ,GAAgB,CAAzB;AACA,SAAK,CAAL,GAAS,CAAC,IAAI,IAAL,GAAY,CAAZ,GAAgB,CAAzB;AACA,SAAK,CAAL,GAAS,CAAC,IAAI,IAAL,GAAY,CAAZ,GAAgB,CAAzB;AACD;;AAdgC,OAAlB,MAAM,CAAC,WAAW,IAAC;AAChC,WAAO,OAAO,CAAC,WAAf;AACD;;AAES,MAAN,MAAM,GAAA;AACR,WAAO,IAAI,KAAJ,CAAU,KAAK,CAAf,EAAkB,KAAK,CAAvB,CAAP;AACD;AAUD;;AAEG;;;AACH,EAAA,IAAI,GAAA;AACF,WAAO,SAAS,CAAC,WAAV,CAAsB,IAAtB,CAAP;AACD;AAED;;AAEG;;;AACH,EAAA,SAAS,GAAA;AACP,WAAO,KAAK,MAAZ;AACD;;AAWD,EAAA,OAAO,CAAC,EAAD,EAAa,EAAb,EAAwB;AAC7B,UAAM,CAAC,GAAG,EAAV;AACA,UAAM,CAAC,GAAG,EAAE,IAAI,IAAN,GAAa,EAAb,GAAkB,EAA5B;AACA,SAAK,CAAL,IAAU,IAAI,CAAd;AACA,SAAK,CAAL,IAAU,IAAI,CAAd;AAEA,WAAO,IAAP;AACD;;AASD,EAAA,kBAAkB,CAChB,CADgB,EAEhB,CAFgB,EAEN;AAEV,UAAM,GAAG,GAAG,KAAK,CAAC,MAAN,CAAa,CAAb,EAAgB,CAAhB,CAAZ;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAJ,GAAQ,KAAK,CAAxB;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAJ,GAAQ,KAAK,CAAxB;AACA,UAAM,CAAC,GAAG,KAAK,CAAf;AACA,UAAM,CAAC,GAAG,KAAK,CAAf;AAEA,WAAQ,EAAE,GAAG,EAAN,IAAa,CAAC,GAAG,CAAjB,IAAuB,EAAE,GAAG,EAAN,IAAa,CAAC,GAAG,CAAjB,CAA7B;AACD;;AAQD,EAAA,aAAa,CAAC,CAAD,EAAgD,CAAhD,EAA0D;AACrE,WAAO,KAAK,kBAAL,CAAwB,CAAxB,EAAqC,CAArC,KAAqD,CAA5D;AACD;AAED;;;AAGG;;;AACH,EAAA,kBAAkB,CAAC,IAAD,EAAW;AAC3B,UAAM,aAAa,GAAG,EAAtB;AACA,UAAM,EAAE,GAAG,KAAK,CAAhB;AACA,UAAM,EAAE,GAAG,KAAK,CAAhB;AACA,UAAM,EAAE,GAAG,IAAI,CAAC,KAAhB;AACA,UAAM,EAAE,GAAG,IAAI,CAAC,GAAhB;AACA,UAAM,GAAG,GAAG,IAAI,CAAC,MAAL,EAAZ;AACA,UAAM,IAAI,GAAG,EAAE,CAAC,IAAH,CAAQ,IAAI,KAAJ,CAAU,KAAK,CAAf,EAAkB,KAAK,CAAvB,CAAR,CAAb;AACA,UAAM,IAAI,GAAG,IAAI,KAAJ,CAAU,GAAG,CAAC,CAAJ,IAAS,EAAE,GAAG,EAAd,CAAV,EAA6B,GAAG,CAAC,CAAJ,IAAS,EAAE,GAAG,EAAd,CAA7B,CAAb;AACA,UAAM,KAAK,GAAG,IAAI,KAAJ,CAAU,IAAI,CAAC,CAAL,IAAU,EAAE,GAAG,EAAf,CAAV,EAA8B,IAAI,CAAC,CAAL,IAAU,EAAE,GAAG,EAAf,CAA9B,CAAd;AAEA,UAAM,CAAC,GAAG,GAAG,CAAC,GAAJ,CAAQ,IAAR,CAAV;AACA,UAAM,CAAC,GAAG,GAAG,CAAC,GAAJ,CAAQ,KAAR,CAAV;AACA,UAAM,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,IAAkB,GAA5B;AACA,UAAM,CAAC,GAAG,CAAC,GAAG,CAAJ,GAAQ,CAAC,GAAG,CAAtB;;AAEA,QAAI,CAAC,GAAG,CAAR,EAAW;AACT,aAAO,IAAP;AACD;;AAED,QAAI,CAAC,GAAG,CAAR,EAAW;AACT,YAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,CAAV,CAAb;AACA,YAAM,EAAE,GAAG,CAAC,CAAC,CAAD,GAAK,IAAN,IAAc,CAAzB;AACA,YAAM,EAAE,GAAG,CAAC,CAAC,CAAD,GAAK,IAAN,IAAc,CAAzB;;AAEA,UAAI,CAAC,EAAE,GAAG,CAAL,IAAU,EAAE,GAAG,CAAhB,MAAuB,EAAE,GAAG,CAAL,IAAU,EAAE,GAAG,CAAtC,CAAJ,EAA8C;AAC5C;AACA,eAAO,IAAP;AACD;;AAED,UAAI,EAAE,IAAI,CAAN,IAAW,EAAE,IAAI,CAArB,EAAwB;AACtB,QAAA,aAAa,CAAC,IAAd,CAAmB,EAAE,CAAC,IAAH,CAAQ,EAAR,EAAY,EAAZ,CAAnB;AACD;;AAED,UAAI,EAAE,IAAI,CAAN,IAAW,EAAE,IAAI,CAArB,EAAwB;AACtB,QAAA,aAAa,CAAC,IAAd,CAAmB,EAAE,CAAC,IAAH,CAAQ,EAAR,EAAY,EAAZ,CAAnB;AACD;AACF,KAjBD,MAiBO;AACL,YAAM,CAAC,GAAG,CAAC,CAAD,GAAK,CAAf;;AACA,UAAI,CAAC,IAAI,CAAL,IAAU,CAAC,IAAI,CAAnB,EAAsB;AACpB,QAAA,aAAa,CAAC,IAAd,CAAmB,EAAE,CAAC,IAAH,CAAQ,EAAR,EAAY,CAAZ,CAAnB;AACD,OAFD,MAEO;AACL;AACA,eAAO,IAAP;AACD;AACF;;AAED,WAAO,aAAP;AACD;AAED;;;;;;;AAOG;;;AACH,EAAA,mCAAmC,CACjC,CADiC,EAExB;AAAA,QAAT,KAAS,uEAAD,CAAC;AAET,UAAM,GAAG,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAZ;;AACA,QAAI,KAAJ,EAAW;AACT,MAAA,GAAG,CAAC,MAAJ,CAAW,KAAX,EAAkB,KAAK,SAAL,EAAlB;AACD;;AAED,UAAM,EAAE,GAAG,GAAG,CAAC,CAAJ,GAAQ,KAAK,CAAxB;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAJ,GAAQ,KAAK,CAAxB;AACA,QAAI,MAAJ;;AAEA,QAAI,EAAE,KAAK,CAAX,EAAc;AACZ,MAAA,MAAM,GAAG,KAAK,IAAL,GAAY,sBAAZ,CAAmC,GAAnC,CAAT;;AACA,UAAI,KAAJ,EAAW;AACT,eAAO,MAAM,CAAC,MAAP,CAAc,CAAC,KAAf,EAAsB,KAAK,SAAL,EAAtB,CAAP;AACD;;AACD,aAAO,MAAP;AACD;;AAED,UAAM,CAAC,GAAG,EAAE,GAAG,EAAf;AACA,UAAM,QAAQ,GAAG,CAAC,GAAG,CAArB;AACA,UAAM,QAAQ,GAAG,KAAK,CAAL,GAAS,KAAK,CAA/B;AACA,UAAM,QAAQ,GAAG,KAAK,CAAL,GAAS,KAAK,CAA/B;AAEA,QAAI,CAAC,GAAG,IAAI,CAAC,IAAL,CAAU,KAAK,IAAI,QAAJ,GAAe,QAAQ,GAAG,QAA/B,CAAV,CAAR;AACA,IAAA,CAAC,GAAG,EAAE,GAAG,CAAL,GAAS,CAAC,CAAV,GAAc,CAAlB;AAEA,UAAM,CAAC,GAAG,CAAC,GAAG,CAAd;AACA,IAAA,MAAM,GAAG,IAAI,KAAJ,CAAU,KAAK,CAAL,GAAS,CAAnB,EAAsB,KAAK,CAAL,GAAS,CAA/B,CAAT;;AAEA,QAAI,KAAJ,EAAW;AACT,aAAO,MAAM,CAAC,MAAP,CAAc,CAAC,KAAf,EAAsB,KAAK,SAAL,EAAtB,CAAP;AACD;;AAED,WAAO,MAAP;AACD;AAED;;;AAGG;;;AACH,EAAA,YAAY,CAAC,CAAD,EAAqC;AAC/C,UAAM,GAAG,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAZ;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAf;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAf;AACA,UAAM,CAAC,GAAG,KAAK,CAAf;AACA,UAAM,CAAC,GAAG,KAAK,CAAf;AACA,UAAM,MAAM,GAAG,KAAK,IAAL,GAAY,MAA3B;AACA,UAAM,EAAE,GAAG,MAAM,CAAC,CAAlB;AACA,UAAM,EAAE,GAAG,MAAM,CAAC,CAAlB;AACA,UAAM,aAAa,GAAG,EAAtB;AAEA,UAAM,EAAE,GAAG,EAAE,GAAG,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,CAA/B;AACA,UAAM,EAAE,GAAG,EAAE,GAAG,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,CAA/B;AAEA,QAAI,CAAJ;AACA,QAAI,CAAJ;;AAEA,QAAI,EAAE,IAAI,EAAV,EAAc;AACZ,MAAA,CAAC,GAAG,EAAE,GAAG,MAAM,CAAC,CAAZ,GAAgB,EAAE,GAAG,aAArB,GAAqC,EAAE,GAAG,aAA9C;AACA,MAAA,CAAC,GACE,CAAC,GAAG,CAAL,IAAW,EAAE,GAAG,EAAhB,IACC,CAAC,GAAG,CAAJ,IAAS,EAAE,GAAG,EAAd,KAAqB,CAAC,GAAG,EAAzB,CAAD,IAAkC,CAAC,GAAG,CAAJ,IAAS,EAAE,GAAG,EAAd,CAAlC,CADA,GAEA,EAHF;AAID,KAND,MAMO;AACL,MAAA,CAAC,GAAG,EAAE,GAAG,MAAM,CAAC,CAAZ,GAAgB,EAAE,GAAG,aAArB,GAAqC,EAAE,GAAG,aAA9C;AACA,MAAA,CAAC,GACE,CAAC,GAAG,CAAL,IAAW,EAAE,GAAG,EAAhB,IACC,CAAC,GAAG,CAAJ,IAAS,EAAE,GAAG,EAAd,KAAqB,CAAC,GAAG,EAAzB,CAAD,IAAkC,CAAC,GAAG,CAAJ,IAAS,EAAE,GAAG,EAAd,CAAlC,CADA,GAEA,EAHF;AAID;;AAED,WAAO,IAAI,KAAJ,CAAU,CAAV,EAAa,CAAb,EAAgB,KAAhB,CAAsB,GAAtB,CAAP;AACD;;AAED,EAAA,KAAK,CAAC,EAAD,EAAa,EAAb,EAAuB;AAC1B,SAAK,CAAL,IAAU,EAAV;AACA,SAAK,CAAL,IAAU,EAAV;AACA,WAAO,IAAP;AACD;;AAED,EAAA,MAAM,CAAC,KAAD,EAAgB,MAAhB,EAA0D;AAC9D,UAAM,IAAI,GAAG,SAAS,CAAC,WAAV,CAAsB,IAAtB,CAAb;AACA,IAAA,IAAI,CAAC,MAAL,CAAY,KAAZ,EAAmB,MAAnB;AACA,UAAM,OAAO,GAAG,OAAO,CAAC,QAAR,CAAiB,IAAjB,CAAhB;AACA,SAAK,CAAL,GAAS,OAAO,CAAC,CAAjB;AACA,SAAK,CAAL,GAAS,OAAO,CAAC,CAAjB;AACA,SAAK,CAAL,GAAS,OAAO,CAAC,CAAjB;AACA,SAAK,CAAL,GAAS,OAAO,CAAC,CAAjB;AACA,WAAO,IAAP;AACD;;AAID,EAAA,SAAS,CAAC,EAAD,EAAiD,EAAjD,EAA4D;AACnE,UAAM,CAAC,GAAG,KAAK,CAAC,MAAN,CAAa,EAAb,EAAiB,EAAjB,CAAV;AACA,SAAK,CAAL,IAAU,CAAC,CAAC,CAAZ;AACA,SAAK,CAAL,IAAU,CAAC,CAAC,CAAZ;AACA,WAAO,IAAP;AACD;;AAED,EAAA,MAAM,CAAC,OAAD,EAAiB;AACrB,WACE,OAAO,IAAI,IAAX,IACA,OAAO,CAAC,CAAR,KAAc,KAAK,CADnB,IAEA,OAAO,CAAC,CAAR,KAAc,KAAK,CAFnB,IAGA,OAAO,CAAC,CAAR,KAAc,KAAK,CAHnB,IAIA,OAAO,CAAC,CAAR,KAAc,KAAK,CALrB;AAOD;;AAED,EAAA,KAAK,GAAA;AACH,WAAO,IAAI,OAAJ,CAAY,KAAK,CAAjB,EAAoB,KAAK,CAAzB,EAA4B,KAAK,CAAjC,EAAoC,KAAK,CAAzC,CAAP;AACD;;AAED,EAAA,MAAM,GAAA;AACJ,WAAO;AAAE,MAAA,CAAC,EAAE,KAAK,CAAV;AAAa,MAAA,CAAC,EAAE,KAAK,CAArB;AAAwB,MAAA,CAAC,EAAE,KAAK,CAAhC;AAAmC,MAAA,CAAC,EAAE,KAAK;AAA3C,KAAP;AACD;;AAED,EAAA,SAAS,GAAA;AACP,WAAO,GAAG,KAAK,CAAC,IAAI,KAAK,CAAC,IAAI,KAAK,CAAC,IAAI,KAAK,CAAC,EAA9C;AACD;;AA7QkC;;AAgRrC,CAAA,UAAiB,OAAjB,EAAwB;AACT,EAAA,OAAA,CAAA,WAAA,GAAc,eAAe,OAAO,CAAC,IAAI,EAAzC;;AAEb,WAAgB,SAAhB,CAA0B,QAA1B,EAAuC;AACrC,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAO,KAAP;AACD;;AAED,QAAI,QAAQ,YAAY,OAAxB,EAAiC;AAC/B,aAAO,IAAP;AACD;;AAED,UAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,WAAR,CAApB;AACA,UAAM,OAAO,GAAG,QAAhB;;AAEA,QACE,CAAC,GAAG,IAAI,IAAP,IAAe,GAAG,KAAK,OAAA,CAAA,WAAxB,KACA,OAAO,OAAO,CAAC,CAAf,KAAqB,QADrB,IAEA,OAAO,OAAO,CAAC,CAAf,KAAqB,QAFrB,IAGA,OAAO,OAAO,CAAC,CAAf,KAAqB,QAHrB,IAIA,OAAO,OAAO,CAAC,CAAf,KAAqB,QAJrB,IAKA,OAAO,OAAO,CAAC,OAAf,KAA2B,UAL3B,IAMA,OAAO,OAAO,CAAC,kBAAf,KAAsC,UAPxC,EAQE;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD;;AAzBe,EAAA,OAAA,CAAA,SAAA,GAAS,SAAT;AA0BjB,CA7BD,EAAiB,OAAO,KAAP,OAAO,GAAA,EAAA,CAAxB;;AA0CA,CAAA,UAAiB,OAAjB,EAAwB;AACtB,WAAgB,MAAhB,CACE,CADF,EAEE,CAFF,EAGE,CAHF,EAIE,CAJF,EAIY;AAEV,QAAI,CAAC,IAAI,IAAL,IAAa,OAAO,CAAP,KAAa,QAA9B,EAAwC;AACtC,aAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,CAAP;AACD;;AAED,WAAO,KAAK,CAAC,CAAD,CAAZ;AACD;;AAXe,EAAA,OAAA,CAAA,MAAA,GAAM,MAAN;;AAahB,WAAgB,KAAhB,CAAsB,CAAtB,EAA4D;AAC1D,QAAI,OAAO,CAAC,SAAR,CAAkB,CAAlB,CAAJ,EAA0B;AACxB,aAAO,CAAC,CAAC,KAAF,EAAP;AACD;;AAED,QAAI,KAAK,CAAC,OAAN,CAAc,CAAd,CAAJ,EAAsB;AACpB,aAAO,IAAI,OAAJ,CAAY,CAAC,CAAC,CAAD,CAAb,EAAkB,CAAC,CAAC,CAAD,CAAnB,EAAwB,CAAC,CAAC,CAAD,CAAzB,EAA8B,CAAC,CAAC,CAAD,CAA/B,CAAP;AACD;;AAED,WAAO,IAAI,OAAJ,CAAY,CAAC,CAAC,CAAd,EAAiB,CAAC,CAAC,CAAnB,EAAsB,CAAC,CAAC,CAAxB,EAA2B,CAAC,CAAC,CAA7B,CAAP;AACD;;AAVe,EAAA,OAAA,CAAA,KAAA,GAAK,KAAL;;AAYhB,WAAgB,QAAhB,CAAyB,IAAzB,EAAwC;AACtC,UAAM,MAAM,GAAG,IAAI,CAAC,MAApB;AACA,WAAO,IAAI,OAAJ,CAAY,MAAM,CAAC,CAAnB,EAAsB,MAAM,CAAC,CAA7B,EAAgC,IAAI,CAAC,KAAL,GAAa,CAA7C,EAAgD,IAAI,CAAC,MAAL,GAAc,CAA9D,CAAP;AACD;;AAHe,EAAA,OAAA,CAAA,QAAA,GAAQ,QAAR;AAIjB,CA9BD,EAAiB,OAAO,KAAP,OAAO,GAAA,EAAA,CAAxB","sourceRoot":"","sourcesContent":["import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Geometry } from './geometry';\nexport class Ellipse extends Geometry {\n    constructor(x, y, a, b) {\n        super();\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n        this.a = a == null ? 0 : a;\n        this.b = b == null ? 0 : b;\n    }\n    get [Symbol.toStringTag]() {\n        return Ellipse.toStringTag;\n    }\n    get center() {\n        return new Point(this.x, this.y);\n    }\n    /**\n     * Returns a rectangle that is the bounding box of the ellipse.\n     */\n    bbox() {\n        return Rectangle.fromEllipse(this);\n    }\n    /**\n     * Returns a point that is the center of the ellipse.\n     */\n    getCenter() {\n        return this.center;\n    }\n    inflate(dx, dy) {\n        const w = dx;\n        const h = dy != null ? dy : dx;\n        this.a += 2 * w;\n        this.b += 2 * h;\n        return this;\n    }\n    normalizedDistance(x, y) {\n        const ref = Point.create(x, y);\n        const dx = ref.x - this.x;\n        const dy = ref.y - this.y;\n        const a = this.a;\n        const b = this.b;\n        return (dx * dx) / (a * a) + (dy * dy) / (b * b);\n    }\n    containsPoint(x, y) {\n        return this.normalizedDistance(x, y) <= 1;\n    }\n    /**\n     * Returns an array of the intersection points of the ellipse and the line.\n     * Returns `null` if no intersection exists.\n     */\n    intersectsWithLine(line) {\n        const intersections = [];\n        const rx = this.a;\n        const ry = this.b;\n        const a1 = line.start;\n        const a2 = line.end;\n        const dir = line.vector();\n        const diff = a1.diff(new Point(this.x, this.y));\n        const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n        const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n        const a = dir.dot(mDir);\n        const b = dir.dot(mDiff);\n        const c = diff.dot(mDiff) - 1.0;\n        const d = b * b - a * c;\n        if (d < 0) {\n            return null;\n        }\n        if (d > 0) {\n            const root = Math.sqrt(d);\n            const ta = (-b - root) / a;\n            const tb = (-b + root) / a;\n            if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n                // outside\n                return null;\n            }\n            if (ta >= 0 && ta <= 1) {\n                intersections.push(a1.lerp(a2, ta));\n            }\n            if (tb >= 0 && tb <= 1) {\n                intersections.push(a1.lerp(a2, tb));\n            }\n        }\n        else {\n            const t = -b / a;\n            if (t >= 0 && t <= 1) {\n                intersections.push(a1.lerp(a2, t));\n            }\n            else {\n                // outside\n                return null;\n            }\n        }\n        return intersections;\n    }\n    /**\n     * Returns the point on the boundary of the ellipse that is the\n     * intersection of the ellipse with a line starting in the center\n     * of the ellipse ending in the point `p`.\n     *\n     * If angle is specified, the intersection will take into account\n     * the rotation of the ellipse by angle degrees around its center.\n     */\n    intersectsWithLineFromCenterToPoint(p, angle = 0) {\n        const ref = Point.clone(p);\n        if (angle) {\n            ref.rotate(angle, this.getCenter());\n        }\n        const dx = ref.x - this.x;\n        const dy = ref.y - this.y;\n        let result;\n        if (dx === 0) {\n            result = this.bbox().getNearestPointToPoint(ref);\n            if (angle) {\n                return result.rotate(-angle, this.getCenter());\n            }\n            return result;\n        }\n        const m = dy / dx;\n        const mSquared = m * m;\n        const aSquared = this.a * this.a;\n        const bSquared = this.b * this.b;\n        let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));\n        x = dx < 0 ? -x : x;\n        const y = m * x;\n        result = new Point(this.x + x, this.y + y);\n        if (angle) {\n            return result.rotate(-angle, this.getCenter());\n        }\n        return result;\n    }\n    /**\n     * Returns the angle between the x-axis and the tangent from a point. It is\n     * valid for points lying on the ellipse boundary only.\n     */\n    tangentTheta(p) {\n        const ref = Point.clone(p);\n        const x0 = ref.x;\n        const y0 = ref.y;\n        const a = this.a;\n        const b = this.b;\n        const center = this.bbox().center;\n        const cx = center.x;\n        const cy = center.y;\n        const refPointDelta = 30;\n        const q1 = x0 > center.x + a / 2;\n        const q3 = x0 < center.x - a / 2;\n        let x;\n        let y;\n        if (q1 || q3) {\n            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n            x =\n                (a * a) / (x0 - cx) -\n                    (a * a * (y0 - cy) * (y - cy)) / (b * b * (x0 - cx)) +\n                    cx;\n        }\n        else {\n            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n            y =\n                (b * b) / (y0 - cy) -\n                    (b * b * (x0 - cx) * (x - cx)) / (a * a * (y0 - cy)) +\n                    cy;\n        }\n        return new Point(x, y).theta(ref);\n    }\n    scale(sx, sy) {\n        this.a *= sx;\n        this.b *= sy;\n        return this;\n    }\n    rotate(angle, origin) {\n        const rect = Rectangle.fromEllipse(this);\n        rect.rotate(angle, origin);\n        const ellipse = Ellipse.fromRect(rect);\n        this.a = ellipse.a;\n        this.b = ellipse.b;\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        return this;\n    }\n    translate(dx, dy) {\n        const p = Point.create(dx, dy);\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    }\n    equals(ellipse) {\n        return (ellipse != null &&\n            ellipse.x === this.x &&\n            ellipse.y === this.y &&\n            ellipse.a === this.a &&\n            ellipse.b === this.b);\n    }\n    clone() {\n        return new Ellipse(this.x, this.y, this.a, this.b);\n    }\n    toJSON() {\n        return { x: this.x, y: this.y, a: this.a, b: this.b };\n    }\n    serialize() {\n        return `${this.x} ${this.y} ${this.a} ${this.b}`;\n    }\n}\n(function (Ellipse) {\n    Ellipse.toStringTag = `X6.Geometry.${Ellipse.name}`;\n    function isEllipse(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Ellipse) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const ellipse = instance;\n        if ((tag == null || tag === Ellipse.toStringTag) &&\n            typeof ellipse.x === 'number' &&\n            typeof ellipse.y === 'number' &&\n            typeof ellipse.a === 'number' &&\n            typeof ellipse.b === 'number' &&\n            typeof ellipse.inflate === 'function' &&\n            typeof ellipse.normalizedDistance === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Ellipse.isEllipse = isEllipse;\n})(Ellipse || (Ellipse = {}));\n(function (Ellipse) {\n    function create(x, y, a, b) {\n        if (x == null || typeof x === 'number') {\n            return new Ellipse(x, y, a, b);\n        }\n        return parse(x);\n    }\n    Ellipse.create = create;\n    function parse(e) {\n        if (Ellipse.isEllipse(e)) {\n            return e.clone();\n        }\n        if (Array.isArray(e)) {\n            return new Ellipse(e[0], e[1], e[2], e[3]);\n        }\n        return new Ellipse(e.x, e.y, e.a, e.b);\n    }\n    Ellipse.parse = parse;\n    function fromRect(rect) {\n        const center = rect.center;\n        return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);\n    }\n    Ellipse.fromRect = fromRect;\n})(Ellipse || (Ellipse = {}));\n//# sourceMappingURL=ellipse.js.map"]},"metadata":{},"sourceType":"module"}