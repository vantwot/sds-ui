{"ast":null,"code":"// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts\n\n/**\n * Given a name and a list of names that are not equal to the name, return a\n * spelling suggestion if there is one that is close enough. Names less than\n * length 3 only check for case-insensitive equality, not Levenshtein distance.\n *\n * - If there is a candidate that's the same except for case, return that.\n * - If there is a candidate that's within one edit of the name, return that.\n * - Otherwise, return the candidate with the smallest Levenshtein distance,\n *     except for candidates:\n *       * With no name\n *       * Whose length differs from the target name by more than 0.34 of the\n *         length of the name.\n *       * Whose levenshtein distance is more than 0.4 of the length of the\n *         name (0.4 allows 1 substitution/transposition for every 5 characters,\n *         and 1 insertion/deletion at 3 characters)\n */\nexport function getSpellingSuggestion(name, candidates, getName) {\n  const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34)); // If the best result isn't better than this, don't bother.\n\n  let bestDistance = Math.floor(name.length * 0.4) + 1;\n  let bestCandidate;\n  let justCheckExactMatches = false;\n  const nameLowerCase = name.toLowerCase(); // eslint-disable-next-line\n\n  for (const candidate of candidates) {\n    const candidateName = getName(candidate);\n\n    if (candidateName !== undefined && Math.abs(candidateName.length - nameLowerCase.length) <= maximumLengthDifference) {\n      const candidateNameLowerCase = candidateName.toLowerCase();\n\n      if (candidateNameLowerCase === nameLowerCase) {\n        if (candidateName === name) {\n          continue;\n        }\n\n        return candidate;\n      }\n\n      if (justCheckExactMatches) {\n        continue;\n      }\n\n      if (candidateName.length < 3) {\n        // Don't bother, user would have noticed a\n        // 2-character name having an extra character.\n        continue;\n      } // Only care about a result better than the best so far.\n\n\n      const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);\n\n      if (distance === undefined) {\n        continue;\n      }\n\n      if (distance < 3) {\n        justCheckExactMatches = true;\n        bestCandidate = candidate;\n      } else {\n        // Debug.assert(distance < bestDistance)\n        bestDistance = distance;\n        bestCandidate = candidate;\n      }\n    }\n  }\n\n  return bestCandidate;\n}\n\nfunction levenshteinWithMax(s1, s2, max) {\n  let previous = new Array(s2.length + 1); // eslint-disable-line\n\n  let current = new Array(s2.length + 1); // eslint-disable-line\n\n  /** Represents any value > max. We don't care about the particular value. */\n\n  const big = max + 1;\n\n  for (let i = 0; i <= s2.length; i += 1) {\n    previous[i] = i;\n  }\n\n  for (let i = 1; i <= s1.length; i += 1) {\n    const c1 = s1.charCodeAt(i - 1);\n    const minJ = i > max ? i - max : 1;\n    const maxJ = s2.length > max + i ? max + i : s2.length;\n    current[0] = i;\n    /** Smallest value of the matrix in the ith column. */\n\n    let colMin = i;\n\n    for (let j = 1; j < minJ; j += 1) {\n      current[j] = big;\n    }\n\n    for (let j = minJ; j <= maxJ; j += 1) {\n      const dist = c1 === s2.charCodeAt(j - 1) ? previous[j - 1] : Math.min(\n      /* delete */\n      previous[j] + 1,\n      /* insert */\n      current[j - 1] + 1,\n      /* substitute */\n      previous[j - 1] + 2);\n      current[j] = dist;\n      colMin = Math.min(colMin, dist);\n    }\n\n    for (let j = maxJ + 1; j <= s2.length; j += 1) {\n      current[j] = big;\n    }\n\n    if (colMin > max) {\n      // Give up -- everything in this column is > max\n      // and it can't get better in future columns.\n      return undefined;\n    }\n\n    const temp = previous;\n    previous = current;\n    current = temp;\n  }\n\n  const res = previous[s2.length];\n  return res > max ? undefined : res;\n}","map":{"version":3,"sources":["../../../src/util/string/suggestion.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["// @see: https://github.com/microsoft/TypeScript/blob/master/src/compiler/checker.ts\n/**\n * Given a name and a list of names that are not equal to the name, return a\n * spelling suggestion if there is one that is close enough. Names less than\n * length 3 only check for case-insensitive equality, not Levenshtein distance.\n *\n * - If there is a candidate that's the same except for case, return that.\n * - If there is a candidate that's within one edit of the name, return that.\n * - Otherwise, return the candidate with the smallest Levenshtein distance,\n *     except for candidates:\n *       * With no name\n *       * Whose length differs from the target name by more than 0.34 of the\n *         length of the name.\n *       * Whose levenshtein distance is more than 0.4 of the length of the\n *         name (0.4 allows 1 substitution/transposition for every 5 characters,\n *         and 1 insertion/deletion at 3 characters)\n */\nexport function getSpellingSuggestion(name, candidates, getName) {\n    const maximumLengthDifference = Math.min(2, Math.floor(name.length * 0.34));\n    // If the best result isn't better than this, don't bother.\n    let bestDistance = Math.floor(name.length * 0.4) + 1;\n    let bestCandidate;\n    let justCheckExactMatches = false;\n    const nameLowerCase = name.toLowerCase();\n    // eslint-disable-next-line\n    for (const candidate of candidates) {\n        const candidateName = getName(candidate);\n        if (candidateName !== undefined &&\n            Math.abs(candidateName.length - nameLowerCase.length) <=\n                maximumLengthDifference) {\n            const candidateNameLowerCase = candidateName.toLowerCase();\n            if (candidateNameLowerCase === nameLowerCase) {\n                if (candidateName === name) {\n                    continue;\n                }\n                return candidate;\n            }\n            if (justCheckExactMatches) {\n                continue;\n            }\n            if (candidateName.length < 3) {\n                // Don't bother, user would have noticed a\n                // 2-character name having an extra character.\n                continue;\n            }\n            // Only care about a result better than the best so far.\n            const distance = levenshteinWithMax(nameLowerCase, candidateNameLowerCase, bestDistance - 1);\n            if (distance === undefined) {\n                continue;\n            }\n            if (distance < 3) {\n                justCheckExactMatches = true;\n                bestCandidate = candidate;\n            }\n            else {\n                // Debug.assert(distance < bestDistance)\n                bestDistance = distance;\n                bestCandidate = candidate;\n            }\n        }\n    }\n    return bestCandidate;\n}\nfunction levenshteinWithMax(s1, s2, max) {\n    let previous = new Array(s2.length + 1); // eslint-disable-line\n    let current = new Array(s2.length + 1); // eslint-disable-line\n    /** Represents any value > max. We don't care about the particular value. */\n    const big = max + 1;\n    for (let i = 0; i <= s2.length; i += 1) {\n        previous[i] = i;\n    }\n    for (let i = 1; i <= s1.length; i += 1) {\n        const c1 = s1.charCodeAt(i - 1);\n        const minJ = i > max ? i - max : 1;\n        const maxJ = s2.length > max + i ? max + i : s2.length;\n        current[0] = i;\n        /** Smallest value of the matrix in the ith column. */\n        let colMin = i;\n        for (let j = 1; j < minJ; j += 1) {\n            current[j] = big;\n        }\n        for (let j = minJ; j <= maxJ; j += 1) {\n            const dist = c1 === s2.charCodeAt(j - 1)\n                ? previous[j - 1]\n                : Math.min(\n                /* delete */ previous[j] + 1, \n                /* insert */ current[j - 1] + 1, \n                /* substitute */ previous[j - 1] + 2);\n            current[j] = dist;\n            colMin = Math.min(colMin, dist);\n        }\n        for (let j = maxJ + 1; j <= s2.length; j += 1) {\n            current[j] = big;\n        }\n        if (colMin > max) {\n            // Give up -- everything in this column is > max\n            // and it can't get better in future columns.\n            return undefined;\n        }\n        const temp = previous;\n        previous = current;\n        current = temp;\n    }\n    const res = previous[s2.length];\n    return res > max ? undefined : res;\n}\n//# sourceMappingURL=suggestion.js.map"]},"metadata":{},"sourceType":"module"}