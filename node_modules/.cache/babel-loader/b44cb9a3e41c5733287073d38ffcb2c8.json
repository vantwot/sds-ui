{"ast":null,"code":"import { Point, Path, Polyline } from '../../geometry';\nimport { NumberExt, FunctionExt } from '../../util';\nexport const ref = {// We do not set `ref` attribute directly on an element.\n  // The attribute itself does not qualify for relative positioning.\n}; // if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n// otherwise, `refX` is the left coordinate of the bounding box\n\nexport const refX = {\n  position: positionWrapper('x', 'width', 'origin')\n};\nexport const refY = {\n  position: positionWrapper('y', 'height', 'origin')\n}; // `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n// coordinate of the reference element.\n\nexport const refDx = {\n  position: positionWrapper('x', 'width', 'corner')\n};\nexport const refDy = {\n  position: positionWrapper('y', 'height', 'corner')\n}; // 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n// the reference element size\n// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\n\nexport const refWidth = {\n  set: setWrapper('width', 'width')\n};\nexport const refHeight = {\n  set: setWrapper('height', 'height')\n};\nexport const refRx = {\n  set: setWrapper('rx', 'width')\n};\nexport const refRy = {\n  set: setWrapper('ry', 'height')\n};\nexport const refRInscribed = {\n  set: (attrName => {\n    const widthFn = setWrapper(attrName, 'width');\n    const heightFn = setWrapper(attrName, 'height');\n    return function (value, options) {\n      const refBBox = options.refBBox;\n      const fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n      return FunctionExt.call(fn, this, value, options);\n    };\n  })('r')\n};\nexport const refRCircumscribed = {\n  set(val, _ref) {\n    let {\n      refBBox\n    } = _ref;\n    let value = parseFloat(val);\n    const percentage = NumberExt.isPercentage(val);\n\n    if (percentage) {\n      value /= 100;\n    }\n\n    const diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n    let rValue;\n\n    if (Number.isFinite(value)) {\n      if (percentage || value >= 0 && value <= 1) {\n        rValue = value * diagonalLength;\n      } else {\n        rValue = Math.max(value + diagonalLength, 0);\n      }\n    }\n\n    return {\n      r: rValue\n    };\n  }\n\n};\nexport const refCx = {\n  set: setWrapper('cx', 'width')\n};\nexport const refCy = {\n  set: setWrapper('cy', 'height')\n};\nexport const refDResetOffset = {\n  set: dWrapper({\n    resetOffset: true\n  })\n};\nexport const refDKeepOffset = {\n  set: dWrapper({\n    resetOffset: false\n  })\n};\nexport const refPointsResetOffset = {\n  set: pointsWrapper({\n    resetOffset: true\n  })\n};\nexport const refPointsKeepOffset = {\n  set: pointsWrapper({\n    resetOffset: false\n  })\n}; // aliases\n// -------\n\nexport const refR = refRInscribed;\nexport const refD = refDResetOffset;\nexport const refPoints = refPointsResetOffset; // Allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\n\nexport const refX2 = refX;\nexport const refY2 = refY;\nexport const refWidth2 = refWidth;\nexport const refHeight2 = refHeight; // utils\n// -----\n\nfunction positionWrapper(axis, dimension, origin) {\n  return (val, _ref2) => {\n    let {\n      refBBox\n    } = _ref2;\n\n    if (val == null) {\n      return null;\n    }\n\n    let value = parseFloat(val);\n    const percentage = NumberExt.isPercentage(val);\n\n    if (percentage) {\n      value /= 100;\n    }\n\n    let delta;\n\n    if (Number.isFinite(value)) {\n      const refOrigin = refBBox[origin];\n\n      if (percentage || value > 0 && value < 1) {\n        delta = refOrigin[axis] + refBBox[dimension] * value;\n      } else {\n        delta = refOrigin[axis] + value;\n      }\n    }\n\n    const point = new Point();\n    point[axis] = delta || 0;\n    return point;\n  };\n}\n\nfunction setWrapper(attrName, dimension) {\n  return function (val, _ref3) {\n    let {\n      refBBox\n    } = _ref3;\n    let value = parseFloat(val);\n    const percentage = NumberExt.isPercentage(val);\n\n    if (percentage) {\n      value /= 100;\n    }\n\n    const attrs = {};\n\n    if (Number.isFinite(value)) {\n      const attrValue = percentage || value >= 0 && value <= 1 ? value * refBBox[dimension] : Math.max(value + refBBox[dimension], 0);\n      attrs[attrName] = attrValue;\n    }\n\n    return attrs;\n  };\n}\n\nfunction shapeWrapper(shapeConstructor, options) {\n  const cacheName = 'x6-shape';\n  const resetOffset = options && options.resetOffset;\n  return function (value, _ref4) {\n    let {\n      view,\n      elem,\n      refBBox\n    } = _ref4;\n    const $elem = view.$(elem);\n    let cache = $elem.data(cacheName);\n\n    if (!cache || cache.value !== value) {\n      // only recalculate if value has changed\n      const cachedShape = shapeConstructor(value);\n      cache = {\n        value,\n        shape: cachedShape,\n        shapeBBox: cachedShape.bbox()\n      };\n      $elem.data(cacheName, cache);\n    }\n\n    const shape = cache.shape.clone();\n    const shapeBBox = cache.shapeBBox.clone();\n    const shapeOrigin = shapeBBox.getOrigin();\n    const refOrigin = refBBox.getOrigin();\n    shapeBBox.x = refOrigin.x;\n    shapeBBox.y = refOrigin.y;\n    const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin); // `maxRectScaleToFit` can give Infinity if width or height is 0\n\n    const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n    const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n    shape.scale(sx, sy, shapeOrigin);\n\n    if (resetOffset) {\n      shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n    }\n\n    return shape;\n  };\n} // `d` attribute for SVGPaths\n\n\nfunction dWrapper(options) {\n  function pathConstructor(value) {\n    return Path.parse(value);\n  }\n\n  const shape = shapeWrapper(pathConstructor, options);\n  return (value, args) => {\n    const path = shape(value, args);\n    return {\n      d: path.serialize()\n    };\n  };\n} // `points` attribute for SVGPolylines and SVGPolygons\n\n\nfunction pointsWrapper(options) {\n  const shape = shapeWrapper(points => new Polyline(points), options);\n  return (value, args) => {\n    const polyline = shape(value, args);\n    return {\n      points: polyline.serialize()\n    };\n  };\n}","map":{"version":3,"sources":["../../../src/registry/attr/ref.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Point, Path, Polyline } from '../../geometry';\nimport { NumberExt, FunctionExt } from '../../util';\nexport const ref = {\n// We do not set `ref` attribute directly on an element.\n// The attribute itself does not qualify for relative positioning.\n};\n// if `refX` is in [0, 1] then `refX` is a fraction of bounding box width\n// if `refX` is < 0 then `refX`'s absolute values is the right coordinate of the bounding box\n// otherwise, `refX` is the left coordinate of the bounding box\nexport const refX = {\n    position: positionWrapper('x', 'width', 'origin'),\n};\nexport const refY = {\n    position: positionWrapper('y', 'height', 'origin'),\n};\n// `ref-dx` and `ref-dy` define the offset of the subelement relative to the right and/or bottom\n// coordinate of the reference element.\nexport const refDx = {\n    position: positionWrapper('x', 'width', 'corner'),\n};\nexport const refDy = {\n    position: positionWrapper('y', 'height', 'corner'),\n};\n// 'ref-width'/'ref-height' defines the width/height of the subelement relatively to\n// the reference element size\n// val in 0..1         ref-width = 0.75 sets the width to 75% of the ref. el. width\n// val < 0 || val > 1  ref-height = -20 sets the height to the ref. el. height shorter by 20\nexport const refWidth = {\n    set: setWrapper('width', 'width'),\n};\nexport const refHeight = {\n    set: setWrapper('height', 'height'),\n};\nexport const refRx = {\n    set: setWrapper('rx', 'width'),\n};\nexport const refRy = {\n    set: setWrapper('ry', 'height'),\n};\nexport const refRInscribed = {\n    set: ((attrName) => {\n        const widthFn = setWrapper(attrName, 'width');\n        const heightFn = setWrapper(attrName, 'height');\n        return function (value, options) {\n            const refBBox = options.refBBox;\n            const fn = refBBox.height > refBBox.width ? widthFn : heightFn;\n            return FunctionExt.call(fn, this, value, options);\n        };\n    })('r'),\n};\nexport const refRCircumscribed = {\n    set(val, { refBBox }) {\n        let value = parseFloat(val);\n        const percentage = NumberExt.isPercentage(val);\n        if (percentage) {\n            value /= 100;\n        }\n        const diagonalLength = Math.sqrt(refBBox.height * refBBox.height + refBBox.width * refBBox.width);\n        let rValue;\n        if (Number.isFinite(value)) {\n            if (percentage || (value >= 0 && value <= 1)) {\n                rValue = value * diagonalLength;\n            }\n            else {\n                rValue = Math.max(value + diagonalLength, 0);\n            }\n        }\n        return { r: rValue };\n    },\n};\nexport const refCx = {\n    set: setWrapper('cx', 'width'),\n};\nexport const refCy = {\n    set: setWrapper('cy', 'height'),\n};\nexport const refDResetOffset = {\n    set: dWrapper({ resetOffset: true }),\n};\nexport const refDKeepOffset = {\n    set: dWrapper({ resetOffset: false }),\n};\nexport const refPointsResetOffset = {\n    set: pointsWrapper({ resetOffset: true }),\n};\nexport const refPointsKeepOffset = {\n    set: pointsWrapper({ resetOffset: false }),\n};\n// aliases\n// -------\nexport const refR = refRInscribed;\nexport const refD = refDResetOffset;\nexport const refPoints = refPointsResetOffset;\n// Allows to combine both absolute and relative positioning\n// refX: 50%, refX2: 20\nexport const refX2 = refX;\nexport const refY2 = refY;\nexport const refWidth2 = refWidth;\nexport const refHeight2 = refHeight;\n// utils\n// -----\nfunction positionWrapper(axis, dimension, origin) {\n    return (val, { refBBox }) => {\n        if (val == null) {\n            return null;\n        }\n        let value = parseFloat(val);\n        const percentage = NumberExt.isPercentage(val);\n        if (percentage) {\n            value /= 100;\n        }\n        let delta;\n        if (Number.isFinite(value)) {\n            const refOrigin = refBBox[origin];\n            if (percentage || (value > 0 && value < 1)) {\n                delta = refOrigin[axis] + refBBox[dimension] * value;\n            }\n            else {\n                delta = refOrigin[axis] + value;\n            }\n        }\n        const point = new Point();\n        point[axis] = delta || 0;\n        return point;\n    };\n}\nfunction setWrapper(attrName, dimension) {\n    return function (val, { refBBox }) {\n        let value = parseFloat(val);\n        const percentage = NumberExt.isPercentage(val);\n        if (percentage) {\n            value /= 100;\n        }\n        const attrs = {};\n        if (Number.isFinite(value)) {\n            const attrValue = percentage || (value >= 0 && value <= 1)\n                ? value * refBBox[dimension]\n                : Math.max(value + refBBox[dimension], 0);\n            attrs[attrName] = attrValue;\n        }\n        return attrs;\n    };\n}\nfunction shapeWrapper(shapeConstructor, options) {\n    const cacheName = 'x6-shape';\n    const resetOffset = options && options.resetOffset;\n    return function (value, { view, elem, refBBox }) {\n        const $elem = view.$(elem);\n        let cache = $elem.data(cacheName);\n        if (!cache || cache.value !== value) {\n            // only recalculate if value has changed\n            const cachedShape = shapeConstructor(value);\n            cache = {\n                value,\n                shape: cachedShape,\n                shapeBBox: cachedShape.bbox(),\n            };\n            $elem.data(cacheName, cache);\n        }\n        const shape = cache.shape.clone();\n        const shapeBBox = cache.shapeBBox.clone();\n        const shapeOrigin = shapeBBox.getOrigin();\n        const refOrigin = refBBox.getOrigin();\n        shapeBBox.x = refOrigin.x;\n        shapeBBox.y = refOrigin.y;\n        const fitScale = refBBox.getMaxScaleToFit(shapeBBox, refOrigin);\n        // `maxRectScaleToFit` can give Infinity if width or height is 0\n        const sx = shapeBBox.width === 0 || refBBox.width === 0 ? 1 : fitScale.sx;\n        const sy = shapeBBox.height === 0 || refBBox.height === 0 ? 1 : fitScale.sy;\n        shape.scale(sx, sy, shapeOrigin);\n        if (resetOffset) {\n            shape.translate(-shapeOrigin.x, -shapeOrigin.y);\n        }\n        return shape;\n    };\n}\n// `d` attribute for SVGPaths\nfunction dWrapper(options) {\n    function pathConstructor(value) {\n        return Path.parse(value);\n    }\n    const shape = shapeWrapper(pathConstructor, options);\n    return (value, args) => {\n        const path = shape(value, args);\n        return {\n            d: path.serialize(),\n        };\n    };\n}\n// `points` attribute for SVGPolylines and SVGPolygons\nfunction pointsWrapper(options) {\n    const shape = shapeWrapper((points) => new Polyline(points), options);\n    return (value, args) => {\n        const polyline = shape(value, args);\n        return {\n            points: polyline.serialize(),\n        };\n    };\n}\n//# sourceMappingURL=ref.js.map"]},"metadata":{},"sourceType":"module"}