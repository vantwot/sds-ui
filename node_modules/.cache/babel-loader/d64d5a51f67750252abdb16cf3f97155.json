{"ast":null,"code":"import { __assign, __extends, __spreadArray } from \"tslib\";\nimport EventEmitter from '@antv/event-emitter';\nimport { ext } from '@antv/matrix-util';\nimport { clone, deepMix, each, isPlainObject, isString } from '@antv/util';\nimport { getDegree, getAdjMatrix as getAdjacentMatrix, Stack, floydWarshall } from '@antv/algorithm';\nimport { lerp, move } from '../util/math';\nimport { dataValidation, singleDataValidation } from '../util/validation';\nimport Global from '../global';\nimport { ItemController, ModeController, StateController, ViewController } from './controller';\nimport { plainCombosToTrees, traverseTree, reconstructTree, traverseTreeUp } from '../util/graphic';\nimport Hull from '../item/hull';\nvar transform = ext.transform;\nvar NODE = 'node';\n\nvar AbstractGraph =\n/** @class */\nfunction (_super) {\n  __extends(AbstractGraph, _super);\n\n  function AbstractGraph(cfg) {\n    var _this = _super.call(this) || this;\n\n    _this.cfg = deepMix(_this.getDefaultCfg(), cfg);\n\n    _this.init();\n\n    _this.animating = false;\n    _this.destroyed = false; // 启用 stack 后，实例化 undoStack 和 redoStack\n\n    if (_this.cfg.enabledStack) {\n      // 实例化 undo 和 redo 栈\n      _this.undoStack = new Stack(_this.cfg.maxStep);\n      _this.redoStack = new Stack(_this.cfg.maxStep);\n    }\n\n    return _this;\n  }\n\n  AbstractGraph.prototype.init = function () {\n    this.initCanvas(); // instance controller\n\n    var viewController = new ViewController(this);\n    var modeController = new ModeController(this);\n    var itemController = new ItemController(this);\n    var stateController = new StateController(this);\n    this.set({\n      viewController: viewController,\n      modeController: modeController,\n      itemController: itemController,\n      stateController: stateController\n    }); // 初始化布局机制\n\n    this.initLayoutController(); // 初始化事件机制\n\n    this.initEventController();\n    this.initGroups();\n    /** 初始化插件 */\n\n    this.initPlugins();\n  }; // 初始化所有 Group\n\n\n  AbstractGraph.prototype.initGroups = function () {\n    var canvas = this.get('canvas');\n    if (!canvas) return;\n    var el = canvas.get('el');\n    var _a = (el || {}).id,\n        id = _a === void 0 ? 'g6' : _a;\n    var group = canvas.addGroup({\n      id: id + \"-root\",\n      className: Global.rootContainerClassName\n    });\n\n    if (this.get('groupByTypes')) {\n      var edgeGroup = group.addGroup({\n        id: id + \"-edge\",\n        className: Global.edgeContainerClassName\n      });\n      var nodeGroup = group.addGroup({\n        id: id + \"-node\",\n        className: Global.nodeContainerClassName\n      });\n      var comboGroup = group.addGroup({\n        id: id + \"-combo\",\n        className: Global.comboContainerClassName\n      }); // 用于存储自定义的群组\n\n      comboGroup.toBack();\n      this.set({\n        nodeGroup: nodeGroup,\n        edgeGroup: edgeGroup,\n        comboGroup: comboGroup\n      });\n    }\n\n    var delegateGroup = group.addGroup({\n      id: id + \"-delegate\",\n      className: Global.delegateContainerClassName\n    });\n    this.set({\n      delegateGroup: delegateGroup\n    });\n    this.set('group', group);\n  }; // eslint-disable-next-line class-methods-use-this\n\n\n  AbstractGraph.prototype.getDefaultCfg = function () {\n    return {\n      /**\n       * Container could be dom object or dom id\n       */\n      container: undefined,\n\n      /**\n       * Canvas width\n       * unit pixel if undefined force fit width\n       */\n      width: undefined,\n\n      /**\n       * Canvas height\n       * unit pixel if undefined force fit height\n       */\n      height: undefined,\n\n      /**\n       * renderer canvas or svg\n       * @type {string}\n       */\n      renderer: 'canvas',\n\n      /**\n       * control graph behaviors\n       */\n      modes: {},\n\n      /**\n       * 注册插件\n       */\n      plugins: [],\n\n      /**\n       * source data\n       */\n      data: {},\n\n      /**\n       * Fit view padding (client scale)\n       */\n      fitViewPadding: 10,\n\n      /**\n       * Minimum scale size\n       */\n      minZoom: 0.2,\n\n      /**\n       * Maxmum scale size\n       */\n      maxZoom: 10,\n\n      /**\n       *  capture events\n       */\n      event: true,\n\n      /**\n       * group node & edges into different graphic groups\n       */\n      groupByTypes: true,\n\n      /**\n       * determine if it's a directed graph\n       */\n      directed: false,\n\n      /**\n       * when data or shape changed, should canvas draw automatically\n       */\n      autoPaint: true,\n\n      /**\n       * store all the node instances\n       */\n      nodes: [],\n\n      /**\n       * store all the edge instances\n       */\n      edges: [],\n\n      /**\n       * store all the combo instances\n       */\n      combos: [],\n\n      /**\n       * store all the edge instances which are virtual edges related to collapsed combo\n       */\n      vedges: [],\n\n      /**\n       * all the instances indexed by id\n       */\n      itemMap: {},\n\n      /**\n       * 边直接连接到节点的中心，不再考虑锚点\n       */\n      linkCenter: false,\n\n      /**\n       * 默认的节点配置，data 上定义的配置会覆盖这些配置。例如：\n       * defaultNode: {\n       *  type: 'rect',\n       *  size: [60, 40],\n       *  style: {\n       *    //... 样式配置项\n       *  }\n       * }\n       * 若数据项为 { id: 'node', x: 100, y: 100 }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'rect', size: [60, 40] }\n       * 若数据项为 { id: 'node', x: 100, y: 100, type: 'circle' }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'circle', size: [60, 40] }\n       */\n      defaultNode: {},\n\n      /**\n       * 默认边配置，data 上定义的配置会覆盖这些配置。用法同 defaultNode\n       */\n      defaultEdge: {},\n\n      /**\n       * 节点默认样式，也可以添加状态样式\n       * 例如：\n       * const graph = new G6.Graph({\n       *  nodeStateStyles: {\n       *    selected: { fill: '#ccc', stroke: '#666' },\n       *    active: { lineWidth: 2 }\n       *  },\n       *  ...\n       * });\n       *\n       */\n      nodeStateStyles: {},\n\n      /**\n       * 边默认样式，用法同nodeStateStyle\n       */\n      edgeStateStyles: {},\n\n      /**\n       * graph 状态\n       */\n      states: {},\n\n      /**\n       * 是否启用全局动画\n       */\n      animate: false,\n\n      /**\n       * 动画设置,仅在 animate 为 true 时有效\n       */\n      animateCfg: {\n        /**\n         * 帧回调函数，用于自定义节点运动路径，为空时线性运动\n         */\n        onFrame: undefined,\n\n        /**\n         * 动画时长(ms)\n         */\n        duration: 500,\n\n        /**\n         * 指定动画动效\n         */\n        easing: 'easeLinear'\n      },\n      callback: undefined,\n      // 默认不启用 undo & redo 功能\n      enabledStack: false,\n      // 只有当 enabledStack 为 true 时才起作用\n      maxStep: 10,\n      // 存储图上的 tooltip dom，方便销毁\n      tooltips: []\n    };\n  };\n  /**\n   * 将值设置到 this.cfg 变量上面\n   * @param key 键 或 对象值\n   * @param val 值\n   */\n\n\n  AbstractGraph.prototype.set = function (key, val) {\n    if (isPlainObject(key)) {\n      this.cfg = __assign(__assign({}, this.cfg), key);\n    } else {\n      this.cfg[key] = val;\n    }\n\n    return this;\n  };\n  /**\n   * 获取 this.cfg 中的值\n   * @param key 键\n   */\n\n\n  AbstractGraph.prototype.get = function (key) {\n    var _a;\n\n    return (_a = this.cfg) === null || _a === void 0 ? void 0 : _a[key];\n  };\n  /**\n   * 获取 graph 的根图形分组\n   * @return 根 group\n   */\n\n\n  AbstractGraph.prototype.getGroup = function () {\n    return this.get('group');\n  };\n  /**\n   * 获取 graph 的 DOM 容器\n   * @return DOM 容器\n   */\n\n\n  AbstractGraph.prototype.getContainer = function () {\n    return this.get('container');\n  };\n  /**\n   * 获取 graph 的最小缩放比例\n   * @return minZoom\n   */\n\n\n  AbstractGraph.prototype.getMinZoom = function () {\n    return this.get('minZoom');\n  };\n  /**\n   * 设置 graph 的最小缩放比例\n   * @return minZoom\n   */\n\n\n  AbstractGraph.prototype.setMinZoom = function (ratio) {\n    return this.set('minZoom', ratio);\n  };\n  /**\n   * 获取 graph 的最大缩放比例\n   * @param maxZoom\n   */\n\n\n  AbstractGraph.prototype.getMaxZoom = function () {\n    return this.get('maxZoom');\n  };\n  /**\n   * 设置 graph 的最大缩放比例\n   * @param maxZoom\n   */\n\n\n  AbstractGraph.prototype.setMaxZoom = function (ratio) {\n    return this.set('maxZoom', ratio);\n  };\n  /**\n   * 获取 graph 的宽度\n   * @return width\n   */\n\n\n  AbstractGraph.prototype.getWidth = function () {\n    return this.get('width');\n  };\n  /**\n   * 获取 graph 的高度\n   * @return width\n   */\n\n\n  AbstractGraph.prototype.getHeight = function () {\n    return this.get('height');\n  };\n  /**\n   * 清理元素多个状态\n   * @param {string|Item} item 元素id或元素实例\n   * @param {string[]} states 状态\n   */\n\n\n  AbstractGraph.prototype.clearItemStates = function (item, states) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n\n    var itemController = this.get('itemController');\n\n    if (!states) {\n      states = item.get('states');\n    }\n\n    itemController.clearItemStates(item, states);\n    var stateController = this.get('stateController');\n    stateController.updateStates(item, states, false);\n  };\n  /**\n   * 设置各个节点样式，以及在各种状态下节点 keyShape 的样式。\n   * 若是自定义节点切在各种状态下\n   * graph.node(node => {\n   *  return {\n   *    type: 'rect',\n   *    label: node.id,\n   *    style: { fill: '#666' },\n   *    stateStyles: {\n   *       selected: { fill: 'blue' },\n   *       custom: { fill: 'green' }\n   *     }\n   *   }\n   * });\n   * @param {function} nodeFn 指定每个节点样式\n   */\n\n\n  AbstractGraph.prototype.node = function (nodeFn) {\n    if (typeof nodeFn === 'function') {\n      this.set('nodeMapper', nodeFn);\n    }\n  };\n  /**\n   * 设置各个边样式\n   * @param {function} edgeFn 指定每个边的样式,用法同 node\n   */\n\n\n  AbstractGraph.prototype.edge = function (edgeFn) {\n    if (typeof edgeFn === 'function') {\n      this.set('edgeMapper', edgeFn);\n    }\n  };\n  /**\n   * 设置各个 combo 的配置\n   * @param comboFn\n   */\n\n\n  AbstractGraph.prototype.combo = function (comboFn) {\n    if (typeof comboFn === 'function') {\n      this.set('comboMapper', comboFn);\n    }\n  };\n  /**\n   * 根据 ID 查询图元素实例\n   * @param id 图元素 ID\n   */\n\n\n  AbstractGraph.prototype.findById = function (id) {\n    return this.get('itemMap')[id];\n  };\n  /**\n   * 根据对应规则查找单个元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge | group)\n   * @param {(item: T, index: number) => T} fn 指定规则\n   * @return {T} 元素实例\n   */\n\n\n  AbstractGraph.prototype.find = function (type, fn) {\n    var result;\n    var items = this.get(type + \"s\"); // eslint-disable-next-line consistent-return\n\n    each(items, function (item, i) {\n      if (fn(item, i)) {\n        result = item;\n        return result;\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有满足规则的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} fn 指定规则\n   * @return {array} 元素实例\n   */\n\n\n  AbstractGraph.prototype.findAll = function (type, fn) {\n    var result = [];\n    each(this.get(type + \"s\"), function (item, i) {\n      if (fn(item, i)) {\n        result.push(item);\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有处于指定状态的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} state 状态\n   * @return {object} 元素实例\n   */\n\n\n  AbstractGraph.prototype.findAllByState = function (type, state) {\n    return this.findAll(type, function (item) {\n      return item.hasState(state);\n    });\n  };\n  /**\n   * 平移画布\n   * @param dx 水平方向位移\n   * @param dy 垂直方向位移\n   */\n\n\n  AbstractGraph.prototype.translate = function (dx, dy) {\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix());\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    matrix = transform(matrix, [['t', dx, dy]]);\n    group.setMatrix(matrix);\n    this.emit('viewportchange', {\n      action: 'translate',\n      matrix: group.getMatrix()\n    });\n    this.autoPaint();\n  };\n  /**\n   * 平移画布到某点\n   * @param {number} x 水平坐标\n   * @param {number} y 垂直坐标\n   */\n\n\n  AbstractGraph.prototype.moveTo = function (x, y, animate, animateCfg) {\n    var group = this.get('group');\n    move(group, {\n      x: x,\n      y: y\n    }, animate, animateCfg || {\n      duration: 500,\n      easing: 'easeCubic'\n    });\n    this.emit('viewportchange', {\n      action: 'move',\n      matrix: group.getMatrix()\n    });\n  };\n  /**\n   * 调整视口适应视图\n   * @param {object} padding 四周围边距\n   * @param {FitViewRules} rules fitView的规则\n   */\n\n\n  AbstractGraph.prototype.fitView = function (padding, rules) {\n    if (padding) {\n      this.set('fitViewPadding', padding);\n    }\n\n    var viewController = this.get('viewController');\n\n    if (rules) {\n      viewController.fitViewByRules(rules);\n    } else {\n      viewController.fitView();\n    }\n\n    this.autoPaint();\n  };\n  /**\n   * 调整视口适应视图，不缩放，仅将图 bbox 中心对齐到画布中心\n   */\n\n\n  AbstractGraph.prototype.fitCenter = function () {\n    var viewController = this.get('viewController');\n    viewController.fitCenter();\n    this.autoPaint();\n  };\n  /**\n   * 新增行为\n   * @param {string | ModeOption | ModeType[]} behaviors 添加的行为\n   * @param {string | string[]} modes 添加到对应的模式\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.addBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, true);\n    return this;\n  };\n  /**\n   * 移除行为\n   * @param {string | ModeOption | ModeType[]} behaviors 移除的行为\n   * @param {string | string[]} modes 从指定的模式中移除\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.removeBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, false);\n    return this;\n  };\n  /**\n   * 更新行为参数\n   * @param {string | ModeOption | ModeType} behavior 需要更新的行为\n   * @param {string | string[]} modes 指定的模式中的行为，不指定则为 default\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.updateBehavior = function (behavior, newCfg, mode) {\n    var modeController = this.get('modeController');\n    modeController.updateBehavior(behavior, newCfg, mode);\n    return this;\n  };\n  /**\n   * 伸缩窗口\n   * @param ratio 伸缩比例\n   * @param center 以center的x, y坐标为中心缩放\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   * @return {boolean} 缩放是否成功\n   */\n\n\n  AbstractGraph.prototype.zoom = function (ratio, center, animate, animateCfg) {\n    var _this = this;\n\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix());\n    var minZoom = this.get('minZoom');\n    var maxZoom = this.get('maxZoom');\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    if (center) {\n      matrix = transform(matrix, [['t', -center.x, -center.y], ['s', ratio, ratio], ['t', center.x, center.y]]);\n    } else {\n      matrix = transform(matrix, [['s', ratio, ratio]]);\n    }\n\n    if (minZoom && matrix[0] < minZoom || maxZoom && matrix[0] > maxZoom) {\n      return false;\n    } // matrix = [2, 0, 0, 0, 2, 0, -125, -125, 1];\n\n\n    if (animate) {\n      // Clone the original matrix to perform the animation\n      var aniMatrix_1 = clone(group.getMatrix());\n\n      if (!aniMatrix_1) {\n        aniMatrix_1 = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      }\n\n      var initialRatio_1 = aniMatrix_1[0];\n      var targetRatio_1 = initialRatio_1 * ratio;\n      var animateConfig = void 0;\n\n      if (!animateCfg) {\n        animateConfig = {\n          duration: 500,\n          callback: function callback() {\n            _this.emit('viewportchange', {\n              action: 'zoom',\n              matrix: aniMatrix_1\n            });\n          }\n        };\n      } else if (animateCfg.callback) {\n        // This is to prevent modifying the original animateCfg.callback\n        var callback_1 = animateCfg.callback;\n        animateConfig = clone(animateCfg);\n\n        animateConfig.callback = function () {\n          _this.emit('viewportchange', {\n            action: 'zoom',\n            matrix: aniMatrix_1\n          });\n\n          callback_1();\n        };\n      } else {\n        animateConfig = animateCfg;\n      }\n\n      group.animate(function (ratio) {\n        if (ratio === 1) {\n          // Reuse the first transformation\n          aniMatrix_1 = matrix;\n        } else {\n          var scale = lerp(initialRatio_1, targetRatio_1, ratio) / aniMatrix_1[0];\n\n          if (center) {\n            aniMatrix_1 = transform(aniMatrix_1, [['t', -center.x, -center.y], ['s', scale, scale], ['t', center.x, center.y]]);\n          } else {\n            aniMatrix_1 = transform(aniMatrix_1, [['s', scale, scale]]);\n          }\n        }\n\n        return {\n          matrix: aniMatrix_1\n        };\n      }, animateConfig);\n    } else {\n      group.setMatrix(matrix);\n      this.emit('viewportchange', {\n        action: 'zoom',\n        matrix: matrix\n      });\n      this.autoPaint();\n    }\n\n    return true;\n  };\n  /**\n   * 伸缩视口到一固定比例\n   * @param {number} toRatio 伸缩比例\n   * @param {Point} center 以center的x, y坐标为中心缩放\n   * @return {boolean} 缩放是否成功\n   */\n\n\n  AbstractGraph.prototype.zoomTo = function (toRatio, center) {\n    var ratio = toRatio / this.getZoom();\n    return this.zoom(ratio, center);\n  };\n  /**\n   * 将元素移动到视口中心\n   * @param {Item} item 指定元素\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.focusItem = function (item, animate, animateCfg) {\n    var viewController = this.get('viewController');\n    var isAnimate = false;\n    if (animate) isAnimate = true;else if (animate === undefined) isAnimate = this.get('animate');\n    var curAniamteCfg = {};\n    if (animateCfg) curAniamteCfg = animateCfg;else if (animateCfg === undefined) curAniamteCfg = this.get('animateCfg');\n    viewController.focus(item, isAnimate, curAniamteCfg);\n    this.autoPaint();\n  };\n  /**\n   * 自动重绘\n   * @internal 仅供内部更新机制调用，外部根据需求调用 render 或 paint 接口\n   */\n\n\n  AbstractGraph.prototype.autoPaint = function () {\n    if (this.get('autoPaint')) {\n      this.paint();\n    }\n  };\n  /**\n   * 仅画布重新绘制\n   */\n\n\n  AbstractGraph.prototype.paint = function () {\n    this.emit('beforepaint');\n    this.get('canvas').draw();\n    this.emit('afterpaint');\n  };\n  /**\n   * 将屏幕坐标转换为视口坐标\n   * @param {number} clientX 屏幕x坐标\n   * @param {number} clientY 屏幕y坐标\n   * @return {Point} 视口坐标\n   */\n\n\n  AbstractGraph.prototype.getPointByClient = function (clientX, clientY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByClient(clientX, clientY);\n  };\n  /**\n   * 将绘制坐标转换为屏幕坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {Point} 绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getClientByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getClientByPoint(x, y);\n  };\n  /**\n   * 将画布坐标转换为绘制坐标\n   * @param {number} canvasX 画布 x 坐标\n   * @param {number} canvasY 画布 y 坐标\n   * @return {object} 绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getPointByCanvas = function (canvasX, canvasY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByCanvas(canvasX, canvasY);\n  };\n  /**\n   * 将绘制坐标转换为画布坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {object} 画布坐标\n   */\n\n\n  AbstractGraph.prototype.getCanvasByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getCanvasByPoint(x, y);\n  };\n  /**\n   * 获取图内容的中心绘制坐标\n   * @return {object} 中心绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getGraphCenterPoint = function () {\n    var bbox = this.get('group').getCanvasBBox();\n    return {\n      x: (bbox.minX + bbox.maxX) / 2,\n      y: (bbox.minY + bbox.maxY) / 2\n    };\n  };\n  /**\n   * 获取视口中心绘制坐标\n   * @return {object} 视口中心绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getViewPortCenterPoint = function () {\n    return this.getPointByCanvas(this.get('width') / 2, this.get('height') / 2);\n  };\n  /**\n   * 显示元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.showItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, true);\n\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.nodes = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.edges = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.combos = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 隐藏元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.hideItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, false);\n\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.nodes = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.edges = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.combos = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 刷新元素\n   * @param {string|object} item 元素id或元素实例\n   */\n\n\n  AbstractGraph.prototype.refreshItem = function (item) {\n    var itemController = this.get('itemController');\n    itemController.refreshItem(item);\n  };\n  /**\n   * 设置是否在更新/刷新后自动重绘\n   * @param {boolean} auto 自动重绘\n   */\n\n\n  AbstractGraph.prototype.setAutoPaint = function (auto) {\n    var self = this;\n    self.set('autoPaint', auto);\n    var canvas = self.get('canvas');\n    canvas.set('autoDraw', auto);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.remove = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    this.removeItem(item, stack);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.removeItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var nodeItem = item;\n    if (isString(item)) nodeItem = this.findById(item);\n\n    if (!nodeItem && isString(item)) {\n      console.warn('The item to be removed does not exist!');\n    } else if (nodeItem) {\n      var type = '';\n      if (nodeItem.getType) type = nodeItem.getType(); // 将删除的元素入栈\n\n      if (stack && this.get('enabledStack')) {\n        var deletedModel = __assign(__assign({}, nodeItem.getModel()), {\n          itemType: type\n        });\n\n        var before = {};\n\n        switch (type) {\n          case 'node':\n            {\n              before.nodes = [deletedModel];\n              before.edges = [];\n              var edges = nodeItem.getEdges();\n\n              for (var i = edges.length - 1; i >= 0; i--) {\n                before.edges.push(__assign(__assign({}, edges[i].getModel()), {\n                  itemType: 'edge'\n                }));\n              }\n\n              break;\n            }\n\n          case 'edge':\n            before.edges = [deletedModel];\n            break;\n\n          case 'combo':\n            before.combos = [deletedModel];\n            break;\n\n          default:\n            break;\n        }\n\n        this.pushStack('delete', {\n          before: before,\n          after: {}\n        });\n      }\n\n      if (type === 'node') {\n        var model = nodeItem.getModel(); // 如果删除的是节点，且该节点存在于某个 Combo 中，则需要先将 node 从 combo 中移除，否则删除节点后，操作 combo 会出错\n\n        if (model.comboId) {\n          this.updateComboTree(nodeItem, undefined, false);\n        }\n      }\n\n      var itemController = this.get('itemController');\n      itemController.removeItem(nodeItem);\n\n      if (type === 'combo') {\n        var newComboTrees = reconstructTree(this.get('comboTrees'));\n        this.set('comboTrees', newComboTrees);\n      }\n    }\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n\n\n  AbstractGraph.prototype.addItem = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController'); // 添加节点、边或combo之前，先验证数据是否符合规范\n\n    if (!singleDataValidation(type, model)) {\n      return false;\n    }\n\n    if (model.id && this.findById(model.id)) {\n      console.warn(\"This item exists already. Be sure the id %c\" + model.id + \"%c is unique.\", 'font-size: 20px; color: red;', '');\n      return;\n    }\n\n    var item;\n    var comboTrees = this.get('comboTrees');\n    if (!comboTrees) comboTrees = [];\n\n    if (type === 'combo') {\n      var itemMap_1 = this.get('itemMap');\n      var foundParent_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundParent_1) return; // terminate the forEach after the tree containing the item is done\n\n        traverseTreeUp(ctree, function (child) {\n          // find the parent\n          if (model.parentId === child.id) {\n            foundParent_1 = true;\n\n            var newCombo = __assign({\n              id: model.id,\n              depth: child.depth + 2\n            }, model);\n\n            if (child.children) child.children.push(newCombo);else child.children = [newCombo];\n            model.depth = newCombo.depth;\n            item = itemController.addItem(type, model);\n          }\n\n          var childItem = itemMap_1[child.id]; // after the parent is found, update all the ancestors\n\n          if (foundParent_1 && childItem && childItem.getType && childItem.getType() === 'combo') {\n            itemController.updateCombo(childItem, child.children);\n          }\n\n          return true;\n        });\n      }); // if the parent is not found, add it to the root\n\n      if (!foundParent_1) {\n        var newCombo = __assign({\n          id: model.id,\n          depth: 0\n        }, model);\n\n        model.depth = newCombo.depth;\n        comboTrees.push(newCombo);\n        item = itemController.addItem(type, model);\n      }\n\n      this.set('comboTrees', comboTrees);\n    } else if (type === 'node' && isString(model.comboId) && comboTrees) {\n      var parentCombo = this.findById(model.comboId);\n\n      if (parentCombo && parentCombo.getType && parentCombo.getType() !== 'combo') {\n        console.warn(\"'\" + model.comboId + \"' is not a id of a combo in the graph, the node will be added without combo.\");\n      }\n\n      item = itemController.addItem(type, model);\n      var itemMap_2 = this.get('itemMap');\n      var foundParent_2 = false,\n          foundNode_1 = false;\n      (comboTrees || []).forEach(function (ctree) {\n        if (foundNode_1 || foundParent_2) return; // terminate the forEach\n\n        traverseTreeUp(ctree, function (child) {\n          if (child.id === model.id) {\n            // if the item exists in the tree already, terminate\n            foundNode_1 = true;\n            return false;\n          }\n\n          if (model.comboId === child.id && !foundNode_1) {\n            // found the parent, add the item to the children of its parent in the tree\n            foundParent_2 = true;\n            var cloneNode = clone(model);\n            cloneNode.itemType = 'node';\n            if (child.children) child.children.push(cloneNode);else child.children = [cloneNode];\n            cloneNode.depth = child.depth + 1;\n          } // update the size of all the ancestors\n\n\n          if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === 'combo') {\n            itemController.updateCombo(itemMap_2[child.id], child.children);\n          }\n\n          return true;\n        });\n      });\n    } else {\n      item = itemController.addItem(type, model);\n    }\n\n    if (type === 'node' && model.comboId || type === 'combo' && model.parentId) {\n      // add the combo to the parent's children array\n      var parentCombo = this.findById(model.comboId || model.parentId);\n      if (parentCombo && parentCombo.getType && parentCombo.getType() === 'combo') parentCombo.addChild(item);\n    }\n\n    var combos = this.get('combos');\n\n    if (combos && combos.length > 0) {\n      this.sortCombos();\n    }\n\n    this.autoPaint();\n\n    if (stack && this.get('enabledStack')) {\n      var addedModel = __assign(__assign({}, item.getModel()), {\n        itemType: type\n      });\n\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          after.nodes = [addedModel];\n          break;\n\n        case 'edge':\n          after.edges = [addedModel];\n          break;\n\n        case 'combo':\n          after.combos = [addedModel];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('add', {\n        before: {},\n        after: after\n      });\n    }\n\n    return item;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @return {Item} 元素实例\n   */\n\n\n  AbstractGraph.prototype.add = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    return this.addItem(type, model, stack, sortCombo);\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   */\n\n\n  AbstractGraph.prototype.updateItem = function (item, cfg, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var currentItem;\n\n    if (isString(item)) {\n      currentItem = this.findById(item);\n    } else {\n      currentItem = item;\n    }\n\n    var UnupdateModel = clone(currentItem.getModel());\n    var type = '';\n    if (currentItem.getType) type = currentItem.getType();\n\n    var states = __spreadArray([], currentItem.getStates(), true);\n\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, false);\n      });\n    }\n\n    itemController.updateItem(currentItem, cfg);\n\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, true);\n      });\n    }\n\n    if (stack && this.get('enabledStack')) {\n      var before = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n\n      var afterModel = __assign({\n        id: UnupdateModel.id\n      }, cfg);\n\n      switch (type) {\n        case 'node':\n          before.nodes.push(UnupdateModel);\n          after.nodes.push(afterModel);\n          break;\n\n        case 'edge':\n          before.edges.push(UnupdateModel);\n          after.edges.push(afterModel);\n          break;\n\n        case 'combo':\n          before.combos.push(UnupdateModel);\n          after.combos.push(afterModel);\n          break;\n\n        default:\n          break;\n      }\n\n      if (type === 'node') {\n        before.nodes.push(UnupdateModel);\n      }\n\n      this.pushStack('update', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.update = function (item, cfg, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    this.updateItem(item, cfg, stack);\n  };\n  /**\n   * 设置元素状态\n   * @param {Item} item 元素id或元素实例\n   * @param {string} state 状态名称\n   * @param {string | boolean} value 是否启用状态 或 状态值\n   */\n\n\n  AbstractGraph.prototype.setItemState = function (item, state, value) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n\n    var itemController = this.get('itemController');\n    itemController.setItemState(item, state, value);\n    var stateController = this.get('stateController');\n\n    if (isString(value)) {\n      stateController.updateState(item, state + \":\" + value, true);\n    } else {\n      stateController.updateState(item, state, value);\n    }\n  };\n  /**\n   * 将指定状态的优先级提升为最高优先级\n   * @param {Item} item 元素id或元素实例\n   * @param state 状态名称\n   */\n\n\n  AbstractGraph.prototype.priorityState = function (item, state) {\n    var itemController = this.get('itemController');\n    itemController.priorityState(item, state);\n  };\n  /**\n   * 设置视图初始化数据\n   * @param {GraphData} data 初始化数据\n   */\n\n\n  AbstractGraph.prototype.data = function (data) {\n    dataValidation(data);\n    this.set('data', data);\n  };\n  /**\n   * 根据data接口的数据渲染视图\n   */\n\n\n  AbstractGraph.prototype.render = function () {\n    var self = this;\n    this.set('comboSorted', false);\n    var data = this.get('data');\n\n    if (this.get('enabledStack')) {\n      // render 之前清空 redo 和 undo 栈\n      this.clearStack();\n    }\n\n    if (!data) {\n      throw new Error('data must be defined first');\n    }\n\n    var _a = data.nodes,\n        nodes = _a === void 0 ? [] : _a,\n        _b = data.edges,\n        edges = _b === void 0 ? [] : _b,\n        _c = data.combos,\n        combos = _c === void 0 ? [] : _c;\n    this.clear(true);\n    this.emit('beforerender');\n    each(nodes, function (node) {\n      self.add('node', node, false, false);\n    }); // process the data to tree structure\n\n    if (combos && combos.length !== 0) {\n      var comboTrees = plainCombosToTrees(combos, nodes);\n      this.set('comboTrees', comboTrees); // add combos\n\n      self.addCombos(combos);\n    }\n\n    each(edges, function (edge) {\n      self.add('edge', edge, false, false);\n    });\n    var animate = self.get('animate');\n\n    if (self.get('fitView') || self.get('fitCenter')) {\n      self.set('animate', false);\n    } // layout\n\n\n    var layoutController = self.get('layoutController');\n\n    if (layoutController) {\n      layoutController.layout(success);\n      if (this.destroyed) return;\n    } else {\n      if (self.get('fitView')) {\n        self.fitView();\n      }\n\n      if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n\n      self.emit('afterrender');\n      self.set('animate', animate);\n    } // 将在 onLayoutEnd 中被调用\n\n\n    function success() {\n      // fitView 与 fitCenter 共存时，fitView 优先，fitCenter 不再执行\n      if (self.get('fitView')) {\n        self.fitView();\n      } else if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n\n      self.autoPaint();\n      self.emit('afterrender');\n\n      if (self.get('fitView') || self.get('fitCenter')) {\n        self.set('animate', animate);\n      }\n    }\n\n    if (!this.get('groupByTypes')) {\n      if (combos && combos.length !== 0) {\n        this.sortCombos();\n      } else {\n        // 为提升性能，选择数量少的进行操作\n        if (data.nodes && data.edges && data.nodes.length < data.edges.length) {\n          var nodesArr = this.getNodes(); // 遍历节点实例，将所有节点提前。\n\n          nodesArr.forEach(function (node) {\n            node.toFront();\n          });\n        } else {\n          var edgesArr = this.getEdges(); // 遍历节点实例，将所有节点提前。\n\n          edgesArr.forEach(function (edge) {\n            edge.toBack();\n          });\n        }\n      }\n    }\n\n    if (this.get('enabledStack')) {\n      this.pushStack('render');\n    }\n  };\n  /**\n   * 接收数据进行渲染\n   * @Param {Object} data 初始化数据\n   */\n\n\n  AbstractGraph.prototype.read = function (data) {\n    this.data(data);\n    this.render();\n  }; // 比较item\n\n\n  AbstractGraph.prototype.diffItems = function (type, items, models) {\n    var self = this;\n    var item;\n    var itemMap = this.get('itemMap');\n    each(models, function (model) {\n      item = itemMap[model.id];\n\n      if (item) {\n        if (self.get('animate') && type === NODE) {\n          var containerMatrix = item.getContainer().getMatrix();\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          item.set('originAttrs', {\n            x: containerMatrix[6],\n            y: containerMatrix[7]\n          });\n        }\n\n        self.updateItem(item, model, false);\n      } else {\n        item = self.addItem(type, model, false);\n      }\n\n      if (item) items[type + \"s\"].push(item);\n    });\n  };\n  /**\n   * 更改源数据，根据新数据重新渲染视图\n   * @param {GraphData | TreeGraphData} data 源数据\n   * @param {boolean} 是否入栈，默认为true\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.changeData = function (data, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var self = this;\n\n    if (!dataValidation(data)) {\n      return this;\n    }\n\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('changedata', {\n        before: self.save(),\n        after: data\n      });\n    }\n\n    this.set('comboSorted', false); // 删除 hulls\n\n    this.removeHulls(); // 更改数据源后，取消所有状态\n\n    this.getNodes().map(function (node) {\n      return self.clearItemStates(node);\n    });\n    this.getEdges().map(function (edge) {\n      return self.clearItemStates(edge);\n    });\n    var canvas = this.get('canvas');\n    var localRefresh = canvas.get('localRefresh');\n    canvas.set('localRefresh', false);\n\n    if (!self.get('data')) {\n      self.data(data);\n      self.render();\n    }\n\n    var itemMap = this.get('itemMap');\n    var items = {\n      nodes: [],\n      edges: []\n    };\n    var combosData = data.combos;\n\n    if (combosData) {\n      var comboTrees = plainCombosToTrees(combosData, data.nodes);\n      this.set('comboTrees', comboTrees);\n    } else {\n      this.set('comboTrees', []);\n    }\n\n    this.diffItems('node', items, data.nodes);\n    each(itemMap, function (item, id) {\n      itemMap[id].getModel().depth = 0;\n      if (item.getType && item.getType() === 'edge') return;\n\n      if (item.getType && item.getType() === 'combo') {\n        delete itemMap[id];\n        item.destroy();\n      } else if (items.nodes.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    }); // clear the destroyed combos here to avoid removing sub nodes before removing the parent combo\n\n    var comboItems = this.getCombos();\n    var combosLength = comboItems.length;\n\n    for (var i = combosLength - 1; i >= 0; i--) {\n      if (comboItems[i].destroyed) {\n        comboItems.splice(i, 1);\n      }\n    } // process the data to tree structure\n\n\n    if (combosData) {\n      // add combos\n      self.addCombos(combosData);\n\n      if (!this.get('groupByTypes')) {\n        this.sortCombos();\n      }\n    }\n\n    this.diffItems('edge', items, data.edges);\n    each(itemMap, function (item, id) {\n      if (item.getType && (item.getType() === 'node' || item.getType() === 'combo')) return;\n\n      if (items.edges.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    });\n    this.set({\n      nodes: items.nodes,\n      edges: items.edges\n    });\n    var layoutController = this.get('layoutController');\n\n    if (layoutController) {\n      layoutController.changeData();\n\n      if (self.get('animate') && !layoutController.getLayoutType()) {\n        // 如果没有指定布局\n        self.positionsAnimate();\n      } else {\n        self.autoPaint();\n      }\n    }\n\n    setTimeout(function () {\n      canvas.set('localRefresh', localRefresh);\n    }, 16);\n    return this;\n  };\n  /**\n   * 私有方法，在 render 和 changeData 的时候批量添加数据中所有平铺的 combos\n   * @param {ComboConfig[]} combos 平铺的 combos 数据\n   */\n\n\n  AbstractGraph.prototype.addCombos = function (combos) {\n    var self = this;\n    var comboTrees = self.get('comboTrees');\n    var itemController = this.get('itemController');\n    itemController.addCombos(comboTrees, combos);\n  };\n  /**\n   * 根据已经存在的节点或 combo 创建新的 combo\n   * @param combo combo ID 或 Combo 配置\n   * @param children 添加到 Combo 中的元素，包括节点和 combo\n   */\n\n\n  AbstractGraph.prototype.createCombo = function (combo, children) {\n    var _this = this;\n\n    this.set('comboSorted', false); // step 1: 创建新的 Combo\n\n    var comboId = '';\n    var comboConfig;\n    if (!combo) return;\n\n    if (isString(combo)) {\n      comboId = combo;\n      comboConfig = {\n        id: combo\n      };\n    } else {\n      comboId = combo.id;\n\n      if (!comboId) {\n        console.warn('Create combo failed. Please assign a unique string id for the adding combo.');\n        return;\n      }\n\n      comboConfig = combo;\n    } // step2: 更新 children，根据类型添加 comboId 或 parentId\n\n\n    var trees = children.map(function (elementId) {\n      var item = _this.findById(elementId);\n\n      var model = item.getModel();\n      var type = '';\n      if (item.getType) type = item.getType();\n      var cItem = {\n        id: item.getID(),\n        itemType: type\n      };\n\n      if (type === 'combo') {\n        cItem.parentId = comboId;\n        model.parentId = comboId;\n      } else if (type === 'node') {\n        cItem.comboId = comboId;\n        model.comboId = comboId;\n      }\n\n      return cItem;\n    });\n    comboConfig.children = trees; // step 3: 添加 Combo，addItem 时会将子将元素添加到 Combo 中\n\n    this.addItem('combo', comboConfig, false);\n    this.set('comboSorted', false); // step4: 更新 comboTrees 结构\n\n    var comboTrees = this.get('comboTrees');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (child.id === comboId) {\n          child.itemType = 'combo';\n          child.children = trees;\n          return false;\n        }\n\n        return true;\n      });\n    });\n\n    if (comboTrees) {\n      this.sortCombos();\n    }\n  };\n  /**\n   * 解散 combo\n   * @param {String | INode | ICombo} combo 需要被解散的 Combo item 或 id\n   */\n\n\n  AbstractGraph.prototype.uncombo = function (combo) {\n    var _this = this;\n\n    var _a;\n\n    var self = this;\n    var comboItem = combo;\n\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item is not a combo!');\n      return;\n    }\n\n    var parentId = comboItem.getModel().parentId;\n    var comboTrees = self.get('comboTrees');\n    if (!comboTrees) comboTrees = [];\n    var itemMap = this.get('itemMap');\n    var comboId = comboItem.get('id');\n    var treeToBeUncombo;\n    var brothers = [];\n    var comboItems = this.get('combos');\n    var parentItem = this.findById(parentId);\n    comboTrees.forEach(function (ctree) {\n      if (treeToBeUncombo) return; // terminate the forEach\n\n      traverseTreeUp(ctree, function (subtree) {\n        var _a; // find the combo to be uncomboed, delete the combo from map and cache\n\n\n        if (subtree.id === comboId) {\n          treeToBeUncombo = subtree; // delete the related edges\n\n          var edges = comboItem.getEdges();\n          edges.forEach(function (edge) {\n            _this.removeItem(edge, false);\n          });\n          var index = comboItems.indexOf(comboItem);\n          comboItems.splice(index, 1);\n          delete itemMap[comboId];\n          comboItem.destroy();\n\n          _this.emit('afterremoveitem', {\n            item: comboItem,\n            type: 'combo'\n          });\n        } // find the parent to remove the combo from the combo's brothers array and add the combo's children to the combo's brothers array in the tree\n\n\n        if (parentId && treeToBeUncombo && subtree.id === parentId) {\n          parentItem.removeCombo(comboItem);\n          brothers = subtree.children; // the combo's brothers\n          // remove the combo from its brothers array\n\n          var index = brothers.indexOf(treeToBeUncombo);\n\n          if (index !== -1) {\n            brothers.splice(index, 1);\n          } // append the combo's children to the combo's brothers array\n\n\n          (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            var item = _this.findById(child.id);\n\n            var childModel = item.getModel();\n\n            if (item.getType && item.getType() === 'combo') {\n              child.parentId = parentId;\n              delete child.comboId;\n              childModel.parentId = parentId; // update the parentId of the model\n\n              delete childModel.comboId;\n            } else if (item.getType && item.getType() === 'node') {\n              child.comboId = parentId;\n              childModel.comboId = parentId; // update the parentId of the model\n            }\n\n            parentItem.addChild(item);\n            brothers.push(child);\n          });\n          return false;\n        }\n\n        return true;\n      });\n    }); // if the parentId is not found, remove the combo from the roots\n\n    if (!parentId && treeToBeUncombo) {\n      var index = comboTrees.indexOf(treeToBeUncombo);\n      comboTrees.splice(index, 1); // modify the parentId of the children\n\n      (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n        child.parentId = undefined;\n\n        var childModel = _this.findById(child.id).getModel();\n\n        delete childModel.parentId; // update the parentId of the model\n\n        delete childModel.comboId; // update the comboId of the model\n\n        if (child.itemType !== 'node') comboTrees.push(child);\n      });\n    }\n  };\n  /**\n   * 根据节点的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围\n   */\n\n\n  AbstractGraph.prototype.updateCombos = function () {\n    var _this = this;\n\n    var self = this;\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (!child) {\n          return true;\n        }\n\n        var childItem = itemMap[child.id];\n\n        if (childItem && childItem.getType && childItem.getType() === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true);\n\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, false);\n          }); // 更新具体的 Combo\n\n          itemController.updateCombo(childItem, child.children); // 更新 Combo 后，还原已有的状态\n\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, true);\n          });\n        }\n\n        return true;\n      });\n    });\n    self.sortCombos();\n  };\n  /**\n   * 根据节点的 bbox 更新 combo 及其祖先 combos 的绘制，包括 combos 的位置和范围\n   * @param {String | ICombo} combo 需要被更新的 Combo 或 id，若指定，则该 Combo 及所有祖先 Combod 都会被更新\n   */\n\n\n  AbstractGraph.prototype.updateCombo = function (combo) {\n    var _this = this;\n\n    var self = this;\n    var comboItem = combo;\n    var comboId;\n\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item to be updated is not a combo!');\n      return;\n    }\n\n    comboId = comboItem.get('id');\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (!child) {\n          return true;\n        }\n\n        var childItem = itemMap[child.id];\n\n        if (comboId === child.id && childItem && childItem.getType && childItem.getType() === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true); // || !item.getStateStyle(stateName)\n\n\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, false);\n            }\n          }); // 更新具体的 Combo\n\n          itemController.updateCombo(childItem, child.children); // 更新 Combo 后，还原已有的状态\n\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, true);\n            }\n          });\n          if (comboId) comboId = child.parentId;\n        }\n\n        return true;\n      });\n    });\n  };\n  /**\n   * 更新树结构，例如移动子树等\n   * @param {String | INode | ICombo} item 需要被更新的 Combo 或 节点 id\n   * @param {string | undefined} parentId 新的父 combo id，undefined 代表没有父 combo\n   */\n\n\n  AbstractGraph.prototype.updateComboTree = function (item, parentId, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var self = this;\n    this.set('comboSorted', false);\n    var uItem;\n\n    if (isString(item)) {\n      uItem = self.findById(item);\n    } else {\n      uItem = item;\n    }\n\n    var model = uItem.getModel();\n    var oldParentId = model.comboId || model.parentId;\n    var type = '';\n    if (uItem.getType) type = uItem.getType(); // 若 item 是 Combo，且 parentId 是其子孙 combo 的 id，则警告并终止\n\n    if (parentId && type === 'combo') {\n      var comboTrees = this.get('comboTrees');\n      var valid_1 = true;\n      var itemSubTree_1;\n      (comboTrees || []).forEach(function (ctree) {\n        if (itemSubTree_1) return;\n        traverseTree(ctree, function (subTree) {\n          if (itemSubTree_1) return; // 找到从 item 开始的子树\n\n          if (subTree.id === uItem.getID()) {\n            itemSubTree_1 = subTree;\n          }\n\n          return true;\n        });\n      }); // 在以 item 为根的子树中寻找与 parentId 相同的后继元素\n\n      traverseTree(itemSubTree_1, function (subTree) {\n        if (subTree.id === parentId) {\n          valid_1 = false;\n          return false;\n        }\n\n        return true;\n      }); // parentId 是 item 的一个后继元素，不能进行更新\n\n      if (!valid_1) {\n        console.warn('Failed to update the combo tree! The parentId points to a descendant of the combo!');\n        return;\n      }\n    }\n\n    if (stack && this.get('enabledStack')) {\n      var beforeData = {},\n          afterData = {};\n\n      if (type === 'combo') {\n        beforeData.combos = [{\n          id: model.id,\n          parentId: model.parentId\n        }];\n        afterData.combos = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      } else if (type === 'node') {\n        beforeData.nodes = [{\n          id: model.id,\n          parentId: model.comboId\n        }];\n        afterData.nodes = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      }\n\n      this.pushStack('updateComboTree', {\n        before: beforeData,\n        after: afterData\n      });\n    } // 当 combo 存在 parentId 或 comboId 时，才将其移除\n\n\n    if (model.parentId || model.comboId) {\n      var combo = this.findById(model.parentId || model.comboId);\n\n      if (combo) {\n        combo.removeChild(uItem);\n      }\n    }\n\n    if (type === 'combo') {\n      model.parentId = parentId;\n    } else if (type === 'node') {\n      model.comboId = parentId;\n    } // 只有当移入到指定 combo 时才添加\n\n\n    if (parentId) {\n      var parentCombo = this.findById(parentId);\n\n      if (parentCombo) {\n        // 将元素添加到 parentCombo 中\n        parentCombo.addChild(uItem);\n      }\n    } // 如果原先有父亲 combo，则从原父 combo 的子元素数组中删除\n\n\n    if (oldParentId) {\n      var parentCombo = this.findById(oldParentId);\n\n      if (parentCombo) {\n        // 将元素从 parentCombo 中移除\n        parentCombo.removeChild(uItem);\n      }\n    }\n\n    var newComboTrees = reconstructTree(this.get('comboTrees'), model.id, parentId);\n    this.set('comboTrees', newComboTrees);\n    this.updateCombos();\n  };\n  /**\n   * 导出图数据\n   * @return {object} data\n   */\n\n\n  AbstractGraph.prototype.save = function () {\n    var nodes = [];\n    var edges = [];\n    var combos = [];\n    each(this.get('nodes'), function (node) {\n      nodes.push(node.getModel());\n    });\n    each(this.get('edges'), function (edge) {\n      edges.push(edge.getModel());\n    });\n    each(this.get('combos'), function (combo) {\n      combos.push(combo.getModel());\n    });\n    return {\n      nodes: nodes,\n      edges: edges,\n      combos: combos\n    };\n  };\n  /**\n   * 改变画布大小\n   * @param  {number} width  画布宽度\n   * @param  {number} height 画布高度\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.changeSize = function (width, height) {\n    var viewController = this.get('viewController');\n    viewController.changeSize(width, height);\n    return this;\n  };\n  /**\n   * 当源数据在外部发生变更时，根据新数据刷新视图。但是不刷新节点位置\n   */\n\n\n  AbstractGraph.prototype.refresh = function () {\n    var self = this;\n    self.emit('beforegraphrefresh');\n\n    if (self.get('animate')) {\n      self.positionsAnimate();\n    } else {\n      var nodes = self.get('nodes');\n      var edges = self.get('edges');\n      var vedges = self.get('edges');\n      each(nodes, function (node) {\n        node.refresh();\n      });\n      each(edges, function (edge) {\n        edge.refresh();\n      });\n      each(vedges, function (vedge) {\n        vedge.refresh();\n      });\n    }\n\n    self.emit('aftergraphrefresh');\n    self.autoPaint();\n  };\n  /**\n   * 获取当前图中所有节点的item实例\n   * @return {INode} item数组\n   */\n\n\n  AbstractGraph.prototype.getNodes = function () {\n    return this.get('nodes');\n  };\n  /**\n   * 获取当前图中所有边的item实例\n   * @return {IEdge} item数组\n   */\n\n\n  AbstractGraph.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取图中所有的 combo 实例\n   */\n\n\n  AbstractGraph.prototype.getCombos = function () {\n    return this.get('combos');\n  };\n  /**\n   * 获取指定 Combo 中所有的节点\n   * @param comboId combo ID\n   */\n\n\n  AbstractGraph.prototype.getComboChildren = function (combo) {\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo does not exist!');\n      return;\n    }\n\n    return combo.getChildren();\n  };\n  /**\n   * 根据 graph 上的 animateCfg 进行视图中节点位置动画接口\n   */\n\n\n  AbstractGraph.prototype.positionsAnimate = function () {\n    var self = this;\n    self.emit('beforeanimate');\n    var animateCfg = self.get('animateCfg');\n    var onFrame = animateCfg.onFrame;\n    var nodes = self.getNodes();\n    var toNodes = nodes.map(function (node) {\n      var model = node.getModel();\n      return {\n        id: model.id,\n        x: model.x,\n        y: model.y\n      };\n    });\n\n    if (self.isAnimating()) {\n      self.stopAnimate();\n    }\n\n    var canvas = self.get('canvas');\n    canvas.animate(function (ratio) {\n      each(toNodes, function (data) {\n        var node = self.findById(data.id);\n\n        if (!node || node.destroyed) {\n          return;\n        }\n\n        var originAttrs = node.get('originAttrs');\n        var model = node.get('model');\n\n        if (!originAttrs) {\n          var containerMatrix = node.getContainer().getMatrix();\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          originAttrs = {\n            x: containerMatrix[6],\n            y: containerMatrix[7]\n          };\n          node.set('originAttrs', originAttrs);\n        }\n\n        if (onFrame) {\n          var attrs = onFrame(node, ratio, data, originAttrs);\n          node.set('model', Object.assign(model, attrs));\n        } else {\n          model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;\n          model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;\n        }\n      });\n      self.refreshPositions();\n    }, {\n      duration: animateCfg.duration,\n      easing: animateCfg.easing,\n      callback: function callback() {\n        each(nodes, function (node) {\n          node.set('originAttrs', null);\n        });\n\n        if (animateCfg.callback) {\n          animateCfg.callback();\n        }\n\n        self.emit('afteranimate');\n        self.animating = false;\n      }\n    });\n  };\n  /**\n   * 当节点位置在外部发生改变时，刷新所有节点位置，重计算边\n   */\n\n\n  AbstractGraph.prototype.refreshPositions = function () {\n    var self = this;\n    self.emit('beforegraphrefreshposition');\n    var nodes = self.get('nodes');\n    var edges = self.get('edges');\n    var vedges = self.get('vedges');\n    var combos = self.get('combos');\n    var model;\n    var updatedNodes = {};\n    each(nodes, function (node) {\n      model = node.getModel();\n      var originAttrs = node.get('originAttrs');\n\n      if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {\n        return;\n      }\n\n      var changed = node.updatePosition({\n        x: model.x,\n        y: model.y\n      });\n      updatedNodes[model.id] = changed;\n      if (model.comboId) updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;\n    });\n\n    if (combos && combos.length !== 0) {\n      self.updateCombos();\n    }\n\n    each(edges, function (edge) {\n      var sourceModel = edge.getSource().getModel();\n      var target = edge.getTarget(); // 避免 target 是纯对象的情况下调用 getModel 方法\n      // 拖动生成边的时候 target 会是纯对象\n\n      if (!isPlainObject(target)) {\n        var targetModel = target.getModel();\n\n        if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {\n          edge.refresh();\n        }\n      }\n    });\n    each(vedges, function (vedge) {\n      vedge.refresh();\n    });\n    self.emit('aftergraphrefreshposition');\n    self.autoPaint();\n  };\n\n  AbstractGraph.prototype.stopAnimate = function () {\n    this.get('canvas').stopAnimate();\n  };\n\n  AbstractGraph.prototype.isAnimating = function () {\n    return this.animating;\n  };\n  /**\n   * 获取当前视口伸缩比例\n   * @return {number} 比例\n   */\n\n\n  AbstractGraph.prototype.getZoom = function () {\n    var matrix = this.get('group').getMatrix();\n    return matrix ? matrix[0] : 1;\n  };\n  /**\n   * 获取当前的行为模式\n   * @return {string} 当前行为模式\n   */\n\n\n  AbstractGraph.prototype.getCurrentMode = function () {\n    var modeController = this.get('modeController');\n    return modeController.getMode();\n  };\n  /**\n   * 切换行为模式\n   * @param {string} mode 指定模式\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.setMode = function (mode) {\n    var modeController = this.get('modeController');\n    modeController.setMode(mode);\n    return this;\n  };\n  /**\n   * 清除画布元素\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.clear = function (avoidEmit) {\n    var _a;\n\n    if (avoidEmit === void 0) {\n      avoidEmit = false;\n    }\n\n    (_a = this.get('canvas')) === null || _a === void 0 ? void 0 : _a.clear();\n    this.initGroups(); // 清空画布时同时清除数据\n\n    this.set({\n      itemMap: {},\n      nodes: [],\n      edges: [],\n      groups: [],\n      combos: [],\n      comboTrees: []\n    });\n    if (!avoidEmit) this.emit('afterrender');\n    return this;\n  };\n  /**\n   * 更换布局配置项\n   * @param {object} cfg 新布局配置项\n   * @param {'center' | 'begin'} align 对齐方式，可选中心（center）对齐到对齐点，或左上角（begin）对齐到对齐点\n   * @param {IPoint} alignPoint 画布上的对齐点，为 Canvas 坐标系（Canvas DOM）\n   * 若 cfg 含有 type 字段或为 String 类型，且与现有布局方法不同，则更换布局\n   * 若 cfg 不包括 type ，则保持原有布局方法，仅更新布局配置项\n   */\n\n\n  AbstractGraph.prototype.updateLayout = function (cfg, align, alignPoint) {\n    var _this = this;\n\n    var layoutController = this.get('layoutController');\n\n    if (isString(cfg)) {\n      cfg = {\n        type: cfg\n      };\n    } // align the graph after layout\n\n\n    if (align) {\n      var toPoint_1 = alignPoint;\n\n      if (!toPoint_1) {\n        if (align === 'begin') toPoint_1 = {\n          x: 0,\n          y: 0\n        };else toPoint_1 = {\n          x: this.getWidth() / 2,\n          y: this.getHeight() / 2\n        };\n      } // translate to point coordinate system\n\n\n      toPoint_1 = this.getPointByCanvas(toPoint_1.x, toPoint_1.y);\n      var forceTypes = ['force', 'gForce', 'fruchterman']; // if it is force layout, only center takes effect, and assign center force\n\n      if (forceTypes.includes(cfg.type) || !cfg.type && forceTypes.includes(layoutController === null || layoutController === void 0 ? void 0 : layoutController.layoutType)) {\n        cfg.center = [toPoint_1.x, toPoint_1.y];\n      } else {\n        this.once('afterlayout', function (e) {\n          var matrix = _this.getGroup().getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          toPoint_1.x = toPoint_1.x * matrix[0] + matrix[6];\n          toPoint_1.y = toPoint_1.y * matrix[0] + matrix[7];\n\n          var _a = _this.getGroup().getCanvasBBox(),\n              minX = _a.minX,\n              maxX = _a.maxX,\n              minY = _a.minY,\n              maxY = _a.maxY;\n\n          var bboxPoint = {\n            x: (minX + maxX) / 2,\n            y: (minY + maxY) / 2\n          };\n\n          if (align === 'begin') {\n            bboxPoint.x = minX;\n            bboxPoint.y = minY;\n          }\n\n          _this.translate(toPoint_1.x - bboxPoint.x, toPoint_1.y - bboxPoint.y);\n        });\n      }\n    }\n\n    var oriLayoutCfg = this.get('layout');\n    var layoutCfg = {};\n    Object.assign(layoutCfg, oriLayoutCfg, cfg);\n    this.set('layout', layoutCfg);\n\n    if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {\n      // no type or same type, or switch the gpu and cpu, update layout\n      layoutController.updateLayoutCfg(layoutCfg);\n    } else {\n      // has different type, change layout\n      layoutController.changeLayout(layoutCfg);\n    }\n  };\n  /**\n   * 销毁布局，changeData 时不会再使用原来的布局方法对新数据进行布局\n   */\n\n\n  AbstractGraph.prototype.destroyLayout = function () {\n    var layoutController = this.get('layoutController');\n    layoutController.destroyLayout();\n  };\n  /**\n   * 重新以当前示例中配置的属性进行一次布局\n   */\n\n\n  AbstractGraph.prototype.layout = function () {\n    var layoutController = this.get('layoutController');\n    var layoutCfg = this.get('layout');\n    if (!layoutCfg || !layoutController) return;\n\n    if (layoutCfg.workerEnabled) {\n      // 如果使用web worker布局\n      layoutController.layout();\n      return;\n    }\n\n    if (layoutController.layoutMethod) {\n      layoutController.relayout(true);\n    } else {\n      layoutController.layout();\n    }\n  };\n  /**\n   * 收起指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n\n\n  AbstractGraph.prototype.collapseCombo = function (combo) {\n    var _this = this;\n\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo) {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.collapseCombo(combo);\n    comboModel.collapsed = true; // add virtual edges\n\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\n\n    var cnodes = [];\n    var ccombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate the forEach\n\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false; // if the combo is found\n\n        if (comboModel.id === subTree.id) found = true;\n\n        if (found) {\n          // if the combo is found, concat the descendant nodes and combos\n          var item = _this.findById(subTree.id);\n\n          if (item && item.getType && item.getType() === 'combo') {\n            cnodes = cnodes.concat(item.getNodes());\n            ccombos = ccombos.concat(item.getCombos());\n          }\n        }\n\n        return true;\n      });\n    });\n    var edgeWeightMap = {};\n    var addedVEdges = [];\n    edges.forEach(function (edge) {\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if ((cnodes.includes(source) || ccombos.includes(source)) && !cnodes.includes(target) && !ccombos.includes(target) || source.getModel().id === comboModel.id) {\n        var edgeModel = edge.getModel();\n\n        if (edgeModel.isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var targetModel = target.getModel();\n\n        while (!target.isVisible()) {\n          target = _this.findById(targetModel.parentId || targetModel.comboId);\n          if (!target || !targetModel.parentId && !targetModel.comboId) return; // all the ancestors are hidden, then ignore the edge\n\n          targetModel = target.getModel();\n        }\n\n        var targetId = targetModel.id;\n\n        if (edgeWeightMap[comboModel.id + \"-\" + targetId]) {\n          edgeWeightMap[comboModel.id + \"-\" + targetId] += edgeModel.size || 1;\n          return;\n        } // the source is in the combo, the target is not\n\n\n        var vedge = _this.addItem('vedge', {\n          source: comboModel.id,\n          target: targetId,\n          isVEdge: true\n        }, false);\n\n        edgeWeightMap[comboModel.id + \"-\" + targetId] = edgeModel.size || 1;\n        addedVEdges.push(vedge);\n      } else if (!cnodes.includes(source) && !ccombos.includes(source) && (cnodes.includes(target) || ccombos.includes(target)) || target.getModel().id === comboModel.id) {\n        var edgeModel = edge.getModel();\n\n        if (edgeModel.isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var sourceModel = source.getModel();\n\n        while (!source.isVisible()) {\n          source = _this.findById(sourceModel.parentId || sourceModel.comboId);\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) return; // all the ancestors are hidden, then ignore the edge\n\n          sourceModel = source.getModel();\n        }\n\n        var sourceId = sourceModel.id;\n\n        if (edgeWeightMap[sourceId + \"-\" + comboModel.id]) {\n          edgeWeightMap[sourceId + \"-\" + comboModel.id] += edgeModel.size || 1;\n          return;\n        } // the target is in the combo, the source is not\n\n\n        var vedge = _this.addItem('vedge', {\n          target: comboModel.id,\n          source: sourceId,\n          isVEdge: true\n        }, false);\n\n        edgeWeightMap[sourceId + \"-\" + comboModel.id] = edgeModel.size || 1;\n        addedVEdges.push(vedge);\n      }\n    }); // update the width of the virtual edges, which is the sum of merged actual edges\n    // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n    addedVEdges.forEach(function (vedge) {\n      var vedgeModel = vedge.getModel();\n\n      _this.updateItem(vedge, {\n        size: edgeWeightMap[vedgeModel.source + \"-\" + vedgeModel.target]\n      }, false);\n    });\n    this.emit('aftercollapseexpandcombo', {\n      action: 'collapse',\n      item: combo\n    });\n  };\n  /**\n   * 展开指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n\n\n  AbstractGraph.prototype.expandCombo = function (combo) {\n    var _this = this;\n\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.expandCombo(combo);\n    comboModel.collapsed = false; // add virtual edges\n\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\n\n    var cnodes = [];\n    var ccombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate\n\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false;\n        if (comboModel.id === subTree.id) found = true;\n\n        if (found) {\n          var item = _this.findById(subTree.id);\n\n          if (item && item.getType && item.getType() === 'combo') {\n            cnodes = cnodes.concat(item.getNodes());\n            ccombos = ccombos.concat(item.getCombos());\n          }\n        }\n\n        return true;\n      });\n    });\n    var edgeWeightMap = {};\n    var addedVEdges = {};\n    edges.forEach(function (edge) {\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var sourceId = source.get('id');\n      var targetId = target.get('id');\n\n      if ((cnodes.includes(source) || ccombos.includes(source)) && !cnodes.includes(target) && !ccombos.includes(target) || sourceId === comboModel.id) {\n        // the source is in the combo, the target is not\n        // ignore the virtual edges\n        if (edge.getModel().isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var targetModel = target.getModel(); // find the nearest visible ancestor\n\n        while (!target.isVisible()) {\n          target = _this.findById(targetModel.comboId || targetModel.parentId);\n\n          if (!target || !targetModel.parentId && !targetModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          targetModel = target.getModel();\n        }\n\n        targetId = targetModel.id;\n        var sourceModel = source.getModel(); // find the nearest visible ancestor\n\n        while (!source.isVisible()) {\n          source = _this.findById(sourceModel.comboId || sourceModel.parentId);\n\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          if (sourceModel.comboId === comboModel.id || sourceModel.parentId === comboModel.id) {\n            break; // if the next ancestor is the combo, break the while\n          }\n\n          sourceModel = source.getModel();\n        }\n\n        sourceId = sourceModel.id;\n\n        if (targetId) {\n          var vedgeId = sourceId + \"-\" + targetId; // update the width of the virtual edges, which is the sum of merged actual edges\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n          if (edgeWeightMap[vedgeId]) {\n            edgeWeightMap[vedgeId] += edge.getModel().size || 1;\n\n            _this.updateItem(addedVEdges[vedgeId], {\n              size: edgeWeightMap[vedgeId]\n            }, false);\n\n            return;\n          }\n\n          var vedge = _this.addItem('vedge', {\n            source: sourceId,\n            target: targetId,\n            isVEdge: true\n          }, false);\n\n          edgeWeightMap[vedgeId] = edge.getModel().size || 1;\n          addedVEdges[vedgeId] = vedge;\n        }\n      } else if (!cnodes.includes(source) && !ccombos.includes(source) && (cnodes.includes(target) || ccombos.includes(target)) || targetId === comboModel.id) {\n        // the target is in the combo, the source is not\n        // ignore the virtual edges\n        if (edge.getModel().isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var sourceModel = source.getModel(); // find the nearest visible ancestor\n\n        while (!source.isVisible()) {\n          source = _this.findById(sourceModel.comboId || sourceModel.parentId);\n\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          sourceModel = source.getModel();\n        }\n\n        sourceId = sourceModel.id;\n        var targetModel = target.getModel(); // find the nearest visible ancestor\n\n        while (!target.isVisible()) {\n          target = _this.findById(targetModel.comboId || targetModel.parentId);\n\n          if (!target || !targetModel.parentId && !targetModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          if (targetModel.comboId === comboModel.id || targetModel.parentId === comboModel.id) {\n            break; // if the next ancestor is the combo, break the while\n          }\n\n          targetModel = target.getModel();\n        }\n\n        targetId = targetModel.id;\n\n        if (sourceId) {\n          var vedgeId = sourceId + \"-\" + targetId; // update the width of the virtual edges, which is the sum of merged actual edges\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n          if (edgeWeightMap[vedgeId]) {\n            edgeWeightMap[vedgeId] += edge.getModel().size || 1;\n\n            _this.updateItem(addedVEdges[vedgeId], {\n              size: edgeWeightMap[vedgeId]\n            }, false);\n\n            return;\n          }\n\n          var vedge = _this.addItem('vedge', {\n            target: targetId,\n            source: sourceId,\n            isVEdge: true\n          }, false);\n\n          edgeWeightMap[vedgeId] = edge.getModel().size || 1;\n          addedVEdges[vedgeId] = vedge;\n        }\n      } else if ((cnodes.includes(source) || ccombos.includes(source)) && (cnodes.includes(target) || ccombos.includes(target))) {\n        // both source and target are in the combo, if the target and source are both visible, show the edge\n        if (source.isVisible() && target.isVisible()) {\n          edge.show();\n        }\n      }\n    });\n    this.emit('aftercollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n  };\n\n  AbstractGraph.prototype.collapseExpandCombo = function (combo) {\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') return;\n    var comboModel = combo.getModel(); // if one ancestor combo of the combo is collapsed, it should not be collapsed or expanded\n\n    var parentItem = this.findById(comboModel.parentId);\n\n    while (parentItem) {\n      var parentModel = parentItem.getModel();\n\n      if (parentModel.collapsed) {\n        console.warn(\"Fail to expand the combo since it's ancestor combo is collapsed.\");\n        parentItem = undefined;\n        return;\n      }\n\n      parentItem = this.findById(parentModel.parentId);\n    }\n\n    var collapsed = comboModel.collapsed; // 该群组已经处于收起状态，需要展开\n\n    if (collapsed) {\n      this.expandCombo(combo);\n    } else {\n      this.collapseCombo(combo);\n    }\n\n    this.updateCombo(combo);\n  };\n  /**\n   * 根据 comboTree 结构整理 Combo 相关的图形绘制层级，包括 Combo 本身、节点、边\n   * @param {GraphData} data 数据\n   */\n\n\n  AbstractGraph.prototype.sortCombos = function () {\n    var _this = this;\n\n    var comboSorted = this.get('comboSorted');\n    if (comboSorted) return;\n    this.set('comboSorted', true);\n    var depthMap = [];\n    var dataDepthMap = {};\n    var comboTrees = this.get('comboTrees');\n    (comboTrees || []).forEach(function (cTree) {\n      traverseTree(cTree, function (child) {\n        if (depthMap[child.depth]) depthMap[child.depth].push(child.id);else depthMap[child.depth] = [child.id];\n        dataDepthMap[child.id] = child.depth;\n        return true;\n      });\n    });\n    var edges = this.getEdges().concat(this.get('vedges'));\n    (edges || []).forEach(function (edgeItem) {\n      var edge = edgeItem.getModel();\n      var sourceDepth = dataDepthMap[edge.source] || 0;\n      var targetDepth = dataDepthMap[edge.target] || 0;\n      var depth = Math.max(sourceDepth, targetDepth);\n      if (depthMap[depth]) depthMap[depth].push(edge.id);else depthMap[depth] = [edge.id];\n    });\n    depthMap.forEach(function (array) {\n      if (!array || !array.length) return;\n\n      for (var i = array.length - 1; i >= 0; i--) {\n        var item = _this.findById(array[i]);\n\n        if (item) item.toFront();\n      }\n    });\n  };\n  /**\n   * 获取节点所有的邻居节点\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @returns {INode[]}\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getNeighbors = function (node, type) {\n    var item = node;\n\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n\n    return item.getNeighbors(type);\n  };\n  /**\n   * 获取 node 的度数\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @param {('in' | 'out' | 'total' | 'all' | undefined)} 度数类型，in 入度，out 出度，total 总度数，all 返回三种类型度数的对象\n   * @returns {Number | Object} 该节点的度数\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getNodeDegree = function (node, type, refresh) {\n    if (type === void 0) {\n      type = undefined;\n    }\n\n    if (refresh === void 0) {\n      refresh = false;\n    }\n\n    var item = node;\n\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n\n    var degrees = this.get('degrees');\n\n    if (!degrees || refresh) {\n      degrees = getDegree(this.save());\n      this.set('degrees', degrees);\n    }\n\n    var nodeDegrees = degrees[item.getID()];\n    var res = 0; // 如果是通过 addItem 后面新增加的节点，此时它的所有度数都为 0\n\n    if (!nodeDegrees) {\n      return 0;\n    }\n\n    switch (type) {\n      case 'in':\n        res = nodeDegrees.inDegree;\n        break;\n\n      case 'out':\n        res = nodeDegrees.outDegree;\n        break;\n\n      case 'all':\n        res = nodeDegrees;\n        break;\n\n      default:\n        res = nodeDegrees.degree;\n        break;\n    }\n\n    return res;\n  };\n\n  AbstractGraph.prototype.getUndoStack = function () {\n    return this.undoStack;\n  };\n\n  AbstractGraph.prototype.getRedoStack = function () {\n    return this.redoStack;\n  };\n  /**\n   * 获取 undo 和 redo 栈的数据\n   */\n\n\n  AbstractGraph.prototype.getStackData = function () {\n    if (!this.get('enabledStack')) {\n      return null;\n    }\n\n    return {\n      undoStack: this.undoStack.toArray(),\n      redoStack: this.redoStack.toArray()\n    };\n  };\n  /**\n   * 清空 undo stack & redo stack\n   */\n\n\n  AbstractGraph.prototype.clearStack = function () {\n    if (this.get('enabledStack')) {\n      this.undoStack.clear();\n      this.redoStack.clear();\n    }\n  };\n  /**\n   * 将操作类型和操作数据入栈\n   * @param action 操作类型\n   * @param data 入栈的数据\n   * @param stackType 栈的类型\n   */\n\n\n  AbstractGraph.prototype.pushStack = function (action, data, stackType) {\n    if (action === void 0) {\n      action = 'update';\n    }\n\n    if (stackType === void 0) {\n      stackType = 'undo';\n    }\n\n    if (!this.get('enabledStack')) {\n      console.warn('请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !');\n      return;\n    }\n\n    var stackData = data ? clone(data) : {\n      before: {},\n      after: clone(this.save())\n    };\n\n    if (stackType === 'redo') {\n      this.redoStack.push({\n        action: action,\n        data: stackData\n      });\n    } else {\n      this.undoStack.push({\n        action: action,\n        data: stackData\n      });\n    }\n\n    this.emit('stackchange', {\n      undoStack: this.undoStack,\n      redoStack: this.redoStack\n    });\n  };\n  /**\n   * 获取邻接矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 邻接矩阵\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getAdjMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n\n    return currentAdjMatrix;\n  };\n  /**\n   * 获取最短路径矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 最短路径矩阵\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getShortestPathMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n    var currentShourtestPathMatrix = this.get('shortestPathMatrix');\n\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n\n    if (!currentShourtestPathMatrix || !cache) {\n      currentShourtestPathMatrix = floydWarshall(this.save(), directed);\n      this.set('shortestPathMatrix', currentShourtestPathMatrix);\n    }\n\n    return currentShourtestPathMatrix;\n  };\n  /**\n   * 重新定义监听函数，复写参数类型\n   */\n\n\n  AbstractGraph.prototype.on = function (eventName, callback, once) {\n    return _super.prototype.on.call(this, eventName, callback, once);\n  };\n  /**\n   * 销毁画布\n   */\n\n\n  AbstractGraph.prototype.destroy = function () {\n    this.clear(); // 清空栈数据\n\n    this.clearStack();\n    this.get('itemController').destroy();\n    this.get('modeController').destroy();\n    this.get('viewController').destroy();\n    this.get('stateController').destroy();\n    this.get('canvas').destroy();\n    this.cfg = null;\n    this.destroyed = true;\n    this.redoStack = null;\n    this.undoStack = null;\n  };\n  /**\n   * 创建凸包或凹包轮廓\n   * @param cfg HullCfg 轮廓配置项\n   */\n\n\n  AbstractGraph.prototype.createHull = function (cfg) {\n    if (!cfg.members || cfg.members.length < 1) {\n      console.warn('Create hull failed! The members is empty.');\n      return;\n    }\n\n    var parent = this.get('hullGroup');\n    var hullMap = this.get('hullMap');\n\n    if (!hullMap) {\n      hullMap = {};\n      this.set('hullMap', hullMap);\n    }\n\n    if (!parent || parent.get('destroyed')) {\n      parent = this.get('group').addGroup({\n        id: 'hullGroup'\n      });\n      parent.toBack();\n      this.set('hullGroup', parent);\n    }\n\n    if (hullMap[cfg.id]) {\n      console.warn('Existed hull id.');\n      return hullMap[cfg.id];\n    }\n\n    var group = parent.addGroup({\n      id: cfg.id + \"-container\"\n    });\n    var hull = new Hull(this, __assign(__assign({}, cfg), {\n      group: group\n    }));\n    var hullId = hull.id;\n    hullMap[hullId] = hull;\n    return hull;\n  };\n  /**\n   * 获取当前 graph 中存在的包裹轮廓\n   * @return {[key: string]: Hull} Hull 的 map，hullId 对应的 hull 实例\n   */\n\n\n  AbstractGraph.prototype.getHulls = function () {\n    return this.get('hullMap');\n  };\n  /**\n   * 根据 hullId 获取对应的 hull\n   * @return Hull\n   */\n\n\n  AbstractGraph.prototype.getHullById = function (hullId) {\n    return this.get('hullMap')[hullId];\n  };\n\n  AbstractGraph.prototype.removeHull = function (hull) {\n    var _a;\n\n    var hullInstance;\n\n    if (isString(hull)) {\n      hullInstance = this.getHullById(hull);\n    } else {\n      hullInstance = hull;\n    }\n\n    (_a = this.get('hullMap')) === null || _a === void 0 ? true : delete _a[hullInstance.id];\n    hullInstance.destroy();\n  };\n\n  AbstractGraph.prototype.removeHulls = function () {\n    var hulls = this.getHulls();\n    if (!hulls || !Object.keys(hulls).length) return;\n    Object.keys(hulls).forEach(function (key) {\n      var hull = hulls[key];\n      hull.destroy();\n    });\n    this.set('hullMap', {});\n  };\n\n  return AbstractGraph;\n}(EventEmitter);\n\nexport default AbstractGraph;","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/@antv/g6-core/es/graph/graph.js"],"names":["__assign","__extends","__spreadArray","EventEmitter","ext","clone","deepMix","each","isPlainObject","isString","getDegree","getAdjMatrix","getAdjacentMatrix","Stack","floydWarshall","lerp","move","dataValidation","singleDataValidation","Global","ItemController","ModeController","StateController","ViewController","plainCombosToTrees","traverseTree","reconstructTree","traverseTreeUp","Hull","transform","NODE","AbstractGraph","_super","cfg","_this","call","getDefaultCfg","init","animating","destroyed","enabledStack","undoStack","maxStep","redoStack","prototype","initCanvas","viewController","modeController","itemController","stateController","set","initLayoutController","initEventController","initGroups","initPlugins","canvas","get","el","_a","id","group","addGroup","className","rootContainerClassName","edgeGroup","edgeContainerClassName","nodeGroup","nodeContainerClassName","comboGroup","comboContainerClassName","toBack","delegateGroup","delegateContainerClassName","container","undefined","width","height","renderer","modes","plugins","data","fitViewPadding","minZoom","maxZoom","event","groupByTypes","directed","autoPaint","nodes","edges","combos","vedges","itemMap","linkCenter","defaultNode","defaultEdge","nodeStateStyles","edgeStateStyles","states","animate","animateCfg","onFrame","duration","easing","callback","tooltips","key","val","getGroup","getContainer","getMinZoom","setMinZoom","ratio","getMaxZoom","setMaxZoom","getWidth","getHeight","clearItemStates","item","findById","updateStates","node","nodeFn","edge","edgeFn","combo","comboFn","find","type","fn","result","items","i","findAll","push","findAllByState","state","hasState","translate","dx","dy","matrix","getMatrix","setMatrix","emit","action","moveTo","x","y","fitView","padding","rules","fitViewByRules","fitCenter","addBehaviors","behaviors","manipulateBehaviors","removeBehaviors","updateBehavior","behavior","newCfg","mode","zoom","center","aniMatrix_1","initialRatio_1","targetRatio_1","animateConfig","callback_1","scale","zoomTo","toRatio","getZoom","focusItem","isAnimate","curAniamteCfg","focus","paint","draw","getPointByClient","clientX","clientY","getClientByPoint","getPointByCanvas","canvasX","canvasY","getCanvasByPoint","getGraphCenterPoint","bbox","getCanvasBBox","minX","maxX","minY","maxY","getViewPortCenterPoint","showItem","stack","object","changeItemVisibility","getID","getType","before","after","visible","pushStack","hideItem","refreshItem","setAutoPaint","auto","self","remove","removeItem","nodeItem","console","warn","deletedModel","getModel","itemType","getEdges","length","model","comboId","updateComboTree","newComboTrees","addItem","sortCombo","currentComboSorted","comboTrees","itemMap_1","foundParent_1","forEach","ctree","child","parentId","newCombo","depth","children","childItem","updateCombo","parentCombo","itemMap_2","foundParent_2","foundNode_1","cloneNode","addChild","sortCombos","addedModel","add","updateItem","currentItem","UnupdateModel","getStates","setItemState","afterModel","update","value","updateState","priorityState","render","clearStack","Error","_b","_c","clear","addCombos","layoutController","layout","success","nodesArr","getNodes","toFront","edgesArr","read","diffItems","models","containerMatrix","changeData","save","removeHulls","map","localRefresh","combosData","destroy","indexOf","comboItems","getCombos","combosLength","splice","getLayoutType","positionsAnimate","setTimeout","createCombo","comboConfig","trees","elementId","cItem","uncombo","comboItem","treeToBeUncombo","brothers","parentItem","subtree","index","removeCombo","childModel","updateCombos","getStateStyle","uItem","oldParentId","valid_1","itemSubTree_1","subTree","beforeData","afterData","removeChild","changeSize","refresh","vedge","getComboChildren","getChildren","toNodes","isAnimating","stopAnimate","originAttrs","attrs","Object","assign","refreshPositions","updatedNodes","changed","updatePosition","sourceModel","getSource","target","getTarget","targetModel","isComboEdge","getCurrentMode","getMode","setMode","avoidEmit","groups","updateLayout","align","alignPoint","toPoint_1","forceTypes","includes","layoutType","once","e","bboxPoint","oriLayoutCfg","layoutCfg","isLayoutTypeSame","gpuEnabled","updateLayoutCfg","changeLayout","destroyLayout","workerEnabled","layoutMethod","relayout","collapseCombo","comboModel","collapsed","concat","cnodes","ccombos","found","edgeWeightMap","addedVEdges","isVisible","isVEdge","source","edgeModel","targetId","size","sourceId","vedgeModel","expandCombo","vedgeId","show","collapseExpandCombo","parentModel","comboSorted","depthMap","dataDepthMap","cTree","edgeItem","sourceDepth","targetDepth","Math","max","array","getNeighbors","getNodeDegree","degrees","nodeDegrees","res","inDegree","outDegree","degree","getUndoStack","getRedoStack","getStackData","toArray","stackType","stackData","cache","currentAdjMatrix","getShortestPathMatrix","currentShourtestPathMatrix","on","eventName","createHull","members","parent","hullMap","hull","hullId","getHulls","getHullById","removeHull","hullInstance","hulls","keys"],"mappings":"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","sourcesContent":["import { __assign, __extends, __spreadArray } from \"tslib\";\nimport EventEmitter from '@antv/event-emitter';\nimport { ext } from '@antv/matrix-util';\nimport { clone, deepMix, each, isPlainObject, isString } from '@antv/util';\nimport { getDegree, getAdjMatrix as getAdjacentMatrix, Stack, floydWarshall } from '@antv/algorithm';\nimport { lerp, move } from '../util/math';\nimport { dataValidation, singleDataValidation } from '../util/validation';\nimport Global from '../global';\nimport { ItemController, ModeController, StateController, ViewController } from './controller';\nimport { plainCombosToTrees, traverseTree, reconstructTree, traverseTreeUp } from '../util/graphic';\nimport Hull from '../item/hull';\nvar transform = ext.transform;\nvar NODE = 'node';\n\nvar AbstractGraph =\n/** @class */\nfunction (_super) {\n  __extends(AbstractGraph, _super);\n\n  function AbstractGraph(cfg) {\n    var _this = _super.call(this) || this;\n\n    _this.cfg = deepMix(_this.getDefaultCfg(), cfg);\n\n    _this.init();\n\n    _this.animating = false;\n    _this.destroyed = false; // 启用 stack 后，实例化 undoStack 和 redoStack\n\n    if (_this.cfg.enabledStack) {\n      // 实例化 undo 和 redo 栈\n      _this.undoStack = new Stack(_this.cfg.maxStep);\n      _this.redoStack = new Stack(_this.cfg.maxStep);\n    }\n\n    return _this;\n  }\n\n  AbstractGraph.prototype.init = function () {\n    this.initCanvas(); // instance controller\n\n    var viewController = new ViewController(this);\n    var modeController = new ModeController(this);\n    var itemController = new ItemController(this);\n    var stateController = new StateController(this);\n    this.set({\n      viewController: viewController,\n      modeController: modeController,\n      itemController: itemController,\n      stateController: stateController\n    }); // 初始化布局机制\n\n    this.initLayoutController(); // 初始化事件机制\n\n    this.initEventController();\n    this.initGroups();\n    /** 初始化插件 */\n\n    this.initPlugins();\n  }; // 初始化所有 Group\n\n\n  AbstractGraph.prototype.initGroups = function () {\n    var canvas = this.get('canvas');\n    if (!canvas) return;\n    var el = canvas.get('el');\n    var _a = (el || {}).id,\n        id = _a === void 0 ? 'g6' : _a;\n    var group = canvas.addGroup({\n      id: id + \"-root\",\n      className: Global.rootContainerClassName\n    });\n\n    if (this.get('groupByTypes')) {\n      var edgeGroup = group.addGroup({\n        id: id + \"-edge\",\n        className: Global.edgeContainerClassName\n      });\n      var nodeGroup = group.addGroup({\n        id: id + \"-node\",\n        className: Global.nodeContainerClassName\n      });\n      var comboGroup = group.addGroup({\n        id: id + \"-combo\",\n        className: Global.comboContainerClassName\n      }); // 用于存储自定义的群组\n\n      comboGroup.toBack();\n      this.set({\n        nodeGroup: nodeGroup,\n        edgeGroup: edgeGroup,\n        comboGroup: comboGroup\n      });\n    }\n\n    var delegateGroup = group.addGroup({\n      id: id + \"-delegate\",\n      className: Global.delegateContainerClassName\n    });\n    this.set({\n      delegateGroup: delegateGroup\n    });\n    this.set('group', group);\n  }; // eslint-disable-next-line class-methods-use-this\n\n\n  AbstractGraph.prototype.getDefaultCfg = function () {\n    return {\n      /**\n       * Container could be dom object or dom id\n       */\n      container: undefined,\n\n      /**\n       * Canvas width\n       * unit pixel if undefined force fit width\n       */\n      width: undefined,\n\n      /**\n       * Canvas height\n       * unit pixel if undefined force fit height\n       */\n      height: undefined,\n\n      /**\n       * renderer canvas or svg\n       * @type {string}\n       */\n      renderer: 'canvas',\n\n      /**\n       * control graph behaviors\n       */\n      modes: {},\n\n      /**\n       * 注册插件\n       */\n      plugins: [],\n\n      /**\n       * source data\n       */\n      data: {},\n\n      /**\n       * Fit view padding (client scale)\n       */\n      fitViewPadding: 10,\n\n      /**\n       * Minimum scale size\n       */\n      minZoom: 0.2,\n\n      /**\n       * Maxmum scale size\n       */\n      maxZoom: 10,\n\n      /**\n       *  capture events\n       */\n      event: true,\n\n      /**\n       * group node & edges into different graphic groups\n       */\n      groupByTypes: true,\n\n      /**\n       * determine if it's a directed graph\n       */\n      directed: false,\n\n      /**\n       * when data or shape changed, should canvas draw automatically\n       */\n      autoPaint: true,\n\n      /**\n       * store all the node instances\n       */\n      nodes: [],\n\n      /**\n       * store all the edge instances\n       */\n      edges: [],\n\n      /**\n       * store all the combo instances\n       */\n      combos: [],\n\n      /**\n       * store all the edge instances which are virtual edges related to collapsed combo\n       */\n      vedges: [],\n\n      /**\n       * all the instances indexed by id\n       */\n      itemMap: {},\n\n      /**\n       * 边直接连接到节点的中心，不再考虑锚点\n       */\n      linkCenter: false,\n\n      /**\n       * 默认的节点配置，data 上定义的配置会覆盖这些配置。例如：\n       * defaultNode: {\n       *  type: 'rect',\n       *  size: [60, 40],\n       *  style: {\n       *    //... 样式配置项\n       *  }\n       * }\n       * 若数据项为 { id: 'node', x: 100, y: 100 }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'rect', size: [60, 40] }\n       * 若数据项为 { id: 'node', x: 100, y: 100, type: 'circle' }\n       * 实际创建的节点模型是 { id: 'node', x: 100, y: 100， type: 'circle', size: [60, 40] }\n       */\n      defaultNode: {},\n\n      /**\n       * 默认边配置，data 上定义的配置会覆盖这些配置。用法同 defaultNode\n       */\n      defaultEdge: {},\n\n      /**\n       * 节点默认样式，也可以添加状态样式\n       * 例如：\n       * const graph = new G6.Graph({\n       *  nodeStateStyles: {\n       *    selected: { fill: '#ccc', stroke: '#666' },\n       *    active: { lineWidth: 2 }\n       *  },\n       *  ...\n       * });\n       *\n       */\n      nodeStateStyles: {},\n\n      /**\n       * 边默认样式，用法同nodeStateStyle\n       */\n      edgeStateStyles: {},\n\n      /**\n       * graph 状态\n       */\n      states: {},\n\n      /**\n       * 是否启用全局动画\n       */\n      animate: false,\n\n      /**\n       * 动画设置,仅在 animate 为 true 时有效\n       */\n      animateCfg: {\n        /**\n         * 帧回调函数，用于自定义节点运动路径，为空时线性运动\n         */\n        onFrame: undefined,\n\n        /**\n         * 动画时长(ms)\n         */\n        duration: 500,\n\n        /**\n         * 指定动画动效\n         */\n        easing: 'easeLinear'\n      },\n      callback: undefined,\n      // 默认不启用 undo & redo 功能\n      enabledStack: false,\n      // 只有当 enabledStack 为 true 时才起作用\n      maxStep: 10,\n      // 存储图上的 tooltip dom，方便销毁\n      tooltips: []\n    };\n  };\n  /**\n   * 将值设置到 this.cfg 变量上面\n   * @param key 键 或 对象值\n   * @param val 值\n   */\n\n\n  AbstractGraph.prototype.set = function (key, val) {\n    if (isPlainObject(key)) {\n      this.cfg = __assign(__assign({}, this.cfg), key);\n    } else {\n      this.cfg[key] = val;\n    }\n\n    return this;\n  };\n  /**\n   * 获取 this.cfg 中的值\n   * @param key 键\n   */\n\n\n  AbstractGraph.prototype.get = function (key) {\n    var _a;\n\n    return (_a = this.cfg) === null || _a === void 0 ? void 0 : _a[key];\n  };\n  /**\n   * 获取 graph 的根图形分组\n   * @return 根 group\n   */\n\n\n  AbstractGraph.prototype.getGroup = function () {\n    return this.get('group');\n  };\n  /**\n   * 获取 graph 的 DOM 容器\n   * @return DOM 容器\n   */\n\n\n  AbstractGraph.prototype.getContainer = function () {\n    return this.get('container');\n  };\n  /**\n   * 获取 graph 的最小缩放比例\n   * @return minZoom\n   */\n\n\n  AbstractGraph.prototype.getMinZoom = function () {\n    return this.get('minZoom');\n  };\n  /**\n   * 设置 graph 的最小缩放比例\n   * @return minZoom\n   */\n\n\n  AbstractGraph.prototype.setMinZoom = function (ratio) {\n    return this.set('minZoom', ratio);\n  };\n  /**\n   * 获取 graph 的最大缩放比例\n   * @param maxZoom\n   */\n\n\n  AbstractGraph.prototype.getMaxZoom = function () {\n    return this.get('maxZoom');\n  };\n  /**\n   * 设置 graph 的最大缩放比例\n   * @param maxZoom\n   */\n\n\n  AbstractGraph.prototype.setMaxZoom = function (ratio) {\n    return this.set('maxZoom', ratio);\n  };\n  /**\n   * 获取 graph 的宽度\n   * @return width\n   */\n\n\n  AbstractGraph.prototype.getWidth = function () {\n    return this.get('width');\n  };\n  /**\n   * 获取 graph 的高度\n   * @return width\n   */\n\n\n  AbstractGraph.prototype.getHeight = function () {\n    return this.get('height');\n  };\n  /**\n   * 清理元素多个状态\n   * @param {string|Item} item 元素id或元素实例\n   * @param {string[]} states 状态\n   */\n\n\n  AbstractGraph.prototype.clearItemStates = function (item, states) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n\n    var itemController = this.get('itemController');\n\n    if (!states) {\n      states = item.get('states');\n    }\n\n    itemController.clearItemStates(item, states);\n    var stateController = this.get('stateController');\n    stateController.updateStates(item, states, false);\n  };\n  /**\n   * 设置各个节点样式，以及在各种状态下节点 keyShape 的样式。\n   * 若是自定义节点切在各种状态下\n   * graph.node(node => {\n   *  return {\n   *    type: 'rect',\n   *    label: node.id,\n   *    style: { fill: '#666' },\n   *    stateStyles: {\n   *       selected: { fill: 'blue' },\n   *       custom: { fill: 'green' }\n   *     }\n   *   }\n   * });\n   * @param {function} nodeFn 指定每个节点样式\n   */\n\n\n  AbstractGraph.prototype.node = function (nodeFn) {\n    if (typeof nodeFn === 'function') {\n      this.set('nodeMapper', nodeFn);\n    }\n  };\n  /**\n   * 设置各个边样式\n   * @param {function} edgeFn 指定每个边的样式,用法同 node\n   */\n\n\n  AbstractGraph.prototype.edge = function (edgeFn) {\n    if (typeof edgeFn === 'function') {\n      this.set('edgeMapper', edgeFn);\n    }\n  };\n  /**\n   * 设置各个 combo 的配置\n   * @param comboFn\n   */\n\n\n  AbstractGraph.prototype.combo = function (comboFn) {\n    if (typeof comboFn === 'function') {\n      this.set('comboMapper', comboFn);\n    }\n  };\n  /**\n   * 根据 ID 查询图元素实例\n   * @param id 图元素 ID\n   */\n\n\n  AbstractGraph.prototype.findById = function (id) {\n    return this.get('itemMap')[id];\n  };\n  /**\n   * 根据对应规则查找单个元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge | group)\n   * @param {(item: T, index: number) => T} fn 指定规则\n   * @return {T} 元素实例\n   */\n\n\n  AbstractGraph.prototype.find = function (type, fn) {\n    var result;\n    var items = this.get(type + \"s\"); // eslint-disable-next-line consistent-return\n\n    each(items, function (item, i) {\n      if (fn(item, i)) {\n        result = item;\n        return result;\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有满足规则的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} fn 指定规则\n   * @return {array} 元素实例\n   */\n\n\n  AbstractGraph.prototype.findAll = function (type, fn) {\n    var result = [];\n    each(this.get(type + \"s\"), function (item, i) {\n      if (fn(item, i)) {\n        result.push(item);\n      }\n    });\n    return result;\n  };\n  /**\n   * 查找所有处于指定状态的元素\n   * @param {string} type 元素类型(node|edge)\n   * @param {string} state 状态\n   * @return {object} 元素实例\n   */\n\n\n  AbstractGraph.prototype.findAllByState = function (type, state) {\n    return this.findAll(type, function (item) {\n      return item.hasState(state);\n    });\n  };\n  /**\n   * 平移画布\n   * @param dx 水平方向位移\n   * @param dy 垂直方向位移\n   */\n\n\n  AbstractGraph.prototype.translate = function (dx, dy) {\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix());\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    matrix = transform(matrix, [['t', dx, dy]]);\n    group.setMatrix(matrix);\n    this.emit('viewportchange', {\n      action: 'translate',\n      matrix: group.getMatrix()\n    });\n    this.autoPaint();\n  };\n  /**\n   * 平移画布到某点\n   * @param {number} x 水平坐标\n   * @param {number} y 垂直坐标\n   */\n\n\n  AbstractGraph.prototype.moveTo = function (x, y, animate, animateCfg) {\n    var group = this.get('group');\n    move(group, {\n      x: x,\n      y: y\n    }, animate, animateCfg || {\n      duration: 500,\n      easing: 'easeCubic'\n    });\n    this.emit('viewportchange', {\n      action: 'move',\n      matrix: group.getMatrix()\n    });\n  };\n  /**\n   * 调整视口适应视图\n   * @param {object} padding 四周围边距\n   * @param {FitViewRules} rules fitView的规则\n   */\n\n\n  AbstractGraph.prototype.fitView = function (padding, rules) {\n    if (padding) {\n      this.set('fitViewPadding', padding);\n    }\n\n    var viewController = this.get('viewController');\n\n    if (rules) {\n      viewController.fitViewByRules(rules);\n    } else {\n      viewController.fitView();\n    }\n\n    this.autoPaint();\n  };\n  /**\n   * 调整视口适应视图，不缩放，仅将图 bbox 中心对齐到画布中心\n   */\n\n\n  AbstractGraph.prototype.fitCenter = function () {\n    var viewController = this.get('viewController');\n    viewController.fitCenter();\n    this.autoPaint();\n  };\n  /**\n   * 新增行为\n   * @param {string | ModeOption | ModeType[]} behaviors 添加的行为\n   * @param {string | string[]} modes 添加到对应的模式\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.addBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, true);\n    return this;\n  };\n  /**\n   * 移除行为\n   * @param {string | ModeOption | ModeType[]} behaviors 移除的行为\n   * @param {string | string[]} modes 从指定的模式中移除\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.removeBehaviors = function (behaviors, modes) {\n    var modeController = this.get('modeController');\n    modeController.manipulateBehaviors(behaviors, modes, false);\n    return this;\n  };\n  /**\n   * 更新行为参数\n   * @param {string | ModeOption | ModeType} behavior 需要更新的行为\n   * @param {string | string[]} modes 指定的模式中的行为，不指定则为 default\n   * @return {Graph} Graph\n   */\n\n\n  AbstractGraph.prototype.updateBehavior = function (behavior, newCfg, mode) {\n    var modeController = this.get('modeController');\n    modeController.updateBehavior(behavior, newCfg, mode);\n    return this;\n  };\n  /**\n   * 伸缩窗口\n   * @param ratio 伸缩比例\n   * @param center 以center的x, y坐标为中心缩放\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   * @return {boolean} 缩放是否成功\n   */\n\n\n  AbstractGraph.prototype.zoom = function (ratio, center, animate, animateCfg) {\n    var _this = this;\n\n    var group = this.get('group');\n    var matrix = clone(group.getMatrix());\n    var minZoom = this.get('minZoom');\n    var maxZoom = this.get('maxZoom');\n\n    if (!matrix) {\n      matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n    }\n\n    if (center) {\n      matrix = transform(matrix, [['t', -center.x, -center.y], ['s', ratio, ratio], ['t', center.x, center.y]]);\n    } else {\n      matrix = transform(matrix, [['s', ratio, ratio]]);\n    }\n\n    if (minZoom && matrix[0] < minZoom || maxZoom && matrix[0] > maxZoom) {\n      return false;\n    } // matrix = [2, 0, 0, 0, 2, 0, -125, -125, 1];\n\n\n    if (animate) {\n      // Clone the original matrix to perform the animation\n      var aniMatrix_1 = clone(group.getMatrix());\n\n      if (!aniMatrix_1) {\n        aniMatrix_1 = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n      }\n\n      var initialRatio_1 = aniMatrix_1[0];\n      var targetRatio_1 = initialRatio_1 * ratio;\n      var animateConfig = void 0;\n\n      if (!animateCfg) {\n        animateConfig = {\n          duration: 500,\n          callback: function callback() {\n            _this.emit('viewportchange', {\n              action: 'zoom',\n              matrix: aniMatrix_1\n            });\n          }\n        };\n      } else if (animateCfg.callback) {\n        // This is to prevent modifying the original animateCfg.callback\n        var callback_1 = animateCfg.callback;\n        animateConfig = clone(animateCfg);\n\n        animateConfig.callback = function () {\n          _this.emit('viewportchange', {\n            action: 'zoom',\n            matrix: aniMatrix_1\n          });\n\n          callback_1();\n        };\n      } else {\n        animateConfig = animateCfg;\n      }\n\n      group.animate(function (ratio) {\n        if (ratio === 1) {\n          // Reuse the first transformation\n          aniMatrix_1 = matrix;\n        } else {\n          var scale = lerp(initialRatio_1, targetRatio_1, ratio) / aniMatrix_1[0];\n\n          if (center) {\n            aniMatrix_1 = transform(aniMatrix_1, [['t', -center.x, -center.y], ['s', scale, scale], ['t', center.x, center.y]]);\n          } else {\n            aniMatrix_1 = transform(aniMatrix_1, [['s', scale, scale]]);\n          }\n        }\n\n        return {\n          matrix: aniMatrix_1\n        };\n      }, animateConfig);\n    } else {\n      group.setMatrix(matrix);\n      this.emit('viewportchange', {\n        action: 'zoom',\n        matrix: matrix\n      });\n      this.autoPaint();\n    }\n\n    return true;\n  };\n  /**\n   * 伸缩视口到一固定比例\n   * @param {number} toRatio 伸缩比例\n   * @param {Point} center 以center的x, y坐标为中心缩放\n   * @return {boolean} 缩放是否成功\n   */\n\n\n  AbstractGraph.prototype.zoomTo = function (toRatio, center) {\n    var ratio = toRatio / this.getZoom();\n    return this.zoom(ratio, center);\n  };\n  /**\n   * 将元素移动到视口中心\n   * @param {Item} item 指定元素\n   * @param {boolean} animate 是否带有动画地移动\n   * @param {GraphAnimateConfig} animateCfg 若带有动画，动画的配置项\n   */\n\n\n  AbstractGraph.prototype.focusItem = function (item, animate, animateCfg) {\n    var viewController = this.get('viewController');\n    var isAnimate = false;\n    if (animate) isAnimate = true;else if (animate === undefined) isAnimate = this.get('animate');\n    var curAniamteCfg = {};\n    if (animateCfg) curAniamteCfg = animateCfg;else if (animateCfg === undefined) curAniamteCfg = this.get('animateCfg');\n    viewController.focus(item, isAnimate, curAniamteCfg);\n    this.autoPaint();\n  };\n  /**\n   * 自动重绘\n   * @internal 仅供内部更新机制调用，外部根据需求调用 render 或 paint 接口\n   */\n\n\n  AbstractGraph.prototype.autoPaint = function () {\n    if (this.get('autoPaint')) {\n      this.paint();\n    }\n  };\n  /**\n   * 仅画布重新绘制\n   */\n\n\n  AbstractGraph.prototype.paint = function () {\n    this.emit('beforepaint');\n    this.get('canvas').draw();\n    this.emit('afterpaint');\n  };\n  /**\n   * 将屏幕坐标转换为视口坐标\n   * @param {number} clientX 屏幕x坐标\n   * @param {number} clientY 屏幕y坐标\n   * @return {Point} 视口坐标\n   */\n\n\n  AbstractGraph.prototype.getPointByClient = function (clientX, clientY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByClient(clientX, clientY);\n  };\n  /**\n   * 将绘制坐标转换为屏幕坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {Point} 绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getClientByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getClientByPoint(x, y);\n  };\n  /**\n   * 将画布坐标转换为绘制坐标\n   * @param {number} canvasX 画布 x 坐标\n   * @param {number} canvasY 画布 y 坐标\n   * @return {object} 绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getPointByCanvas = function (canvasX, canvasY) {\n    var viewController = this.get('viewController');\n    return viewController.getPointByCanvas(canvasX, canvasY);\n  };\n  /**\n   * 将绘制坐标转换为画布坐标\n   * @param {number} x 绘制坐标 x\n   * @param {number} y 绘制坐标 y\n   * @return {object} 画布坐标\n   */\n\n\n  AbstractGraph.prototype.getCanvasByPoint = function (x, y) {\n    var viewController = this.get('viewController');\n    return viewController.getCanvasByPoint(x, y);\n  };\n  /**\n   * 获取图内容的中心绘制坐标\n   * @return {object} 中心绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getGraphCenterPoint = function () {\n    var bbox = this.get('group').getCanvasBBox();\n    return {\n      x: (bbox.minX + bbox.maxX) / 2,\n      y: (bbox.minY + bbox.maxY) / 2\n    };\n  };\n  /**\n   * 获取视口中心绘制坐标\n   * @return {object} 视口中心绘制坐标\n   */\n\n\n  AbstractGraph.prototype.getViewPortCenterPoint = function () {\n    return this.getPointByCanvas(this.get('width') / 2, this.get('height') / 2);\n  };\n  /**\n   * 显示元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.showItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, true);\n\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.nodes = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.edges = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: false\n          }];\n          after.combos = [{\n            id: id,\n            visible: true\n          }];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 隐藏元素\n   * @param {Item} item 指定元素\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.hideItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var object = itemController.changeItemVisibility(item, false);\n\n    if (stack && this.get('enabledStack')) {\n      var id = object.getID();\n      var type = object.getType();\n      var before = {};\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.nodes = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        case 'edge':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.edges = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        case 'combo':\n          before.nodes = [{\n            id: id,\n            visible: true\n          }];\n          after.combos = [{\n            id: id,\n            visible: false\n          }];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('visible', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 刷新元素\n   * @param {string|object} item 元素id或元素实例\n   */\n\n\n  AbstractGraph.prototype.refreshItem = function (item) {\n    var itemController = this.get('itemController');\n    itemController.refreshItem(item);\n  };\n  /**\n   * 设置是否在更新/刷新后自动重绘\n   * @param {boolean} auto 自动重绘\n   */\n\n\n  AbstractGraph.prototype.setAutoPaint = function (auto) {\n    var self = this;\n    self.set('autoPaint', auto);\n    var canvas = self.get('canvas');\n    canvas.set('autoDraw', auto);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.remove = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    this.removeItem(item, stack);\n  };\n  /**\n   * 删除元素\n   * @param {Item} item 元素id或元素实例\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.removeItem = function (item, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var nodeItem = item;\n    if (isString(item)) nodeItem = this.findById(item);\n\n    if (!nodeItem && isString(item)) {\n      console.warn('The item to be removed does not exist!');\n    } else if (nodeItem) {\n      var type = '';\n      if (nodeItem.getType) type = nodeItem.getType(); // 将删除的元素入栈\n\n      if (stack && this.get('enabledStack')) {\n        var deletedModel = __assign(__assign({}, nodeItem.getModel()), {\n          itemType: type\n        });\n\n        var before = {};\n\n        switch (type) {\n          case 'node':\n            {\n              before.nodes = [deletedModel];\n              before.edges = [];\n              var edges = nodeItem.getEdges();\n\n              for (var i = edges.length - 1; i >= 0; i--) {\n                before.edges.push(__assign(__assign({}, edges[i].getModel()), {\n                  itemType: 'edge'\n                }));\n              }\n\n              break;\n            }\n\n          case 'edge':\n            before.edges = [deletedModel];\n            break;\n\n          case 'combo':\n            before.combos = [deletedModel];\n            break;\n\n          default:\n            break;\n        }\n\n        this.pushStack('delete', {\n          before: before,\n          after: {}\n        });\n      }\n\n      if (type === 'node') {\n        var model = nodeItem.getModel(); // 如果删除的是节点，且该节点存在于某个 Combo 中，则需要先将 node 从 combo 中移除，否则删除节点后，操作 combo 会出错\n\n        if (model.comboId) {\n          this.updateComboTree(nodeItem, undefined, false);\n        }\n      }\n\n      var itemController = this.get('itemController');\n      itemController.removeItem(nodeItem);\n\n      if (type === 'combo') {\n        var newComboTrees = reconstructTree(this.get('comboTrees'));\n        this.set('comboTrees', newComboTrees);\n      }\n    }\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @param {boolean} sortCombo 本次操作是否需要更新 combo 层级顺序，内部参数，用户在外部使用 addItem 时始终时需要更新\n   * @return {Item} 元素实例\n   */\n\n\n  AbstractGraph.prototype.addItem = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    var currentComboSorted = this.get('comboSorted');\n    this.set('comboSorted', currentComboSorted && !sortCombo);\n    var itemController = this.get('itemController'); // 添加节点、边或combo之前，先验证数据是否符合规范\n\n    if (!singleDataValidation(type, model)) {\n      return false;\n    }\n\n    if (model.id && this.findById(model.id)) {\n      console.warn(\"This item exists already. Be sure the id %c\" + model.id + \"%c is unique.\", 'font-size: 20px; color: red;', '');\n      return;\n    }\n\n    var item;\n    var comboTrees = this.get('comboTrees');\n    if (!comboTrees) comboTrees = [];\n\n    if (type === 'combo') {\n      var itemMap_1 = this.get('itemMap');\n      var foundParent_1 = false;\n      comboTrees.forEach(function (ctree) {\n        if (foundParent_1) return; // terminate the forEach after the tree containing the item is done\n\n        traverseTreeUp(ctree, function (child) {\n          // find the parent\n          if (model.parentId === child.id) {\n            foundParent_1 = true;\n\n            var newCombo = __assign({\n              id: model.id,\n              depth: child.depth + 2\n            }, model);\n\n            if (child.children) child.children.push(newCombo);else child.children = [newCombo];\n            model.depth = newCombo.depth;\n            item = itemController.addItem(type, model);\n          }\n\n          var childItem = itemMap_1[child.id]; // after the parent is found, update all the ancestors\n\n          if (foundParent_1 && childItem && childItem.getType && childItem.getType() === 'combo') {\n            itemController.updateCombo(childItem, child.children);\n          }\n\n          return true;\n        });\n      }); // if the parent is not found, add it to the root\n\n      if (!foundParent_1) {\n        var newCombo = __assign({\n          id: model.id,\n          depth: 0\n        }, model);\n\n        model.depth = newCombo.depth;\n        comboTrees.push(newCombo);\n        item = itemController.addItem(type, model);\n      }\n\n      this.set('comboTrees', comboTrees);\n    } else if (type === 'node' && isString(model.comboId) && comboTrees) {\n      var parentCombo = this.findById(model.comboId);\n\n      if (parentCombo && parentCombo.getType && parentCombo.getType() !== 'combo') {\n        console.warn(\"'\" + model.comboId + \"' is not a id of a combo in the graph, the node will be added without combo.\");\n      }\n\n      item = itemController.addItem(type, model);\n      var itemMap_2 = this.get('itemMap');\n      var foundParent_2 = false,\n          foundNode_1 = false;\n      (comboTrees || []).forEach(function (ctree) {\n        if (foundNode_1 || foundParent_2) return; // terminate the forEach\n\n        traverseTreeUp(ctree, function (child) {\n          if (child.id === model.id) {\n            // if the item exists in the tree already, terminate\n            foundNode_1 = true;\n            return false;\n          }\n\n          if (model.comboId === child.id && !foundNode_1) {\n            // found the parent, add the item to the children of its parent in the tree\n            foundParent_2 = true;\n            var cloneNode = clone(model);\n            cloneNode.itemType = 'node';\n            if (child.children) child.children.push(cloneNode);else child.children = [cloneNode];\n            cloneNode.depth = child.depth + 1;\n          } // update the size of all the ancestors\n\n\n          if (foundParent_2 && itemMap_2[child.id].getType && itemMap_2[child.id].getType() === 'combo') {\n            itemController.updateCombo(itemMap_2[child.id], child.children);\n          }\n\n          return true;\n        });\n      });\n    } else {\n      item = itemController.addItem(type, model);\n    }\n\n    if (type === 'node' && model.comboId || type === 'combo' && model.parentId) {\n      // add the combo to the parent's children array\n      var parentCombo = this.findById(model.comboId || model.parentId);\n      if (parentCombo && parentCombo.getType && parentCombo.getType() === 'combo') parentCombo.addChild(item);\n    }\n\n    var combos = this.get('combos');\n\n    if (combos && combos.length > 0) {\n      this.sortCombos();\n    }\n\n    this.autoPaint();\n\n    if (stack && this.get('enabledStack')) {\n      var addedModel = __assign(__assign({}, item.getModel()), {\n        itemType: type\n      });\n\n      var after = {};\n\n      switch (type) {\n        case 'node':\n          after.nodes = [addedModel];\n          break;\n\n        case 'edge':\n          after.edges = [addedModel];\n          break;\n\n        case 'combo':\n          after.combos = [addedModel];\n          break;\n\n        default:\n          break;\n      }\n\n      this.pushStack('add', {\n        before: {},\n        after: after\n      });\n    }\n\n    return item;\n  };\n  /**\n   * 新增元素\n   * @param {ITEM_TYPE} type 元素类型(node | edge)\n   * @param {ModelConfig} model 元素数据模型\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   * @return {Item} 元素实例\n   */\n\n\n  AbstractGraph.prototype.add = function (type, model, stack, sortCombo) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    if (sortCombo === void 0) {\n      sortCombo = true;\n    }\n\n    return this.addItem(type, model, stack, sortCombo);\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   */\n\n\n  AbstractGraph.prototype.updateItem = function (item, cfg, stack) {\n    var _this = this;\n\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var itemController = this.get('itemController');\n    var currentItem;\n\n    if (isString(item)) {\n      currentItem = this.findById(item);\n    } else {\n      currentItem = item;\n    }\n\n    var UnupdateModel = clone(currentItem.getModel());\n    var type = '';\n    if (currentItem.getType) type = currentItem.getType();\n\n    var states = __spreadArray([], currentItem.getStates(), true);\n\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, false);\n      });\n    }\n\n    itemController.updateItem(currentItem, cfg);\n\n    if (type === 'combo') {\n      each(states, function (state) {\n        return _this.setItemState(currentItem, state, true);\n      });\n    }\n\n    if (stack && this.get('enabledStack')) {\n      var before = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n      var after = {\n        nodes: [],\n        edges: [],\n        combos: []\n      };\n\n      var afterModel = __assign({\n        id: UnupdateModel.id\n      }, cfg);\n\n      switch (type) {\n        case 'node':\n          before.nodes.push(UnupdateModel);\n          after.nodes.push(afterModel);\n          break;\n\n        case 'edge':\n          before.edges.push(UnupdateModel);\n          after.edges.push(afterModel);\n          break;\n\n        case 'combo':\n          before.combos.push(UnupdateModel);\n          after.combos.push(afterModel);\n          break;\n\n        default:\n          break;\n      }\n\n      if (type === 'node') {\n        before.nodes.push(UnupdateModel);\n      }\n\n      this.pushStack('update', {\n        before: before,\n        after: after\n      });\n    }\n  };\n  /**\n   * 更新元素\n   * @param {Item} item 元素id或元素实例\n   * @param {Partial<NodeConfig> | EdgeConfig} cfg 需要更新的数据\n   * @param {boolean} stack 本次操作是否入栈，默认为 true\n   */\n\n\n  AbstractGraph.prototype.update = function (item, cfg, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    this.updateItem(item, cfg, stack);\n  };\n  /**\n   * 设置元素状态\n   * @param {Item} item 元素id或元素实例\n   * @param {string} state 状态名称\n   * @param {string | boolean} value 是否启用状态 或 状态值\n   */\n\n\n  AbstractGraph.prototype.setItemState = function (item, state, value) {\n    if (isString(item)) {\n      item = this.findById(item);\n    }\n\n    var itemController = this.get('itemController');\n    itemController.setItemState(item, state, value);\n    var stateController = this.get('stateController');\n\n    if (isString(value)) {\n      stateController.updateState(item, state + \":\" + value, true);\n    } else {\n      stateController.updateState(item, state, value);\n    }\n  };\n  /**\n   * 将指定状态的优先级提升为最高优先级\n   * @param {Item} item 元素id或元素实例\n   * @param state 状态名称\n   */\n\n\n  AbstractGraph.prototype.priorityState = function (item, state) {\n    var itemController = this.get('itemController');\n    itemController.priorityState(item, state);\n  };\n  /**\n   * 设置视图初始化数据\n   * @param {GraphData} data 初始化数据\n   */\n\n\n  AbstractGraph.prototype.data = function (data) {\n    dataValidation(data);\n    this.set('data', data);\n  };\n  /**\n   * 根据data接口的数据渲染视图\n   */\n\n\n  AbstractGraph.prototype.render = function () {\n    var self = this;\n    this.set('comboSorted', false);\n    var data = this.get('data');\n\n    if (this.get('enabledStack')) {\n      // render 之前清空 redo 和 undo 栈\n      this.clearStack();\n    }\n\n    if (!data) {\n      throw new Error('data must be defined first');\n    }\n\n    var _a = data.nodes,\n        nodes = _a === void 0 ? [] : _a,\n        _b = data.edges,\n        edges = _b === void 0 ? [] : _b,\n        _c = data.combos,\n        combos = _c === void 0 ? [] : _c;\n    this.clear(true);\n    this.emit('beforerender');\n    each(nodes, function (node) {\n      self.add('node', node, false, false);\n    }); // process the data to tree structure\n\n    if (combos && combos.length !== 0) {\n      var comboTrees = plainCombosToTrees(combos, nodes);\n      this.set('comboTrees', comboTrees); // add combos\n\n      self.addCombos(combos);\n    }\n\n    each(edges, function (edge) {\n      self.add('edge', edge, false, false);\n    });\n    var animate = self.get('animate');\n\n    if (self.get('fitView') || self.get('fitCenter')) {\n      self.set('animate', false);\n    } // layout\n\n\n    var layoutController = self.get('layoutController');\n\n    if (layoutController) {\n      layoutController.layout(success);\n      if (this.destroyed) return;\n    } else {\n      if (self.get('fitView')) {\n        self.fitView();\n      }\n\n      if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n\n      self.emit('afterrender');\n      self.set('animate', animate);\n    } // 将在 onLayoutEnd 中被调用\n\n\n    function success() {\n      // fitView 与 fitCenter 共存时，fitView 优先，fitCenter 不再执行\n      if (self.get('fitView')) {\n        self.fitView();\n      } else if (self.get('fitCenter')) {\n        self.fitCenter();\n      }\n\n      self.autoPaint();\n      self.emit('afterrender');\n\n      if (self.get('fitView') || self.get('fitCenter')) {\n        self.set('animate', animate);\n      }\n    }\n\n    if (!this.get('groupByTypes')) {\n      if (combos && combos.length !== 0) {\n        this.sortCombos();\n      } else {\n        // 为提升性能，选择数量少的进行操作\n        if (data.nodes && data.edges && data.nodes.length < data.edges.length) {\n          var nodesArr = this.getNodes(); // 遍历节点实例，将所有节点提前。\n\n          nodesArr.forEach(function (node) {\n            node.toFront();\n          });\n        } else {\n          var edgesArr = this.getEdges(); // 遍历节点实例，将所有节点提前。\n\n          edgesArr.forEach(function (edge) {\n            edge.toBack();\n          });\n        }\n      }\n    }\n\n    if (this.get('enabledStack')) {\n      this.pushStack('render');\n    }\n  };\n  /**\n   * 接收数据进行渲染\n   * @Param {Object} data 初始化数据\n   */\n\n\n  AbstractGraph.prototype.read = function (data) {\n    this.data(data);\n    this.render();\n  }; // 比较item\n\n\n  AbstractGraph.prototype.diffItems = function (type, items, models) {\n    var self = this;\n    var item;\n    var itemMap = this.get('itemMap');\n    each(models, function (model) {\n      item = itemMap[model.id];\n\n      if (item) {\n        if (self.get('animate') && type === NODE) {\n          var containerMatrix = item.getContainer().getMatrix();\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          item.set('originAttrs', {\n            x: containerMatrix[6],\n            y: containerMatrix[7]\n          });\n        }\n\n        self.updateItem(item, model, false);\n      } else {\n        item = self.addItem(type, model, false);\n      }\n\n      if (item) items[type + \"s\"].push(item);\n    });\n  };\n  /**\n   * 更改源数据，根据新数据重新渲染视图\n   * @param {GraphData | TreeGraphData} data 源数据\n   * @param {boolean} 是否入栈，默认为true\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.changeData = function (data, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var self = this;\n\n    if (!dataValidation(data)) {\n      return this;\n    }\n\n    if (stack && this.get('enabledStack')) {\n      this.pushStack('changedata', {\n        before: self.save(),\n        after: data\n      });\n    }\n\n    this.set('comboSorted', false); // 删除 hulls\n\n    this.removeHulls(); // 更改数据源后，取消所有状态\n\n    this.getNodes().map(function (node) {\n      return self.clearItemStates(node);\n    });\n    this.getEdges().map(function (edge) {\n      return self.clearItemStates(edge);\n    });\n    var canvas = this.get('canvas');\n    var localRefresh = canvas.get('localRefresh');\n    canvas.set('localRefresh', false);\n\n    if (!self.get('data')) {\n      self.data(data);\n      self.render();\n    }\n\n    var itemMap = this.get('itemMap');\n    var items = {\n      nodes: [],\n      edges: []\n    };\n    var combosData = data.combos;\n\n    if (combosData) {\n      var comboTrees = plainCombosToTrees(combosData, data.nodes);\n      this.set('comboTrees', comboTrees);\n    } else {\n      this.set('comboTrees', []);\n    }\n\n    this.diffItems('node', items, data.nodes);\n    each(itemMap, function (item, id) {\n      itemMap[id].getModel().depth = 0;\n      if (item.getType && item.getType() === 'edge') return;\n\n      if (item.getType && item.getType() === 'combo') {\n        delete itemMap[id];\n        item.destroy();\n      } else if (items.nodes.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    }); // clear the destroyed combos here to avoid removing sub nodes before removing the parent combo\n\n    var comboItems = this.getCombos();\n    var combosLength = comboItems.length;\n\n    for (var i = combosLength - 1; i >= 0; i--) {\n      if (comboItems[i].destroyed) {\n        comboItems.splice(i, 1);\n      }\n    } // process the data to tree structure\n\n\n    if (combosData) {\n      // add combos\n      self.addCombos(combosData);\n\n      if (!this.get('groupByTypes')) {\n        this.sortCombos();\n      }\n    }\n\n    this.diffItems('edge', items, data.edges);\n    each(itemMap, function (item, id) {\n      if (item.getType && (item.getType() === 'node' || item.getType() === 'combo')) return;\n\n      if (items.edges.indexOf(item) < 0) {\n        delete itemMap[id];\n        self.remove(item, false);\n      }\n    });\n    this.set({\n      nodes: items.nodes,\n      edges: items.edges\n    });\n    var layoutController = this.get('layoutController');\n\n    if (layoutController) {\n      layoutController.changeData();\n\n      if (self.get('animate') && !layoutController.getLayoutType()) {\n        // 如果没有指定布局\n        self.positionsAnimate();\n      } else {\n        self.autoPaint();\n      }\n    }\n\n    setTimeout(function () {\n      canvas.set('localRefresh', localRefresh);\n    }, 16);\n    return this;\n  };\n  /**\n   * 私有方法，在 render 和 changeData 的时候批量添加数据中所有平铺的 combos\n   * @param {ComboConfig[]} combos 平铺的 combos 数据\n   */\n\n\n  AbstractGraph.prototype.addCombos = function (combos) {\n    var self = this;\n    var comboTrees = self.get('comboTrees');\n    var itemController = this.get('itemController');\n    itemController.addCombos(comboTrees, combos);\n  };\n  /**\n   * 根据已经存在的节点或 combo 创建新的 combo\n   * @param combo combo ID 或 Combo 配置\n   * @param children 添加到 Combo 中的元素，包括节点和 combo\n   */\n\n\n  AbstractGraph.prototype.createCombo = function (combo, children) {\n    var _this = this;\n\n    this.set('comboSorted', false); // step 1: 创建新的 Combo\n\n    var comboId = '';\n    var comboConfig;\n    if (!combo) return;\n\n    if (isString(combo)) {\n      comboId = combo;\n      comboConfig = {\n        id: combo\n      };\n    } else {\n      comboId = combo.id;\n\n      if (!comboId) {\n        console.warn('Create combo failed. Please assign a unique string id for the adding combo.');\n        return;\n      }\n\n      comboConfig = combo;\n    } // step2: 更新 children，根据类型添加 comboId 或 parentId\n\n\n    var trees = children.map(function (elementId) {\n      var item = _this.findById(elementId);\n\n      var model = item.getModel();\n      var type = '';\n      if (item.getType) type = item.getType();\n      var cItem = {\n        id: item.getID(),\n        itemType: type\n      };\n\n      if (type === 'combo') {\n        cItem.parentId = comboId;\n        model.parentId = comboId;\n      } else if (type === 'node') {\n        cItem.comboId = comboId;\n        model.comboId = comboId;\n      }\n\n      return cItem;\n    });\n    comboConfig.children = trees; // step 3: 添加 Combo，addItem 时会将子将元素添加到 Combo 中\n\n    this.addItem('combo', comboConfig, false);\n    this.set('comboSorted', false); // step4: 更新 comboTrees 结构\n\n    var comboTrees = this.get('comboTrees');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (child.id === comboId) {\n          child.itemType = 'combo';\n          child.children = trees;\n          return false;\n        }\n\n        return true;\n      });\n    });\n\n    if (comboTrees) {\n      this.sortCombos();\n    }\n  };\n  /**\n   * 解散 combo\n   * @param {String | INode | ICombo} combo 需要被解散的 Combo item 或 id\n   */\n\n\n  AbstractGraph.prototype.uncombo = function (combo) {\n    var _this = this;\n\n    var _a;\n\n    var self = this;\n    var comboItem = combo;\n\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item is not a combo!');\n      return;\n    }\n\n    var parentId = comboItem.getModel().parentId;\n    var comboTrees = self.get('comboTrees');\n    if (!comboTrees) comboTrees = [];\n    var itemMap = this.get('itemMap');\n    var comboId = comboItem.get('id');\n    var treeToBeUncombo;\n    var brothers = [];\n    var comboItems = this.get('combos');\n    var parentItem = this.findById(parentId);\n    comboTrees.forEach(function (ctree) {\n      if (treeToBeUncombo) return; // terminate the forEach\n\n      traverseTreeUp(ctree, function (subtree) {\n        var _a; // find the combo to be uncomboed, delete the combo from map and cache\n\n\n        if (subtree.id === comboId) {\n          treeToBeUncombo = subtree; // delete the related edges\n\n          var edges = comboItem.getEdges();\n          edges.forEach(function (edge) {\n            _this.removeItem(edge, false);\n          });\n          var index = comboItems.indexOf(comboItem);\n          comboItems.splice(index, 1);\n          delete itemMap[comboId];\n          comboItem.destroy();\n\n          _this.emit('afterremoveitem', {\n            item: comboItem,\n            type: 'combo'\n          });\n        } // find the parent to remove the combo from the combo's brothers array and add the combo's children to the combo's brothers array in the tree\n\n\n        if (parentId && treeToBeUncombo && subtree.id === parentId) {\n          parentItem.removeCombo(comboItem);\n          brothers = subtree.children; // the combo's brothers\n          // remove the combo from its brothers array\n\n          var index = brothers.indexOf(treeToBeUncombo);\n\n          if (index !== -1) {\n            brothers.splice(index, 1);\n          } // append the combo's children to the combo's brothers array\n\n\n          (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n            var item = _this.findById(child.id);\n\n            var childModel = item.getModel();\n\n            if (item.getType && item.getType() === 'combo') {\n              child.parentId = parentId;\n              delete child.comboId;\n              childModel.parentId = parentId; // update the parentId of the model\n\n              delete childModel.comboId;\n            } else if (item.getType && item.getType() === 'node') {\n              child.comboId = parentId;\n              childModel.comboId = parentId; // update the parentId of the model\n            }\n\n            parentItem.addChild(item);\n            brothers.push(child);\n          });\n          return false;\n        }\n\n        return true;\n      });\n    }); // if the parentId is not found, remove the combo from the roots\n\n    if (!parentId && treeToBeUncombo) {\n      var index = comboTrees.indexOf(treeToBeUncombo);\n      comboTrees.splice(index, 1); // modify the parentId of the children\n\n      (_a = treeToBeUncombo.children) === null || _a === void 0 ? void 0 : _a.forEach(function (child) {\n        child.parentId = undefined;\n\n        var childModel = _this.findById(child.id).getModel();\n\n        delete childModel.parentId; // update the parentId of the model\n\n        delete childModel.comboId; // update the comboId of the model\n\n        if (child.itemType !== 'node') comboTrees.push(child);\n      });\n    }\n  };\n  /**\n   * 根据节点的 bbox 更新所有 combos 的绘制，包括 combos 的位置和范围\n   */\n\n\n  AbstractGraph.prototype.updateCombos = function () {\n    var _this = this;\n\n    var self = this;\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (!child) {\n          return true;\n        }\n\n        var childItem = itemMap[child.id];\n\n        if (childItem && childItem.getType && childItem.getType() === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true);\n\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, false);\n          }); // 更新具体的 Combo\n\n          itemController.updateCombo(childItem, child.children); // 更新 Combo 后，还原已有的状态\n\n          each(states, function (state) {\n            return _this.setItemState(childItem, state, true);\n          });\n        }\n\n        return true;\n      });\n    });\n    self.sortCombos();\n  };\n  /**\n   * 根据节点的 bbox 更新 combo 及其祖先 combos 的绘制，包括 combos 的位置和范围\n   * @param {String | ICombo} combo 需要被更新的 Combo 或 id，若指定，则该 Combo 及所有祖先 Combod 都会被更新\n   */\n\n\n  AbstractGraph.prototype.updateCombo = function (combo) {\n    var _this = this;\n\n    var self = this;\n    var comboItem = combo;\n    var comboId;\n\n    if (isString(combo)) {\n      comboItem = this.findById(combo);\n    }\n\n    if (!comboItem || comboItem.getType && comboItem.getType() !== 'combo') {\n      console.warn('The item to be updated is not a combo!');\n      return;\n    }\n\n    comboId = comboItem.get('id');\n    var comboTrees = this.get('comboTrees');\n    var itemController = self.get('itemController');\n    var itemMap = self.get('itemMap');\n    (comboTrees || []).forEach(function (ctree) {\n      traverseTreeUp(ctree, function (child) {\n        if (!child) {\n          return true;\n        }\n\n        var childItem = itemMap[child.id];\n\n        if (comboId === child.id && childItem && childItem.getType && childItem.getType() === 'combo') {\n          // 更新具体的 Combo 之前先清除所有的已有状态，以免将 state 中的样式更新为 Combo 的样式\n          var states = __spreadArray([], childItem.getStates(), true); // || !item.getStateStyle(stateName)\n\n\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, false);\n            }\n          }); // 更新具体的 Combo\n\n          itemController.updateCombo(childItem, child.children); // 更新 Combo 后，还原已有的状态\n\n          each(states, function (state) {\n            if (childItem.getStateStyle(state)) {\n              _this.setItemState(childItem, state, true);\n            }\n          });\n          if (comboId) comboId = child.parentId;\n        }\n\n        return true;\n      });\n    });\n  };\n  /**\n   * 更新树结构，例如移动子树等\n   * @param {String | INode | ICombo} item 需要被更新的 Combo 或 节点 id\n   * @param {string | undefined} parentId 新的父 combo id，undefined 代表没有父 combo\n   */\n\n\n  AbstractGraph.prototype.updateComboTree = function (item, parentId, stack) {\n    if (stack === void 0) {\n      stack = true;\n    }\n\n    var self = this;\n    this.set('comboSorted', false);\n    var uItem;\n\n    if (isString(item)) {\n      uItem = self.findById(item);\n    } else {\n      uItem = item;\n    }\n\n    var model = uItem.getModel();\n    var oldParentId = model.comboId || model.parentId;\n    var type = '';\n    if (uItem.getType) type = uItem.getType(); // 若 item 是 Combo，且 parentId 是其子孙 combo 的 id，则警告并终止\n\n    if (parentId && type === 'combo') {\n      var comboTrees = this.get('comboTrees');\n      var valid_1 = true;\n      var itemSubTree_1;\n      (comboTrees || []).forEach(function (ctree) {\n        if (itemSubTree_1) return;\n        traverseTree(ctree, function (subTree) {\n          if (itemSubTree_1) return; // 找到从 item 开始的子树\n\n          if (subTree.id === uItem.getID()) {\n            itemSubTree_1 = subTree;\n          }\n\n          return true;\n        });\n      }); // 在以 item 为根的子树中寻找与 parentId 相同的后继元素\n\n      traverseTree(itemSubTree_1, function (subTree) {\n        if (subTree.id === parentId) {\n          valid_1 = false;\n          return false;\n        }\n\n        return true;\n      }); // parentId 是 item 的一个后继元素，不能进行更新\n\n      if (!valid_1) {\n        console.warn('Failed to update the combo tree! The parentId points to a descendant of the combo!');\n        return;\n      }\n    }\n\n    if (stack && this.get('enabledStack')) {\n      var beforeData = {},\n          afterData = {};\n\n      if (type === 'combo') {\n        beforeData.combos = [{\n          id: model.id,\n          parentId: model.parentId\n        }];\n        afterData.combos = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      } else if (type === 'node') {\n        beforeData.nodes = [{\n          id: model.id,\n          parentId: model.comboId\n        }];\n        afterData.nodes = [{\n          id: model.id,\n          parentId: parentId\n        }];\n      }\n\n      this.pushStack('updateComboTree', {\n        before: beforeData,\n        after: afterData\n      });\n    } // 当 combo 存在 parentId 或 comboId 时，才将其移除\n\n\n    if (model.parentId || model.comboId) {\n      var combo = this.findById(model.parentId || model.comboId);\n\n      if (combo) {\n        combo.removeChild(uItem);\n      }\n    }\n\n    if (type === 'combo') {\n      model.parentId = parentId;\n    } else if (type === 'node') {\n      model.comboId = parentId;\n    } // 只有当移入到指定 combo 时才添加\n\n\n    if (parentId) {\n      var parentCombo = this.findById(parentId);\n\n      if (parentCombo) {\n        // 将元素添加到 parentCombo 中\n        parentCombo.addChild(uItem);\n      }\n    } // 如果原先有父亲 combo，则从原父 combo 的子元素数组中删除\n\n\n    if (oldParentId) {\n      var parentCombo = this.findById(oldParentId);\n\n      if (parentCombo) {\n        // 将元素从 parentCombo 中移除\n        parentCombo.removeChild(uItem);\n      }\n    }\n\n    var newComboTrees = reconstructTree(this.get('comboTrees'), model.id, parentId);\n    this.set('comboTrees', newComboTrees);\n    this.updateCombos();\n  };\n  /**\n   * 导出图数据\n   * @return {object} data\n   */\n\n\n  AbstractGraph.prototype.save = function () {\n    var nodes = [];\n    var edges = [];\n    var combos = [];\n    each(this.get('nodes'), function (node) {\n      nodes.push(node.getModel());\n    });\n    each(this.get('edges'), function (edge) {\n      edges.push(edge.getModel());\n    });\n    each(this.get('combos'), function (combo) {\n      combos.push(combo.getModel());\n    });\n    return {\n      nodes: nodes,\n      edges: edges,\n      combos: combos\n    };\n  };\n  /**\n   * 改变画布大小\n   * @param  {number} width  画布宽度\n   * @param  {number} height 画布高度\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.changeSize = function (width, height) {\n    var viewController = this.get('viewController');\n    viewController.changeSize(width, height);\n    return this;\n  };\n  /**\n   * 当源数据在外部发生变更时，根据新数据刷新视图。但是不刷新节点位置\n   */\n\n\n  AbstractGraph.prototype.refresh = function () {\n    var self = this;\n    self.emit('beforegraphrefresh');\n\n    if (self.get('animate')) {\n      self.positionsAnimate();\n    } else {\n      var nodes = self.get('nodes');\n      var edges = self.get('edges');\n      var vedges = self.get('edges');\n      each(nodes, function (node) {\n        node.refresh();\n      });\n      each(edges, function (edge) {\n        edge.refresh();\n      });\n      each(vedges, function (vedge) {\n        vedge.refresh();\n      });\n    }\n\n    self.emit('aftergraphrefresh');\n    self.autoPaint();\n  };\n  /**\n   * 获取当前图中所有节点的item实例\n   * @return {INode} item数组\n   */\n\n\n  AbstractGraph.prototype.getNodes = function () {\n    return this.get('nodes');\n  };\n  /**\n   * 获取当前图中所有边的item实例\n   * @return {IEdge} item数组\n   */\n\n\n  AbstractGraph.prototype.getEdges = function () {\n    return this.get('edges');\n  };\n  /**\n   * 获取图中所有的 combo 实例\n   */\n\n\n  AbstractGraph.prototype.getCombos = function () {\n    return this.get('combos');\n  };\n  /**\n   * 获取指定 Combo 中所有的节点\n   * @param comboId combo ID\n   */\n\n\n  AbstractGraph.prototype.getComboChildren = function (combo) {\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo does not exist!');\n      return;\n    }\n\n    return combo.getChildren();\n  };\n  /**\n   * 根据 graph 上的 animateCfg 进行视图中节点位置动画接口\n   */\n\n\n  AbstractGraph.prototype.positionsAnimate = function () {\n    var self = this;\n    self.emit('beforeanimate');\n    var animateCfg = self.get('animateCfg');\n    var onFrame = animateCfg.onFrame;\n    var nodes = self.getNodes();\n    var toNodes = nodes.map(function (node) {\n      var model = node.getModel();\n      return {\n        id: model.id,\n        x: model.x,\n        y: model.y\n      };\n    });\n\n    if (self.isAnimating()) {\n      self.stopAnimate();\n    }\n\n    var canvas = self.get('canvas');\n    canvas.animate(function (ratio) {\n      each(toNodes, function (data) {\n        var node = self.findById(data.id);\n\n        if (!node || node.destroyed) {\n          return;\n        }\n\n        var originAttrs = node.get('originAttrs');\n        var model = node.get('model');\n\n        if (!originAttrs) {\n          var containerMatrix = node.getContainer().getMatrix();\n          if (!containerMatrix) containerMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          originAttrs = {\n            x: containerMatrix[6],\n            y: containerMatrix[7]\n          };\n          node.set('originAttrs', originAttrs);\n        }\n\n        if (onFrame) {\n          var attrs = onFrame(node, ratio, data, originAttrs);\n          node.set('model', Object.assign(model, attrs));\n        } else {\n          model.x = originAttrs.x + (data.x - originAttrs.x) * ratio;\n          model.y = originAttrs.y + (data.y - originAttrs.y) * ratio;\n        }\n      });\n      self.refreshPositions();\n    }, {\n      duration: animateCfg.duration,\n      easing: animateCfg.easing,\n      callback: function callback() {\n        each(nodes, function (node) {\n          node.set('originAttrs', null);\n        });\n\n        if (animateCfg.callback) {\n          animateCfg.callback();\n        }\n\n        self.emit('afteranimate');\n        self.animating = false;\n      }\n    });\n  };\n  /**\n   * 当节点位置在外部发生改变时，刷新所有节点位置，重计算边\n   */\n\n\n  AbstractGraph.prototype.refreshPositions = function () {\n    var self = this;\n    self.emit('beforegraphrefreshposition');\n    var nodes = self.get('nodes');\n    var edges = self.get('edges');\n    var vedges = self.get('vedges');\n    var combos = self.get('combos');\n    var model;\n    var updatedNodes = {};\n    each(nodes, function (node) {\n      model = node.getModel();\n      var originAttrs = node.get('originAttrs');\n\n      if (originAttrs && model.x === originAttrs.x && model.y === originAttrs.y) {\n        return;\n      }\n\n      var changed = node.updatePosition({\n        x: model.x,\n        y: model.y\n      });\n      updatedNodes[model.id] = changed;\n      if (model.comboId) updatedNodes[model.comboId] = updatedNodes[model.comboId] || changed;\n    });\n\n    if (combos && combos.length !== 0) {\n      self.updateCombos();\n    }\n\n    each(edges, function (edge) {\n      var sourceModel = edge.getSource().getModel();\n      var target = edge.getTarget(); // 避免 target 是纯对象的情况下调用 getModel 方法\n      // 拖动生成边的时候 target 会是纯对象\n\n      if (!isPlainObject(target)) {\n        var targetModel = target.getModel();\n\n        if (updatedNodes[sourceModel.id] || updatedNodes[targetModel.id] || edge.getModel().isComboEdge) {\n          edge.refresh();\n        }\n      }\n    });\n    each(vedges, function (vedge) {\n      vedge.refresh();\n    });\n    self.emit('aftergraphrefreshposition');\n    self.autoPaint();\n  };\n\n  AbstractGraph.prototype.stopAnimate = function () {\n    this.get('canvas').stopAnimate();\n  };\n\n  AbstractGraph.prototype.isAnimating = function () {\n    return this.animating;\n  };\n  /**\n   * 获取当前视口伸缩比例\n   * @return {number} 比例\n   */\n\n\n  AbstractGraph.prototype.getZoom = function () {\n    var matrix = this.get('group').getMatrix();\n    return matrix ? matrix[0] : 1;\n  };\n  /**\n   * 获取当前的行为模式\n   * @return {string} 当前行为模式\n   */\n\n\n  AbstractGraph.prototype.getCurrentMode = function () {\n    var modeController = this.get('modeController');\n    return modeController.getMode();\n  };\n  /**\n   * 切换行为模式\n   * @param {string} mode 指定模式\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.setMode = function (mode) {\n    var modeController = this.get('modeController');\n    modeController.setMode(mode);\n    return this;\n  };\n  /**\n   * 清除画布元素\n   * @return {object} this\n   */\n\n\n  AbstractGraph.prototype.clear = function (avoidEmit) {\n    var _a;\n\n    if (avoidEmit === void 0) {\n      avoidEmit = false;\n    }\n\n    (_a = this.get('canvas')) === null || _a === void 0 ? void 0 : _a.clear();\n    this.initGroups(); // 清空画布时同时清除数据\n\n    this.set({\n      itemMap: {},\n      nodes: [],\n      edges: [],\n      groups: [],\n      combos: [],\n      comboTrees: []\n    });\n    if (!avoidEmit) this.emit('afterrender');\n    return this;\n  };\n  /**\n   * 更换布局配置项\n   * @param {object} cfg 新布局配置项\n   * @param {'center' | 'begin'} align 对齐方式，可选中心（center）对齐到对齐点，或左上角（begin）对齐到对齐点\n   * @param {IPoint} alignPoint 画布上的对齐点，为 Canvas 坐标系（Canvas DOM）\n   * 若 cfg 含有 type 字段或为 String 类型，且与现有布局方法不同，则更换布局\n   * 若 cfg 不包括 type ，则保持原有布局方法，仅更新布局配置项\n   */\n\n\n  AbstractGraph.prototype.updateLayout = function (cfg, align, alignPoint) {\n    var _this = this;\n\n    var layoutController = this.get('layoutController');\n\n    if (isString(cfg)) {\n      cfg = {\n        type: cfg\n      };\n    } // align the graph after layout\n\n\n    if (align) {\n      var toPoint_1 = alignPoint;\n\n      if (!toPoint_1) {\n        if (align === 'begin') toPoint_1 = {\n          x: 0,\n          y: 0\n        };else toPoint_1 = {\n          x: this.getWidth() / 2,\n          y: this.getHeight() / 2\n        };\n      } // translate to point coordinate system\n\n\n      toPoint_1 = this.getPointByCanvas(toPoint_1.x, toPoint_1.y);\n      var forceTypes = ['force', 'gForce', 'fruchterman']; // if it is force layout, only center takes effect, and assign center force\n\n      if (forceTypes.includes(cfg.type) || !cfg.type && forceTypes.includes(layoutController === null || layoutController === void 0 ? void 0 : layoutController.layoutType)) {\n        cfg.center = [toPoint_1.x, toPoint_1.y];\n      } else {\n        this.once('afterlayout', function (e) {\n          var matrix = _this.getGroup().getMatrix() || [1, 0, 0, 0, 1, 0, 0, 0, 1];\n          toPoint_1.x = toPoint_1.x * matrix[0] + matrix[6];\n          toPoint_1.y = toPoint_1.y * matrix[0] + matrix[7];\n\n          var _a = _this.getGroup().getCanvasBBox(),\n              minX = _a.minX,\n              maxX = _a.maxX,\n              minY = _a.minY,\n              maxY = _a.maxY;\n\n          var bboxPoint = {\n            x: (minX + maxX) / 2,\n            y: (minY + maxY) / 2\n          };\n\n          if (align === 'begin') {\n            bboxPoint.x = minX;\n            bboxPoint.y = minY;\n          }\n\n          _this.translate(toPoint_1.x - bboxPoint.x, toPoint_1.y - bboxPoint.y);\n        });\n      }\n    }\n\n    var oriLayoutCfg = this.get('layout');\n    var layoutCfg = {};\n    Object.assign(layoutCfg, oriLayoutCfg, cfg);\n    this.set('layout', layoutCfg);\n\n    if (layoutController.isLayoutTypeSame(layoutCfg) && layoutCfg.gpuEnabled === oriLayoutCfg.gpuEnabled) {\n      // no type or same type, or switch the gpu and cpu, update layout\n      layoutController.updateLayoutCfg(layoutCfg);\n    } else {\n      // has different type, change layout\n      layoutController.changeLayout(layoutCfg);\n    }\n  };\n  /**\n   * 销毁布局，changeData 时不会再使用原来的布局方法对新数据进行布局\n   */\n\n\n  AbstractGraph.prototype.destroyLayout = function () {\n    var layoutController = this.get('layoutController');\n    layoutController.destroyLayout();\n  };\n  /**\n   * 重新以当前示例中配置的属性进行一次布局\n   */\n\n\n  AbstractGraph.prototype.layout = function () {\n    var layoutController = this.get('layoutController');\n    var layoutCfg = this.get('layout');\n    if (!layoutCfg || !layoutController) return;\n\n    if (layoutCfg.workerEnabled) {\n      // 如果使用web worker布局\n      layoutController.layout();\n      return;\n    }\n\n    if (layoutController.layoutMethod) {\n      layoutController.relayout(true);\n    } else {\n      layoutController.layout();\n    }\n  };\n  /**\n   * 收起指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n\n\n  AbstractGraph.prototype.collapseCombo = function (combo) {\n    var _this = this;\n\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo) {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.collapseCombo(combo);\n    comboModel.collapsed = true; // add virtual edges\n\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\n\n    var cnodes = [];\n    var ccombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate the forEach\n\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false; // if the combo is found\n\n        if (comboModel.id === subTree.id) found = true;\n\n        if (found) {\n          // if the combo is found, concat the descendant nodes and combos\n          var item = _this.findById(subTree.id);\n\n          if (item && item.getType && item.getType() === 'combo') {\n            cnodes = cnodes.concat(item.getNodes());\n            ccombos = ccombos.concat(item.getCombos());\n          }\n        }\n\n        return true;\n      });\n    });\n    var edgeWeightMap = {};\n    var addedVEdges = [];\n    edges.forEach(function (edge) {\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n\n      if ((cnodes.includes(source) || ccombos.includes(source)) && !cnodes.includes(target) && !ccombos.includes(target) || source.getModel().id === comboModel.id) {\n        var edgeModel = edge.getModel();\n\n        if (edgeModel.isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var targetModel = target.getModel();\n\n        while (!target.isVisible()) {\n          target = _this.findById(targetModel.parentId || targetModel.comboId);\n          if (!target || !targetModel.parentId && !targetModel.comboId) return; // all the ancestors are hidden, then ignore the edge\n\n          targetModel = target.getModel();\n        }\n\n        var targetId = targetModel.id;\n\n        if (edgeWeightMap[comboModel.id + \"-\" + targetId]) {\n          edgeWeightMap[comboModel.id + \"-\" + targetId] += edgeModel.size || 1;\n          return;\n        } // the source is in the combo, the target is not\n\n\n        var vedge = _this.addItem('vedge', {\n          source: comboModel.id,\n          target: targetId,\n          isVEdge: true\n        }, false);\n\n        edgeWeightMap[comboModel.id + \"-\" + targetId] = edgeModel.size || 1;\n        addedVEdges.push(vedge);\n      } else if (!cnodes.includes(source) && !ccombos.includes(source) && (cnodes.includes(target) || ccombos.includes(target)) || target.getModel().id === comboModel.id) {\n        var edgeModel = edge.getModel();\n\n        if (edgeModel.isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var sourceModel = source.getModel();\n\n        while (!source.isVisible()) {\n          source = _this.findById(sourceModel.parentId || sourceModel.comboId);\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) return; // all the ancestors are hidden, then ignore the edge\n\n          sourceModel = source.getModel();\n        }\n\n        var sourceId = sourceModel.id;\n\n        if (edgeWeightMap[sourceId + \"-\" + comboModel.id]) {\n          edgeWeightMap[sourceId + \"-\" + comboModel.id] += edgeModel.size || 1;\n          return;\n        } // the target is in the combo, the source is not\n\n\n        var vedge = _this.addItem('vedge', {\n          target: comboModel.id,\n          source: sourceId,\n          isVEdge: true\n        }, false);\n\n        edgeWeightMap[sourceId + \"-\" + comboModel.id] = edgeModel.size || 1;\n        addedVEdges.push(vedge);\n      }\n    }); // update the width of the virtual edges, which is the sum of merged actual edges\n    // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n    addedVEdges.forEach(function (vedge) {\n      var vedgeModel = vedge.getModel();\n\n      _this.updateItem(vedge, {\n        size: edgeWeightMap[vedgeModel.source + \"-\" + vedgeModel.target]\n      }, false);\n    });\n    this.emit('aftercollapseexpandcombo', {\n      action: 'collapse',\n      item: combo\n    });\n  };\n  /**\n   * 展开指定的 combo\n   * @param {string | ICombo} combo combo ID 或 combo item\n   */\n\n\n  AbstractGraph.prototype.expandCombo = function (combo) {\n    var _this = this;\n\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') {\n      console.warn('The combo to be collapsed does not exist!');\n      return;\n    }\n\n    this.emit('beforecollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n    var comboModel = combo.getModel();\n    var itemController = this.get('itemController');\n    itemController.expandCombo(combo);\n    comboModel.collapsed = false; // add virtual edges\n\n    var edges = this.getEdges().concat(this.get('vedges')); // find all the descendant nodes and combos\n\n    var cnodes = [];\n    var ccombos = [];\n    var comboTrees = this.get('comboTrees');\n    var found = false;\n    (comboTrees || []).forEach(function (ctree) {\n      if (found) return; // if the combo is found, terminate\n\n      traverseTree(ctree, function (subTree) {\n        // if the combo is found and it is traversing the other branches, terminate\n        if (found && subTree.depth <= comboModel.depth) return false;\n        if (comboModel.id === subTree.id) found = true;\n\n        if (found) {\n          var item = _this.findById(subTree.id);\n\n          if (item && item.getType && item.getType() === 'combo') {\n            cnodes = cnodes.concat(item.getNodes());\n            ccombos = ccombos.concat(item.getCombos());\n          }\n        }\n\n        return true;\n      });\n    });\n    var edgeWeightMap = {};\n    var addedVEdges = {};\n    edges.forEach(function (edge) {\n      if (edge.isVisible() && !edge.getModel().isVEdge) return;\n      var source = edge.getSource();\n      var target = edge.getTarget();\n      var sourceId = source.get('id');\n      var targetId = target.get('id');\n\n      if ((cnodes.includes(source) || ccombos.includes(source)) && !cnodes.includes(target) && !ccombos.includes(target) || sourceId === comboModel.id) {\n        // the source is in the combo, the target is not\n        // ignore the virtual edges\n        if (edge.getModel().isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var targetModel = target.getModel(); // find the nearest visible ancestor\n\n        while (!target.isVisible()) {\n          target = _this.findById(targetModel.comboId || targetModel.parentId);\n\n          if (!target || !targetModel.parentId && !targetModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          targetModel = target.getModel();\n        }\n\n        targetId = targetModel.id;\n        var sourceModel = source.getModel(); // find the nearest visible ancestor\n\n        while (!source.isVisible()) {\n          source = _this.findById(sourceModel.comboId || sourceModel.parentId);\n\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          if (sourceModel.comboId === comboModel.id || sourceModel.parentId === comboModel.id) {\n            break; // if the next ancestor is the combo, break the while\n          }\n\n          sourceModel = source.getModel();\n        }\n\n        sourceId = sourceModel.id;\n\n        if (targetId) {\n          var vedgeId = sourceId + \"-\" + targetId; // update the width of the virtual edges, which is the sum of merged actual edges\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n          if (edgeWeightMap[vedgeId]) {\n            edgeWeightMap[vedgeId] += edge.getModel().size || 1;\n\n            _this.updateItem(addedVEdges[vedgeId], {\n              size: edgeWeightMap[vedgeId]\n            }, false);\n\n            return;\n          }\n\n          var vedge = _this.addItem('vedge', {\n            source: sourceId,\n            target: targetId,\n            isVEdge: true\n          }, false);\n\n          edgeWeightMap[vedgeId] = edge.getModel().size || 1;\n          addedVEdges[vedgeId] = vedge;\n        }\n      } else if (!cnodes.includes(source) && !ccombos.includes(source) && (cnodes.includes(target) || ccombos.includes(target)) || targetId === comboModel.id) {\n        // the target is in the combo, the source is not\n        // ignore the virtual edges\n        if (edge.getModel().isVEdge) {\n          _this.removeItem(edge, false);\n\n          return;\n        }\n\n        var sourceModel = source.getModel(); // find the nearest visible ancestor\n\n        while (!source.isVisible()) {\n          source = _this.findById(sourceModel.comboId || sourceModel.parentId);\n\n          if (!source || !sourceModel.parentId && !sourceModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          sourceModel = source.getModel();\n        }\n\n        sourceId = sourceModel.id;\n        var targetModel = target.getModel(); // find the nearest visible ancestor\n\n        while (!target.isVisible()) {\n          target = _this.findById(targetModel.comboId || targetModel.parentId);\n\n          if (!target || !targetModel.parentId && !targetModel.comboId) {\n            return; // if all the ancestors of the oppsite are all hidden, ignore the edge\n          }\n\n          if (targetModel.comboId === comboModel.id || targetModel.parentId === comboModel.id) {\n            break; // if the next ancestor is the combo, break the while\n          }\n\n          targetModel = target.getModel();\n        }\n\n        targetId = targetModel.id;\n\n        if (sourceId) {\n          var vedgeId = sourceId + \"-\" + targetId; // update the width of the virtual edges, which is the sum of merged actual edges\n          // be attention that the actual edges with same endpoints but different directions will be represented by two different virtual edges\n\n          if (edgeWeightMap[vedgeId]) {\n            edgeWeightMap[vedgeId] += edge.getModel().size || 1;\n\n            _this.updateItem(addedVEdges[vedgeId], {\n              size: edgeWeightMap[vedgeId]\n            }, false);\n\n            return;\n          }\n\n          var vedge = _this.addItem('vedge', {\n            target: targetId,\n            source: sourceId,\n            isVEdge: true\n          }, false);\n\n          edgeWeightMap[vedgeId] = edge.getModel().size || 1;\n          addedVEdges[vedgeId] = vedge;\n        }\n      } else if ((cnodes.includes(source) || ccombos.includes(source)) && (cnodes.includes(target) || ccombos.includes(target))) {\n        // both source and target are in the combo, if the target and source are both visible, show the edge\n        if (source.isVisible() && target.isVisible()) {\n          edge.show();\n        }\n      }\n    });\n    this.emit('aftercollapseexpandcombo', {\n      action: 'expand',\n      item: combo\n    });\n  };\n\n  AbstractGraph.prototype.collapseExpandCombo = function (combo) {\n    if (isString(combo)) {\n      combo = this.findById(combo);\n    }\n\n    if (!combo || combo.getType && combo.getType() !== 'combo') return;\n    var comboModel = combo.getModel(); // if one ancestor combo of the combo is collapsed, it should not be collapsed or expanded\n\n    var parentItem = this.findById(comboModel.parentId);\n\n    while (parentItem) {\n      var parentModel = parentItem.getModel();\n\n      if (parentModel.collapsed) {\n        console.warn(\"Fail to expand the combo since it's ancestor combo is collapsed.\");\n        parentItem = undefined;\n        return;\n      }\n\n      parentItem = this.findById(parentModel.parentId);\n    }\n\n    var collapsed = comboModel.collapsed; // 该群组已经处于收起状态，需要展开\n\n    if (collapsed) {\n      this.expandCombo(combo);\n    } else {\n      this.collapseCombo(combo);\n    }\n\n    this.updateCombo(combo);\n  };\n  /**\n   * 根据 comboTree 结构整理 Combo 相关的图形绘制层级，包括 Combo 本身、节点、边\n   * @param {GraphData} data 数据\n   */\n\n\n  AbstractGraph.prototype.sortCombos = function () {\n    var _this = this;\n\n    var comboSorted = this.get('comboSorted');\n    if (comboSorted) return;\n    this.set('comboSorted', true);\n    var depthMap = [];\n    var dataDepthMap = {};\n    var comboTrees = this.get('comboTrees');\n    (comboTrees || []).forEach(function (cTree) {\n      traverseTree(cTree, function (child) {\n        if (depthMap[child.depth]) depthMap[child.depth].push(child.id);else depthMap[child.depth] = [child.id];\n        dataDepthMap[child.id] = child.depth;\n        return true;\n      });\n    });\n    var edges = this.getEdges().concat(this.get('vedges'));\n    (edges || []).forEach(function (edgeItem) {\n      var edge = edgeItem.getModel();\n      var sourceDepth = dataDepthMap[edge.source] || 0;\n      var targetDepth = dataDepthMap[edge.target] || 0;\n      var depth = Math.max(sourceDepth, targetDepth);\n      if (depthMap[depth]) depthMap[depth].push(edge.id);else depthMap[depth] = [edge.id];\n    });\n    depthMap.forEach(function (array) {\n      if (!array || !array.length) return;\n\n      for (var i = array.length - 1; i >= 0; i--) {\n        var item = _this.findById(array[i]);\n\n        if (item) item.toFront();\n      }\n    });\n  };\n  /**\n   * 获取节点所有的邻居节点\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @returns {INode[]}\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getNeighbors = function (node, type) {\n    var item = node;\n\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n\n    return item.getNeighbors(type);\n  };\n  /**\n   * 获取 node 的度数\n   *\n   * @param {(string | INode)} node 节点 ID 或实例\n   * @param {('in' | 'out' | 'total' | 'all' | undefined)} 度数类型，in 入度，out 出度，total 总度数，all 返回三种类型度数的对象\n   * @returns {Number | Object} 该节点的度数\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getNodeDegree = function (node, type, refresh) {\n    if (type === void 0) {\n      type = undefined;\n    }\n\n    if (refresh === void 0) {\n      refresh = false;\n    }\n\n    var item = node;\n\n    if (isString(node)) {\n      item = this.findById(node);\n    }\n\n    var degrees = this.get('degrees');\n\n    if (!degrees || refresh) {\n      degrees = getDegree(this.save());\n      this.set('degrees', degrees);\n    }\n\n    var nodeDegrees = degrees[item.getID()];\n    var res = 0; // 如果是通过 addItem 后面新增加的节点，此时它的所有度数都为 0\n\n    if (!nodeDegrees) {\n      return 0;\n    }\n\n    switch (type) {\n      case 'in':\n        res = nodeDegrees.inDegree;\n        break;\n\n      case 'out':\n        res = nodeDegrees.outDegree;\n        break;\n\n      case 'all':\n        res = nodeDegrees;\n        break;\n\n      default:\n        res = nodeDegrees.degree;\n        break;\n    }\n\n    return res;\n  };\n\n  AbstractGraph.prototype.getUndoStack = function () {\n    return this.undoStack;\n  };\n\n  AbstractGraph.prototype.getRedoStack = function () {\n    return this.redoStack;\n  };\n  /**\n   * 获取 undo 和 redo 栈的数据\n   */\n\n\n  AbstractGraph.prototype.getStackData = function () {\n    if (!this.get('enabledStack')) {\n      return null;\n    }\n\n    return {\n      undoStack: this.undoStack.toArray(),\n      redoStack: this.redoStack.toArray()\n    };\n  };\n  /**\n   * 清空 undo stack & redo stack\n   */\n\n\n  AbstractGraph.prototype.clearStack = function () {\n    if (this.get('enabledStack')) {\n      this.undoStack.clear();\n      this.redoStack.clear();\n    }\n  };\n  /**\n   * 将操作类型和操作数据入栈\n   * @param action 操作类型\n   * @param data 入栈的数据\n   * @param stackType 栈的类型\n   */\n\n\n  AbstractGraph.prototype.pushStack = function (action, data, stackType) {\n    if (action === void 0) {\n      action = 'update';\n    }\n\n    if (stackType === void 0) {\n      stackType = 'undo';\n    }\n\n    if (!this.get('enabledStack')) {\n      console.warn('请先启用 undo & redo 功能，在实例化 Graph 时候配置 enabledStack: true !');\n      return;\n    }\n\n    var stackData = data ? clone(data) : {\n      before: {},\n      after: clone(this.save())\n    };\n\n    if (stackType === 'redo') {\n      this.redoStack.push({\n        action: action,\n        data: stackData\n      });\n    } else {\n      this.undoStack.push({\n        action: action,\n        data: stackData\n      });\n    }\n\n    this.emit('stackchange', {\n      undoStack: this.undoStack,\n      redoStack: this.redoStack\n    });\n  };\n  /**\n   * 获取邻接矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 邻接矩阵\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getAdjMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n\n    return currentAdjMatrix;\n  };\n  /**\n   * 获取最短路径矩阵\n   *\n   * @param {boolean} cache 是否使用缓存的\n   * @param {boolean} directed 是否是有向图，默认取 graph.directed\n   * @returns {Matrix} 最短路径矩阵\n   * @memberof IAbstractGraph\n   */\n\n\n  AbstractGraph.prototype.getShortestPathMatrix = function (cache, directed) {\n    if (cache === void 0) {\n      cache = true;\n    }\n\n    if (directed === undefined) directed = this.get('directed');\n    var currentAdjMatrix = this.get('adjMatrix');\n    var currentShourtestPathMatrix = this.get('shortestPathMatrix');\n\n    if (!currentAdjMatrix || !cache) {\n      currentAdjMatrix = getAdjacentMatrix(this.save(), directed);\n      this.set('adjMatrix', currentAdjMatrix);\n    }\n\n    if (!currentShourtestPathMatrix || !cache) {\n      currentShourtestPathMatrix = floydWarshall(this.save(), directed);\n      this.set('shortestPathMatrix', currentShourtestPathMatrix);\n    }\n\n    return currentShourtestPathMatrix;\n  };\n  /**\n   * 重新定义监听函数，复写参数类型\n   */\n\n\n  AbstractGraph.prototype.on = function (eventName, callback, once) {\n    return _super.prototype.on.call(this, eventName, callback, once);\n  };\n  /**\n   * 销毁画布\n   */\n\n\n  AbstractGraph.prototype.destroy = function () {\n    this.clear(); // 清空栈数据\n\n    this.clearStack();\n    this.get('itemController').destroy();\n    this.get('modeController').destroy();\n    this.get('viewController').destroy();\n    this.get('stateController').destroy();\n    this.get('canvas').destroy();\n    this.cfg = null;\n    this.destroyed = true;\n    this.redoStack = null;\n    this.undoStack = null;\n  };\n  /**\n   * 创建凸包或凹包轮廓\n   * @param cfg HullCfg 轮廓配置项\n   */\n\n\n  AbstractGraph.prototype.createHull = function (cfg) {\n    if (!cfg.members || cfg.members.length < 1) {\n      console.warn('Create hull failed! The members is empty.');\n      return;\n    }\n\n    var parent = this.get('hullGroup');\n    var hullMap = this.get('hullMap');\n\n    if (!hullMap) {\n      hullMap = {};\n      this.set('hullMap', hullMap);\n    }\n\n    if (!parent || parent.get('destroyed')) {\n      parent = this.get('group').addGroup({\n        id: 'hullGroup'\n      });\n      parent.toBack();\n      this.set('hullGroup', parent);\n    }\n\n    if (hullMap[cfg.id]) {\n      console.warn('Existed hull id.');\n      return hullMap[cfg.id];\n    }\n\n    var group = parent.addGroup({\n      id: cfg.id + \"-container\"\n    });\n    var hull = new Hull(this, __assign(__assign({}, cfg), {\n      group: group\n    }));\n    var hullId = hull.id;\n    hullMap[hullId] = hull;\n    return hull;\n  };\n  /**\n   * 获取当前 graph 中存在的包裹轮廓\n   * @return {[key: string]: Hull} Hull 的 map，hullId 对应的 hull 实例\n   */\n\n\n  AbstractGraph.prototype.getHulls = function () {\n    return this.get('hullMap');\n  };\n  /**\n   * 根据 hullId 获取对应的 hull\n   * @return Hull\n   */\n\n\n  AbstractGraph.prototype.getHullById = function (hullId) {\n    return this.get('hullMap')[hullId];\n  };\n\n  AbstractGraph.prototype.removeHull = function (hull) {\n    var _a;\n\n    var hullInstance;\n\n    if (isString(hull)) {\n      hullInstance = this.getHullById(hull);\n    } else {\n      hullInstance = hull;\n    }\n\n    (_a = this.get('hullMap')) === null || _a === void 0 ? true : delete _a[hullInstance.id];\n    hullInstance.destroy();\n  };\n\n  AbstractGraph.prototype.removeHulls = function () {\n    var hulls = this.getHulls();\n    if (!hulls || !Object.keys(hulls).length) return;\n    Object.keys(hulls).forEach(function (key) {\n      var hull = hulls[key];\n      hull.destroy();\n    });\n    this.set('hullMap', {});\n  };\n\n  return AbstractGraph;\n}(EventEmitter);\n\nexport default AbstractGraph;"]},"metadata":{},"sourceType":"module"}