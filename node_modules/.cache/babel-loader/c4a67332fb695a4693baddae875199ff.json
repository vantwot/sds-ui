{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { Bounds, GeoCoordinates, Point, toLngLat } from '@antv/geo-coord';\nimport { createLayerContainer } from '@antv/l7-core';\nimport ImageTile from './ImageTile';\nimport TileCache from './tileCache';\nvar CacheLimit = 30;\n\nvar Tile = function () {\n  function Tile(props) {\n    _classCallCheck(this, Tile);\n\n    _defineProperty(this, \"tileList\", {});\n\n    _defineProperty(this, \"tileCache\", void 0);\n\n    _defineProperty(this, \"updateTileList\", void 0);\n\n    _defineProperty(this, \"tileZoom\", void 0);\n\n    _defineProperty(this, \"noPruneRange\", void 0);\n\n    _defineProperty(this, \"url\", void 0);\n\n    _defineProperty(this, \"resolution\", void 0);\n\n    _defineProperty(this, \"maxSourceZoom\", void 0);\n\n    _defineProperty(this, \"crstype\", void 0);\n\n    _defineProperty(this, \"currentCrs\", void 0);\n\n    _defineProperty(this, \"layerService\", void 0);\n\n    _defineProperty(this, \"layer\", void 0);\n\n    this.layerService = props.layerService;\n    this.layer = props.layer;\n    this.url = props.url;\n    this.resolution = props.resolution === 'low' ? -1 : 0;\n    this.maxSourceZoom = props.maxSourceZoom;\n    this.crstype = props.crstype;\n    this.currentCrs = new GeoCoordinates.default({\n      start: {\n        x: 0,\n        y: 0\n      },\n      end: {\n        x: 0,\n        y: 0\n      },\n      projection: this.crstype\n    }).crs;\n    this.destroyTile = this.destroyTile.bind(this);\n    this.tileCache = new TileCache(CacheLimit, this.destroyTile);\n    this.updateTileList = [];\n    this.removeTiles = this.removeTiles.bind(this);\n  }\n\n  _createClass(Tile, [{\n    key: \"calCurrentTiles\",\n    value: function calCurrentTiles(oprions) {\n      var _this = this;\n\n      var NE = oprions.NE,\n          SW = oprions.SW,\n          tileCenter = oprions.tileCenter,\n          currentZoom = oprions.currentZoom,\n          minSourceZoom = oprions.minSourceZoom,\n          minZoom = oprions.minZoom,\n          maxZoom = oprions.maxZoom;\n\n      if (currentZoom >= this.maxSourceZoom) {\n        return;\n      }\n\n      var zoom = Math.floor(currentZoom) + this.resolution;\n      this.tileZoom = zoom > this.maxSourceZoom ? this.maxSourceZoom : zoom;\n\n      if (currentZoom < minZoom || currentZoom >= maxZoom || currentZoom < minSourceZoom) {\n        this.removeTiles();\n        return;\n      }\n\n      this.updateTileList = [];\n      var centerPoint = this.currentCrs.lngLatToPoint(toLngLat(tileCenter.lng, tileCenter.lat), this.tileZoom);\n      var centerXY = centerPoint.divideBy(256).floor();\n      var pixelBounds = this.getPixelBounds(NE, SW, tileCenter, this.tileZoom, this.currentCrs);\n      var tileRange = this.pxBoundsToTileRange(pixelBounds);\n      var margin = 4;\n      this.noPruneRange = new Bounds(tileRange.getBottomLeft().subtract([margin, -margin]), tileRange.getTopRight().add([margin, -margin]));\n\n      if (!(isFinite(tileRange.min.x) && isFinite(tileRange.min.y) && isFinite(tileRange.max.x) && isFinite(tileRange.max.y))) {\n        throw new Error('Attempted to load an infinite number of tiles');\n      }\n\n      for (var j = tileRange.min.y; j <= tileRange.max.y; j++) {\n        for (var i = tileRange.min.x; i <= tileRange.max.x; i++) {\n          var coords = [i, j, this.tileZoom];\n          var tile = this.tileList[coords.join('_')];\n\n          if (tile) {\n            tile.current = true;\n          } else {\n            this.tileList[coords.join('_')] = {\n              current: true,\n              coords: coords\n            };\n            this.updateTileList.push(coords);\n          }\n        }\n      }\n\n      this.updateTileList.sort(function (a, b) {\n        var tile1 = a;\n        var tile2 = b;\n        var d1 = Math.pow(tile1[0] * 1 - centerXY.x, 2) + Math.pow(tile1[1] * 1 - centerXY.y, 2);\n        var d2 = Math.pow(tile2[0] * 1 - centerXY.x, 2) + Math.pow(tile2[1] * 1 - centerXY.y, 2);\n        return d1 - d2;\n      });\n      this.pruneTiles();\n      this.updateTileList.forEach(function (coords) {\n        var key = coords.join('_');\n\n        if (_this.tileList[key].current) {\n          _this.requestTile(key);\n        }\n      });\n    }\n  }, {\n    key: \"pxBoundsToTileRange\",\n    value: function pxBoundsToTileRange(pixelBounds) {\n      return new Bounds(pixelBounds.min.divideBy(256).floor(), pixelBounds.max.divideBy(256).ceil().subtract([1, 1]));\n    }\n  }, {\n    key: \"getPixelBounds\",\n    value: function getPixelBounds(NE, SW, tileCenter, tileZoom, crs) {\n      var zoom = tileZoom;\n      var NEPoint = crs.lngLatToPoint(toLngLat(NE.lng, NE.lat), zoom);\n      var SWPoint = crs.lngLatToPoint(toLngLat(SW.lng, SW.lat), zoom);\n      var centerPoint = crs.lngLatToPoint(toLngLat(tileCenter.lng, tileCenter.lat), zoom);\n      var topHeight = centerPoint.y - NEPoint.y;\n      var bottomHeight = SWPoint.y - centerPoint.y;\n      var leftWidth;\n      var rightWidth;\n\n      if (tileCenter.lng - NE.lng > 0 || tileCenter.lng - SW.lng < 0) {\n        var width = Math.pow(2, zoom) * 256 / 360 * (180 - NE.lng) + Math.pow(2, zoom) * 256 / 360 * (SW.lng + 180);\n\n        if (tileCenter.lng - NE.lng > 0) {\n          leftWidth = Math.pow(2, zoom) * 256 / 360 * (tileCenter.lng - NE.lng);\n          rightWidth = width - leftWidth;\n        } else {\n          rightWidth = Math.pow(2, zoom) * 256 / 360 * (SW.lng - tileCenter.lng);\n          leftWidth = width - rightWidth;\n        }\n      } else {\n        leftWidth = Math.pow(2, zoom) * 256 / 360 * (tileCenter.lng - SW.lng);\n        rightWidth = Math.pow(2, zoom) * 256 / 360 * (NE.lng - tileCenter.lng);\n      }\n\n      var pixelBounds = new Bounds(centerPoint.subtract(leftWidth, topHeight), centerPoint.add(rightWidth, bottomHeight));\n      return pixelBounds;\n    }\n  }, {\n    key: \"pruneTiles\",\n    value: function pruneTiles() {\n      var _this2 = this;\n\n      Object.keys(this.tileList).map(function (key) {\n        var c = _this2.tileList[key].coords;\n\n        if (c[2] !== _this2.tileZoom || !_this2.noPruneRange.contains(new Point(c[0], c[1]))) {\n          _this2.tileList[key].current = false;\n        }\n      });\n      Object.keys(this.tileList).map(function (key) {\n        var tile = _this2.tileList[key];\n        tile.retain = tile.current;\n      });\n      Object.keys(this.tileList).map(function (key) {\n        var tile = _this2.tileList[key];\n\n        if (tile.current && !tile.active) {\n          var _key$split$map = key.split('_').map(function (v) {\n            return Number(v);\n          }),\n              _key$split$map2 = _slicedToArray(_key$split$map, 3),\n              x = _key$split$map2[0],\n              y = _key$split$map2[1],\n              z = _key$split$map2[2];\n\n          if (!_this2.retainParent(x, y, z, z - 5)) {\n            _this2.retainChildren(x, y, z, z + 2);\n          }\n        }\n      });\n      this.removeOutTiles();\n    }\n  }, {\n    key: \"requestTile\",\n    value: function requestTile(key) {\n      var t = this.tileList[key];\n\n      if (!t) {\n        return;\n      }\n\n      var tile = this.tileCache.getTile(key);\n\n      if (!tile) {\n        var container = createLayerContainer(this.layer.sceneContainer);\n        tile = new ImageTile(key, this.url, container, this.layer.sceneContainer);\n        tile.name = key;\n        t.current = true;\n        t.retain = true;\n        t.active = true;\n        this.layer.layerChildren.push(tile.imageLayer);\n        this.tileCache.setTile(tile, key);\n        this.pruneTiles();\n        this.layerService.updateLayerRenderList();\n        this.layerService.renderLayers();\n      } else {\n        tile.imageLayer.show();\n        t.current = true;\n        t.retain = true;\n        t.active = true;\n        this.pruneTiles();\n      }\n    }\n  }, {\n    key: \"retainParent\",\n    value: function retainParent(x, y, z, minZoom) {\n      var x2 = Math.floor(x / 2);\n      var y2 = Math.floor(y / 2);\n      var z2 = z - 1;\n      var tile = this.tileList[[x2, y2, z2].join('_')];\n\n      if (tile && tile.active) {\n        tile.retain = true;\n        return true;\n      } else if (tile && tile.loaded) {\n        tile.retain = true;\n      }\n\n      if (z2 > minZoom) {\n        return this.retainParent(x2, y2, z2, minZoom);\n      }\n\n      return false;\n    }\n  }, {\n    key: \"retainChildren\",\n    value: function retainChildren(x, y, z, maxZoom) {\n      for (var i = 2 * x; i < 2 * x + 2; i++) {\n        for (var j = 2 * y; j < 2 * y + 2; j++) {\n          var key = [i, j, z + 1].join('_');\n          var tile = this.tileList[key];\n\n          if (tile && tile.active) {\n            tile.retain = true;\n            continue;\n          } else if (tile && tile.loaded) {\n            tile.retain = true;\n          }\n\n          if (z + 1 < maxZoom) {\n            this.retainChildren(i, j, z + 1, maxZoom);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"destroyTile\",\n    value: function destroyTile(tile) {\n      var layerIndex = this.layer.layerChildren.indexOf(tile.imageLayer);\n\n      if (layerIndex > -1) {\n        this.layer.layerChildren.splice(layerIndex, 1);\n      }\n\n      tile.imageLayer.destroy();\n      this.layerService.updateLayerRenderList();\n      this.layerService.renderLayers();\n      tile = null;\n    }\n  }, {\n    key: \"removeOutTiles\",\n    value: function removeOutTiles() {\n      for (var key in this.tileList) {\n        if (!this.tileList[key].retain) {\n          var tile = this.tileCache.getTile(key);\n\n          if (tile) {\n            tile.imageLayer.hide();\n          }\n\n          delete this.tileList[key];\n        }\n      }\n    }\n  }, {\n    key: \"removeTiles\",\n    value: function removeTiles() {\n      this.layer.layerChildren.forEach(function (layer) {\n        layer.destroy();\n      });\n      this.layer.layerChildren = [];\n      this.layerService.updateLayerRenderList();\n      this.layerService.renderLayers();\n      this.tileList = {};\n      this.tileCache.destory();\n    }\n  }]);\n\n  return Tile;\n}();\n\nexport { Tile as default };","map":{"version":3,"sources":["../../../src/imagetile/utils/Tile.ts"],"names":["CacheLimit","Tile","props","GeoCoordinates","start","x","y","end","projection","crstype","NE","SW","tileCenter","currentZoom","minSourceZoom","minZoom","maxZoom","oprions","zoom","Math","centerPoint","toLngLat","centerXY","pixelBounds","tileRange","margin","isFinite","j","i","coords","tile","current","tile1","tile2","d1","d2","key","NEPoint","crs","SWPoint","topHeight","bottomHeight","width","leftWidth","rightWidth","Object","c","z","Number","t","container","createLayerContainer","x2","y2","z2","layerIndex","layer"],"mappings":"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","sourcesContent":["import { Bounds, GeoCoordinates, Point, toLngLat } from '@antv/geo-coord';\nimport {\n  createLayerContainer,\n  ILayer,\n  ILayerService,\n  ILngLat,\n} from '@antv/l7-core';\nimport { Container } from 'inversify';\n\nimport ImageTile from './ImageTile';\nimport TileCache from './tileCache';\n\n// Tip: 瓦片地图的存储上限\nconst CacheLimit = 30;\n\nexport default class Tile {\n  public tileList: any = {};\n  public tileCache: any;\n\n  public updateTileList: any[];\n  public tileZoom: number;\n  public noPruneRange: any;\n  public url: string;\n  public resolution: number;\n  public maxSourceZoom: number;\n  public crstype: string;\n  public currentCrs: any;\n\n  public layerService: ILayerService;\n  public layer: ILayer;\n  constructor(props: any) {\n    this.layerService = props.layerService;\n    this.layer = props.layer;\n    this.url = props.url;\n    this.resolution = props.resolution === 'low' ? -1 : 0;\n    this.maxSourceZoom = props.maxSourceZoom;\n    this.crstype = props.crstype;\n\n    this.currentCrs = new GeoCoordinates.default({\n      start: { x: 0, y: 0 },\n      end: { x: 0, y: 0 },\n      projection: this.crstype,\n    }).crs as any;\n\n    this.destroyTile = this.destroyTile.bind(this);\n    this.tileCache = new TileCache(CacheLimit, this.destroyTile);\n\n    this.updateTileList = [];\n\n    this.removeTiles = this.removeTiles.bind(this);\n  }\n\n  public calCurrentTiles(oprions: any) {\n    const {\n      NE,\n      SW,\n      tileCenter,\n      currentZoom,\n      minSourceZoom,\n      minZoom,\n      maxZoom,\n    } = oprions;\n    // TODO: 当前瓦片的层级要比地图底图的层级低\n    if (currentZoom >= this.maxSourceZoom) {\n      return;\n    }\n    const zoom = Math.floor(currentZoom) + this.resolution;\n\n    this.tileZoom = zoom > this.maxSourceZoom ? this.maxSourceZoom : zoom;\n\n    if (\n      currentZoom < minZoom ||\n      currentZoom >= maxZoom ||\n      currentZoom < minSourceZoom\n    ) {\n      this.removeTiles();\n      return;\n    }\n\n    this.updateTileList = [];\n\n    // 计算瓦片中心\n    const centerPoint = this.currentCrs.lngLatToPoint(\n      toLngLat(tileCenter.lng, tileCenter.lat),\n      this.tileZoom,\n    );\n    const centerXY = centerPoint.divideBy(256).floor();\n\n    const pixelBounds = this.getPixelBounds(\n      NE,\n      SW,\n      tileCenter,\n      this.tileZoom,\n      this.currentCrs,\n    ); // 计算像素范围\n    const tileRange = this.pxBoundsToTileRange(pixelBounds); // 计算瓦片范围\n\n    const margin = 4;\n\n    this.noPruneRange = new Bounds(\n      tileRange.getBottomLeft().subtract([margin, -margin]),\n      tileRange.getTopRight().add([margin, -margin]),\n    );\n\n    // T: isFinite(n: number) 用于检测 n 是否无穷大\n    if (\n      !(\n        isFinite(tileRange.min.x) &&\n        isFinite(tileRange.min.y) &&\n        isFinite(tileRange.max.x) &&\n        isFinite(tileRange.max.y)\n      )\n    ) {\n      throw new Error('Attempted to load an infinite number of tiles');\n    }\n\n    // 根据视野判断新增的瓦片索引\n    for (let j = tileRange.min.y; j <= tileRange.max.y; j++) {\n      for (let i = tileRange.min.x; i <= tileRange.max.x; i++) {\n        const coords = [i, j, this.tileZoom];\n        const tile = this.tileList[coords.join('_')];\n        if (tile) {\n          tile.current = true;\n        } else {\n          this.tileList[coords.join('_')] = {\n            current: true,\n            coords,\n          };\n          this.updateTileList.push(coords);\n        }\n      }\n    }\n\n    // 瓦片列表排序\n    this.updateTileList.sort((a: any, b: any) => {\n      const tile1 = a;\n      const tile2 = b;\n      const d1 =\n        Math.pow(tile1[0] * 1 - centerXY.x, 2) +\n        Math.pow(tile1[1] * 1 - centerXY.y, 2);\n      const d2 =\n        Math.pow(tile2[0] * 1 - centerXY.x, 2) +\n        Math.pow(tile2[1] * 1 - centerXY.y, 2);\n      return d1 - d2;\n    });\n\n    this.pruneTiles();\n    this.updateTileList.forEach((coords: any) => {\n      const key = coords.join('_');\n      if (this.tileList[key].current) {\n        this.requestTile(key);\n      }\n    });\n  }\n\n  public pxBoundsToTileRange(pixelBounds: any) {\n    return new Bounds(\n      pixelBounds.min.divideBy(256).floor(),\n      pixelBounds.max\n        .divideBy(256)\n        .ceil()\n        .subtract([1, 1]),\n    );\n  }\n\n  public getPixelBounds(\n    NE: ILngLat,\n    SW: ILngLat,\n    tileCenter: ILngLat,\n    tileZoom: number,\n    crs: any,\n  ) {\n    const zoom = tileZoom;\n    const NEPoint = crs.lngLatToPoint(toLngLat(NE.lng, NE.lat), zoom);\n    const SWPoint = crs.lngLatToPoint(toLngLat(SW.lng, SW.lat), zoom);\n    const centerPoint = crs.lngLatToPoint(\n      toLngLat(tileCenter.lng, tileCenter.lat),\n      zoom,\n    );\n    const topHeight = centerPoint.y - NEPoint.y;\n    const bottomHeight = SWPoint.y - centerPoint.y;\n    // 跨日界线的情况\n    let leftWidth;\n    let rightWidth;\n    if (tileCenter.lng - NE.lng > 0 || tileCenter.lng - SW.lng < 0) {\n      const width =\n        ((Math.pow(2, zoom) * 256) / 360) * (180 - NE.lng) +\n        ((Math.pow(2, zoom) * 256) / 360) * (SW.lng + 180);\n      if (tileCenter.lng - NE.lng > 0) {\n        // 日界线在右侧\n        leftWidth =\n          ((Math.pow(2, zoom) * 256) / 360) * (tileCenter.lng - NE.lng);\n        rightWidth = width - leftWidth;\n      } else {\n        rightWidth =\n          ((Math.pow(2, zoom) * 256) / 360) * (SW.lng - tileCenter.lng);\n        leftWidth = width - rightWidth;\n      }\n    } else {\n      // 不跨日界线\n      leftWidth = ((Math.pow(2, zoom) * 256) / 360) * (tileCenter.lng - SW.lng);\n      rightWidth =\n        ((Math.pow(2, zoom) * 256) / 360) * (NE.lng - tileCenter.lng);\n    }\n    const pixelBounds = new Bounds(\n      centerPoint.subtract(leftWidth, topHeight),\n      centerPoint.add(rightWidth, bottomHeight),\n    );\n    return pixelBounds;\n  }\n\n  public pruneTiles() {\n    Object.keys(this.tileList).map((key) => {\n      const c = this.tileList[key].coords;\n      // 如果不是同一个缩放层级，则将瓦片设为不显示\n      if (\n        c[2] !== this.tileZoom ||\n        !this.noPruneRange.contains(new Point(c[0], c[1]))\n      ) {\n        this.tileList[key].current = false;\n      }\n    });\n\n    Object.keys(this.tileList).map((key) => {\n      const tile = this.tileList[key];\n      tile.retain = tile.current;\n    });\n\n    Object.keys(this.tileList).map((key) => {\n      const tile = this.tileList[key];\n      if (tile.current && !tile.active) {\n        const [x, y, z] = key.split('_').map((v) => Number(v));\n\n        if (!this.retainParent(x, y, z, z - 5)) {\n          this.retainChildren(x, y, z, z + 2);\n        }\n      }\n    });\n\n    this.removeOutTiles();\n  }\n\n  public requestTile(key: string) {\n    const t = this.tileList[key];\n    if (!t) {\n      return;\n    }\n    let tile = this.tileCache.getTile(key);\n    if (!tile) {\n      const container = createLayerContainer(\n        this.layer.sceneContainer as Container,\n      );\n      tile = new ImageTile(\n        key,\n        this.url,\n        container,\n        this.layer.sceneContainer as Container,\n      );\n      tile.name = key;\n\n      t.current = true;\n      t.retain = true;\n      t.active = true;\n\n      // 往 imageTileLayer 中添加子图层\n      this.layer.layerChildren.push(tile.imageLayer);\n\n      this.tileCache.setTile(tile, key);\n\n      this.pruneTiles();\n      this.layerService.updateLayerRenderList();\n      this.layerService.renderLayers();\n    } else {\n      // Tip: show 方法就是将相应的瓦片图片添加到渲染队列\n      tile.imageLayer.show();\n      t.current = true;\n      t.retain = true;\n      t.active = true;\n\n      this.pruneTiles();\n    }\n  }\n\n  public retainParent(x: number, y: number, z: number, minZoom: number): any {\n    const x2 = Math.floor(x / 2);\n    const y2 = Math.floor(y / 2);\n    const z2 = z - 1;\n    const tile = this.tileList[[x2, y2, z2].join('_')];\n    if (tile && tile.active) {\n      tile.retain = true;\n      return true;\n    } else if (tile && tile.loaded) {\n      tile.retain = true;\n    }\n    if (z2 > minZoom) {\n      return this.retainParent(x2, y2, z2, minZoom);\n    }\n    return false;\n  }\n\n  public retainChildren(x: number, y: number, z: number, maxZoom: number) {\n    for (let i = 2 * x; i < 2 * x + 2; i++) {\n      for (let j = 2 * y; j < 2 * y + 2; j++) {\n        const key = [i, j, z + 1].join('_');\n        const tile = this.tileList[key];\n        if (tile && tile.active) {\n          tile.retain = true;\n          continue;\n        } else if (tile && tile.loaded) {\n          tile.retain = true;\n        }\n\n        if (z + 1 < maxZoom) {\n          this.retainChildren(i, j, z + 1, maxZoom);\n        }\n      }\n    }\n  }\n\n  public destroyTile(tile: any) {\n    const layerIndex = this.layer.layerChildren.indexOf(tile.imageLayer);\n    if (layerIndex > -1) {\n      this.layer.layerChildren.splice(layerIndex, 1);\n    }\n\n    tile.imageLayer.destroy();\n    this.layerService.updateLayerRenderList();\n    this.layerService.renderLayers();\n\n    // 清除 tileCache 中的存储 相当于 tileCache.setTile(tile, null)\n    tile = null;\n  }\n\n  public removeOutTiles() {\n    for (const key in this.tileList) {\n      if (!this.tileList[key].retain) {\n        // Tip: 不需要显示的瓦片对象\n        const tile = this.tileCache.getTile(key);\n        // Tip: 若是网格对象存在\n        if (tile) {\n          // Tip: hide 方法就是将相应的瓦片图片从渲染队列中剔除\n          tile.imageLayer.hide();\n        }\n        delete this.tileList[key];\n      }\n    }\n  }\n\n  public removeTiles() {\n    this.layer.layerChildren.forEach((layer: any) => {\n      layer.destroy();\n    });\n\n    this.layer.layerChildren = [];\n    this.layerService.updateLayerRenderList();\n    this.layerService.renderLayers();\n    this.tileList = {};\n    this.tileCache.destory();\n  }\n}\n"]},"metadata":{},"sourceType":"module"}