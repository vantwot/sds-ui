{"ast":null,"code":"import { Curve } from '../curve';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport class CurveTo extends Segment {\n  constructor(arg0, arg1, arg2, arg3, arg4, arg5) {\n    super();\n\n    if (Curve.isCurve(arg0)) {\n      this.controlPoint1 = arg0.controlPoint1.clone().round(2);\n      this.controlPoint2 = arg0.controlPoint2.clone().round(2);\n      this.endPoint = arg0.end.clone().round(2);\n    } else if (typeof arg0 === 'number') {\n      this.controlPoint1 = new Point(arg0, arg1).round(2);\n      this.controlPoint2 = new Point(arg2, arg3).round(2);\n      this.endPoint = new Point(arg4, arg5).round(2);\n    } else {\n      this.controlPoint1 = Point.create(arg0).round(2);\n      this.controlPoint2 = Point.create(arg1).round(2);\n      this.endPoint = Point.create(arg2).round(2);\n    }\n  }\n\n  get type() {\n    return 'C';\n  }\n\n  get curve() {\n    return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n  }\n\n  bbox() {\n    return this.curve.bbox();\n  }\n\n  closestPoint(p) {\n    return this.curve.closestPoint(p);\n  }\n\n  closestPointLength(p) {\n    return this.curve.closestPointLength(p);\n  }\n\n  closestPointNormalizedLength(p) {\n    return this.curve.closestPointNormalizedLength(p);\n  }\n\n  closestPointTangent(p) {\n    return this.curve.closestPointTangent(p);\n  }\n\n  length() {\n    return this.curve.length();\n  }\n\n  divideAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // TODO: fix options\n    const divided = this.curve.divideAt(ratio, options);\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n  }\n\n  divideAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // TODO: fix options\n    const divided = this.curve.divideAtLength(length, options);\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n  }\n\n  divideAtT(t) {\n    const divided = this.curve.divideAtT(t);\n    return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n  }\n\n  getSubdivisions() {\n    return [];\n  }\n\n  pointAt(ratio) {\n    return this.curve.pointAt(ratio);\n  }\n\n  pointAtLength(length) {\n    return this.curve.pointAtLength(length);\n  }\n\n  tangentAt(ratio) {\n    return this.curve.tangentAt(ratio);\n  }\n\n  tangentAtLength(length) {\n    return this.curve.tangentAtLength(length);\n  }\n\n  isDifferentiable() {\n    if (!this.previousSegment) {\n      return false;\n    }\n\n    const start = this.start;\n    const control1 = this.controlPoint1;\n    const control2 = this.controlPoint2;\n    const end = this.end;\n    return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n  }\n\n  scale(sx, sy, origin) {\n    this.controlPoint1.scale(sx, sy, origin);\n    this.controlPoint2.scale(sx, sy, origin);\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.controlPoint1.rotate(angle, origin);\n    this.controlPoint2.rotate(angle, origin);\n    this.end.rotate(angle, origin);\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.controlPoint1.translate(tx, ty);\n      this.controlPoint2.translate(tx, ty);\n      this.end.translate(tx, ty);\n    } else {\n      this.controlPoint1.translate(tx);\n      this.controlPoint2.translate(tx);\n      this.end.translate(tx);\n    }\n\n    return this;\n  }\n\n  equals(s) {\n    return this.start.equals(s.start) && this.end.equals(s.end) && this.controlPoint1.equals(s.controlPoint1) && this.controlPoint2.equals(s.controlPoint2);\n  }\n\n  clone() {\n    return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      start: this.start.toJSON(),\n      controlPoint1: this.controlPoint1.toJSON(),\n      controlPoint2: this.controlPoint2.toJSON(),\n      end: this.end.toJSON()\n    };\n  }\n\n  serialize() {\n    const c1 = this.controlPoint1;\n    const c2 = this.controlPoint2;\n    const end = this.end;\n    return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');\n  }\n\n}\n\n(function (CurveTo) {\n  function create() {\n    const len = arguments.length;\n    const arg0 = arguments.length <= 0 ? undefined : arguments[0]; // curve provided\n\n    if (Curve.isCurve(arg0)) {\n      return new CurveTo(arg0);\n    } // points provided\n\n\n    if (Point.isPointLike(arg0)) {\n      if (len === 3) {\n        return new CurveTo(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      } // this is a poly-bezier segment\n\n\n      const segments = [];\n\n      for (let i = 0; i < len; i += 3) {\n        segments.push(new CurveTo(i < 0 || arguments.length <= i ? undefined : arguments[i], i + 1 < 0 || arguments.length <= i + 1 ? undefined : arguments[i + 1], i + 2 < 0 || arguments.length <= i + 2 ? undefined : arguments[i + 2]));\n      }\n\n      return segments;\n    } // coordinates provided\n\n\n    if (len === 6) {\n      return new CurveTo(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2], arguments.length <= 3 ? undefined : arguments[3], arguments.length <= 4 ? undefined : arguments[4], arguments.length <= 5 ? undefined : arguments[5]);\n    } // this is a poly-bezier segment\n\n\n    const segments = [];\n\n    for (let i = 0; i < len; i += 6) {\n      segments.push(new CurveTo(i < 0 || arguments.length <= i ? undefined : arguments[i], i + 1 < 0 || arguments.length <= i + 1 ? undefined : arguments[i + 1], i + 2 < 0 || arguments.length <= i + 2 ? undefined : arguments[i + 2], i + 3 < 0 || arguments.length <= i + 3 ? undefined : arguments[i + 3], i + 4 < 0 || arguments.length <= i + 4 ? undefined : arguments[i + 4], i + 5 < 0 || arguments.length <= i + 5 ? undefined : arguments[i + 5]));\n    }\n\n    return segments;\n  }\n\n  CurveTo.create = create;\n})(CurveTo || (CurveTo = {}));","map":{"version":3,"sources":["../../../src/geometry/path/curveto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Curve } from '../curve';\nimport { Point } from '../point';\nimport { Segment } from './segment';\nexport class CurveTo extends Segment {\n    constructor(arg0, arg1, arg2, arg3, arg4, arg5) {\n        super();\n        if (Curve.isCurve(arg0)) {\n            this.controlPoint1 = arg0.controlPoint1.clone().round(2);\n            this.controlPoint2 = arg0.controlPoint2.clone().round(2);\n            this.endPoint = arg0.end.clone().round(2);\n        }\n        else if (typeof arg0 === 'number') {\n            this.controlPoint1 = new Point(arg0, arg1).round(2);\n            this.controlPoint2 = new Point(arg2, arg3).round(2);\n            this.endPoint = new Point(arg4, arg5).round(2);\n        }\n        else {\n            this.controlPoint1 = Point.create(arg0).round(2);\n            this.controlPoint2 = Point.create(arg1).round(2);\n            this.endPoint = Point.create(arg2).round(2);\n        }\n    }\n    get type() {\n        return 'C';\n    }\n    get curve() {\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    }\n    bbox() {\n        return this.curve.bbox();\n    }\n    closestPoint(p) {\n        return this.curve.closestPoint(p);\n    }\n    closestPointLength(p) {\n        return this.curve.closestPointLength(p);\n    }\n    closestPointNormalizedLength(p) {\n        return this.curve.closestPointNormalizedLength(p);\n    }\n    closestPointTangent(p) {\n        return this.curve.closestPointTangent(p);\n    }\n    length() {\n        return this.curve.length();\n    }\n    divideAt(ratio, options = {}) {\n        // TODO: fix options\n        const divided = this.curve.divideAt(ratio, options);\n        return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n    }\n    divideAtLength(length, options = {}) {\n        // TODO: fix options\n        const divided = this.curve.divideAtLength(length, options);\n        return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n    }\n    divideAtT(t) {\n        const divided = this.curve.divideAtT(t);\n        return [new CurveTo(divided[0]), new CurveTo(divided[1])];\n    }\n    getSubdivisions() {\n        return [];\n    }\n    pointAt(ratio) {\n        return this.curve.pointAt(ratio);\n    }\n    pointAtLength(length) {\n        return this.curve.pointAtLength(length);\n    }\n    tangentAt(ratio) {\n        return this.curve.tangentAt(ratio);\n    }\n    tangentAtLength(length) {\n        return this.curve.tangentAtLength(length);\n    }\n    isDifferentiable() {\n        if (!this.previousSegment) {\n            return false;\n        }\n        const start = this.start;\n        const control1 = this.controlPoint1;\n        const control2 = this.controlPoint2;\n        const end = this.end;\n        return !(start.equals(control1) &&\n            control1.equals(control2) &&\n            control2.equals(end));\n    }\n    scale(sx, sy, origin) {\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    }\n    rotate(angle, origin) {\n        this.controlPoint1.rotate(angle, origin);\n        this.controlPoint2.rotate(angle, origin);\n        this.end.rotate(angle, origin);\n        return this;\n    }\n    translate(tx, ty) {\n        if (typeof tx === 'number') {\n            this.controlPoint1.translate(tx, ty);\n            this.controlPoint2.translate(tx, ty);\n            this.end.translate(tx, ty);\n        }\n        else {\n            this.controlPoint1.translate(tx);\n            this.controlPoint2.translate(tx);\n            this.end.translate(tx);\n        }\n        return this;\n    }\n    equals(s) {\n        return (this.start.equals(s.start) &&\n            this.end.equals(s.end) &&\n            this.controlPoint1.equals(s.controlPoint1) &&\n            this.controlPoint2.equals(s.controlPoint2));\n    }\n    clone() {\n        return new CurveTo(this.controlPoint1, this.controlPoint2, this.end);\n    }\n    toJSON() {\n        return {\n            type: this.type,\n            start: this.start.toJSON(),\n            controlPoint1: this.controlPoint1.toJSON(),\n            controlPoint2: this.controlPoint2.toJSON(),\n            end: this.end.toJSON(),\n        };\n    }\n    serialize() {\n        const c1 = this.controlPoint1;\n        const c2 = this.controlPoint2;\n        const end = this.end;\n        return [this.type, c1.x, c1.y, c2.x, c2.y, end.x, end.y].join(' ');\n    }\n}\n(function (CurveTo) {\n    function create(...args) {\n        const len = args.length;\n        const arg0 = args[0];\n        // curve provided\n        if (Curve.isCurve(arg0)) {\n            return new CurveTo(arg0);\n        }\n        // points provided\n        if (Point.isPointLike(arg0)) {\n            if (len === 3) {\n                return new CurveTo(args[0], args[1], args[2]);\n            }\n            // this is a poly-bezier segment\n            const segments = [];\n            for (let i = 0; i < len; i += 3) {\n                segments.push(new CurveTo(args[i], args[i + 1], args[i + 2]));\n            }\n            return segments;\n        }\n        // coordinates provided\n        if (len === 6) {\n            return new CurveTo(args[0], args[1], args[2], args[3], args[4], args[5]);\n        }\n        // this is a poly-bezier segment\n        const segments = [];\n        for (let i = 0; i < len; i += 6) {\n            segments.push(new CurveTo(args[i], args[i + 1], args[i + 2], args[i + 3], args[i + 4], args[i + 5]));\n        }\n        return segments;\n    }\n    CurveTo.create = create;\n})(CurveTo || (CurveTo = {}));\n//# sourceMappingURL=curveto.js.map"]},"metadata":{},"sourceType":"module"}