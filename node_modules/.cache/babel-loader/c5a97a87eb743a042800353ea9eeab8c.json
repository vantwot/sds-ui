{"ast":null,"code":"var __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Point, Line, Rectangle, Polyline, Ellipse, Path } from '../../geometry';\nimport { attr } from './attr';\nimport { sample, toPath, getPointsFromSvgElement } from './path';\nimport { ensureId, isSVGGraphicsElement, createSvgElement, isHTMLElement } from './elem';\nimport { getComputedStyle } from './style';\nimport { createSVGPoint, createSVGMatrix, decomposeMatrix, transformRectangle, transformStringToMatrix } from './matrix';\n/**\n * Returns the bounding box of the element after transformations are\n * applied. If `withoutTransformations` is `true`, transformations of\n * the element will not be considered when computing the bounding box.\n * If `target` is specified, bounding box will be computed relatively\n * to the `target` element.\n */\n\nexport function bbox(elem, withoutTransformations, target) {\n  let box;\n  const ownerSVGElement = elem.ownerSVGElement; // If the element is not in the live DOM, it does not have a bounding\n  // box defined and so fall back to 'zero' dimension element.\n\n  if (!ownerSVGElement) {\n    return new Rectangle(0, 0, 0, 0);\n  }\n\n  try {\n    box = elem.getBBox();\n  } catch (e) {\n    // Fallback for IE.\n    box = {\n      x: elem.clientLeft,\n      y: elem.clientTop,\n      width: elem.clientWidth,\n      height: elem.clientHeight\n    };\n  }\n\n  if (withoutTransformations) {\n    return Rectangle.create(box);\n  }\n\n  const matrix = getTransformToElement(elem, target || ownerSVGElement);\n  return transformRectangle(box, matrix);\n}\n/**\n * Returns the bounding box of the element after transformations are\n * applied. Unlike `bbox()`, this function fixes a browser implementation\n * bug to return the correct bounding box if this elemenent is a group of\n * svg elements (if `options.recursive` is specified).\n */\n\nexport function getBBox(elem) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let outputBBox;\n  const ownerSVGElement = elem.ownerSVGElement; // If the element is not in the live DOM, it does not have a bounding box\n  // defined and so fall back to 'zero' dimension element.\n  // If the element is not an SVGGraphicsElement, we could not measure the\n  // bounding box either\n\n  if (!ownerSVGElement || !isSVGGraphicsElement(elem)) {\n    if (isHTMLElement(elem)) {\n      // If the element is a HTMLElement, return the position relative to the body\n      const {\n        left,\n        top,\n        width,\n        height\n      } = getBoundingOffsetRect(elem);\n      return new Rectangle(left, top, width, height);\n    }\n\n    return new Rectangle(0, 0, 0, 0);\n  }\n\n  let target = options.target;\n  const recursive = options.recursive;\n\n  if (!recursive) {\n    try {\n      outputBBox = elem.getBBox();\n    } catch (e) {\n      outputBBox = {\n        x: elem.clientLeft,\n        y: elem.clientTop,\n        width: elem.clientWidth,\n        height: elem.clientHeight\n      };\n    }\n\n    if (!target) {\n      return Rectangle.create(outputBBox);\n    } // transform like target\n\n\n    const matrix = getTransformToElement(elem, target);\n    return transformRectangle(outputBBox, matrix);\n  } // recursive\n\n\n  {\n    const children = elem.childNodes;\n    const n = children.length;\n\n    if (n === 0) {\n      return getBBox(elem, {\n        target\n      });\n    }\n\n    if (!target) {\n      target = elem; // eslint-disable-line\n    }\n\n    for (let i = 0; i < n; i += 1) {\n      const child = children[i];\n      let childBBox;\n\n      if (child.childNodes.length === 0) {\n        childBBox = getBBox(child, {\n          target\n        });\n      } else {\n        // if child is a group element, enter it with a recursive call\n        childBBox = getBBox(child, {\n          target,\n          recursive: true\n        });\n      }\n\n      if (!outputBBox) {\n        outputBBox = childBBox;\n      } else {\n        outputBBox = outputBBox.union(childBBox);\n      }\n    }\n\n    return outputBBox;\n  }\n} // BBox is calculated by the attribute on the node\n\nexport function getBBoxByElementAttr(elem) {\n  let node = elem;\n  let tagName = node ? node.tagName.toLowerCase() : ''; // find shape node\n\n  while (tagName === 'g') {\n    node = node.firstElementChild;\n    tagName = node ? node.tagName.toLowerCase() : '';\n  }\n\n  const attr = name => {\n    const s = node.getAttribute(name);\n    const v = s ? parseFloat(s) : 0;\n    return Number.isNaN(v) ? 0 : v;\n  };\n\n  let r;\n  let bbox;\n\n  switch (tagName) {\n    case 'rect':\n      bbox = new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));\n      break;\n\n    case 'circle':\n      r = attr('r');\n      bbox = new Rectangle(attr('cx') - r, attr('cy') - r, 2 * r, 2 * r);\n      break;\n\n    default:\n      break;\n  }\n\n  return bbox;\n} // Matrix is calculated by the transform attribute on the node\n\nexport function getMatrixByElementAttr(elem, target) {\n  let matrix = createSVGMatrix();\n\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    let node = elem;\n    const matrixList = [];\n\n    while (node && node !== target) {\n      const transform = node.getAttribute('transform') || null;\n      const nodeMatrix = transformStringToMatrix(transform);\n      matrixList.push(nodeMatrix);\n      node = node.parentNode;\n    }\n\n    matrixList.reverse().forEach(m => {\n      matrix = matrix.multiply(m);\n    });\n  }\n\n  return matrix;\n}\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n */\n\nexport function getTransformToElement(elem, target) {\n  if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n    const targetCTM = target.getScreenCTM();\n    const nodeCTM = elem.getScreenCTM();\n\n    if (targetCTM && nodeCTM) {\n      return targetCTM.inverse().multiply(nodeCTM);\n    }\n  } // Could not get actual transformation matrix\n\n\n  return createSVGMatrix();\n}\n/**\n * Converts a global point with coordinates `x` and `y` into the\n * coordinate space of the element.\n */\n\nexport function toLocalPoint(elem, x, y) {\n  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n  const p = svg.createSVGPoint();\n  p.x = x;\n  p.y = y;\n\n  try {\n    const ctm = svg.getScreenCTM();\n    const globalPoint = p.matrixTransform(ctm.inverse());\n    const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();\n    return globalPoint.matrixTransform(globalToLocalMatrix);\n  } catch (e) {\n    return p;\n  }\n}\n/**\n * Convert the SVGElement to an equivalent geometric shape. The element's\n * transformations are not taken into account.\n *\n * SVGRectElement      => Rectangle\n *\n * SVGLineElement      => Line\n *\n * SVGCircleElement    => Ellipse\n *\n * SVGEllipseElement   => Ellipse\n *\n * SVGPolygonElement   => Polyline\n *\n * SVGPolylineElement  => Polyline\n *\n * SVGPathElement      => Path\n *\n * others              => Rectangle\n */\n\nexport function toGeometryShape(elem) {\n  const attr = name => {\n    const s = elem.getAttribute(name);\n    const v = s ? parseFloat(s) : 0;\n    return Number.isNaN(v) ? 0 : v;\n  };\n\n  switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {\n    case 'rect':\n      return new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));\n\n    case 'circle':\n      return new Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'));\n\n    case 'ellipse':\n      return new Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'));\n\n    case 'polyline':\n      {\n        const points = getPointsFromSvgElement(elem);\n        return new Polyline(points);\n      }\n\n    case 'polygon':\n      {\n        const points = getPointsFromSvgElement(elem);\n\n        if (points.length > 1) {\n          points.push(points[0]);\n        }\n\n        return new Polyline(points);\n      }\n\n    case 'path':\n      {\n        let d = elem.getAttribute('d');\n\n        if (!Path.isValid(d)) {\n          d = Path.normalize(d);\n        }\n\n        return Path.parse(d);\n      }\n\n    case 'line':\n      {\n        return new Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));\n      }\n\n    default:\n      break;\n  } // Anything else is a rectangle\n\n\n  return getBBox(elem);\n}\nexport function getIntersection(elem, ref, target) {\n  const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n  target = target || svg; // eslint-disable-line\n\n  const bbox = getBBox(target);\n  const center = bbox.getCenter();\n\n  if (!bbox.intersectsWithLineFromCenterToPoint(ref)) {\n    return null;\n  }\n\n  let spot = null;\n  const tagName = elem.tagName.toLowerCase(); // Little speed up optimization for `<rect>` element. We do not do convert\n  // to path element and sampling but directly calculate the intersection\n  // through a transformed geometrical rectangle.\n\n  if (tagName === 'rect') {\n    const gRect = new Rectangle(parseFloat(elem.getAttribute('x') || '0'), parseFloat(elem.getAttribute('y') || '0'), parseFloat(elem.getAttribute('width') || '0'), parseFloat(elem.getAttribute('height') || '0')); // Get the rect transformation matrix with regards to the SVG document.\n\n    const rectMatrix = getTransformToElement(elem, target);\n    const rectMatrixComponents = decomposeMatrix(rectMatrix); // Rotate the rectangle back so that we can use\n    // `intersectsWithLineFromCenterToPoint()`.\n\n    const reseted = svg.createSVGTransform();\n    reseted.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n    const rect = transformRectangle(gRect, reseted.matrix.multiply(rectMatrix));\n    spot = Rectangle.create(rect).intersectsWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n  } else if (tagName === 'path' || tagName === 'polygon' || tagName === 'polyline' || tagName === 'circle' || tagName === 'ellipse') {\n    const pathNode = tagName === 'path' ? elem : toPath(elem);\n    const samples = sample(pathNode);\n    let minDistance = Infinity;\n    let closestSamples = [];\n\n    for (let i = 0, ii = samples.length; i < ii; i += 1) {\n      const sample = samples[i]; // Convert the sample point in the local coordinate system\n      // to the global coordinate system.\n\n      let gp = createSVGPoint(sample.x, sample.y);\n      gp = gp.matrixTransform(getTransformToElement(elem, target));\n      const ggp = Point.create(gp);\n      const centerDistance = ggp.distance(center); // Penalize a higher distance to the reference point by 10%.\n      // This gives better results. This is due to\n      // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n\n      const refDistance = ggp.distance(ref) * 1.1;\n      const distance = centerDistance + refDistance;\n\n      if (distance < minDistance) {\n        minDistance = distance;\n        closestSamples = [{\n          sample,\n          refDistance\n        }];\n      } else if (distance < minDistance + 1) {\n        closestSamples.push({\n          sample,\n          refDistance\n        });\n      }\n    }\n\n    closestSamples.sort((a, b) => a.refDistance - b.refDistance);\n\n    if (closestSamples[0]) {\n      spot = Point.create(closestSamples[0].sample);\n    }\n  }\n\n  return spot;\n}\nexport function animate(elem, options) {\n  return createAnimation(elem, options, 'animate');\n}\nexport function animateTransform(elem, options) {\n  return createAnimation(elem, options, 'animateTransform');\n}\n\nfunction createAnimation(elem, options, type) {\n  // @see\n  // https://www.w3.org/TR/SVG11/animate.html#AnimateElement\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateElement\n  // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateTransformElement\n  const animate = createSvgElement(type);\n  elem.appendChild(animate);\n\n  try {\n    return setupAnimation(animate, options);\n  } catch (error) {// pass\n  }\n\n  return () => {};\n}\n\nfunction setupAnimation(animate, options) {\n  const {\n    start,\n    complete,\n    repeat\n  } = options,\n        attrs = __rest(options, [\"start\", \"complete\", \"repeat\"]);\n\n  attr(animate, attrs);\n  start && animate.addEventListener('beginEvent', start);\n  complete && animate.addEventListener('endEvent', complete);\n  repeat && animate.addEventListener('repeatEvent', repeat);\n  const ani = animate;\n  ani.beginElement();\n  return () => ani.endElement();\n}\n/**\n * Animate the element along the path SVG element (or Vector object).\n * `attrs` contain Animation Timing attributes describing the animation.\n */\n\n\nexport function animateAlongPath(elem, options, path) {\n  const id = ensureId(path); // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimationElement\n\n  const animate = createSvgElement('animateMotion');\n  const mpath = createSvgElement('mpath');\n  attr(mpath, {\n    'xlink:href': `#${id}`\n  });\n  animate.appendChild(mpath);\n  elem.appendChild(animate);\n\n  try {\n    return setupAnimation(animate, options);\n  } catch (e) {\n    // Fallback for IE 9.\n    if (document.documentElement.getAttribute('smiling') === 'fake') {\n      // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n      const ani = animate;\n      ani.animators = [];\n      const win = window;\n      const animationID = ani.getAttribute('id');\n\n      if (animationID) {\n        win.id2anim[animationID] = ani;\n      }\n\n      const targets = win.getTargets(ani);\n\n      for (let i = 0, ii = targets.length; i < ii; i += 1) {\n        const target = targets[i];\n        const animator = new win.Animator(ani, target, i);\n        win.animators.push(animator);\n        ani.animators[i] = animator;\n        animator.register();\n      }\n    }\n  }\n\n  return () => {};\n}\nexport function getBoundingOffsetRect(elem) {\n  let left = 0;\n  let top = 0;\n  let width = 0;\n  let height = 0;\n\n  if (elem) {\n    let current = elem;\n\n    while (current) {\n      left += current.offsetLeft;\n      top += current.offsetTop;\n      current = current.offsetParent;\n\n      if (current) {\n        left += parseInt(getComputedStyle(current, 'borderLeft'), 10);\n        top += parseInt(getComputedStyle(current, 'borderTop'), 10);\n      }\n    }\n\n    width = elem.offsetWidth;\n    height = elem.offsetHeight;\n  }\n\n  return {\n    left,\n    top,\n    width,\n    height\n  };\n}","map":{"version":3,"sources":["../../../src/util/dom/geom.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { Point, Line, Rectangle, Polyline, Ellipse, Path } from '../../geometry';\nimport { attr } from './attr';\nimport { sample, toPath, getPointsFromSvgElement } from './path';\nimport { ensureId, isSVGGraphicsElement, createSvgElement, isHTMLElement, } from './elem';\nimport { getComputedStyle } from './style';\nimport { createSVGPoint, createSVGMatrix, decomposeMatrix, transformRectangle, transformStringToMatrix, } from './matrix';\n/**\n * Returns the bounding box of the element after transformations are\n * applied. If `withoutTransformations` is `true`, transformations of\n * the element will not be considered when computing the bounding box.\n * If `target` is specified, bounding box will be computed relatively\n * to the `target` element.\n */\nexport function bbox(elem, withoutTransformations, target) {\n    let box;\n    const ownerSVGElement = elem.ownerSVGElement;\n    // If the element is not in the live DOM, it does not have a bounding\n    // box defined and so fall back to 'zero' dimension element.\n    if (!ownerSVGElement) {\n        return new Rectangle(0, 0, 0, 0);\n    }\n    try {\n        box = elem.getBBox();\n    }\n    catch (e) {\n        // Fallback for IE.\n        box = {\n            x: elem.clientLeft,\n            y: elem.clientTop,\n            width: elem.clientWidth,\n            height: elem.clientHeight,\n        };\n    }\n    if (withoutTransformations) {\n        return Rectangle.create(box);\n    }\n    const matrix = getTransformToElement(elem, target || ownerSVGElement);\n    return transformRectangle(box, matrix);\n}\n/**\n * Returns the bounding box of the element after transformations are\n * applied. Unlike `bbox()`, this function fixes a browser implementation\n * bug to return the correct bounding box if this elemenent is a group of\n * svg elements (if `options.recursive` is specified).\n */\nexport function getBBox(elem, options = {}) {\n    let outputBBox;\n    const ownerSVGElement = elem.ownerSVGElement;\n    // If the element is not in the live DOM, it does not have a bounding box\n    // defined and so fall back to 'zero' dimension element.\n    // If the element is not an SVGGraphicsElement, we could not measure the\n    // bounding box either\n    if (!ownerSVGElement || !isSVGGraphicsElement(elem)) {\n        if (isHTMLElement(elem)) {\n            // If the element is a HTMLElement, return the position relative to the body\n            const { left, top, width, height } = getBoundingOffsetRect(elem);\n            return new Rectangle(left, top, width, height);\n        }\n        return new Rectangle(0, 0, 0, 0);\n    }\n    let target = options.target;\n    const recursive = options.recursive;\n    if (!recursive) {\n        try {\n            outputBBox = elem.getBBox();\n        }\n        catch (e) {\n            outputBBox = {\n                x: elem.clientLeft,\n                y: elem.clientTop,\n                width: elem.clientWidth,\n                height: elem.clientHeight,\n            };\n        }\n        if (!target) {\n            return Rectangle.create(outputBBox);\n        }\n        // transform like target\n        const matrix = getTransformToElement(elem, target);\n        return transformRectangle(outputBBox, matrix);\n    }\n    // recursive\n    {\n        const children = elem.childNodes;\n        const n = children.length;\n        if (n === 0) {\n            return getBBox(elem, { target });\n        }\n        if (!target) {\n            target = elem; // eslint-disable-line\n        }\n        for (let i = 0; i < n; i += 1) {\n            const child = children[i];\n            let childBBox;\n            if (child.childNodes.length === 0) {\n                childBBox = getBBox(child, { target });\n            }\n            else {\n                // if child is a group element, enter it with a recursive call\n                childBBox = getBBox(child, { target, recursive: true });\n            }\n            if (!outputBBox) {\n                outputBBox = childBBox;\n            }\n            else {\n                outputBBox = outputBBox.union(childBBox);\n            }\n        }\n        return outputBBox;\n    }\n}\n// BBox is calculated by the attribute on the node\nexport function getBBoxByElementAttr(elem) {\n    let node = elem;\n    let tagName = node ? node.tagName.toLowerCase() : '';\n    // find shape node\n    while (tagName === 'g') {\n        node = node.firstElementChild;\n        tagName = node ? node.tagName.toLowerCase() : '';\n    }\n    const attr = (name) => {\n        const s = node.getAttribute(name);\n        const v = s ? parseFloat(s) : 0;\n        return Number.isNaN(v) ? 0 : v;\n    };\n    let r;\n    let bbox;\n    switch (tagName) {\n        case 'rect':\n            bbox = new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));\n            break;\n        case 'circle':\n            r = attr('r');\n            bbox = new Rectangle(attr('cx') - r, attr('cy') - r, 2 * r, 2 * r);\n            break;\n        default:\n            break;\n    }\n    return bbox;\n}\n// Matrix is calculated by the transform attribute on the node\nexport function getMatrixByElementAttr(elem, target) {\n    let matrix = createSVGMatrix();\n    if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n        let node = elem;\n        const matrixList = [];\n        while (node && node !== target) {\n            const transform = node.getAttribute('transform') || null;\n            const nodeMatrix = transformStringToMatrix(transform);\n            matrixList.push(nodeMatrix);\n            node = node.parentNode;\n        }\n        matrixList.reverse().forEach((m) => {\n            matrix = matrix.multiply(m);\n        });\n    }\n    return matrix;\n}\n/**\n * Returns an DOMMatrix that specifies the transformation necessary\n * to convert `elem` coordinate system into `target` coordinate system.\n */\nexport function getTransformToElement(elem, target) {\n    if (isSVGGraphicsElement(target) && isSVGGraphicsElement(elem)) {\n        const targetCTM = target.getScreenCTM();\n        const nodeCTM = elem.getScreenCTM();\n        if (targetCTM && nodeCTM) {\n            return targetCTM.inverse().multiply(nodeCTM);\n        }\n    }\n    // Could not get actual transformation matrix\n    return createSVGMatrix();\n}\n/**\n * Converts a global point with coordinates `x` and `y` into the\n * coordinate space of the element.\n */\nexport function toLocalPoint(elem, x, y) {\n    const svg = elem instanceof SVGSVGElement\n        ? elem\n        : elem.ownerSVGElement;\n    const p = svg.createSVGPoint();\n    p.x = x;\n    p.y = y;\n    try {\n        const ctm = svg.getScreenCTM();\n        const globalPoint = p.matrixTransform(ctm.inverse());\n        const globalToLocalMatrix = getTransformToElement(elem, svg).inverse();\n        return globalPoint.matrixTransform(globalToLocalMatrix);\n    }\n    catch (e) {\n        return p;\n    }\n}\n/**\n * Convert the SVGElement to an equivalent geometric shape. The element's\n * transformations are not taken into account.\n *\n * SVGRectElement      => Rectangle\n *\n * SVGLineElement      => Line\n *\n * SVGCircleElement    => Ellipse\n *\n * SVGEllipseElement   => Ellipse\n *\n * SVGPolygonElement   => Polyline\n *\n * SVGPolylineElement  => Polyline\n *\n * SVGPathElement      => Path\n *\n * others              => Rectangle\n */\nexport function toGeometryShape(elem) {\n    const attr = (name) => {\n        const s = elem.getAttribute(name);\n        const v = s ? parseFloat(s) : 0;\n        return Number.isNaN(v) ? 0 : v;\n    };\n    switch (elem instanceof SVGElement && elem.nodeName.toLowerCase()) {\n        case 'rect':\n            return new Rectangle(attr('x'), attr('y'), attr('width'), attr('height'));\n        case 'circle':\n            return new Ellipse(attr('cx'), attr('cy'), attr('r'), attr('r'));\n        case 'ellipse':\n            return new Ellipse(attr('cx'), attr('cy'), attr('rx'), attr('ry'));\n        case 'polyline': {\n            const points = getPointsFromSvgElement(elem);\n            return new Polyline(points);\n        }\n        case 'polygon': {\n            const points = getPointsFromSvgElement(elem);\n            if (points.length > 1) {\n                points.push(points[0]);\n            }\n            return new Polyline(points);\n        }\n        case 'path': {\n            let d = elem.getAttribute('d');\n            if (!Path.isValid(d)) {\n                d = Path.normalize(d);\n            }\n            return Path.parse(d);\n        }\n        case 'line': {\n            return new Line(attr('x1'), attr('y1'), attr('x2'), attr('y2'));\n        }\n        default:\n            break;\n    }\n    // Anything else is a rectangle\n    return getBBox(elem);\n}\nexport function getIntersection(elem, ref, target) {\n    const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n    target = target || svg; // eslint-disable-line\n    const bbox = getBBox(target);\n    const center = bbox.getCenter();\n    if (!bbox.intersectsWithLineFromCenterToPoint(ref)) {\n        return null;\n    }\n    let spot = null;\n    const tagName = elem.tagName.toLowerCase();\n    // Little speed up optimization for `<rect>` element. We do not do convert\n    // to path element and sampling but directly calculate the intersection\n    // through a transformed geometrical rectangle.\n    if (tagName === 'rect') {\n        const gRect = new Rectangle(parseFloat(elem.getAttribute('x') || '0'), parseFloat(elem.getAttribute('y') || '0'), parseFloat(elem.getAttribute('width') || '0'), parseFloat(elem.getAttribute('height') || '0'));\n        // Get the rect transformation matrix with regards to the SVG document.\n        const rectMatrix = getTransformToElement(elem, target);\n        const rectMatrixComponents = decomposeMatrix(rectMatrix);\n        // Rotate the rectangle back so that we can use\n        // `intersectsWithLineFromCenterToPoint()`.\n        const reseted = svg.createSVGTransform();\n        reseted.setRotate(-rectMatrixComponents.rotation, center.x, center.y);\n        const rect = transformRectangle(gRect, reseted.matrix.multiply(rectMatrix));\n        spot = Rectangle.create(rect).intersectsWithLineFromCenterToPoint(ref, rectMatrixComponents.rotation);\n    }\n    else if (tagName === 'path' ||\n        tagName === 'polygon' ||\n        tagName === 'polyline' ||\n        tagName === 'circle' ||\n        tagName === 'ellipse') {\n        const pathNode = tagName === 'path' ? elem : toPath(elem);\n        const samples = sample(pathNode);\n        let minDistance = Infinity;\n        let closestSamples = [];\n        for (let i = 0, ii = samples.length; i < ii; i += 1) {\n            const sample = samples[i];\n            // Convert the sample point in the local coordinate system\n            // to the global coordinate system.\n            let gp = createSVGPoint(sample.x, sample.y);\n            gp = gp.matrixTransform(getTransformToElement(elem, target));\n            const ggp = Point.create(gp);\n            const centerDistance = ggp.distance(center);\n            // Penalize a higher distance to the reference point by 10%.\n            // This gives better results. This is due to\n            // inaccuracies introduced by rounding errors and getPointAtLength() returns.\n            const refDistance = ggp.distance(ref) * 1.1;\n            const distance = centerDistance + refDistance;\n            if (distance < minDistance) {\n                minDistance = distance;\n                closestSamples = [{ sample, refDistance }];\n            }\n            else if (distance < minDistance + 1) {\n                closestSamples.push({ sample, refDistance });\n            }\n        }\n        closestSamples.sort((a, b) => a.refDistance - b.refDistance);\n        if (closestSamples[0]) {\n            spot = Point.create(closestSamples[0].sample);\n        }\n    }\n    return spot;\n}\nexport function animate(elem, options) {\n    return createAnimation(elem, options, 'animate');\n}\nexport function animateTransform(elem, options) {\n    return createAnimation(elem, options, 'animateTransform');\n}\nfunction createAnimation(elem, options, type) {\n    // @see\n    // https://www.w3.org/TR/SVG11/animate.html#AnimateElement\n    // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateElement\n    // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimateTransformElement\n    const animate = createSvgElement(type);\n    elem.appendChild(animate);\n    try {\n        return setupAnimation(animate, options);\n    }\n    catch (error) {\n        // pass\n    }\n    return () => { };\n}\nfunction setupAnimation(animate, options) {\n    const { start, complete, repeat } = options, attrs = __rest(options, [\"start\", \"complete\", \"repeat\"]);\n    attr(animate, attrs);\n    start && animate.addEventListener('beginEvent', start);\n    complete && animate.addEventListener('endEvent', complete);\n    repeat && animate.addEventListener('repeatEvent', repeat);\n    const ani = animate;\n    ani.beginElement();\n    return () => ani.endElement();\n}\n/**\n * Animate the element along the path SVG element (or Vector object).\n * `attrs` contain Animation Timing attributes describing the animation.\n */\nexport function animateAlongPath(elem, options, path) {\n    const id = ensureId(path);\n    // https://developer.mozilla.org/en-US/docs/Web/API/SVGAnimationElement\n    const animate = createSvgElement('animateMotion');\n    const mpath = createSvgElement('mpath');\n    attr(mpath, { 'xlink:href': `#${id}` });\n    animate.appendChild(mpath);\n    elem.appendChild(animate);\n    try {\n        return setupAnimation(animate, options);\n    }\n    catch (e) {\n        // Fallback for IE 9.\n        if (document.documentElement.getAttribute('smiling') === 'fake') {\n            // Register the animation. (See `https://answers.launchpad.net/smil/+question/203333`)\n            const ani = animate;\n            ani.animators = [];\n            const win = window;\n            const animationID = ani.getAttribute('id');\n            if (animationID) {\n                win.id2anim[animationID] = ani;\n            }\n            const targets = win.getTargets(ani);\n            for (let i = 0, ii = targets.length; i < ii; i += 1) {\n                const target = targets[i];\n                const animator = new win.Animator(ani, target, i);\n                win.animators.push(animator);\n                ani.animators[i] = animator;\n                animator.register();\n            }\n        }\n    }\n    return () => { };\n}\nexport function getBoundingOffsetRect(elem) {\n    let left = 0;\n    let top = 0;\n    let width = 0;\n    let height = 0;\n    if (elem) {\n        let current = elem;\n        while (current) {\n            left += current.offsetLeft;\n            top += current.offsetTop;\n            current = current.offsetParent;\n            if (current) {\n                left += parseInt(getComputedStyle(current, 'borderLeft'), 10);\n                top += parseInt(getComputedStyle(current, 'borderTop'), 10);\n            }\n        }\n        width = elem.offsetWidth;\n        height = elem.offsetHeight;\n    }\n    return { left, top, width, height };\n}\n//# sourceMappingURL=geom.js.map"]},"metadata":{},"sourceType":"module"}