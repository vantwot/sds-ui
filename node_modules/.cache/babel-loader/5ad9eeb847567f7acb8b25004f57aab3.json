{"ast":null,"code":"var isEdgeView = function isEdgeView(val, _ref) {\n  var view = _ref.view;\n  return view.cell.isEdge();\n};\n\nexport var connection = {\n  qualify: isEdgeView,\n  set: function set(val, args) {\n    var view = args.view;\n    var stubs = val.stubs || 0;\n    var d;\n\n    if (Number.isFinite(stubs) && stubs !== 0) {\n      var offset;\n\n      if (stubs < 0) {\n        var len = view.getConnectionLength() || 0;\n        offset = (len + stubs) / 2;\n      } else {\n        offset = stubs;\n      }\n\n      var path = view.getConnection();\n\n      if (path) {\n        var sourceParts = path.divideAtLength(offset);\n        var targetParts = path.divideAtLength(-offset);\n\n        if (sourceParts && targetParts) {\n          d = \"\".concat(sourceParts[0].serialize(), \" \").concat(targetParts[1].serialize());\n        }\n      }\n    }\n\n    return {\n      d: d || view.getConnectionPathData()\n    };\n  }\n};\nexport var atConnectionLengthKeepGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', {\n    rotate: true\n  })\n};\nexport var atConnectionLengthIgnoreGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', {\n    rotate: false\n  })\n};\nexport var atConnectionRatioKeepGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', {\n    rotate: true\n  })\n};\nexport var atConnectionRatioIgnoreGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', {\n    rotate: false\n  })\n}; // aliases\n// -------\n\nexport var atConnectionLength = atConnectionLengthKeepGradient;\nexport var atConnectionRatio = atConnectionRatioKeepGradient; // utils\n// -----\n\nfunction atConnectionWrapper(method, options) {\n  var zeroVector = {\n    x: 1,\n    y: 0\n  };\n  return function (value, args) {\n    var p;\n    var angle;\n    var view = args.view;\n    var tangent = view[method](Number(value));\n\n    if (tangent) {\n      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n      p = tangent.start;\n    } else {\n      p = view.path.start;\n      angle = 0;\n    }\n\n    if (angle === 0) {\n      return {\n        transform: \"translate(\".concat(p.x, \",\").concat(p.y, \"')\")\n      };\n    }\n\n    return {\n      transform: \"translate(\".concat(p.x, \",\").concat(p.y, \"') rotate(\").concat(angle, \")\")\n    };\n  };\n}","map":{"version":3,"sources":["../../../src/registry/attr/connection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["const isEdgeView = (val, { view }) => {\n    return view.cell.isEdge();\n};\nexport const connection = {\n    qualify: isEdgeView,\n    set(val, args) {\n        const view = args.view;\n        const stubs = (val.stubs || 0);\n        let d;\n        if (Number.isFinite(stubs) && stubs !== 0) {\n            let offset;\n            if (stubs < 0) {\n                const len = view.getConnectionLength() || 0;\n                offset = (len + stubs) / 2;\n            }\n            else {\n                offset = stubs;\n            }\n            const path = view.getConnection();\n            if (path) {\n                const sourceParts = path.divideAtLength(offset);\n                const targetParts = path.divideAtLength(-offset);\n                if (sourceParts && targetParts) {\n                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n                }\n            }\n        }\n        return { d: d || view.getConnectionPathData() };\n    },\n};\nexport const atConnectionLengthKeepGradient = {\n    qualify: isEdgeView,\n    set: atConnectionWrapper('getTangentAtLength', { rotate: true }),\n};\nexport const atConnectionLengthIgnoreGradient = {\n    qualify: isEdgeView,\n    set: atConnectionWrapper('getTangentAtLength', { rotate: false }),\n};\nexport const atConnectionRatioKeepGradient = {\n    qualify: isEdgeView,\n    set: atConnectionWrapper('getTangentAtRatio', { rotate: true }),\n};\nexport const atConnectionRatioIgnoreGradient = {\n    qualify: isEdgeView,\n    set: atConnectionWrapper('getTangentAtRatio', { rotate: false }),\n};\n// aliases\n// -------\nexport const atConnectionLength = atConnectionLengthKeepGradient;\nexport const atConnectionRatio = atConnectionRatioKeepGradient;\n// utils\n// -----\nfunction atConnectionWrapper(method, options) {\n    const zeroVector = { x: 1, y: 0 };\n    return (value, args) => {\n        let p;\n        let angle;\n        const view = args.view;\n        const tangent = view[method](Number(value));\n        if (tangent) {\n            angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n            p = tangent.start;\n        }\n        else {\n            p = view.path.start;\n            angle = 0;\n        }\n        if (angle === 0) {\n            return { transform: `translate(${p.x},${p.y}')` };\n        }\n        return {\n            transform: `translate(${p.x},${p.y}') rotate(${angle})`,\n        };\n    };\n}\n//# sourceMappingURL=connection.js.map"]},"metadata":{},"sourceType":"module"}