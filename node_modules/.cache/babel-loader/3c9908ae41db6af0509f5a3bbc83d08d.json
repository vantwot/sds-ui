{"ast":null,"code":"import _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\n\n/* eslint-disable no-control-regex */\nimport { NumberExt } from '../number';\nimport { Text } from '../text';\nimport { attr } from './attr';\nimport { Vector } from '../vector';\nimport { createSvgElement, empty, remove } from './elem';\nimport { Platform } from '../platform';\n\nfunction createTextPathNode(attrs, elem) {\n  var vel = Vector.create(elem);\n  var textPath = Vector.create('textPath');\n  var d = attrs.d;\n\n  if (d && attrs['xlink:href'] === undefined) {\n    var path = Vector.create('path').attr('d', d).appendTo(vel.defs());\n    textPath.attr('xlink:href', \"#\".concat(path.id));\n  }\n\n  if (typeof attrs === 'object') {\n    textPath.attr(attrs);\n  }\n\n  return textPath.node;\n}\n\nfunction annotateTextLine(lineNode, lineAnnotations, options) {\n  var eol = options.eol;\n  var baseSize = options.baseSize;\n  var lineHeight = options.lineHeight;\n  var maxFontSize = 0;\n  var tspanNode;\n  var fontMetrics = {};\n  var lastJ = lineAnnotations.length - 1;\n\n  for (var j = 0; j <= lastJ; j += 1) {\n    var annotation = lineAnnotations[j];\n    var fontSize = null;\n\n    if (typeof annotation === 'object') {\n      var annotationAttrs = annotation.attrs;\n      var vTSpan = Vector.create('tspan', annotationAttrs);\n      tspanNode = vTSpan.node;\n      var t = annotation.t;\n\n      if (eol && j === lastJ) {\n        t += eol;\n      }\n\n      tspanNode.textContent = t; // Per annotation className\n\n      var annotationClass = annotationAttrs.class;\n\n      if (annotationClass) {\n        vTSpan.addClass(annotationClass);\n      } // set the list of indices of all the applied annotations\n      // in the `annotations` attribute. This list is a comma\n      // separated list of indices.\n\n\n      if (options.includeAnnotationIndices) {\n        vTSpan.attr('annotations', annotation.annotations.join(','));\n      } // Check for max font size\n\n\n      fontSize = parseFloat(annotationAttrs['font-size']);\n      if (fontSize === undefined) fontSize = baseSize;\n      if (fontSize && fontSize > maxFontSize) maxFontSize = fontSize;\n    } else {\n      if (eol && j === lastJ) {\n        annotation += eol;\n      }\n\n      tspanNode = document.createTextNode(annotation || ' ');\n\n      if (baseSize && baseSize > maxFontSize) {\n        maxFontSize = baseSize;\n      }\n    }\n\n    lineNode.appendChild(tspanNode);\n  }\n\n  if (maxFontSize) {\n    fontMetrics.maxFontSize = maxFontSize;\n  }\n\n  if (lineHeight) {\n    fontMetrics.lineHeight = lineHeight;\n  } else if (maxFontSize) {\n    fontMetrics.lineHeight = maxFontSize * 1.2;\n  }\n\n  return fontMetrics;\n}\n\nvar emRegex = /em$/;\n\nfunction emToPx(em, fontSize) {\n  var numerical = parseFloat(em);\n\n  if (emRegex.test(em)) {\n    return numerical * fontSize;\n  }\n\n  return numerical;\n}\n\nfunction calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n  if (!Array.isArray(linesMetrics)) {\n    return 0;\n  }\n\n  var n = linesMetrics.length;\n  if (!n) return 0;\n  var lineMetrics = linesMetrics[0];\n  var flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n  var rLineHeights = 0;\n  var lineHeightPx = emToPx(lineHeight, baseSizePx);\n\n  for (var i = 1; i < n; i += 1) {\n    lineMetrics = linesMetrics[i];\n    var iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n    rLineHeights += iLineHeight;\n  }\n\n  var llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n  var dy;\n\n  switch (alignment) {\n    case 'middle':\n      dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n      break;\n\n    case 'bottom':\n      dy = -(0.25 * llMaxFont) - rLineHeights;\n      break;\n\n    default:\n    case 'top':\n      dy = 0.8 * flMaxFont;\n      break;\n  }\n\n  return dy;\n}\n\nexport function text(elem, content) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  content = Text.sanitize(content); // eslint-disable-line\n\n  var eol = options.eol;\n  var textPath = options.textPath;\n  var verticalAnchor = options.textVerticalAnchor;\n  var namedVerticalAnchor = verticalAnchor === 'middle' || verticalAnchor === 'bottom' || verticalAnchor === 'top'; // Horizontal shift applied to all the lines but the first.\n\n  var x = options.x;\n\n  if (x === undefined) {\n    x = elem.getAttribute('x') || 0;\n  } // Annotations\n\n\n  var iai = options.includeAnnotationIndices;\n  var annotations = options.annotations;\n\n  if (annotations && !Array.isArray(annotations)) {\n    annotations = [annotations];\n  } // Shift all the <tspan> but first by one line (`1em`)\n\n\n  var defaultLineHeight = options.lineHeight;\n  var autoLineHeight = defaultLineHeight === 'auto';\n  var lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';\n  empty(elem);\n  attr(elem, {\n    // Preserve spaces, do not consecutive spaces to get collapsed to one.\n    'xml:space': 'preserve',\n    // An empty text gets rendered into the DOM in webkit-based browsers.\n    // In order to unify this behaviour across all browsers\n    // we rather hide the text element when it's empty.\n    display: content || options.displayEmpty ? null : 'none'\n  }); // Set default font-size if none\n\n  var strFontSize = attr(elem, 'font-size');\n  var fontSize = parseFloat(strFontSize);\n\n  if (!fontSize) {\n    fontSize = 16;\n\n    if ((namedVerticalAnchor || annotations) && !strFontSize) {\n      attr(elem, 'font-size', \"\".concat(fontSize));\n    }\n  }\n\n  var containerNode;\n\n  if (textPath) {\n    // Now all the `<tspan>`s will be inside the `<textPath>`.\n    if (typeof textPath === 'string') {\n      textPath = {\n        d: textPath\n      };\n    }\n\n    containerNode = createTextPathNode(textPath, elem);\n  } else {\n    containerNode = document.createDocumentFragment();\n  }\n\n  var dy;\n  var offset = 0;\n  var annotatedY;\n  var lines = content.split('\\n');\n  var linesMetrics = [];\n  var lastI = lines.length - 1;\n\n  for (var i = 0; i <= lastI; i += 1) {\n    dy = lineHeight;\n    var lineClassName = 'v-line';\n    var lineNode = createSvgElement('tspan');\n    var lineMetrics = void 0;\n    var line = lines[i];\n\n    if (line) {\n      if (annotations) {\n        // Find the *compacted* annotations for this line.\n        var lineAnnotations = Text.annotate(line, annotations, {\n          offset: -offset,\n          includeAnnotationIndices: iai\n        });\n        lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n          eol: i !== lastI && eol,\n          baseSize: fontSize,\n          lineHeight: autoLineHeight ? null : lineHeight,\n          includeAnnotationIndices: iai\n        }); // Get the line height based on the biggest font size\n        // in the annotations for this line.\n\n        var iLineHeight = lineMetrics.lineHeight;\n\n        if (iLineHeight && autoLineHeight && i !== 0) {\n          dy = iLineHeight;\n        }\n\n        if (i === 0) {\n          annotatedY = lineMetrics.maxFontSize * 0.8;\n        }\n      } else {\n        if (eol && i !== lastI) {\n          line += eol;\n        }\n\n        lineNode.textContent = line;\n      }\n    } else {\n      // Make sure the textContent is never empty. If it is, add a dummy\n      // character and make it invisible, making the following lines correctly\n      // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n      lineNode.textContent = '-';\n      lineClassName += ' v-empty-line';\n      var lineNodeStyle = lineNode.style;\n      lineNodeStyle.fillOpacity = 0;\n      lineNodeStyle.strokeOpacity = 0;\n\n      if (annotations) {\n        lineMetrics = {};\n      }\n    }\n\n    if (lineMetrics) {\n      linesMetrics.push(lineMetrics);\n    }\n\n    if (i > 0) {\n      lineNode.setAttribute('dy', dy);\n    } // Firefox requires 'x' to be set on the first line\n\n\n    if (i > 0 || textPath) {\n      lineNode.setAttribute('x', x);\n    }\n\n    lineNode.className.baseVal = lineClassName;\n    containerNode.appendChild(lineNode);\n    offset += line.length + 1; // + 1 = newline character.\n  } // Y Alignment calculation\n\n\n  if (namedVerticalAnchor) {\n    if (annotations) {\n      dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n    } else if (verticalAnchor === 'top') {\n      // A shortcut for top alignment. It does not depend on font-size nor line-height\n      dy = '0.8em';\n    } else {\n      var rh; // remaining height\n\n      if (lastI > 0) {\n        rh = parseFloat(lineHeight) || 1;\n        rh *= lastI;\n        if (!emRegex.test(lineHeight)) rh /= fontSize;\n      } else {\n        // Single-line text\n        rh = 0;\n      }\n\n      switch (verticalAnchor) {\n        case 'middle':\n          dy = \"\".concat(0.3 - rh / 2, \"em\");\n          break;\n\n        case 'bottom':\n          dy = \"\".concat(-rh - 0.3, \"em\");\n          break;\n\n        default:\n          break;\n      }\n    }\n  } else if (verticalAnchor === 0) {\n    dy = '0em';\n  } else if (verticalAnchor) {\n    dy = verticalAnchor;\n  } else {\n    // No vertical anchor is defined\n    dy = 0; // Backwards compatibility - we change the `y` attribute instead of `dy`.\n\n    if (elem.getAttribute('y') == null) {\n      elem.setAttribute('y', \"\".concat(annotatedY || '0.8em'));\n    }\n  }\n\n  var firstLine = containerNode.firstChild;\n  firstLine.setAttribute('dy', dy);\n  elem.appendChild(containerNode);\n}\n\nfunction splitText(text, separator, eol, hyphen) {\n  var words = [];\n  var separators = [];\n\n  if (separator != null) {\n    var parts = text.split(separator);\n    words.push.apply(words, _toConsumableArray(parts));\n\n    if (typeof separator === 'string') {\n      for (var i = 0, l = parts.length - 1; i < l; i += 1) {\n        separators.push(separator);\n      }\n    } else {\n      var seps = text.match(new RegExp(separator, 'g'));\n\n      for (var _i = 0, _l = parts.length - 1; _i < _l; _i += 1) {\n        separators.push(seps ? seps[_i] : '');\n      }\n    }\n  } else {\n    var word = '';\n\n    for (var _i2 = 0, _l2 = text.length; _i2 < _l2; _i2 += 1) {\n      var char = text[_i2];\n\n      if (char === ' ') {\n        words.push(word);\n        separators.push(' ');\n        word = '';\n      } else if (char.match(/[^\\x00-\\xff]/)) {\n        // split double byte character\n        if (word.length) {\n          words.push(word);\n          separators.push('');\n        }\n\n        words.push(char);\n        separators.push('');\n        word = '';\n      } else {\n        word += char;\n      }\n    }\n\n    if (word.length) {\n      words.push(word);\n    }\n  } // end-of-line\n\n\n  for (var _i3 = 0; _i3 < words.length; _i3 += 1) {\n    var _word = words[_i3];\n\n    if (_word.indexOf(eol) >= 0 && _word.length > 1) {\n      var _parts = _word.split(eol);\n\n      for (var j = 0, k = _parts.length - 1; j < k; j += 1) {\n        _parts.splice(2 * j + 1, 0, eol);\n      }\n\n      var valids = _parts.filter(function (part) {\n        return part !== '';\n      });\n\n      words.splice.apply(words, [_i3, 1].concat(_toConsumableArray(valids)));\n\n      var _seps = valids.map(function () {\n        return '';\n      });\n\n      _seps.pop();\n\n      separators.splice.apply(separators, [_i3, 0].concat(_toConsumableArray(_seps)));\n    }\n  } // hyphen\n\n\n  for (var _i4 = 0; _i4 < words.length; _i4 += 1) {\n    var _word2 = words[_i4];\n\n    var index = _word2.search(hyphen);\n\n    if (index > 0 && index < _word2.length - 1) {\n      words.splice(_i4, 1, _word2.substring(0, index + 1), _word2.substring(index + 1));\n      separators.splice(_i4, 0, '');\n    }\n  }\n\n  return {\n    words: words,\n    separators: separators\n  };\n}\n\nexport function breakText(text, size) {\n  var styles = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var width = size.width;\n  var height = size.height;\n  var svgDocument = options.svgDocument || createSvgElement('svg');\n  var telem = createSvgElement('text');\n  var tspan = createSvgElement('tspan');\n  var tnode = document.createTextNode('');\n  attr(telem, styles);\n  telem.appendChild(tspan); // Prevent flickering\n\n  telem.style.opacity = '0'; // Prevent FF from throwing an uncaught exception when `getBBox()`\n  // called on element that is not in the render tree (is not measurable).\n  // <tspan>.getComputedTextLength() returns always 0 in this case.\n  // Note that the `textElement` resp. `textSpan` can become hidden\n  // when it's appended to the DOM and a `display: none` CSS stylesheet\n  // rule gets applied.\n\n  telem.style.display = 'block';\n  tspan.style.display = 'block';\n  tspan.appendChild(tnode);\n  svgDocument.appendChild(telem);\n  var shouldAppend = svgDocument.parentNode == null;\n\n  if (shouldAppend) {\n    document.body.appendChild(svgDocument);\n  }\n\n  var eol = options.eol || '\\n';\n  var separator = options.separator || ' ';\n  var hyphen = options.hyphen ? new RegExp(options.hyphen) : /[^\\w\\d]/;\n  var breakWord = options.breakWord !== false;\n  var full = [];\n  var lineSeprators = {};\n  var lines = [];\n  var partIndex; // let hyphenIndex\n\n  var lineHeight;\n  var currentSeparator;\n\n  var _splitText = splitText(text, options.separator, eol, hyphen),\n      words = _splitText.words,\n      separators = _splitText.separators;\n\n  for (var wordIndex = 0, lineIndex = 0, wordCount = words.length; wordIndex < wordCount; wordIndex += 1) {\n    var word = words[wordIndex]; // empty word\n\n    if (!word) {\n      continue;\n    } // end of line\n\n\n    if (word === eol) {\n      full[lineIndex] = true; // start a new line\n\n      lineIndex += 1;\n      lines[lineIndex] = '';\n      continue;\n    }\n\n    if (lines[lineIndex] != null) {\n      currentSeparator = separators[wordIndex - 1] || '';\n      tnode.data = \"\".concat(lines[lineIndex]).concat(currentSeparator).concat(word);\n    } else {\n      tnode.data = word;\n    }\n\n    if (tspan.getComputedTextLength() <= width) {\n      // update line\n      lines[lineIndex] = tnode.data;\n      lineSeprators[lineIndex] = separators[wordIndex]; // when is partitioning, put rest of the word onto next line\n\n      if (partIndex) {\n        full[lineIndex] = true;\n        lineIndex += 1;\n        partIndex = 0;\n      }\n    } else {\n      if (breakWord) {\n        // word is too long to put in one line or is partitioning\n        if (!lines[lineIndex] || partIndex) {\n          var isPartition = !!partIndex;\n          var isCharacter = word.length === 1;\n          partIndex = word.length - 1;\n\n          if (isPartition || isCharacter) {\n            // word has only one character.\n            if (isCharacter) {\n              if (!lines[lineIndex]) {\n                // can't fit this text within our rect\n                lines = [];\n                break;\n              } // partitioning didn't help on the non-empty line\n              // try again, but this time start with a new line\n              // cancel partitions created\n\n\n              words.splice(wordIndex, 2, word + words[wordIndex + 1]);\n              separators.splice(wordIndex + 1, 1);\n              full[lineIndex] = true;\n              lineIndex += 1;\n              wordCount -= 1;\n              wordIndex -= 1;\n              continue;\n            } // update the partitioning words\n\n\n            words[wordIndex] = word.substring(0, partIndex);\n            words[wordIndex + 1] = word.substring(partIndex) + words[wordIndex + 1];\n          } else {\n            // partitioning the long word into two words\n            words.splice(wordIndex, 1, word.substring(0, partIndex), word.substring(partIndex));\n            separators.splice(wordIndex, 0, '');\n            wordCount += 1; // if the previous line is not full\n\n            if (lineIndex && !full[lineIndex - 1]) {\n              lineIndex -= 1;\n            }\n          }\n\n          wordIndex -= 1;\n          continue;\n        }\n      } else if (!lines[lineIndex]) {\n        lines[lineIndex] = word;\n        full[lineIndex] = true;\n        lineIndex += 1;\n        continue;\n      }\n\n      lineIndex += 1;\n      wordIndex -= 1;\n    } // check whether the height of the entire text exceeds the rect height\n\n\n    if (height != null) {\n      // ensure line height\n      if (lineHeight == null) {\n        var heightValue = void 0; // use the same defaults as in V.prototype.text\n\n        if (styles.lineHeight === 'auto') {\n          heightValue = {\n            value: 1.5,\n            unit: 'em'\n          };\n        } else {\n          heightValue = NumberExt.parseCssNumeric(styles.lineHeight, ['em']) || {\n            value: 1,\n            unit: 'em'\n          };\n        }\n\n        lineHeight = heightValue.value;\n\n        if (heightValue.unit === 'em') {\n          if (Platform.IS_FIREFOX) {\n            lineHeight *= tspan.getBBox().height;\n          } else {\n            lineHeight *= telem.getBBox().height;\n          }\n        }\n      }\n\n      if (lineHeight * lines.length > height) {\n        // remove overflowing lines\n        var lastLineIndex = Math.floor(height / lineHeight) - 1;\n        var lastLine = lines[lastLineIndex];\n        var overflowLine = lines[lastLineIndex + 1];\n        lines.splice(lastLineIndex + 1);\n\n        if (lastLine == null) {\n          break;\n        } // add ellipsis\n\n\n        var ellipsis = options.ellipsis;\n\n        if (!ellipsis) {\n          break;\n        }\n\n        if (typeof ellipsis !== 'string') {\n          ellipsis = \"\\u2026\";\n        }\n\n        var fullLastLine = lastLine;\n\n        if (overflowLine && breakWord) {\n          fullLastLine += currentSeparator + overflowLine;\n        }\n\n        var lastCharIndex = fullLastLine.length;\n        var fixedLastLine = void 0;\n        var lastChar = void 0;\n\n        do {\n          lastChar = fullLastLine[lastCharIndex];\n          fixedLastLine = fullLastLine.substring(0, lastCharIndex);\n\n          if (!lastChar) {\n            fixedLastLine += lineSeprators[lastLineIndex];\n          } else if (lastChar.match(separator)) {\n            fixedLastLine += lastChar;\n          }\n\n          fixedLastLine += ellipsis;\n          tnode.data = fixedLastLine;\n\n          if (tspan.getComputedTextLength() <= width) {\n            lines[lastLineIndex] = fixedLastLine;\n            break;\n          }\n\n          lastCharIndex -= 1;\n        } while (lastCharIndex >= 0);\n\n        break;\n      }\n    }\n  }\n\n  if (shouldAppend) {\n    remove(svgDocument);\n  } else {\n    remove(telem);\n  }\n\n  return lines.join(eol);\n}","map":{"version":3,"sources":["../../../src/util/dom/text.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* eslint-disable no-control-regex */\nimport { NumberExt } from '../number';\nimport { Text } from '../text';\nimport { attr } from './attr';\nimport { Vector } from '../vector';\nimport { createSvgElement, empty, remove } from './elem';\nimport { Platform } from '../platform';\nfunction createTextPathNode(attrs, elem) {\n    const vel = Vector.create(elem);\n    const textPath = Vector.create('textPath');\n    const d = attrs.d;\n    if (d && attrs['xlink:href'] === undefined) {\n        const path = Vector.create('path').attr('d', d).appendTo(vel.defs());\n        textPath.attr('xlink:href', `#${path.id}`);\n    }\n    if (typeof attrs === 'object') {\n        textPath.attr(attrs);\n    }\n    return textPath.node;\n}\nfunction annotateTextLine(lineNode, lineAnnotations, options) {\n    const eol = options.eol;\n    const baseSize = options.baseSize;\n    const lineHeight = options.lineHeight;\n    let maxFontSize = 0;\n    let tspanNode;\n    const fontMetrics = {};\n    const lastJ = lineAnnotations.length - 1;\n    for (let j = 0; j <= lastJ; j += 1) {\n        let annotation = lineAnnotations[j];\n        let fontSize = null;\n        if (typeof annotation === 'object') {\n            const annotationAttrs = annotation.attrs;\n            const vTSpan = Vector.create('tspan', annotationAttrs);\n            tspanNode = vTSpan.node;\n            let t = annotation.t;\n            if (eol && j === lastJ) {\n                t += eol;\n            }\n            tspanNode.textContent = t;\n            // Per annotation className\n            const annotationClass = annotationAttrs.class;\n            if (annotationClass) {\n                vTSpan.addClass(annotationClass);\n            }\n            // set the list of indices of all the applied annotations\n            // in the `annotations` attribute. This list is a comma\n            // separated list of indices.\n            if (options.includeAnnotationIndices) {\n                vTSpan.attr('annotations', annotation.annotations.join(','));\n            }\n            // Check for max font size\n            fontSize = parseFloat(annotationAttrs['font-size']);\n            if (fontSize === undefined)\n                fontSize = baseSize;\n            if (fontSize && fontSize > maxFontSize)\n                maxFontSize = fontSize;\n        }\n        else {\n            if (eol && j === lastJ) {\n                annotation += eol;\n            }\n            tspanNode = document.createTextNode(annotation || ' ');\n            if (baseSize && baseSize > maxFontSize) {\n                maxFontSize = baseSize;\n            }\n        }\n        lineNode.appendChild(tspanNode);\n    }\n    if (maxFontSize) {\n        fontMetrics.maxFontSize = maxFontSize;\n    }\n    if (lineHeight) {\n        fontMetrics.lineHeight = lineHeight;\n    }\n    else if (maxFontSize) {\n        fontMetrics.lineHeight = maxFontSize * 1.2;\n    }\n    return fontMetrics;\n}\nconst emRegex = /em$/;\nfunction emToPx(em, fontSize) {\n    const numerical = parseFloat(em);\n    if (emRegex.test(em)) {\n        return numerical * fontSize;\n    }\n    return numerical;\n}\nfunction calculateDY(alignment, linesMetrics, baseSizePx, lineHeight) {\n    if (!Array.isArray(linesMetrics)) {\n        return 0;\n    }\n    const n = linesMetrics.length;\n    if (!n)\n        return 0;\n    let lineMetrics = linesMetrics[0];\n    const flMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n    let rLineHeights = 0;\n    const lineHeightPx = emToPx(lineHeight, baseSizePx);\n    for (let i = 1; i < n; i += 1) {\n        lineMetrics = linesMetrics[i];\n        const iLineHeight = emToPx(lineMetrics.lineHeight, baseSizePx) || lineHeightPx;\n        rLineHeights += iLineHeight;\n    }\n    const llMaxFont = emToPx(lineMetrics.maxFontSize, baseSizePx) || baseSizePx;\n    let dy;\n    switch (alignment) {\n        case 'middle':\n            dy = flMaxFont / 2 - 0.15 * llMaxFont - rLineHeights / 2;\n            break;\n        case 'bottom':\n            dy = -(0.25 * llMaxFont) - rLineHeights;\n            break;\n        default:\n        case 'top':\n            dy = 0.8 * flMaxFont;\n            break;\n    }\n    return dy;\n}\nexport function text(elem, content, options = {}) {\n    content = Text.sanitize(content); // eslint-disable-line\n    const eol = options.eol;\n    let textPath = options.textPath;\n    const verticalAnchor = options.textVerticalAnchor;\n    const namedVerticalAnchor = verticalAnchor === 'middle' ||\n        verticalAnchor === 'bottom' ||\n        verticalAnchor === 'top';\n    // Horizontal shift applied to all the lines but the first.\n    let x = options.x;\n    if (x === undefined) {\n        x = elem.getAttribute('x') || 0;\n    }\n    // Annotations\n    const iai = options.includeAnnotationIndices;\n    let annotations = options.annotations;\n    if (annotations && !Array.isArray(annotations)) {\n        annotations = [annotations];\n    }\n    // Shift all the <tspan> but first by one line (`1em`)\n    const defaultLineHeight = options.lineHeight;\n    const autoLineHeight = defaultLineHeight === 'auto';\n    const lineHeight = autoLineHeight ? '1.5em' : defaultLineHeight || '1em';\n    empty(elem);\n    attr(elem, {\n        // Preserve spaces, do not consecutive spaces to get collapsed to one.\n        'xml:space': 'preserve',\n        // An empty text gets rendered into the DOM in webkit-based browsers.\n        // In order to unify this behaviour across all browsers\n        // we rather hide the text element when it's empty.\n        display: content || options.displayEmpty ? null : 'none',\n    });\n    // Set default font-size if none\n    const strFontSize = attr(elem, 'font-size');\n    let fontSize = parseFloat(strFontSize);\n    if (!fontSize) {\n        fontSize = 16;\n        if ((namedVerticalAnchor || annotations) && !strFontSize) {\n            attr(elem, 'font-size', `${fontSize}`);\n        }\n    }\n    let containerNode;\n    if (textPath) {\n        // Now all the `<tspan>`s will be inside the `<textPath>`.\n        if (typeof textPath === 'string') {\n            textPath = { d: textPath };\n        }\n        containerNode = createTextPathNode(textPath, elem);\n    }\n    else {\n        containerNode = document.createDocumentFragment();\n    }\n    let dy;\n    let offset = 0;\n    let annotatedY;\n    const lines = content.split('\\n');\n    const linesMetrics = [];\n    const lastI = lines.length - 1;\n    for (let i = 0; i <= lastI; i += 1) {\n        dy = lineHeight;\n        let lineClassName = 'v-line';\n        const lineNode = createSvgElement('tspan');\n        let lineMetrics;\n        let line = lines[i];\n        if (line) {\n            if (annotations) {\n                // Find the *compacted* annotations for this line.\n                const lineAnnotations = Text.annotate(line, annotations, {\n                    offset: -offset,\n                    includeAnnotationIndices: iai,\n                });\n                lineMetrics = annotateTextLine(lineNode, lineAnnotations, {\n                    eol: i !== lastI && eol,\n                    baseSize: fontSize,\n                    lineHeight: autoLineHeight ? null : lineHeight,\n                    includeAnnotationIndices: iai,\n                });\n                // Get the line height based on the biggest font size\n                // in the annotations for this line.\n                const iLineHeight = lineMetrics.lineHeight;\n                if (iLineHeight && autoLineHeight && i !== 0) {\n                    dy = iLineHeight;\n                }\n                if (i === 0) {\n                    annotatedY = lineMetrics.maxFontSize * 0.8;\n                }\n            }\n            else {\n                if (eol && i !== lastI) {\n                    line += eol;\n                }\n                lineNode.textContent = line;\n            }\n        }\n        else {\n            // Make sure the textContent is never empty. If it is, add a dummy\n            // character and make it invisible, making the following lines correctly\n            // relatively positioned. `dy=1em` won't work with empty lines otherwise.\n            lineNode.textContent = '-';\n            lineClassName += ' v-empty-line';\n            const lineNodeStyle = lineNode.style;\n            lineNodeStyle.fillOpacity = 0;\n            lineNodeStyle.strokeOpacity = 0;\n            if (annotations) {\n                lineMetrics = {};\n            }\n        }\n        if (lineMetrics) {\n            linesMetrics.push(lineMetrics);\n        }\n        if (i > 0) {\n            lineNode.setAttribute('dy', dy);\n        }\n        // Firefox requires 'x' to be set on the first line\n        if (i > 0 || textPath) {\n            lineNode.setAttribute('x', x);\n        }\n        lineNode.className.baseVal = lineClassName;\n        containerNode.appendChild(lineNode);\n        offset += line.length + 1; // + 1 = newline character.\n    }\n    // Y Alignment calculation\n    if (namedVerticalAnchor) {\n        if (annotations) {\n            dy = calculateDY(verticalAnchor, linesMetrics, fontSize, lineHeight);\n        }\n        else if (verticalAnchor === 'top') {\n            // A shortcut for top alignment. It does not depend on font-size nor line-height\n            dy = '0.8em';\n        }\n        else {\n            let rh; // remaining height\n            if (lastI > 0) {\n                rh = parseFloat(lineHeight) || 1;\n                rh *= lastI;\n                if (!emRegex.test(lineHeight))\n                    rh /= fontSize;\n            }\n            else {\n                // Single-line text\n                rh = 0;\n            }\n            switch (verticalAnchor) {\n                case 'middle':\n                    dy = `${0.3 - rh / 2}em`;\n                    break;\n                case 'bottom':\n                    dy = `${-rh - 0.3}em`;\n                    break;\n                default:\n                    break;\n            }\n        }\n    }\n    else if (verticalAnchor === 0) {\n        dy = '0em';\n    }\n    else if (verticalAnchor) {\n        dy = verticalAnchor;\n    }\n    else {\n        // No vertical anchor is defined\n        dy = 0;\n        // Backwards compatibility - we change the `y` attribute instead of `dy`.\n        if (elem.getAttribute('y') == null) {\n            elem.setAttribute('y', `${annotatedY || '0.8em'}`);\n        }\n    }\n    const firstLine = containerNode.firstChild;\n    firstLine.setAttribute('dy', dy);\n    elem.appendChild(containerNode);\n}\nfunction splitText(text, separator, eol, hyphen) {\n    const words = [];\n    const separators = [];\n    if (separator != null) {\n        const parts = text.split(separator);\n        words.push(...parts);\n        if (typeof separator === 'string') {\n            for (let i = 0, l = parts.length - 1; i < l; i += 1) {\n                separators.push(separator);\n            }\n        }\n        else {\n            const seps = text.match(new RegExp(separator, 'g'));\n            for (let i = 0, l = parts.length - 1; i < l; i += 1) {\n                separators.push(seps ? seps[i] : '');\n            }\n        }\n    }\n    else {\n        let word = '';\n        for (let i = 0, l = text.length; i < l; i += 1) {\n            const char = text[i];\n            if (char === ' ') {\n                words.push(word);\n                separators.push(' ');\n                word = '';\n            }\n            else if (char.match(/[^\\x00-\\xff]/)) {\n                // split double byte character\n                if (word.length) {\n                    words.push(word);\n                    separators.push('');\n                }\n                words.push(char);\n                separators.push('');\n                word = '';\n            }\n            else {\n                word += char;\n            }\n        }\n        if (word.length) {\n            words.push(word);\n        }\n    }\n    // end-of-line\n    for (let i = 0; i < words.length; i += 1) {\n        const word = words[i];\n        if (word.indexOf(eol) >= 0 && word.length > 1) {\n            const parts = word.split(eol);\n            for (let j = 0, k = parts.length - 1; j < k; j += 1) {\n                parts.splice(2 * j + 1, 0, eol);\n            }\n            const valids = parts.filter((part) => part !== '');\n            words.splice(i, 1, ...valids);\n            const seps = valids.map(() => '');\n            seps.pop();\n            separators.splice(i, 0, ...seps);\n        }\n    }\n    // hyphen\n    for (let i = 0; i < words.length; i += 1) {\n        const word = words[i];\n        const index = word.search(hyphen);\n        if (index > 0 && index < word.length - 1) {\n            words.splice(i, 1, word.substring(0, index + 1), word.substring(index + 1));\n            separators.splice(i, 0, '');\n        }\n    }\n    return { words, separators };\n}\nexport function breakText(text, size, styles = {}, options = {}) {\n    const width = size.width;\n    const height = size.height;\n    const svgDocument = options.svgDocument || createSvgElement('svg');\n    const telem = createSvgElement('text');\n    const tspan = createSvgElement('tspan');\n    const tnode = document.createTextNode('');\n    attr(telem, styles);\n    telem.appendChild(tspan);\n    // Prevent flickering\n    telem.style.opacity = '0';\n    // Prevent FF from throwing an uncaught exception when `getBBox()`\n    // called on element that is not in the render tree (is not measurable).\n    // <tspan>.getComputedTextLength() returns always 0 in this case.\n    // Note that the `textElement` resp. `textSpan` can become hidden\n    // when it's appended to the DOM and a `display: none` CSS stylesheet\n    // rule gets applied.\n    telem.style.display = 'block';\n    tspan.style.display = 'block';\n    tspan.appendChild(tnode);\n    svgDocument.appendChild(telem);\n    const shouldAppend = svgDocument.parentNode == null;\n    if (shouldAppend) {\n        document.body.appendChild(svgDocument);\n    }\n    const eol = options.eol || '\\n';\n    const separator = options.separator || ' ';\n    const hyphen = options.hyphen ? new RegExp(options.hyphen) : /[^\\w\\d]/;\n    const breakWord = options.breakWord !== false;\n    const full = [];\n    const lineSeprators = {};\n    let lines = [];\n    let partIndex;\n    // let hyphenIndex\n    let lineHeight;\n    let currentSeparator;\n    const { words, separators } = splitText(text, options.separator, eol, hyphen);\n    for (let wordIndex = 0, lineIndex = 0, wordCount = words.length; wordIndex < wordCount; wordIndex += 1) {\n        const word = words[wordIndex];\n        // empty word\n        if (!word) {\n            continue;\n        }\n        // end of line\n        if (word === eol) {\n            full[lineIndex] = true;\n            // start a new line\n            lineIndex += 1;\n            lines[lineIndex] = '';\n            continue;\n        }\n        if (lines[lineIndex] != null) {\n            currentSeparator = separators[wordIndex - 1] || '';\n            tnode.data = `${lines[lineIndex]}${currentSeparator}${word}`;\n        }\n        else {\n            tnode.data = word;\n        }\n        if (tspan.getComputedTextLength() <= width) {\n            // update line\n            lines[lineIndex] = tnode.data;\n            lineSeprators[lineIndex] = separators[wordIndex];\n            // when is partitioning, put rest of the word onto next line\n            if (partIndex) {\n                full[lineIndex] = true;\n                lineIndex += 1;\n                partIndex = 0;\n            }\n        }\n        else {\n            if (breakWord) {\n                // word is too long to put in one line or is partitioning\n                if (!lines[lineIndex] || partIndex) {\n                    const isPartition = !!partIndex;\n                    const isCharacter = word.length === 1;\n                    partIndex = word.length - 1;\n                    if (isPartition || isCharacter) {\n                        // word has only one character.\n                        if (isCharacter) {\n                            if (!lines[lineIndex]) {\n                                // can't fit this text within our rect\n                                lines = [];\n                                break;\n                            }\n                            // partitioning didn't help on the non-empty line\n                            // try again, but this time start with a new line\n                            // cancel partitions created\n                            words.splice(wordIndex, 2, word + words[wordIndex + 1]);\n                            separators.splice(wordIndex + 1, 1);\n                            full[lineIndex] = true;\n                            lineIndex += 1;\n                            wordCount -= 1;\n                            wordIndex -= 1;\n                            continue;\n                        }\n                        // update the partitioning words\n                        words[wordIndex] = word.substring(0, partIndex);\n                        words[wordIndex + 1] =\n                            word.substring(partIndex) + words[wordIndex + 1];\n                    }\n                    else {\n                        // partitioning the long word into two words\n                        words.splice(wordIndex, 1, word.substring(0, partIndex), word.substring(partIndex));\n                        separators.splice(wordIndex, 0, '');\n                        wordCount += 1;\n                        // if the previous line is not full\n                        if (lineIndex && !full[lineIndex - 1]) {\n                            lineIndex -= 1;\n                        }\n                    }\n                    wordIndex -= 1;\n                    continue;\n                }\n            }\n            else if (!lines[lineIndex]) {\n                lines[lineIndex] = word;\n                full[lineIndex] = true;\n                lineIndex += 1;\n                continue;\n            }\n            lineIndex += 1;\n            wordIndex -= 1;\n        }\n        // check whether the height of the entire text exceeds the rect height\n        if (height != null) {\n            // ensure line height\n            if (lineHeight == null) {\n                let heightValue;\n                // use the same defaults as in V.prototype.text\n                if (styles.lineHeight === 'auto') {\n                    heightValue = { value: 1.5, unit: 'em' };\n                }\n                else {\n                    heightValue = NumberExt.parseCssNumeric(styles.lineHeight, [\n                        'em',\n                    ]) || {\n                        value: 1,\n                        unit: 'em',\n                    };\n                }\n                lineHeight = heightValue.value;\n                if (heightValue.unit === 'em') {\n                    if (Platform.IS_FIREFOX) {\n                        lineHeight *= tspan.getBBox().height;\n                    }\n                    else {\n                        lineHeight *= telem.getBBox().height;\n                    }\n                }\n            }\n            if (lineHeight * lines.length > height) {\n                // remove overflowing lines\n                const lastLineIndex = Math.floor(height / lineHeight) - 1;\n                const lastLine = lines[lastLineIndex];\n                const overflowLine = lines[lastLineIndex + 1];\n                lines.splice(lastLineIndex + 1);\n                if (lastLine == null) {\n                    break;\n                }\n                // add ellipsis\n                let ellipsis = options.ellipsis;\n                if (!ellipsis) {\n                    break;\n                }\n                if (typeof ellipsis !== 'string') {\n                    ellipsis = '\\u2026';\n                }\n                let fullLastLine = lastLine;\n                if (overflowLine && breakWord) {\n                    fullLastLine += currentSeparator + overflowLine;\n                }\n                let lastCharIndex = fullLastLine.length;\n                let fixedLastLine;\n                let lastChar;\n                do {\n                    lastChar = fullLastLine[lastCharIndex];\n                    fixedLastLine = fullLastLine.substring(0, lastCharIndex);\n                    if (!lastChar) {\n                        fixedLastLine += lineSeprators[lastLineIndex];\n                    }\n                    else if (lastChar.match(separator)) {\n                        fixedLastLine += lastChar;\n                    }\n                    fixedLastLine += ellipsis;\n                    tnode.data = fixedLastLine;\n                    if (tspan.getComputedTextLength() <= width) {\n                        lines[lastLineIndex] = fixedLastLine;\n                        break;\n                    }\n                    lastCharIndex -= 1;\n                } while (lastCharIndex >= 0);\n                break;\n            }\n        }\n    }\n    if (shouldAppend) {\n        remove(svgDocument);\n    }\n    else {\n        remove(telem);\n    }\n    return lines.join(eol);\n}\n//# sourceMappingURL=text.js.map"]},"metadata":{},"sourceType":"module"}