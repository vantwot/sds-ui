{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport rewind from '@mapbox/geojson-rewind';\nimport { getCoords } from '@turf/invariant';\nimport * as turfMeta from '@turf/meta';\nexport default function geoJSON(data, cfg) {\n  var resultData = [];\n  var featureKeys = {};\n  data.features = data.features.filter(function (item) {\n    var geometry = item.geometry;\n    return item != null && geometry && geometry.type && geometry.coordinates && geometry.coordinates.length > 0;\n  });\n  rewind(data, true);\n\n  if (data.features.length === 0) {\n    return {\n      dataArray: [],\n      featureKeys: featureKeys\n    };\n  }\n\n  var i = 0;\n  turfMeta.flattenEach(data, function (currentFeature, featureIndex) {\n    var coord = getCoords(currentFeature);\n    var id = featureIndex;\n\n    var dataItem = _objectSpread(_objectSpread({}, currentFeature.properties), {}, {\n      coordinates: coord,\n      _id: id\n    });\n\n    resultData.push(dataItem);\n  });\n  return {\n    dataArray: resultData,\n    featureKeys: featureKeys\n  };\n}","map":{"version":3,"sources":["../../src/parser/geojson.ts"],"names":["resultData","featureKeys","data","geometry","item","rewind","dataArray","i","turfMeta","coord","getCoords","id","dataItem","currentFeature","coordinates","_id"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AACA,OAAA,MAAA,MAAA,wBAAA;AAQA,SAAA,SAAA,QAAA,iBAAA;AACA,OAAO,KAAP,QAAA,MAAA,YAAA;AASA,eAAe,SAAA,OAAA,CAAA,IAAA,EAAA,GAAA,EAGA;AACb,MAAMA,UAA4B,GAAlC,EAAA;AACA,MAAMC,WAAwB,GAA9B,EAAA;AACAC,EAAAA,IAAI,CAAJA,QAAAA,GAAgB,IAAI,CAAJ,QAAA,CAAA,MAAA,CAAqB,UAAA,IAAA,EAAmB;AACtD,QAAMC,QAAyB,GAAGC,IAAI,CAAtC,QAAA;AACA,WACEA,IAAI,IAAJA,IAAAA,IAAAA,QAAAA,IAEAD,QAAQ,CAFRC,IAAAA,IAGAD,QAAQ,CAHRC,WAAAA,IAIAD,QAAQ,CAARA,WAAAA,CAAAA,MAAAA,GALF,CAAA;AAFFD,GAAgB,CAAhBA;AAUAG,EAAAA,MAAM,CAAA,IAAA,EAANA,IAAM,CAANA;;AACA,MAAIH,IAAI,CAAJA,QAAAA,CAAAA,MAAAA,KAAJ,CAAA,EAAgC;AAC9B,WAAO;AACLI,MAAAA,SAAS,EADJ,EAAA;AAELL,MAAAA,WAAW,EAAXA;AAFK,KAAP;AAID;;AAED,MAAMM,CAAC,GAAP,CAAA;AAEAC,EAAAA,QAAQ,CAARA,WAAAA,CAAAA,IAAAA,EAEE,UAAA,cAAA,EAAA,YAAA,EAA2E;AACzE,QAAMC,KAAK,GAAGC,SAAS,CAAvB,cAAuB,CAAvB;AACA,QAAMC,EAAE,GAAR,YAAA;;AACA,QAAMC,QAAwB,GAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EACzBC,cAAc,CADW,UAAA,CAAA,EAAA,EAAA,EAAA;AAE5BC,MAAAA,WAAW,EAFiB,KAAA;AAG5BC,MAAAA,GAAG,EAAEJ;AAHuB,KAAA,CAA9B;;AAKAX,IAAAA,UAAU,CAAVA,IAAAA,CAAAA,QAAAA;AAVJQ,GAAAA;AAcA,SAAO;AACLF,IAAAA,SAAS,EADJ,UAAA;AAELL,IAAAA,WAAW,EAAXA;AAFK,GAAP;AAID","sourcesContent":["// @ts-ignore\nimport rewind from '@mapbox/geojson-rewind';\nimport {\n  Feature,\n  FeatureCollection,\n  Geometries,\n  Geometry,\n  Properties,\n} from '@turf/helpers';\nimport { getCoords } from '@turf/invariant';\nimport * as turfMeta from '@turf/meta';\nimport { IFeatureKey, IParseDataItem, IParserData } from '../interface';\ninterface IGeoJSON {\n  features: object[];\n}\ninterface IParserCFG {\n  idField?: string;\n  [key: string]: any;\n}\nexport default function geoJSON(\n  data: FeatureCollection<Geometries, Properties>,\n  cfg?: IParserCFG,\n): IParserData {\n  const resultData: IParseDataItem[] = [];\n  const featureKeys: IFeatureKey = {};\n  data.features = data.features.filter((item: Feature) => {\n    const geometry: Geometry | null = item.geometry as Geometry;\n    return (\n      item != null &&\n      geometry &&\n      geometry.type &&\n      geometry.coordinates &&\n      geometry.coordinates.length > 0\n    );\n  });\n  rewind(data, true); // 设置地理多边形方向 If clockwise is true, the outer ring is clockwise, otherwise it is counterclockwise.\n  if (data.features.length === 0) {\n    return {\n      dataArray: [],\n      featureKeys,\n    };\n  }\n  // 数据为空时处理\n  const i = 0;\n  // multi polygon 拆分\n  turfMeta.flattenEach(\n    data,\n    (currentFeature: Feature<Geometries, Properties>, featureIndex: number) => {\n      const coord = getCoords(currentFeature);\n      const id = featureIndex;\n      const dataItem: IParseDataItem = {\n        ...currentFeature.properties,\n        coordinates: coord,\n        _id: id,\n      };\n      resultData.push(dataItem);\n      // }\n    },\n  );\n  return {\n    dataArray: resultData,\n    featureKeys,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}