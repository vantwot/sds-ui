{"ast":null,"code":"import { Line } from '../../geometry';\nexport function offset(p1, p2, offset) {\n  var tx;\n\n  if (typeof offset === 'object') {\n    if (Number.isFinite(offset.y)) {\n      var line = new Line(p2, p1);\n\n      var _line$parallel = line.parallel(offset.y),\n          start = _line$parallel.start,\n          end = _line$parallel.end;\n\n      p2 = start; // eslint-disable-line\n\n      p1 = end; // eslint-disable-line\n    }\n\n    tx = offset.x;\n  } else {\n    tx = offset;\n  }\n\n  if (tx == null || !Number.isFinite(tx)) {\n    return p1;\n  }\n\n  var length = p1.distance(p2);\n\n  if (tx === 0 && length > 0) {\n    return p1;\n  }\n\n  return p1.move(p2, -Math.min(tx, length - 1));\n}\nexport function getStrokeWidth(magnet) {\n  var stroke = magnet.getAttribute('stroke-width');\n\n  if (stroke === null) {\n    return 0;\n  }\n\n  return parseFloat(stroke) || 0;\n}\nexport function findShapeNode(magnet) {\n  if (magnet == null) {\n    return null;\n  }\n\n  var node = magnet;\n\n  do {\n    var tagName = node.tagName;\n    if (typeof tagName !== 'string') return null;\n    tagName = tagName.toUpperCase();\n\n    if (tagName === 'G') {\n      node = node.firstElementChild;\n    } else if (tagName === 'TITLE') {\n      node = node.nextElementSibling;\n    } else break;\n  } while (node);\n\n  return node;\n}","map":{"version":3,"sources":["../../../src/registry/connection-point/util.ts"],"names":[],"mappings":"AAAA,SAAgB,IAAhB,QAA4B,gBAA5B;AAEA,OAAM,SAAU,MAAV,CACJ,EADI,EAEJ,EAFI,EAGJ,MAHI,EAG6B;AAEjC,MAAI,EAAJ;;AACA,MAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,QAAI,MAAM,CAAC,QAAP,CAAgB,MAAM,CAAC,CAAvB,CAAJ,EAA+B;AAC7B,UAAM,IAAI,GAAG,IAAI,IAAJ,CAAS,EAAT,EAAa,EAAb,CAAb;;AACA,2BAAuB,IAAI,CAAC,QAAL,CAAc,MAAM,CAAC,CAArB,CAAvB;AAAA,UAAQ,KAAR,kBAAQ,KAAR;AAAA,UAAe,GAAf,kBAAe,GAAf;;AACA,MAAA,EAAE,GAAG,KAAL,CAH6B,CAGlB;;AACX,MAAA,EAAE,GAAG,GAAL,CAJ6B,CAIpB;AACV;;AACD,IAAA,EAAE,GAAG,MAAM,CAAC,CAAZ;AACD,GARD,MAQO;AACL,IAAA,EAAE,GAAG,MAAL;AACD;;AAED,MAAI,EAAE,IAAI,IAAN,IAAc,CAAC,MAAM,CAAC,QAAP,CAAgB,EAAhB,CAAnB,EAAwC;AACtC,WAAO,EAAP;AACD;;AAED,MAAM,MAAM,GAAG,EAAE,CAAC,QAAH,CAAY,EAAZ,CAAf;;AACA,MAAI,EAAE,KAAK,CAAP,IAAY,MAAM,GAAG,CAAzB,EAA4B;AAC1B,WAAO,EAAP;AACD;;AACD,SAAO,EAAE,CAAC,IAAH,CAAQ,EAAR,EAAY,CAAC,IAAI,CAAC,GAAL,CAAS,EAAT,EAAa,MAAM,GAAG,CAAtB,CAAb,CAAP;AACD;AAED,OAAM,SAAU,cAAV,CAAyB,MAAzB,EAA2C;AAC/C,MAAM,MAAM,GAAG,MAAM,CAAC,YAAP,CAAoB,cAApB,CAAf;;AACA,MAAI,MAAM,KAAK,IAAf,EAAqB;AACnB,WAAO,CAAP;AACD;;AACD,SAAO,UAAU,CAAC,MAAD,CAAV,IAAsB,CAA7B;AACD;AAED,OAAM,SAAU,aAAV,CAAwB,MAAxB,EAAuC;AAC3C,MAAI,MAAM,IAAI,IAAd,EAAoB;AAClB,WAAO,IAAP;AACD;;AAED,MAAI,IAAI,GAAG,MAAX;;AACA,KAAG;AACD,QAAI,OAAO,GAAG,IAAI,CAAC,OAAnB;AACA,QAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC,OAAO,IAAP;AACjC,IAAA,OAAO,GAAG,OAAO,CAAC,WAAR,EAAV;;AACA,QAAI,OAAO,KAAK,GAAhB,EAAqB;AACnB,MAAA,IAAI,GAAG,IAAI,CAAC,iBAAZ;AACD,KAFD,MAEO,IAAI,OAAO,KAAK,OAAhB,EAAyB;AAC9B,MAAA,IAAI,GAAG,IAAI,CAAC,kBAAZ;AACD,KAFM,MAEA;AACR,GATD,QASS,IATT;;AAWA,SAAO,IAAP;AACD","sourceRoot":"","sourcesContent":["import { Line } from '../../geometry';\nexport function offset(p1, p2, offset) {\n    let tx;\n    if (typeof offset === 'object') {\n        if (Number.isFinite(offset.y)) {\n            const line = new Line(p2, p1);\n            const { start, end } = line.parallel(offset.y);\n            p2 = start; // eslint-disable-line\n            p1 = end; // eslint-disable-line\n        }\n        tx = offset.x;\n    }\n    else {\n        tx = offset;\n    }\n    if (tx == null || !Number.isFinite(tx)) {\n        return p1;\n    }\n    const length = p1.distance(p2);\n    if (tx === 0 && length > 0) {\n        return p1;\n    }\n    return p1.move(p2, -Math.min(tx, length - 1));\n}\nexport function getStrokeWidth(magnet) {\n    const stroke = magnet.getAttribute('stroke-width');\n    if (stroke === null) {\n        return 0;\n    }\n    return parseFloat(stroke) || 0;\n}\nexport function findShapeNode(magnet) {\n    if (magnet == null) {\n        return null;\n    }\n    let node = magnet;\n    do {\n        let tagName = node.tagName;\n        if (typeof tagName !== 'string')\n            return null;\n        tagName = tagName.toUpperCase();\n        if (tagName === 'G') {\n            node = node.firstElementChild;\n        }\n        else if (tagName === 'TITLE') {\n            node = node.nextElementSibling;\n        }\n        else\n            break;\n    } while (node);\n    return node;\n}\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}