{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport { lngLatToMeters } from '@antv/l7-utils';\nimport earcut from 'earcut';\nimport { vec3 } from 'gl-matrix';\nimport { EARTH_RADIUS, EARTH_RADIUS_OUTER, EARTH_SEGMENTS, lglt2xyz, primitiveSphere } from '../earth/utils';\nimport ExtrudePolyline from '../utils/extrude_polyline';\nimport { calculateCentroid } from '../utils/geo';\nimport extrudePolygon, { extrude_PolygonNormal, fillPolygon } from './shape/extrude';\nimport { geometryShape } from './shape/Path';\nvar GeometryCache = {};\nexport function PointFillTriangulation(feature) {\n  var coordinates = calculateCentroid(feature.coordinates);\n  return {\n    vertices: [].concat(_toConsumableArray(coordinates), _toConsumableArray(coordinates), _toConsumableArray(coordinates), _toConsumableArray(coordinates)),\n    indices: [0, 1, 2, 2, 3, 0],\n    size: coordinates.length\n  };\n}\nexport function GlobelPointFillTriangulation(feature) {\n  var coordinates = calculateCentroid(feature.coordinates);\n  var xyz = lglt2xyz(coordinates);\n  return {\n    vertices: [].concat(_toConsumableArray(xyz), _toConsumableArray(xyz), _toConsumableArray(xyz), _toConsumableArray(xyz)),\n    indices: [0, 1, 2, 2, 3, 0],\n    size: xyz.length\n  };\n}\nexport function PointExtrudeTriangulation(feature) {\n  var shape = feature.shape;\n\n  var _getGeometry = getGeometry(shape, false),\n      positions = _getGeometry.positions,\n      index = _getGeometry.index,\n      normals = _getGeometry.normals;\n\n  return {\n    vertices: positions,\n    indices: index,\n    normals: normals,\n    size: 5\n  };\n}\nexport function PointImageTriangulation(feature) {\n  var coordinates = calculateCentroid(feature.coordinates);\n  return {\n    vertices: _toConsumableArray(coordinates),\n    indices: [0],\n    size: coordinates.length\n  };\n}\nexport function LineTriangulation(feature) {\n  var coordinates = feature.coordinates,\n      originCoordinates = feature.originCoordinates,\n      version = feature.version;\n  var line = new ExtrudePolyline({\n    dash: true,\n    join: 'bevel'\n  });\n\n  if (version === 'GAODE2.x') {\n    var path1 = coordinates;\n\n    if (!Array.isArray(path1[0][0])) {\n      path1 = [coordinates];\n    }\n\n    var path2 = originCoordinates;\n\n    if (!Array.isArray(path2[0][0])) {\n      path2 = [originCoordinates];\n    }\n\n    for (var i = 0; i < path1.length; i++) {\n      var item1 = path1[i];\n      var item2 = path2[i];\n      line.extrude_gaode2(item1, item2);\n    }\n  } else {\n    var path = coordinates;\n\n    if (!Array.isArray(path[0][0])) {\n      path = [coordinates];\n    }\n\n    path.forEach(function (item) {\n      line.extrude(item);\n    });\n  }\n\n  var linebuffer = line.complex;\n  return {\n    vertices: linebuffer.positions,\n    indices: linebuffer.indices,\n    normals: linebuffer.normals,\n    size: 6\n  };\n}\nexport function polygonTriangulation(feature) {\n  var coordinates = feature.coordinates;\n  var flattengeo = earcut.flatten(coordinates);\n  var vertices = flattengeo.vertices,\n      dimensions = flattengeo.dimensions,\n      holes = flattengeo.holes;\n  return {\n    indices: earcut(vertices, holes, dimensions),\n    vertices: vertices,\n    size: dimensions\n  };\n}\nexport function PolygonExtrudeTriangulation(feature) {\n  var coordinates = feature.coordinates;\n\n  var _extrude_PolygonNorma = extrude_PolygonNormal(coordinates, true),\n      positions = _extrude_PolygonNorma.positions,\n      index = _extrude_PolygonNorma.index,\n      normals = _extrude_PolygonNorma.normals;\n\n  return {\n    vertices: positions,\n    indices: index,\n    normals: normals,\n    size: 5\n  };\n}\nexport function HeatmapGridTriangulation(feature) {\n  var shape = feature.shape;\n\n  var _getHeatmapGeometry = getHeatmapGeometry(shape),\n      positions = _getHeatmapGeometry.positions,\n      index = _getHeatmapGeometry.index;\n\n  return {\n    vertices: positions,\n    indices: index,\n    size: 3\n  };\n}\nexport function RasterImageTriangulation(feature) {\n  var coordinates = feature.coordinates;\n  var positions = [].concat(_toConsumableArray(coordinates[0]), [0, 0, 1, coordinates[1][0], coordinates[0][1], 0, 1, 1], _toConsumableArray(coordinates[1]), [0, 1, 0], _toConsumableArray(coordinates[0]), [0, 0, 1], _toConsumableArray(coordinates[1]), [0, 1, 0, coordinates[0][0], coordinates[1][1], 0, 0, 0]);\n  var indexs = [0, 1, 2, 3, 4, 5];\n  return {\n    vertices: positions,\n    indices: indexs,\n    size: 5\n  };\n}\nexport function LineArcTriangulation(feature, segmentNumber) {\n  var segNum = segmentNumber ? segmentNumber : 30;\n  var coordinates = feature.coordinates;\n  var positions = [];\n  var indexArray = [];\n\n  var _loop = function _loop(i) {\n    positions.push(i, 1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1], i, -1, i, coordinates[0][0], coordinates[0][1], coordinates[1][0], coordinates[1][1]);\n\n    if (i !== segNum - 1) {\n      indexArray.push.apply(indexArray, _toConsumableArray([0, 1, 2, 1, 3, 2].map(function (v) {\n        return i * 2 + v;\n      })));\n    }\n  };\n\n  for (var i = 0; i < segNum; i++) {\n    _loop(i);\n  }\n\n  return {\n    vertices: positions,\n    indices: indexArray,\n    size: 7\n  };\n}\nexport function HeatmapTriangulation(feature) {\n  var coordinates = feature.coordinates;\n\n  if (coordinates.length === 2) {\n    coordinates.push(0);\n  }\n\n  var size = feature.size;\n  var dir = addDir(-1, 1);\n  var dir1 = addDir(1, 1);\n  var dir2 = addDir(-1, -1);\n  var dir3 = addDir(1, -1);\n  var positions = [].concat(_toConsumableArray(coordinates), _toConsumableArray(dir), _toConsumableArray(coordinates), _toConsumableArray(dir2), _toConsumableArray(coordinates), _toConsumableArray(dir3), _toConsumableArray(coordinates), _toConsumableArray(dir1));\n  var indexArray = [0, 1, 2, 3, 0, 2];\n  return {\n    vertices: positions,\n    indices: indexArray,\n    size: 5\n  };\n}\n\nfunction getGeometry(shape) {\n  var needFlat = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n  if (GeometryCache && GeometryCache[shape]) {\n    return GeometryCache[shape];\n  }\n\n  var path = geometryShape[shape] ? geometryShape[shape]() : geometryShape.cylinder();\n  var geometry = extrude_PolygonNormal([path], needFlat);\n  GeometryCache[shape] = geometry;\n  return geometry;\n}\n\nfunction computeVertexNormals(positions, indexArray) {\n  var dim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 3;\n  var needFlat = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  var normals = new Float32Array(positions.length / dim * 3);\n  var vA;\n  var vB;\n  var vC;\n  var cb = vec3.create();\n  var ab = vec3.create();\n  var normal = vec3.create();\n\n  for (var i = 0, li = indexArray.length; i < li; i += 3) {\n    vA = indexArray[i + 0] * 3;\n    vB = indexArray[i + 1] * 3;\n    vC = indexArray[i + 2] * 3;\n    var p1 = [positions[vA], positions[vA + 1]];\n    var p2 = [positions[vB], positions[vB + 1]];\n    var p3 = [positions[vC], positions[vC + 1]];\n\n    if (needFlat) {\n      p1 = lngLatToMeters(p1);\n      p2 = lngLatToMeters(p2);\n      p3 = lngLatToMeters(p3);\n    }\n\n    var _p = p1,\n        _p2 = _slicedToArray(_p, 2),\n        ax = _p2[0],\n        ay = _p2[1];\n\n    var pA = vec3.fromValues(ax, ay, positions[vA + 2]);\n\n    var _p3 = p2,\n        _p4 = _slicedToArray(_p3, 2),\n        bx = _p4[0],\n        by = _p4[1];\n\n    var pB = vec3.fromValues(bx, by, positions[vB + 2]);\n\n    var _p5 = p3,\n        _p6 = _slicedToArray(_p5, 2),\n        cx = _p6[0],\n        cy = _p6[1];\n\n    var pC = vec3.fromValues(cx, cy, positions[vC + 2]);\n    vec3.sub(cb, pC, pB);\n    vec3.sub(ab, pA, pB);\n    vec3.cross(normal, cb, ab);\n    normals[vA] += cb[0];\n    normals[vA + 1] += cb[1];\n    normals[vA + 2] += cb[2];\n    normals[vB] += cb[0];\n    normals[vB + 1] += cb[1];\n    normals[vB + 2] += cb[2];\n    normals[vC] += cb[0];\n    normals[vC + 1] += cb[1];\n    normals[vC + 2] += cb[2];\n  }\n\n  normalizeNormals(normals);\n  return normals;\n}\n\nfunction normalizeNormals(normals) {\n  for (var i = 0, li = normals.length; i < li; i += 3) {\n    var normal = vec3.fromValues(normals[i], normals[i + 1], normals[i + 2]);\n    var newNormal = vec3.create();\n    vec3.normalize(newNormal, normal);\n    normals.set(newNormal, i);\n  }\n}\n\nfunction checkIsClosed(points) {\n  var p1 = points[0][0];\n  var p2 = points[0][points[0].length - 1];\n  return p1[0] === p2[0] && p1[1] === p2[1];\n}\n\nfunction getHeatmapGeometry(shape) {\n  var shape3d = ['cylinder', 'triangleColumn', 'hexagonColumn', 'squareColumn'];\n  var path = geometryShape[shape] ? geometryShape[shape]() : geometryShape.circle();\n  var geometry = shape3d.indexOf(shape) === -1 ? fillPolygon([path]) : extrudePolygon([path]);\n  return geometry;\n}\n\nfunction addDir(dirX, dirY) {\n  var x = (dirX + 1) / 2;\n  var y = (dirY + 1) / 2;\n  return [x, y];\n}\n\nexport function earthTriangulation() {\n  var earthmesh = primitiveSphere(EARTH_RADIUS, {\n    segments: EARTH_SEGMENTS\n  });\n  var positionsArr = earthmesh.positionsArr,\n      indicesArr = earthmesh.indicesArr,\n      normalArr = earthmesh.normalArr;\n  return {\n    vertices: positionsArr,\n    indices: indicesArr,\n    size: 5,\n    normals: normalArr\n  };\n}\nexport function earthOuterTriangulation() {\n  var earthmesh = primitiveSphere(EARTH_RADIUS + EARTH_RADIUS_OUTER, {\n    segments: EARTH_SEGMENTS\n  });\n  var positionsArr = earthmesh.positionsArr,\n      indicesArr = earthmesh.indicesArr,\n      normalArr = earthmesh.normalArr;\n  return {\n    vertices: positionsArr,\n    indices: indicesArr,\n    size: 5,\n    normals: normalArr\n  };\n}","map":{"version":3,"sources":["../../src/core/triangulation.ts"],"names":["GeometryCache","coordinates","calculateCentroid","feature","vertices","indices","size","length","xyz","lglt2xyz","shape","positions","index","normals","getGeometry","originCoordinates","version","line","dash","join","path1","Array","path2","i","item1","item2","path","linebuffer","flattengeo","earcut","dimensions","holes","extrude_PolygonNormal","getHeatmapGeometry","indexs","segNum","segmentNumber","indexArray","dir","addDir","dir1","dir2","dir3","needFlat","geometryShape","geometry","dim","cb","vec3","ab","normal","li","vA","vB","vC","p1","p2","p3","lngLatToMeters","ax","ay","pA","bx","by","pB","cx","cy","pC","normalizeNormals","newNormal","points","shape3d","fillPolygon","extrudePolygon","x","dirX","y","dirY","earthmesh","primitiveSphere","segments","EARTH_SEGMENTS","positionsArr","indicesArr","normalArr","EARTH_RADIUS"],"mappings":"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","sourcesContent":["import { IEncodeFeature } from '@antv/l7-core';\nimport { aProjectFlat, lngLatToMeters } from '@antv/l7-utils';\nimport earcut from 'earcut';\n// @ts-ignore\nimport { mat4, vec3 } from 'gl-matrix';\nimport {\n  EARTH_RADIUS,\n  EARTH_RADIUS_OUTER,\n  EARTH_SEGMENTS,\n  lglt2xyz,\n  primitiveSphere,\n} from '../earth/utils';\nimport ExtrudePolyline from '../utils/extrude_polyline';\nimport { calculateCentroid } from '../utils/geo';\nimport extrudePolygon, {\n  extrude_PolygonNormal,\n  fillPolygon,\n  IExtrudeGeomety,\n} from './shape/extrude';\nimport {\n  geometryShape,\n  IPosition,\n  ShapeType2D,\n  ShapeType3D,\n} from './shape/Path';\ntype IShape = ShapeType2D & ShapeType3D;\ninterface IGeometryCache {\n  [key: string]: IExtrudeGeomety;\n}\nconst GeometryCache: IGeometryCache = {};\n\n/**\n * 计算2D 填充点图顶点\n * @param feature 映射feature\n */\n\nexport function PointFillTriangulation(feature: IEncodeFeature) {\n  const coordinates = calculateCentroid(feature.coordinates);\n  return {\n    vertices: [...coordinates, ...coordinates, ...coordinates, ...coordinates],\n    indices: [0, 1, 2, 2, 3, 0],\n    size: coordinates.length,\n  };\n}\n/**\n * 计算2D 填充点图顶点 (地球模式)\n * @param feature 映射feature\n */\nexport function GlobelPointFillTriangulation(feature: IEncodeFeature) {\n  const coordinates = calculateCentroid(feature.coordinates);\n  const xyz = lglt2xyz(coordinates as [number, number]);\n  return {\n    vertices: [...xyz, ...xyz, ...xyz, ...xyz],\n    indices: [0, 1, 2, 2, 3, 0],\n    size: xyz.length,\n  };\n}\n\n/**\n * 计算3D 拉伸点图\n * @param feature 映射feature\n */\nexport function PointExtrudeTriangulation(feature: IEncodeFeature) {\n  const { shape } = feature;\n  const { positions, index, normals } = getGeometry(\n    shape as ShapeType3D,\n    false,\n  );\n  return {\n    vertices: positions,\n    indices: index,\n    normals,\n    size: 5,\n  };\n}\n\n/**\n * 计算图片标注\n * @param feature 映射feature\n */\nexport function PointImageTriangulation(feature: IEncodeFeature) {\n  const coordinates = calculateCentroid(feature.coordinates);\n  return {\n    vertices: [...coordinates],\n    indices: [0],\n    size: coordinates.length,\n  };\n}\n\n/**\n * 线三角化\n * @param feature 映射feature\n */\nexport function LineTriangulation(feature: IEncodeFeature) {\n  const { coordinates, originCoordinates, version } = feature;\n  // let path = coordinates as number[][][] | number[][];\n  // if (!Array.isArray(path[0][0])) {\n  //   path = [coordinates] as number[][][];\n  // }\n\n  const line = new ExtrudePolyline({\n    dash: true,\n    join: 'bevel',\n  });\n\n  if (version === 'GAODE2.x') {\n    // 处理高德2.0几何体构建\n    let path1 = coordinates as number[][][] | number[][]; // 计算位置\n    if (!Array.isArray(path1[0][0])) {\n      path1 = [coordinates] as number[][][];\n    }\n    let path2 = originCoordinates as number[][][] | number[][]; // 计算法线\n    if (!Array.isArray(path2[0][0])) {\n      path2 = [originCoordinates] as number[][][];\n    }\n\n    for (let i = 0; i < path1.length; i++) {\n      // 高德2.0在计算线时，需要使用经纬度计算发现，使用 customCoords.lnglatToCoords 计算的数据来计算顶点的位置\n      const item1 = path1[i];\n      const item2 = path2[i];\n      line.extrude_gaode2(item1 as number[][], item2 as number[][]);\n    }\n  } else {\n    // 处理非高德2.0的几何体构建\n    let path = coordinates as number[][][] | number[][];\n    if (!Array.isArray(path[0][0])) {\n      path = [coordinates] as number[][][];\n    }\n    path.forEach((item: any) => {\n      line.extrude(item as number[][]);\n    });\n  }\n\n  const linebuffer = line.complex;\n  return {\n    vertices: linebuffer.positions, // [ x,y,z, distance, miter,total ]\n    indices: linebuffer.indices,\n    normals: linebuffer.normals,\n    size: 6,\n  };\n}\n\nexport function polygonTriangulation(feature: IEncodeFeature) {\n  const { coordinates } = feature;\n  const flattengeo = earcut.flatten(coordinates as number[][][]);\n  const { vertices, dimensions, holes } = flattengeo;\n  return {\n    indices: earcut(vertices, holes, dimensions),\n    vertices,\n    size: dimensions,\n  };\n}\n\nexport function PolygonExtrudeTriangulation(feature: IEncodeFeature) {\n  const coordinates = feature.coordinates as IPosition[][];\n  const { positions, index, normals } = extrude_PolygonNormal(\n    coordinates,\n    true,\n  );\n  return {\n    vertices: positions, // [ x, y, z, uv.x,uv.y ]\n    indices: index,\n    normals,\n    size: 5,\n  };\n}\n\nexport function HeatmapGridTriangulation(feature: IEncodeFeature) {\n  const { shape } = feature;\n  const { positions, index } = getHeatmapGeometry(shape as IShape);\n  return {\n    vertices: positions, // [ x, y, z ] 多边形顶点\n    indices: index,\n    size: 3,\n  };\n}\n\n/**\n * 图片图层顶点构造\n * @param feature 数据\n */\nexport function RasterImageTriangulation(feature: IEncodeFeature) {\n  const coordinates = feature.coordinates as IPosition[];\n  // [ x, y, z. uv.x, uv.y]\n  const positions: number[] = [\n    ...coordinates[0],\n    0,\n    0,\n    1,\n    coordinates[1][0],\n    coordinates[0][1],\n    0,\n    1,\n    1,\n    ...coordinates[1],\n    0,\n    1,\n    0,\n    ...coordinates[0],\n    0,\n    0,\n    1,\n    ...coordinates[1],\n    0,\n    1,\n    0,\n    coordinates[0][0],\n    coordinates[1][1],\n    0,\n    0,\n    0,\n  ];\n  const indexs = [0, 1, 2, 3, 4, 5];\n  return {\n    vertices: positions,\n    indices: indexs,\n    size: 5,\n  };\n}\n/**\n *  计算3D弧线顶点\n * @param feature 映射数据\n * @param segNum 弧线线段数\n */\nexport function LineArcTriangulation(\n  feature: IEncodeFeature,\n  segmentNumber?: number,\n) {\n  const segNum = segmentNumber ? segmentNumber : 30;\n  const coordinates = feature.coordinates as IPosition[];\n  const positions = [];\n  const indexArray = [];\n  for (let i = 0; i < segNum; i++) {\n    // 上线两个顶点\n    // [ x, y, z, sx,sy, tx,ty]\n    positions.push(\n      i,\n      1,\n      i,\n      coordinates[0][0],\n      coordinates[0][1],\n      coordinates[1][0],\n      coordinates[1][1],\n      i,\n      -1,\n      i,\n      coordinates[0][0],\n      coordinates[0][1],\n      coordinates[1][0],\n      coordinates[1][1],\n    );\n\n    if (i !== segNum - 1) {\n      indexArray.push(\n        ...[0, 1, 2, 1, 3, 2].map((v) => {\n          return i * 2 + v;\n        }),\n      );\n    }\n  }\n  return {\n    vertices: positions,\n    indices: indexArray,\n    size: 7,\n  };\n}\n\n/**\n * 构建热力图密度图的顶点\n * @param feature\n * @returns\n */\nexport function HeatmapTriangulation(feature: IEncodeFeature) {\n  const coordinates = feature.coordinates as number[];\n  if (coordinates.length === 2) {\n    coordinates.push(0);\n  }\n  const size = feature.size as number;\n  const dir = addDir(-1, 1);\n  const dir1 = addDir(1, 1);\n  const dir2 = addDir(-1, -1);\n  const dir3 = addDir(1, -1);\n  // [x,y,z, dirx ,diry, weight]\n  const positions = [\n    ...coordinates,\n    ...dir,\n    ...coordinates,\n    ...dir2,\n    ...coordinates,\n    ...dir3,\n    ...coordinates,\n    ...dir1,\n  ];\n  const indexArray = [0, 1, 2, 3, 0, 2];\n  return {\n    vertices: positions,\n    indices: indexArray,\n    size: 5,\n  };\n}\n\n/**\n * 点图层3d geomerty\n * @param shape 3D形状\n */\nfunction getGeometry(shape: ShapeType3D, needFlat = false): IExtrudeGeomety {\n  if (GeometryCache && GeometryCache[shape]) {\n    return GeometryCache[shape];\n  }\n  const path = geometryShape[shape]\n    ? geometryShape[shape]()\n    : geometryShape.cylinder();\n  const geometry = extrude_PolygonNormal([path], needFlat);\n  GeometryCache[shape] = geometry;\n  return geometry;\n}\n\nfunction computeVertexNormals(\n  positions: number[],\n  indexArray: number[],\n  dim: number = 3,\n  needFlat: boolean = false,\n) {\n  const normals = new Float32Array((positions.length / dim) * 3);\n  let vA: number;\n  let vB: number;\n  let vC: number;\n  const cb = vec3.create();\n  const ab = vec3.create();\n  const normal = vec3.create();\n  for (let i = 0, li = indexArray.length; i < li; i += 3) {\n    vA = indexArray[i + 0] * 3;\n    vB = indexArray[i + 1] * 3;\n    vC = indexArray[i + 2] * 3;\n    let p1 = [positions[vA], positions[vA + 1]];\n    let p2 = [positions[vB], positions[vB + 1]];\n    let p3 = [positions[vC], positions[vC + 1]];\n    if (needFlat) {\n      p1 = lngLatToMeters(p1);\n      p2 = lngLatToMeters(p2);\n      p3 = lngLatToMeters(p3);\n    }\n    const [ax, ay] = p1;\n    const pA = vec3.fromValues(ax, ay, positions[vA + 2]);\n    const [bx, by] = p2;\n    const pB = vec3.fromValues(bx, by, positions[vB + 2]);\n    const [cx, cy] = p3;\n    const pC = vec3.fromValues(cx, cy, positions[vC + 2]);\n    vec3.sub(cb, pC, pB);\n    vec3.sub(ab, pA, pB);\n    vec3.cross(normal, cb, ab);\n    normals[vA] += cb[0];\n    normals[vA + 1] += cb[1];\n    normals[vA + 2] += cb[2];\n    normals[vB] += cb[0];\n    normals[vB + 1] += cb[1];\n    normals[vB + 2] += cb[2];\n    normals[vC] += cb[0];\n    normals[vC + 1] += cb[1];\n    normals[vC + 2] += cb[2];\n  }\n  normalizeNormals(normals);\n  return normals;\n}\n\nfunction normalizeNormals(normals: Float32Array) {\n  for (let i = 0, li = normals.length; i < li; i += 3) {\n    const normal = vec3.fromValues(normals[i], normals[i + 1], normals[i + 2]);\n    const newNormal = vec3.create();\n    vec3.normalize(newNormal, normal);\n    normals.set(newNormal, i);\n  }\n}\n\nfunction checkIsClosed(points: number[][][]) {\n  const p1 = points[0][0];\n  const p2 = points[0][points[0].length - 1];\n  return p1[0] === p2[0] && p1[1] === p2[1];\n}\n\nfunction getHeatmapGeometry(shape: ShapeType2D | ShapeType3D): IExtrudeGeomety {\n  const shape3d = [\n    'cylinder',\n    'triangleColumn',\n    'hexagonColumn',\n    'squareColumn',\n  ];\n  const path = geometryShape[shape]\n    ? geometryShape[shape]()\n    : geometryShape.circle();\n  const geometry =\n    shape3d.indexOf(shape) === -1\n      ? fillPolygon([path])\n      : extrudePolygon([path]);\n  // const geometry = fillPolygon([path]);\n  return geometry;\n}\n// 热力图计算范围\nfunction addDir(dirX: number, dirY: number) {\n  const x = (dirX + 1) / 2;\n  const y = (dirY + 1) / 2;\n  return [x, y];\n}\n\n/**\n * 构建地球三角网格\n * @returns\n */\nexport function earthTriangulation() {\n  const earthmesh = primitiveSphere(EARTH_RADIUS, { segments: EARTH_SEGMENTS });\n  const { positionsArr, indicesArr, normalArr } = earthmesh;\n  return {\n    vertices: positionsArr,\n    indices: indicesArr,\n    size: 5,\n    normals: normalArr,\n  };\n}\n\nexport function earthOuterTriangulation() {\n  const earthmesh = primitiveSphere(EARTH_RADIUS + EARTH_RADIUS_OUTER, {\n    segments: EARTH_SEGMENTS,\n  });\n  const { positionsArr, indicesArr, normalArr } = earthmesh;\n  return {\n    vertices: positionsArr,\n    indices: indicesArr,\n    size: 5,\n    normals: normalArr,\n  };\n}\n"]},"metadata":{},"sourceType":"module"}