{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Path } from '../../geometry';\nimport * as Dom from '../dom/core';\nexport var Vector = /*#__PURE__*/function (_Symbol$toStringTag) {\n  function Vector(elem, attrs, children) {\n    _classCallCheck(this, Vector);\n\n    if (!elem) {\n      throw new TypeError('Invalid element to create vector');\n    }\n\n    var node;\n\n    if (Vector.isVector(elem)) {\n      node = elem.node;\n    } else if (typeof elem === 'string') {\n      if (elem.toLowerCase() === 'svg') {\n        node = Dom.createSvgDocument();\n      } else if (elem[0] === '<') {\n        var doc = Dom.createSvgDocument(elem); // only import the first child\n\n        node = document.importNode(doc.firstChild, true);\n      } else {\n        node = document.createElementNS(Dom.ns.svg, elem);\n      }\n    } else {\n      node = elem;\n    }\n\n    this.node = node;\n\n    if (attrs) {\n      this.setAttributes(attrs);\n    }\n\n    if (children) {\n      this.append(children);\n    }\n  }\n\n  _createClass(Vector, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Vector.toStringTag;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this.node.nodeName;\n    }\n  }, {\n    key: \"id\",\n    get: function get() {\n      return this.node.id;\n    }\n  }, {\n    key: \"id\",\n    set: function set(id) {\n      this.node.id = id;\n    }\n  }, {\n    key: \"transform\",\n    value: function transform(matrix, options) {\n      if (matrix == null) {\n        return Dom.transform(this.node);\n      }\n\n      Dom.transform(this.node, matrix, options);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx) {\n      var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (tx == null) {\n        return Dom.translate(this.node);\n      }\n\n      Dom.translate(this.node, tx, ty, options);\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, cx, cy) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      if (angle == null) {\n        return Dom.rotate(this.node);\n      }\n\n      Dom.rotate(this.node, angle, cx, cy, options);\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy) {\n      if (sx == null) {\n        return Dom.scale(this.node);\n      }\n\n      Dom.scale(this.node, sx, sy);\n      return this;\n    }\n    /**\n     * Returns an SVGMatrix that specifies the transformation necessary\n     * to convert this coordinate system into `target` coordinate system.\n     */\n\n  }, {\n    key: \"getTransformToElement\",\n    value: function getTransformToElement(target) {\n      var ref = Vector.toNode(target);\n      return Dom.getTransformToElement(this.node, ref);\n    }\n  }, {\n    key: \"removeAttribute\",\n    value: function removeAttribute(name) {\n      Dom.removeAttribute(this.node, name);\n      return this;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute(name) {\n      return Dom.getAttribute(this.node, name);\n    }\n  }, {\n    key: \"setAttribute\",\n    value: function setAttribute(name, value) {\n      Dom.setAttribute(this.node, name, value);\n      return this;\n    }\n  }, {\n    key: \"setAttributes\",\n    value: function setAttributes(attrs) {\n      Dom.setAttributes(this.node, attrs);\n      return this;\n    }\n  }, {\n    key: \"attr\",\n    value: function attr(name, value) {\n      if (name == null) {\n        return Dom.attr(this.node);\n      }\n\n      if (typeof name === 'string' && value === undefined) {\n        return Dom.attr(this.node, name);\n      }\n\n      if (typeof name === 'object') {\n        Dom.attr(this.node, name);\n      } else {\n        Dom.attr(this.node, name, value);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"svg\",\n    value: function svg() {\n      return this.node instanceof SVGSVGElement ? this : Vector.create(this.node.ownerSVGElement);\n    }\n  }, {\n    key: \"defs\",\n    value: function defs() {\n      var context = this.svg() || this;\n      var defsNode = context.node.getElementsByTagName('defs')[0];\n\n      if (defsNode) {\n        return Vector.create(defsNode);\n      }\n\n      return Vector.create('defs').appendTo(context);\n    }\n  }, {\n    key: \"text\",\n    value: function text(content) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      Dom.text(this.node, content, options);\n      return this;\n    }\n  }, {\n    key: \"tagName\",\n    value: function tagName() {\n      return Dom.tagName(this.node);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return Vector.create(this.node.cloneNode(true));\n    }\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      Dom.remove(this.node);\n      return this;\n    }\n  }, {\n    key: \"empty\",\n    value: function empty() {\n      Dom.empty(this.node);\n      return this;\n    }\n  }, {\n    key: \"append\",\n    value: function append(elems) {\n      Dom.append(this.node, Vector.toNodes(elems));\n      return this;\n    }\n  }, {\n    key: \"appendTo\",\n    value: function appendTo(target) {\n      Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target);\n      return this;\n    }\n  }, {\n    key: \"prepend\",\n    value: function prepend(elems) {\n      Dom.prepend(this.node, Vector.toNodes(elems));\n      return this;\n    }\n  }, {\n    key: \"before\",\n    value: function before(elems) {\n      Dom.before(this.node, Vector.toNodes(elems));\n      return this;\n    }\n  }, {\n    key: \"replace\",\n    value: function replace(elem) {\n      if (this.node.parentNode) {\n        this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);\n      }\n\n      return Vector.create(elem);\n    }\n  }, {\n    key: \"first\",\n    value: function first() {\n      return this.node.firstChild ? Vector.create(this.node.firstChild) : null;\n    }\n  }, {\n    key: \"last\",\n    value: function last() {\n      return this.node.lastChild ? Vector.create(this.node.lastChild) : null;\n    }\n  }, {\n    key: \"get\",\n    value: function get(index) {\n      var child = this.node.childNodes[index];\n      return child ? Vector.create(child) : null;\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(elem) {\n      var children = Array.prototype.slice.call(this.node.childNodes);\n      return children.indexOf(Vector.toNode(elem));\n    }\n  }, {\n    key: \"find\",\n    value: function find(selector) {\n      var vels = [];\n      var nodes = Dom.find(this.node, selector);\n\n      if (nodes) {\n        for (var i = 0, ii = nodes.length; i < ii; i += 1) {\n          vels.push(Vector.create(nodes[i]));\n        }\n      }\n\n      return vels;\n    }\n  }, {\n    key: \"findOne\",\n    value: function findOne(selector) {\n      var found = Dom.findOne(this.node, selector);\n      return found ? Vector.create(found) : null;\n    }\n  }, {\n    key: \"findParentByClass\",\n    value: function findParentByClass(className, terminator) {\n      var node = Dom.findParentByClass(this.node, className, terminator);\n      return node ? Vector.create(node) : null;\n    }\n  }, {\n    key: \"matches\",\n    value: function matches(selector) {\n      var node = this.node;\n      var matches = this.node.matches;\n      var matcher = node.matches || node.matchesSelector || node.msMatchesSelector || node.mozMatchesSelector || node.webkitMatchesSelector || node.oMatchesSelector || null;\n      return matcher && matcher.call(node, selector);\n    }\n  }, {\n    key: \"contains\",\n    value: function contains(child) {\n      return Dom.contains(this.node, Vector.isVector(child) ? child.node : child);\n    }\n  }, {\n    key: \"wrap\",\n    value: function wrap(node) {\n      var vel = Vector.create(node);\n      var parentNode = this.node.parentNode;\n\n      if (parentNode != null) {\n        parentNode.insertBefore(vel.node, this.node);\n      }\n\n      return vel.append(this);\n    }\n  }, {\n    key: \"parent\",\n    value: function parent(type) {\n      var parent = this; // eslint-disable-line @typescript-eslint/no-this-alias\n      // check for parent\n\n      if (parent.node.parentNode == null) {\n        return null;\n      } // get parent element\n\n\n      parent = Vector.create(parent.node.parentNode);\n\n      if (type == null) {\n        return parent;\n      } // loop trough ancestors if type is given\n\n\n      do {\n        if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {\n          return parent;\n        }\n      } while (parent = Vector.create(parent.node.parentNode));\n\n      return parent;\n    }\n  }, {\n    key: \"children\",\n    value: function children() {\n      var children = this.node.childNodes;\n      var vels = [];\n\n      for (var i = 0; i < children.length; i += 1) {\n        var currentChild = children[i];\n\n        if (currentChild.nodeType === 1) {\n          vels.push(Vector.create(children[i]));\n        }\n      }\n\n      return vels;\n    }\n  }, {\n    key: \"eachChild\",\n    value: function eachChild(fn, deep) {\n      var children = this.children();\n\n      for (var i = 0, l = children.length; i < l; i += 1) {\n        fn.call(children[i], children[i], i, children);\n\n        if (deep) {\n          children[i].eachChild(fn, deep);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"index\",\n    value: function index() {\n      return Dom.index(this.node);\n    }\n  }, {\n    key: \"hasClass\",\n    value: function hasClass(className) {\n      return Dom.hasClass(this.node, className);\n    }\n  }, {\n    key: \"addClass\",\n    value: function addClass(className) {\n      Dom.addClass(this.node, className);\n      return this;\n    }\n  }, {\n    key: \"removeClass\",\n    value: function removeClass(className) {\n      Dom.removeClass(this.node, className);\n      return this;\n    }\n  }, {\n    key: \"toggleClass\",\n    value: function toggleClass(className, stateVal) {\n      Dom.toggleClass(this.node, className, stateVal);\n      return this;\n    }\n  }, {\n    key: \"toLocalPoint\",\n    value: function toLocalPoint(x, y) {\n      return Dom.toLocalPoint(this.node, x, y);\n    }\n  }, {\n    key: \"toGeometryShape\",\n    value: function toGeometryShape() {\n      return Dom.toGeometryShape(this.node);\n    }\n  }, {\n    key: \"translateCenterToPoint\",\n    value: function translateCenterToPoint(p) {\n      var bbox = this.getBBox({\n        target: this.svg()\n      });\n      var center = bbox.getCenter();\n      this.translate(p.x - center.x, p.y - center.y);\n      return this;\n    }\n  }, {\n    key: \"translateAndAutoOrient\",\n    value: function translateAndAutoOrient(position, reference, target) {\n      Dom.translateAndAutoOrient(this.node, position, reference, target);\n      return this;\n    }\n  }, {\n    key: \"animate\",\n    value: function animate(options) {\n      return Dom.animate(this.node, options);\n    }\n  }, {\n    key: \"animateTransform\",\n    value: function animateTransform(options) {\n      return Dom.animateTransform(this.node, options);\n    }\n  }, {\n    key: \"animateAlongPath\",\n    value: function animateAlongPath(options, path) {\n      return Dom.animateAlongPath(this.node, options, path);\n    }\n    /**\n     * Normalize this element's d attribute. SVGPathElements without\n     * a path data attribute obtain a value of 'M 0 0'.\n     */\n\n  }, {\n    key: \"normalizePath\",\n    value: function normalizePath() {\n      var tagName = this.tagName();\n\n      if (tagName === 'path') {\n        this.attr('d', Path.normalize(this.attr('d')));\n      }\n\n      return this;\n    }\n    /**\n     * Returns the bounding box of the element after transformations are applied.\n     * If `withoutTransformations` is `true`, transformations of the element\n     * will not be considered when computing the bounding box. If `target` is\n     * specified, bounding box will be computed relatively to the target element.\n     */\n\n  }, {\n    key: \"bbox\",\n    value: function bbox(withoutTransformations, target) {\n      return Dom.bbox(this.node, withoutTransformations, target);\n    }\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return Dom.getBBox(this.node, {\n        recursive: options.recursive,\n        target: options.target ? Vector.toNode(options.target) : null\n      });\n    }\n    /**\n     * Samples the underlying SVG element (it currently works only on\n     * paths - where it is most useful anyway). Returns an array of objects\n     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n     * objects represent a point on the path. This basically creates a discrete\n     * representation of the path (which is possible a curve). The sampling\n     * interval defines the accuracy of the sampling. In other words, we travel\n     * from the beginning of the path to the end by interval distance (on the\n     * path, not between the resulting points) and collect the discrete points\n     * on the path. This is very useful in many situations. For example, SVG\n     * does not provide a built-in mechanism to find intersections between two\n     * paths. Using sampling, we can just generate bunch of points for each of\n     * the path and find the closest ones from each set.\n     */\n\n  }, {\n    key: \"sample\",\n    value: function sample() {\n      var interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n      if (this.node instanceof SVGPathElement) {\n        return Dom.sample(this.node, interval);\n      }\n\n      return [];\n    }\n  }, {\n    key: \"toPath\",\n    value: function toPath() {\n      return Vector.create(Dom.toPath(this.node));\n    }\n  }, {\n    key: \"toPathData\",\n    value: function toPathData() {\n      return Dom.toPathData(this.node);\n    }\n  }]);\n\n  return Vector;\n}(Symbol.toStringTag);\n\n(function (Vector) {\n  Vector.toStringTag = \"X6.\".concat(Vector.name);\n\n  function isVector(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Vector) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var vector = instance;\n\n    if ((tag == null || tag === Vector.toStringTag) && vector.node instanceof SVGElement && typeof vector.animate === 'function' && typeof vector.sample === 'function' && typeof vector.normalizePath === 'function' && typeof vector.toPath === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Vector.isVector = isVector;\n\n  function create(elem, attrs, children) {\n    return new Vector(elem, attrs, children);\n  }\n\n  Vector.create = create;\n\n  function createVectors(markup) {\n    if (markup[0] === '<') {\n      var svgDoc = Dom.createSvgDocument(markup);\n      var vels = [];\n\n      for (var i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n        var childNode = svgDoc.childNodes[i];\n        vels.push(create(document.importNode(childNode, true)));\n      }\n\n      return vels;\n    }\n\n    return [create(markup)];\n  }\n\n  Vector.createVectors = createVectors;\n\n  function toNode(elem) {\n    if (isVector(elem)) {\n      return elem.node;\n    }\n\n    return elem;\n  }\n\n  Vector.toNode = toNode;\n\n  function toNodes(elems) {\n    if (Array.isArray(elems)) {\n      return elems.map(function (elem) {\n        return toNode(elem);\n      });\n    }\n\n    return [toNode(elems)];\n  }\n\n  Vector.toNodes = toNodes;\n})(Vector || (Vector = {}));","map":{"version":3,"sources":["../../../src/util/vector/index.ts"],"names":[],"mappings":";;AAAA,SAAgB,IAAhB,QAA4B,gBAA5B;AACA,OAAO,KAAK,GAAZ,MAAqB,aAArB;AAEA,WAAa,MAAb;AAmBE,kBACE,IADF,EAEE,KAFF,EAGE,QAHF,EAG0D;AAAA;;AAExD,QAAI,CAAC,IAAL,EAAW;AACT,YAAM,IAAI,SAAJ,CAAc,kCAAd,CAAN;AACD;;AAED,QAAI,IAAJ;;AACA,QAAI,MAAM,CAAC,QAAP,CAAgB,IAAhB,CAAJ,EAA2B;AACzB,MAAA,IAAI,GAAG,IAAI,CAAC,IAAZ;AACD,KAFD,MAEO,IAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AACnC,UAAI,IAAI,CAAC,WAAL,OAAuB,KAA3B,EAAkC;AAChC,QAAA,IAAI,GAAG,GAAG,CAAC,iBAAJ,EAAP;AACD,OAFD,MAEO,IAAI,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAhB,EAAqB;AAC1B,YAAM,GAAG,GAAG,GAAG,CAAC,iBAAJ,CAAsB,IAAtB,CAAZ,CAD0B,CAE1B;;AACA,QAAA,IAAI,GAAG,QAAQ,CAAC,UAAT,CAAoB,GAAG,CAAC,UAAxB,EAAqC,IAArC,CAAP;AACD,OAJM,MAIA;AACL,QAAA,IAAI,GAAG,QAAQ,CAAC,eAAT,CAAyB,GAAG,CAAC,EAAJ,CAAO,GAAhC,EAAqC,IAArC,CAAP;AACD;AACF,KAVM,MAUA;AACL,MAAA,IAAI,GAAG,IAAP;AACD;;AAED,SAAK,IAAL,GAAY,IAAZ;;AAEA,QAAI,KAAJ,EAAW;AACT,WAAK,aAAL,CAAmB,KAAnB;AACD;;AAED,QAAI,QAAJ,EAAc;AACZ,WAAK,MAAL,CAAY,QAAZ;AACD;AACF;;AAtDH;AAAA;AAAA,SAGE,eAAkC;AAChC,aAAO,MAAM,CAAC,WAAd;AACD;AALH;AAAA;AAAA,SAOE,eAAe;AACb,aAAO,KAAK,IAAL,CAAU,QAAjB;AACD;AATH;AAAA;AAAA,SAWE,eAAa;AACX,aAAO,KAAK,IAAL,CAAU,EAAjB;AACD;AAbH;AAAA;AAAA,SAeE,aAAc,EAAd,EAAwB;AACtB,WAAK,IAAL,CAAU,EAAV,GAAe,EAAf;AACD;AAjBH;AAAA;AAAA,WAgEE,mBAAU,MAAV,EAA8B,OAA9B,EAA4D;AAC1D,UAAI,MAAM,IAAI,IAAd,EAAoB;AAClB,eAAO,GAAG,CAAC,SAAJ,CAAc,KAAK,IAAnB,CAAP;AACD;;AAED,MAAA,GAAG,CAAC,SAAJ,CAAc,KAAK,IAAnB,EAAyB,MAAzB,EAAiC,OAAjC;AAEA,aAAO,IAAP;AACD;AAxEH;AAAA;AAAA,WAoFE,mBAAU,EAAV,EAAiE;AAAA,UAA1C,EAA0C,uEAArC,CAAqC;AAAA,UAAlC,OAAkC,uEAAF,EAAE;;AAC/D,UAAI,EAAE,IAAI,IAAV,EAAgB;AACd,eAAO,GAAG,CAAC,SAAJ,CAAc,KAAK,IAAnB,CAAP;AACD;;AAED,MAAA,GAAG,CAAC,SAAJ,CAAc,KAAK,IAAnB,EAAyB,EAAzB,EAA6B,EAA7B,EAAiC,OAAjC;AACA,aAAO,IAAP;AACD;AA3FH;AAAA;AAAA,WA2GE,gBACE,KADF,EAEE,EAFF,EAGE,EAHF,EAIoC;AAAA,UAAlC,OAAkC,uEAAF,EAAE;;AAElC,UAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,eAAO,GAAG,CAAC,MAAJ,CAAW,KAAK,IAAhB,CAAP;AACD;;AAED,MAAA,GAAG,CAAC,MAAJ,CAAW,KAAK,IAAhB,EAAsB,KAAtB,EAA6B,EAA7B,EAAiC,EAAjC,EAAqC,OAArC;AACA,aAAO,IAAP;AACD;AAvHH;AAAA;AAAA,WAkIE,eAAM,EAAN,EAAmB,EAAnB,EAA8B;AAC5B,UAAI,EAAE,IAAI,IAAV,EAAgB;AACd,eAAO,GAAG,CAAC,KAAJ,CAAU,KAAK,IAAf,CAAP;AACD;;AACD,MAAA,GAAG,CAAC,KAAJ,CAAU,KAAK,IAAf,EAAqB,EAArB,EAAyB,EAAzB;AACA,aAAO,IAAP;AACD;AAED;;;AAGG;;AA7IL;AAAA;AAAA,WA8IE,+BAAsB,MAAtB,EAAiD;AAC/C,UAAM,GAAG,GAAG,MAAM,CAAC,MAAP,CAAc,MAAd,CAAZ;AACA,aAAO,GAAG,CAAC,qBAAJ,CAA0B,KAAK,IAA/B,EAAqC,GAArC,CAAP;AACD;AAjJH;AAAA;AAAA,WAmJE,yBAAgB,IAAhB,EAA4B;AAC1B,MAAA,GAAG,CAAC,eAAJ,CAAoB,KAAK,IAAzB,EAA+B,IAA/B;AACA,aAAO,IAAP;AACD;AAtJH;AAAA;AAAA,WAwJE,sBAAa,IAAb,EAAyB;AACvB,aAAO,GAAG,CAAC,YAAJ,CAAiB,KAAK,IAAtB,EAA4B,IAA5B,CAAP;AACD;AA1JH;AAAA;AAAA,WA4JE,sBAAa,IAAb,EAA2B,KAA3B,EAAyD;AACvD,MAAA,GAAG,CAAC,YAAJ,CAAiB,KAAK,IAAtB,EAA4B,IAA5B,EAAkC,KAAlC;AACA,aAAO,IAAP;AACD;AA/JH;AAAA;AAAA,WAiKE,uBAAc,KAAd,EAA2E;AACzE,MAAA,GAAG,CAAC,aAAJ,CAAkB,KAAK,IAAvB,EAA6B,KAA7B;AACA,aAAO,IAAP;AACD;AApKH;AAAA;AAAA,WA0KE,cACE,IADF,EAEE,KAFF,EAEgC;AAE9B,UAAI,IAAI,IAAI,IAAZ,EAAkB;AAChB,eAAO,GAAG,CAAC,IAAJ,CAAS,KAAK,IAAd,CAAP;AACD;;AAED,UAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,KAAK,KAAK,SAA1C,EAAqD;AACnD,eAAO,GAAG,CAAC,IAAJ,CAAS,KAAK,IAAd,EAAoB,IAApB,CAAP;AACD;;AAED,UAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAA,GAAG,CAAC,IAAJ,CAAS,KAAK,IAAd,EAAoB,IAApB;AACD,OAFD,MAEO;AACL,QAAA,GAAG,CAAC,IAAJ,CAAS,KAAK,IAAd,EAAoB,IAApB,EAA0B,KAA1B;AACD;;AAED,aAAO,IAAP;AACD;AA7LH;AAAA;AAAA,WA+LE,eAAG;AACD,aAAO,KAAK,IAAL,YAAqB,aAArB,GACH,IADG,GAEH,MAAM,CAAC,MAAP,CAAc,KAAK,IAAL,CAAU,eAAxB,CAFJ;AAGD;AAnMH;AAAA;AAAA,WAqME,gBAAI;AACF,UAAM,OAAO,GAAG,KAAK,GAAL,MAAc,IAA9B;AACA,UAAM,QAAQ,GAAG,OAAO,CAAC,IAAR,CAAa,oBAAb,CAAkC,MAAlC,EAA0C,CAA1C,CAAjB;;AACA,UAAI,QAAJ,EAAc;AACZ,eAAO,MAAM,CAAC,MAAP,CAAc,QAAd,CAAP;AACD;;AAED,aAAO,MAAM,CAAC,MAAP,CAAc,MAAd,EAAsB,QAAtB,CAA+B,OAA/B,CAAP;AACD;AA7MH;AAAA;AAAA,WA+ME,cAAK,OAAL,EAAmD;AAAA,UAA7B,OAA6B,uEAAF,EAAE;AACjD,MAAA,GAAG,CAAC,IAAJ,CAAS,KAAK,IAAd,EAAoB,OAApB,EAA6B,OAA7B;AACA,aAAO,IAAP;AACD;AAlNH;AAAA;AAAA,WAoNE,mBAAO;AACL,aAAO,GAAG,CAAC,OAAJ,CAAY,KAAK,IAAjB,CAAP;AACD;AAtNH;AAAA;AAAA,WAwNE,iBAAK;AACH,aAAO,MAAM,CAAC,MAAP,CAAc,KAAK,IAAL,CAAU,SAAV,CAAoB,IAApB,CAAd,CAAP;AACD;AA1NH;AAAA;AAAA,WA4NE,kBAAM;AACJ,MAAA,GAAG,CAAC,MAAJ,CAAW,KAAK,IAAhB;AACA,aAAO,IAAP;AACD;AA/NH;AAAA;AAAA,WAiOE,iBAAK;AACH,MAAA,GAAG,CAAC,KAAJ,CAAU,KAAK,IAAf;AACA,aAAO,IAAP;AACD;AApOH;AAAA;AAAA,WAsOE,gBACE,KADF,EAKgD;AAE9C,MAAA,GAAG,CAAC,MAAJ,CAAW,KAAK,IAAhB,EAAsB,MAAM,CAAC,OAAP,CAAe,KAAf,CAAtB;AACA,aAAO,IAAP;AACD;AA/OH;AAAA;AAAA,WAiPE,kBAAS,MAAT,EAAiC;AAC/B,MAAA,GAAG,CAAC,QAAJ,CAAa,KAAK,IAAlB,EAAwB,MAAM,CAAC,QAAP,CAAgB,MAAhB,IAA0B,MAAM,CAAC,IAAjC,GAAwC,MAAhE;AACA,aAAO,IAAP;AACD;AApPH;AAAA;AAAA,WAsPE,iBACE,KADF,EAKgD;AAE9C,MAAA,GAAG,CAAC,OAAJ,CAAY,KAAK,IAAjB,EAAuB,MAAM,CAAC,OAAP,CAAe,KAAf,CAAvB;AACA,aAAO,IAAP;AACD;AA/PH;AAAA;AAAA,WAiQE,gBACE,KADF,EAKgD;AAE9C,MAAA,GAAG,CAAC,MAAJ,CAAW,KAAK,IAAhB,EAAsB,MAAM,CAAC,OAAP,CAAe,KAAf,CAAtB;AACA,aAAO,IAAP;AACD;AA1QH;AAAA;AAAA,WA4QE,iBAAQ,IAAR,EAAiC;AAC/B,UAAI,KAAK,IAAL,CAAU,UAAd,EAA0B;AACxB,aAAK,IAAL,CAAU,UAAV,CAAqB,YAArB,CAAkC,MAAM,CAAC,MAAP,CAAc,IAAd,CAAlC,EAAuD,KAAK,IAA5D;AACD;;AACD,aAAO,MAAM,CAAC,MAAP,CAAc,IAAd,CAAP;AACD;AAjRH;AAAA;AAAA,WAmRE,iBAAK;AACH,aAAO,KAAK,IAAL,CAAU,UAAV,GACH,MAAM,CAAC,MAAP,CAAc,KAAK,IAAL,CAAU,UAAxB,CADG,GAEH,IAFJ;AAGD;AAvRH;AAAA;AAAA,WAyRE,gBAAI;AACF,aAAO,KAAK,IAAL,CAAU,SAAV,GACH,MAAM,CAAC,MAAP,CAAc,KAAK,IAAL,CAAU,SAAxB,CADG,GAEH,IAFJ;AAGD;AA7RH;AAAA;AAAA,WA+RE,aAAI,KAAJ,EAAiB;AACf,UAAM,KAAK,GAAG,KAAK,IAAL,CAAU,UAAV,CAAqB,KAArB,CAAd;AACA,aAAO,KAAK,GAAG,MAAM,CAAC,MAAP,CAAc,KAAd,CAAH,GAA0B,IAAtC;AACD;AAlSH;AAAA;AAAA,WAoSE,iBAAQ,IAAR,EAAiC;AAC/B,UAAM,QAAQ,GAAiB,KAAK,CAAC,SAAN,CAAgB,KAAhB,CAAsB,IAAtB,CAC7B,KAAK,IAAL,CAAU,UADmB,CAA/B;AAGA,aAAO,QAAQ,CAAC,OAAT,CAAiB,MAAM,CAAC,MAAP,CAAc,IAAd,CAAjB,CAAP;AACD;AAzSH;AAAA;AAAA,WA2SE,cAAK,QAAL,EAAqB;AACnB,UAAM,IAAI,GAAa,EAAvB;AACA,UAAM,KAAK,GAAG,GAAG,CAAC,IAAJ,CAAS,KAAK,IAAd,EAAoB,QAApB,CAAd;;AACA,UAAI,KAAJ,EAAW;AACT,aAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,KAAK,CAAC,MAA3B,EAAmC,CAAC,GAAG,EAAvC,EAA2C,CAAC,IAAI,CAAhD,EAAmD;AACjD,UAAA,IAAI,CAAC,IAAL,CAAU,MAAM,CAAC,MAAP,CAAc,KAAK,CAAC,CAAD,CAAnB,CAAV;AACD;AACF;;AAED,aAAO,IAAP;AACD;AArTH;AAAA;AAAA,WAuTE,iBAAQ,QAAR,EAAwB;AACtB,UAAM,KAAK,GAAG,GAAG,CAAC,OAAJ,CAAY,KAAK,IAAjB,EAAuB,QAAvB,CAAd;AACA,aAAO,KAAK,GAAG,MAAM,CAAC,MAAP,CAAc,KAAd,CAAH,GAAwC,IAApD;AACD;AA1TH;AAAA;AAAA,WA4TE,2BAAkB,SAAlB,EAAqC,UAArC,EAA4D;AAC1D,UAAM,IAAI,GAAG,GAAG,CAAC,iBAAJ,CAAsB,KAAK,IAA3B,EAAiC,SAAjC,EAA4C,UAA5C,CAAb;AACA,aAAO,IAAI,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAH,GAAuC,IAAlD;AACD;AA/TH;AAAA;AAAA,WAiUE,iBAAQ,QAAR,EAAwB;AACtB,UAAM,IAAI,GAAG,KAAK,IAAlB;AACA,UAAM,OAAO,GAAG,KAAK,IAAL,CAAU,OAA1B;AACA,UAAM,OAAO,GACX,IAAI,CAAC,OAAL,IACA,IAAI,CAAC,eADL,IAEA,IAAI,CAAC,iBAFL,IAGA,IAAI,CAAC,kBAHL,IAIA,IAAI,CAAC,qBAJL,IAKA,IAAI,CAAC,gBALL,IAMA,IAPF;AAQA,aAAO,OAAO,IAAI,OAAO,CAAC,IAAR,CAAa,IAAb,EAAmB,QAAnB,CAAlB;AACD;AA7UH;AAAA;AAAA,WA+UE,kBAAS,KAAT,EAAmC;AACjC,aAAO,GAAG,CAAC,QAAJ,CAAa,KAAK,IAAlB,EAAwB,MAAM,CAAC,QAAP,CAAgB,KAAhB,IAAyB,KAAK,CAAC,IAA/B,GAAsC,KAA9D,CAAP;AACD;AAjVH;AAAA;AAAA,WAmVE,cAAK,IAAL,EAA8B;AAC5B,UAAM,GAAG,GAAG,MAAM,CAAC,MAAP,CAAc,IAAd,CAAZ;AACA,UAAM,UAAU,GAAG,KAAK,IAAL,CAAU,UAA7B;;AACA,UAAI,UAAU,IAAI,IAAlB,EAAwB;AACtB,QAAA,UAAU,CAAC,YAAX,CAAwB,GAAG,CAAC,IAA5B,EAAkC,KAAK,IAAvC;AACD;;AACD,aAAO,GAAG,CAAC,MAAJ,CAAW,IAAX,CAAP;AACD;AA1VH;AAAA;AAAA,WA4VE,gBAAO,IAAP,EAAoB;AAClB,UAAI,MAAM,GAAW,IAArB,CADkB,CACQ;AAE1B;;AACA,UAAI,MAAM,CAAC,IAAP,CAAY,UAAZ,IAA0B,IAA9B,EAAoC;AAClC,eAAO,IAAP;AACD,OANiB,CAQlB;;;AACA,MAAA,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,MAAM,CAAC,IAAP,CAAY,UAA1B,CAAT;;AAEA,UAAI,IAAI,IAAI,IAAZ,EAAkB;AAChB,eAAO,MAAP;AACD,OAbiB,CAelB;;;AACA,SAAG;AACD,YACE,OAAO,IAAP,KAAgB,QAAhB,GAA2B,MAAM,CAAC,OAAP,CAAe,IAAf,CAA3B,GAAkD,MAAM,YAAY,IADtE,EAEE;AACA,iBAAO,MAAP;AACD;AACF,OAND,QAMU,MAAM,GAAG,MAAM,CAAC,MAAP,CAAc,MAAM,CAAC,IAAP,CAAY,UAA1B,CANnB;;AAQA,aAAO,MAAP;AACD;AArXH;AAAA;AAAA,WAuXE,oBAAQ;AACN,UAAM,QAAQ,GAAG,KAAK,IAAL,CAAU,UAA3B;AACA,UAAM,IAAI,GAAa,EAAvB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,IAAI,CAA1C,EAA6C;AAC3C,YAAM,YAAY,GAAG,QAAQ,CAAC,CAAD,CAA7B;;AACA,YAAI,YAAY,CAAC,QAAb,KAA0B,CAA9B,EAAiC;AAC/B,UAAA,IAAI,CAAC,IAAL,CAAU,MAAM,CAAC,MAAP,CAAc,QAAQ,CAAC,CAAD,CAAtB,CAAV;AACD;AACF;;AACD,aAAO,IAAP;AACD;AAjYH;AAAA;AAAA,WAmYE,mBACE,EADF,EAOE,IAPF,EAOgB;AAEd,UAAM,QAAQ,GAAG,KAAK,QAAL,EAAjB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,QAAQ,CAAC,MAA7B,EAAqC,CAAC,GAAG,CAAzC,EAA4C,CAAC,IAAI,CAAjD,EAAoD;AAClD,QAAA,EAAE,CAAC,IAAH,CAAQ,QAAQ,CAAC,CAAD,CAAhB,EAAqB,QAAQ,CAAC,CAAD,CAA7B,EAAkC,CAAlC,EAAqC,QAArC;;AACA,YAAI,IAAJ,EAAU;AACR,UAAA,QAAQ,CAAC,CAAD,CAAR,CAAY,SAAZ,CAAsB,EAAtB,EAA0B,IAA1B;AACD;AACF;;AAED,aAAO,IAAP;AACD;AArZH;AAAA;AAAA,WAuZE,iBAAK;AACH,aAAO,GAAG,CAAC,KAAJ,CAAU,KAAK,IAAf,CAAP;AACD;AAzZH;AAAA;AAAA,WA2ZE,kBAAS,SAAT,EAA0B;AACxB,aAAO,GAAG,CAAC,QAAJ,CAAa,KAAK,IAAlB,EAAwB,SAAxB,CAAP;AACD;AA7ZH;AAAA;AAAA,WA+ZE,kBAAS,SAAT,EAA0B;AACxB,MAAA,GAAG,CAAC,QAAJ,CAAa,KAAK,IAAlB,EAAwB,SAAxB;AACA,aAAO,IAAP;AACD;AAlaH;AAAA;AAAA,WAoaE,qBAAY,SAAZ,EAA8B;AAC5B,MAAA,GAAG,CAAC,WAAJ,CAAgB,KAAK,IAArB,EAA2B,SAA3B;AACA,aAAO,IAAP;AACD;AAvaH;AAAA;AAAA,WAyaE,qBAAY,SAAZ,EAA+B,QAA/B,EAAiD;AAC/C,MAAA,GAAG,CAAC,WAAJ,CAAgB,KAAK,IAArB,EAA2B,SAA3B,EAAsC,QAAtC;AACA,aAAO,IAAP;AACD;AA5aH;AAAA;AAAA,WA8aE,sBAAa,CAAb,EAAwB,CAAxB,EAAiC;AAC/B,aAAO,GAAG,CAAC,YAAJ,CAAiB,KAAK,IAAtB,EAA4B,CAA5B,EAA+B,CAA/B,CAAP;AACD;AAhbH;AAAA;AAAA,WAkbE,2BAAe;AACb,aAAO,GAAG,CAAC,eAAJ,CAAoB,KAAK,IAAzB,CAAP;AACD;AApbH;AAAA;AAAA,WAsbE,gCAAuB,CAAvB,EAAyC;AACvC,UAAM,IAAI,GAAG,KAAK,OAAL,CAAa;AAAE,QAAA,MAAM,EAAE,KAAK,GAAL;AAAV,OAAb,CAAb;AACA,UAAM,MAAM,GAAG,IAAI,CAAC,SAAL,EAAf;AACA,WAAK,SAAL,CAAe,CAAC,CAAC,CAAF,GAAM,MAAM,CAAC,CAA5B,EAA+B,CAAC,CAAC,CAAF,GAAM,MAAM,CAAC,CAA5C;AACA,aAAO,IAAP;AACD;AA3bH;AAAA;AAAA,WA6bE,gCACE,QADF,EAEE,SAFF,EAGE,MAHF,EAGqB;AAEnB,MAAA,GAAG,CAAC,sBAAJ,CAA2B,KAAK,IAAhC,EAAsC,QAAtC,EAAgD,SAAhD,EAA2D,MAA3D;AACA,aAAO,IAAP;AACD;AApcH;AAAA;AAAA,WAscE,iBAAQ,OAAR,EAAqC;AACnC,aAAO,GAAG,CAAC,OAAJ,CAAY,KAAK,IAAjB,EAAuB,OAAvB,CAAP;AACD;AAxcH;AAAA;AAAA,WA0cE,0BAAiB,OAAjB,EAA8C;AAC5C,aAAO,GAAG,CAAC,gBAAJ,CAAqB,KAAK,IAA1B,EAAgC,OAAhC,CAAP;AACD;AA5cH;AAAA;AAAA,WA8cE,0BAAiB,OAAjB,EAAgD,IAAhD,EAAoE;AAClE,aAAO,GAAG,CAAC,gBAAJ,CAAqB,KAAK,IAA1B,EAAgC,OAAhC,EAAyC,IAAzC,CAAP;AACD;AAED;;;AAGG;;AArdL;AAAA;AAAA,WAsdE,yBAAa;AACX,UAAM,OAAO,GAAG,KAAK,OAAL,EAAhB;;AACA,UAAI,OAAO,KAAK,MAAhB,EAAwB;AACtB,aAAK,IAAL,CAAU,GAAV,EAAe,IAAI,CAAC,SAAL,CAAe,KAAK,IAAL,CAAU,GAAV,CAAf,CAAf;AACD;;AAED,aAAO,IAAP;AACD;AAED;;;;;AAKG;;AApeL;AAAA;AAAA,WAqeE,cAAK,sBAAL,EAAuC,MAAvC,EAA0D;AACxD,aAAO,GAAG,CAAC,IAAJ,CAAS,KAAK,IAAd,EAAoB,sBAApB,EAA4C,MAA5C,CAAP;AACD;AAveH;AAAA;AAAA,WAyeE,mBAIQ;AAAA,UAHN,OAGM,uEAAF,EAAE;AAEN,aAAO,GAAG,CAAC,OAAJ,CAAY,KAAK,IAAjB,EAAuB;AAC5B,QAAA,SAAS,EAAE,OAAO,CAAC,SADS;AAE5B,QAAA,MAAM,EAAE,OAAO,CAAC,MAAR,GAAiB,MAAM,CAAC,MAAP,CAAc,OAAO,CAAC,MAAtB,CAAjB,GAAiD;AAF7B,OAAvB,CAAP;AAID;AAED;;;;;;;;;;;;;AAaG;;AAlgBL;AAAA;AAAA,WAmgBE,kBAAmB;AAAA,UAAZ,QAAY,uEAAD,CAAC;;AACjB,UAAI,KAAK,IAAL,YAAqB,cAAzB,EAAyC;AACvC,eAAO,GAAG,CAAC,MAAJ,CAAW,KAAK,IAAhB,EAAsB,QAAtB,CAAP;AACD;;AACD,aAAO,EAAP;AACD;AAxgBH;AAAA;AAAA,WA0gBE,kBAAM;AACJ,aAAO,MAAM,CAAC,MAAP,CAAc,GAAG,CAAC,MAAJ,CAAW,KAAK,IAAhB,CAAd,CAAP;AACD;AA5gBH;AAAA;AAAA,WA8gBE,sBAAU;AACR,aAAO,GAAG,CAAC,UAAJ,CAAe,KAAK,IAApB,CAAP;AACD;AAhhBH;;AAAA;AAAA,EAGiB,MAAM,CAAC,WAHxB;;AAmhBA,CAAA,UAAiB,MAAjB,EAAuB;AACR,EAAA,MAAA,CAAA,WAAA,gBAAoB,MAAM,CAAC,IAA3B;;AAEb,WAAgB,QAAhB,CAAyB,QAAzB,EAAsC;AACpC,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAO,KAAP;AACD;;AAED,QAAI,QAAQ,YAAY,MAAxB,EAAgC;AAC9B,aAAO,IAAP;AACD;;AAED,QAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,WAAR,CAApB;AACA,QAAM,MAAM,GAAG,QAAf;;AAEA,QACE,CAAC,GAAG,IAAI,IAAP,IAAe,GAAG,KAAK,MAAA,CAAA,WAAxB,KACA,MAAM,CAAC,IAAP,YAAuB,UADvB,IAEA,OAAO,MAAM,CAAC,OAAd,KAA0B,UAF1B,IAGA,OAAO,MAAM,CAAC,MAAd,KAAyB,UAHzB,IAIA,OAAO,MAAM,CAAC,aAAd,KAAgC,UAJhC,IAKA,OAAO,MAAM,CAAC,MAAd,KAAyB,UAN3B,EAOE;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD;;AAxBe,EAAA,MAAA,CAAA,QAAA,GAAQ,QAAR;;AA0BhB,WAAgB,MAAhB,CACE,IADF,EAEE,KAFF,EAGE,QAHF,EAG0D;AAExD,WAAO,IAAI,MAAJ,CAAW,IAAX,EAAiB,KAAjB,EAAwB,QAAxB,CAAP;AACD;;AANe,EAAA,MAAA,CAAA,MAAA,GAAM,MAAN;;AAQhB,WAAgB,aAAhB,CAA8B,MAA9B,EAA4C;AAC1C,QAAI,MAAM,CAAC,CAAD,CAAN,KAAc,GAAlB,EAAuB;AACrB,UAAM,MAAM,GAAG,GAAG,CAAC,iBAAJ,CAAsB,MAAtB,CAAf;AACA,UAAM,IAAI,GAAa,EAAvB;;AACA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,MAAM,CAAC,UAAP,CAAkB,MAAvC,EAA+C,CAAC,GAAG,EAAnD,EAAuD,CAAC,IAAI,CAA5D,EAA+D;AAC7D,YAAM,SAAS,GAAG,MAAM,CAAC,UAAP,CAAkB,CAAlB,CAAlB;AACA,QAAA,IAAI,CAAC,IAAL,CAAU,MAAM,CAAC,QAAQ,CAAC,UAAT,CAAoB,SAApB,EAA+B,IAA/B,CAAD,CAAhB;AACD;;AAED,aAAO,IAAP;AACD;;AAED,WAAO,CAAC,MAAM,CAAC,MAAD,CAAP,CAAP;AACD;;AAbe,EAAA,MAAA,CAAA,aAAA,GAAa,aAAb;;AAehB,WAAgB,MAAhB,CACE,IADF,EAC8C;AAE5C,QAAI,QAAQ,CAAC,IAAD,CAAZ,EAAoB;AAClB,aAAO,IAAI,CAAC,IAAZ;AACD;;AACD,WAAO,IAAP;AACD;;AAPe,EAAA,MAAA,CAAA,MAAA,GAAM,MAAN;;AAShB,WAAgB,OAAhB,CACE,KADF,EAKgD;AAE9C,QAAI,KAAK,CAAC,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACxB,aAAO,KAAK,CAAC,GAAN,CAAU,UAAC,IAAD;AAAA,eAAU,MAAM,CAAC,IAAD,CAAhB;AAAA,OAAV,CAAP;AACD;;AAED,WAAO,CAAC,MAAM,CAAC,KAAD,CAAP,CAAP;AACD;;AAZe,EAAA,MAAA,CAAA,OAAA,GAAO,OAAP;AAajB,CA1ED,EAAiB,MAAM,KAAN,MAAM,GAAA,EAAA,CAAvB","sourceRoot":"","sourcesContent":["import { Path } from '../../geometry';\nimport * as Dom from '../dom/core';\nexport class Vector {\n    constructor(elem, attrs, children) {\n        if (!elem) {\n            throw new TypeError('Invalid element to create vector');\n        }\n        let node;\n        if (Vector.isVector(elem)) {\n            node = elem.node;\n        }\n        else if (typeof elem === 'string') {\n            if (elem.toLowerCase() === 'svg') {\n                node = Dom.createSvgDocument();\n            }\n            else if (elem[0] === '<') {\n                const doc = Dom.createSvgDocument(elem);\n                // only import the first child\n                node = document.importNode(doc.firstChild, true);\n            }\n            else {\n                node = document.createElementNS(Dom.ns.svg, elem);\n            }\n        }\n        else {\n            node = elem;\n        }\n        this.node = node;\n        if (attrs) {\n            this.setAttributes(attrs);\n        }\n        if (children) {\n            this.append(children);\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return Vector.toStringTag;\n    }\n    get type() {\n        return this.node.nodeName;\n    }\n    get id() {\n        return this.node.id;\n    }\n    set id(id) {\n        this.node.id = id;\n    }\n    transform(matrix, options) {\n        if (matrix == null) {\n            return Dom.transform(this.node);\n        }\n        Dom.transform(this.node, matrix, options);\n        return this;\n    }\n    translate(tx, ty = 0, options = {}) {\n        if (tx == null) {\n            return Dom.translate(this.node);\n        }\n        Dom.translate(this.node, tx, ty, options);\n        return this;\n    }\n    rotate(angle, cx, cy, options = {}) {\n        if (angle == null) {\n            return Dom.rotate(this.node);\n        }\n        Dom.rotate(this.node, angle, cx, cy, options);\n        return this;\n    }\n    scale(sx, sy) {\n        if (sx == null) {\n            return Dom.scale(this.node);\n        }\n        Dom.scale(this.node, sx, sy);\n        return this;\n    }\n    /**\n     * Returns an SVGMatrix that specifies the transformation necessary\n     * to convert this coordinate system into `target` coordinate system.\n     */\n    getTransformToElement(target) {\n        const ref = Vector.toNode(target);\n        return Dom.getTransformToElement(this.node, ref);\n    }\n    removeAttribute(name) {\n        Dom.removeAttribute(this.node, name);\n        return this;\n    }\n    getAttribute(name) {\n        return Dom.getAttribute(this.node, name);\n    }\n    setAttribute(name, value) {\n        Dom.setAttribute(this.node, name, value);\n        return this;\n    }\n    setAttributes(attrs) {\n        Dom.setAttributes(this.node, attrs);\n        return this;\n    }\n    attr(name, value) {\n        if (name == null) {\n            return Dom.attr(this.node);\n        }\n        if (typeof name === 'string' && value === undefined) {\n            return Dom.attr(this.node, name);\n        }\n        if (typeof name === 'object') {\n            Dom.attr(this.node, name);\n        }\n        else {\n            Dom.attr(this.node, name, value);\n        }\n        return this;\n    }\n    svg() {\n        return this.node instanceof SVGSVGElement\n            ? this\n            : Vector.create(this.node.ownerSVGElement);\n    }\n    defs() {\n        const context = this.svg() || this;\n        const defsNode = context.node.getElementsByTagName('defs')[0];\n        if (defsNode) {\n            return Vector.create(defsNode);\n        }\n        return Vector.create('defs').appendTo(context);\n    }\n    text(content, options = {}) {\n        Dom.text(this.node, content, options);\n        return this;\n    }\n    tagName() {\n        return Dom.tagName(this.node);\n    }\n    clone() {\n        return Vector.create(this.node.cloneNode(true));\n    }\n    remove() {\n        Dom.remove(this.node);\n        return this;\n    }\n    empty() {\n        Dom.empty(this.node);\n        return this;\n    }\n    append(elems) {\n        Dom.append(this.node, Vector.toNodes(elems));\n        return this;\n    }\n    appendTo(target) {\n        Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target);\n        return this;\n    }\n    prepend(elems) {\n        Dom.prepend(this.node, Vector.toNodes(elems));\n        return this;\n    }\n    before(elems) {\n        Dom.before(this.node, Vector.toNodes(elems));\n        return this;\n    }\n    replace(elem) {\n        if (this.node.parentNode) {\n            this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);\n        }\n        return Vector.create(elem);\n    }\n    first() {\n        return this.node.firstChild\n            ? Vector.create(this.node.firstChild)\n            : null;\n    }\n    last() {\n        return this.node.lastChild\n            ? Vector.create(this.node.lastChild)\n            : null;\n    }\n    get(index) {\n        const child = this.node.childNodes[index];\n        return child ? Vector.create(child) : null;\n    }\n    indexOf(elem) {\n        const children = Array.prototype.slice.call(this.node.childNodes);\n        return children.indexOf(Vector.toNode(elem));\n    }\n    find(selector) {\n        const vels = [];\n        const nodes = Dom.find(this.node, selector);\n        if (nodes) {\n            for (let i = 0, ii = nodes.length; i < ii; i += 1) {\n                vels.push(Vector.create(nodes[i]));\n            }\n        }\n        return vels;\n    }\n    findOne(selector) {\n        const found = Dom.findOne(this.node, selector);\n        return found ? Vector.create(found) : null;\n    }\n    findParentByClass(className, terminator) {\n        const node = Dom.findParentByClass(this.node, className, terminator);\n        return node ? Vector.create(node) : null;\n    }\n    matches(selector) {\n        const node = this.node;\n        const matches = this.node.matches;\n        const matcher = node.matches ||\n            node.matchesSelector ||\n            node.msMatchesSelector ||\n            node.mozMatchesSelector ||\n            node.webkitMatchesSelector ||\n            node.oMatchesSelector ||\n            null;\n        return matcher && matcher.call(node, selector);\n    }\n    contains(child) {\n        return Dom.contains(this.node, Vector.isVector(child) ? child.node : child);\n    }\n    wrap(node) {\n        const vel = Vector.create(node);\n        const parentNode = this.node.parentNode;\n        if (parentNode != null) {\n            parentNode.insertBefore(vel.node, this.node);\n        }\n        return vel.append(this);\n    }\n    parent(type) {\n        let parent = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        // check for parent\n        if (parent.node.parentNode == null) {\n            return null;\n        }\n        // get parent element\n        parent = Vector.create(parent.node.parentNode);\n        if (type == null) {\n            return parent;\n        }\n        // loop trough ancestors if type is given\n        do {\n            if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {\n                return parent;\n            }\n        } while ((parent = Vector.create(parent.node.parentNode)));\n        return parent;\n    }\n    children() {\n        const children = this.node.childNodes;\n        const vels = [];\n        for (let i = 0; i < children.length; i += 1) {\n            const currentChild = children[i];\n            if (currentChild.nodeType === 1) {\n                vels.push(Vector.create(children[i]));\n            }\n        }\n        return vels;\n    }\n    eachChild(fn, deep) {\n        const children = this.children();\n        for (let i = 0, l = children.length; i < l; i += 1) {\n            fn.call(children[i], children[i], i, children);\n            if (deep) {\n                children[i].eachChild(fn, deep);\n            }\n        }\n        return this;\n    }\n    index() {\n        return Dom.index(this.node);\n    }\n    hasClass(className) {\n        return Dom.hasClass(this.node, className);\n    }\n    addClass(className) {\n        Dom.addClass(this.node, className);\n        return this;\n    }\n    removeClass(className) {\n        Dom.removeClass(this.node, className);\n        return this;\n    }\n    toggleClass(className, stateVal) {\n        Dom.toggleClass(this.node, className, stateVal);\n        return this;\n    }\n    toLocalPoint(x, y) {\n        return Dom.toLocalPoint(this.node, x, y);\n    }\n    toGeometryShape() {\n        return Dom.toGeometryShape(this.node);\n    }\n    translateCenterToPoint(p) {\n        const bbox = this.getBBox({ target: this.svg() });\n        const center = bbox.getCenter();\n        this.translate(p.x - center.x, p.y - center.y);\n        return this;\n    }\n    translateAndAutoOrient(position, reference, target) {\n        Dom.translateAndAutoOrient(this.node, position, reference, target);\n        return this;\n    }\n    animate(options) {\n        return Dom.animate(this.node, options);\n    }\n    animateTransform(options) {\n        return Dom.animateTransform(this.node, options);\n    }\n    animateAlongPath(options, path) {\n        return Dom.animateAlongPath(this.node, options, path);\n    }\n    /**\n     * Normalize this element's d attribute. SVGPathElements without\n     * a path data attribute obtain a value of 'M 0 0'.\n     */\n    normalizePath() {\n        const tagName = this.tagName();\n        if (tagName === 'path') {\n            this.attr('d', Path.normalize(this.attr('d')));\n        }\n        return this;\n    }\n    /**\n     * Returns the bounding box of the element after transformations are applied.\n     * If `withoutTransformations` is `true`, transformations of the element\n     * will not be considered when computing the bounding box. If `target` is\n     * specified, bounding box will be computed relatively to the target element.\n     */\n    bbox(withoutTransformations, target) {\n        return Dom.bbox(this.node, withoutTransformations, target);\n    }\n    getBBox(options = {}) {\n        return Dom.getBBox(this.node, {\n            recursive: options.recursive,\n            target: options.target ? Vector.toNode(options.target) : null,\n        });\n    }\n    /**\n     * Samples the underlying SVG element (it currently works only on\n     * paths - where it is most useful anyway). Returns an array of objects\n     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n     * objects represent a point on the path. This basically creates a discrete\n     * representation of the path (which is possible a curve). The sampling\n     * interval defines the accuracy of the sampling. In other words, we travel\n     * from the beginning of the path to the end by interval distance (on the\n     * path, not between the resulting points) and collect the discrete points\n     * on the path. This is very useful in many situations. For example, SVG\n     * does not provide a built-in mechanism to find intersections between two\n     * paths. Using sampling, we can just generate bunch of points for each of\n     * the path and find the closest ones from each set.\n     */\n    sample(interval = 1) {\n        if (this.node instanceof SVGPathElement) {\n            return Dom.sample(this.node, interval);\n        }\n        return [];\n    }\n    toPath() {\n        return Vector.create(Dom.toPath(this.node));\n    }\n    toPathData() {\n        return Dom.toPathData(this.node);\n    }\n}\n(function (Vector) {\n    Vector.toStringTag = `X6.${Vector.name}`;\n    function isVector(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Vector) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const vector = instance;\n        if ((tag == null || tag === Vector.toStringTag) &&\n            vector.node instanceof SVGElement &&\n            typeof vector.animate === 'function' &&\n            typeof vector.sample === 'function' &&\n            typeof vector.normalizePath === 'function' &&\n            typeof vector.toPath === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Vector.isVector = isVector;\n    function create(elem, attrs, children) {\n        return new Vector(elem, attrs, children);\n    }\n    Vector.create = create;\n    function createVectors(markup) {\n        if (markup[0] === '<') {\n            const svgDoc = Dom.createSvgDocument(markup);\n            const vels = [];\n            for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n                const childNode = svgDoc.childNodes[i];\n                vels.push(create(document.importNode(childNode, true)));\n            }\n            return vels;\n        }\n        return [create(markup)];\n    }\n    Vector.createVectors = createVectors;\n    function toNode(elem) {\n        if (isVector(elem)) {\n            return elem.node;\n        }\n        return elem;\n    }\n    Vector.toNode = toNode;\n    function toNodes(elems) {\n        if (Array.isArray(elems)) {\n            return elems.map((elem) => toNode(elem));\n        }\n        return [toNode(elems)];\n    }\n    Vector.toNodes = toNodes;\n})(Vector || (Vector = {}));\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}