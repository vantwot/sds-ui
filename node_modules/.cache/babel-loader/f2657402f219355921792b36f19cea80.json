{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _possibleConstructorReturn from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/possibleConstructorReturn\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Line } from './line';\nimport { Geometry } from './geometry';\nexport var Polyline = /*#__PURE__*/function (_Geometry, _Symbol$toStringTag) {\n  _inherits(Polyline, _Geometry);\n\n  var _super = _createSuper(Polyline);\n\n  function Polyline(points) {\n    var _this;\n\n    _classCallCheck(this, Polyline);\n\n    _this = _super.call(this);\n\n    if (points != null) {\n      if (typeof points === 'string') {\n        return _possibleConstructorReturn(_this, Polyline.parse(points));\n      }\n\n      _this.points = points.map(function (p) {\n        return Point.create(p);\n      });\n    } else {\n      _this.points = [];\n    }\n\n    return _this;\n  }\n\n  _createClass(Polyline, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Polyline.toStringTag;\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      if (this.points.length === 0) {\n        return null;\n      }\n\n      return this.points[0];\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      if (this.points.length === 0) {\n        return null;\n      }\n\n      return this.points[this.points.length - 1];\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy) {\n      var origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n      this.points.forEach(function (p) {\n        return p.scale(sx, sy, origin);\n      });\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.points.forEach(function (p) {\n        return p.rotate(angle, origin);\n      });\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(dx, dy) {\n      var t = Point.create(dx, dy);\n      this.points.forEach(function (p) {\n        return p.translate(t.x, t.y);\n      });\n      return this;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      if (this.points.length === 0) {\n        return new Rectangle();\n      }\n\n      var x1 = Infinity;\n      var x2 = -Infinity;\n      var y1 = Infinity;\n      var y2 = -Infinity;\n      var points = this.points;\n\n      for (var i = 0, ii = points.length; i < ii; i += 1) {\n        var point = points[i];\n        var x = point.x;\n        var y = point.y;\n        if (x < x1) x1 = x;\n        if (x > x2) x2 = x;\n        if (y < y1) y1 = y;\n        if (y > y2) y2 = y;\n      }\n\n      return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      var cpLength = this.closestPointLength(p);\n      return this.pointAtLength(cpLength);\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0 || count === 1) {\n        return 0;\n      }\n\n      var length = 0;\n      var cpLength = 0;\n      var minSqrDistance = Infinity;\n\n      for (var i = 0, ii = count - 1; i < ii; i += 1) {\n        var line = new Line(points[i], points[i + 1]);\n        var lineLength = line.length();\n        var cpNormalizedLength = line.closestPointNormalizedLength(p);\n        var cp = line.pointAt(cpNormalizedLength);\n        var sqrDistance = cp.squaredDistance(p);\n\n        if (sqrDistance < minSqrDistance) {\n          minSqrDistance = sqrDistance;\n          cpLength = length + cpNormalizedLength * lineLength;\n        }\n\n        length += lineLength;\n      }\n\n      return cpLength;\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      var cpLength = this.closestPointLength(p);\n\n      if (cpLength === 0) {\n        return 0;\n      }\n\n      var length = this.length();\n\n      if (length === 0) {\n        return 0;\n      }\n\n      return cpLength / length;\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      var cpLength = this.closestPointLength(p);\n      return this.tangentAtLength(cpLength);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      if (this.points.length === 0) {\n        return false;\n      }\n\n      var ref = Point.clone(p);\n      var x = ref.x;\n      var y = ref.y;\n      var points = this.points;\n      var count = points.length;\n      var startIndex = count - 1;\n      var intersectionCount = 0;\n\n      for (var endIndex = 0; endIndex < count; endIndex += 1) {\n        var start = points[startIndex];\n        var end = points[endIndex];\n\n        if (ref.equals(start)) {\n          return true;\n        }\n\n        var segment = new Line(start, end);\n\n        if (segment.containsPoint(p)) {\n          return true;\n        } // do we have an intersection?\n\n\n        if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n          // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n          // (when `y === start.y === end.y`)\n          // this conditional branch IS entered when `segment` touches `ray` at only one point\n          // (e.g. when `y === start.y !== end.y`)\n          // since this branch is entered again for the following segment, the two touches cancel out\n          var xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n\n          if (xDifference >= 0) {\n            // segment lies at least partially to the right of `p`\n            var rayEnd = new Point(x + xDifference, y); // right\n\n            var ray = new Line(p, rayEnd);\n\n            if (segment.intersectsWithLine(ray)) {\n              // an intersection was detected to the right of `p`\n              intersectionCount += 1;\n            }\n          } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\n        } // move to check the next polyline segment\n\n\n        startIndex = endIndex;\n      } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n      return intersectionCount % 2 === 1;\n    }\n  }, {\n    key: \"intersectsWithLine\",\n    value: function intersectsWithLine(line) {\n      var intersections = [];\n\n      for (var i = 0, n = this.points.length - 1; i < n; i += 1) {\n        var a = this.points[i];\n        var b = this.points[i + 1];\n        var int = line.intersectsWithLine(new Line(a, b));\n\n        if (int) {\n          intersections.push(int);\n        }\n      }\n\n      return intersections.length > 0 ? intersections : null;\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      for (var i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n        var a = this.points[i];\n        var b = this.points[i + 1];\n        var line = new Line(a, b);\n\n        if (line.isDifferentiable()) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var len = 0;\n\n      for (var i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n        var a = this.points[i];\n        var b = this.points[i + 1];\n        len += a.distance(b);\n      }\n\n      return len;\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      if (count === 1) {\n        return points[0].clone();\n      }\n\n      if (ratio <= 0) {\n        return points[0].clone();\n      }\n\n      if (ratio >= 1) {\n        return points[count - 1].clone();\n      }\n\n      var total = this.length();\n      var length = total * ratio;\n      return this.pointAtLength(length);\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      if (count === 1) {\n        return points[0].clone();\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var tmp = 0;\n\n      for (var i = 0, ii = count - 1; i < ii; i += 1) {\n        var index = fromStart ? i : ii - 1 - i;\n        var a = points[index];\n        var b = points[index + 1];\n        var l = new Line(a, b);\n        var d = a.distance(b);\n\n        if (length <= tmp + d) {\n          return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));\n        }\n\n        tmp += d;\n      }\n\n      var lastPoint = fromStart ? points[count - 1] : points[0];\n      return lastPoint.clone();\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0 || count === 1) {\n        return null;\n      }\n\n      if (ratio < 0) {\n        ratio = 0; // eslint-disable-line\n      }\n\n      if (ratio > 1) {\n        ratio = 1; // eslint-disable-line\n      }\n\n      var total = this.length();\n      var length = total * ratio;\n      return this.tangentAtLength(length);\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0 || count === 1) {\n        return null;\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var lastValidLine;\n      var tmp = 0;\n\n      for (var i = 0, ii = count - 1; i < ii; i += 1) {\n        var index = fromStart ? i : ii - 1 - i;\n        var a = points[index];\n        var b = points[index + 1];\n        var l = new Line(a, b);\n        var d = a.distance(b);\n\n        if (l.isDifferentiable()) {\n          // has a tangent line (line length is not 0)\n          if (length <= tmp + d) {\n            return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));\n          }\n\n          lastValidLine = l;\n        }\n\n        tmp += d;\n      }\n\n      if (lastValidLine) {\n        var ratio = fromStart ? 1 : 0;\n        return lastValidLine.tangentAt(ratio);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"simplify\",\n    value: function simplify() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var points = this.points; // we need at least 3 points\n\n      if (points.length < 3) {\n        return this;\n      }\n\n      var threshold = options.threshold || 0; // start at the beginning of the polyline and go forward\n\n      var currentIndex = 0; // we need at least one intermediate point (3 points) in every iteration\n      // as soon as that stops being true, we know we reached the end of the polyline\n\n      while (points[currentIndex + 2]) {\n        var firstIndex = currentIndex;\n        var middleIndex = currentIndex + 1;\n        var lastIndex = currentIndex + 2;\n        var firstPoint = points[firstIndex];\n        var middlePoint = points[middleIndex];\n        var lastPoint = points[lastIndex];\n        var chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\n        var closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\n        var closestPointDistance = closestPoint.distance(middlePoint);\n\n        if (closestPointDistance <= threshold) {\n          // middle point is close enough to the chord = simplify\n          // 1) remove middle point:\n          points.splice(middleIndex, 1); // 2) in next iteration, investigate the newly-created triplet of points\n          //    - do not change `currentIndex`\n          //    = (first point stays, point after removed point becomes middle point)\n        } else {\n          // middle point is far from the chord\n          // 1) preserve middle point\n          // 2) in next iteration, move `currentIndex` by one step:\n          currentIndex += 1; //    = (point after first point becomes first point)\n        }\n      } // `points` array was modified in-place\n\n\n      return this;\n    }\n  }, {\n    key: \"toHull\",\n    value: function toHull() {\n      var points = this.points;\n      var count = points.length;\n\n      if (count === 0) {\n        return new Polyline();\n      } // Step 1: find the starting point -- point with\n      // the lowest y (if equality, highest x).\n\n\n      var startPoint = points[0];\n\n      for (var i = 1; i < count; i += 1) {\n        if (points[i].y < startPoint.y) {\n          startPoint = points[i];\n        } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n          startPoint = points[i];\n        }\n      } // Step 2: sort the list of points by angle between line\n      // from start point to current point and the x-axis (theta).\n      // Step 2a: create the point records = [point, originalIndex, angle]\n\n\n      var sortedRecords = [];\n\n      for (var _i = 0; _i < count; _i += 1) {\n        var angle = startPoint.theta(points[_i]);\n\n        if (angle === 0) {\n          // Give highest angle to start point.\n          // The start point will end up at end of sorted list.\n          // The start point will end up at beginning of hull points list.\n          angle = 360;\n        }\n\n        sortedRecords.push([points[_i], _i, angle]);\n      } // Step 2b: sort the list in place\n\n\n      sortedRecords.sort(function (record1, record2) {\n        var ret = record1[2] - record2[2];\n\n        if (ret === 0) {\n          ret = record2[1] - record1[1];\n        }\n\n        return ret;\n      }); // Step 2c: duplicate start record from the top of\n      // the stack to the bottom of the stack.\n\n      if (sortedRecords.length > 2) {\n        var _startPoint = sortedRecords[sortedRecords.length - 1];\n        sortedRecords.unshift(_startPoint);\n      } // Step 3\n      // ------\n      // Step 3a: go through sorted points in order and find those with\n      // right turns, and we want to get our results in clockwise order.\n      // Dictionary of points with left turns - cannot be on the hull.\n\n\n      var insidePoints = {}; // Stack of records with right turns - hull point candidates.\n\n      var hullRecords = [];\n\n      var getKey = function getKey(record) {\n        return \"\".concat(record[0].toString(), \"@\").concat(record[1]);\n      };\n\n      while (sortedRecords.length !== 0) {\n        var currentRecord = sortedRecords.pop();\n        var currentPoint = currentRecord[0]; // Check if point has already been discarded.\n\n        if (insidePoints[getKey(currentRecord)]) {\n          continue;\n        }\n\n        var correctTurnFound = false;\n\n        while (!correctTurnFound) {\n          if (hullRecords.length < 2) {\n            // Not enough points for comparison, just add current point.\n            hullRecords.push(currentRecord);\n            correctTurnFound = true;\n          } else {\n            var lastHullRecord = hullRecords.pop();\n            var lastHullPoint = lastHullRecord[0];\n            var secondLastHullRecord = hullRecords.pop();\n            var secondLastHullPoint = secondLastHullRecord[0];\n            var crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n            if (crossProduct < 0) {\n              // Found a right turn.\n              hullRecords.push(secondLastHullRecord);\n              hullRecords.push(lastHullRecord);\n              hullRecords.push(currentRecord);\n              correctTurnFound = true;\n            } else if (crossProduct === 0) {\n              // the three points are collinear\n              // three options:\n              // there may be a 180 or 0 degree angle at lastHullPoint\n              // or two of the three points are coincident\n              // we have to take rounding errors into account\n              var THRESHOLD = 1e-10;\n              var angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\n              if (Math.abs(angleBetween - 180) < THRESHOLD) {\n                // rouding around 180 to 180\n                // if the cross product is 0 because the angle is 180 degrees\n                // discard last hull point (add to insidePoints)\n                // insidePoints.unshift(lastHullPoint);\n                insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n                hullRecords.push(secondLastHullRecord); // do not do anything with current point\n                // correct turn not found\n              } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n                // if the cross product is 0 because two points are the same\n                // discard last hull point (add to insidePoints)\n                // insidePoints.unshift(lastHullPoint);\n                insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n                hullRecords.push(secondLastHullRecord); // do not do anything with current point\n                // correct turn not found\n              } else if (Math.abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n                // rounding around 0 and 360 to 0\n                // if the cross product is 0 because the angle is 0 degrees\n                // remove last hull point from hull BUT do not discard it\n                // reenter second-to-last hull point (will be last at next iter)\n                hullRecords.push(secondLastHullRecord); // put last hull point back into the sorted point records list\n\n                sortedRecords.push(lastHullRecord); // we are switching the order of the 0deg and 180deg points\n                // correct turn not found\n              }\n            } else {\n              // found a left turn\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter of loop)\n\n              hullRecords.push(secondLastHullRecord); // do not do anything with current point\n              // correct turn not found\n            }\n          }\n        }\n      } // At this point, hullPointRecords contains the output points in clockwise order\n      // the points start with lowest-y,highest-x startPoint, and end at the same point\n      // Step 3b: remove duplicated startPointRecord from the end of the array\n\n\n      if (hullRecords.length > 2) {\n        hullRecords.pop();\n      } // Step 4: find the lowest originalIndex record and put it at the beginning of hull\n\n\n      var lowestHullIndex; // the lowest originalIndex on the hull\n\n      var indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\n      for (var _i2 = 0, n = hullRecords.length; _i2 < n; _i2 += 1) {\n        var currentHullIndex = hullRecords[_i2][1];\n\n        if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n          lowestHullIndex = currentHullIndex;\n          indexOfLowestHullIndexRecord = _i2;\n        }\n      }\n\n      var hullPointRecordsReordered = [];\n\n      if (indexOfLowestHullIndexRecord > 0) {\n        var newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);\n        var newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);\n        hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n      } else {\n        hullPointRecordsReordered = hullRecords;\n      }\n\n      var hullPoints = [];\n\n      for (var _i3 = 0, _n = hullPointRecordsReordered.length; _i3 < _n; _i3 += 1) {\n        hullPoints.push(hullPointRecordsReordered[_i3][0]);\n      }\n\n      return new Polyline(hullPoints);\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(p) {\n      var _this2 = this;\n\n      if (p == null) {\n        return false;\n      }\n\n      if (p.points.length !== this.points.length) {\n        return false;\n      }\n\n      return p.points.every(function (a, i) {\n        return a.equals(_this2.points[i]);\n      });\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Polyline(this.points.map(function (p) {\n        return p.clone();\n      }));\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.points.map(function (p) {\n        return p.toJSON();\n      });\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return this.points.map(function (p) {\n        return \"\".concat(p.x, \", \").concat(p.y);\n      }).join(' ');\n    }\n  }]);\n\n  return Polyline;\n}(Geometry, Symbol.toStringTag);\n\n(function (Polyline) {\n  Polyline.toStringTag = \"X6.Geometry.\".concat(Polyline.name);\n\n  function isPolyline(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Polyline) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var polyline = instance;\n\n    if ((tag == null || tag === Polyline.toStringTag) && typeof polyline.toHull === 'function' && typeof polyline.simplify === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Polyline.isPolyline = isPolyline;\n})(Polyline || (Polyline = {}));\n\n(function (Polyline) {\n  function parse(svgString) {\n    var str = svgString.trim();\n\n    if (str === '') {\n      return new Polyline();\n    }\n\n    var points = [];\n    var coords = str.split(/\\s*,\\s*|\\s+/);\n\n    for (var i = 0, ii = coords.length; i < ii; i += 2) {\n      points.push({\n        x: +coords[i],\n        y: +coords[i + 1]\n      });\n    }\n\n    return new Polyline(points);\n  }\n\n  Polyline.parse = parse;\n})(Polyline || (Polyline = {}));","map":{"version":3,"sources":["../../src/geometry/polyline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Line } from './line';\nimport { Geometry } from './geometry';\nexport class Polyline extends Geometry {\n    constructor(points) {\n        super();\n        if (points != null) {\n            if (typeof points === 'string') {\n                return Polyline.parse(points);\n            }\n            this.points = points.map((p) => Point.create(p));\n        }\n        else {\n            this.points = [];\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return Polyline.toStringTag;\n    }\n    get start() {\n        if (this.points.length === 0) {\n            return null;\n        }\n        return this.points[0];\n    }\n    get end() {\n        if (this.points.length === 0) {\n            return null;\n        }\n        return this.points[this.points.length - 1];\n    }\n    scale(sx, sy, origin = new Point()) {\n        this.points.forEach((p) => p.scale(sx, sy, origin));\n        return this;\n    }\n    rotate(angle, origin) {\n        this.points.forEach((p) => p.rotate(angle, origin));\n        return this;\n    }\n    translate(dx, dy) {\n        const t = Point.create(dx, dy);\n        this.points.forEach((p) => p.translate(t.x, t.y));\n        return this;\n    }\n    bbox() {\n        if (this.points.length === 0) {\n            return new Rectangle();\n        }\n        let x1 = Infinity;\n        let x2 = -Infinity;\n        let y1 = Infinity;\n        let y2 = -Infinity;\n        const points = this.points;\n        for (let i = 0, ii = points.length; i < ii; i += 1) {\n            const point = points[i];\n            const x = point.x;\n            const y = point.y;\n            if (x < x1)\n                x1 = x;\n            if (x > x2)\n                x2 = x;\n            if (y < y1)\n                y1 = y;\n            if (y > y2)\n                y2 = y;\n        }\n        return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n    }\n    closestPoint(p) {\n        const cpLength = this.closestPointLength(p);\n        return this.pointAtLength(cpLength);\n    }\n    closestPointLength(p) {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0 || count === 1) {\n            return 0;\n        }\n        let length = 0;\n        let cpLength = 0;\n        let minSqrDistance = Infinity;\n        for (let i = 0, ii = count - 1; i < ii; i += 1) {\n            const line = new Line(points[i], points[i + 1]);\n            const lineLength = line.length();\n            const cpNormalizedLength = line.closestPointNormalizedLength(p);\n            const cp = line.pointAt(cpNormalizedLength);\n            const sqrDistance = cp.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                minSqrDistance = sqrDistance;\n                cpLength = length + cpNormalizedLength * lineLength;\n            }\n            length += lineLength;\n        }\n        return cpLength;\n    }\n    closestPointNormalizedLength(p) {\n        const cpLength = this.closestPointLength(p);\n        if (cpLength === 0) {\n            return 0;\n        }\n        const length = this.length();\n        if (length === 0) {\n            return 0;\n        }\n        return cpLength / length;\n    }\n    closestPointTangent(p) {\n        const cpLength = this.closestPointLength(p);\n        return this.tangentAtLength(cpLength);\n    }\n    containsPoint(p) {\n        if (this.points.length === 0) {\n            return false;\n        }\n        const ref = Point.clone(p);\n        const x = ref.x;\n        const y = ref.y;\n        const points = this.points;\n        const count = points.length;\n        let startIndex = count - 1;\n        let intersectionCount = 0;\n        for (let endIndex = 0; endIndex < count; endIndex += 1) {\n            const start = points[startIndex];\n            const end = points[endIndex];\n            if (ref.equals(start)) {\n                return true;\n            }\n            const segment = new Line(start, end);\n            if (segment.containsPoint(p)) {\n                return true;\n            }\n            // do we have an intersection?\n            if ((y <= start.y && y > end.y) || (y > start.y && y <= end.y)) {\n                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                // (when `y === start.y === end.y`)\n                // this conditional branch IS entered when `segment` touches `ray` at only one point\n                // (e.g. when `y === start.y !== end.y`)\n                // since this branch is entered again for the following segment, the two touches cancel out\n                const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n                if (xDifference >= 0) {\n                    // segment lies at least partially to the right of `p`\n                    const rayEnd = new Point(x + xDifference, y); // right\n                    const ray = new Line(p, rayEnd);\n                    if (segment.intersectsWithLine(ray)) {\n                        // an intersection was detected to the right of `p`\n                        intersectionCount += 1;\n                    }\n                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n            }\n            // move to check the next polyline segment\n            startIndex = endIndex;\n        }\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return intersectionCount % 2 === 1;\n    }\n    intersectsWithLine(line) {\n        const intersections = [];\n        for (let i = 0, n = this.points.length - 1; i < n; i += 1) {\n            const a = this.points[i];\n            const b = this.points[i + 1];\n            const int = line.intersectsWithLine(new Line(a, b));\n            if (int) {\n                intersections.push(int);\n            }\n        }\n        return intersections.length > 0 ? intersections : null;\n    }\n    isDifferentiable() {\n        for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n            const a = this.points[i];\n            const b = this.points[i + 1];\n            const line = new Line(a, b);\n            if (line.isDifferentiable()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    length() {\n        let len = 0;\n        for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n            const a = this.points[i];\n            const b = this.points[i + 1];\n            len += a.distance(b);\n        }\n        return len;\n    }\n    pointAt(ratio) {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0) {\n            return null;\n        }\n        if (count === 1) {\n            return points[0].clone();\n        }\n        if (ratio <= 0) {\n            return points[0].clone();\n        }\n        if (ratio >= 1) {\n            return points[count - 1].clone();\n        }\n        const total = this.length();\n        const length = total * ratio;\n        return this.pointAtLength(length);\n    }\n    pointAtLength(length) {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0) {\n            return null;\n        }\n        if (count === 1) {\n            return points[0].clone();\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        let tmp = 0;\n        for (let i = 0, ii = count - 1; i < ii; i += 1) {\n            const index = fromStart ? i : ii - 1 - i;\n            const a = points[index];\n            const b = points[index + 1];\n            const l = new Line(a, b);\n            const d = a.distance(b);\n            if (length <= tmp + d) {\n                return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));\n            }\n            tmp += d;\n        }\n        const lastPoint = fromStart ? points[count - 1] : points[0];\n        return lastPoint.clone();\n    }\n    tangentAt(ratio) {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0 || count === 1) {\n            return null;\n        }\n        if (ratio < 0) {\n            ratio = 0; // eslint-disable-line\n        }\n        if (ratio > 1) {\n            ratio = 1; // eslint-disable-line\n        }\n        const total = this.length();\n        const length = total * ratio;\n        return this.tangentAtLength(length);\n    }\n    tangentAtLength(length) {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0 || count === 1) {\n            return null;\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        let lastValidLine;\n        let tmp = 0;\n        for (let i = 0, ii = count - 1; i < ii; i += 1) {\n            const index = fromStart ? i : ii - 1 - i;\n            const a = points[index];\n            const b = points[index + 1];\n            const l = new Line(a, b);\n            const d = a.distance(b);\n            if (l.isDifferentiable()) {\n                // has a tangent line (line length is not 0)\n                if (length <= tmp + d) {\n                    return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));\n                }\n                lastValidLine = l;\n            }\n            tmp += d;\n        }\n        if (lastValidLine) {\n            const ratio = fromStart ? 1 : 0;\n            return lastValidLine.tangentAt(ratio);\n        }\n        return null;\n    }\n    simplify(\n    // TODO: Accept startIndex and endIndex to specify where to start and end simplification\n    options = {}) {\n        const points = this.points;\n        // we need at least 3 points\n        if (points.length < 3) {\n            return this;\n        }\n        const threshold = options.threshold || 0;\n        // start at the beginning of the polyline and go forward\n        let currentIndex = 0;\n        // we need at least one intermediate point (3 points) in every iteration\n        // as soon as that stops being true, we know we reached the end of the polyline\n        while (points[currentIndex + 2]) {\n            const firstIndex = currentIndex;\n            const middleIndex = currentIndex + 1;\n            const lastIndex = currentIndex + 2;\n            const firstPoint = points[firstIndex];\n            const middlePoint = points[middleIndex];\n            const lastPoint = points[lastIndex];\n            const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n            const closestPointDistance = closestPoint.distance(middlePoint);\n            if (closestPointDistance <= threshold) {\n                // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n                // 2) in next iteration, investigate the newly-created triplet of points\n                //    - do not change `currentIndex`\n                //    = (first point stays, point after removed point becomes middle point)\n            }\n            else {\n                // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n                //    = (point after first point becomes first point)\n            }\n        }\n        // `points` array was modified in-place\n        return this;\n    }\n    toHull() {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0) {\n            return new Polyline();\n        }\n        // Step 1: find the starting point -- point with\n        // the lowest y (if equality, highest x).\n        let startPoint = points[0];\n        for (let i = 1; i < count; i += 1) {\n            if (points[i].y < startPoint.y) {\n                startPoint = points[i];\n            }\n            else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n                startPoint = points[i];\n            }\n        }\n        // Step 2: sort the list of points by angle between line\n        // from start point to current point and the x-axis (theta).\n        // Step 2a: create the point records = [point, originalIndex, angle]\n        const sortedRecords = [];\n        for (let i = 0; i < count; i += 1) {\n            let angle = startPoint.theta(points[i]);\n            if (angle === 0) {\n                // Give highest angle to start point.\n                // The start point will end up at end of sorted list.\n                // The start point will end up at beginning of hull points list.\n                angle = 360;\n            }\n            sortedRecords.push([points[i], i, angle]);\n        }\n        // Step 2b: sort the list in place\n        sortedRecords.sort((record1, record2) => {\n            let ret = record1[2] - record2[2];\n            if (ret === 0) {\n                ret = record2[1] - record1[1];\n            }\n            return ret;\n        });\n        // Step 2c: duplicate start record from the top of\n        // the stack to the bottom of the stack.\n        if (sortedRecords.length > 2) {\n            const startPoint = sortedRecords[sortedRecords.length - 1];\n            sortedRecords.unshift(startPoint);\n        }\n        // Step 3\n        // ------\n        // Step 3a: go through sorted points in order and find those with\n        // right turns, and we want to get our results in clockwise order.\n        // Dictionary of points with left turns - cannot be on the hull.\n        const insidePoints = {};\n        // Stack of records with right turns - hull point candidates.\n        const hullRecords = [];\n        const getKey = (record) => `${record[0].toString()}@${record[1]}`;\n        while (sortedRecords.length !== 0) {\n            const currentRecord = sortedRecords.pop();\n            const currentPoint = currentRecord[0];\n            // Check if point has already been discarded.\n            if (insidePoints[getKey(currentRecord)]) {\n                continue;\n            }\n            let correctTurnFound = false;\n            while (!correctTurnFound) {\n                if (hullRecords.length < 2) {\n                    // Not enough points for comparison, just add current point.\n                    hullRecords.push(currentRecord);\n                    correctTurnFound = true;\n                }\n                else {\n                    const lastHullRecord = hullRecords.pop();\n                    const lastHullPoint = lastHullRecord[0];\n                    const secondLastHullRecord = hullRecords.pop();\n                    const secondLastHullPoint = secondLastHullRecord[0];\n                    const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n                    if (crossProduct < 0) {\n                        // Found a right turn.\n                        hullRecords.push(secondLastHullRecord);\n                        hullRecords.push(lastHullRecord);\n                        hullRecords.push(currentRecord);\n                        correctTurnFound = true;\n                    }\n                    else if (crossProduct === 0) {\n                        // the three points are collinear\n                        // three options:\n                        // there may be a 180 or 0 degree angle at lastHullPoint\n                        // or two of the three points are coincident\n                        // we have to take rounding errors into account\n                        const THRESHOLD = 1e-10;\n                        const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                        if (Math.abs(angleBetween - 180) < THRESHOLD) {\n                            // rouding around 180 to 180\n                            // if the cross product is 0 because the angle is 180 degrees\n                            // discard last hull point (add to insidePoints)\n                            // insidePoints.unshift(lastHullPoint);\n                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;\n                            // reenter second-to-last hull point (will be last at next iter)\n                            hullRecords.push(secondLastHullRecord);\n                            // do not do anything with current point\n                            // correct turn not found\n                        }\n                        else if (lastHullPoint.equals(currentPoint) ||\n                            secondLastHullPoint.equals(lastHullPoint)) {\n                            // if the cross product is 0 because two points are the same\n                            // discard last hull point (add to insidePoints)\n                            // insidePoints.unshift(lastHullPoint);\n                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;\n                            // reenter second-to-last hull point (will be last at next iter)\n                            hullRecords.push(secondLastHullRecord);\n                            // do not do anything with current point\n                            // correct turn not found\n                        }\n                        else if (Math.abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) {\n                            // rounding around 0 and 360 to 0\n                            // if the cross product is 0 because the angle is 0 degrees\n                            // remove last hull point from hull BUT do not discard it\n                            // reenter second-to-last hull point (will be last at next iter)\n                            hullRecords.push(secondLastHullRecord);\n                            // put last hull point back into the sorted point records list\n                            sortedRecords.push(lastHullRecord);\n                            // we are switching the order of the 0deg and 180deg points\n                            // correct turn not found\n                        }\n                    }\n                    else {\n                        // found a left turn\n                        // discard last hull point (add to insidePoints)\n                        // insidePoints.unshift(lastHullPoint);\n                        insidePoints[getKey(lastHullRecord)] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter of loop)\n                        hullRecords.push(secondLastHullRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n                    }\n                }\n            }\n        }\n        // At this point, hullPointRecords contains the output points in clockwise order\n        // the points start with lowest-y,highest-x startPoint, and end at the same point\n        // Step 3b: remove duplicated startPointRecord from the end of the array\n        if (hullRecords.length > 2) {\n            hullRecords.pop();\n        }\n        // Step 4: find the lowest originalIndex record and put it at the beginning of hull\n        let lowestHullIndex; // the lowest originalIndex on the hull\n        let indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n        for (let i = 0, n = hullRecords.length; i < n; i += 1) {\n            const currentHullIndex = hullRecords[i][1];\n            if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n                lowestHullIndex = currentHullIndex;\n                indexOfLowestHullIndexRecord = i;\n            }\n        }\n        let hullPointRecordsReordered = [];\n        if (indexOfLowestHullIndexRecord > 0) {\n            const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);\n            const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);\n            hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n        }\n        else {\n            hullPointRecordsReordered = hullRecords;\n        }\n        const hullPoints = [];\n        for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {\n            hullPoints.push(hullPointRecordsReordered[i][0]);\n        }\n        return new Polyline(hullPoints);\n    }\n    equals(p) {\n        if (p == null) {\n            return false;\n        }\n        if (p.points.length !== this.points.length) {\n            return false;\n        }\n        return p.points.every((a, i) => a.equals(this.points[i]));\n    }\n    clone() {\n        return new Polyline(this.points.map((p) => p.clone()));\n    }\n    toJSON() {\n        return this.points.map((p) => p.toJSON());\n    }\n    serialize() {\n        return this.points.map((p) => `${p.x}, ${p.y}`).join(' ');\n    }\n}\n(function (Polyline) {\n    Polyline.toStringTag = `X6.Geometry.${Polyline.name}`;\n    function isPolyline(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Polyline) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const polyline = instance;\n        if ((tag == null || tag === Polyline.toStringTag) &&\n            typeof polyline.toHull === 'function' &&\n            typeof polyline.simplify === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Polyline.isPolyline = isPolyline;\n})(Polyline || (Polyline = {}));\n(function (Polyline) {\n    function parse(svgString) {\n        const str = svgString.trim();\n        if (str === '') {\n            return new Polyline();\n        }\n        const points = [];\n        const coords = str.split(/\\s*,\\s*|\\s+/);\n        for (let i = 0, ii = coords.length; i < ii; i += 2) {\n            points.push({ x: +coords[i], y: +coords[i + 1] });\n        }\n        return new Polyline(points);\n    }\n    Polyline.parse = parse;\n})(Polyline || (Polyline = {}));\n//# sourceMappingURL=polyline.js.map"]},"metadata":{},"sourceType":"module"}