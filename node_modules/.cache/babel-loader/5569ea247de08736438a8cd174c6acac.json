{"ast":null,"code":"export var DataUri;\n\n(function (DataUri) {\n  function isDataUrl(url) {\n    const prefix = 'data:';\n    return url.substr(0, prefix.length) === prefix;\n  }\n\n  DataUri.isDataUrl = isDataUrl;\n  /**\n   * Converts an image at `url` to base64-encoded data uri.\n   * The mime type of the image is inferred from the `url` file extension.\n   */\n\n  function imageToDataUri(url, callback) {\n    // No need to convert to data uri if it is already in data uri.\n    if (!url || isDataUrl(url)) {\n      // Keep the async nature of the function.\n      setTimeout(() => callback(null, url));\n      return;\n    }\n\n    const onError = () => {\n      callback(new Error(`Failed to load image: ${url}`));\n    };\n\n    const onLoad = window.FileReader ? // chrome, IE10+\n    xhr => {\n      if (xhr.status === 200) {\n        const reader = new FileReader();\n\n        reader.onload = evt => {\n          const dataUri = evt.target.result;\n          callback(null, dataUri);\n        };\n\n        reader.onerror = onError;\n        reader.readAsDataURL(xhr.response);\n      } else {\n        onError();\n      }\n    } : xhr => {\n      const toString = u8a => {\n        const CHUNK_SZ = 0x8000;\n        const c = [];\n\n        for (let i = 0; i < u8a.length; i += CHUNK_SZ) {\n          c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n        }\n\n        return c.join('');\n      };\n\n      if (xhr.status === 200) {\n        let suffix = url.split('.').pop() || 'png';\n\n        if (suffix === 'svg') {\n          suffix = 'svg+xml';\n        }\n\n        const meta = `data:image/${suffix};base64,`;\n        const bytes = new Uint8Array(xhr.response);\n        const base64 = meta + btoa(toString(bytes));\n        callback(null, base64);\n      } else {\n        onError();\n      }\n    };\n    const xhr = new XMLHttpRequest();\n    xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n    xhr.open('GET', url, true);\n    xhr.addEventListener('error', onError);\n    xhr.addEventListener('load', () => onLoad(xhr));\n    xhr.send();\n  }\n\n  DataUri.imageToDataUri = imageToDataUri;\n\n  function dataUriToBlob(dataUrl) {\n    let uri = dataUrl.replace(/\\s/g, '');\n    uri = decodeURIComponent(uri);\n    const index = uri.indexOf(',');\n    const dataType = uri.slice(0, index); // e.g. 'data:image/jpeg;base64'\n\n    const mime = dataType.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n\n    const data = uri.slice(index + 1);\n    let decodedString;\n\n    if (dataType.indexOf('base64') >= 0) {\n      // data may be encoded in base64\n      decodedString = atob(data);\n    } else {\n      // convert the decoded string to UTF-8\n      decodedString = unescape(encodeURIComponent(data));\n    } // write the bytes of the string to a typed array\n\n\n    const ia = new Uint8Array(decodedString.length);\n\n    for (let i = 0; i < decodedString.length; i += 1) {\n      ia[i] = decodedString.charCodeAt(i);\n    }\n\n    return new Blob([ia], {\n      type: mime\n    });\n  }\n\n  DataUri.dataUriToBlob = dataUriToBlob;\n\n  function downloadBlob(blob, fileName) {\n    const msSaveBlob = window.navigator.msSaveBlob;\n\n    if (msSaveBlob) {\n      // requires IE 10+\n      // pulls up a save dialog\n      msSaveBlob(blob, fileName);\n    } else {\n      // other browsers\n      // downloads directly in Chrome and Safari\n      // presents a save/open dialog in Firefox\n      // Firefox bug: `from` field in save dialog always shows `from:blob:`\n      // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n      const url = window.URL.createObjectURL(blob);\n      const link = document.createElement('a');\n      link.href = url;\n      link.download = fileName;\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link); // mark the url for garbage collection\n\n      window.URL.revokeObjectURL(url);\n    }\n  }\n\n  DataUri.downloadBlob = downloadBlob;\n\n  function downloadDataUri(dataUrl, fileName) {\n    const blob = dataUriToBlob(dataUrl);\n    downloadBlob(blob, fileName);\n  }\n\n  DataUri.downloadDataUri = downloadDataUri;\n\n  function parseViewBox(svg) {\n    const matches = svg.match(/<svg[^>]*viewBox\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i);\n\n    if (matches && matches[2]) {\n      return matches[2].replace(/\\s+/, ' ').split(' ');\n    }\n\n    return null;\n  }\n\n  function getNumber(str) {\n    const ret = parseFloat(str);\n    return Number.isNaN(ret) ? null : ret;\n  }\n\n  function svgToDataUrl(svg) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let viewBox = null;\n\n    const getNumberFromViewBox = index => {\n      if (viewBox == null) {\n        viewBox = parseViewBox(svg);\n      }\n\n      if (viewBox != null) {\n        return getNumber(viewBox[index]);\n      }\n\n      return null;\n    };\n\n    const getNumberFromMatches = reg => {\n      const matches = svg.match(reg);\n\n      if (matches && matches[2]) {\n        return getNumber(matches[2]);\n      }\n\n      return null;\n    };\n\n    let w = options.width;\n\n    if (w == null) {\n      w = getNumberFromMatches(/<svg[^>]*width\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i);\n    }\n\n    if (w == null) {\n      w = getNumberFromViewBox(2);\n    }\n\n    if (w == null) {\n      throw new Error('Can not parse width from svg string');\n    }\n\n    let h = options.height;\n\n    if (h == null) {\n      h = getNumberFromMatches(/<svg[^>]*height\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i);\n    }\n\n    if (h == null) {\n      h = getNumberFromViewBox(3);\n    }\n\n    if (h == null) {\n      throw new Error('Can not parse height from svg string');\n    }\n\n    const decoded = encodeURIComponent(svg).replace(/'/g, '%27').replace(/\"/g, '%22');\n    const header = 'data:image/svg+xml';\n    const dataUrl = `${header},${decoded}`;\n    return dataUrl;\n  }\n\n  DataUri.svgToDataUrl = svgToDataUrl;\n})(DataUri || (DataUri = {}));","map":{"version":3,"sources":["../../../src/util/datauri/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export var DataUri;\n(function (DataUri) {\n    function isDataUrl(url) {\n        const prefix = 'data:';\n        return url.substr(0, prefix.length) === prefix;\n    }\n    DataUri.isDataUrl = isDataUrl;\n    /**\n     * Converts an image at `url` to base64-encoded data uri.\n     * The mime type of the image is inferred from the `url` file extension.\n     */\n    function imageToDataUri(url, callback) {\n        // No need to convert to data uri if it is already in data uri.\n        if (!url || isDataUrl(url)) {\n            // Keep the async nature of the function.\n            setTimeout(() => callback(null, url));\n            return;\n        }\n        const onError = () => {\n            callback(new Error(`Failed to load image: ${url}`));\n        };\n        const onLoad = window.FileReader\n            ? // chrome, IE10+\n                (xhr) => {\n                    if (xhr.status === 200) {\n                        const reader = new FileReader();\n                        reader.onload = (evt) => {\n                            const dataUri = evt.target.result;\n                            callback(null, dataUri);\n                        };\n                        reader.onerror = onError;\n                        reader.readAsDataURL(xhr.response);\n                    }\n                    else {\n                        onError();\n                    }\n                }\n            : (xhr) => {\n                const toString = (u8a) => {\n                    const CHUNK_SZ = 0x8000;\n                    const c = [];\n                    for (let i = 0; i < u8a.length; i += CHUNK_SZ) {\n                        c.push(String.fromCharCode.apply(null, u8a.subarray(i, i + CHUNK_SZ)));\n                    }\n                    return c.join('');\n                };\n                if (xhr.status === 200) {\n                    let suffix = url.split('.').pop() || 'png';\n                    if (suffix === 'svg') {\n                        suffix = 'svg+xml';\n                    }\n                    const meta = `data:image/${suffix};base64,`;\n                    const bytes = new Uint8Array(xhr.response);\n                    const base64 = meta + btoa(toString(bytes));\n                    callback(null, base64);\n                }\n                else {\n                    onError();\n                }\n            };\n        const xhr = new XMLHttpRequest();\n        xhr.responseType = window.FileReader ? 'blob' : 'arraybuffer';\n        xhr.open('GET', url, true);\n        xhr.addEventListener('error', onError);\n        xhr.addEventListener('load', () => onLoad(xhr));\n        xhr.send();\n    }\n    DataUri.imageToDataUri = imageToDataUri;\n    function dataUriToBlob(dataUrl) {\n        let uri = dataUrl.replace(/\\s/g, '');\n        uri = decodeURIComponent(uri);\n        const index = uri.indexOf(',');\n        const dataType = uri.slice(0, index); // e.g. 'data:image/jpeg;base64'\n        const mime = dataType.split(':')[1].split(';')[0]; // e.g. 'image/jpeg'\n        const data = uri.slice(index + 1);\n        let decodedString;\n        if (dataType.indexOf('base64') >= 0) {\n            // data may be encoded in base64\n            decodedString = atob(data);\n        }\n        else {\n            // convert the decoded string to UTF-8\n            decodedString = unescape(encodeURIComponent(data));\n        }\n        // write the bytes of the string to a typed array\n        const ia = new Uint8Array(decodedString.length);\n        for (let i = 0; i < decodedString.length; i += 1) {\n            ia[i] = decodedString.charCodeAt(i);\n        }\n        return new Blob([ia], { type: mime });\n    }\n    DataUri.dataUriToBlob = dataUriToBlob;\n    function downloadBlob(blob, fileName) {\n        const msSaveBlob = window.navigator.msSaveBlob;\n        if (msSaveBlob) {\n            // requires IE 10+\n            // pulls up a save dialog\n            msSaveBlob(blob, fileName);\n        }\n        else {\n            // other browsers\n            // downloads directly in Chrome and Safari\n            // presents a save/open dialog in Firefox\n            // Firefox bug: `from` field in save dialog always shows `from:blob:`\n            // https://bugzilla.mozilla.org/show_bug.cgi?id=1053327\n            const url = window.URL.createObjectURL(blob);\n            const link = document.createElement('a');\n            link.href = url;\n            link.download = fileName;\n            document.body.appendChild(link);\n            link.click();\n            document.body.removeChild(link);\n            // mark the url for garbage collection\n            window.URL.revokeObjectURL(url);\n        }\n    }\n    DataUri.downloadBlob = downloadBlob;\n    function downloadDataUri(dataUrl, fileName) {\n        const blob = dataUriToBlob(dataUrl);\n        downloadBlob(blob, fileName);\n    }\n    DataUri.downloadDataUri = downloadDataUri;\n    function parseViewBox(svg) {\n        const matches = svg.match(/<svg[^>]*viewBox\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i);\n        if (matches && matches[2]) {\n            return matches[2].replace(/\\s+/, ' ').split(' ');\n        }\n        return null;\n    }\n    function getNumber(str) {\n        const ret = parseFloat(str);\n        return Number.isNaN(ret) ? null : ret;\n    }\n    function svgToDataUrl(svg, options = {}) {\n        let viewBox = null;\n        const getNumberFromViewBox = (index) => {\n            if (viewBox == null) {\n                viewBox = parseViewBox(svg);\n            }\n            if (viewBox != null) {\n                return getNumber(viewBox[index]);\n            }\n            return null;\n        };\n        const getNumberFromMatches = (reg) => {\n            const matches = svg.match(reg);\n            if (matches && matches[2]) {\n                return getNumber(matches[2]);\n            }\n            return null;\n        };\n        let w = options.width;\n        if (w == null) {\n            w = getNumberFromMatches(/<svg[^>]*width\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i);\n        }\n        if (w == null) {\n            w = getNumberFromViewBox(2);\n        }\n        if (w == null) {\n            throw new Error('Can not parse width from svg string');\n        }\n        let h = options.height;\n        if (h == null) {\n            h = getNumberFromMatches(/<svg[^>]*height\\s*=\\s*([\"']?)(.+?)\\1[^>]*>/i);\n        }\n        if (h == null) {\n            h = getNumberFromViewBox(3);\n        }\n        if (h == null) {\n            throw new Error('Can not parse height from svg string');\n        }\n        const decoded = encodeURIComponent(svg)\n            .replace(/'/g, '%27')\n            .replace(/\"/g, '%22');\n        const header = 'data:image/svg+xml';\n        const dataUrl = `${header},${decoded}`;\n        return dataUrl;\n    }\n    DataUri.svgToDataUrl = svgToDataUrl;\n})(DataUri || (DataUri = {}));\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}