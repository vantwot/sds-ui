{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _class, _descriptor;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { lazyInject, TYPES } from '@antv/l7-core';\nvar BaseMapWrapper = (_dec = lazyInject(TYPES.IGlobalConfigService), (_class = function () {\n  function BaseMapWrapper(config) {\n    _classCallCheck(this, BaseMapWrapper);\n\n    _initializerDefineProperty(this, \"configService\", _descriptor, this);\n\n    _defineProperty(this, \"config\", void 0);\n\n    this.config = config;\n  }\n\n  _createClass(BaseMapWrapper, [{\n    key: \"setContainer\",\n    value: function setContainer(sceneContainer, id, canvas, hasBaseMap) {\n      sceneContainer.bind(TYPES.MapConfig).toConstantValue(_objectSpread(_objectSpread({}, this.config), {}, {\n        id: id,\n        canvas: canvas,\n        hasBaseMap: hasBaseMap\n      }));\n      sceneContainer.bind(TYPES.IMapService).to(this.getServiceConstructor()).inSingletonScope();\n    }\n  }, {\n    key: \"getServiceConstructor\",\n    value: function getServiceConstructor() {\n      throw new Error('Method not implemented.');\n    }\n  }]);\n\n  return BaseMapWrapper;\n}(), _descriptor = _applyDecoratedDescriptor(_class.prototype, \"configService\", [_dec], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class));\nexport { BaseMapWrapper as default };","map":{"version":3,"sources":["../src/BaseMapWrapper.ts"],"names":["BaseMapWrapper","lazyInject","TYPES","sceneContainer","id","canvas","hasBaseMap"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,UAAA,EAAA,KAAA,QAAA,eAAA;IASqBA,c,WAClBC,UAAU,CAACC,KAAK,CAAN,oBAAA,C;AAKX,WAAA,cAAA,CAAA,MAAA,EAAyC;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,cAAA,CAAA;;AAAA,IAAA,0BAAA,CAAA,IAAA,EAAA,eAAA,EAAA,WAAA,EAAA,IAAA,CAAA;;AAAA,IAAA,eAAA,CAAA,IAAA,EAAA,QAAA,EAAA,KAAA,CAAA,CAAA;;AACvC,SAAA,MAAA,GAAA,MAAA;AACD;;;;WAED,SAAA,YAAA,CAAA,cAAA,EAAA,EAAA,EAAA,MAAA,EAAA,UAAA,EAKE;AAWAC,MAAAA,cAAc,CAAdA,IAAAA,CAAyCD,KAAK,CAA9CC,SAAAA,EAAAA,eAAAA,CAAAA,aAAAA,CAAAA,aAAAA,CAAAA,EAAAA,EACK,KADLA,MAAAA,CAAAA,EAAAA,EAAAA,EAAAA;AAEEC,QAAAA,EAAE,EAFJD,EAAAA;AAGEE,QAAAA,MAAM,EAHRF,MAAAA;AAIEG,QAAAA,UAAU,EAAVA;AAJFH,OAAAA,CAAAA;AAMAA,MAAAA,cAAc,CAAdA,IAAAA,CAC6BD,KAAK,CADlCC,WAAAA,EAAAA,EAAAA,CAEM,KAFNA,qBAEM,EAFNA,EAAAA,gBAAAA;AAID;;;WAED,SAAA,qBAAA,GAEE;AACA,YAAM,IAAA,KAAA,CAAN,yBAAM,CAAN;AACD;;;;;;;;;;SA1CkBH,c","sourcesContent":["import {\n  IGlobalConfigService,\n  IMapConfig,\n  IMapService,\n  IMapWrapper,\n  lazyInject,\n  TYPES,\n} from '@antv/l7-core';\nimport { Container } from 'inversify';\nexport default class BaseMapWrapper<RawMap> implements IMapWrapper {\n  @lazyInject(TYPES.IGlobalConfigService)\n  protected readonly configService: IGlobalConfigService;\n\n  protected config: Partial<IMapConfig>;\n\n  constructor(config: Partial<IMapConfig>) {\n    this.config = config;\n  }\n\n  public setContainer(\n    sceneContainer: Container,\n    id: string | HTMLDivElement,\n    canvas?: HTMLCanvasElement,\n    hasBaseMap?: boolean,\n  ) {\n    // // 首先使用全局配置服务校验地图参数\n    // const { valid, errorText } = this.configService.validateMapConfig(\n    //   this.config,\n    // );\n\n    // if (!valid) {\n    //   this.logger.error(errorText || '');\n    //   return;\n    // }\n    // 绑定用户传入的原始地图参数\n    sceneContainer.bind<Partial<IMapConfig>>(TYPES.MapConfig).toConstantValue({\n      ...this.config,\n      id,\n      canvas,\n      hasBaseMap,\n    });\n    sceneContainer\n      .bind<IMapService<RawMap>>(TYPES.IMapService)\n      .to(this.getServiceConstructor())\n      .inSingletonScope();\n  }\n\n  protected getServiceConstructor(): new (...args: any[]) => IMapService<\n    RawMap\n  > {\n    throw new Error('Method not implemented.');\n  }\n}\n"]},"metadata":{},"sourceType":"module"}