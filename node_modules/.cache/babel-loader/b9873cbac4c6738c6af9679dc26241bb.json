{"ast":null,"code":"const isEdgeView = (val, _ref) => {\n  let {\n    view\n  } = _ref;\n  return view.cell.isEdge();\n};\n\nexport const connection = {\n  qualify: isEdgeView,\n\n  set(val, args) {\n    const view = args.view;\n    const stubs = val.stubs || 0;\n    let d;\n\n    if (Number.isFinite(stubs) && stubs !== 0) {\n      let offset;\n\n      if (stubs < 0) {\n        const len = view.getConnectionLength() || 0;\n        offset = (len + stubs) / 2;\n      } else {\n        offset = stubs;\n      }\n\n      const path = view.getConnection();\n\n      if (path) {\n        const sourceParts = path.divideAtLength(offset);\n        const targetParts = path.divideAtLength(-offset);\n\n        if (sourceParts && targetParts) {\n          d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n        }\n      }\n    }\n\n    return {\n      d: d || view.getConnectionPathData()\n    };\n  }\n\n};\nexport const atConnectionLengthKeepGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', {\n    rotate: true\n  })\n};\nexport const atConnectionLengthIgnoreGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtLength', {\n    rotate: false\n  })\n};\nexport const atConnectionRatioKeepGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', {\n    rotate: true\n  })\n};\nexport const atConnectionRatioIgnoreGradient = {\n  qualify: isEdgeView,\n  set: atConnectionWrapper('getTangentAtRatio', {\n    rotate: false\n  })\n}; // aliases\n// -------\n\nexport const atConnectionLength = atConnectionLengthKeepGradient;\nexport const atConnectionRatio = atConnectionRatioKeepGradient; // utils\n// -----\n\nfunction atConnectionWrapper(method, options) {\n  const zeroVector = {\n    x: 1,\n    y: 0\n  };\n  return (value, args) => {\n    let p;\n    let angle;\n    const view = args.view;\n    const tangent = view[method](Number(value));\n\n    if (tangent) {\n      angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n      p = tangent.start;\n    } else {\n      p = view.path.start;\n      angle = 0;\n    }\n\n    if (angle === 0) {\n      return {\n        transform: `translate(${p.x},${p.y}')`\n      };\n    }\n\n    return {\n      transform: `translate(${p.x},${p.y}') rotate(${angle})`\n    };\n  };\n}","map":{"version":3,"sources":["../../../src/registry/attr/connection.ts"],"names":[],"mappings":"AAGA,MAAM,UAAU,GAAyB,CAAC,GAAD,WAAkB;AAAA,MAAZ;AAAE,IAAA;AAAF,GAAY;AACzD,SAAO,IAAI,CAAC,IAAL,CAAU,MAAV,EAAP;AACD,CAFD;;AAIA,OAAO,MAAM,UAAU,GAAoB;AACzC,EAAA,OAAO,EAAE,UADgC;;AAEzC,EAAA,GAAG,CAAC,GAAD,EAAM,IAAN,EAAU;AACX,UAAM,IAAI,GAAG,IAAI,CAAC,IAAlB;AACA,UAAM,KAAK,GAAK,GAAW,CAAC,KAAZ,IAAqB,CAArC;AACA,QAAI,CAAJ;;AACA,QAAI,MAAM,CAAC,QAAP,CAAgB,KAAhB,KAA0B,KAAK,KAAK,CAAxC,EAA2C;AACzC,UAAI,MAAJ;;AACA,UAAI,KAAK,GAAG,CAAZ,EAAe;AACb,cAAM,GAAG,GAAG,IAAI,CAAC,mBAAL,MAA8B,CAA1C;AACA,QAAA,MAAM,GAAG,CAAC,GAAG,GAAG,KAAP,IAAgB,CAAzB;AACD,OAHD,MAGO;AACL,QAAA,MAAM,GAAG,KAAT;AACD;;AAED,YAAM,IAAI,GAAG,IAAI,CAAC,aAAL,EAAb;;AACA,UAAI,IAAJ,EAAU;AACR,cAAM,WAAW,GAAG,IAAI,CAAC,cAAL,CAAoB,MAApB,CAApB;AACA,cAAM,WAAW,GAAG,IAAI,CAAC,cAAL,CAAoB,CAAC,MAArB,CAApB;;AACA,YAAI,WAAW,IAAI,WAAnB,EAAgC;AAC9B,UAAA,CAAC,GAAG,GAAG,WAAW,CAAC,CAAD,CAAX,CAAe,SAAf,EAA0B,IAAI,WAAW,CAAC,CAAD,CAAX,CAAe,SAAf,EAA0B,EAA/D;AACD;AACF;AACF;;AAED,WAAO;AAAE,MAAA,CAAC,EAAE,CAAC,IAAI,IAAI,CAAC,qBAAL;AAAV,KAAP;AACD;;AA1BwC,CAApC;AA6BP,OAAO,MAAM,8BAA8B,GAAoB;AAC7D,EAAA,OAAO,EAAE,UADoD;AAE7D,EAAA,GAAG,EAAE,mBAAmB,CAAC,oBAAD,EAAuB;AAAE,IAAA,MAAM,EAAE;AAAV,GAAvB;AAFqC,CAAxD;AAKP,OAAO,MAAM,gCAAgC,GAAoB;AAC/D,EAAA,OAAO,EAAE,UADsD;AAE/D,EAAA,GAAG,EAAE,mBAAmB,CAAC,oBAAD,EAAuB;AAAE,IAAA,MAAM,EAAE;AAAV,GAAvB;AAFuC,CAA1D;AAKP,OAAO,MAAM,6BAA6B,GAAoB;AAC5D,EAAA,OAAO,EAAE,UADmD;AAE5D,EAAA,GAAG,EAAE,mBAAmB,CAAC,mBAAD,EAAsB;AAAE,IAAA,MAAM,EAAE;AAAV,GAAtB;AAFoC,CAAvD;AAKP,OAAO,MAAM,+BAA+B,GAAoB;AAC9D,EAAA,OAAO,EAAE,UADqD;AAE9D,EAAA,GAAG,EAAE,mBAAmB,CAAC,mBAAD,EAAsB;AAAE,IAAA,MAAM,EAAE;AAAV,GAAtB;AAFsC,CAAzD,C,CAKP;AACA;;AACA,OAAO,MAAM,kBAAkB,GAAG,8BAA3B;AACP,OAAO,MAAM,iBAAiB,GAAG,6BAA1B,C,CAEP;AACA;;AAEA,SAAS,mBAAT,CACE,MADF,EAEE,OAFF,EAE8B;AAE5B,QAAM,UAAU,GAAG;AAAE,IAAA,CAAC,EAAE,CAAL;AAAQ,IAAA,CAAC,EAAE;AAAX,GAAnB;AAEA,SAAO,CAAC,KAAD,EAAQ,IAAR,KAAgB;AACrB,QAAI,CAAJ;AACA,QAAI,KAAJ;AAEA,UAAM,IAAI,GAAG,IAAI,CAAC,IAAlB;AACA,UAAM,OAAO,GAAG,IAAI,CAAC,MAAD,CAAJ,CAAa,MAAM,CAAC,KAAD,CAAnB,CAAhB;;AACA,QAAI,OAAJ,EAAa;AACX,MAAA,KAAK,GAAG,OAAO,CAAC,MAAR,GAAiB,OAAO,CAAC,MAAR,GAAiB,WAAjB,CAA6B,UAA7B,CAAjB,GAA4D,CAApE;AACA,MAAA,CAAC,GAAG,OAAO,CAAC,KAAZ;AACD,KAHD,MAGO;AACL,MAAA,CAAC,GAAI,IAAY,CAAC,IAAb,CAAkB,KAAvB;AACA,MAAA,KAAK,GAAG,CAAR;AACD;;AAED,QAAI,KAAK,KAAK,CAAd,EAAiB;AACf,aAAO;AAAE,QAAA,SAAS,EAAE,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC;AAApC,OAAP;AACD;;AAED,WAAO;AACL,MAAA,SAAS,EAAE,aAAa,CAAC,CAAC,CAAC,IAAI,CAAC,CAAC,CAAC,aAAa,KAAK;AAD/C,KAAP;AAGD,GArBD;AAsBD","sourceRoot":"","sourcesContent":["const isEdgeView = (val, { view }) => {\n    return view.cell.isEdge();\n};\nexport const connection = {\n    qualify: isEdgeView,\n    set(val, args) {\n        const view = args.view;\n        const stubs = (val.stubs || 0);\n        let d;\n        if (Number.isFinite(stubs) && stubs !== 0) {\n            let offset;\n            if (stubs < 0) {\n                const len = view.getConnectionLength() || 0;\n                offset = (len + stubs) / 2;\n            }\n            else {\n                offset = stubs;\n            }\n            const path = view.getConnection();\n            if (path) {\n                const sourceParts = path.divideAtLength(offset);\n                const targetParts = path.divideAtLength(-offset);\n                if (sourceParts && targetParts) {\n                    d = `${sourceParts[0].serialize()} ${targetParts[1].serialize()}`;\n                }\n            }\n        }\n        return { d: d || view.getConnectionPathData() };\n    },\n};\nexport const atConnectionLengthKeepGradient = {\n    qualify: isEdgeView,\n    set: atConnectionWrapper('getTangentAtLength', { rotate: true }),\n};\nexport const atConnectionLengthIgnoreGradient = {\n    qualify: isEdgeView,\n    set: atConnectionWrapper('getTangentAtLength', { rotate: false }),\n};\nexport const atConnectionRatioKeepGradient = {\n    qualify: isEdgeView,\n    set: atConnectionWrapper('getTangentAtRatio', { rotate: true }),\n};\nexport const atConnectionRatioIgnoreGradient = {\n    qualify: isEdgeView,\n    set: atConnectionWrapper('getTangentAtRatio', { rotate: false }),\n};\n// aliases\n// -------\nexport const atConnectionLength = atConnectionLengthKeepGradient;\nexport const atConnectionRatio = atConnectionRatioKeepGradient;\n// utils\n// -----\nfunction atConnectionWrapper(method, options) {\n    const zeroVector = { x: 1, y: 0 };\n    return (value, args) => {\n        let p;\n        let angle;\n        const view = args.view;\n        const tangent = view[method](Number(value));\n        if (tangent) {\n            angle = options.rotate ? tangent.vector().vectorAngle(zeroVector) : 0;\n            p = tangent.start;\n        }\n        else {\n            p = view.path.start;\n            angle = 0;\n        }\n        if (angle === 0) {\n            return { transform: `translate(${p.x},${p.y}')` };\n        }\n        return {\n            transform: `translate(${p.x},${p.y}') rotate(${angle})`,\n        };\n    };\n}\n//# sourceMappingURL=connection.js.map"]},"metadata":{},"sourceType":"module"}