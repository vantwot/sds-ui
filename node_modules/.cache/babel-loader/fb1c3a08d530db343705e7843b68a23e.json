{"ast":null,"code":"import { Path, Point } from '../../geometry';\nexport var loop = function loop(sourcePoint, targetPoint, routePoints) {\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var fix = routePoints.length === 3 ? 0 : 1;\n  var p1 = Point.create(routePoints[0 + fix]);\n  var p2 = Point.create(routePoints[2 + fix]);\n  var center = Point.create(routePoints[1 + fix]);\n\n  if (!Point.equals(sourcePoint, targetPoint)) {\n    var middle = new Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);\n    var angle = middle.angleBetween(Point.create(sourcePoint).rotate(90, middle), center);\n\n    if (angle > 1) {\n      p1.rotate(180 - angle, middle);\n      p2.rotate(180 - angle, middle);\n      center.rotate(180 - angle, middle);\n    }\n  }\n\n  var pathData = \"\\n     M \".concat(sourcePoint.x, \" \").concat(sourcePoint.y, \"\\n     Q \").concat(p1.x, \" \").concat(p1.y, \" \").concat(center.x, \" \").concat(center.y, \"\\n     Q \").concat(p2.x, \" \").concat(p2.y, \" \").concat(targetPoint.x, \" \").concat(targetPoint.y, \"\\n  \");\n  return options.raw ? Path.parse(pathData) : pathData;\n};","map":{"version":3,"sources":["../../../src/registry/connector/loop.ts"],"names":[],"mappings":"AAAA,SAAS,IAAT,EAAe,KAAf,QAA4B,gBAA5B;AAOA,OAAO,IAAM,IAAI,GAA+C,SAAnD,IAAmD,CAC9D,WAD8D,EAE9D,WAF8D,EAG9D,WAH8D,EAIlD;AAAA,MAAZ,OAAY,uEAAF,EAAE;AAEZ,MAAM,GAAG,GAAG,WAAW,CAAC,MAAZ,KAAuB,CAAvB,GAA2B,CAA3B,GAA+B,CAA3C;AACA,MAAM,EAAE,GAAG,KAAK,CAAC,MAAN,CAAa,WAAW,CAAC,IAAI,GAAL,CAAxB,CAAX;AACA,MAAM,EAAE,GAAG,KAAK,CAAC,MAAN,CAAa,WAAW,CAAC,IAAI,GAAL,CAAxB,CAAX;AACA,MAAM,MAAM,GAAG,KAAK,CAAC,MAAN,CAAa,WAAW,CAAC,IAAI,GAAL,CAAxB,CAAf;;AAEA,MAAI,CAAC,KAAK,CAAC,MAAN,CAAa,WAAb,EAA0B,WAA1B,CAAL,EAA6C;AAC3C,QAAM,MAAM,GAAG,IAAI,KAAJ,CACb,CAAC,WAAW,CAAC,CAAZ,GAAgB,WAAW,CAAC,CAA7B,IAAkC,CADrB,EAEb,CAAC,WAAW,CAAC,CAAZ,GAAgB,WAAW,CAAC,CAA7B,IAAkC,CAFrB,CAAf;AAIA,QAAM,KAAK,GAAG,MAAM,CAAC,YAAP,CACZ,KAAK,CAAC,MAAN,CAAa,WAAb,EAA0B,MAA1B,CAAiC,EAAjC,EAAqC,MAArC,CADY,EAEZ,MAFY,CAAd;;AAIA,QAAI,KAAK,GAAG,CAAZ,EAAe;AACb,MAAA,EAAE,CAAC,MAAH,CAAU,MAAM,KAAhB,EAAuB,MAAvB;AACA,MAAA,EAAE,CAAC,MAAH,CAAU,MAAM,KAAhB,EAAuB,MAAvB;AACA,MAAA,MAAM,CAAC,MAAP,CAAc,MAAM,KAApB,EAA2B,MAA3B;AACD;AACF;;AAED,MAAM,QAAQ,sBACP,WAAW,CAAC,CADL,cACU,WAAW,CAAC,CADtB,sBAEP,EAAE,CAAC,CAFI,cAEC,EAAE,CAAC,CAFJ,cAES,MAAM,CAAC,CAFhB,cAEqB,MAAM,CAAC,CAF5B,sBAGP,EAAE,CAAC,CAHI,cAGC,EAAE,CAAC,CAHJ,cAGS,WAAW,CAAC,CAHrB,cAG0B,WAAW,CAAC,CAHtC,SAAd;AAMA,SAAO,OAAO,CAAC,GAAR,GAAc,IAAI,CAAC,KAAL,CAAW,QAAX,CAAd,GAAqC,QAA5C;AACD,CAlCM","sourceRoot":"","sourcesContent":["import { Path, Point } from '../../geometry';\nexport const loop = function (sourcePoint, targetPoint, routePoints, options = {}) {\n    const fix = routePoints.length === 3 ? 0 : 1;\n    const p1 = Point.create(routePoints[0 + fix]);\n    const p2 = Point.create(routePoints[2 + fix]);\n    const center = Point.create(routePoints[1 + fix]);\n    if (!Point.equals(sourcePoint, targetPoint)) {\n        const middle = new Point((sourcePoint.x + targetPoint.x) / 2, (sourcePoint.y + targetPoint.y) / 2);\n        const angle = middle.angleBetween(Point.create(sourcePoint).rotate(90, middle), center);\n        if (angle > 1) {\n            p1.rotate(180 - angle, middle);\n            p2.rotate(180 - angle, middle);\n            center.rotate(180 - angle, middle);\n        }\n    }\n    const pathData = `\n     M ${sourcePoint.x} ${sourcePoint.y}\n     Q ${p1.x} ${p1.y} ${center.x} ${center.y}\n     Q ${p2.x} ${p2.y} ${targetPoint.x} ${targetPoint.y}\n  `;\n    return options.raw ? Path.parse(pathData) : pathData;\n};\n//# sourceMappingURL=loop.js.map"]},"metadata":{},"sourceType":"module"}