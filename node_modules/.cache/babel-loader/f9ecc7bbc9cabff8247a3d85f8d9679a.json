{"ast":null,"code":"import { PriorityQueue } from './priorityqueue';\nexport var Dijkstra;\n\n(function (Dijkstra) {\n  function run(adjacencyList, source) {\n    let weight = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : (u, v) => 1;\n    const dist = {};\n    const previous = {};\n    const scanned = {};\n    const queue = new PriorityQueue();\n    dist[source] = 0;\n    Object.keys(adjacencyList).forEach(v => {\n      if (v !== source) {\n        dist[v] = Infinity;\n      }\n\n      queue.insert(dist[v], v, v);\n    });\n\n    while (!queue.isEmpty()) {\n      const u = queue.remove();\n      scanned[u] = true;\n      const neighbours = adjacencyList[u] || [];\n\n      for (let i = 0; i < neighbours.length; i += 1) {\n        const v = neighbours[i];\n\n        if (!scanned[v]) {\n          const alt = dist[u] + weight(u, v);\n\n          if (alt < dist[v]) {\n            dist[v] = alt;\n            previous[v] = u;\n            queue.updatePriority(v, alt);\n          }\n        }\n      }\n    }\n\n    return previous;\n  }\n\n  Dijkstra.run = run;\n})(Dijkstra || (Dijkstra = {}));","map":{"version":3,"sources":["../../../src/common/algorithm/dijkstra.ts"],"names":[],"mappings":"AAAA,SAAS,aAAT,QAA8B,iBAA9B;AAEA,OAAM,IAAW,QAAX;;AAAN,CAAA,UAAiB,QAAjB,EAAyB;AAIvB,WAAgB,GAAhB,CACE,aADF,EAEE,MAFF,EAG8B;AAAA,QAA5B,MAA4B,uEAAX,CAAC,CAAD,EAAI,CAAJ,KAAU,CAAC;AAE5B,UAAM,IAAI,GAA8B,EAAxC;AACA,UAAM,QAAQ,GAA8B,EAA5C;AACA,UAAM,OAAO,GAA+B,EAA5C;AACA,UAAM,KAAK,GAAG,IAAI,aAAJ,EAAd;AAEA,IAAA,IAAI,CAAC,MAAD,CAAJ,GAAe,CAAf;AAEA,IAAA,MAAM,CAAC,IAAP,CAAY,aAAZ,EAA2B,OAA3B,CAAoC,CAAD,IAAM;AACvC,UAAI,CAAC,KAAK,MAAV,EAAkB;AAChB,QAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,QAAV;AACD;;AACD,MAAA,KAAK,CAAC,MAAN,CAAa,IAAI,CAAC,CAAD,CAAjB,EAAsB,CAAtB,EAAyB,CAAzB;AACD,KALD;;AAOA,WAAO,CAAC,KAAK,CAAC,OAAN,EAAR,EAAyB;AACvB,YAAM,CAAC,GAAG,KAAK,CAAC,MAAN,EAAV;AACA,MAAA,OAAO,CAAC,CAAD,CAAP,GAAa,IAAb;AAEA,YAAM,UAAU,GAAG,aAAa,CAAC,CAAD,CAAb,IAAoB,EAAvC;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,UAAU,CAAC,MAA/B,EAAuC,CAAC,IAAI,CAA5C,EAA+C;AAC7C,cAAM,CAAC,GAAG,UAAU,CAAC,CAAD,CAApB;;AACA,YAAI,CAAC,OAAO,CAAC,CAAD,CAAZ,EAAiB;AACf,gBAAM,GAAG,GAAG,IAAI,CAAC,CAAD,CAAJ,GAAU,MAAM,CAAC,CAAD,EAAI,CAAJ,CAA5B;;AACA,cAAI,GAAG,GAAG,IAAI,CAAC,CAAD,CAAd,EAAmB;AACjB,YAAA,IAAI,CAAC,CAAD,CAAJ,GAAU,GAAV;AACA,YAAA,QAAQ,CAAC,CAAD,CAAR,GAAc,CAAd;AACA,YAAA,KAAK,CAAC,cAAN,CAAqB,CAArB,EAAwB,GAAxB;AACD;AACF;AACF;AACF;;AAED,WAAO,QAAP;AACD;;AAtCe,EAAA,QAAA,CAAA,GAAA,GAAG,GAAH;AAuCjB,CA3CD,EAAiB,QAAQ,KAAR,QAAQ,GAAA,EAAA,CAAzB","sourceRoot":"","sourcesContent":["import { PriorityQueue } from './priorityqueue';\nexport var Dijkstra;\n(function (Dijkstra) {\n    function run(adjacencyList, source, weight = (u, v) => 1) {\n        const dist = {};\n        const previous = {};\n        const scanned = {};\n        const queue = new PriorityQueue();\n        dist[source] = 0;\n        Object.keys(adjacencyList).forEach((v) => {\n            if (v !== source) {\n                dist[v] = Infinity;\n            }\n            queue.insert(dist[v], v, v);\n        });\n        while (!queue.isEmpty()) {\n            const u = queue.remove();\n            scanned[u] = true;\n            const neighbours = adjacencyList[u] || [];\n            for (let i = 0; i < neighbours.length; i += 1) {\n                const v = neighbours[i];\n                if (!scanned[v]) {\n                    const alt = dist[u] + weight(u, v);\n                    if (alt < dist[v]) {\n                        dist[v] = alt;\n                        previous[v] = u;\n                        queue.updatePriority(v, alt);\n                    }\n                }\n            }\n        }\n        return previous;\n    }\n    Dijkstra.run = run;\n})(Dijkstra || (Dijkstra = {}));\n//# sourceMappingURL=dijkstra.js.map"]},"metadata":{},"sourceType":"module"}