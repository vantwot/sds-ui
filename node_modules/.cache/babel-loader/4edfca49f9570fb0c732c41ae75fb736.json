{"ast":null,"code":"import { ObjectExt } from '../object';\nimport { mergeAttrs } from '../dom/attr';\nexport function annotate(t, annotations) {\n  let opt = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const offset = opt.offset || 0;\n  const compacted = [];\n  const ret = [];\n  let curr;\n  let prev;\n  let batch = null;\n\n  for (let i = 0; i < t.length; i += 1) {\n    curr = ret[i] = t[i];\n\n    for (let j = 0, jj = annotations.length; j < jj; j += 1) {\n      const annotation = annotations[j];\n      const start = annotation.start + offset;\n      const end = annotation.end + offset;\n\n      if (i >= start && i < end) {\n        if (typeof curr === 'string') {\n          curr = ret[i] = {\n            t: t[i],\n            attrs: annotation.attrs\n          };\n        } else {\n          curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs);\n        }\n\n        if (opt.includeAnnotationIndices) {\n          if (curr.annotations == null) {\n            curr.annotations = [];\n          }\n\n          curr.annotations.push(j);\n        }\n      }\n    }\n\n    prev = ret[i - 1];\n\n    if (!prev) {\n      batch = curr;\n    } else if (ObjectExt.isObject(curr) && ObjectExt.isObject(prev)) {\n      batch = batch; // Both previous item and the current one are annotations.\n      // If the attributes didn't change, merge the text.\n\n      if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {\n        batch.t += curr.t;\n      } else {\n        compacted.push(batch);\n        batch = curr;\n      }\n    } else if (ObjectExt.isObject(curr)) {\n      // Previous item was a string, current item is an annotation.\n      batch = batch;\n      compacted.push(batch);\n      batch = curr;\n    } else if (ObjectExt.isObject(prev)) {\n      // Previous item was an annotation, current item is a string.\n      batch = batch;\n      compacted.push(batch);\n      batch = curr;\n    } else {\n      // Both previous and current item are strings.\n      batch = (batch || '') + curr;\n    }\n  }\n\n  if (batch != null) {\n    compacted.push(batch);\n  }\n\n  return compacted;\n}\nexport function findAnnotationsAtIndex(annotations, index) {\n  return annotations ? annotations.filter(a => a.start < index && index <= a.end) : [];\n}\nexport function findAnnotationsBetweenIndexes(annotations, start, end) {\n  return annotations ? annotations.filter(a => start >= a.start && start < a.end || end > a.start && end <= a.end || a.start >= start && a.end < end) : [];\n}\nexport function shiftAnnotations(annotations, index, offset) {\n  if (annotations) {\n    annotations.forEach(a => {\n      if (a.start < index && a.end >= index) {\n        a.end += offset;\n      } else if (a.start >= index) {\n        a.start += offset;\n        a.end += offset;\n      }\n    });\n  }\n\n  return annotations;\n}","map":{"version":3,"sources":["../../../src/util/text/annotate.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ObjectExt } from '../object';\nimport { mergeAttrs } from '../dom/attr';\nexport function annotate(t, annotations, opt = {}) {\n    const offset = opt.offset || 0;\n    const compacted = [];\n    const ret = [];\n    let curr;\n    let prev;\n    let batch = null;\n    for (let i = 0; i < t.length; i += 1) {\n        curr = ret[i] = t[i];\n        for (let j = 0, jj = annotations.length; j < jj; j += 1) {\n            const annotation = annotations[j];\n            const start = annotation.start + offset;\n            const end = annotation.end + offset;\n            if (i >= start && i < end) {\n                if (typeof curr === 'string') {\n                    curr = ret[i] = {\n                        t: t[i],\n                        attrs: annotation.attrs,\n                    };\n                }\n                else {\n                    curr.attrs = mergeAttrs(mergeAttrs({}, curr.attrs), annotation.attrs);\n                }\n                if (opt.includeAnnotationIndices) {\n                    if (curr.annotations == null) {\n                        curr.annotations = [];\n                    }\n                    curr.annotations.push(j);\n                }\n            }\n        }\n        prev = ret[i - 1];\n        if (!prev) {\n            batch = curr;\n        }\n        else if (ObjectExt.isObject(curr) && ObjectExt.isObject(prev)) {\n            batch = batch;\n            // Both previous item and the current one are annotations.\n            // If the attributes didn't change, merge the text.\n            if (JSON.stringify(curr.attrs) === JSON.stringify(prev.attrs)) {\n                batch.t += curr.t;\n            }\n            else {\n                compacted.push(batch);\n                batch = curr;\n            }\n        }\n        else if (ObjectExt.isObject(curr)) {\n            // Previous item was a string, current item is an annotation.\n            batch = batch;\n            compacted.push(batch);\n            batch = curr;\n        }\n        else if (ObjectExt.isObject(prev)) {\n            // Previous item was an annotation, current item is a string.\n            batch = batch;\n            compacted.push(batch);\n            batch = curr;\n        }\n        else {\n            // Both previous and current item are strings.\n            batch = (batch || '') + curr;\n        }\n    }\n    if (batch != null) {\n        compacted.push(batch);\n    }\n    return compacted;\n}\nexport function findAnnotationsAtIndex(annotations, index) {\n    return annotations\n        ? annotations.filter((a) => a.start < index && index <= a.end)\n        : [];\n}\nexport function findAnnotationsBetweenIndexes(annotations, start, end) {\n    return annotations\n        ? annotations.filter((a) => (start >= a.start && start < a.end) ||\n            (end > a.start && end <= a.end) ||\n            (a.start >= start && a.end < end))\n        : [];\n}\nexport function shiftAnnotations(annotations, index, offset) {\n    if (annotations) {\n        annotations.forEach((a) => {\n            if (a.start < index && a.end >= index) {\n                a.end += offset;\n            }\n            else if (a.start >= index) {\n                a.start += offset;\n                a.end += offset;\n            }\n        });\n    }\n    return annotations;\n}\n//# sourceMappingURL=annotate.js.map"]},"metadata":{},"sourceType":"module"}