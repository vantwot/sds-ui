{"ast":null,"code":"import _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Angle, Point, Line } from '../../geometry';\n\nfunction rollup(points, merge) {\n  if (merge != null && merge !== false) {\n    var amount = typeof merge === 'boolean' ? 0 : merge;\n\n    if (amount > 0) {\n      var center1 = Point.create(points[1]).move(points[2], amount);\n      var center2 = Point.create(points[1]).move(points[0], amount);\n      return [center1.toJSON()].concat(_toConsumableArray(points), [center2.toJSON()]);\n    }\n\n    {\n      var center = points[1];\n      return [Object.assign({}, center)].concat(_toConsumableArray(points), [Object.assign({}, center)]);\n    }\n  }\n\n  return points;\n}\n\nexport var loop = function loop(vertices, options, edgeView) {\n  var width = options.width || 50;\n  var height = options.height || 80;\n  var halfHeight = height / 2;\n  var angle = options.angle || 'auto';\n  var sourceAnchor = edgeView.sourceAnchor;\n  var targetAnchor = edgeView.targetAnchor;\n  var sourceBBox = edgeView.sourceBBox;\n  var targetBBox = edgeView.targetBBox;\n\n  if (sourceAnchor.equals(targetAnchor)) {\n    var getVertices = function getVertices(angle) {\n      var rad = Angle.toRad(angle);\n      var sin = Math.sin(rad);\n      var cos = Math.cos(rad);\n      var center = new Point(sourceAnchor.x + cos * width, sourceAnchor.y + sin * width);\n      var ref = new Point(center.x - cos * halfHeight, center.y - sin * halfHeight);\n      var p1 = ref.clone().rotate(-90, center);\n      var p2 = ref.clone().rotate(90, center);\n      return [p1.toJSON(), center.toJSON(), p2.toJSON()];\n    };\n\n    var validate = function validate(end) {\n      var start = sourceAnchor.clone().move(end, -1);\n      var line = new Line(start, end);\n      return !sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line);\n    };\n\n    var angles = [0, 90, 180, 270, 45, 135, 225, 315];\n\n    if (typeof angle === 'number') {\n      return rollup(getVertices(angle), options.merge);\n    }\n\n    var center = sourceBBox.getCenter();\n\n    if (center.equals(sourceAnchor)) {\n      return rollup(getVertices(0), options.merge);\n    }\n\n    var deg = center.angleBetween(sourceAnchor, center.clone().translate(1, 0));\n    var ret = getVertices(deg);\n\n    if (validate(ret[1])) {\n      return rollup(ret, options.merge);\n    } // return the best vertices\n\n\n    for (var i = 1, l = angles.length; i < l; i += 1) {\n      ret = getVertices(deg + angles[i]);\n\n      if (validate(ret[1])) {\n        return rollup(ret, options.merge);\n      }\n    }\n\n    return rollup(ret, options.merge);\n  }\n\n  {\n    var line = new Line(sourceAnchor, targetAnchor);\n    var parallel = line.parallel(-width);\n\n    var _center = parallel.getCenter();\n\n    var p1 = parallel.start.clone().move(parallel.end, halfHeight);\n    var p2 = parallel.end.clone().move(parallel.start, halfHeight);\n    var ref = line.parallel(-1);\n    var line1 = new Line(ref.start, _center);\n    var line2 = new Line(ref.end, _center);\n\n    if (sourceBBox.containsPoint(_center) || targetBBox.containsPoint(_center) || sourceBBox.intersectsWithLine(line1) || sourceBBox.intersectsWithLine(line2) || targetBBox.intersectsWithLine(line1) || targetBBox.intersectsWithLine(line2)) {\n      parallel = line.parallel(width);\n      _center = parallel.getCenter();\n      p1 = parallel.start.clone().move(parallel.end, halfHeight);\n      p2 = parallel.end.clone().move(parallel.start, halfHeight);\n    }\n\n    if (options.merge) {\n      var _line = new Line(sourceAnchor, targetAnchor);\n\n      var normal = new Line(_center, _line.center).setLength(Number.MAX_SAFE_INTEGER);\n      var intersects1 = sourceBBox.intersectsWithLine(normal);\n      var intersects2 = targetBBox.intersectsWithLine(normal);\n      var intersects = intersects1 ? Array.isArray(intersects1) ? intersects1 : [intersects1] : [];\n\n      if (intersects2) {\n        if (Array.isArray(intersects2)) {\n          intersects.push.apply(intersects, _toConsumableArray(intersects2));\n        } else {\n          intersects.push(intersects2);\n        }\n      }\n\n      var anchor = _line.center.closest(intersects);\n\n      if (anchor) {\n        edgeView.sourceAnchor = anchor.clone();\n        edgeView.targetAnchor = anchor.clone();\n      } else {\n        edgeView.sourceAnchor = _line.center.clone();\n        edgeView.targetAnchor = _line.center.clone();\n      }\n    }\n\n    return rollup([p1.toJSON(), _center.toJSON(), p2.toJSON()], options.merge);\n  }\n};","map":{"version":3,"sources":["../../../src/registry/router/loop.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Angle, Point, Line } from '../../geometry';\nfunction rollup(points, merge) {\n    if (merge != null && merge !== false) {\n        const amount = typeof merge === 'boolean' ? 0 : merge;\n        if (amount > 0) {\n            const center1 = Point.create(points[1]).move(points[2], amount);\n            const center2 = Point.create(points[1]).move(points[0], amount);\n            return [center1.toJSON(), ...points, center2.toJSON()];\n        }\n        {\n            const center = points[1];\n            return [Object.assign({}, center), ...points, Object.assign({}, center)];\n        }\n    }\n    return points;\n}\nexport const loop = function (vertices, options, edgeView) {\n    const width = options.width || 50;\n    const height = options.height || 80;\n    const halfHeight = height / 2;\n    const angle = options.angle || 'auto';\n    const sourceAnchor = edgeView.sourceAnchor;\n    const targetAnchor = edgeView.targetAnchor;\n    const sourceBBox = edgeView.sourceBBox;\n    const targetBBox = edgeView.targetBBox;\n    if (sourceAnchor.equals(targetAnchor)) {\n        const getVertices = (angle) => {\n            const rad = Angle.toRad(angle);\n            const sin = Math.sin(rad);\n            const cos = Math.cos(rad);\n            const center = new Point(sourceAnchor.x + cos * width, sourceAnchor.y + sin * width);\n            const ref = new Point(center.x - cos * halfHeight, center.y - sin * halfHeight);\n            const p1 = ref.clone().rotate(-90, center);\n            const p2 = ref.clone().rotate(90, center);\n            return [p1.toJSON(), center.toJSON(), p2.toJSON()];\n        };\n        const validate = (end) => {\n            const start = sourceAnchor.clone().move(end, -1);\n            const line = new Line(start, end);\n            return (!sourceBBox.containsPoint(end) && !sourceBBox.intersectsWithLine(line));\n        };\n        const angles = [0, 90, 180, 270, 45, 135, 225, 315];\n        if (typeof angle === 'number') {\n            return rollup(getVertices(angle), options.merge);\n        }\n        const center = sourceBBox.getCenter();\n        if (center.equals(sourceAnchor)) {\n            return rollup(getVertices(0), options.merge);\n        }\n        const deg = center.angleBetween(sourceAnchor, center.clone().translate(1, 0));\n        let ret = getVertices(deg);\n        if (validate(ret[1])) {\n            return rollup(ret, options.merge);\n        }\n        // return the best vertices\n        for (let i = 1, l = angles.length; i < l; i += 1) {\n            ret = getVertices(deg + angles[i]);\n            if (validate(ret[1])) {\n                return rollup(ret, options.merge);\n            }\n        }\n        return rollup(ret, options.merge);\n    }\n    {\n        const line = new Line(sourceAnchor, targetAnchor);\n        let parallel = line.parallel(-width);\n        let center = parallel.getCenter();\n        let p1 = parallel.start.clone().move(parallel.end, halfHeight);\n        let p2 = parallel.end.clone().move(parallel.start, halfHeight);\n        const ref = line.parallel(-1);\n        const line1 = new Line(ref.start, center);\n        const line2 = new Line(ref.end, center);\n        if (sourceBBox.containsPoint(center) ||\n            targetBBox.containsPoint(center) ||\n            sourceBBox.intersectsWithLine(line1) ||\n            sourceBBox.intersectsWithLine(line2) ||\n            targetBBox.intersectsWithLine(line1) ||\n            targetBBox.intersectsWithLine(line2)) {\n            parallel = line.parallel(width);\n            center = parallel.getCenter();\n            p1 = parallel.start.clone().move(parallel.end, halfHeight);\n            p2 = parallel.end.clone().move(parallel.start, halfHeight);\n        }\n        if (options.merge) {\n            const line = new Line(sourceAnchor, targetAnchor);\n            const normal = new Line(center, line.center).setLength(Number.MAX_SAFE_INTEGER);\n            const intersects1 = sourceBBox.intersectsWithLine(normal);\n            const intersects2 = targetBBox.intersectsWithLine(normal);\n            const intersects = intersects1\n                ? Array.isArray(intersects1)\n                    ? intersects1\n                    : [intersects1]\n                : [];\n            if (intersects2) {\n                if (Array.isArray(intersects2)) {\n                    intersects.push(...intersects2);\n                }\n                else {\n                    intersects.push(intersects2);\n                }\n            }\n            const anchor = line.center.closest(intersects);\n            if (anchor) {\n                edgeView.sourceAnchor = anchor.clone();\n                edgeView.targetAnchor = anchor.clone();\n            }\n            else {\n                edgeView.sourceAnchor = line.center.clone();\n                edgeView.targetAnchor = line.center.clone();\n            }\n        }\n        return rollup([p1.toJSON(), center.toJSON(), p2.toJSON()], options.merge);\n    }\n};\n//# sourceMappingURL=loop.js.map"]},"metadata":{},"sourceType":"module"}