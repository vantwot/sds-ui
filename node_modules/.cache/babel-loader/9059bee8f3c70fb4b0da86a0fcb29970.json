{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Util, Config } from '../global';\nimport { ArrayExt, FunctionExt, Dom, Vector } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Cell } from '../model/cell';\nimport { CellView } from './cell';\nimport { Markup } from './markup';\nexport var NodeView = /*#__PURE__*/function (_CellView, _Symbol$toStringTag) {\n  _inherits(NodeView, _CellView);\n\n  var _super = _createSuper(NodeView);\n\n  function NodeView() {\n    var _this;\n\n    _classCallCheck(this, NodeView);\n\n    _this = _super.apply(this, arguments);\n    _this.scalableNode = null;\n    _this.rotatableNode = null;\n    _this.scalableSelector = 'scalable';\n    _this.rotatableSelector = 'rotatable';\n    _this.defaultPortMarkup = Markup.getPortMarkup();\n    _this.defaultPortLabelMarkup = Markup.getPortLabelMarkup();\n    _this.defaultPortContainerMarkup = Markup.getPortContainerMarkup();\n    _this.portsCache = {}; // #endregion\n\n    return _this;\n  }\n\n  _createClass(NodeView, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return NodeView.toStringTag;\n    }\n  }, {\n    key: \"getContainerClassName\",\n    value: function getContainerClassName() {\n      var classList = [_get(_getPrototypeOf(NodeView.prototype), \"getContainerClassName\", this).call(this), this.prefixClassName('node')];\n\n      if (!this.can('nodeMovable')) {\n        classList.push(this.prefixClassName('node-immovable'));\n      }\n\n      return classList.join(' ');\n    }\n  }, {\n    key: \"updateClassName\",\n    value: function updateClassName(e) {\n      var target = e.target;\n\n      if (target.hasAttribute('magnet')) {\n        // port\n        var className = this.prefixClassName('port-unconnectable');\n\n        if (this.can('magnetConnectable')) {\n          Dom.removeClass(target, className);\n        } else {\n          Dom.addClass(target, className);\n        }\n      } else {\n        // node\n        var _className = this.prefixClassName('node-immovable');\n\n        if (this.can('nodeMovable')) {\n          this.removeClass(_className);\n        } else {\n          this.addClass(_className);\n        }\n      }\n    }\n  }, {\n    key: \"isNodeView\",\n    value: function isNodeView() {\n      return true;\n    }\n  }, {\n    key: \"confirmUpdate\",\n    value: function confirmUpdate(flag) {\n      var _this2 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var ret = flag;\n\n      if (this.hasAction(ret, 'ports')) {\n        this.removePorts();\n        this.cleanPortsCache();\n      }\n\n      if (this.hasAction(ret, 'render')) {\n        this.render();\n        ret = this.removeAction(ret, ['render', 'update', 'resize', 'translate', 'rotate', 'ports', 'tools']);\n      } else {\n        ret = this.handleAction(ret, 'resize', function () {\n          return _this2.resize(options);\n        }, 'update');\n        ret = this.handleAction(ret, 'update', function () {\n          return _this2.update();\n        }, // `update()` will render ports when useCSSSelectors are enabled\n        Config.useCSSSelector ? 'ports' : null);\n        ret = this.handleAction(ret, 'translate', function () {\n          return _this2.translate();\n        });\n        ret = this.handleAction(ret, 'rotate', function () {\n          return _this2.rotate();\n        });\n        ret = this.handleAction(ret, 'ports', function () {\n          return _this2.renderPorts();\n        });\n        ret = this.handleAction(ret, 'tools', function () {\n          return _this2.renderTools();\n        });\n      }\n\n      return ret;\n    }\n  }, {\n    key: \"update\",\n    value: function update(partialAttrs) {\n      this.cleanCache(); // When CSS selector strings are used, make sure no rule matches port nodes.\n\n      if (Config.useCSSSelector) {\n        this.removePorts();\n      }\n\n      var node = this.cell;\n      var size = node.getSize();\n      var attrs = node.getAttrs();\n      this.updateAttrs(this.container, attrs, {\n        attrs: partialAttrs === attrs ? null : partialAttrs,\n        rootBBox: new Rectangle(0, 0, size.width, size.height),\n        selectors: this.selectors,\n        scalableNode: this.scalableNode,\n        rotatableNode: this.rotatableNode\n      });\n\n      if (Config.useCSSSelector) {\n        this.renderPorts();\n      }\n    }\n  }, {\n    key: \"renderMarkup\",\n    value: function renderMarkup() {\n      var markup = this.cell.markup;\n\n      if (markup) {\n        if (typeof markup === 'string') {\n          return this.renderStringMarkup(markup);\n        }\n\n        return this.renderJSONMarkup(markup);\n      }\n\n      throw new TypeError('Invalid node markup.');\n    }\n  }, {\n    key: \"renderJSONMarkup\",\n    value: function renderJSONMarkup(markup) {\n      var ret = this.parseJSONMarkup(markup, this.container);\n\n      var one = function one(elems) {\n        return Array.isArray(elems) ? elems[0] : elems;\n      };\n\n      this.selectors = ret.selectors;\n      this.rotatableNode = one(this.selectors[this.rotatableSelector]);\n      this.scalableNode = one(this.selectors[this.scalableSelector]);\n      this.container.appendChild(ret.fragment);\n    }\n  }, {\n    key: \"renderStringMarkup\",\n    value: function renderStringMarkup(markup) {\n      Dom.append(this.container, Vector.toNodes(Vector.createVectors(markup)));\n      this.rotatableNode = Dom.findOne(this.container, \".\".concat(this.rotatableSelector));\n      this.scalableNode = Dom.findOne(this.container, \".\".concat(this.scalableSelector));\n      this.selectors = {};\n\n      if (this.rootSelector) {\n        this.selectors[this.rootSelector] = this.container;\n      }\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.empty();\n      this.renderMarkup();\n\n      if (this.scalableNode) {\n        // Double update is necessary for elements with the scalable group only\n        // Note the `resize()` triggers the other `update`.\n        this.update();\n      }\n\n      this.resize();\n\n      if (this.rotatableNode) {\n        this.rotate();\n        this.translate();\n      } else {\n        this.updateTransform();\n      }\n\n      if (!Config.useCSSSelector) {\n        this.renderPorts();\n      }\n\n      this.renderTools();\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize() {\n      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.scalableNode) {\n        return this.updateSize(opt);\n      }\n\n      if (this.cell.getAngle()) {\n        this.rotate();\n      }\n\n      this.update();\n    }\n  }, {\n    key: \"translate\",\n    value: function translate() {\n      if (this.rotatableNode) {\n        return this.updateTranslation();\n      }\n\n      this.updateTransform();\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate() {\n      if (this.rotatableNode) {\n        this.updateRotation(); // It's necessary to call the update for the nodes outside\n        // the rotatable group referencing nodes inside the group\n\n        this.update();\n        return;\n      }\n\n      this.updateTransform();\n    }\n  }, {\n    key: \"getTranslationString\",\n    value: function getTranslationString() {\n      var position = this.cell.getPosition();\n      return \"translate(\".concat(position.x, \",\").concat(position.y, \")\");\n    }\n  }, {\n    key: \"getRotationString\",\n    value: function getRotationString() {\n      var angle = this.cell.getAngle();\n\n      if (angle) {\n        var size = this.cell.getSize();\n        return \"rotate(\".concat(angle, \",\").concat(size.width / 2, \",\").concat(size.height / 2, \")\");\n      }\n    }\n  }, {\n    key: \"updateTransform\",\n    value: function updateTransform() {\n      var transform = this.getTranslationString();\n      var rot = this.getRotationString();\n\n      if (rot) {\n        transform += \" \".concat(rot);\n      }\n\n      this.container.setAttribute('transform', transform);\n    }\n  }, {\n    key: \"updateRotation\",\n    value: function updateRotation() {\n      if (this.rotatableNode != null) {\n        var transform = this.getRotationString();\n\n        if (transform != null) {\n          this.rotatableNode.setAttribute('transform', transform);\n        } else {\n          this.rotatableNode.removeAttribute('transform');\n        }\n      }\n    }\n  }, {\n    key: \"updateTranslation\",\n    value: function updateTranslation() {\n      this.container.setAttribute('transform', this.getTranslationString());\n    }\n  }, {\n    key: \"updateSize\",\n    value: function updateSize() {\n      var opt = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var cell = this.cell;\n      var size = cell.getSize();\n      var angle = cell.getAngle();\n      var scalableNode = this.scalableNode; // Getting scalable group's bbox.\n      // Due to a bug in webkit's native SVG .getBBox implementation, the\n      // bbox of groups with path children includes the paths' control points.\n      // To work around the issue, we need to check whether there are any path\n      // elements inside the scalable group.\n\n      var recursive = false;\n\n      if (scalableNode.getElementsByTagName('path').length > 0) {\n        // If scalable has at least one descendant that is a path, we need\n        // toswitch to recursive bbox calculation. Otherwise, group bbox\n        // calculation works and so we can use the (faster) native function.\n        recursive = true;\n      }\n\n      var scalableBBox = Dom.getBBox(scalableNode, {\n        recursive: recursive\n      }); // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero\n      // which can happen if the element does not have any content.\n\n      var sx = size.width / (scalableBBox.width || 1);\n      var sy = size.height / (scalableBBox.height || 1);\n      scalableNode.setAttribute('transform', \"scale(\".concat(sx, \",\").concat(sy, \")\")); // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n      // Order of transformations is significant but we want to reconstruct the object always in the order:\n      // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n      // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n      // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n      // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n      // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n      // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n\n      var rotatableNode = this.rotatableNode;\n\n      if (rotatableNode != null) {\n        var transform = rotatableNode.getAttribute('transform');\n\n        if (transform) {\n          rotatableNode.setAttribute('transform', \"\".concat(transform, \" rotate(\").concat(-angle, \",\").concat(size.width / 2, \",\").concat(size.height / 2, \")\"));\n          var rotatableBBox = Dom.getBBox(scalableNode, {\n            target: this.graph.view.stage\n          }); // Store new x, y and perform rotate() again against the new rotation origin.\n\n          cell.prop('position', {\n            x: rotatableBBox.x,\n            y: rotatableBBox.y\n          }, Object.assign({\n            updated: true\n          }, opt));\n          this.translate();\n          this.rotate();\n        }\n      } // Update must always be called on non-rotated element. Otherwise,\n      // relative positioning would work with wrong (rotated) bounding boxes.\n\n\n      this.update();\n    } // #region ports\n\n  }, {\n    key: \"findPortElem\",\n    value: function findPortElem(portId, selector) {\n      var cache = portId ? this.portsCache[portId] : null;\n\n      if (!cache) {\n        return null;\n      }\n\n      var portRoot = cache.portContentElement;\n      var portSelectors = cache.portContentSelectors || {};\n      return this.findOne(selector, portRoot, portSelectors);\n    }\n  }, {\n    key: \"initializePorts\",\n    value: function initializePorts() {\n      this.cleanPortsCache();\n    }\n  }, {\n    key: \"refreshPorts\",\n    value: function refreshPorts() {\n      this.removePorts();\n      this.cleanPortsCache();\n      this.renderPorts();\n    }\n  }, {\n    key: \"cleanPortsCache\",\n    value: function cleanPortsCache() {\n      this.portsCache = {};\n    }\n  }, {\n    key: \"removePorts\",\n    value: function removePorts() {\n      var _this3 = this;\n\n      Object.keys(this.portsCache).forEach(function (portId) {\n        var cached = _this3.portsCache[portId];\n        Dom.remove(cached.portElement);\n      });\n    }\n  }, {\n    key: \"renderPorts\",\n    value: function renderPorts() {\n      var _this4 = this;\n\n      var container = this.getPortsContainer(); // References to rendered elements without z-index\n\n      var references = [];\n      container.childNodes.forEach(function (child) {\n        references.push(child);\n      });\n      var portsGropsByZ = ArrayExt.groupBy(this.cell.getParsedPorts(), 'zIndex');\n      var autoZIndexKey = 'auto'; // render non-z first\n\n      if (portsGropsByZ[autoZIndexKey]) {\n        portsGropsByZ[autoZIndexKey].forEach(function (port) {\n          var portElement = _this4.getPortElement(port);\n\n          container.append(portElement);\n          references.push(portElement);\n        });\n      }\n\n      Object.keys(portsGropsByZ).forEach(function (key) {\n        if (key !== autoZIndexKey) {\n          var zIndex = parseInt(key, 10);\n\n          _this4.appendPorts(portsGropsByZ[key], zIndex, references);\n        }\n      });\n      this.updatePorts();\n    }\n  }, {\n    key: \"getPortsContainer\",\n    value: function getPortsContainer() {\n      return this.rotatableNode || this.container;\n    }\n  }, {\n    key: \"appendPorts\",\n    value: function appendPorts(ports, zIndex, refs) {\n      var _this5 = this;\n\n      var elems = ports.map(function (p) {\n        return _this5.getPortElement(p);\n      });\n\n      if (refs[zIndex] || zIndex < 0) {\n        Dom.before(refs[Math.max(zIndex, 0)], elems);\n      } else {\n        Dom.append(this.getPortsContainer(), elems);\n      }\n    }\n  }, {\n    key: \"getPortElement\",\n    value: function getPortElement(port) {\n      var cached = this.portsCache[port.id];\n\n      if (cached) {\n        return cached.portElement;\n      }\n\n      return this.createPortElement(port);\n    }\n  }, {\n    key: \"createPortElement\",\n    value: function createPortElement(port) {\n      var renderResult = Markup.renderMarkup(this.getPortContainerMarkup());\n      var portElement = renderResult.elem;\n\n      if (portElement == null) {\n        throw new Error('Invalid port container markup.');\n      }\n\n      renderResult = Markup.renderMarkup(this.getPortMarkup(port));\n      var portContentElement = renderResult.elem;\n      var portContentSelectors = renderResult.selectors;\n\n      if (portContentElement == null) {\n        throw new Error('Invalid port markup.');\n      }\n\n      this.setAttrs({\n        port: port.id,\n        'port-group': port.group\n      }, portContentElement);\n      renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label));\n      var portLabelElement = renderResult.elem;\n      var portLabelSelectors = renderResult.selectors;\n\n      if (portLabelElement == null) {\n        throw new Error('Invalid port label markup.');\n      }\n\n      var portSelectors;\n\n      if (portContentSelectors && portLabelSelectors) {\n        // eslint-disable-next-line\n        for (var key in portLabelSelectors) {\n          if (portContentSelectors[key] && key !== this.rootSelector) {\n            throw new Error('Selectors within port must be unique.');\n          }\n        }\n\n        portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);\n      } else {\n        portSelectors = portContentSelectors || portLabelSelectors;\n      }\n\n      Dom.addClass(portElement, 'x6-port');\n      Dom.addClass(portContentElement, 'x6-port-body');\n      Dom.addClass(portLabelElement, 'x6-port-label');\n      portElement.appendChild(portContentElement);\n      portElement.appendChild(portLabelElement);\n      this.portsCache[port.id] = {\n        portElement: portElement,\n        portSelectors: portSelectors,\n        portLabelElement: portLabelElement,\n        portLabelSelectors: portLabelSelectors,\n        portContentElement: portContentElement,\n        portContentSelectors: portContentSelectors\n      };\n      this.graph.hook.onPortRendered({\n        port: port,\n        node: this.cell,\n        container: portElement,\n        selectors: portSelectors,\n        labelContainer: portLabelElement,\n        labelSelectors: portLabelSelectors,\n        contentContainer: portContentElement,\n        contentSelectors: portContentSelectors\n      });\n      return portElement;\n    }\n  }, {\n    key: \"updatePorts\",\n    value: function updatePorts() {\n      var _this6 = this;\n\n      // Layout ports without group\n      this.updatePortGroup(); // Layout ports with explicit group\n\n      var groups = this.cell.getParsedGroups();\n      Object.keys(groups).forEach(function (groupName) {\n        return _this6.updatePortGroup(groupName);\n      });\n    }\n  }, {\n    key: \"updatePortGroup\",\n    value: function updatePortGroup(groupName) {\n      var bbox = Rectangle.fromSize(this.cell.getSize());\n      var metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);\n\n      for (var i = 0, n = metrics.length; i < n; i += 1) {\n        var metric = metrics[i];\n        var portId = metric.portId;\n        var cached = this.portsCache[portId] || {};\n        var portLayout = metric.portLayout;\n        this.applyPortTransform(cached.portElement, portLayout);\n\n        if (metric.portAttrs != null) {\n          var options = {\n            selectors: cached.portSelectors || {}\n          };\n\n          if (metric.portSize) {\n            options.rootBBox = Rectangle.fromSize(metric.portSize);\n          }\n\n          this.updateAttrs(cached.portElement, metric.portAttrs, options);\n        }\n\n        var labelLayout = metric.labelLayout;\n\n        if (labelLayout) {\n          this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));\n\n          if (labelLayout.attrs) {\n            var _options = {\n              selectors: cached.portLabelSelectors || {}\n            };\n\n            if (metric.labelSize) {\n              _options.rootBBox = Rectangle.fromSize(metric.labelSize);\n            }\n\n            this.updateAttrs(cached.portLabelElement, labelLayout.attrs, _options);\n          }\n        }\n      }\n    }\n  }, {\n    key: \"applyPortTransform\",\n    value: function applyPortTransform(element, layout) {\n      var initialAngle = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var angle = layout.angle;\n      var position = layout.position;\n      var matrix = Dom.createSVGMatrix().rotate(initialAngle).translate(position.x || 0, position.y || 0).rotate(angle || 0);\n      Dom.transform(element, matrix, {\n        absolute: true\n      });\n    }\n  }, {\n    key: \"getPortContainerMarkup\",\n    value: function getPortContainerMarkup() {\n      return this.cell.getPortContainerMarkup() || this.defaultPortContainerMarkup;\n    }\n  }, {\n    key: \"getPortMarkup\",\n    value: function getPortMarkup(port) {\n      return port.markup || this.cell.portMarkup || this.defaultPortMarkup;\n    }\n  }, {\n    key: \"getPortLabelMarkup\",\n    value: function getPortLabelMarkup(label) {\n      return label.markup || this.cell.portLabelMarkup || this.defaultPortLabelMarkup;\n    }\n  }, {\n    key: \"getEventArgs\",\n    value: function getEventArgs(e, x, y) {\n      var view = this; // eslint-disable-line\n\n      var node = view.cell;\n      var cell = node;\n\n      if (x == null || y == null) {\n        return {\n          e: e,\n          view: view,\n          node: node,\n          cell: cell\n        };\n      }\n\n      return {\n        e: e,\n        x: x,\n        y: y,\n        view: view,\n        node: node,\n        cell: cell\n      };\n    }\n  }, {\n    key: \"notifyMouseDown\",\n    value: function notifyMouseDown(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseDown\", this).call(this, e, x, y);\n\n      this.notify('node:mousedown', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"notifyMouseMove\",\n    value: function notifyMouseMove(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseMove\", this).call(this, e, x, y);\n\n      this.notify('node:mousemove', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"notifyMouseUp\",\n    value: function notifyMouseUp(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseUp\", this).call(this, e, x, y);\n\n      this.notify('node:mouseup', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onClick\",\n    value: function onClick(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onClick\", this).call(this, e, x, y);\n\n      this.notify('node:click', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onDblClick\",\n    value: function onDblClick(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onDblClick\", this).call(this, e, x, y);\n\n      this.notify('node:dblclick', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onContextMenu\",\n    value: function onContextMenu(e, x, y) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onContextMenu\", this).call(this, e, x, y);\n\n      this.notify('node:contextmenu', this.getEventArgs(e, x, y));\n    }\n  }, {\n    key: \"onMouseDown\",\n    value: function onMouseDown(e, x, y) {\n      if (this.isPropagationStopped(e)) {\n        return;\n      }\n\n      this.notifyMouseDown(e, x, y);\n      this.startNodeDragging(e, x, y);\n    }\n  }, {\n    key: \"onMouseMove\",\n    value: function onMouseMove(e, x, y) {\n      var data = this.getEventData(e);\n      var action = data.action;\n\n      if (action === 'magnet') {\n        this.dragMagnet(e, x, y);\n      } else {\n        if (action === 'move') {\n          var meta = data;\n          var view = meta.targetView || this;\n          view.dragNode(e, x, y);\n          view.notify('node:moving', {\n            e: e,\n            x: x,\n            y: y,\n            view: view,\n            cell: view.cell,\n            node: view.cell\n          });\n        }\n\n        this.notifyMouseMove(e, x, y);\n      }\n\n      this.setEventData(e, data);\n    }\n  }, {\n    key: \"onMouseUp\",\n    value: function onMouseUp(e, x, y) {\n      var data = this.getEventData(e);\n      var action = data.action;\n\n      if (action === 'magnet') {\n        this.stopMagnetDragging(e, x, y);\n      } else {\n        this.notifyMouseUp(e, x, y);\n\n        if (action === 'move') {\n          var meta = data;\n          var view = meta.targetView || this;\n          view.stopNodeDragging(e, x, y);\n        }\n      }\n\n      var magnet = data.targetMagnet;\n\n      if (magnet) {\n        this.onMagnetClick(e, magnet, x, y);\n      }\n\n      this.checkMouseleave(e);\n    }\n  }, {\n    key: \"onMouseOver\",\n    value: function onMouseOver(e) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseOver\", this).call(this, e);\n\n      this.notify('node:mouseover', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseOut\",\n    value: function onMouseOut(e) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseOut\", this).call(this, e);\n\n      this.notify('node:mouseout', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseEnter\",\n    value: function onMouseEnter(e) {\n      this.updateClassName(e);\n\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseEnter\", this).call(this, e);\n\n      this.notify('node:mouseenter', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseLeave\",\n    value: function onMouseLeave(e) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseLeave\", this).call(this, e);\n\n      this.notify('node:mouseleave', this.getEventArgs(e));\n    }\n  }, {\n    key: \"onMouseWheel\",\n    value: function onMouseWheel(e, x, y, delta) {\n      _get(_getPrototypeOf(NodeView.prototype), \"onMouseWheel\", this).call(this, e, x, y, delta);\n\n      this.notify('node:mousewheel', Object.assign({\n        delta: delta\n      }, this.getEventArgs(e, x, y)));\n    }\n  }, {\n    key: \"onMagnetClick\",\n    value: function onMagnetClick(e, magnet, x, y) {\n      var count = this.graph.view.getMouseMovedCount(e);\n\n      if (count > this.graph.options.clickThreshold) {\n        return;\n      }\n\n      this.notify('node:magnet:click', Object.assign({\n        magnet: magnet\n      }, this.getEventArgs(e, x, y)));\n    }\n  }, {\n    key: \"onMagnetDblClick\",\n    value: function onMagnetDblClick(e, magnet, x, y) {\n      this.notify('node:magnet:dblclick', Object.assign({\n        magnet: magnet\n      }, this.getEventArgs(e, x, y)));\n    }\n  }, {\n    key: \"onMagnetContextMenu\",\n    value: function onMagnetContextMenu(e, magnet, x, y) {\n      this.notify('node:magnet:contextmenu', Object.assign({\n        magnet: magnet\n      }, this.getEventArgs(e, x, y)));\n    }\n  }, {\n    key: \"onMagnetMouseDown\",\n    value: function onMagnetMouseDown(e, magnet, x, y) {\n      this.startMagnetDragging(e, x, y);\n    }\n  }, {\n    key: \"onCustomEvent\",\n    value: function onCustomEvent(e, name, x, y) {\n      this.notify('node:customevent', Object.assign({\n        name: name\n      }, this.getEventArgs(e, x, y)));\n\n      _get(_getPrototypeOf(NodeView.prototype), \"onCustomEvent\", this).call(this, e, name, x, y);\n    }\n  }, {\n    key: \"prepareEmbedding\",\n    value: function prepareEmbedding(e) {\n      // const cell = data.cell || this.cell\n      // const graph = data.graph || this.graph\n      // const model = graph.model\n      // model.startBatch('to-front')\n      // // Bring the model to the front with all his embeds.\n      // cell.toFront({ deep: true, ui: true })\n      // const maxZ = model\n      //   .getNodes()\n      //   .reduce((max, cell) => Math.max(max, cell.getZIndex() || 0), 0)\n      // const connectedEdges = model.getConnectedEdges(cell, {\n      //   deep: true,\n      //   enclosed: true,\n      // })\n      // connectedEdges.forEach((edge) => {\n      //   const zIndex = edge.getZIndex() || 0\n      //   if (zIndex <= maxZ) {\n      //     edge.setZIndex(maxZ + 1, { ui: true })\n      //   }\n      // })\n      // model.stopBatch('to-front')\n      // Before we start looking for suitable parent we remove the current one.\n      // const parent = cell.getParent()\n      // if (parent) {\n      //   parent.unembed(cell, { ui: true })\n      // }\n      var data = this.getEventData(e);\n      var node = data.cell || this.cell;\n      var view = this.graph.findViewByCell(node);\n      var localPoint = this.graph.snapToGrid(e.clientX, e.clientY);\n      this.notify('node:embed', {\n        e: e,\n        node: node,\n        view: view,\n        cell: node,\n        x: localPoint.x,\n        y: localPoint.y,\n        currentParent: node.getParent()\n      });\n    }\n  }, {\n    key: \"processEmbedding\",\n    value: function processEmbedding(e, data) {\n      var _this7 = this;\n\n      var cell = data.cell || this.cell;\n      var graph = data.graph || this.graph;\n      var options = graph.options.embedding;\n      var findParent = options.findParent;\n      var candidates = typeof findParent === 'function' ? FunctionExt.call(findParent, graph, {\n        view: this,\n        node: this.cell\n      }).filter(function (c) {\n        return Cell.isCell(c) && _this7.cell.id !== c.id && !c.isDescendantOf(_this7.cell);\n      }) : graph.model.getNodesUnderNode(cell, {\n        by: findParent\n      }); // Picks the node with the highest `z` index\n\n      if (options.frontOnly) {\n        candidates = candidates.slice(-1);\n      }\n\n      var newCandidateView = null;\n      var prevCandidateView = data.candidateEmbedView;\n      var validateEmbeding = options.validate;\n\n      for (var i = candidates.length - 1; i >= 0; i -= 1) {\n        var candidate = candidates[i];\n\n        if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {\n          // candidate remains the same\n          newCandidateView = prevCandidateView;\n          break;\n        } else {\n          var view = candidate.findView(graph);\n\n          if (FunctionExt.call(validateEmbeding, graph, {\n            child: this.cell,\n            parent: view.cell,\n            childView: this,\n            parentView: view\n          })) {\n            // flip to the new candidate\n            newCandidateView = view;\n            break;\n          }\n        }\n      }\n\n      this.clearEmbedding(data);\n\n      if (newCandidateView) {\n        newCandidateView.highlight(null, {\n          type: 'embedding'\n        });\n      }\n\n      data.candidateEmbedView = newCandidateView;\n      var localPoint = graph.snapToGrid(e.clientX, e.clientY);\n      this.notify('node:embedding', {\n        e: e,\n        cell: cell,\n        node: cell,\n        view: graph.findViewByCell(cell),\n        x: localPoint.x,\n        y: localPoint.y,\n        currentParent: cell.getParent(),\n        candidateParent: newCandidateView ? newCandidateView.cell : null\n      });\n    }\n  }, {\n    key: \"clearEmbedding\",\n    value: function clearEmbedding(data) {\n      var candidateView = data.candidateEmbedView;\n\n      if (candidateView) {\n        candidateView.unhighlight(null, {\n          type: 'embedding'\n        });\n        data.candidateEmbedView = null;\n      }\n    }\n  }, {\n    key: \"finalizeEmbedding\",\n    value: function finalizeEmbedding(e, data) {\n      var cell = data.cell || this.cell;\n      var graph = data.graph || this.graph;\n      var view = graph.findViewByCell(cell);\n      var parent = cell.getParent();\n      var candidateView = data.candidateEmbedView;\n\n      if (candidateView) {\n        // Candidate view is chosen to become the parent of the node.\n        candidateView.unhighlight(null, {\n          type: 'embedding'\n        });\n        data.candidateEmbedView = null;\n\n        if (parent == null || parent.id !== candidateView.cell.id) {\n          candidateView.cell.insertChild(cell, undefined, {\n            ui: true\n          });\n        }\n      } else if (parent) {\n        parent.unembed(cell, {\n          ui: true\n        });\n      }\n\n      graph.model.getConnectedEdges(cell, {\n        deep: true\n      }).forEach(function (edge) {\n        edge.updateParent({\n          ui: true\n        });\n      });\n      var localPoint = graph.snapToGrid(e.clientX, e.clientY);\n\n      if (view) {\n        view.notify('node:embedded', {\n          e: e,\n          cell: cell,\n          x: localPoint.x,\n          y: localPoint.y,\n          node: cell,\n          view: graph.findViewByCell(cell),\n          previousParent: parent,\n          currentParent: cell.getParent()\n        });\n      }\n    }\n  }, {\n    key: \"getDelegatedView\",\n    value: function getDelegatedView() {\n      var cell = this.cell;\n      var view = this; // eslint-disable-line\n\n      while (view) {\n        if (cell.isEdge()) {\n          break;\n        }\n\n        if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {\n          return view;\n        }\n\n        cell = cell.getParent();\n        view = this.graph.renderer.findViewByCell(cell);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"startMagnetDragging\",\n    value: function startMagnetDragging(e, x, y) {\n      if (!this.can('magnetConnectable')) {\n        return;\n      }\n\n      e.stopPropagation();\n      var magnet = e.currentTarget;\n      var graph = this.graph;\n      this.setEventData(e, {\n        targetMagnet: magnet\n      });\n\n      if (graph.hook.validateMagnet(this, magnet, e)) {\n        if (graph.options.magnetThreshold <= 0) {\n          this.startConnectting(e, magnet, x, y);\n        }\n\n        this.setEventData(e, {\n          action: 'magnet'\n        });\n        this.stopPropagation(e);\n      } else {\n        this.onMouseDown(e, x, y);\n      }\n\n      graph.view.delegateDragEvents(e, this);\n    }\n  }, {\n    key: \"startConnectting\",\n    value: function startConnectting(e, magnet, x, y) {\n      this.graph.model.startBatch('add-edge');\n      var edgeView = this.createEdgeFromMagnet(magnet, x, y);\n      edgeView.notifyMouseDown(e, x, y); // backwards compatibility events\n\n      edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {\n        x: x,\n        y: y,\n        isNewEdge: true,\n        fallbackAction: 'remove'\n      }));\n      this.setEventData(e, {\n        edgeView: edgeView\n      });\n    }\n  }, {\n    key: \"createEdgeFromMagnet\",\n    value: function createEdgeFromMagnet(magnet, x, y) {\n      var graph = this.graph;\n      var model = graph.model;\n      var edge = graph.hook.getDefaultEdge(this, magnet);\n      edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));\n      edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), {\n        x: x,\n        y: y\n      }));\n      edge.addTo(model, {\n        async: false,\n        ui: true\n      });\n      return edge.findView(graph);\n    }\n  }, {\n    key: \"dragMagnet\",\n    value: function dragMagnet(e, x, y) {\n      var data = this.getEventData(e);\n      var edgeView = data.edgeView;\n\n      if (edgeView) {\n        edgeView.onMouseMove(e, x, y);\n        this.autoScrollGraph(e.clientX, e.clientY);\n      } else {\n        var graph = this.graph;\n        var magnetThreshold = graph.options.magnetThreshold;\n        var currentTarget = this.getEventTarget(e);\n        var targetMagnet = data.targetMagnet; // magnetThreshold when the pointer leaves the magnet\n\n        if (magnetThreshold === 'onleave') {\n          if (targetMagnet === currentTarget || targetMagnet.contains(currentTarget)) {\n            return;\n          } // eslint-disable-next-line no-lonely-if\n\n        } else {\n          // magnetThreshold defined as a number of movements\n          if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {\n            return;\n          }\n        }\n\n        this.startConnectting(e, targetMagnet, x, y);\n      }\n    }\n  }, {\n    key: \"stopMagnetDragging\",\n    value: function stopMagnetDragging(e, x, y) {\n      var data = this.eventData(e);\n      var edgeView = data.edgeView;\n\n      if (edgeView) {\n        edgeView.onMouseUp(e, x, y);\n        this.graph.model.stopBatch('add-edge');\n      }\n    }\n  }, {\n    key: \"notifyUnhandledMouseDown\",\n    value: function notifyUnhandledMouseDown(e, x, y) {\n      this.notify('node:unhandled:mousedown', {\n        e: e,\n        x: x,\n        y: y,\n        view: this,\n        cell: this.cell,\n        node: this.cell\n      });\n    }\n  }, {\n    key: \"notifyNodeMove\",\n    value: function notifyNodeMove(name, e, x, y, cell) {\n      var _this8 = this;\n\n      var cells = [cell];\n      var selection = this.graph.selection.widget;\n\n      if (selection && selection.options.movable) {\n        var selectedCells = this.graph.getSelectedCells();\n\n        if (selectedCells.includes(cell)) {\n          cells = selectedCells.filter(function (c) {\n            return c.isNode();\n          });\n        }\n      }\n\n      cells.forEach(function (c) {\n        _this8.notify(name, {\n          e: e,\n          x: x,\n          y: y,\n          cell: c,\n          node: c,\n          view: c.findView(_this8.graph)\n        });\n      });\n    }\n  }, {\n    key: \"startNodeDragging\",\n    value: function startNodeDragging(e, x, y) {\n      var targetView = this.getDelegatedView();\n\n      if (targetView == null || !targetView.can('nodeMovable')) {\n        return this.notifyUnhandledMouseDown(e, x, y);\n      }\n\n      this.setEventData(e, {\n        targetView: targetView,\n        action: 'move'\n      });\n      var position = Point.create(targetView.cell.getPosition());\n      targetView.setEventData(e, {\n        moving: false,\n        offset: position.diff(x, y),\n        restrict: this.graph.hook.getRestrictArea(targetView)\n      });\n    }\n  }, {\n    key: \"dragNode\",\n    value: function dragNode(e, x, y) {\n      var node = this.cell;\n      var graph = this.graph;\n      var gridSize = graph.getGridSize();\n      var data = this.getEventData(e);\n      var offset = data.offset;\n      var restrict = data.restrict;\n\n      if (!data.moving) {\n        data.moving = true;\n        this.addClass('node-moving');\n        this.notifyNodeMove('node:move', e, x, y, this.cell);\n      }\n\n      this.autoScrollGraph(e.clientX, e.clientY);\n      var posX = Util.snapToGrid(x + offset.x, gridSize);\n      var posY = Util.snapToGrid(y + offset.y, gridSize);\n      node.setPosition(posX, posY, {\n        restrict: restrict,\n        deep: true,\n        ui: true\n      });\n\n      if (graph.options.embedding.enabled) {\n        if (!data.embedding) {\n          this.prepareEmbedding(e);\n          data.embedding = true;\n        }\n\n        this.processEmbedding(e, data);\n      }\n    }\n  }, {\n    key: \"stopNodeDragging\",\n    value: function stopNodeDragging(e, x, y) {\n      var data = this.getEventData(e);\n\n      if (data.embedding) {\n        this.finalizeEmbedding(e, data);\n      }\n\n      if (data.moving) {\n        this.removeClass('node-moving');\n        this.notifyNodeMove('node:moved', e, x, y, this.cell);\n      }\n\n      data.moving = false;\n      data.embedding = false;\n    }\n  }, {\n    key: \"autoScrollGraph\",\n    value: function autoScrollGraph(x, y) {\n      var scroller = this.graph.scroller.widget;\n\n      if (scroller) {\n        scroller.autoScroll(x, y);\n      }\n    }\n  }]);\n\n  return NodeView;\n}(CellView, Symbol.toStringTag);\n\n(function (NodeView) {\n  NodeView.toStringTag = \"X6.\".concat(NodeView.name);\n\n  function isNodeView(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof NodeView) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var view = instance;\n\n    if ((tag == null || tag === NodeView.toStringTag) && typeof view.isNodeView === 'function' && typeof view.isEdgeView === 'function' && typeof view.confirmUpdate === 'function' && typeof view.update === 'function' && typeof view.findPortElem === 'function' && typeof view.resize === 'function' && typeof view.rotate === 'function' && typeof view.translate === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  NodeView.isNodeView = isNodeView;\n})(NodeView || (NodeView = {}));\n\nNodeView.config({\n  isSvgElement: true,\n  priority: 0,\n  bootstrap: ['render'],\n  actions: {\n    view: ['render'],\n    markup: ['render'],\n    attrs: ['update'],\n    size: ['resize', 'ports', 'tools'],\n    angle: ['rotate', 'tools'],\n    position: ['translate', 'tools'],\n    ports: ['ports'],\n    tools: ['tools']\n  }\n});\nNodeView.registry.register('node', NodeView, true);","map":{"version":3,"sources":["../../src/view/node.ts"],"names":[],"mappings":";;;;;;AAAA,SAAS,IAAT,EAAe,MAAf,QAA6B,WAA7B;AACA,SAAS,QAAT,EAAmB,WAAnB,EAAgC,GAAhC,EAAqC,MAArC,QAAmD,SAAnD;AACA,SAAS,SAAT,EAAoB,KAApB,QAAiC,aAAjC;AAEA,SAAS,IAAT,QAAqB,eAArB;AAIA,SAAS,QAAT,QAAyB,QAAzB;AAEA,SAAS,MAAT,QAAuB,UAAvB;AAGA,WAAa,QAAb;AAAA;;AAAA;;AAAA,sBAAA;AAAA;;AAAA;;;AAIS,UAAA,YAAA,GAA+B,IAA/B;AACA,UAAA,aAAA,GAAgC,IAAhC;AACY,UAAA,gBAAA,GAA2B,UAA3B;AACA,UAAA,iBAAA,GAA4B,WAA5B;AACA,UAAA,iBAAA,GAAoB,MAAM,CAAC,aAAP,EAApB;AACA,UAAA,sBAAA,GAAyB,MAAM,CAAC,kBAAP,EAAzB;AACA,UAAA,0BAAA,GACjB,MAAM,CAAC,sBAAP,EADiB;AAET,UAAA,UAAA,GAAmD,EAAnD,CAZZ,CA4oCE;;AA5oCF;AA6oCC;;AA7oCD;AAAA;AAAA,SAcE,eAAkC;AAChC,aAAO,QAAQ,CAAC,WAAhB;AACD;AAhBH;AAAA;AAAA,WAkBY,iCAAqB;AAC7B,UAAM,SAAS,GAAG,sFAEhB,KAAK,eAAL,CAAqB,MAArB,CAFgB,CAAlB;;AAIA,UAAI,CAAC,KAAK,GAAL,CAAS,aAAT,CAAL,EAA8B;AAC5B,QAAA,SAAS,CAAC,IAAV,CAAe,KAAK,eAAL,CAAqB,gBAArB,CAAf;AACD;;AACD,aAAO,SAAS,CAAC,IAAV,CAAe,GAAf,CAAP;AACD;AA3BH;AAAA;AAAA,WA6BY,yBAAgB,CAAhB,EAAyC;AACjD,UAAM,MAAM,GAAG,CAAC,CAAC,MAAjB;;AACA,UAAI,MAAM,CAAC,YAAP,CAAoB,QAApB,CAAJ,EAAmC;AACjC;AACA,YAAM,SAAS,GAAG,KAAK,eAAL,CAAqB,oBAArB,CAAlB;;AACA,YAAI,KAAK,GAAL,CAAS,mBAAT,CAAJ,EAAmC;AACjC,UAAA,GAAG,CAAC,WAAJ,CAAgB,MAAhB,EAAwB,SAAxB;AACD,SAFD,MAEO;AACL,UAAA,GAAG,CAAC,QAAJ,CAAa,MAAb,EAAqB,SAArB;AACD;AACF,OARD,MAQO;AACL;AACA,YAAM,UAAS,GAAG,KAAK,eAAL,CAAqB,gBAArB,CAAlB;;AACA,YAAI,KAAK,GAAL,CAAS,aAAT,CAAJ,EAA6B;AAC3B,eAAK,WAAL,CAAiB,UAAjB;AACD,SAFD,MAEO;AACL,eAAK,QAAL,CAAc,UAAd;AACD;AACF;AACF;AAhDH;AAAA;AAAA,WAkDE,sBAAU;AACR,aAAO,IAAP;AACD;AApDH;AAAA;AAAA,WAsDE,uBAAc,IAAd,EAA6C;AAAA;;AAAA,UAAjB,OAAiB,uEAAF,EAAE;AAC3C,UAAI,GAAG,GAAG,IAAV;;AACA,UAAI,KAAK,SAAL,CAAe,GAAf,EAAoB,OAApB,CAAJ,EAAkC;AAChC,aAAK,WAAL;AACA,aAAK,eAAL;AACD;;AAED,UAAI,KAAK,SAAL,CAAe,GAAf,EAAoB,QAApB,CAAJ,EAAmC;AACjC,aAAK,MAAL;AACA,QAAA,GAAG,GAAG,KAAK,YAAL,CAAkB,GAAlB,EAAuB,CAC3B,QAD2B,EAE3B,QAF2B,EAG3B,QAH2B,EAI3B,WAJ2B,EAK3B,QAL2B,EAM3B,OAN2B,EAO3B,OAP2B,CAAvB,CAAN;AASD,OAXD,MAWO;AACL,QAAA,GAAG,GAAG,KAAK,YAAL,CACJ,GADI,EAEJ,QAFI,EAGJ;AAAA,iBAAM,MAAI,CAAC,MAAL,CAAY,OAAZ,CAAN;AAAA,SAHI,EAIJ,QAJI,CAAN;AAOA,QAAA,GAAG,GAAG,KAAK,YAAL,CACJ,GADI,EAEJ,QAFI,EAGJ;AAAA,iBAAM,MAAI,CAAC,MAAL,EAAN;AAAA,SAHI,EAIJ;AACA,QAAA,MAAM,CAAC,cAAP,GAAwB,OAAxB,GAAkC,IAL9B,CAAN;AAQA,QAAA,GAAG,GAAG,KAAK,YAAL,CAAkB,GAAlB,EAAuB,WAAvB,EAAoC;AAAA,iBAAM,MAAI,CAAC,SAAL,EAAN;AAAA,SAApC,CAAN;AACA,QAAA,GAAG,GAAG,KAAK,YAAL,CAAkB,GAAlB,EAAuB,QAAvB,EAAiC;AAAA,iBAAM,MAAI,CAAC,MAAL,EAAN;AAAA,SAAjC,CAAN;AACA,QAAA,GAAG,GAAG,KAAK,YAAL,CAAkB,GAAlB,EAAuB,OAAvB,EAAgC;AAAA,iBAAM,MAAI,CAAC,WAAL,EAAN;AAAA,SAAhC,CAAN;AACA,QAAA,GAAG,GAAG,KAAK,YAAL,CAAkB,GAAlB,EAAuB,OAAvB,EAAgC;AAAA,iBAAM,MAAI,CAAC,WAAL,EAAN;AAAA,SAAhC,CAAN;AACD;;AAED,aAAO,GAAP;AACD;AA/FH;AAAA;AAAA,WAiGE,gBAAO,YAAP,EAAoC;AAClC,WAAK,UAAL,GADkC,CAGlC;;AACA,UAAI,MAAM,CAAC,cAAX,EAA2B;AACzB,aAAK,WAAL;AACD;;AAED,UAAM,IAAI,GAAG,KAAK,IAAlB;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,OAAL,EAAb;AACA,UAAM,KAAK,GAAG,IAAI,CAAC,QAAL,EAAd;AACA,WAAK,WAAL,CAAiB,KAAK,SAAtB,EAAiC,KAAjC,EAAwC;AACtC,QAAA,KAAK,EAAE,YAAY,KAAK,KAAjB,GAAyB,IAAzB,GAAgC,YADD;AAEtC,QAAA,QAAQ,EAAE,IAAI,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,IAAI,CAAC,KAAzB,EAAgC,IAAI,CAAC,MAArC,CAF4B;AAGtC,QAAA,SAAS,EAAE,KAAK,SAHsB;AAItC,QAAA,YAAY,EAAE,KAAK,YAJmB;AAKtC,QAAA,aAAa,EAAE,KAAK;AALkB,OAAxC;;AAQA,UAAI,MAAM,CAAC,cAAX,EAA2B;AACzB,aAAK,WAAL;AACD;AACF;AAvHH;AAAA;AAAA,WAyHY,wBAAY;AACpB,UAAM,MAAM,GAAG,KAAK,IAAL,CAAU,MAAzB;;AACA,UAAI,MAAJ,EAAY;AACV,YAAI,OAAO,MAAP,KAAkB,QAAtB,EAAgC;AAC9B,iBAAO,KAAK,kBAAL,CAAwB,MAAxB,CAAP;AACD;;AAED,eAAO,KAAK,gBAAL,CAAsB,MAAtB,CAAP;AACD;;AAED,YAAM,IAAI,SAAJ,CAAc,sBAAd,CAAN;AACD;AApIH;AAAA;AAAA,WAsIY,0BAAiB,MAAjB,EAAgE;AACxE,UAAM,GAAG,GAAG,KAAK,eAAL,CAAqB,MAArB,EAA6B,KAAK,SAAlC,CAAZ;;AACA,UAAM,GAAG,GAAG,SAAN,GAAM,CAAC,KAAD;AAAA,eACV,KAAK,CAAC,OAAN,CAAc,KAAd,IAAuB,KAAK,CAAC,CAAD,CAA5B,GAAkC,KADxB;AAAA,OAAZ;;AAEA,WAAK,SAAL,GAAiB,GAAG,CAAC,SAArB;AACA,WAAK,aAAL,GAAqB,GAAG,CAAC,KAAK,SAAL,CAAe,KAAK,iBAApB,CAAD,CAAxB;AACA,WAAK,YAAL,GAAoB,GAAG,CAAC,KAAK,SAAL,CAAe,KAAK,gBAApB,CAAD,CAAvB;AACA,WAAK,SAAL,CAAe,WAAf,CAA2B,GAAG,CAAC,QAA/B;AACD;AA9IH;AAAA;AAAA,WAgJY,4BAAmB,MAAnB,EAAiC;AACzC,MAAA,GAAG,CAAC,MAAJ,CAAW,KAAK,SAAhB,EAA2B,MAAM,CAAC,OAAP,CAAe,MAAM,CAAC,aAAP,CAAqB,MAArB,CAAf,CAA3B;AACA,WAAK,aAAL,GAAqB,GAAG,CAAC,OAAJ,CACnB,KAAK,SADc,aAEf,KAAK,iBAFU,EAArB;AAIA,WAAK,YAAL,GAAoB,GAAG,CAAC,OAAJ,CAAY,KAAK,SAAjB,aAAgC,KAAK,gBAArC,EAApB;AACA,WAAK,SAAL,GAAiB,EAAjB;;AACA,UAAI,KAAK,YAAT,EAAuB;AACrB,aAAK,SAAL,CAAe,KAAK,YAApB,IAAoC,KAAK,SAAzC;AACD;AACF;AA3JH;AAAA;AAAA,WA6JE,kBAAM;AACJ,WAAK,KAAL;AACA,WAAK,YAAL;;AAEA,UAAI,KAAK,YAAT,EAAuB;AACrB;AACA;AACA,aAAK,MAAL;AACD;;AAED,WAAK,MAAL;;AAEA,UAAI,KAAK,aAAT,EAAwB;AACtB,aAAK,MAAL;AACA,aAAK,SAAL;AACD,OAHD,MAGO;AACL,aAAK,eAAL;AACD;;AAED,UAAI,CAAC,MAAM,CAAC,cAAZ,EAA4B;AAC1B,aAAK,WAAL;AACD;;AAED,WAAK,WAAL;AAEA,aAAO,IAAP;AACD;AAvLH;AAAA;AAAA,WAyLE,kBAAoB;AAAA,UAAb,GAAa,uEAAF,EAAE;;AAClB,UAAI,KAAK,YAAT,EAAuB;AACrB,eAAO,KAAK,UAAL,CAAgB,GAAhB,CAAP;AACD;;AAED,UAAI,KAAK,IAAL,CAAU,QAAV,EAAJ,EAA0B;AACxB,aAAK,MAAL;AACD;;AAED,WAAK,MAAL;AACD;AAnMH;AAAA;AAAA,WAqME,qBAAS;AACP,UAAI,KAAK,aAAT,EAAwB;AACtB,eAAO,KAAK,iBAAL,EAAP;AACD;;AAED,WAAK,eAAL;AACD;AA3MH;AAAA;AAAA,WA6ME,kBAAM;AACJ,UAAI,KAAK,aAAT,EAAwB;AACtB,aAAK,cAAL,GADsB,CAEtB;AACA;;AACA,aAAK,MAAL;AACA;AACD;;AAED,WAAK,eAAL;AACD;AAvNH;AAAA;AAAA,WAyNY,gCAAoB;AAC5B,UAAM,QAAQ,GAAG,KAAK,IAAL,CAAU,WAAV,EAAjB;AACA,iCAAoB,QAAQ,CAAC,CAA7B,cAAkC,QAAQ,CAAC,CAA3C;AACD;AA5NH;AAAA;AAAA,WA8NY,6BAAiB;AACzB,UAAM,KAAK,GAAG,KAAK,IAAL,CAAU,QAAV,EAAd;;AACA,UAAI,KAAJ,EAAW;AACT,YAAM,IAAI,GAAG,KAAK,IAAL,CAAU,OAAV,EAAb;AACA,gCAAiB,KAAjB,cAA0B,IAAI,CAAC,KAAL,GAAa,CAAvC,cAA4C,IAAI,CAAC,MAAL,GAAc,CAA1D;AACD;AACF;AApOH;AAAA;AAAA,WAsOY,2BAAe;AACvB,UAAI,SAAS,GAAG,KAAK,oBAAL,EAAhB;AACA,UAAM,GAAG,GAAG,KAAK,iBAAL,EAAZ;;AACA,UAAI,GAAJ,EAAS;AACP,QAAA,SAAS,eAAQ,GAAR,CAAT;AACD;;AACD,WAAK,SAAL,CAAe,YAAf,CAA4B,WAA5B,EAAyC,SAAzC;AACD;AA7OH;AAAA;AAAA,WA+OY,0BAAc;AACtB,UAAI,KAAK,aAAL,IAAsB,IAA1B,EAAgC;AAC9B,YAAM,SAAS,GAAG,KAAK,iBAAL,EAAlB;;AACA,YAAI,SAAS,IAAI,IAAjB,EAAuB;AACrB,eAAK,aAAL,CAAmB,YAAnB,CAAgC,WAAhC,EAA6C,SAA7C;AACD,SAFD,MAEO;AACL,eAAK,aAAL,CAAmB,eAAnB,CAAmC,WAAnC;AACD;AACF;AACF;AAxPH;AAAA;AAAA,WA0PY,6BAAiB;AACzB,WAAK,SAAL,CAAe,YAAf,CAA4B,WAA5B,EAAyC,KAAK,oBAAL,EAAzC;AACD;AA5PH;AAAA;AAAA,WA8PY,sBAAwB;AAAA,UAAb,GAAa,uEAAF,EAAE;AAChC,UAAM,IAAI,GAAG,KAAK,IAAlB;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,OAAL,EAAb;AACA,UAAM,KAAK,GAAG,IAAI,CAAC,QAAL,EAAd;AACA,UAAM,YAAY,GAAG,KAAK,YAA1B,CAJgC,CAMhC;AACA;AACA;AACA;AACA;;AACA,UAAI,SAAS,GAAG,KAAhB;;AACA,UAAI,YAAY,CAAC,oBAAb,CAAkC,MAAlC,EAA0C,MAA1C,GAAmD,CAAvD,EAA0D;AACxD;AACA;AACA;AACA,QAAA,SAAS,GAAG,IAAZ;AACD;;AACD,UAAM,YAAY,GAAG,GAAG,CAAC,OAAJ,CAAY,YAAZ,EAAwC;AAAE,QAAA,SAAS,EAAT;AAAF,OAAxC,CAArB,CAlBgC,CAoBhC;AACA;;AACA,UAAM,EAAE,GAAG,IAAI,CAAC,KAAL,IAAc,YAAY,CAAC,KAAb,IAAsB,CAApC,CAAX;AACA,UAAM,EAAE,GAAG,IAAI,CAAC,MAAL,IAAe,YAAY,CAAC,MAAb,IAAuB,CAAtC,CAAX;AACA,MAAA,YAAY,CAAC,YAAb,CAA0B,WAA1B,kBAAgD,EAAhD,cAAsD,EAAtD,QAxBgC,CA0BhC;AACA;AACA;AACA;AACA;AACA;AACA;AAEA;;AACA,UAAM,aAAa,GAAG,KAAK,aAA3B;;AACA,UAAI,aAAa,IAAI,IAArB,EAA2B;AACzB,YAAM,SAAS,GAAG,aAAa,CAAC,YAAd,CAA2B,WAA3B,CAAlB;;AACA,YAAI,SAAJ,EAAe;AACb,UAAA,aAAa,CAAC,YAAd,CACE,WADF,YAEK,SAFL,qBAEyB,CAAC,KAF1B,cAEmC,IAAI,CAAC,KAAL,GAAa,CAFhD,cAEqD,IAAI,CAAC,MAAL,GAAc,CAFnE;AAIA,cAAM,aAAa,GAAG,GAAG,CAAC,OAAJ,CAAY,YAAZ,EAAwC;AAC5D,YAAA,MAAM,EAAE,KAAK,KAAL,CAAW,IAAX,CAAgB;AADoC,WAAxC,CAAtB,CALa,CASb;;AACA,UAAA,IAAI,CAAC,IAAL,CACE,UADF,EAEE;AAAE,YAAA,CAAC,EAAE,aAAa,CAAC,CAAnB;AAAsB,YAAA,CAAC,EAAE,aAAa,CAAC;AAAvC,WAFF,EAE4C,MAAA,CAAA,MAAA,CAAA;AACxC,YAAA,OAAO,EAAE;AAD+B,WAAA,EACtB,GADsB,CAF5C;AAKA,eAAK,SAAL;AACA,eAAK,MAAL;AACD;AACF,OAxD+B,CA0DhC;AACA;;;AACA,WAAK,MAAL;AACD,KA3TH,CA6TE;;AA7TF;AAAA;AAAA,WA+TE,sBAAa,MAAb,EAA8B,QAA9B,EAA+C;AAC7C,UAAM,KAAK,GAAG,MAAM,GAAG,KAAK,UAAL,CAAgB,MAAhB,CAAH,GAA6B,IAAjD;;AACA,UAAI,CAAC,KAAL,EAAY;AACV,eAAO,IAAP;AACD;;AACD,UAAM,QAAQ,GAAG,KAAK,CAAC,kBAAvB;AACA,UAAM,aAAa,GAAG,KAAK,CAAC,oBAAN,IAA8B,EAApD;AACA,aAAO,KAAK,OAAL,CAAa,QAAb,EAAuB,QAAvB,EAAiC,aAAjC,CAAP;AACD;AAvUH;AAAA;AAAA,WAyUY,2BAAe;AACvB,WAAK,eAAL;AACD;AA3UH;AAAA;AAAA,WA6UY,wBAAY;AACpB,WAAK,WAAL;AACA,WAAK,eAAL;AACA,WAAK,WAAL;AACD;AAjVH;AAAA;AAAA,WAmVY,2BAAe;AACvB,WAAK,UAAL,GAAkB,EAAlB;AACD;AArVH;AAAA;AAAA,WAuVY,uBAAW;AAAA;;AACnB,MAAA,MAAM,CAAC,IAAP,CAAY,KAAK,UAAjB,EAA6B,OAA7B,CAAqC,UAAC,MAAD,EAAW;AAC9C,YAAM,MAAM,GAAG,MAAI,CAAC,UAAL,CAAgB,MAAhB,CAAf;AACA,QAAA,GAAG,CAAC,MAAJ,CAAW,MAAM,CAAC,WAAlB;AACD,OAHD;AAID;AA5VH;AAAA;AAAA,WA8VY,uBAAW;AAAA;;AACnB,UAAM,SAAS,GAAG,KAAK,iBAAL,EAAlB,CADmB,CAEnB;;AACA,UAAM,UAAU,GAAc,EAA9B;AACA,MAAA,SAAS,CAAC,UAAV,CAAqB,OAArB,CAA6B,UAAC,KAAD,EAAU;AACrC,QAAA,UAAU,CAAC,IAAX,CAAgB,KAAhB;AACD,OAFD;AAIA,UAAM,aAAa,GAAG,QAAQ,CAAC,OAAT,CAAiB,KAAK,IAAL,CAAU,cAAV,EAAjB,EAA6C,QAA7C,CAAtB;AACA,UAAM,aAAa,GAAG,MAAtB,CATmB,CAWnB;;AACA,UAAI,aAAa,CAAC,aAAD,CAAjB,EAAkC;AAChC,QAAA,aAAa,CAAC,aAAD,CAAb,CAA6B,OAA7B,CAAqC,UAAC,IAAD,EAAS;AAC5C,cAAM,WAAW,GAAG,MAAI,CAAC,cAAL,CAAoB,IAApB,CAApB;;AACA,UAAA,SAAS,CAAC,MAAV,CAAiB,WAAjB;AACA,UAAA,UAAU,CAAC,IAAX,CAAgB,WAAhB;AACD,SAJD;AAKD;;AAED,MAAA,MAAM,CAAC,IAAP,CAAY,aAAZ,EAA2B,OAA3B,CAAmC,UAAC,GAAD,EAAQ;AACzC,YAAI,GAAG,KAAK,aAAZ,EAA2B;AACzB,cAAM,MAAM,GAAG,QAAQ,CAAC,GAAD,EAAM,EAAN,CAAvB;;AACA,UAAA,MAAI,CAAC,WAAL,CAAiB,aAAa,CAAC,GAAD,CAA9B,EAAqC,MAArC,EAA6C,UAA7C;AACD;AACF,OALD;AAOA,WAAK,WAAL;AACD;AA1XH;AAAA;AAAA,WA4XY,6BAAiB;AACzB,aAAO,KAAK,aAAL,IAAsB,KAAK,SAAlC;AACD;AA9XH;AAAA;AAAA,WAgYY,qBACR,KADQ,EAER,MAFQ,EAGR,IAHQ,EAGO;AAAA;;AAEf,UAAM,KAAK,GAAG,KAAK,CAAC,GAAN,CAAU,UAAC,CAAD;AAAA,eAAO,MAAI,CAAC,cAAL,CAAoB,CAApB,CAAP;AAAA,OAAV,CAAd;;AACA,UAAI,IAAI,CAAC,MAAD,CAAJ,IAAgB,MAAM,GAAG,CAA7B,EAAgC;AAC9B,QAAA,GAAG,CAAC,MAAJ,CAAW,IAAI,CAAC,IAAI,CAAC,GAAL,CAAS,MAAT,EAAiB,CAAjB,CAAD,CAAf,EAAsC,KAAtC;AACD,OAFD,MAEO;AACL,QAAA,GAAG,CAAC,MAAJ,CAAW,KAAK,iBAAL,EAAX,EAAqC,KAArC;AACD;AACF;AA3YH;AAAA;AAAA,WA6YY,wBAAe,IAAf,EAAqC;AAC7C,UAAM,MAAM,GAAG,KAAK,UAAL,CAAgB,IAAI,CAAC,EAArB,CAAf;;AACA,UAAI,MAAJ,EAAY;AACV,eAAO,MAAM,CAAC,WAAd;AACD;;AACD,aAAO,KAAK,iBAAL,CAAuB,IAAvB,CAAP;AACD;AAnZH;AAAA;AAAA,WAqZY,2BAAkB,IAAlB,EAAwC;AAChD,UAAI,YAAY,GAAG,MAAM,CAAC,YAAP,CAAoB,KAAK,sBAAL,EAApB,CAAnB;AACA,UAAM,WAAW,GAAG,YAAY,CAAC,IAAjC;;AACA,UAAI,WAAW,IAAI,IAAnB,EAAyB;AACvB,cAAM,IAAI,KAAJ,CAAU,gCAAV,CAAN;AACD;;AAED,MAAA,YAAY,GAAG,MAAM,CAAC,YAAP,CAAoB,KAAK,aAAL,CAAmB,IAAnB,CAApB,CAAf;AACA,UAAM,kBAAkB,GAAG,YAAY,CAAC,IAAxC;AACA,UAAM,oBAAoB,GAAG,YAAY,CAAC,SAA1C;;AAEA,UAAI,kBAAkB,IAAI,IAA1B,EAAgC;AAC9B,cAAM,IAAI,KAAJ,CAAU,sBAAV,CAAN;AACD;;AAED,WAAK,QAAL,CACE;AACE,QAAA,IAAI,EAAE,IAAI,CAAC,EADb;AAEE,sBAAc,IAAI,CAAC;AAFrB,OADF,EAKE,kBALF;AAQA,MAAA,YAAY,GAAG,MAAM,CAAC,YAAP,CAAoB,KAAK,kBAAL,CAAwB,IAAI,CAAC,KAA7B,CAApB,CAAf;AACA,UAAM,gBAAgB,GAAG,YAAY,CAAC,IAAtC;AACA,UAAM,kBAAkB,GAAG,YAAY,CAAC,SAAxC;;AAEA,UAAI,gBAAgB,IAAI,IAAxB,EAA8B;AAC5B,cAAM,IAAI,KAAJ,CAAU,4BAAV,CAAN;AACD;;AAED,UAAI,aAAJ;;AACA,UAAI,oBAAoB,IAAI,kBAA5B,EAAgD;AAC9C;AACA,aAAK,IAAM,GAAX,IAAkB,kBAAlB,EAAsC;AACpC,cAAI,oBAAoB,CAAC,GAAD,CAApB,IAA6B,GAAG,KAAK,KAAK,YAA9C,EAA4D;AAC1D,kBAAM,IAAI,KAAJ,CAAU,uCAAV,CAAN;AACD;AACF;;AACD,QAAA,aAAa,GAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACR,oBADQ,CAAA,EAER,kBAFQ,CAAb;AAID,OAXD,MAWO;AACL,QAAA,aAAa,GAAG,oBAAoB,IAAI,kBAAxC;AACD;;AAED,MAAA,GAAG,CAAC,QAAJ,CAAa,WAAb,EAA0B,SAA1B;AACA,MAAA,GAAG,CAAC,QAAJ,CAAa,kBAAb,EAAiC,cAAjC;AACA,MAAA,GAAG,CAAC,QAAJ,CAAa,gBAAb,EAA+B,eAA/B;AAEA,MAAA,WAAW,CAAC,WAAZ,CAAwB,kBAAxB;AACA,MAAA,WAAW,CAAC,WAAZ,CAAwB,gBAAxB;AAEA,WAAK,UAAL,CAAgB,IAAI,CAAC,EAArB,IAA2B;AACzB,QAAA,WAAW,EAAX,WADyB;AAEzB,QAAA,aAAa,EAAb,aAFyB;AAGzB,QAAA,gBAAgB,EAAhB,gBAHyB;AAIzB,QAAA,kBAAkB,EAAlB,kBAJyB;AAKzB,QAAA,kBAAkB,EAAlB,kBALyB;AAMzB,QAAA,oBAAoB,EAApB;AANyB,OAA3B;AASA,WAAK,KAAL,CAAW,IAAX,CAAgB,cAAhB,CAA+B;AAC7B,QAAA,IAAI,EAAJ,IAD6B;AAE7B,QAAA,IAAI,EAAE,KAAK,IAFkB;AAG7B,QAAA,SAAS,EAAE,WAHkB;AAI7B,QAAA,SAAS,EAAE,aAJkB;AAK7B,QAAA,cAAc,EAAE,gBALa;AAM7B,QAAA,cAAc,EAAE,kBANa;AAO7B,QAAA,gBAAgB,EAAE,kBAPW;AAQ7B,QAAA,gBAAgB,EAAE;AARW,OAA/B;AAWA,aAAO,WAAP;AACD;AAheH;AAAA;AAAA,WAkeY,uBAAW;AAAA;;AACnB;AACA,WAAK,eAAL,GAFmB,CAInB;;AACA,UAAM,MAAM,GAAG,KAAK,IAAL,CAAU,eAAV,EAAf;AACA,MAAA,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,OAApB,CAA4B,UAAC,SAAD;AAAA,eAAe,MAAI,CAAC,eAAL,CAAqB,SAArB,CAAf;AAAA,OAA5B;AACD;AAzeH;AAAA;AAAA,WA2eY,yBAAgB,SAAhB,EAAkC;AAC1C,UAAM,IAAI,GAAG,SAAS,CAAC,QAAV,CAAmB,KAAK,IAAL,CAAU,OAAV,EAAnB,CAAb;AACA,UAAM,OAAO,GAAG,KAAK,IAAL,CAAU,qBAAV,CAAgC,SAAhC,EAA2C,IAA3C,CAAhB;;AAEA,WAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,OAAO,CAAC,MAA5B,EAAoC,CAAC,GAAG,CAAxC,EAA2C,CAAC,IAAI,CAAhD,EAAmD;AACjD,YAAM,MAAM,GAAG,OAAO,CAAC,CAAD,CAAtB;AACA,YAAM,MAAM,GAAG,MAAM,CAAC,MAAtB;AACA,YAAM,MAAM,GAAG,KAAK,UAAL,CAAgB,MAAhB,KAA2B,EAA1C;AACA,YAAM,UAAU,GAAG,MAAM,CAAC,UAA1B;AACA,aAAK,kBAAL,CAAwB,MAAM,CAAC,WAA/B,EAA4C,UAA5C;;AACA,YAAI,MAAM,CAAC,SAAP,IAAoB,IAAxB,EAA8B;AAC5B,cAAM,OAAO,GAAuC;AAClD,YAAA,SAAS,EAAE,MAAM,CAAC,aAAP,IAAwB;AADe,WAApD;;AAIA,cAAI,MAAM,CAAC,QAAX,EAAqB;AACnB,YAAA,OAAO,CAAC,QAAR,GAAmB,SAAS,CAAC,QAAV,CAAmB,MAAM,CAAC,QAA1B,CAAnB;AACD;;AAED,eAAK,WAAL,CAAiB,MAAM,CAAC,WAAxB,EAAqC,MAAM,CAAC,SAA5C,EAAuD,OAAvD;AACD;;AAED,YAAM,WAAW,GAAG,MAAM,CAAC,WAA3B;;AACA,YAAI,WAAJ,EAAiB;AACf,eAAK,kBAAL,CACE,MAAM,CAAC,gBADT,EAEE,WAFF,EAGE,EAAE,UAAU,CAAC,KAAX,IAAoB,CAAtB,CAHF;;AAMA,cAAI,WAAW,CAAC,KAAhB,EAAuB;AACrB,gBAAM,QAAO,GAAuC;AAClD,cAAA,SAAS,EAAE,MAAM,CAAC,kBAAP,IAA6B;AADU,aAApD;;AAIA,gBAAI,MAAM,CAAC,SAAX,EAAsB;AACpB,cAAA,QAAO,CAAC,QAAR,GAAmB,SAAS,CAAC,QAAV,CAAmB,MAAM,CAAC,SAA1B,CAAnB;AACD;;AAED,iBAAK,WAAL,CAAiB,MAAM,CAAC,gBAAxB,EAA0C,WAAW,CAAC,KAAtD,EAA6D,QAA7D;AACD;AACF;AACF;AACF;AAthBH;AAAA;AAAA,WAwhBY,4BACR,OADQ,EAER,MAFQ,EAGQ;AAAA,UAAhB,YAAgB,uEAAD,CAAC;AAEhB,UAAM,KAAK,GAAG,MAAM,CAAC,KAArB;AACA,UAAM,QAAQ,GAAG,MAAM,CAAC,QAAxB;AACA,UAAM,MAAM,GAAG,GAAG,CAAC,eAAJ,GACZ,MADY,CACL,YADK,EAEZ,SAFY,CAEF,QAAQ,CAAC,CAAT,IAAc,CAFZ,EAEe,QAAQ,CAAC,CAAT,IAAc,CAF7B,EAGZ,MAHY,CAGL,KAAK,IAAI,CAHJ,CAAf;AAKA,MAAA,GAAG,CAAC,SAAJ,CAAc,OAAd,EAAqC,MAArC,EAA6C;AAAE,QAAA,QAAQ,EAAE;AAAZ,OAA7C;AACD;AAriBH;AAAA;AAAA,WAuiBY,kCAAsB;AAC9B,aAAO,KAAK,IAAL,CAAU,sBAAV,MAAsC,KAAK,0BAAlD;AACD;AAziBH;AAAA;AAAA,WA2iBY,uBAAc,IAAd,EAAoC;AAC5C,aAAO,IAAI,CAAC,MAAL,IAAe,KAAK,IAAL,CAAU,UAAzB,IAAuC,KAAK,iBAAnD;AACD;AA7iBH;AAAA;AAAA,WA+iBY,4BAAmB,KAAnB,EAA2C;AACnD,aACE,KAAK,CAAC,MAAN,IAAgB,KAAK,IAAL,CAAU,eAA1B,IAA6C,KAAK,sBADpD;AAGD;AAnjBH;AAAA;AAAA,WA+jBY,sBAAgB,CAAhB,EAAsB,CAAtB,EAAkC,CAAlC,EAA4C;AACpD,UAAM,IAAI,GAAG,IAAb,CADoD,CAClC;;AAClB,UAAM,IAAI,GAAG,IAAI,CAAC,IAAlB;AACA,UAAM,IAAI,GAAG,IAAb;;AACA,UAAI,CAAC,IAAI,IAAL,IAAa,CAAC,IAAI,IAAtB,EAA4B;AAC1B,eAAO;AAAE,UAAA,CAAC,EAAD,CAAF;AAAK,UAAA,IAAI,EAAJ,IAAL;AAAW,UAAA,IAAI,EAAJ,IAAX;AAAiB,UAAA,IAAI,EAAJ;AAAjB,SAAP;AACD;;AACD,aAAO;AAAE,QAAA,CAAC,EAAD,CAAF;AAAK,QAAA,CAAC,EAAD,CAAL;AAAQ,QAAA,CAAC,EAAD,CAAR;AAAW,QAAA,IAAI,EAAJ,IAAX;AAAiB,QAAA,IAAI,EAAJ,IAAjB;AAAuB,QAAA,IAAI,EAAJ;AAAvB,OAAP;AACD;AAvkBH;AAAA;AAAA,WAykBE,yBAAgB,CAAhB,EAA0C,CAA1C,EAAqD,CAArD,EAA8D;AAC5D,gFAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB;;AACA,WAAK,MAAL,CAAY,gBAAZ,EAA8B,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAA9B;AACD;AA5kBH;AAAA;AAAA,WA8kBE,yBAAgB,CAAhB,EAA0C,CAA1C,EAAqD,CAArD,EAA8D;AAC5D,gFAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB;;AACA,WAAK,MAAL,CAAY,gBAAZ,EAA8B,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAA9B;AACD;AAjlBH;AAAA;AAAA,WAmlBE,uBAAc,CAAd,EAAsC,CAAtC,EAAiD,CAAjD,EAA0D;AACxD,8EAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB;;AACA,WAAK,MAAL,CAAY,cAAZ,EAA4B,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAA5B;AACD;AAtlBH;AAAA;AAAA,WAwlBE,iBAAQ,CAAR,EAA8B,CAA9B,EAAyC,CAAzC,EAAkD;AAChD,4EAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB;;AACA,WAAK,MAAL,CAAY,YAAZ,EAA0B,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAA1B;AACD;AA3lBH;AAAA;AAAA,WA6lBE,oBAAW,CAAX,EAAuC,CAAvC,EAAkD,CAAlD,EAA2D;AACzD,+EAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB;;AACA,WAAK,MAAL,CAAY,eAAZ,EAA6B,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAA7B;AACD;AAhmBH;AAAA;AAAA,WAkmBE,uBAAc,CAAd,EAA0C,CAA1C,EAAqD,CAArD,EAA8D;AAC5D,kFAAoB,CAApB,EAAuB,CAAvB,EAA0B,CAA1B;;AACA,WAAK,MAAL,CAAY,kBAAZ,EAAgC,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAAhC;AACD;AArmBH;AAAA;AAAA,WAumBE,qBAAY,CAAZ,EAAsC,CAAtC,EAAiD,CAAjD,EAA0D;AACxD,UAAI,KAAK,oBAAL,CAA0B,CAA1B,CAAJ,EAAkC;AAChC;AACD;;AACD,WAAK,eAAL,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B;AACA,WAAK,iBAAL,CAAuB,CAAvB,EAA0B,CAA1B,EAA6B,CAA7B;AACD;AA7mBH;AAAA;AAAA,WA+mBE,qBAAY,CAAZ,EAAsC,CAAtC,EAAiD,CAAjD,EAA0D;AACxD,UAAM,IAAI,GAAG,KAAK,YAAL,CAAuC,CAAvC,CAAb;AACA,UAAM,MAAM,GAAG,IAAI,CAAC,MAApB;;AACA,UAAI,MAAM,KAAK,QAAf,EAAyB;AACvB,aAAK,UAAL,CAAgB,CAAhB,EAAmB,CAAnB,EAAsB,CAAtB;AACD,OAFD,MAEO;AACL,YAAI,MAAM,KAAK,MAAf,EAAuB;AACrB,cAAM,IAAI,GAAG,IAAb;AACA,cAAM,IAAI,GAAG,IAAI,CAAC,UAAL,IAAmB,IAAhC;AACA,UAAA,IAAI,CAAC,QAAL,CAAc,CAAd,EAAiB,CAAjB,EAAoB,CAApB;AACA,UAAA,IAAI,CAAC,MAAL,CAAY,aAAZ,EAA2B;AACzB,YAAA,CAAC,EAAD,CADyB;AAEzB,YAAA,CAAC,EAAD,CAFyB;AAGzB,YAAA,CAAC,EAAD,CAHyB;AAIzB,YAAA,IAAI,EAAJ,IAJyB;AAKzB,YAAA,IAAI,EAAE,IAAI,CAAC,IALc;AAMzB,YAAA,IAAI,EAAE,IAAI,CAAC;AANc,WAA3B;AAQD;;AACD,aAAK,eAAL,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B;AACD;;AAED,WAAK,YAAL,CAAuC,CAAvC,EAA0C,IAA1C;AACD;AAtoBH;AAAA;AAAA,WAwoBE,mBAAU,CAAV,EAAkC,CAAlC,EAA6C,CAA7C,EAAsD;AACpD,UAAM,IAAI,GAAG,KAAK,YAAL,CAAuC,CAAvC,CAAb;AACA,UAAM,MAAM,GAAG,IAAI,CAAC,MAApB;;AACA,UAAI,MAAM,KAAK,QAAf,EAAyB;AACvB,aAAK,kBAAL,CAAwB,CAAxB,EAA2B,CAA3B,EAA8B,CAA9B;AACD,OAFD,MAEO;AACL,aAAK,aAAL,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB;;AACA,YAAI,MAAM,KAAK,MAAf,EAAuB;AACrB,cAAM,IAAI,GAAG,IAAb;AACA,cAAM,IAAI,GAAG,IAAI,CAAC,UAAL,IAAmB,IAAhC;AACA,UAAA,IAAI,CAAC,gBAAL,CAAsB,CAAtB,EAAyB,CAAzB,EAA4B,CAA5B;AACD;AACF;;AAED,UAAM,MAAM,GAAI,IAAyB,CAAC,YAA1C;;AACA,UAAI,MAAJ,EAAY;AACV,aAAK,aAAL,CAAmB,CAAnB,EAAsB,MAAtB,EAA8B,CAA9B,EAAiC,CAAjC;AACD;;AAED,WAAK,eAAL,CAAqB,CAArB;AACD;AA5pBH;AAAA;AAAA,WA8pBE,qBAAY,CAAZ,EAAoC;AAClC,gFAAkB,CAAlB;;AACA,WAAK,MAAL,CAAY,gBAAZ,EAA8B,KAAK,YAAL,CAAkB,CAAlB,CAA9B;AACD;AAjqBH;AAAA;AAAA,WAmqBE,oBAAW,CAAX,EAAkC;AAChC,+EAAiB,CAAjB;;AACA,WAAK,MAAL,CAAY,eAAZ,EAA6B,KAAK,YAAL,CAAkB,CAAlB,CAA7B;AACD;AAtqBH;AAAA;AAAA,WAwqBE,sBAAa,CAAb,EAAsC;AACpC,WAAK,eAAL,CAAqB,CAArB;;AACA,iFAAmB,CAAnB;;AACA,WAAK,MAAL,CAAY,iBAAZ,EAA+B,KAAK,YAAL,CAAkB,CAAlB,CAA/B;AACD;AA5qBH;AAAA;AAAA,WA8qBE,sBAAa,CAAb,EAAsC;AACpC,iFAAmB,CAAnB;;AACA,WAAK,MAAL,CAAY,iBAAZ,EAA+B,KAAK,YAAL,CAAkB,CAAlB,CAA/B;AACD;AAjrBH;AAAA;AAAA,WAmrBE,sBAAa,CAAb,EAAuC,CAAvC,EAAkD,CAAlD,EAA6D,KAA7D,EAA0E;AACxE,iFAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB,EAA4B,KAA5B;;AACA,WAAK,MAAL,CAAY,iBAAZ,EAA6B,MAAA,CAAA,MAAA,CAAA;AAC3B,QAAA,KAAK,EAAL;AAD2B,OAAA,EAExB,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAFwB,CAA7B;AAID;AAzrBH;AAAA;AAAA,WA2rBE,uBAAc,CAAd,EAAsC,MAAtC,EAAuD,CAAvD,EAAkE,CAAlE,EAA2E;AACzE,UAAM,KAAK,GAAG,KAAK,KAAL,CAAW,IAAX,CAAgB,kBAAhB,CAAmC,CAAnC,CAAd;;AACA,UAAI,KAAK,GAAG,KAAK,KAAL,CAAW,OAAX,CAAmB,cAA/B,EAA+C;AAC7C;AACD;;AACD,WAAK,MAAL,CAAY,mBAAZ,EAA+B,MAAA,CAAA,MAAA,CAAA;AAC7B,QAAA,MAAM,EAAN;AAD6B,OAAA,EAE1B,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAF0B,CAA/B;AAID;AApsBH;AAAA;AAAA,WAssBE,0BACE,CADF,EAEE,MAFF,EAGE,CAHF,EAIE,CAJF,EAIW;AAET,WAAK,MAAL,CAAY,sBAAZ,EAAkC,MAAA,CAAA,MAAA,CAAA;AAChC,QAAA,MAAM,EAAN;AADgC,OAAA,EAE7B,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAF6B,CAAlC;AAID;AAhtBH;AAAA;AAAA,WAktBE,6BACE,CADF,EAEE,MAFF,EAGE,CAHF,EAIE,CAJF,EAIW;AAET,WAAK,MAAL,CAAY,yBAAZ,EAAqC,MAAA,CAAA,MAAA,CAAA;AACnC,QAAA,MAAM,EAAN;AADmC,OAAA,EAEhC,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAFgC,CAArC;AAID;AA5tBH;AAAA;AAAA,WA8tBE,2BACE,CADF,EAEE,MAFF,EAGE,CAHF,EAIE,CAJF,EAIW;AAET,WAAK,mBAAL,CAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B;AACD;AAruBH;AAAA;AAAA,WAuuBE,uBAAc,CAAd,EAAwC,IAAxC,EAAsD,CAAtD,EAAiE,CAAjE,EAA0E;AACxE,WAAK,MAAL,CAAY,kBAAZ,EAA8B,MAAA,CAAA,MAAA,CAAA;AAAI,QAAA,IAAI,EAAJ;AAAJ,OAAA,EAAa,KAAK,YAAL,CAAkB,CAAlB,EAAqB,CAArB,EAAwB,CAAxB,CAAb,CAA9B;;AACA,kFAAoB,CAApB,EAAuB,IAAvB,EAA6B,CAA7B,EAAgC,CAAhC;AACD;AA1uBH;AAAA;AAAA,WA4uBY,0BAAiB,CAAjB,EAAyC;AACjD;AACA;AACA;AAEA;AAEA;AACA;AAEA;AACA;AACA;AAEA;AACA;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AAEA;AAEA;AACA;AACA;AACA;AACA;AAEA,UAAM,IAAI,GAAG,KAAK,YAAL,CAA8C,CAA9C,CAAb;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,IAAL,IAAa,KAAK,IAA/B;AACA,UAAM,IAAI,GAAG,KAAK,KAAL,CAAW,cAAX,CAA0B,IAA1B,CAAb;AACA,UAAM,UAAU,GAAG,KAAK,KAAL,CAAW,UAAX,CAAsB,CAAC,CAAC,OAAxB,EAAiC,CAAC,CAAC,OAAnC,CAAnB;AAEA,WAAK,MAAL,CAAY,YAAZ,EAA0B;AACxB,QAAA,CAAC,EAAD,CADwB;AAExB,QAAA,IAAI,EAAJ,IAFwB;AAGxB,QAAA,IAAI,EAAJ,IAHwB;AAIxB,QAAA,IAAI,EAAE,IAJkB;AAKxB,QAAA,CAAC,EAAE,UAAU,CAAC,CALU;AAMxB,QAAA,CAAC,EAAE,UAAU,CAAC,CANU;AAOxB,QAAA,aAAa,EAAE,IAAI,CAAC,SAAL;AAPS,OAA1B;AASD;AA5xBH;AAAA;AAAA,WA8xBE,0BAAiB,CAAjB,EAA2C,IAA3C,EAA2E;AAAA;;AACzE,UAAM,IAAI,GAAG,IAAI,CAAC,IAAL,IAAa,KAAK,IAA/B;AACA,UAAM,KAAK,GAAG,IAAI,CAAC,KAAL,IAAc,KAAK,KAAjC;AACA,UAAM,OAAO,GAAG,KAAK,CAAC,OAAN,CAAc,SAA9B;AACA,UAAM,UAAU,GAAG,OAAO,CAAC,UAA3B;AAEA,UAAI,UAAU,GACZ,OAAO,UAAP,KAAsB,UAAtB,GAEM,WAAW,CAAC,IAAZ,CAAiB,UAAjB,EAA6B,KAA7B,EAAoC;AAClC,QAAA,IAAI,EAAE,IAD4B;AAElC,QAAA,IAAI,EAAE,KAAK;AAFuB,OAApC,EAIA,MAJA,CAIO,UAAC,CAAD,EAAM;AACb,eACE,IAAI,CAAC,MAAL,CAAY,CAAZ,KACA,MAAI,CAAC,IAAL,CAAU,EAAV,KAAiB,CAAC,CAAC,EADnB,IAEA,CAAC,CAAC,CAAC,cAAF,CAAiB,MAAI,CAAC,IAAtB,CAHH;AAKD,OAVC,CAFN,GAaI,KAAK,CAAC,KAAN,CAAY,iBAAZ,CAA8B,IAA9B,EAAoC;AAClC,QAAA,EAAE,EAAE;AAD8B,OAApC,CAdN,CANyE,CAwBzE;;AACA,UAAI,OAAO,CAAC,SAAZ,EAAuB;AACrB,QAAA,UAAU,GAAG,UAAU,CAAC,KAAX,CAAiB,CAAC,CAAlB,CAAb;AACD;;AAED,UAAI,gBAAgB,GAAG,IAAvB;AACA,UAAM,iBAAiB,GAAG,IAAI,CAAC,kBAA/B;AACA,UAAM,gBAAgB,GAAG,OAAO,CAAC,QAAjC;;AACA,WAAK,IAAI,CAAC,GAAG,UAAU,CAAC,MAAX,GAAoB,CAAjC,EAAoC,CAAC,IAAI,CAAzC,EAA4C,CAAC,IAAI,CAAjD,EAAoD;AAClD,YAAM,SAAS,GAAG,UAAU,CAAC,CAAD,CAA5B;;AAEA,YAAI,iBAAiB,IAAI,iBAAiB,CAAC,IAAlB,CAAuB,EAAvB,KAA8B,SAAS,CAAC,EAAjE,EAAqE;AACnE;AACA,UAAA,gBAAgB,GAAG,iBAAnB;AACA;AACD,SAJD,MAIO;AACL,cAAM,IAAI,GAAG,SAAS,CAAC,QAAV,CAAmB,KAAnB,CAAb;;AACA,cACE,WAAW,CAAC,IAAZ,CAAiB,gBAAjB,EAAmC,KAAnC,EAA0C;AACxC,YAAA,KAAK,EAAE,KAAK,IAD4B;AAExC,YAAA,MAAM,EAAE,IAAI,CAAC,IAF2B;AAGxC,YAAA,SAAS,EAAE,IAH6B;AAIxC,YAAA,UAAU,EAAE;AAJ4B,WAA1C,CADF,EAOE;AACA;AACA,YAAA,gBAAgB,GAAG,IAAnB;AACA;AACD;AACF;AACF;;AAED,WAAK,cAAL,CAAoB,IAApB;;AACA,UAAI,gBAAJ,EAAsB;AACpB,QAAA,gBAAgB,CAAC,SAAjB,CAA2B,IAA3B,EAAiC;AAAE,UAAA,IAAI,EAAE;AAAR,SAAjC;AACD;;AACD,MAAA,IAAI,CAAC,kBAAL,GAA0B,gBAA1B;AAEA,UAAM,UAAU,GAAG,KAAK,CAAC,UAAN,CAAiB,CAAC,CAAC,OAAnB,EAA4B,CAAC,CAAC,OAA9B,CAAnB;AACA,WAAK,MAAL,CAAY,gBAAZ,EAA8B;AAC5B,QAAA,CAAC,EAAD,CAD4B;AAE5B,QAAA,IAAI,EAAJ,IAF4B;AAG5B,QAAA,IAAI,EAAE,IAHsB;AAI5B,QAAA,IAAI,EAAE,KAAK,CAAC,cAAN,CAAqB,IAArB,CAJsB;AAK5B,QAAA,CAAC,EAAE,UAAU,CAAC,CALc;AAM5B,QAAA,CAAC,EAAE,UAAU,CAAC,CANc;AAO5B,QAAA,aAAa,EAAE,IAAI,CAAC,SAAL,EAPa;AAQ5B,QAAA,eAAe,EAAE,gBAAgB,GAAG,gBAAgB,CAAC,IAApB,GAA2B;AARhC,OAA9B;AAUD;AAv2BH;AAAA;AAAA,WAy2BE,wBAAe,IAAf,EAA+C;AAC7C,UAAM,aAAa,GAAG,IAAI,CAAC,kBAA3B;;AACA,UAAI,aAAJ,EAAmB;AACjB,QAAA,aAAa,CAAC,WAAd,CAA0B,IAA1B,EAAgC;AAAE,UAAA,IAAI,EAAE;AAAR,SAAhC;AACA,QAAA,IAAI,CAAC,kBAAL,GAA0B,IAA1B;AACD;AACF;AA/2BH;AAAA;AAAA,WAi3BE,2BAAkB,CAAlB,EAA0C,IAA1C,EAA0E;AACxE,UAAM,IAAI,GAAG,IAAI,CAAC,IAAL,IAAa,KAAK,IAA/B;AACA,UAAM,KAAK,GAAG,IAAI,CAAC,KAAL,IAAc,KAAK,KAAjC;AACA,UAAM,IAAI,GAAG,KAAK,CAAC,cAAN,CAAqB,IAArB,CAAb;AACA,UAAM,MAAM,GAAG,IAAI,CAAC,SAAL,EAAf;AACA,UAAM,aAAa,GAAG,IAAI,CAAC,kBAA3B;;AACA,UAAI,aAAJ,EAAmB;AACjB;AACA,QAAA,aAAa,CAAC,WAAd,CAA0B,IAA1B,EAAgC;AAAE,UAAA,IAAI,EAAE;AAAR,SAAhC;AACA,QAAA,IAAI,CAAC,kBAAL,GAA0B,IAA1B;;AACA,YAAI,MAAM,IAAI,IAAV,IAAkB,MAAM,CAAC,EAAP,KAAc,aAAa,CAAC,IAAd,CAAmB,EAAvD,EAA2D;AACzD,UAAA,aAAa,CAAC,IAAd,CAAmB,WAAnB,CAA+B,IAA/B,EAAqC,SAArC,EAAgD;AAAE,YAAA,EAAE,EAAE;AAAN,WAAhD;AACD;AACF,OAPD,MAOO,IAAI,MAAJ,EAAY;AACjB,QAAA,MAAM,CAAC,OAAP,CAAe,IAAf,EAAqB;AAAE,UAAA,EAAE,EAAE;AAAN,SAArB;AACD;;AAED,MAAA,KAAK,CAAC,KAAN,CAAY,iBAAZ,CAA8B,IAA9B,EAAoC;AAAE,QAAA,IAAI,EAAE;AAAR,OAApC,EAAoD,OAApD,CAA4D,UAAC,IAAD,EAAS;AACnE,QAAA,IAAI,CAAC,YAAL,CAAkB;AAAE,UAAA,EAAE,EAAE;AAAN,SAAlB;AACD,OAFD;AAIA,UAAM,UAAU,GAAG,KAAK,CAAC,UAAN,CAAiB,CAAC,CAAC,OAAnB,EAA4B,CAAC,CAAC,OAA9B,CAAnB;;AAEA,UAAI,IAAJ,EAAU;AACR,QAAA,IAAI,CAAC,MAAL,CAAY,eAAZ,EAA6B;AAC3B,UAAA,CAAC,EAAD,CAD2B;AAE3B,UAAA,IAAI,EAAJ,IAF2B;AAG3B,UAAA,CAAC,EAAE,UAAU,CAAC,CAHa;AAI3B,UAAA,CAAC,EAAE,UAAU,CAAC,CAJa;AAK3B,UAAA,IAAI,EAAE,IALqB;AAM3B,UAAA,IAAI,EAAE,KAAK,CAAC,cAAN,CAAqB,IAArB,CANqB;AAO3B,UAAA,cAAc,EAAE,MAPW;AAQ3B,UAAA,aAAa,EAAE,IAAI,CAAC,SAAL;AARY,SAA7B;AAUD;AACF;AAp5BH;AAAA;AAAA,WAs5BE,4BAAgB;AACd,UAAI,IAAI,GAAG,KAAK,IAAhB;AACA,UAAI,IAAI,GAAa,IAArB,CAFc,CAEY;;AAE1B,aAAO,IAAP,EAAa;AACX,YAAI,IAAI,CAAC,MAAL,EAAJ,EAAmB;AACjB;AACD;;AACD,YAAI,CAAC,IAAI,CAAC,SAAL,EAAD,IAAqB,IAAI,CAAC,GAAL,CAAS,wBAAT,CAAzB,EAA6D;AAC3D,iBAAO,IAAP;AACD;;AACD,QAAA,IAAI,GAAG,IAAI,CAAC,SAAL,EAAP;AACA,QAAA,IAAI,GAAG,KAAK,KAAL,CAAW,QAAX,CAAoB,cAApB,CAAmC,IAAnC,CAAP;AACD;;AAED,aAAO,IAAP;AACD;AAt6BH;AAAA;AAAA,WAw6BY,6BACR,CADQ,EAER,CAFQ,EAGR,CAHQ,EAGC;AAET,UAAI,CAAC,KAAK,GAAL,CAAS,mBAAT,CAAL,EAAoC;AAClC;AACD;;AAED,MAAA,CAAC,CAAC,eAAF;AAEA,UAAM,MAAM,GAAG,CAAC,CAAC,aAAjB;AACA,UAAM,KAAK,GAAG,KAAK,KAAnB;AAEA,WAAK,YAAL,CAA6C,CAA7C,EAAgD;AAC9C,QAAA,YAAY,EAAE;AADgC,OAAhD;;AAIA,UAAI,KAAK,CAAC,IAAN,CAAW,cAAX,CAA0B,IAA1B,EAAgC,MAAhC,EAAwC,CAAxC,CAAJ,EAAgD;AAC9C,YAAI,KAAK,CAAC,OAAN,CAAc,eAAd,IAAiC,CAArC,EAAwC;AACtC,eAAK,gBAAL,CAAsB,CAAtB,EAAyB,MAAzB,EAAiC,CAAjC,EAAoC,CAApC;AACD;;AAED,aAAK,YAAL,CAA6C,CAA7C,EAAgD;AAC9C,UAAA,MAAM,EAAE;AADsC,SAAhD;AAGA,aAAK,eAAL,CAAqB,CAArB;AACD,OATD,MASO;AACL,aAAK,WAAL,CAAiB,CAAjB,EAAoB,CAApB,EAAuB,CAAvB;AACD;;AAED,MAAA,KAAK,CAAC,IAAN,CAAW,kBAAX,CAA8B,CAA9B,EAAiC,IAAjC;AACD;AAx8BH;AAAA;AAAA,WA08BY,0BACR,CADQ,EAER,MAFQ,EAGR,CAHQ,EAIR,CAJQ,EAIC;AAET,WAAK,KAAL,CAAW,KAAX,CAAiB,UAAjB,CAA4B,UAA5B;AACA,UAAM,QAAQ,GAAG,KAAK,oBAAL,CAA0B,MAA1B,EAAkC,CAAlC,EAAqC,CAArC,CAAjB;AACA,MAAA,QAAQ,CAAC,eAAT,CAAyB,CAAzB,EAA4B,CAA5B,EAA+B,CAA/B,EAJS,CAIyB;;AAClC,MAAA,QAAQ,CAAC,YAAT,CACE,CADF,EAEE,QAAQ,CAAC,wBAAT,CAAkC,QAAlC,EAA4C;AAC1C,QAAA,CAAC,EAAD,CAD0C;AAE1C,QAAA,CAAC,EAAD,CAF0C;AAG1C,QAAA,SAAS,EAAE,IAH+B;AAI1C,QAAA,cAAc,EAAE;AAJ0B,OAA5C,CAFF;AASA,WAAK,YAAL,CAA6C,CAA7C,EAAgD;AAAE,QAAA,QAAQ,EAAR;AAAF,OAAhD;AACD;AA79BH;AAAA;AAAA,WA+9BY,8BAAqB,MAArB,EAAsC,CAAtC,EAAiD,CAAjD,EAA0D;AAClE,UAAM,KAAK,GAAG,KAAK,KAAnB;AACA,UAAM,KAAK,GAAG,KAAK,CAAC,KAApB;AACA,UAAM,IAAI,GAAG,KAAK,CAAC,IAAN,CAAW,cAAX,CAA0B,IAA1B,EAAgC,MAAhC,CAAb;AAEA,MAAA,IAAI,CAAC,SAAL,CAAc,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACT,IAAI,CAAC,SAAL,EADS,CAAA,EAET,KAAK,eAAL,CAAqB,MAArB,EAA6B,CAA7B,EAAgC,CAAhC,EAAmC,IAAnC,EAAyC,QAAzC,CAFS,CAAd;AAIA,MAAA,IAAI,CAAC,SAAL,CAAc,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAM,IAAI,CAAC,SAAL,EAAN,CAAA,EAAsB;AAAE,QAAA,CAAC,EAAD,CAAF;AAAK,QAAA,CAAC,EAAD;AAAL,OAAtB,CAAd;AACA,MAAA,IAAI,CAAC,KAAL,CAAW,KAAX,EAAkB;AAAE,QAAA,KAAK,EAAE,KAAT;AAAgB,QAAA,EAAE,EAAE;AAApB,OAAlB;AAEA,aAAO,IAAI,CAAC,QAAL,CAAc,KAAd,CAAP;AACD;AA5+BH;AAAA;AAAA,WA8+BY,oBAAW,CAAX,EAAqC,CAArC,EAAgD,CAAhD,EAAyD;AACjE,UAAM,IAAI,GAAG,KAAK,YAAL,CAAoC,CAApC,CAAb;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,QAAtB;;AACA,UAAI,QAAJ,EAAc;AACZ,QAAA,QAAQ,CAAC,WAAT,CAAqB,CAArB,EAAwB,CAAxB,EAA2B,CAA3B;AACA,aAAK,eAAL,CAAqB,CAAC,CAAC,OAAvB,EAAgC,CAAC,CAAC,OAAlC;AACD,OAHD,MAGO;AACL,YAAM,KAAK,GAAG,KAAK,KAAnB;AACA,YAAM,eAAe,GAAG,KAAK,CAAC,OAAN,CAAc,eAAtC;AACA,YAAM,aAAa,GAAG,KAAK,cAAL,CAAoB,CAApB,CAAtB;AACA,YAAM,YAAY,GAAG,IAAI,CAAC,YAA1B,CAJK,CAML;;AACA,YAAI,eAAe,KAAK,SAAxB,EAAmC;AACjC,cACE,YAAY,KAAK,aAAjB,IACA,YAAY,CAAC,QAAb,CAAsB,aAAtB,CAFF,EAGE;AACA;AACD,WANgC,CAOjC;;AACD,SARD,MAQO;AACL;AACA,cAAI,KAAK,CAAC,IAAN,CAAW,kBAAX,CAA8B,CAA9B,KAAoC,eAAxC,EAAyD;AACvD;AACD;AACF;;AACD,aAAK,gBAAL,CAAsB,CAAtB,EAAgC,YAAhC,EAA8C,CAA9C,EAAiD,CAAjD;AACD;AACF;AA3gCH;AAAA;AAAA,WA6gCY,4BAAmB,CAAnB,EAA2C,CAA3C,EAAsD,CAAtD,EAA+D;AACvE,UAAM,IAAI,GAAG,KAAK,SAAL,CAAiC,CAAjC,CAAb;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,QAAtB;;AACA,UAAI,QAAJ,EAAc;AACZ,QAAA,QAAQ,CAAC,SAAT,CAAmB,CAAnB,EAAsB,CAAtB,EAAyB,CAAzB;AACA,aAAK,KAAL,CAAW,KAAX,CAAiB,SAAjB,CAA2B,UAA3B;AACD;AACF;AAphCH;AAAA;AAAA,WAshCY,kCACR,CADQ,EAER,CAFQ,EAGR,CAHQ,EAGC;AAET,WAAK,MAAL,CAAY,0BAAZ,EAAwC;AACtC,QAAA,CAAC,EAAD,CADsC;AAEtC,QAAA,CAAC,EAAD,CAFsC;AAGtC,QAAA,CAAC,EAAD,CAHsC;AAItC,QAAA,IAAI,EAAE,IAJgC;AAKtC,QAAA,IAAI,EAAE,KAAK,IAL2B;AAMtC,QAAA,IAAI,EAAE,KAAK;AAN2B,OAAxC;AAQD;AAniCH;AAAA;AAAA,WAqiCY,wBACR,IADQ,EAER,CAFQ,EAGR,CAHQ,EAIR,CAJQ,EAKR,IALQ,EAKE;AAAA;;AAEV,UAAI,KAAK,GAAG,CAAC,IAAD,CAAZ;AAEA,UAAM,SAAS,GAAG,KAAK,KAAL,CAAW,SAAX,CAAqB,MAAvC;;AACA,UAAI,SAAS,IAAI,SAAS,CAAC,OAAV,CAAkB,OAAnC,EAA4C;AAC1C,YAAM,aAAa,GAAG,KAAK,KAAL,CAAW,gBAAX,EAAtB;;AACA,YAAI,aAAa,CAAC,QAAd,CAAuB,IAAvB,CAAJ,EAAkC;AAChC,UAAA,KAAK,GAAG,aAAa,CAAC,MAAd,CAAqB,UAAC,CAAD;AAAA,mBAAa,CAAC,CAAC,MAAF,EAAb;AAAA,WAArB,CAAR;AACD;AACF;;AAED,MAAA,KAAK,CAAC,OAAN,CAAc,UAAC,CAAD,EAAY;AACxB,QAAA,MAAI,CAAC,MAAL,CAAY,IAAZ,EAAkB;AAChB,UAAA,CAAC,EAAD,CADgB;AAEhB,UAAA,CAAC,EAAD,CAFgB;AAGhB,UAAA,CAAC,EAAD,CAHgB;AAIhB,UAAA,IAAI,EAAE,CAJU;AAKhB,UAAA,IAAI,EAAE,CALU;AAMhB,UAAA,IAAI,EAAE,CAAC,CAAC,QAAF,CAAW,MAAI,CAAC,KAAhB;AANU,SAAlB;AAQD,OATD;AAUD;AAhkCH;AAAA;AAAA,WAkkCY,2BAAkB,CAAlB,EAA4C,CAA5C,EAAuD,CAAvD,EAAgE;AACxE,UAAM,UAAU,GAAG,KAAK,gBAAL,EAAnB;;AACA,UAAI,UAAU,IAAI,IAAd,IAAsB,CAAC,UAAU,CAAC,GAAX,CAAe,aAAf,CAA3B,EAA0D;AACxD,eAAO,KAAK,wBAAL,CAA8B,CAA9B,EAAiC,CAAjC,EAAoC,CAApC,CAAP;AACD;;AAED,WAAK,YAAL,CAAoC,CAApC,EAAuC;AACrC,QAAA,UAAU,EAAV,UADqC;AAErC,QAAA,MAAM,EAAE;AAF6B,OAAvC;AAKA,UAAM,QAAQ,GAAG,KAAK,CAAC,MAAN,CAAa,UAAU,CAAC,IAAX,CAAgB,WAAhB,EAAb,CAAjB;AACA,MAAA,UAAU,CAAC,YAAX,CAAoD,CAApD,EAAuD;AACrD,QAAA,MAAM,EAAE,KAD6C;AAErD,QAAA,MAAM,EAAE,QAAQ,CAAC,IAAT,CAAc,CAAd,EAAiB,CAAjB,CAF6C;AAGrD,QAAA,QAAQ,EAAE,KAAK,KAAL,CAAW,IAAX,CAAgB,eAAhB,CAAgC,UAAhC;AAH2C,OAAvD;AAKD;AAnlCH;AAAA;AAAA,WAqlCY,kBAAS,CAAT,EAAmC,CAAnC,EAA8C,CAA9C,EAAuD;AAC/D,UAAM,IAAI,GAAG,KAAK,IAAlB;AACA,UAAM,KAAK,GAAG,KAAK,KAAnB;AACA,UAAM,QAAQ,GAAG,KAAK,CAAC,WAAN,EAAjB;AACA,UAAM,IAAI,GAAG,KAAK,YAAL,CAA8C,CAA9C,CAAb;AACA,UAAM,MAAM,GAAG,IAAI,CAAC,MAApB;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,QAAtB;;AAEA,UAAI,CAAC,IAAI,CAAC,MAAV,EAAkB;AAChB,QAAA,IAAI,CAAC,MAAL,GAAc,IAAd;AACA,aAAK,QAAL,CAAc,aAAd;AACA,aAAK,cAAL,CAAoB,WAApB,EAAiC,CAAjC,EAAoC,CAApC,EAAuC,CAAvC,EAA0C,KAAK,IAA/C;AACD;;AAED,WAAK,eAAL,CAAqB,CAAC,CAAC,OAAvB,EAAgC,CAAC,CAAC,OAAlC;AAEA,UAAM,IAAI,GAAG,IAAI,CAAC,UAAL,CAAgB,CAAC,GAAG,MAAM,CAAC,CAA3B,EAA8B,QAA9B,CAAb;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,UAAL,CAAgB,CAAC,GAAG,MAAM,CAAC,CAA3B,EAA8B,QAA9B,CAAb;AACA,MAAA,IAAI,CAAC,WAAL,CAAiB,IAAjB,EAAuB,IAAvB,EAA6B;AAC3B,QAAA,QAAQ,EAAR,QAD2B;AAE3B,QAAA,IAAI,EAAE,IAFqB;AAG3B,QAAA,EAAE,EAAE;AAHuB,OAA7B;;AAMA,UAAI,KAAK,CAAC,OAAN,CAAc,SAAd,CAAwB,OAA5B,EAAqC;AACnC,YAAI,CAAC,IAAI,CAAC,SAAV,EAAqB;AACnB,eAAK,gBAAL,CAAsB,CAAtB;AACA,UAAA,IAAI,CAAC,SAAL,GAAiB,IAAjB;AACD;;AACD,aAAK,gBAAL,CAAsB,CAAtB,EAAyB,IAAzB;AACD;AACF;AApnCH;AAAA;AAAA,WAsnCY,0BAAiB,CAAjB,EAAyC,CAAzC,EAAoD,CAApD,EAA6D;AACrE,UAAM,IAAI,GAAG,KAAK,YAAL,CAA8C,CAA9C,CAAb;;AACA,UAAI,IAAI,CAAC,SAAT,EAAoB;AAClB,aAAK,iBAAL,CAAuB,CAAvB,EAA0B,IAA1B;AACD;;AAED,UAAI,IAAI,CAAC,MAAT,EAAiB;AACf,aAAK,WAAL,CAAiB,aAAjB;AACA,aAAK,cAAL,CAAoB,YAApB,EAAkC,CAAlC,EAAqC,CAArC,EAAwC,CAAxC,EAA2C,KAAK,IAAhD;AACD;;AAED,MAAA,IAAI,CAAC,MAAL,GAAc,KAAd;AACA,MAAA,IAAI,CAAC,SAAL,GAAiB,KAAjB;AACD;AAnoCH;AAAA;AAAA,WAqoCY,yBAAgB,CAAhB,EAA2B,CAA3B,EAAoC;AAC5C,UAAM,QAAQ,GAAG,KAAK,KAAL,CAAW,QAAX,CAAoB,MAArC;;AACA,UAAI,QAAJ,EAAc;AACZ,QAAA,QAAQ,CAAC,UAAT,CAAoB,CAApB,EAAuB,CAAvB;AACD;AACF;AA1oCH;;AAAA;AAAA,EAGU,QAHV,EAciB,MAAM,CAAC,WAdxB;;AAgvCA,CAAA,UAAiB,QAAjB,EAAyB;AACV,EAAA,QAAA,CAAA,WAAA,gBAAoB,QAAQ,CAAC,IAA7B;;AAEb,WAAgB,UAAhB,CAA2B,QAA3B,EAAwC;AACtC,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAO,KAAP;AACD;;AAED,QAAI,QAAQ,YAAY,QAAxB,EAAkC;AAChC,aAAO,IAAP;AACD;;AAED,QAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,WAAR,CAApB;AACA,QAAM,IAAI,GAAG,QAAb;;AAEA,QACE,CAAC,GAAG,IAAI,IAAP,IAAe,GAAG,KAAK,QAAA,CAAA,WAAxB,KACA,OAAO,IAAI,CAAC,UAAZ,KAA2B,UAD3B,IAEA,OAAO,IAAI,CAAC,UAAZ,KAA2B,UAF3B,IAGA,OAAO,IAAI,CAAC,aAAZ,KAA8B,UAH9B,IAIA,OAAO,IAAI,CAAC,MAAZ,KAAuB,UAJvB,IAKA,OAAO,IAAI,CAAC,YAAZ,KAA6B,UAL7B,IAMA,OAAO,IAAI,CAAC,MAAZ,KAAuB,UANvB,IAOA,OAAO,IAAI,CAAC,MAAZ,KAAuB,UAPvB,IAQA,OAAO,IAAI,CAAC,SAAZ,KAA0B,UAT5B,EAUE;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD;;AA3Be,EAAA,QAAA,CAAA,UAAA,GAAU,UAAV;AA4BjB,CA/BD,EAAiB,QAAQ,KAAR,QAAQ,GAAA,EAAA,CAAzB;;AA0DA,QAAQ,CAAC,MAAT,CAAgB;AACd,EAAA,YAAY,EAAE,IADA;AAEd,EAAA,QAAQ,EAAE,CAFI;AAGd,EAAA,SAAS,EAAE,CAAC,QAAD,CAHG;AAId,EAAA,OAAO,EAAE;AACP,IAAA,IAAI,EAAE,CAAC,QAAD,CADC;AAEP,IAAA,MAAM,EAAE,CAAC,QAAD,CAFD;AAGP,IAAA,KAAK,EAAE,CAAC,QAAD,CAHA;AAIP,IAAA,IAAI,EAAE,CAAC,QAAD,EAAW,OAAX,EAAoB,OAApB,CAJC;AAKP,IAAA,KAAK,EAAE,CAAC,QAAD,EAAW,OAAX,CALA;AAMP,IAAA,QAAQ,EAAE,CAAC,WAAD,EAAc,OAAd,CANH;AAOP,IAAA,KAAK,EAAE,CAAC,OAAD,CAPA;AAQP,IAAA,KAAK,EAAE,CAAC,OAAD;AARA;AAJK,CAAhB;AAgBA,QAAQ,CAAC,QAAT,CAAkB,QAAlB,CAA2B,MAA3B,EAAmC,QAAnC,EAA6C,IAA7C","sourceRoot":"","sourcesContent":["import { Util, Config } from '../global';\nimport { ArrayExt, FunctionExt, Dom, Vector } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Cell } from '../model/cell';\nimport { CellView } from './cell';\nimport { Markup } from './markup';\nexport class NodeView extends CellView {\n    constructor() {\n        super(...arguments);\n        this.scalableNode = null;\n        this.rotatableNode = null;\n        this.scalableSelector = 'scalable';\n        this.rotatableSelector = 'rotatable';\n        this.defaultPortMarkup = Markup.getPortMarkup();\n        this.defaultPortLabelMarkup = Markup.getPortLabelMarkup();\n        this.defaultPortContainerMarkup = Markup.getPortContainerMarkup();\n        this.portsCache = {};\n        // #endregion\n    }\n    get [Symbol.toStringTag]() {\n        return NodeView.toStringTag;\n    }\n    getContainerClassName() {\n        const classList = [\n            super.getContainerClassName(),\n            this.prefixClassName('node'),\n        ];\n        if (!this.can('nodeMovable')) {\n            classList.push(this.prefixClassName('node-immovable'));\n        }\n        return classList.join(' ');\n    }\n    updateClassName(e) {\n        const target = e.target;\n        if (target.hasAttribute('magnet')) {\n            // port\n            const className = this.prefixClassName('port-unconnectable');\n            if (this.can('magnetConnectable')) {\n                Dom.removeClass(target, className);\n            }\n            else {\n                Dom.addClass(target, className);\n            }\n        }\n        else {\n            // node\n            const className = this.prefixClassName('node-immovable');\n            if (this.can('nodeMovable')) {\n                this.removeClass(className);\n            }\n            else {\n                this.addClass(className);\n            }\n        }\n    }\n    isNodeView() {\n        return true;\n    }\n    confirmUpdate(flag, options = {}) {\n        let ret = flag;\n        if (this.hasAction(ret, 'ports')) {\n            this.removePorts();\n            this.cleanPortsCache();\n        }\n        if (this.hasAction(ret, 'render')) {\n            this.render();\n            ret = this.removeAction(ret, [\n                'render',\n                'update',\n                'resize',\n                'translate',\n                'rotate',\n                'ports',\n                'tools',\n            ]);\n        }\n        else {\n            ret = this.handleAction(ret, 'resize', () => this.resize(options), 'update');\n            ret = this.handleAction(ret, 'update', () => this.update(), \n            // `update()` will render ports when useCSSSelectors are enabled\n            Config.useCSSSelector ? 'ports' : null);\n            ret = this.handleAction(ret, 'translate', () => this.translate());\n            ret = this.handleAction(ret, 'rotate', () => this.rotate());\n            ret = this.handleAction(ret, 'ports', () => this.renderPorts());\n            ret = this.handleAction(ret, 'tools', () => this.renderTools());\n        }\n        return ret;\n    }\n    update(partialAttrs) {\n        this.cleanCache();\n        // When CSS selector strings are used, make sure no rule matches port nodes.\n        if (Config.useCSSSelector) {\n            this.removePorts();\n        }\n        const node = this.cell;\n        const size = node.getSize();\n        const attrs = node.getAttrs();\n        this.updateAttrs(this.container, attrs, {\n            attrs: partialAttrs === attrs ? null : partialAttrs,\n            rootBBox: new Rectangle(0, 0, size.width, size.height),\n            selectors: this.selectors,\n            scalableNode: this.scalableNode,\n            rotatableNode: this.rotatableNode,\n        });\n        if (Config.useCSSSelector) {\n            this.renderPorts();\n        }\n    }\n    renderMarkup() {\n        const markup = this.cell.markup;\n        if (markup) {\n            if (typeof markup === 'string') {\n                return this.renderStringMarkup(markup);\n            }\n            return this.renderJSONMarkup(markup);\n        }\n        throw new TypeError('Invalid node markup.');\n    }\n    renderJSONMarkup(markup) {\n        const ret = this.parseJSONMarkup(markup, this.container);\n        const one = (elems) => Array.isArray(elems) ? elems[0] : elems;\n        this.selectors = ret.selectors;\n        this.rotatableNode = one(this.selectors[this.rotatableSelector]);\n        this.scalableNode = one(this.selectors[this.scalableSelector]);\n        this.container.appendChild(ret.fragment);\n    }\n    renderStringMarkup(markup) {\n        Dom.append(this.container, Vector.toNodes(Vector.createVectors(markup)));\n        this.rotatableNode = Dom.findOne(this.container, `.${this.rotatableSelector}`);\n        this.scalableNode = Dom.findOne(this.container, `.${this.scalableSelector}`);\n        this.selectors = {};\n        if (this.rootSelector) {\n            this.selectors[this.rootSelector] = this.container;\n        }\n    }\n    render() {\n        this.empty();\n        this.renderMarkup();\n        if (this.scalableNode) {\n            // Double update is necessary for elements with the scalable group only\n            // Note the `resize()` triggers the other `update`.\n            this.update();\n        }\n        this.resize();\n        if (this.rotatableNode) {\n            this.rotate();\n            this.translate();\n        }\n        else {\n            this.updateTransform();\n        }\n        if (!Config.useCSSSelector) {\n            this.renderPorts();\n        }\n        this.renderTools();\n        return this;\n    }\n    resize(opt = {}) {\n        if (this.scalableNode) {\n            return this.updateSize(opt);\n        }\n        if (this.cell.getAngle()) {\n            this.rotate();\n        }\n        this.update();\n    }\n    translate() {\n        if (this.rotatableNode) {\n            return this.updateTranslation();\n        }\n        this.updateTransform();\n    }\n    rotate() {\n        if (this.rotatableNode) {\n            this.updateRotation();\n            // It's necessary to call the update for the nodes outside\n            // the rotatable group referencing nodes inside the group\n            this.update();\n            return;\n        }\n        this.updateTransform();\n    }\n    getTranslationString() {\n        const position = this.cell.getPosition();\n        return `translate(${position.x},${position.y})`;\n    }\n    getRotationString() {\n        const angle = this.cell.getAngle();\n        if (angle) {\n            const size = this.cell.getSize();\n            return `rotate(${angle},${size.width / 2},${size.height / 2})`;\n        }\n    }\n    updateTransform() {\n        let transform = this.getTranslationString();\n        const rot = this.getRotationString();\n        if (rot) {\n            transform += ` ${rot}`;\n        }\n        this.container.setAttribute('transform', transform);\n    }\n    updateRotation() {\n        if (this.rotatableNode != null) {\n            const transform = this.getRotationString();\n            if (transform != null) {\n                this.rotatableNode.setAttribute('transform', transform);\n            }\n            else {\n                this.rotatableNode.removeAttribute('transform');\n            }\n        }\n    }\n    updateTranslation() {\n        this.container.setAttribute('transform', this.getTranslationString());\n    }\n    updateSize(opt = {}) {\n        const cell = this.cell;\n        const size = cell.getSize();\n        const angle = cell.getAngle();\n        const scalableNode = this.scalableNode;\n        // Getting scalable group's bbox.\n        // Due to a bug in webkit's native SVG .getBBox implementation, the\n        // bbox of groups with path children includes the paths' control points.\n        // To work around the issue, we need to check whether there are any path\n        // elements inside the scalable group.\n        let recursive = false;\n        if (scalableNode.getElementsByTagName('path').length > 0) {\n            // If scalable has at least one descendant that is a path, we need\n            // toswitch to recursive bbox calculation. Otherwise, group bbox\n            // calculation works and so we can use the (faster) native function.\n            recursive = true;\n        }\n        const scalableBBox = Dom.getBBox(scalableNode, { recursive });\n        // Make sure `scalableBbox.width` and `scalableBbox.height` are not zero\n        // which can happen if the element does not have any content.\n        const sx = size.width / (scalableBBox.width || 1);\n        const sy = size.height / (scalableBBox.height || 1);\n        scalableNode.setAttribute('transform', `scale(${sx},${sy})`);\n        // Now the interesting part. The goal is to be able to store the object geometry via just `x`, `y`, `angle`, `width` and `height`\n        // Order of transformations is significant but we want to reconstruct the object always in the order:\n        // resize(), rotate(), translate() no matter of how the object was transformed. For that to work,\n        // we must adjust the `x` and `y` coordinates of the object whenever we resize it (because the origin of the\n        // rotation changes). The new `x` and `y` coordinates are computed by canceling the previous rotation\n        // around the center of the resized object (which is a different origin then the origin of the previous rotation)\n        // and getting the top-left corner of the resulting object. Then we clean up the rotation back to what it originally was.\n        // Cancel the rotation but now around a different origin, which is the center of the scaled object.\n        const rotatableNode = this.rotatableNode;\n        if (rotatableNode != null) {\n            const transform = rotatableNode.getAttribute('transform');\n            if (transform) {\n                rotatableNode.setAttribute('transform', `${transform} rotate(${-angle},${size.width / 2},${size.height / 2})`);\n                const rotatableBBox = Dom.getBBox(scalableNode, {\n                    target: this.graph.view.stage,\n                });\n                // Store new x, y and perform rotate() again against the new rotation origin.\n                cell.prop('position', { x: rotatableBBox.x, y: rotatableBBox.y }, Object.assign({ updated: true }, opt));\n                this.translate();\n                this.rotate();\n            }\n        }\n        // Update must always be called on non-rotated element. Otherwise,\n        // relative positioning would work with wrong (rotated) bounding boxes.\n        this.update();\n    }\n    // #region ports\n    findPortElem(portId, selector) {\n        const cache = portId ? this.portsCache[portId] : null;\n        if (!cache) {\n            return null;\n        }\n        const portRoot = cache.portContentElement;\n        const portSelectors = cache.portContentSelectors || {};\n        return this.findOne(selector, portRoot, portSelectors);\n    }\n    initializePorts() {\n        this.cleanPortsCache();\n    }\n    refreshPorts() {\n        this.removePorts();\n        this.cleanPortsCache();\n        this.renderPorts();\n    }\n    cleanPortsCache() {\n        this.portsCache = {};\n    }\n    removePorts() {\n        Object.keys(this.portsCache).forEach((portId) => {\n            const cached = this.portsCache[portId];\n            Dom.remove(cached.portElement);\n        });\n    }\n    renderPorts() {\n        const container = this.getPortsContainer();\n        // References to rendered elements without z-index\n        const references = [];\n        container.childNodes.forEach((child) => {\n            references.push(child);\n        });\n        const portsGropsByZ = ArrayExt.groupBy(this.cell.getParsedPorts(), 'zIndex');\n        const autoZIndexKey = 'auto';\n        // render non-z first\n        if (portsGropsByZ[autoZIndexKey]) {\n            portsGropsByZ[autoZIndexKey].forEach((port) => {\n                const portElement = this.getPortElement(port);\n                container.append(portElement);\n                references.push(portElement);\n            });\n        }\n        Object.keys(portsGropsByZ).forEach((key) => {\n            if (key !== autoZIndexKey) {\n                const zIndex = parseInt(key, 10);\n                this.appendPorts(portsGropsByZ[key], zIndex, references);\n            }\n        });\n        this.updatePorts();\n    }\n    getPortsContainer() {\n        return this.rotatableNode || this.container;\n    }\n    appendPorts(ports, zIndex, refs) {\n        const elems = ports.map((p) => this.getPortElement(p));\n        if (refs[zIndex] || zIndex < 0) {\n            Dom.before(refs[Math.max(zIndex, 0)], elems);\n        }\n        else {\n            Dom.append(this.getPortsContainer(), elems);\n        }\n    }\n    getPortElement(port) {\n        const cached = this.portsCache[port.id];\n        if (cached) {\n            return cached.portElement;\n        }\n        return this.createPortElement(port);\n    }\n    createPortElement(port) {\n        let renderResult = Markup.renderMarkup(this.getPortContainerMarkup());\n        const portElement = renderResult.elem;\n        if (portElement == null) {\n            throw new Error('Invalid port container markup.');\n        }\n        renderResult = Markup.renderMarkup(this.getPortMarkup(port));\n        const portContentElement = renderResult.elem;\n        const portContentSelectors = renderResult.selectors;\n        if (portContentElement == null) {\n            throw new Error('Invalid port markup.');\n        }\n        this.setAttrs({\n            port: port.id,\n            'port-group': port.group,\n        }, portContentElement);\n        renderResult = Markup.renderMarkup(this.getPortLabelMarkup(port.label));\n        const portLabelElement = renderResult.elem;\n        const portLabelSelectors = renderResult.selectors;\n        if (portLabelElement == null) {\n            throw new Error('Invalid port label markup.');\n        }\n        let portSelectors;\n        if (portContentSelectors && portLabelSelectors) {\n            // eslint-disable-next-line\n            for (const key in portLabelSelectors) {\n                if (portContentSelectors[key] && key !== this.rootSelector) {\n                    throw new Error('Selectors within port must be unique.');\n                }\n            }\n            portSelectors = Object.assign(Object.assign({}, portContentSelectors), portLabelSelectors);\n        }\n        else {\n            portSelectors = portContentSelectors || portLabelSelectors;\n        }\n        Dom.addClass(portElement, 'x6-port');\n        Dom.addClass(portContentElement, 'x6-port-body');\n        Dom.addClass(portLabelElement, 'x6-port-label');\n        portElement.appendChild(portContentElement);\n        portElement.appendChild(portLabelElement);\n        this.portsCache[port.id] = {\n            portElement,\n            portSelectors,\n            portLabelElement,\n            portLabelSelectors,\n            portContentElement,\n            portContentSelectors,\n        };\n        this.graph.hook.onPortRendered({\n            port,\n            node: this.cell,\n            container: portElement,\n            selectors: portSelectors,\n            labelContainer: portLabelElement,\n            labelSelectors: portLabelSelectors,\n            contentContainer: portContentElement,\n            contentSelectors: portContentSelectors,\n        });\n        return portElement;\n    }\n    updatePorts() {\n        // Layout ports without group\n        this.updatePortGroup();\n        // Layout ports with explicit group\n        const groups = this.cell.getParsedGroups();\n        Object.keys(groups).forEach((groupName) => this.updatePortGroup(groupName));\n    }\n    updatePortGroup(groupName) {\n        const bbox = Rectangle.fromSize(this.cell.getSize());\n        const metrics = this.cell.getPortsLayoutByGroup(groupName, bbox);\n        for (let i = 0, n = metrics.length; i < n; i += 1) {\n            const metric = metrics[i];\n            const portId = metric.portId;\n            const cached = this.portsCache[portId] || {};\n            const portLayout = metric.portLayout;\n            this.applyPortTransform(cached.portElement, portLayout);\n            if (metric.portAttrs != null) {\n                const options = {\n                    selectors: cached.portSelectors || {},\n                };\n                if (metric.portSize) {\n                    options.rootBBox = Rectangle.fromSize(metric.portSize);\n                }\n                this.updateAttrs(cached.portElement, metric.portAttrs, options);\n            }\n            const labelLayout = metric.labelLayout;\n            if (labelLayout) {\n                this.applyPortTransform(cached.portLabelElement, labelLayout, -(portLayout.angle || 0));\n                if (labelLayout.attrs) {\n                    const options = {\n                        selectors: cached.portLabelSelectors || {},\n                    };\n                    if (metric.labelSize) {\n                        options.rootBBox = Rectangle.fromSize(metric.labelSize);\n                    }\n                    this.updateAttrs(cached.portLabelElement, labelLayout.attrs, options);\n                }\n            }\n        }\n    }\n    applyPortTransform(element, layout, initialAngle = 0) {\n        const angle = layout.angle;\n        const position = layout.position;\n        const matrix = Dom.createSVGMatrix()\n            .rotate(initialAngle)\n            .translate(position.x || 0, position.y || 0)\n            .rotate(angle || 0);\n        Dom.transform(element, matrix, { absolute: true });\n    }\n    getPortContainerMarkup() {\n        return this.cell.getPortContainerMarkup() || this.defaultPortContainerMarkup;\n    }\n    getPortMarkup(port) {\n        return port.markup || this.cell.portMarkup || this.defaultPortMarkup;\n    }\n    getPortLabelMarkup(label) {\n        return (label.markup || this.cell.portLabelMarkup || this.defaultPortLabelMarkup);\n    }\n    getEventArgs(e, x, y) {\n        const view = this; // eslint-disable-line\n        const node = view.cell;\n        const cell = node;\n        if (x == null || y == null) {\n            return { e, view, node, cell };\n        }\n        return { e, x, y, view, node, cell };\n    }\n    notifyMouseDown(e, x, y) {\n        super.onMouseDown(e, x, y);\n        this.notify('node:mousedown', this.getEventArgs(e, x, y));\n    }\n    notifyMouseMove(e, x, y) {\n        super.onMouseMove(e, x, y);\n        this.notify('node:mousemove', this.getEventArgs(e, x, y));\n    }\n    notifyMouseUp(e, x, y) {\n        super.onMouseUp(e, x, y);\n        this.notify('node:mouseup', this.getEventArgs(e, x, y));\n    }\n    onClick(e, x, y) {\n        super.onClick(e, x, y);\n        this.notify('node:click', this.getEventArgs(e, x, y));\n    }\n    onDblClick(e, x, y) {\n        super.onDblClick(e, x, y);\n        this.notify('node:dblclick', this.getEventArgs(e, x, y));\n    }\n    onContextMenu(e, x, y) {\n        super.onContextMenu(e, x, y);\n        this.notify('node:contextmenu', this.getEventArgs(e, x, y));\n    }\n    onMouseDown(e, x, y) {\n        if (this.isPropagationStopped(e)) {\n            return;\n        }\n        this.notifyMouseDown(e, x, y);\n        this.startNodeDragging(e, x, y);\n    }\n    onMouseMove(e, x, y) {\n        const data = this.getEventData(e);\n        const action = data.action;\n        if (action === 'magnet') {\n            this.dragMagnet(e, x, y);\n        }\n        else {\n            if (action === 'move') {\n                const meta = data;\n                const view = meta.targetView || this;\n                view.dragNode(e, x, y);\n                view.notify('node:moving', {\n                    e,\n                    x,\n                    y,\n                    view,\n                    cell: view.cell,\n                    node: view.cell,\n                });\n            }\n            this.notifyMouseMove(e, x, y);\n        }\n        this.setEventData(e, data);\n    }\n    onMouseUp(e, x, y) {\n        const data = this.getEventData(e);\n        const action = data.action;\n        if (action === 'magnet') {\n            this.stopMagnetDragging(e, x, y);\n        }\n        else {\n            this.notifyMouseUp(e, x, y);\n            if (action === 'move') {\n                const meta = data;\n                const view = meta.targetView || this;\n                view.stopNodeDragging(e, x, y);\n            }\n        }\n        const magnet = data.targetMagnet;\n        if (magnet) {\n            this.onMagnetClick(e, magnet, x, y);\n        }\n        this.checkMouseleave(e);\n    }\n    onMouseOver(e) {\n        super.onMouseOver(e);\n        this.notify('node:mouseover', this.getEventArgs(e));\n    }\n    onMouseOut(e) {\n        super.onMouseOut(e);\n        this.notify('node:mouseout', this.getEventArgs(e));\n    }\n    onMouseEnter(e) {\n        this.updateClassName(e);\n        super.onMouseEnter(e);\n        this.notify('node:mouseenter', this.getEventArgs(e));\n    }\n    onMouseLeave(e) {\n        super.onMouseLeave(e);\n        this.notify('node:mouseleave', this.getEventArgs(e));\n    }\n    onMouseWheel(e, x, y, delta) {\n        super.onMouseWheel(e, x, y, delta);\n        this.notify('node:mousewheel', Object.assign({ delta }, this.getEventArgs(e, x, y)));\n    }\n    onMagnetClick(e, magnet, x, y) {\n        const count = this.graph.view.getMouseMovedCount(e);\n        if (count > this.graph.options.clickThreshold) {\n            return;\n        }\n        this.notify('node:magnet:click', Object.assign({ magnet }, this.getEventArgs(e, x, y)));\n    }\n    onMagnetDblClick(e, magnet, x, y) {\n        this.notify('node:magnet:dblclick', Object.assign({ magnet }, this.getEventArgs(e, x, y)));\n    }\n    onMagnetContextMenu(e, magnet, x, y) {\n        this.notify('node:magnet:contextmenu', Object.assign({ magnet }, this.getEventArgs(e, x, y)));\n    }\n    onMagnetMouseDown(e, magnet, x, y) {\n        this.startMagnetDragging(e, x, y);\n    }\n    onCustomEvent(e, name, x, y) {\n        this.notify('node:customevent', Object.assign({ name }, this.getEventArgs(e, x, y)));\n        super.onCustomEvent(e, name, x, y);\n    }\n    prepareEmbedding(e) {\n        // const cell = data.cell || this.cell\n        // const graph = data.graph || this.graph\n        // const model = graph.model\n        // model.startBatch('to-front')\n        // // Bring the model to the front with all his embeds.\n        // cell.toFront({ deep: true, ui: true })\n        // const maxZ = model\n        //   .getNodes()\n        //   .reduce((max, cell) => Math.max(max, cell.getZIndex() || 0), 0)\n        // const connectedEdges = model.getConnectedEdges(cell, {\n        //   deep: true,\n        //   enclosed: true,\n        // })\n        // connectedEdges.forEach((edge) => {\n        //   const zIndex = edge.getZIndex() || 0\n        //   if (zIndex <= maxZ) {\n        //     edge.setZIndex(maxZ + 1, { ui: true })\n        //   }\n        // })\n        // model.stopBatch('to-front')\n        // Before we start looking for suitable parent we remove the current one.\n        // const parent = cell.getParent()\n        // if (parent) {\n        //   parent.unembed(cell, { ui: true })\n        // }\n        const data = this.getEventData(e);\n        const node = data.cell || this.cell;\n        const view = this.graph.findViewByCell(node);\n        const localPoint = this.graph.snapToGrid(e.clientX, e.clientY);\n        this.notify('node:embed', {\n            e,\n            node,\n            view,\n            cell: node,\n            x: localPoint.x,\n            y: localPoint.y,\n            currentParent: node.getParent(),\n        });\n    }\n    processEmbedding(e, data) {\n        const cell = data.cell || this.cell;\n        const graph = data.graph || this.graph;\n        const options = graph.options.embedding;\n        const findParent = options.findParent;\n        let candidates = typeof findParent === 'function'\n            ? FunctionExt.call(findParent, graph, {\n                view: this,\n                node: this.cell,\n            }).filter((c) => {\n                return (Cell.isCell(c) &&\n                    this.cell.id !== c.id &&\n                    !c.isDescendantOf(this.cell));\n            })\n            : graph.model.getNodesUnderNode(cell, {\n                by: findParent,\n            });\n        // Picks the node with the highest `z` index\n        if (options.frontOnly) {\n            candidates = candidates.slice(-1);\n        }\n        let newCandidateView = null;\n        const prevCandidateView = data.candidateEmbedView;\n        const validateEmbeding = options.validate;\n        for (let i = candidates.length - 1; i >= 0; i -= 1) {\n            const candidate = candidates[i];\n            if (prevCandidateView && prevCandidateView.cell.id === candidate.id) {\n                // candidate remains the same\n                newCandidateView = prevCandidateView;\n                break;\n            }\n            else {\n                const view = candidate.findView(graph);\n                if (FunctionExt.call(validateEmbeding, graph, {\n                    child: this.cell,\n                    parent: view.cell,\n                    childView: this,\n                    parentView: view,\n                })) {\n                    // flip to the new candidate\n                    newCandidateView = view;\n                    break;\n                }\n            }\n        }\n        this.clearEmbedding(data);\n        if (newCandidateView) {\n            newCandidateView.highlight(null, { type: 'embedding' });\n        }\n        data.candidateEmbedView = newCandidateView;\n        const localPoint = graph.snapToGrid(e.clientX, e.clientY);\n        this.notify('node:embedding', {\n            e,\n            cell,\n            node: cell,\n            view: graph.findViewByCell(cell),\n            x: localPoint.x,\n            y: localPoint.y,\n            currentParent: cell.getParent(),\n            candidateParent: newCandidateView ? newCandidateView.cell : null,\n        });\n    }\n    clearEmbedding(data) {\n        const candidateView = data.candidateEmbedView;\n        if (candidateView) {\n            candidateView.unhighlight(null, { type: 'embedding' });\n            data.candidateEmbedView = null;\n        }\n    }\n    finalizeEmbedding(e, data) {\n        const cell = data.cell || this.cell;\n        const graph = data.graph || this.graph;\n        const view = graph.findViewByCell(cell);\n        const parent = cell.getParent();\n        const candidateView = data.candidateEmbedView;\n        if (candidateView) {\n            // Candidate view is chosen to become the parent of the node.\n            candidateView.unhighlight(null, { type: 'embedding' });\n            data.candidateEmbedView = null;\n            if (parent == null || parent.id !== candidateView.cell.id) {\n                candidateView.cell.insertChild(cell, undefined, { ui: true });\n            }\n        }\n        else if (parent) {\n            parent.unembed(cell, { ui: true });\n        }\n        graph.model.getConnectedEdges(cell, { deep: true }).forEach((edge) => {\n            edge.updateParent({ ui: true });\n        });\n        const localPoint = graph.snapToGrid(e.clientX, e.clientY);\n        if (view) {\n            view.notify('node:embedded', {\n                e,\n                cell,\n                x: localPoint.x,\n                y: localPoint.y,\n                node: cell,\n                view: graph.findViewByCell(cell),\n                previousParent: parent,\n                currentParent: cell.getParent(),\n            });\n        }\n    }\n    getDelegatedView() {\n        let cell = this.cell;\n        let view = this; // eslint-disable-line\n        while (view) {\n            if (cell.isEdge()) {\n                break;\n            }\n            if (!cell.hasParent() || view.can('stopDelegateOnDragging')) {\n                return view;\n            }\n            cell = cell.getParent();\n            view = this.graph.renderer.findViewByCell(cell);\n        }\n        return null;\n    }\n    startMagnetDragging(e, x, y) {\n        if (!this.can('magnetConnectable')) {\n            return;\n        }\n        e.stopPropagation();\n        const magnet = e.currentTarget;\n        const graph = this.graph;\n        this.setEventData(e, {\n            targetMagnet: magnet,\n        });\n        if (graph.hook.validateMagnet(this, magnet, e)) {\n            if (graph.options.magnetThreshold <= 0) {\n                this.startConnectting(e, magnet, x, y);\n            }\n            this.setEventData(e, {\n                action: 'magnet',\n            });\n            this.stopPropagation(e);\n        }\n        else {\n            this.onMouseDown(e, x, y);\n        }\n        graph.view.delegateDragEvents(e, this);\n    }\n    startConnectting(e, magnet, x, y) {\n        this.graph.model.startBatch('add-edge');\n        const edgeView = this.createEdgeFromMagnet(magnet, x, y);\n        edgeView.notifyMouseDown(e, x, y); // backwards compatibility events\n        edgeView.setEventData(e, edgeView.prepareArrowheadDragging('target', {\n            x,\n            y,\n            isNewEdge: true,\n            fallbackAction: 'remove',\n        }));\n        this.setEventData(e, { edgeView });\n    }\n    createEdgeFromMagnet(magnet, x, y) {\n        const graph = this.graph;\n        const model = graph.model;\n        const edge = graph.hook.getDefaultEdge(this, magnet);\n        edge.setSource(Object.assign(Object.assign({}, edge.getSource()), this.getEdgeTerminal(magnet, x, y, edge, 'source')));\n        edge.setTarget(Object.assign(Object.assign({}, edge.getTarget()), { x, y }));\n        edge.addTo(model, { async: false, ui: true });\n        return edge.findView(graph);\n    }\n    dragMagnet(e, x, y) {\n        const data = this.getEventData(e);\n        const edgeView = data.edgeView;\n        if (edgeView) {\n            edgeView.onMouseMove(e, x, y);\n            this.autoScrollGraph(e.clientX, e.clientY);\n        }\n        else {\n            const graph = this.graph;\n            const magnetThreshold = graph.options.magnetThreshold;\n            const currentTarget = this.getEventTarget(e);\n            const targetMagnet = data.targetMagnet;\n            // magnetThreshold when the pointer leaves the magnet\n            if (magnetThreshold === 'onleave') {\n                if (targetMagnet === currentTarget ||\n                    targetMagnet.contains(currentTarget)) {\n                    return;\n                }\n                // eslint-disable-next-line no-lonely-if\n            }\n            else {\n                // magnetThreshold defined as a number of movements\n                if (graph.view.getMouseMovedCount(e) <= magnetThreshold) {\n                    return;\n                }\n            }\n            this.startConnectting(e, targetMagnet, x, y);\n        }\n    }\n    stopMagnetDragging(e, x, y) {\n        const data = this.eventData(e);\n        const edgeView = data.edgeView;\n        if (edgeView) {\n            edgeView.onMouseUp(e, x, y);\n            this.graph.model.stopBatch('add-edge');\n        }\n    }\n    notifyUnhandledMouseDown(e, x, y) {\n        this.notify('node:unhandled:mousedown', {\n            e,\n            x,\n            y,\n            view: this,\n            cell: this.cell,\n            node: this.cell,\n        });\n    }\n    notifyNodeMove(name, e, x, y, cell) {\n        let cells = [cell];\n        const selection = this.graph.selection.widget;\n        if (selection && selection.options.movable) {\n            const selectedCells = this.graph.getSelectedCells();\n            if (selectedCells.includes(cell)) {\n                cells = selectedCells.filter((c) => c.isNode());\n            }\n        }\n        cells.forEach((c) => {\n            this.notify(name, {\n                e,\n                x,\n                y,\n                cell: c,\n                node: c,\n                view: c.findView(this.graph),\n            });\n        });\n    }\n    startNodeDragging(e, x, y) {\n        const targetView = this.getDelegatedView();\n        if (targetView == null || !targetView.can('nodeMovable')) {\n            return this.notifyUnhandledMouseDown(e, x, y);\n        }\n        this.setEventData(e, {\n            targetView,\n            action: 'move',\n        });\n        const position = Point.create(targetView.cell.getPosition());\n        targetView.setEventData(e, {\n            moving: false,\n            offset: position.diff(x, y),\n            restrict: this.graph.hook.getRestrictArea(targetView),\n        });\n    }\n    dragNode(e, x, y) {\n        const node = this.cell;\n        const graph = this.graph;\n        const gridSize = graph.getGridSize();\n        const data = this.getEventData(e);\n        const offset = data.offset;\n        const restrict = data.restrict;\n        if (!data.moving) {\n            data.moving = true;\n            this.addClass('node-moving');\n            this.notifyNodeMove('node:move', e, x, y, this.cell);\n        }\n        this.autoScrollGraph(e.clientX, e.clientY);\n        const posX = Util.snapToGrid(x + offset.x, gridSize);\n        const posY = Util.snapToGrid(y + offset.y, gridSize);\n        node.setPosition(posX, posY, {\n            restrict,\n            deep: true,\n            ui: true,\n        });\n        if (graph.options.embedding.enabled) {\n            if (!data.embedding) {\n                this.prepareEmbedding(e);\n                data.embedding = true;\n            }\n            this.processEmbedding(e, data);\n        }\n    }\n    stopNodeDragging(e, x, y) {\n        const data = this.getEventData(e);\n        if (data.embedding) {\n            this.finalizeEmbedding(e, data);\n        }\n        if (data.moving) {\n            this.removeClass('node-moving');\n            this.notifyNodeMove('node:moved', e, x, y, this.cell);\n        }\n        data.moving = false;\n        data.embedding = false;\n    }\n    autoScrollGraph(x, y) {\n        const scroller = this.graph.scroller.widget;\n        if (scroller) {\n            scroller.autoScroll(x, y);\n        }\n    }\n}\n(function (NodeView) {\n    NodeView.toStringTag = `X6.${NodeView.name}`;\n    function isNodeView(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof NodeView) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const view = instance;\n        if ((tag == null || tag === NodeView.toStringTag) &&\n            typeof view.isNodeView === 'function' &&\n            typeof view.isEdgeView === 'function' &&\n            typeof view.confirmUpdate === 'function' &&\n            typeof view.update === 'function' &&\n            typeof view.findPortElem === 'function' &&\n            typeof view.resize === 'function' &&\n            typeof view.rotate === 'function' &&\n            typeof view.translate === 'function') {\n            return true;\n        }\n        return false;\n    }\n    NodeView.isNodeView = isNodeView;\n})(NodeView || (NodeView = {}));\nNodeView.config({\n    isSvgElement: true,\n    priority: 0,\n    bootstrap: ['render'],\n    actions: {\n        view: ['render'],\n        markup: ['render'],\n        attrs: ['update'],\n        size: ['resize', 'ports', 'tools'],\n        angle: ['rotate', 'tools'],\n        position: ['translate', 'tools'],\n        ports: ['ports'],\n        tools: ['tools'],\n    },\n});\nNodeView.registry.register('node', NodeView, true);\n//# sourceMappingURL=node.js.map"]},"metadata":{},"sourceType":"module"}