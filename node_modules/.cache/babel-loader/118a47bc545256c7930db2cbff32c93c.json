{"ast":null,"code":"/* eslint-disable no-underscore-dangle */\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ArrayExt, StringExt, ObjectExt, FunctionExt } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Basecoat } from '../common';\nimport { Attr } from '../registry';\nimport { Animation } from './animation';\nimport { Store } from './store';\nexport class Cell extends Basecoat {\n  constructor() {\n    let metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    const ctor = this.constructor;\n    const defaults = ctor.getDefaults(true);\n    const props = ObjectExt.merge({}, this.preprocess(defaults), this.preprocess(metadata));\n    this.id = props.id || StringExt.uuid();\n    this.store = new Store(props);\n    this.animation = new Animation(this);\n    this.setup();\n    this.init();\n    this.postprocess(metadata);\n  }\n\n  static config(presets) {\n    const {\n      markup,\n      propHooks,\n      attrHooks\n    } = presets,\n          others = __rest(presets, [\"markup\", \"propHooks\", \"attrHooks\"]);\n\n    if (markup != null) {\n      this.markup = markup;\n    }\n\n    if (propHooks) {\n      this.propHooks = this.propHooks.slice();\n\n      if (Array.isArray(propHooks)) {\n        this.propHooks.push(...propHooks);\n      } else if (typeof propHooks === 'function') {\n        this.propHooks.push(propHooks);\n      } else {\n        Object.keys(propHooks).forEach(name => {\n          const hook = propHooks[name];\n\n          if (typeof hook === 'function') {\n            this.propHooks.push(hook);\n          }\n        });\n      }\n    }\n\n    if (attrHooks) {\n      this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);\n    }\n\n    this.defaults = ObjectExt.merge({}, this.defaults, others);\n  }\n\n  static getMarkup() {\n    return this.markup;\n  }\n\n  static getDefaults(raw) {\n    return raw ? this.defaults : ObjectExt.cloneDeep(this.defaults);\n  }\n\n  static getAttrHooks() {\n    return this.attrHooks;\n  }\n\n  static applyPropHooks(cell, metadata) {\n    return this.propHooks.reduce((memo, hook) => {\n      return hook ? FunctionExt.call(hook, cell, memo) : memo;\n    }, metadata);\n  } // #endregion\n\n\n  get [Symbol.toStringTag]() {\n    return Cell.toStringTag;\n  }\n\n  init() {} // #region model\n\n\n  get model() {\n    return this._model;\n  }\n\n  set model(model) {\n    if (this._model !== model) {\n      this._model = model;\n    }\n  } // #endregion\n\n\n  preprocess(metadata, ignoreIdCheck) {\n    const id = metadata.id;\n    const ctor = this.constructor;\n    const props = ctor.applyPropHooks(this, metadata);\n\n    if (id == null && ignoreIdCheck !== true) {\n      props.id = StringExt.uuid();\n    }\n\n    return props;\n  }\n\n  postprocess(metadata) {} // eslint-disable-line\n\n\n  setup() {\n    this.store.on('change:*', metadata => {\n      const {\n        key,\n        current,\n        previous,\n        options\n      } = metadata;\n      this.notify('change:*', {\n        key,\n        options,\n        current,\n        previous,\n        cell: this\n      });\n      this.notify(`change:${key}`, {\n        options,\n        current,\n        previous,\n        cell: this\n      });\n      const type = key;\n\n      if (type === 'source' || type === 'target') {\n        this.notify(`change:terminal`, {\n          type,\n          current,\n          previous,\n          options,\n          cell: this\n        });\n      }\n    });\n    this.store.on('changed', _ref => {\n      let {\n        options\n      } = _ref;\n      return this.notify('changed', {\n        options,\n        cell: this\n      });\n    });\n  }\n\n  notify(name, args) {\n    this.trigger(name, args);\n    const model = this.model;\n\n    if (model) {\n      model.notify(`cell:${name}`, args);\n\n      if (this.isNode()) {\n        model.notify(`node:${name}`, Object.assign(Object.assign({}, args), {\n          node: this\n        }));\n      } else if (this.isEdge()) {\n        model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), {\n          edge: this\n        }));\n      }\n    }\n\n    return this;\n  }\n\n  isNode() {\n    return false;\n  }\n\n  isEdge() {\n    return false;\n  }\n\n  isSameStore(cell) {\n    return this.store === cell.store;\n  }\n\n  get view() {\n    return this.store.get('view');\n  }\n\n  get shape() {\n    return this.store.get('shape', '');\n  }\n\n  getProp(key, defaultValue) {\n    if (key == null) {\n      return this.store.get();\n    }\n\n    return this.store.get(key, defaultValue);\n  }\n\n  setProp(key, value, options) {\n    if (typeof key === 'string') {\n      this.store.set(key, value, options);\n    } else {\n      const props = this.preprocess(key, true);\n      this.store.set(ObjectExt.merge({}, this.getProp(), props), value);\n      this.postprocess(key);\n    }\n\n    return this;\n  }\n\n  removeProp(key, options) {\n    if (typeof key === 'string' || Array.isArray(key)) {\n      this.store.removeByPath(key, options);\n    } else {\n      this.store.remove(options);\n    }\n\n    return this;\n  }\n\n  hasChanged(key) {\n    return key == null ? this.store.hasChanged() : this.store.hasChanged(key);\n  }\n\n  getPropByPath(path) {\n    return this.store.getByPath(path);\n  }\n\n  setPropByPath(path, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (this.model) {\n      // update inner reference\n      if (path === 'children') {\n        this._children = value ? value.map(id => this.model.getCell(id)).filter(child => child != null) : null;\n      } else if (path === 'parent') {\n        this._parent = value ? this.model.getCell(value) : null;\n      }\n    }\n\n    this.store.setByPath(path, value, options);\n    return this;\n  }\n\n  removePropByPath(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const paths = Array.isArray(path) ? path : path.split('/'); // Once a property is removed from the `attrs` the CellView will\n    // recognize a `dirty` flag and re-render itself in order to remove\n    // the attribute from SVGElement.\n\n    if (paths[0] === 'attrs') {\n      options.dirty = true;\n    }\n\n    this.store.removeByPath(paths, options);\n    return this;\n  }\n\n  prop(key, value, options) {\n    if (key == null) {\n      return this.getProp();\n    }\n\n    if (typeof key === 'string' || Array.isArray(key)) {\n      if (arguments.length === 1) {\n        return this.getPropByPath(key);\n      }\n\n      if (value == null) {\n        return this.removePropByPath(key, options || {});\n      }\n\n      return this.setPropByPath(key, value, options || {});\n    }\n\n    return this.setProp(key, value || {});\n  }\n\n  previous(name) {\n    return this.store.getPrevious(name);\n  } // #endregion\n  // #region zIndex\n\n\n  get zIndex() {\n    return this.getZIndex();\n  }\n\n  set zIndex(z) {\n    if (z == null) {\n      this.removeZIndex();\n    } else {\n      this.setZIndex(z);\n    }\n  }\n\n  getZIndex() {\n    return this.store.get('zIndex');\n  }\n\n  setZIndex(z) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('zIndex', z, options);\n    return this;\n  }\n\n  removeZIndex() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('zIndex', options);\n    return this;\n  }\n\n  toFront() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const model = this.model;\n\n    if (model) {\n      let z = model.getMaxZIndex();\n      let cells;\n\n      if (options.deep) {\n        cells = this.getDescendants({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n\n      z = z - cells.length + 1;\n      const count = model.total();\n      let changed = model.indexOf(this) !== count - cells.length;\n\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n      }\n\n      if (changed) {\n        this.batchUpdate('to-front', () => {\n          z += cells.length;\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options);\n          });\n        });\n      }\n    }\n\n    return this;\n  }\n\n  toBack() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const model = this.model;\n\n    if (model) {\n      let z = model.getMinZIndex();\n      let cells;\n\n      if (options.deep) {\n        cells = this.getDescendants({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.unshift(this);\n      } else {\n        cells = [this];\n      }\n\n      let changed = model.indexOf(this) !== 0;\n\n      if (!changed) {\n        changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n      }\n\n      if (changed) {\n        this.batchUpdate('to-back', () => {\n          z -= cells.length;\n          cells.forEach((cell, index) => {\n            cell.setZIndex(z + index, options);\n          });\n        });\n      }\n    }\n\n    return this;\n  } // #endregion\n  // #region markup\n\n\n  get markup() {\n    return this.getMarkup();\n  }\n\n  set markup(value) {\n    if (value == null) {\n      this.removeMarkup();\n    } else {\n      this.setMarkup(value);\n    }\n  }\n\n  getMarkup() {\n    let markup = this.store.get('markup');\n\n    if (markup == null) {\n      const ctor = this.constructor;\n      markup = ctor.getMarkup();\n    }\n\n    return markup;\n  }\n\n  setMarkup(markup) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('markup', markup, options);\n    return this;\n  }\n\n  removeMarkup() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('markup', options);\n    return this;\n  } // #endregion\n  // #region attrs\n\n\n  get attrs() {\n    return this.getAttrs();\n  }\n\n  set attrs(value) {\n    if (value == null) {\n      this.removeAttrs();\n    } else {\n      this.setAttrs(value);\n    }\n  }\n\n  getAttrs() {\n    const result = this.store.get('attrs');\n    return result ? Object.assign({}, result) : {};\n  }\n\n  setAttrs(attrs) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (attrs == null) {\n      this.removeAttrs(options);\n    } else {\n      const set = attrs => this.store.set('attrs', attrs, options);\n\n      if (options.overwrite === true) {\n        set(attrs);\n      } else {\n        const prev = this.getAttrs();\n\n        if (options.deep === false) {\n          set(Object.assign(Object.assign({}, prev), attrs));\n        } else {\n          set(ObjectExt.merge({}, prev, attrs));\n        }\n      }\n    }\n\n    return this;\n  }\n\n  replaceAttrs(attrs) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n      overwrite: true\n    }));\n  }\n\n  updateAttrs(attrs) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.setAttrs(attrs, Object.assign(Object.assign({}, options), {\n      deep: false\n    }));\n  }\n\n  removeAttrs() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('attrs', options);\n    return this;\n  }\n\n  getAttrDefinition(attrName) {\n    if (!attrName) {\n      return null;\n    }\n\n    const ctor = this.constructor;\n    const hooks = ctor.getAttrHooks() || {};\n    let definition = hooks[attrName] || Attr.registry.get(attrName);\n\n    if (!definition) {\n      const name = StringExt.camelCase(attrName);\n      definition = hooks[name] || Attr.registry.get(name);\n    }\n\n    return definition || null;\n  }\n\n  getAttrByPath(path) {\n    if (path == null || path === '') {\n      return this.getAttrs();\n    }\n\n    return this.getPropByPath(this.prefixAttrPath(path));\n  }\n\n  setAttrByPath(path, value) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    this.setPropByPath(this.prefixAttrPath(path), value, options);\n    return this;\n  }\n\n  removeAttrByPath(path) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.removePropByPath(this.prefixAttrPath(path), options);\n    return this;\n  }\n\n  prefixAttrPath(path) {\n    return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`;\n  }\n\n  attr(path, value, options) {\n    if (path == null) {\n      return this.getAttrByPath();\n    }\n\n    if (typeof path === 'string' || Array.isArray(path)) {\n      if (arguments.length === 1) {\n        return this.getAttrByPath(path);\n      }\n\n      if (value == null) {\n        return this.removeAttrByPath(path, options || {});\n      }\n\n      return this.setAttrByPath(path, value, options || {});\n    }\n\n    return this.setAttrs(path, value || {});\n  } // #endregion\n  // #region visible\n\n\n  get visible() {\n    return this.isVisible();\n  }\n\n  set visible(value) {\n    this.setVisible(value);\n  }\n\n  setVisible(visible) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.store.set('visible', visible, options);\n    return this;\n  }\n\n  isVisible() {\n    return this.store.get('visible') !== false;\n  }\n\n  show() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!this.isVisible()) {\n      this.setVisible(true, options);\n    }\n\n    return this;\n  }\n\n  hide() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.isVisible()) {\n      this.setVisible(false, options);\n    }\n\n    return this;\n  }\n\n  toggleVisible(isVisible) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();\n    const localOptions = typeof isVisible === 'boolean' ? options : isVisible;\n\n    if (visible) {\n      this.show(localOptions);\n    } else {\n      this.hide(localOptions);\n    }\n\n    return this;\n  } // #endregion\n  // #region data\n\n\n  get data() {\n    return this.getData();\n  }\n\n  set data(val) {\n    this.setData(val);\n  }\n\n  getData() {\n    return this.store.get('data');\n  }\n\n  setData(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (data == null) {\n      this.removeData(options);\n    } else {\n      const set = data => this.store.set('data', data, options);\n\n      if (options.overwrite === true) {\n        set(data);\n      } else {\n        const prev = this.getData();\n\n        if (options.deep === false) {\n          set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);\n        } else {\n          set(ObjectExt.merge({}, prev, data));\n        }\n      }\n    }\n\n    return this;\n  }\n\n  replaceData(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.setData(data, Object.assign(Object.assign({}, options), {\n      overwrite: true\n    }));\n  }\n\n  updateData(data) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.setData(data, Object.assign(Object.assign({}, options), {\n      deep: false\n    }));\n  }\n\n  removeData() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('data', options);\n    return this;\n  } // #endregion\n  // #region parent children\n\n\n  get parent() {\n    return this.getParent();\n  }\n\n  get children() {\n    return this.getChildren();\n  }\n\n  getParentId() {\n    return this.store.get('parent');\n  }\n\n  getParent() {\n    let parent = this._parent;\n\n    if (parent == null && this.store) {\n      const parentId = this.getParentId();\n\n      if (parentId != null && this.model) {\n        parent = this.model.getCell(parentId);\n        this._parent = parent;\n      }\n    }\n\n    return parent;\n  }\n\n  getChildren() {\n    let children = this._children;\n\n    if (children == null) {\n      const childrenIds = this.store.get('children');\n\n      if (childrenIds && childrenIds.length && this.model) {\n        children = childrenIds.map(id => {\n          var _a;\n\n          return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id);\n        }).filter(cell => cell != null);\n        this._children = children;\n      }\n    }\n\n    return children ? [...children] : null;\n  }\n\n  hasParent() {\n    return this.parent != null;\n  }\n\n  isParentOf(child) {\n    return child != null && child.getParent() === this;\n  }\n\n  isChildOf(parent) {\n    return parent != null && this.getParent() === parent;\n  }\n\n  eachChild(iterator, context) {\n    if (this.children) {\n      this.children.forEach(iterator, context);\n    }\n\n    return this;\n  }\n\n  filterChild(filter, context) {\n    return this.children ? this.children.filter(filter, context) : [];\n  }\n\n  getChildCount() {\n    return this.children == null ? 0 : this.children.length;\n  }\n\n  getChildIndex(child) {\n    return this.children == null ? -1 : this.children.indexOf(child);\n  }\n\n  getChildAt(index) {\n    return this.children != null && index >= 0 ? this.children[index] : null;\n  }\n\n  getAncestors() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const ancestors = [];\n    let parent = this.getParent();\n\n    while (parent) {\n      ancestors.push(parent);\n      parent = options.deep !== false ? parent.getParent() : null;\n    }\n\n    return ancestors;\n  }\n\n  getDescendants() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.deep !== false) {\n      // breadth first\n      if (options.breadthFirst) {\n        const cells = [];\n        const queue = this.getChildren() || [];\n\n        while (queue.length > 0) {\n          const parent = queue.shift();\n          const children = parent.getChildren();\n          cells.push(parent);\n\n          if (children) {\n            queue.push(...children);\n          }\n        }\n\n        return cells;\n      } // depth first\n\n\n      {\n        const cells = this.getChildren() || [];\n        cells.forEach(cell => {\n          cells.push(...cell.getDescendants(options));\n        });\n        return cells;\n      }\n    }\n\n    return this.getChildren() || [];\n  }\n\n  isDescendantOf(ancestor) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (ancestor == null) {\n      return false;\n    }\n\n    if (options.deep !== false) {\n      let current = this.getParent();\n\n      while (current) {\n        if (current === ancestor) {\n          return true;\n        }\n\n        current = current.getParent();\n      }\n\n      return false;\n    }\n\n    return this.isChildOf(ancestor);\n  }\n\n  isAncestorOf(descendant) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (descendant == null) {\n      return false;\n    }\n\n    return descendant.isDescendantOf(this, options);\n  }\n\n  contains(cell) {\n    return this.isAncestorOf(cell);\n  }\n\n  getCommonAncestor() {\n    for (var _len = arguments.length, cells = new Array(_len), _key = 0; _key < _len; _key++) {\n      cells[_key] = arguments[_key];\n    }\n\n    return Cell.getCommonAncestor(this, ...cells);\n  }\n\n  setParent(parent) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._parent = parent;\n\n    if (parent) {\n      this.store.set('parent', parent.id, options);\n    } else {\n      this.store.remove('parent', options);\n    }\n\n    return this;\n  }\n\n  setChildren(children) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this._children = children;\n\n    if (children != null) {\n      this.store.set('children', children.map(child => child.id), options);\n    } else {\n      this.store.remove('children', options);\n    }\n\n    return this;\n  }\n\n  unembed(child) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const children = this.children;\n\n    if (children != null && child != null) {\n      const index = this.getChildIndex(child);\n\n      if (index !== -1) {\n        children.splice(index, 1);\n        child.setParent(null, options);\n        this.setChildren(children, options);\n      }\n    }\n\n    return this;\n  }\n\n  embed(child) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    child.addTo(this, options);\n    return this;\n  }\n\n  addTo(target) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (Cell.isCell(target)) {\n      target.addChild(this, options);\n    } else {\n      target.addCell(this, options);\n    }\n\n    return this;\n  }\n\n  insertTo(parent, index) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    parent.insertChild(this, index, options);\n    return this;\n  }\n\n  addChild(child) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return this.insertChild(child, undefined, options);\n  }\n\n  insertChild(child, index) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (child != null && child !== this) {\n      const oldParent = child.getParent();\n      const changed = this !== oldParent;\n      let pos = index;\n\n      if (pos == null) {\n        pos = this.getChildCount();\n\n        if (!changed) {\n          pos -= 1;\n        }\n      } // remove from old parent\n\n\n      if (oldParent) {\n        const children = oldParent.getChildren();\n\n        if (children) {\n          const index = children.indexOf(child);\n\n          if (index >= 0) {\n            child.setParent(null, options);\n            children.splice(index, 1);\n            oldParent.setChildren(children, options);\n          }\n        }\n      }\n\n      let children = this.children;\n\n      if (children == null) {\n        children = [];\n        children.push(child);\n      } else {\n        children.splice(pos, 0, child);\n      }\n\n      child.setParent(this, options);\n      this.setChildren(children, options);\n\n      if (changed && this.model) {\n        const incomings = this.model.getIncomingEdges(this);\n        const outgoings = this.model.getOutgoingEdges(this);\n\n        if (incomings) {\n          incomings.forEach(edge => edge.updateParent(options));\n        }\n\n        if (outgoings) {\n          outgoings.forEach(edge => edge.updateParent(options));\n        }\n      }\n\n      if (this.model) {\n        this.model.addCell(child, options);\n      }\n    }\n\n    return this;\n  }\n\n  removeFromParent() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const parent = this.getParent();\n\n    if (parent != null) {\n      const index = parent.getChildIndex(this);\n      parent.removeChildAt(index, options);\n    }\n\n    return this;\n  }\n\n  removeChild(child) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.getChildIndex(child);\n    return this.removeChildAt(index, options);\n  }\n\n  removeChildAt(index) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const child = this.getChildAt(index);\n    const children = this.children;\n\n    if (children != null && child != null) {\n      this.unembed(child, options);\n      child.remove(options);\n    }\n\n    return child;\n  }\n\n  remove() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.batchUpdate('remove', () => {\n      const parent = this.getParent();\n\n      if (parent) {\n        parent.removeChild(this, options);\n      }\n\n      if (options.deep !== false) {\n        this.eachChild(child => child.remove(options));\n      }\n\n      if (this.model) {\n        this.model.removeCell(this, options);\n      }\n    });\n    return this;\n  }\n\n  transition(path, target) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    let delim = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : '/';\n    return this.animation.start(path, target, options, delim);\n  }\n\n  stopTransition(path, options) {\n    let delim = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : '/';\n    this.animation.stop(path, options, delim);\n    return this;\n  }\n\n  getTransitions() {\n    return this.animation.get();\n  } // #endregion\n  // #region transform\n  // eslint-disable-next-line\n\n\n  translate(tx, ty, options) {\n    return this;\n  }\n\n  scale(sx, // eslint-disable-line\n  sy, // eslint-disable-line\n  origin, // eslint-disable-line\n  options) {\n    return this;\n  }\n\n  addTools(items, obj, options) {\n    const toolItems = Array.isArray(items) ? items : [items];\n    const name = typeof obj === 'string' ? obj : null;\n    const config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};\n\n    if (config.reset) {\n      return this.setTools({\n        name,\n        items: toolItems,\n        local: config.local\n      }, config);\n    }\n\n    let tools = ObjectExt.cloneDeep(this.getTools());\n\n    if (tools == null || name == null || tools.name === name) {\n      if (tools == null) {\n        tools = {};\n      }\n\n      if (!tools.items) {\n        tools.items = [];\n      }\n\n      tools.name = name;\n      tools.items = [...tools.items, ...toolItems];\n      return this.setTools(Object.assign({}, tools), config);\n    }\n  }\n\n  setTools(tools) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (tools == null) {\n      this.removeTools();\n    } else {\n      this.store.set('tools', Cell.normalizeTools(tools), options);\n    }\n\n    return this;\n  }\n\n  getTools() {\n    return this.store.get('tools');\n  }\n\n  removeTools() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.store.remove('tools', options);\n    return this;\n  }\n\n  hasTools(name) {\n    const tools = this.getTools();\n\n    if (tools == null) {\n      return false;\n    }\n\n    if (name == null) {\n      return true;\n    }\n\n    return tools.name === name;\n  }\n\n  hasTool(name) {\n    const tools = this.getTools();\n\n    if (tools == null) {\n      return false;\n    }\n\n    return tools.items.some(item => typeof item === 'string' ? item === name : item.name === name);\n  }\n\n  removeTool(nameOrIndex) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const tools = ObjectExt.cloneDeep(this.getTools());\n\n    if (tools) {\n      let updated = false;\n      const items = tools.items.slice();\n\n      const remove = index => {\n        items.splice(index, 1);\n        updated = true;\n      };\n\n      if (typeof nameOrIndex === 'number') {\n        remove(nameOrIndex);\n      } else {\n        for (let i = items.length - 1; i >= 0; i -= 1) {\n          const item = items[i];\n          const exist = typeof item === 'string' ? item === nameOrIndex : item.name === nameOrIndex;\n\n          if (exist) {\n            remove(i);\n          }\n        }\n      }\n\n      if (updated) {\n        tools.items = items;\n        this.setTools(tools, options);\n      }\n    }\n\n    return this;\n  } // #endregion\n  // #region common\n  // eslint-disable-next-line\n\n\n  getBBox(options) {\n    return new Rectangle();\n  } // eslint-disable-next-line\n\n\n  getConnectionPoint(edge, type) {\n    return new Point();\n  }\n\n  toJSON() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const props = Object.assign({}, this.store.get());\n    const toString = Object.prototype.toString;\n    const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';\n\n    if (!props.shape) {\n      const ctor = this.constructor;\n      throw new Error(`Unable to serialize ${cellType} missing \"shape\" prop, check the ${cellType} \"${ctor.name || toString.call(ctor)}\"`);\n    }\n\n    const ctor = this.constructor;\n    const diff = options.diff === true;\n    const attrs = props.attrs || {};\n    const presets = ctor.getDefaults(true); // When `options.diff` is `true`, we should process the custom options,\n    // such as `width`, `height` etc. to ensure the comparing work correctly.\n\n    const defaults = diff ? this.preprocess(presets, true) : presets;\n    const defaultAttrs = defaults.attrs || {};\n    const finalAttrs = {};\n    Object.keys(props).forEach(key => {\n      const val = props[key];\n\n      if (val != null && !Array.isArray(val) && typeof val === 'object' && !ObjectExt.isPlainObject(val)) {\n        throw new Error(`Can only serialize ${cellType} with plain-object props, but got a \"${toString.call(val)}\" type of key \"${key}\" on ${cellType} \"${this.id}\"`);\n      }\n\n      if (key !== 'attrs' && key !== 'shape' && diff) {\n        const preset = defaults[key];\n\n        if (ObjectExt.isEqual(val, preset)) {\n          delete props[key];\n        }\n      }\n    });\n    Object.keys(attrs).forEach(key => {\n      const attr = attrs[key];\n      const defaultAttr = defaultAttrs[key];\n      Object.keys(attr).forEach(name => {\n        const value = attr[name];\n        const defaultValue = defaultAttr ? defaultAttr[name] : null;\n\n        if (value != null && typeof value === 'object' && !Array.isArray(value)) {\n          Object.keys(value).forEach(subName => {\n            const subValue = value[subName];\n\n            if (defaultAttr == null || defaultValue == null || !ObjectExt.isObject(defaultValue) || !ObjectExt.isEqual(defaultValue[subName], subValue)) {\n              if (finalAttrs[key] == null) {\n                finalAttrs[key] = {};\n              }\n\n              if (finalAttrs[key][name] == null) {\n                finalAttrs[key][name] = {};\n              }\n\n              const tmp = finalAttrs[key][name];\n              tmp[subName] = subValue;\n            }\n          });\n        } else if (defaultAttr == null || !ObjectExt.isEqual(defaultValue, value)) {\n          // `value` is not an object, default attribute with `key` does not\n          // exist or it is different than the attribute value set on the cell.\n          if (finalAttrs[key] == null) {\n            finalAttrs[key] = {};\n          }\n\n          finalAttrs[key][name] = value;\n        }\n      });\n    });\n    const finalProps = Object.assign(Object.assign({}, props), {\n      attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs\n    });\n\n    if (finalProps.attrs == null) {\n      delete finalProps.attrs;\n    }\n\n    const ret = finalProps;\n\n    if (ret.angle === 0) {\n      delete ret.angle;\n    }\n\n    return ObjectExt.cloneDeep(ret);\n  }\n\n  clone() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (!options.deep) {\n      const data = Object.assign({}, this.store.get());\n\n      if (!options.keepId) {\n        delete data.id;\n      }\n\n      delete data.parent;\n      delete data.children;\n      const ctor = this.constructor;\n      return new ctor(data); // eslint-disable-line new-cap\n    } // Deep cloning. Clone the cell itself and all its children.\n\n\n    const map = Cell.deepClone(this);\n    return map[this.id];\n  }\n\n  findView(graph) {\n    return graph.renderer.findViewByCell(this);\n  } // #endregion\n  // #region batch\n\n\n  startBatch(name) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.model;\n    this.notify('batch:start', {\n      name,\n      data,\n      cell: this\n    });\n\n    if (model) {\n      model.startBatch(name, Object.assign(Object.assign({}, data), {\n        cell: this\n      }));\n    }\n\n    return this;\n  }\n\n  stopBatch(name) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let model = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this.model;\n\n    if (model) {\n      model.stopBatch(name, Object.assign(Object.assign({}, data), {\n        cell: this\n      }));\n    }\n\n    this.notify('batch:stop', {\n      name,\n      data,\n      cell: this\n    });\n    return this;\n  }\n\n  batchUpdate(name, execute, data) {\n    // The model is null after cell was removed(remove batch).\n    // So we should temp save model to trigger pairing batch event.\n    const model = this.model;\n    this.startBatch(name, data, model);\n    const result = execute();\n    this.stopBatch(name, data, model);\n    return result;\n  } // #endregion\n  // #region IDisposable\n\n\n  dispose() {\n    this.removeFromParent();\n    this.store.dispose();\n  }\n\n}\nCell.defaults = {};\nCell.attrHooks = {};\nCell.propHooks = [];\n\n__decorate([Basecoat.dispose()], Cell.prototype, \"dispose\", null);\n\n(function (Cell) {\n  function normalizeTools(raw) {\n    if (typeof raw === 'string') {\n      return {\n        items: [raw]\n      };\n    }\n\n    if (Array.isArray(raw)) {\n      return {\n        items: raw\n      };\n    }\n\n    if (raw.items) {\n      return raw;\n    }\n\n    return {\n      items: [raw]\n    };\n  }\n\n  Cell.normalizeTools = normalizeTools;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  Cell.toStringTag = `X6.${Cell.name}`;\n\n  function isCell(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Cell) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const cell = instance;\n\n    if ((tag == null || tag === Cell.toStringTag) && typeof cell.isNode === 'function' && typeof cell.isEdge === 'function' && typeof cell.prop === 'function' && typeof cell.attr === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Cell.isCell = isCell;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  function getCommonAncestor() {\n    for (var _len2 = arguments.length, cells = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      cells[_key2] = arguments[_key2];\n    }\n\n    const ancestors = cells.filter(cell => cell != null).map(cell => cell.getAncestors()).sort((a, b) => {\n      return a.length - b.length;\n    });\n    const first = ancestors.shift();\n    return first.find(cell => ancestors.every(item => item.includes(cell))) || null;\n  }\n\n  Cell.getCommonAncestor = getCommonAncestor;\n\n  function getCellsBBox(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    let bbox = null;\n\n    for (let i = 0, ii = cells.length; i < ii; i += 1) {\n      const cell = cells[i];\n      let rect = cell.getBBox(options);\n\n      if (rect) {\n        if (cell.isNode()) {\n          const angle = cell.getAngle();\n\n          if (angle != null && angle !== 0) {\n            rect = rect.bbox(angle);\n          }\n        }\n\n        bbox = bbox == null ? rect : bbox.union(rect);\n      }\n    }\n\n    return bbox;\n  }\n\n  Cell.getCellsBBox = getCellsBBox;\n\n  function deepClone(cell) {\n    const cells = [cell, ...cell.getDescendants({\n      deep: true\n    })];\n    return Cell.cloneCells(cells);\n  }\n\n  Cell.deepClone = deepClone;\n\n  function cloneCells(cells) {\n    const inputs = ArrayExt.uniq(cells);\n    const cloneMap = inputs.reduce((map, cell) => {\n      map[cell.id] = cell.clone();\n      return map;\n    }, {});\n    inputs.forEach(cell => {\n      const clone = cloneMap[cell.id];\n\n      if (clone.isEdge()) {\n        const sourceId = clone.getSourceCellId();\n        const targetId = clone.getTargetCellId();\n\n        if (sourceId && cloneMap[sourceId]) {\n          // Source is a node and the node is among the clones.\n          // Then update the source of the cloned edge.\n          clone.setSource(Object.assign(Object.assign({}, clone.getSource()), {\n            cell: cloneMap[sourceId].id\n          }));\n        }\n\n        if (targetId && cloneMap[targetId]) {\n          // Target is a node and the node is among the clones.\n          // Then update the target of the cloned edge.\n          clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), {\n            cell: cloneMap[targetId].id\n          }));\n        }\n      } // Find the parent of the original cell\n\n\n      const parent = cell.getParent();\n\n      if (parent && cloneMap[parent.id]) {\n        clone.setParent(cloneMap[parent.id]);\n      } // Find the children of the original cell\n\n\n      const children = cell.getChildren();\n\n      if (children && children.length) {\n        const embeds = children.reduce((memo, child) => {\n          // Embedded cells that are not being cloned can not be carried\n          // over with other embedded cells.\n          if (cloneMap[child.id]) {\n            memo.push(cloneMap[child.id]);\n          }\n\n          return memo;\n        }, []);\n\n        if (embeds.length > 0) {\n          clone.setChildren(embeds);\n        }\n      }\n    });\n    return cloneMap;\n  }\n\n  Cell.cloneCells = cloneCells;\n})(Cell || (Cell = {}));\n\n(function (Cell) {\n  Cell.config({\n    propHooks(_a) {\n      var {\n        tools\n      } = _a,\n          metadata = __rest(_a, [\"tools\"]);\n\n      if (tools) {\n        metadata.tools = Cell.normalizeTools(tools);\n      }\n\n      return metadata;\n    }\n\n  });\n})(Cell || (Cell = {}));","map":{"version":3,"sources":["../../src/model/cell.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/* eslint-disable no-underscore-dangle */\nvar __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ArrayExt, StringExt, ObjectExt, FunctionExt } from '../util';\nimport { Rectangle, Point } from '../geometry';\nimport { Basecoat } from '../common';\nimport { Attr } from '../registry';\nimport { Animation } from './animation';\nimport { Store } from './store';\nexport class Cell extends Basecoat {\n    constructor(metadata = {}) {\n        super();\n        const ctor = this.constructor;\n        const defaults = ctor.getDefaults(true);\n        const props = ObjectExt.merge({}, this.preprocess(defaults), this.preprocess(metadata));\n        this.id = props.id || StringExt.uuid();\n        this.store = new Store(props);\n        this.animation = new Animation(this);\n        this.setup();\n        this.init();\n        this.postprocess(metadata);\n    }\n    static config(presets) {\n        const { markup, propHooks, attrHooks } = presets, others = __rest(presets, [\"markup\", \"propHooks\", \"attrHooks\"]);\n        if (markup != null) {\n            this.markup = markup;\n        }\n        if (propHooks) {\n            this.propHooks = this.propHooks.slice();\n            if (Array.isArray(propHooks)) {\n                this.propHooks.push(...propHooks);\n            }\n            else if (typeof propHooks === 'function') {\n                this.propHooks.push(propHooks);\n            }\n            else {\n                Object.keys(propHooks).forEach((name) => {\n                    const hook = propHooks[name];\n                    if (typeof hook === 'function') {\n                        this.propHooks.push(hook);\n                    }\n                });\n            }\n        }\n        if (attrHooks) {\n            this.attrHooks = Object.assign(Object.assign({}, this.attrHooks), attrHooks);\n        }\n        this.defaults = ObjectExt.merge({}, this.defaults, others);\n    }\n    static getMarkup() {\n        return this.markup;\n    }\n    static getDefaults(raw) {\n        return (raw ? this.defaults : ObjectExt.cloneDeep(this.defaults));\n    }\n    static getAttrHooks() {\n        return this.attrHooks;\n    }\n    static applyPropHooks(cell, metadata) {\n        return this.propHooks.reduce((memo, hook) => {\n            return hook ? FunctionExt.call(hook, cell, memo) : memo;\n        }, metadata);\n    }\n    // #endregion\n    get [Symbol.toStringTag]() {\n        return Cell.toStringTag;\n    }\n    init() { }\n    // #region model\n    get model() {\n        return this._model;\n    }\n    set model(model) {\n        if (this._model !== model) {\n            this._model = model;\n        }\n    }\n    // #endregion\n    preprocess(metadata, ignoreIdCheck) {\n        const id = metadata.id;\n        const ctor = this.constructor;\n        const props = ctor.applyPropHooks(this, metadata);\n        if (id == null && ignoreIdCheck !== true) {\n            props.id = StringExt.uuid();\n        }\n        return props;\n    }\n    postprocess(metadata) { } // eslint-disable-line\n    setup() {\n        this.store.on('change:*', (metadata) => {\n            const { key, current, previous, options } = metadata;\n            this.notify('change:*', {\n                key,\n                options,\n                current,\n                previous,\n                cell: this,\n            });\n            this.notify(`change:${key}`, {\n                options,\n                current,\n                previous,\n                cell: this,\n            });\n            const type = key;\n            if (type === 'source' || type === 'target') {\n                this.notify(`change:terminal`, {\n                    type,\n                    current,\n                    previous,\n                    options,\n                    cell: this,\n                });\n            }\n        });\n        this.store.on('changed', ({ options }) => this.notify('changed', { options, cell: this }));\n    }\n    notify(name, args) {\n        this.trigger(name, args);\n        const model = this.model;\n        if (model) {\n            model.notify(`cell:${name}`, args);\n            if (this.isNode()) {\n                model.notify(`node:${name}`, Object.assign(Object.assign({}, args), { node: this }));\n            }\n            else if (this.isEdge()) {\n                model.notify(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: this }));\n            }\n        }\n        return this;\n    }\n    isNode() {\n        return false;\n    }\n    isEdge() {\n        return false;\n    }\n    isSameStore(cell) {\n        return this.store === cell.store;\n    }\n    get view() {\n        return this.store.get('view');\n    }\n    get shape() {\n        return this.store.get('shape', '');\n    }\n    getProp(key, defaultValue) {\n        if (key == null) {\n            return this.store.get();\n        }\n        return this.store.get(key, defaultValue);\n    }\n    setProp(key, value, options) {\n        if (typeof key === 'string') {\n            this.store.set(key, value, options);\n        }\n        else {\n            const props = this.preprocess(key, true);\n            this.store.set(ObjectExt.merge({}, this.getProp(), props), value);\n            this.postprocess(key);\n        }\n        return this;\n    }\n    removeProp(key, options) {\n        if (typeof key === 'string' || Array.isArray(key)) {\n            this.store.removeByPath(key, options);\n        }\n        else {\n            this.store.remove(options);\n        }\n        return this;\n    }\n    hasChanged(key) {\n        return key == null ? this.store.hasChanged() : this.store.hasChanged(key);\n    }\n    getPropByPath(path) {\n        return this.store.getByPath(path);\n    }\n    setPropByPath(path, value, options = {}) {\n        if (this.model) {\n            // update inner reference\n            if (path === 'children') {\n                this._children = value\n                    ? value\n                        .map((id) => this.model.getCell(id))\n                        .filter((child) => child != null)\n                    : null;\n            }\n            else if (path === 'parent') {\n                this._parent = value ? this.model.getCell(value) : null;\n            }\n        }\n        this.store.setByPath(path, value, options);\n        return this;\n    }\n    removePropByPath(path, options = {}) {\n        const paths = Array.isArray(path) ? path : path.split('/');\n        // Once a property is removed from the `attrs` the CellView will\n        // recognize a `dirty` flag and re-render itself in order to remove\n        // the attribute from SVGElement.\n        if (paths[0] === 'attrs') {\n            options.dirty = true;\n        }\n        this.store.removeByPath(paths, options);\n        return this;\n    }\n    prop(key, value, options) {\n        if (key == null) {\n            return this.getProp();\n        }\n        if (typeof key === 'string' || Array.isArray(key)) {\n            if (arguments.length === 1) {\n                return this.getPropByPath(key);\n            }\n            if (value == null) {\n                return this.removePropByPath(key, options || {});\n            }\n            return this.setPropByPath(key, value, options || {});\n        }\n        return this.setProp(key, value || {});\n    }\n    previous(name) {\n        return this.store.getPrevious(name);\n    }\n    // #endregion\n    // #region zIndex\n    get zIndex() {\n        return this.getZIndex();\n    }\n    set zIndex(z) {\n        if (z == null) {\n            this.removeZIndex();\n        }\n        else {\n            this.setZIndex(z);\n        }\n    }\n    getZIndex() {\n        return this.store.get('zIndex');\n    }\n    setZIndex(z, options = {}) {\n        this.store.set('zIndex', z, options);\n        return this;\n    }\n    removeZIndex(options = {}) {\n        this.store.remove('zIndex', options);\n        return this;\n    }\n    toFront(options = {}) {\n        const model = this.model;\n        if (model) {\n            let z = model.getMaxZIndex();\n            let cells;\n            if (options.deep) {\n                cells = this.getDescendants({ deep: true, breadthFirst: true });\n                cells.unshift(this);\n            }\n            else {\n                cells = [this];\n            }\n            z = z - cells.length + 1;\n            const count = model.total();\n            let changed = model.indexOf(this) !== count - cells.length;\n            if (!changed) {\n                changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n            }\n            if (changed) {\n                this.batchUpdate('to-front', () => {\n                    z += cells.length;\n                    cells.forEach((cell, index) => {\n                        cell.setZIndex(z + index, options);\n                    });\n                });\n            }\n        }\n        return this;\n    }\n    toBack(options = {}) {\n        const model = this.model;\n        if (model) {\n            let z = model.getMinZIndex();\n            let cells;\n            if (options.deep) {\n                cells = this.getDescendants({ deep: true, breadthFirst: true });\n                cells.unshift(this);\n            }\n            else {\n                cells = [this];\n            }\n            let changed = model.indexOf(this) !== 0;\n            if (!changed) {\n                changed = cells.some((cell, index) => cell.getZIndex() !== z + index);\n            }\n            if (changed) {\n                this.batchUpdate('to-back', () => {\n                    z -= cells.length;\n                    cells.forEach((cell, index) => {\n                        cell.setZIndex(z + index, options);\n                    });\n                });\n            }\n        }\n        return this;\n    }\n    // #endregion\n    // #region markup\n    get markup() {\n        return this.getMarkup();\n    }\n    set markup(value) {\n        if (value == null) {\n            this.removeMarkup();\n        }\n        else {\n            this.setMarkup(value);\n        }\n    }\n    getMarkup() {\n        let markup = this.store.get('markup');\n        if (markup == null) {\n            const ctor = this.constructor;\n            markup = ctor.getMarkup();\n        }\n        return markup;\n    }\n    setMarkup(markup, options = {}) {\n        this.store.set('markup', markup, options);\n        return this;\n    }\n    removeMarkup(options = {}) {\n        this.store.remove('markup', options);\n        return this;\n    }\n    // #endregion\n    // #region attrs\n    get attrs() {\n        return this.getAttrs();\n    }\n    set attrs(value) {\n        if (value == null) {\n            this.removeAttrs();\n        }\n        else {\n            this.setAttrs(value);\n        }\n    }\n    getAttrs() {\n        const result = this.store.get('attrs');\n        return result ? Object.assign({}, result) : {};\n    }\n    setAttrs(attrs, options = {}) {\n        if (attrs == null) {\n            this.removeAttrs(options);\n        }\n        else {\n            const set = (attrs) => this.store.set('attrs', attrs, options);\n            if (options.overwrite === true) {\n                set(attrs);\n            }\n            else {\n                const prev = this.getAttrs();\n                if (options.deep === false) {\n                    set(Object.assign(Object.assign({}, prev), attrs));\n                }\n                else {\n                    set(ObjectExt.merge({}, prev, attrs));\n                }\n            }\n        }\n        return this;\n    }\n    replaceAttrs(attrs, options = {}) {\n        return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { overwrite: true }));\n    }\n    updateAttrs(attrs, options = {}) {\n        return this.setAttrs(attrs, Object.assign(Object.assign({}, options), { deep: false }));\n    }\n    removeAttrs(options = {}) {\n        this.store.remove('attrs', options);\n        return this;\n    }\n    getAttrDefinition(attrName) {\n        if (!attrName) {\n            return null;\n        }\n        const ctor = this.constructor;\n        const hooks = ctor.getAttrHooks() || {};\n        let definition = hooks[attrName] || Attr.registry.get(attrName);\n        if (!definition) {\n            const name = StringExt.camelCase(attrName);\n            definition = hooks[name] || Attr.registry.get(name);\n        }\n        return definition || null;\n    }\n    getAttrByPath(path) {\n        if (path == null || path === '') {\n            return this.getAttrs();\n        }\n        return this.getPropByPath(this.prefixAttrPath(path));\n    }\n    setAttrByPath(path, value, options = {}) {\n        this.setPropByPath(this.prefixAttrPath(path), value, options);\n        return this;\n    }\n    removeAttrByPath(path, options = {}) {\n        this.removePropByPath(this.prefixAttrPath(path), options);\n        return this;\n    }\n    prefixAttrPath(path) {\n        return Array.isArray(path) ? ['attrs'].concat(path) : `attrs/${path}`;\n    }\n    attr(path, value, options) {\n        if (path == null) {\n            return this.getAttrByPath();\n        }\n        if (typeof path === 'string' || Array.isArray(path)) {\n            if (arguments.length === 1) {\n                return this.getAttrByPath(path);\n            }\n            if (value == null) {\n                return this.removeAttrByPath(path, options || {});\n            }\n            return this.setAttrByPath(path, value, options || {});\n        }\n        return this.setAttrs(path, (value || {}));\n    }\n    // #endregion\n    // #region visible\n    get visible() {\n        return this.isVisible();\n    }\n    set visible(value) {\n        this.setVisible(value);\n    }\n    setVisible(visible, options = {}) {\n        this.store.set('visible', visible, options);\n        return this;\n    }\n    isVisible() {\n        return this.store.get('visible') !== false;\n    }\n    show(options = {}) {\n        if (!this.isVisible()) {\n            this.setVisible(true, options);\n        }\n        return this;\n    }\n    hide(options = {}) {\n        if (this.isVisible()) {\n            this.setVisible(false, options);\n        }\n        return this;\n    }\n    toggleVisible(isVisible, options = {}) {\n        const visible = typeof isVisible === 'boolean' ? isVisible : !this.isVisible();\n        const localOptions = typeof isVisible === 'boolean' ? options : isVisible;\n        if (visible) {\n            this.show(localOptions);\n        }\n        else {\n            this.hide(localOptions);\n        }\n        return this;\n    }\n    // #endregion\n    // #region data\n    get data() {\n        return this.getData();\n    }\n    set data(val) {\n        this.setData(val);\n    }\n    getData() {\n        return this.store.get('data');\n    }\n    setData(data, options = {}) {\n        if (data == null) {\n            this.removeData(options);\n        }\n        else {\n            const set = (data) => this.store.set('data', data, options);\n            if (options.overwrite === true) {\n                set(data);\n            }\n            else {\n                const prev = this.getData();\n                if (options.deep === false) {\n                    set(typeof data === 'object' ? Object.assign(Object.assign({}, prev), data) : data);\n                }\n                else {\n                    set(ObjectExt.merge({}, prev, data));\n                }\n            }\n        }\n        return this;\n    }\n    replaceData(data, options = {}) {\n        return this.setData(data, Object.assign(Object.assign({}, options), { overwrite: true }));\n    }\n    updateData(data, options = {}) {\n        return this.setData(data, Object.assign(Object.assign({}, options), { deep: false }));\n    }\n    removeData(options = {}) {\n        this.store.remove('data', options);\n        return this;\n    }\n    // #endregion\n    // #region parent children\n    get parent() {\n        return this.getParent();\n    }\n    get children() {\n        return this.getChildren();\n    }\n    getParentId() {\n        return this.store.get('parent');\n    }\n    getParent() {\n        let parent = this._parent;\n        if (parent == null && this.store) {\n            const parentId = this.getParentId();\n            if (parentId != null && this.model) {\n                parent = this.model.getCell(parentId);\n                this._parent = parent;\n            }\n        }\n        return parent;\n    }\n    getChildren() {\n        let children = this._children;\n        if (children == null) {\n            const childrenIds = this.store.get('children');\n            if (childrenIds && childrenIds.length && this.model) {\n                children = childrenIds\n                    .map((id) => { var _a; return (_a = this.model) === null || _a === void 0 ? void 0 : _a.getCell(id); })\n                    .filter((cell) => cell != null);\n                this._children = children;\n            }\n        }\n        return children ? [...children] : null;\n    }\n    hasParent() {\n        return this.parent != null;\n    }\n    isParentOf(child) {\n        return child != null && child.getParent() === this;\n    }\n    isChildOf(parent) {\n        return parent != null && this.getParent() === parent;\n    }\n    eachChild(iterator, context) {\n        if (this.children) {\n            this.children.forEach(iterator, context);\n        }\n        return this;\n    }\n    filterChild(filter, context) {\n        return this.children ? this.children.filter(filter, context) : [];\n    }\n    getChildCount() {\n        return this.children == null ? 0 : this.children.length;\n    }\n    getChildIndex(child) {\n        return this.children == null ? -1 : this.children.indexOf(child);\n    }\n    getChildAt(index) {\n        return this.children != null && index >= 0 ? this.children[index] : null;\n    }\n    getAncestors(options = {}) {\n        const ancestors = [];\n        let parent = this.getParent();\n        while (parent) {\n            ancestors.push(parent);\n            parent = options.deep !== false ? parent.getParent() : null;\n        }\n        return ancestors;\n    }\n    getDescendants(options = {}) {\n        if (options.deep !== false) {\n            // breadth first\n            if (options.breadthFirst) {\n                const cells = [];\n                const queue = this.getChildren() || [];\n                while (queue.length > 0) {\n                    const parent = queue.shift();\n                    const children = parent.getChildren();\n                    cells.push(parent);\n                    if (children) {\n                        queue.push(...children);\n                    }\n                }\n                return cells;\n            }\n            // depth first\n            {\n                const cells = this.getChildren() || [];\n                cells.forEach((cell) => {\n                    cells.push(...cell.getDescendants(options));\n                });\n                return cells;\n            }\n        }\n        return this.getChildren() || [];\n    }\n    isDescendantOf(ancestor, options = {}) {\n        if (ancestor == null) {\n            return false;\n        }\n        if (options.deep !== false) {\n            let current = this.getParent();\n            while (current) {\n                if (current === ancestor) {\n                    return true;\n                }\n                current = current.getParent();\n            }\n            return false;\n        }\n        return this.isChildOf(ancestor);\n    }\n    isAncestorOf(descendant, options = {}) {\n        if (descendant == null) {\n            return false;\n        }\n        return descendant.isDescendantOf(this, options);\n    }\n    contains(cell) {\n        return this.isAncestorOf(cell);\n    }\n    getCommonAncestor(...cells) {\n        return Cell.getCommonAncestor(this, ...cells);\n    }\n    setParent(parent, options = {}) {\n        this._parent = parent;\n        if (parent) {\n            this.store.set('parent', parent.id, options);\n        }\n        else {\n            this.store.remove('parent', options);\n        }\n        return this;\n    }\n    setChildren(children, options = {}) {\n        this._children = children;\n        if (children != null) {\n            this.store.set('children', children.map((child) => child.id), options);\n        }\n        else {\n            this.store.remove('children', options);\n        }\n        return this;\n    }\n    unembed(child, options = {}) {\n        const children = this.children;\n        if (children != null && child != null) {\n            const index = this.getChildIndex(child);\n            if (index !== -1) {\n                children.splice(index, 1);\n                child.setParent(null, options);\n                this.setChildren(children, options);\n            }\n        }\n        return this;\n    }\n    embed(child, options = {}) {\n        child.addTo(this, options);\n        return this;\n    }\n    addTo(target, options = {}) {\n        if (Cell.isCell(target)) {\n            target.addChild(this, options);\n        }\n        else {\n            target.addCell(this, options);\n        }\n        return this;\n    }\n    insertTo(parent, index, options = {}) {\n        parent.insertChild(this, index, options);\n        return this;\n    }\n    addChild(child, options = {}) {\n        return this.insertChild(child, undefined, options);\n    }\n    insertChild(child, index, options = {}) {\n        if (child != null && child !== this) {\n            const oldParent = child.getParent();\n            const changed = this !== oldParent;\n            let pos = index;\n            if (pos == null) {\n                pos = this.getChildCount();\n                if (!changed) {\n                    pos -= 1;\n                }\n            }\n            // remove from old parent\n            if (oldParent) {\n                const children = oldParent.getChildren();\n                if (children) {\n                    const index = children.indexOf(child);\n                    if (index >= 0) {\n                        child.setParent(null, options);\n                        children.splice(index, 1);\n                        oldParent.setChildren(children, options);\n                    }\n                }\n            }\n            let children = this.children;\n            if (children == null) {\n                children = [];\n                children.push(child);\n            }\n            else {\n                children.splice(pos, 0, child);\n            }\n            child.setParent(this, options);\n            this.setChildren(children, options);\n            if (changed && this.model) {\n                const incomings = this.model.getIncomingEdges(this);\n                const outgoings = this.model.getOutgoingEdges(this);\n                if (incomings) {\n                    incomings.forEach((edge) => edge.updateParent(options));\n                }\n                if (outgoings) {\n                    outgoings.forEach((edge) => edge.updateParent(options));\n                }\n            }\n            if (this.model) {\n                this.model.addCell(child, options);\n            }\n        }\n        return this;\n    }\n    removeFromParent(options = {}) {\n        const parent = this.getParent();\n        if (parent != null) {\n            const index = parent.getChildIndex(this);\n            parent.removeChildAt(index, options);\n        }\n        return this;\n    }\n    removeChild(child, options = {}) {\n        const index = this.getChildIndex(child);\n        return this.removeChildAt(index, options);\n    }\n    removeChildAt(index, options = {}) {\n        const child = this.getChildAt(index);\n        const children = this.children;\n        if (children != null && child != null) {\n            this.unembed(child, options);\n            child.remove(options);\n        }\n        return child;\n    }\n    remove(options = {}) {\n        this.batchUpdate('remove', () => {\n            const parent = this.getParent();\n            if (parent) {\n                parent.removeChild(this, options);\n            }\n            if (options.deep !== false) {\n                this.eachChild((child) => child.remove(options));\n            }\n            if (this.model) {\n                this.model.removeCell(this, options);\n            }\n        });\n        return this;\n    }\n    transition(path, target, options = {}, delim = '/') {\n        return this.animation.start(path, target, options, delim);\n    }\n    stopTransition(path, options, delim = '/') {\n        this.animation.stop(path, options, delim);\n        return this;\n    }\n    getTransitions() {\n        return this.animation.get();\n    }\n    // #endregion\n    // #region transform\n    // eslint-disable-next-line\n    translate(tx, ty, options) {\n        return this;\n    }\n    scale(sx, // eslint-disable-line\n    sy, // eslint-disable-line\n    origin, // eslint-disable-line\n    options) {\n        return this;\n    }\n    addTools(items, obj, options) {\n        const toolItems = Array.isArray(items) ? items : [items];\n        const name = typeof obj === 'string' ? obj : null;\n        const config = typeof obj === 'object' ? obj : typeof options === 'object' ? options : {};\n        if (config.reset) {\n            return this.setTools({ name, items: toolItems, local: config.local }, config);\n        }\n        let tools = ObjectExt.cloneDeep(this.getTools());\n        if (tools == null || name == null || tools.name === name) {\n            if (tools == null) {\n                tools = {};\n            }\n            if (!tools.items) {\n                tools.items = [];\n            }\n            tools.name = name;\n            tools.items = [...tools.items, ...toolItems];\n            return this.setTools(Object.assign({}, tools), config);\n        }\n    }\n    setTools(tools, options = {}) {\n        if (tools == null) {\n            this.removeTools();\n        }\n        else {\n            this.store.set('tools', Cell.normalizeTools(tools), options);\n        }\n        return this;\n    }\n    getTools() {\n        return this.store.get('tools');\n    }\n    removeTools(options = {}) {\n        this.store.remove('tools', options);\n        return this;\n    }\n    hasTools(name) {\n        const tools = this.getTools();\n        if (tools == null) {\n            return false;\n        }\n        if (name == null) {\n            return true;\n        }\n        return tools.name === name;\n    }\n    hasTool(name) {\n        const tools = this.getTools();\n        if (tools == null) {\n            return false;\n        }\n        return tools.items.some((item) => typeof item === 'string' ? item === name : item.name === name);\n    }\n    removeTool(nameOrIndex, options = {}) {\n        const tools = ObjectExt.cloneDeep(this.getTools());\n        if (tools) {\n            let updated = false;\n            const items = tools.items.slice();\n            const remove = (index) => {\n                items.splice(index, 1);\n                updated = true;\n            };\n            if (typeof nameOrIndex === 'number') {\n                remove(nameOrIndex);\n            }\n            else {\n                for (let i = items.length - 1; i >= 0; i -= 1) {\n                    const item = items[i];\n                    const exist = typeof item === 'string'\n                        ? item === nameOrIndex\n                        : item.name === nameOrIndex;\n                    if (exist) {\n                        remove(i);\n                    }\n                }\n            }\n            if (updated) {\n                tools.items = items;\n                this.setTools(tools, options);\n            }\n        }\n        return this;\n    }\n    // #endregion\n    // #region common\n    // eslint-disable-next-line\n    getBBox(options) {\n        return new Rectangle();\n    }\n    // eslint-disable-next-line\n    getConnectionPoint(edge, type) {\n        return new Point();\n    }\n    toJSON(options = {}) {\n        const props = Object.assign({}, this.store.get());\n        const toString = Object.prototype.toString;\n        const cellType = this.isNode() ? 'node' : this.isEdge() ? 'edge' : 'cell';\n        if (!props.shape) {\n            const ctor = this.constructor;\n            throw new Error(`Unable to serialize ${cellType} missing \"shape\" prop, check the ${cellType} \"${ctor.name || toString.call(ctor)}\"`);\n        }\n        const ctor = this.constructor;\n        const diff = options.diff === true;\n        const attrs = props.attrs || {};\n        const presets = ctor.getDefaults(true);\n        // When `options.diff` is `true`, we should process the custom options,\n        // such as `width`, `height` etc. to ensure the comparing work correctly.\n        const defaults = diff ? this.preprocess(presets, true) : presets;\n        const defaultAttrs = defaults.attrs || {};\n        const finalAttrs = {};\n        Object.keys(props).forEach((key) => {\n            const val = props[key];\n            if (val != null &&\n                !Array.isArray(val) &&\n                typeof val === 'object' &&\n                !ObjectExt.isPlainObject(val)) {\n                throw new Error(`Can only serialize ${cellType} with plain-object props, but got a \"${toString.call(val)}\" type of key \"${key}\" on ${cellType} \"${this.id}\"`);\n            }\n            if (key !== 'attrs' && key !== 'shape' && diff) {\n                const preset = defaults[key];\n                if (ObjectExt.isEqual(val, preset)) {\n                    delete props[key];\n                }\n            }\n        });\n        Object.keys(attrs).forEach((key) => {\n            const attr = attrs[key];\n            const defaultAttr = defaultAttrs[key];\n            Object.keys(attr).forEach((name) => {\n                const value = attr[name];\n                const defaultValue = defaultAttr ? defaultAttr[name] : null;\n                if (value != null &&\n                    typeof value === 'object' &&\n                    !Array.isArray(value)) {\n                    Object.keys(value).forEach((subName) => {\n                        const subValue = value[subName];\n                        if (defaultAttr == null ||\n                            defaultValue == null ||\n                            !ObjectExt.isObject(defaultValue) ||\n                            !ObjectExt.isEqual(defaultValue[subName], subValue)) {\n                            if (finalAttrs[key] == null) {\n                                finalAttrs[key] = {};\n                            }\n                            if (finalAttrs[key][name] == null) {\n                                finalAttrs[key][name] = {};\n                            }\n                            const tmp = finalAttrs[key][name];\n                            tmp[subName] = subValue;\n                        }\n                    });\n                }\n                else if (defaultAttr == null ||\n                    !ObjectExt.isEqual(defaultValue, value)) {\n                    // `value` is not an object, default attribute with `key` does not\n                    // exist or it is different than the attribute value set on the cell.\n                    if (finalAttrs[key] == null) {\n                        finalAttrs[key] = {};\n                    }\n                    finalAttrs[key][name] = value;\n                }\n            });\n        });\n        const finalProps = Object.assign(Object.assign({}, props), { attrs: ObjectExt.isEmpty(finalAttrs) ? undefined : finalAttrs });\n        if (finalProps.attrs == null) {\n            delete finalProps.attrs;\n        }\n        const ret = finalProps;\n        if (ret.angle === 0) {\n            delete ret.angle;\n        }\n        return ObjectExt.cloneDeep(ret);\n    }\n    clone(options = {}) {\n        if (!options.deep) {\n            const data = Object.assign({}, this.store.get());\n            if (!options.keepId) {\n                delete data.id;\n            }\n            delete data.parent;\n            delete data.children;\n            const ctor = this.constructor;\n            return new ctor(data); // eslint-disable-line new-cap\n        }\n        // Deep cloning. Clone the cell itself and all its children.\n        const map = Cell.deepClone(this);\n        return map[this.id];\n    }\n    findView(graph) {\n        return graph.renderer.findViewByCell(this);\n    }\n    // #endregion\n    // #region batch\n    startBatch(name, data = {}, model = this.model) {\n        this.notify('batch:start', { name, data, cell: this });\n        if (model) {\n            model.startBatch(name, Object.assign(Object.assign({}, data), { cell: this }));\n        }\n        return this;\n    }\n    stopBatch(name, data = {}, model = this.model) {\n        if (model) {\n            model.stopBatch(name, Object.assign(Object.assign({}, data), { cell: this }));\n        }\n        this.notify('batch:stop', { name, data, cell: this });\n        return this;\n    }\n    batchUpdate(name, execute, data) {\n        // The model is null after cell was removed(remove batch).\n        // So we should temp save model to trigger pairing batch event.\n        const model = this.model;\n        this.startBatch(name, data, model);\n        const result = execute();\n        this.stopBatch(name, data, model);\n        return result;\n    }\n    // #endregion\n    // #region IDisposable\n    dispose() {\n        this.removeFromParent();\n        this.store.dispose();\n    }\n}\nCell.defaults = {};\nCell.attrHooks = {};\nCell.propHooks = [];\n__decorate([\n    Basecoat.dispose()\n], Cell.prototype, \"dispose\", null);\n(function (Cell) {\n    function normalizeTools(raw) {\n        if (typeof raw === 'string') {\n            return { items: [raw] };\n        }\n        if (Array.isArray(raw)) {\n            return { items: raw };\n        }\n        if (raw.items) {\n            return raw;\n        }\n        return {\n            items: [raw],\n        };\n    }\n    Cell.normalizeTools = normalizeTools;\n})(Cell || (Cell = {}));\n(function (Cell) {\n    Cell.toStringTag = `X6.${Cell.name}`;\n    function isCell(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Cell) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const cell = instance;\n        if ((tag == null || tag === Cell.toStringTag) &&\n            typeof cell.isNode === 'function' &&\n            typeof cell.isEdge === 'function' &&\n            typeof cell.prop === 'function' &&\n            typeof cell.attr === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Cell.isCell = isCell;\n})(Cell || (Cell = {}));\n(function (Cell) {\n    function getCommonAncestor(...cells) {\n        const ancestors = cells\n            .filter((cell) => cell != null)\n            .map((cell) => cell.getAncestors())\n            .sort((a, b) => {\n            return a.length - b.length;\n        });\n        const first = ancestors.shift();\n        return (first.find((cell) => ancestors.every((item) => item.includes(cell))) ||\n            null);\n    }\n    Cell.getCommonAncestor = getCommonAncestor;\n    function getCellsBBox(cells, options = {}) {\n        let bbox = null;\n        for (let i = 0, ii = cells.length; i < ii; i += 1) {\n            const cell = cells[i];\n            let rect = cell.getBBox(options);\n            if (rect) {\n                if (cell.isNode()) {\n                    const angle = cell.getAngle();\n                    if (angle != null && angle !== 0) {\n                        rect = rect.bbox(angle);\n                    }\n                }\n                bbox = bbox == null ? rect : bbox.union(rect);\n            }\n        }\n        return bbox;\n    }\n    Cell.getCellsBBox = getCellsBBox;\n    function deepClone(cell) {\n        const cells = [cell, ...cell.getDescendants({ deep: true })];\n        return Cell.cloneCells(cells);\n    }\n    Cell.deepClone = deepClone;\n    function cloneCells(cells) {\n        const inputs = ArrayExt.uniq(cells);\n        const cloneMap = inputs.reduce((map, cell) => {\n            map[cell.id] = cell.clone();\n            return map;\n        }, {});\n        inputs.forEach((cell) => {\n            const clone = cloneMap[cell.id];\n            if (clone.isEdge()) {\n                const sourceId = clone.getSourceCellId();\n                const targetId = clone.getTargetCellId();\n                if (sourceId && cloneMap[sourceId]) {\n                    // Source is a node and the node is among the clones.\n                    // Then update the source of the cloned edge.\n                    clone.setSource(Object.assign(Object.assign({}, clone.getSource()), { cell: cloneMap[sourceId].id }));\n                }\n                if (targetId && cloneMap[targetId]) {\n                    // Target is a node and the node is among the clones.\n                    // Then update the target of the cloned edge.\n                    clone.setTarget(Object.assign(Object.assign({}, clone.getTarget()), { cell: cloneMap[targetId].id }));\n                }\n            }\n            // Find the parent of the original cell\n            const parent = cell.getParent();\n            if (parent && cloneMap[parent.id]) {\n                clone.setParent(cloneMap[parent.id]);\n            }\n            // Find the children of the original cell\n            const children = cell.getChildren();\n            if (children && children.length) {\n                const embeds = children.reduce((memo, child) => {\n                    // Embedded cells that are not being cloned can not be carried\n                    // over with other embedded cells.\n                    if (cloneMap[child.id]) {\n                        memo.push(cloneMap[child.id]);\n                    }\n                    return memo;\n                }, []);\n                if (embeds.length > 0) {\n                    clone.setChildren(embeds);\n                }\n            }\n        });\n        return cloneMap;\n    }\n    Cell.cloneCells = cloneCells;\n})(Cell || (Cell = {}));\n(function (Cell) {\n    Cell.config({\n        propHooks(_a) {\n            var { tools } = _a, metadata = __rest(_a, [\"tools\"]);\n            if (tools) {\n                metadata.tools = Cell.normalizeTools(tools);\n            }\n            return metadata;\n        },\n    });\n})(Cell || (Cell = {}));\n//# sourceMappingURL=cell.js.map"]},"metadata":{},"sourceType":"module"}