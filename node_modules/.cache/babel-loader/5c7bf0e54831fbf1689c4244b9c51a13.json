{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Platform, NumberExt, ObjectExt, Dom, FunctionExt } from '../../util';\nimport { Point, Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Renderer } from '../../graph/renderer';\nimport { GraphView } from '../../graph/view';\nimport { BackgroundManager } from '../../graph/background';\nexport var Scroller = /*#__PURE__*/function (_View) {\n  _inherits(Scroller, _View);\n\n  var _super = _createSuper(Scroller);\n\n  function Scroller(options) {\n    var _this;\n\n    _classCallCheck(this, Scroller);\n\n    _this = _super.call(this);\n    _this.padding = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    _this.options = Util.getOptions(options);\n\n    var scale = _this.graph.transform.getScale();\n\n    _this.sx = scale.sx;\n    _this.sy = scale.sy;\n    var width = _this.options.width || _this.graph.options.width;\n    var height = _this.options.height || _this.graph.options.height;\n    _this.container = document.createElement('div');\n    _this.$container = _this.$(_this.container).addClass(_this.prefixClassName(Util.containerClass)).css({\n      width: width,\n      height: height\n    });\n\n    if (_this.options.pageVisible) {\n      _this.$container.addClass(_this.prefixClassName(Util.pagedClass));\n    }\n\n    if (_this.options.className) {\n      _this.$container.addClass(_this.options.className);\n    }\n\n    var graphContainer = _this.graph.container;\n\n    if (graphContainer.parentNode) {\n      _this.$container.insertBefore(graphContainer);\n    } // copy style\n\n\n    var style = graphContainer.getAttribute('style');\n\n    if (style) {\n      var obj = {};\n      var styles = style.split(';');\n      styles.forEach(function (item) {\n        var section = item.trim();\n\n        if (section) {\n          var pair = section.split(':');\n\n          if (pair.length) {\n            obj[pair[0].trim()] = pair[1] ? pair[1].trim() : '';\n          }\n        }\n      });\n      Object.keys(obj).forEach(function (key) {\n        if (key === 'width' || key === 'height') {\n          return;\n        }\n\n        graphContainer.style[key] = '';\n        _this.container.style[key] = obj[key];\n      });\n    }\n\n    _this.content = document.createElement('div');\n    _this.$content = _this.$(_this.content).addClass(_this.prefixClassName(Util.contentClass)).css({\n      width: _this.graph.options.width,\n      height: _this.graph.options.height\n    }); // custom background\n\n    _this.background = document.createElement('div');\n    _this.$background = _this.$(_this.background).addClass(_this.prefixClassName(Util.backgroundClass));\n\n    _this.$content.append(_this.background);\n\n    if (!_this.options.pageVisible) {\n      _this.$content.append(_this.graph.view.grid);\n    }\n\n    _this.$content.append(graphContainer);\n\n    _this.$content.appendTo(_this.container);\n\n    _this.startListening();\n\n    if (!_this.options.pageVisible) {\n      _this.graph.grid.update();\n    }\n\n    _this.backgroundManager = new Scroller.Background(_assertThisInitialized(_this));\n\n    if (!_this.options.autoResize) {\n      _this.update();\n    }\n\n    return _this;\n  }\n\n  _createClass(Scroller, [{\n    key: \"graph\",\n    get: function get() {\n      return this.options.graph;\n    }\n  }, {\n    key: \"model\",\n    get: function get() {\n      return this.graph.model;\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      var graph = this.graph;\n      var model = this.model;\n      graph.on('scale', this.onScale, this);\n      graph.on('resize', this.onResize, this);\n      graph.on('before:print', this.storeScrollPosition, this);\n      graph.on('before:export', this.storeScrollPosition, this);\n      graph.on('after:print', this.restoreScrollPosition, this);\n      graph.on('after:export', this.restoreScrollPosition, this);\n      graph.on('render:done', this.onRenderDone, this);\n      graph.on('unfreeze', this.onUpdate, this);\n      model.on('reseted', this.onUpdate, this);\n      model.on('cell:added', this.onUpdate, this);\n      model.on('cell:removed', this.onUpdate, this);\n      model.on('cell:changed', this.onUpdate, this);\n      model.on('batch:stop', this.onBatchStop, this);\n      this.delegateBackgroundEvents();\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      var graph = this.graph;\n      var model = this.model;\n      graph.off('scale', this.onScale, this);\n      graph.off('resize', this.onResize, this);\n      graph.off('beforeprint', this.storeScrollPosition, this);\n      graph.off('beforeexport', this.storeScrollPosition, this);\n      graph.off('afterprint', this.restoreScrollPosition, this);\n      graph.off('afterexport', this.restoreScrollPosition, this);\n      graph.off('render:done', this.onRenderDone, this);\n      graph.off('unfreeze', this.onUpdate, this);\n      model.off('reseted', this.onUpdate, this);\n      model.off('cell:added', this.onUpdate, this);\n      model.off('cell:removed', this.onUpdate, this);\n      model.off('cell:changed', this.onUpdate, this);\n      model.off('batch:stop', this.onBatchStop, this);\n      this.undelegateBackgroundEvents();\n    }\n  }, {\n    key: \"enableAutoResize\",\n    value: function enableAutoResize() {\n      this.options.autoResize = true;\n    }\n  }, {\n    key: \"disableAutoResize\",\n    value: function disableAutoResize() {\n      this.options.autoResize = false;\n    }\n  }, {\n    key: \"onUpdate\",\n    value: function onUpdate() {\n      if (this.graph.isAsync() || !this.options.autoResize) {\n        return;\n      }\n\n      this.update();\n    }\n  }, {\n    key: \"onBatchStop\",\n    value: function onBatchStop(args) {\n      if (this.graph.isAsync() || !this.options.autoResize) {\n        return;\n      }\n\n      if (Renderer.UPDATE_DELAYING_BATCHES.includes(args.name)) {\n        this.update();\n      }\n    }\n  }, {\n    key: \"delegateBackgroundEvents\",\n    value: function delegateBackgroundEvents(events) {\n      var _this2 = this;\n\n      var evts = events || GraphView.events;\n      this.delegatedHandlers = Object.keys(evts).reduce(function (memo, name) {\n        var handler = evts[name];\n\n        if (name.indexOf(' ') === -1) {\n          if (typeof handler === 'function') {\n            memo[name] = handler;\n          } else {\n            var method = _this2.graph.view[handler];\n\n            if (typeof method === 'function') {\n              method = method.bind(_this2.graph.view);\n              memo[name] = method;\n            }\n          }\n        }\n\n        return memo;\n      }, {});\n      this.onBackgroundEvent = this.onBackgroundEvent.bind(this);\n      Object.keys(this.delegatedHandlers).forEach(function (name) {\n        _this2.delegateEvent(name, {\n          guarded: false\n        }, _this2.onBackgroundEvent);\n      });\n    }\n  }, {\n    key: \"undelegateBackgroundEvents\",\n    value: function undelegateBackgroundEvents() {\n      var _this3 = this;\n\n      Object.keys(this.delegatedHandlers).forEach(function (name) {\n        _this3.undelegateEvent(name, _this3.onBackgroundEvent);\n      });\n    }\n  }, {\n    key: \"onBackgroundEvent\",\n    value: function onBackgroundEvent(e) {\n      var valid = false;\n      var target = e.target;\n\n      if (!this.options.pageVisible) {\n        var view = this.graph.view;\n        valid = view.background === target || view.grid === target;\n      } else if (this.options.background) {\n        valid = this.background === target;\n      } else {\n        valid = this.content === target;\n      }\n\n      if (valid) {\n        var handler = this.delegatedHandlers[e.type];\n\n        if (typeof handler === 'function') {\n          handler.apply(this.graph, arguments); // eslint-disable-line\n        }\n      }\n    }\n  }, {\n    key: \"onRenderDone\",\n    value: function onRenderDone(_ref) {\n      var stats = _ref.stats;\n\n      if (this.options.autoResize && stats.priority < 2) {\n        this.update();\n      }\n    }\n  }, {\n    key: \"onResize\",\n    value: function onResize() {\n      if (this.cachedCenterPoint) {\n        this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y);\n        this.updatePageBreak();\n      }\n    }\n  }, {\n    key: \"onScale\",\n    value: function onScale(_ref2) {\n      var sx = _ref2.sx,\n          sy = _ref2.sy,\n          ox = _ref2.ox,\n          oy = _ref2.oy;\n      this.updateScale(sx, sy);\n\n      if (ox || oy) {\n        this.centerPoint(ox, oy);\n        this.updatePageBreak();\n      }\n\n      var autoResizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n\n      if (typeof autoResizeOptions === 'function') {\n        this.update();\n      }\n    }\n  }, {\n    key: \"storeScrollPosition\",\n    value: function storeScrollPosition() {\n      this.cachedScrollLeft = this.container.scrollLeft;\n      this.cachedScrollTop = this.container.scrollTop;\n    }\n  }, {\n    key: \"restoreScrollPosition\",\n    value: function restoreScrollPosition() {\n      this.container.scrollLeft = this.cachedScrollLeft;\n      this.container.scrollTop = this.cachedScrollTop;\n      this.cachedScrollLeft = null;\n      this.cachedScrollTop = null;\n    }\n  }, {\n    key: \"storeClientSize\",\n    value: function storeClientSize() {\n      this.cachedClientSize = {\n        width: this.container.clientWidth,\n        height: this.container.clientHeight\n      };\n    }\n  }, {\n    key: \"restoreClientSize\",\n    value: function restoreClientSize() {\n      this.cachedClientSize = null;\n    }\n  }, {\n    key: \"beforeManipulation\",\n    value: function beforeManipulation() {\n      if (Platform.IS_IE || Platform.IS_EDGE) {\n        this.$container.css('visibility', 'hidden');\n      }\n    }\n  }, {\n    key: \"afterManipulation\",\n    value: function afterManipulation() {\n      if (Platform.IS_IE || Platform.IS_EDGE) {\n        this.$container.css('visibility', 'visible');\n      }\n    }\n  }, {\n    key: \"updatePageSize\",\n    value: function updatePageSize(width, height) {\n      if (width != null) {\n        this.options.pageWidth = width;\n      }\n\n      if (height != null) {\n        this.options.pageHeight = height;\n      }\n\n      this.updatePageBreak();\n    }\n  }, {\n    key: \"updatePageBreak\",\n    value: function updatePageBreak() {\n      if (this.pageBreak && this.pageBreak.parentNode) {\n        this.pageBreak.parentNode.removeChild(this.pageBreak);\n      }\n\n      this.pageBreak = null;\n\n      if (this.options.pageVisible && this.options.pageBreak) {\n        var graphWidth = this.graph.options.width;\n        var graphHeight = this.graph.options.height;\n        var pageWidth = this.options.pageWidth * this.sx;\n        var pageHeight = this.options.pageHeight * this.sy;\n\n        if (graphWidth > pageWidth || graphHeight > pageHeight) {\n          var hasPageBreak = false;\n          var container = document.createElement('div');\n\n          for (var i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {\n            this.$('<div/>').addClass(this.prefixClassName(\"graph-pagebreak-vertical\")).css({\n              left: i * pageWidth\n            }).appendTo(container);\n            hasPageBreak = true;\n          }\n\n          for (var _i = 1, _l = Math.floor(graphHeight / pageHeight); _i < _l; _i += 1) {\n            this.$('<div/>').addClass(this.prefixClassName(\"graph-pagebreak-horizontal\")).css({\n              top: _i * pageHeight\n            }).appendTo(container);\n            hasPageBreak = true;\n          }\n\n          if (hasPageBreak) {\n            Dom.addClass(container, this.prefixClassName('graph-pagebreak'));\n            this.$(this.graph.view.grid).after(container);\n            this.pageBreak = container;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      var size = this.getClientSize();\n      this.cachedCenterPoint = this.clientToLocalPoint(size.width / 2, size.height / 2);\n      var resizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n\n      if (typeof resizeOptions === 'function') {\n        resizeOptions = FunctionExt.call(resizeOptions, this, this);\n      }\n\n      var options = Object.assign({\n        gridWidth: this.options.pageWidth,\n        gridHeight: this.options.pageHeight,\n        allowNewOrigin: 'negative'\n      }, resizeOptions);\n      this.graph.fitToContent(this.getFitToContentOptions(options));\n    }\n  }, {\n    key: \"getFitToContentOptions\",\n    value: function getFitToContentOptions(options) {\n      var sx = this.sx;\n      var sy = this.sy;\n      options.gridWidth && (options.gridWidth *= sx);\n      options.gridHeight && (options.gridHeight *= sy);\n      options.minWidth && (options.minWidth *= sx);\n      options.minHeight && (options.minHeight *= sy);\n\n      if (typeof options.padding === 'object') {\n        options.padding = {\n          left: (options.padding.left || 0) * sx,\n          right: (options.padding.right || 0) * sx,\n          top: (options.padding.top || 0) * sy,\n          bottom: (options.padding.bottom || 0) * sy\n        };\n      } else if (typeof options.padding === 'number') {\n        options.padding *= sx;\n      }\n\n      if (!this.options.autoResize) {\n        options.contentArea = Rectangle.create();\n      }\n\n      return options;\n    }\n  }, {\n    key: \"updateScale\",\n    value: function updateScale(sx, sy) {\n      var options = this.graph.options;\n      var dx = sx / this.sx;\n      var dy = sy / this.sy;\n      this.sx = sx;\n      this.sy = sy;\n      this.graph.translate(options.x * dx, options.y * dy);\n      this.graph.resizeGraph(options.width * dx, options.height * dy);\n    }\n  }, {\n    key: \"scrollbarPosition\",\n    value: function scrollbarPosition(left, top, options) {\n      if (left == null && top == null) {\n        return {\n          left: this.container.scrollLeft,\n          top: this.container.scrollTop\n        };\n      }\n\n      var prop = {};\n\n      if (typeof left === 'number') {\n        prop.scrollLeft = left;\n      }\n\n      if (typeof top === 'number') {\n        prop.scrollTop = top;\n      }\n\n      if (options && options.animation) {\n        this.$container.animate(prop, options.animation);\n      } else {\n        this.$container.prop(prop);\n      }\n\n      return this;\n    }\n    /**\n     * Try to scroll to ensure that the position (x,y) on the graph (in local\n     * coordinates) is at the center of the viewport. If only one of the\n     * coordinates is specified, only scroll in the specified dimension and\n     * keep the other coordinate unchanged.\n     */\n\n  }, {\n    key: \"scrollToPoint\",\n    value: function scrollToPoint(x, y, options) {\n      var size = this.getClientSize();\n      var ctm = this.graph.matrix();\n      var prop = {};\n\n      if (typeof x === 'number') {\n        prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0);\n      }\n\n      if (typeof y === 'number') {\n        prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0);\n      }\n\n      if (options && options.animation) {\n        this.$container.animate(prop, options.animation);\n      } else {\n        this.$container.prop(prop);\n      }\n\n      return this;\n    }\n    /**\n     * Try to scroll to ensure that the center of graph content is at the\n     * center of the viewport.\n     */\n\n  }, {\n    key: \"scrollToContent\",\n    value: function scrollToContent(options) {\n      var sx = this.sx;\n      var sy = this.sy;\n      var center = this.graph.getContentArea().getCenter();\n      return this.scrollToPoint(center.x * sx, center.y * sy, options);\n    }\n    /**\n     * Try to scroll to ensure that the center of cell is at the center of\n     * the viewport.\n     */\n\n  }, {\n    key: \"scrollToCell\",\n    value: function scrollToCell(cell, options) {\n      var sx = this.sx;\n      var sy = this.sy;\n      var center = cell.getBBox().getCenter();\n      return this.scrollToPoint(center.x * sx, center.y * sy, options);\n    }\n    /**\n     * The center methods are more aggressive than the scroll methods. These\n     * methods position the graph so that a specific point on the graph lies\n     * at the center of the viewport, adding paddings around the paper if\n     * necessary (e.g. if the requested point lies in a corner of the paper).\n     * This means that the requested point will always move into the center\n     * of the viewport. (Use the scroll functions to avoid adding paddings\n     * and only scroll the viewport as far as the graph boundary.)\n     */\n\n    /**\n     * Position the center of graph to the center of the viewport.\n     */\n\n  }, {\n    key: \"center\",\n    value: function center(optons) {\n      return this.centerPoint(optons);\n    }\n  }, {\n    key: \"centerPoint\",\n    value: function centerPoint(x, y, options) {\n      var ctm = this.graph.matrix();\n      var sx = ctm.a;\n      var sy = ctm.d;\n      var tx = -ctm.e;\n      var ty = -ctm.f;\n      var tWidth = tx + this.graph.options.width;\n      var tHeight = ty + this.graph.options.height;\n      var localOptions;\n      this.storeClientSize(); // avoid multilple reflow\n\n      if (typeof x === 'number' || typeof y === 'number') {\n        localOptions = options;\n        var visibleCenter = this.getVisibleArea().getCenter();\n\n        if (typeof x === 'number') {\n          x *= sx; // eslint-disable-line\n        } else {\n          x = visibleCenter.x; // eslint-disable-line\n        }\n\n        if (typeof y === 'number') {\n          y *= sy; // eslint-disable-line\n        } else {\n          y = visibleCenter.y; // eslint-disable-line\n        }\n      } else {\n        localOptions = x;\n        x = (tx + tWidth) / 2; // eslint-disable-line\n\n        y = (ty + tHeight) / 2; // eslint-disable-line\n      }\n\n      if (localOptions && localOptions.padding) {\n        return this.positionPoint({\n          x: x,\n          y: y\n        }, '50%', '50%', localOptions);\n      }\n\n      var padding = this.getPadding();\n      var clientSize = this.getClientSize();\n      var cx = clientSize.width / 2;\n      var cy = clientSize.height / 2;\n      var left = cx - padding.left - x + tx;\n      var right = cx - padding.right + x - tWidth;\n      var top = cy - padding.top - y + ty;\n      var bottom = cy - padding.bottom + y - tHeight;\n      this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));\n      var result = this.scrollToPoint(x, y, localOptions || undefined);\n      this.restoreClientSize();\n      return result;\n    }\n  }, {\n    key: \"centerContent\",\n    value: function centerContent(options) {\n      return this.positionContent('center', options);\n    }\n  }, {\n    key: \"centerCell\",\n    value: function centerCell(cell, options) {\n      return this.positionCell(cell, 'center', options);\n    }\n    /**\n     * The position methods are a more general version of the center methods.\n     * They position the graph so that a specific point on the graph lies at\n     * requested coordinates inside the viewport.\n     */\n\n    /**\n     *\n     */\n\n  }, {\n    key: \"positionContent\",\n    value: function positionContent(pos, options) {\n      var rect = this.graph.getContentArea(options);\n      return this.positionRect(rect, pos, options);\n    }\n  }, {\n    key: \"positionCell\",\n    value: function positionCell(cell, pos, options) {\n      var bbox = cell.getBBox();\n      return this.positionRect(bbox, pos, options);\n    }\n  }, {\n    key: \"positionRect\",\n    value: function positionRect(rect, pos, options) {\n      var bbox = Rectangle.create(rect);\n\n      switch (pos) {\n        case 'center':\n          return this.positionPoint(bbox.getCenter(), '50%', '50%', options);\n\n        case 'top':\n          return this.positionPoint(bbox.getTopCenter(), '50%', 0, options);\n\n        case 'top-right':\n          return this.positionPoint(bbox.getTopRight(), '100%', 0, options);\n\n        case 'right':\n          return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options);\n\n        case 'bottom-right':\n          return this.positionPoint(bbox.getBottomRight(), '100%', '100%', options);\n\n        case 'bottom':\n          return this.positionPoint(bbox.getBottomCenter(), '50%', '100%', options);\n\n        case 'bottom-left':\n          return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options);\n\n        case 'left':\n          return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options);\n\n        case 'top-left':\n          return this.positionPoint(bbox.getTopLeft(), 0, 0, options);\n\n        default:\n          return this;\n      }\n    }\n  }, {\n    key: \"positionPoint\",\n    value: function positionPoint(point, x, y) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      var pad = options.padding,\n          localOptions = __rest(options, [\"padding\"]);\n\n      var padding = NumberExt.normalizeSides(pad);\n      var clientRect = Rectangle.fromSize(this.getClientSize());\n      var targetRect = clientRect.clone().moveAndExpand({\n        x: padding.left,\n        y: padding.top,\n        width: -padding.right - padding.left,\n        height: -padding.top - padding.bottom\n      }); // eslint-disable-next-line\n\n      x = NumberExt.normalizePercentage(x, Math.max(0, targetRect.width));\n\n      if (x < 0) {\n        x = targetRect.width + x; // eslint-disable-line\n      } // eslint-disable-next-line\n\n\n      y = NumberExt.normalizePercentage(y, Math.max(0, targetRect.height));\n\n      if (y < 0) {\n        y = targetRect.height + y; // eslint-disable-line\n      }\n\n      var origin = targetRect.getTopLeft().translate(x, y);\n      var diff = clientRect.getCenter().diff(origin);\n      var scale = this.zoom();\n      var rawDiff = diff.scale(1 / scale, 1 / scale);\n      var result = Point.create(point).translate(rawDiff);\n      return this.centerPoint(result.x, result.y, localOptions);\n    }\n  }, {\n    key: \"zoom\",\n    value: function zoom(factor, options) {\n      if (factor == null) {\n        return this.sx;\n      }\n\n      options = options || {}; // eslint-disable-line\n\n      var cx;\n      var cy;\n      var clientSize = this.getClientSize();\n      var center = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n      var sx = factor;\n      var sy = factor;\n\n      if (!options.absolute) {\n        sx += this.sx;\n        sy += this.sy;\n      }\n\n      if (options.scaleGrid) {\n        sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;\n        sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;\n      }\n\n      if (options.maxScale) {\n        sx = Math.min(options.maxScale, sx);\n        sy = Math.min(options.maxScale, sy);\n      }\n\n      if (options.minScale) {\n        sx = Math.max(options.minScale, sx);\n        sy = Math.max(options.minScale, sy);\n      }\n\n      sx = this.graph.transform.clampScale(sx);\n      sy = this.graph.transform.clampScale(sy);\n\n      if (options.center) {\n        var fx = sx / this.sx;\n        var fy = sy / this.sy;\n        cx = options.center.x - (options.center.x - center.x) / fx;\n        cy = options.center.y - (options.center.y - center.y) / fy;\n      } else {\n        cx = center.x;\n        cy = center.y;\n      }\n\n      this.beforeManipulation();\n      this.graph.transform.scale(sx, sy);\n      this.centerPoint(cx, cy);\n      this.afterManipulation();\n      return this;\n    }\n  }, {\n    key: \"zoomToRect\",\n    value: function zoomToRect(rect) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var area = Rectangle.create(rect);\n      var graph = this.graph;\n      options.contentArea = area;\n\n      if (options.viewportArea == null) {\n        options.viewportArea = {\n          x: graph.options.x,\n          y: graph.options.y,\n          width: this.$container.width(),\n          height: this.$container.height()\n        };\n      }\n\n      this.beforeManipulation();\n      graph.transform.scaleContentToFitImpl(options, false);\n      var center = area.getCenter();\n      this.centerPoint(center.x, center.y);\n      this.afterManipulation();\n      return this;\n    }\n  }, {\n    key: \"zoomToFit\",\n    value: function zoomToFit() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.zoomToRect(this.graph.getContentArea(options), options);\n    }\n  }, {\n    key: \"transitionToPoint\",\n    value: function transitionToPoint(x, y, options) {\n      var _this4 = this;\n\n      if (typeof x === 'object') {\n        options = y; // eslint-disable-line\n\n        y = x.y; // eslint-disable-line\n\n        x = x.x; // eslint-disable-line\n      } else {\n        y = y; // eslint-disable-line\n      }\n\n      if (options == null) {\n        options = {}; // eslint-disable-line\n      }\n\n      var transform;\n      var transformOrigin;\n      var scale = this.sx;\n      var targetScale = Math.max(options.scale || scale, 0.000001);\n      var clientSize = this.getClientSize();\n      var targetPoint = new Point(x, y);\n      var localPoint = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n\n      if (scale === targetScale) {\n        var translate = localPoint.diff(targetPoint).scale(scale, scale).round();\n        transform = \"translate(\".concat(translate.x, \"px,\").concat(translate.y, \"px)\");\n      } else {\n        var delta = targetScale / (scale - targetScale) * targetPoint.distance(localPoint);\n        var range = localPoint.clone().move(targetPoint, delta);\n        var origin = this.localToBackgroundPoint(range).round();\n        transform = \"scale(\".concat(targetScale / scale, \")\");\n        transformOrigin = \"\".concat(origin.x, \"px \").concat(origin.y, \"px\");\n      }\n\n      var onTransitionEnd = options.onTransitionEnd;\n      this.$container.addClass(Util.transitionClassName);\n      this.$content.off(Util.transitionEventName).on(Util.transitionEventName, function (e) {\n        _this4.syncTransition(targetScale, {\n          x: x,\n          y: y\n        });\n\n        if (typeof onTransitionEnd === 'function') {\n          FunctionExt.call(onTransitionEnd, _this4, e.originalEvent);\n        }\n      }).css({\n        transform: transform,\n        transformOrigin: transformOrigin,\n        transition: 'transform',\n        transitionDuration: options.duration || '1s',\n        transitionDelay: options.delay,\n        transitionTimingFunction: options.timing\n      });\n      return this;\n    }\n  }, {\n    key: \"syncTransition\",\n    value: function syncTransition(scale, p) {\n      this.beforeManipulation();\n      this.graph.scale(scale);\n      this.removeTransition();\n      this.centerPoint(p.x, p.y);\n      this.afterManipulation();\n      return this;\n    }\n  }, {\n    key: \"removeTransition\",\n    value: function removeTransition() {\n      this.$container.removeClass(Util.transitionClassName);\n      this.$content.off(Util.transitionEventName).css({\n        transform: '',\n        transformOrigin: '',\n        transition: '',\n        transitionDuration: '',\n        transitionDelay: '',\n        transitionTimingFunction: ''\n      });\n      return this;\n    }\n  }, {\n    key: \"transitionToRect\",\n    value: function transitionToRect(rectangle) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var rect = Rectangle.create(rectangle);\n      var maxScale = options.maxScale || Infinity;\n      var minScale = options.minScale || Number.MIN_VALUE;\n      var scaleGrid = options.scaleGrid || null;\n      var PIXEL_SIZE = options.visibility || 1;\n      var center = options.center ? Point.create(options.center) : rect.getCenter();\n      var clientSize = this.getClientSize();\n      var w = clientSize.width * PIXEL_SIZE;\n      var h = clientSize.height * PIXEL_SIZE;\n      var scale = new Rectangle(center.x - w / 2, center.y - h / 2, w, h).getMaxUniformScaleToFit(rect, center);\n      scale = Math.min(scale, maxScale);\n\n      if (scaleGrid) {\n        scale = Math.floor(scale / scaleGrid) * scaleGrid;\n      }\n\n      scale = Math.max(minScale, scale);\n      return this.transitionToPoint(center, Object.assign({\n        scale: scale\n      }, options));\n    }\n  }, {\n    key: \"startPanning\",\n    value: function startPanning(evt) {\n      var e = this.normalizeEvent(evt);\n      this.clientX = e.clientX;\n      this.clientY = e.clientY;\n      this.trigger('pan:start', {\n        e: e\n      });\n      this.$(document.body).on({\n        'mousemove.panning touchmove.panning': this.pan.bind(this),\n        'mouseup.panning touchend.panning': this.stopPanning.bind(this)\n      });\n      this.$(window).on('mouseup.panning', this.stopPanning.bind(this));\n    }\n  }, {\n    key: \"pan\",\n    value: function pan(evt) {\n      var e = this.normalizeEvent(evt);\n      var dx = e.clientX - this.clientX;\n      var dy = e.clientY - this.clientY;\n      this.container.scrollTop -= dy;\n      this.container.scrollLeft -= dx;\n      this.clientX = e.clientX;\n      this.clientY = e.clientY;\n      this.trigger('panning', {\n        e: e\n      });\n    }\n  }, {\n    key: \"stopPanning\",\n    value: function stopPanning(e) {\n      this.$(document.body).off('.panning');\n      this.$(window).off('.panning');\n      this.trigger('pan:stop', {\n        e: e\n      });\n    }\n  }, {\n    key: \"clientToLocalPoint\",\n    value: function clientToLocalPoint(a, b) {\n      var x = typeof a === 'object' ? a.x : a;\n      var y = typeof a === 'object' ? a.y : b;\n      var ctm = this.graph.matrix();\n      x += this.container.scrollLeft - this.padding.left - ctm.e;\n      y += this.container.scrollTop - this.padding.top - ctm.f;\n      return new Point(x / ctm.a, y / ctm.d);\n    }\n  }, {\n    key: \"localToBackgroundPoint\",\n    value: function localToBackgroundPoint(x, y) {\n      var p = typeof x === 'object' ? Point.create(x) : new Point(x, y);\n      var ctm = this.graph.matrix();\n      var padding = this.padding;\n      return Dom.transformPoint(p, ctm).translate(padding.left, padding.top);\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      var w = width != null ? width : this.container.clientWidth;\n      var h = height != null ? height : this.container.clientHeight;\n\n      if (typeof w === 'number') {\n        w = Math.round(w);\n      }\n\n      if (typeof h === 'number') {\n        h = Math.round(h);\n      }\n\n      this.options.width = w;\n      this.options.height = h;\n      this.$container.css({\n        width: w,\n        height: h\n      });\n      this.update();\n    }\n  }, {\n    key: \"getClientSize\",\n    value: function getClientSize() {\n      if (this.cachedClientSize) {\n        return this.cachedClientSize;\n      }\n\n      return {\n        width: this.container.clientWidth,\n        height: this.container.clientHeight\n      };\n    }\n  }, {\n    key: \"autoScroll\",\n    value: function autoScroll(clientX, clientY) {\n      var buffer = 10;\n      var container = this.container;\n      var rect = container.getBoundingClientRect();\n      var dx = 0;\n      var dy = 0;\n\n      if (clientX <= rect.left + buffer) {\n        dx = -buffer;\n      }\n\n      if (clientY <= rect.top + buffer) {\n        dy = -buffer;\n      }\n\n      if (clientX >= rect.right - buffer) {\n        dx = buffer;\n      }\n\n      if (clientY >= rect.bottom - buffer) {\n        dy = buffer;\n      }\n\n      if (dx !== 0) {\n        container.scrollLeft += dx;\n      }\n\n      if (dy !== 0) {\n        container.scrollTop += dy;\n      }\n\n      return {\n        scrollerX: dx,\n        scrollerY: dy\n      };\n    }\n  }, {\n    key: \"addPadding\",\n    value: function addPadding(left, right, top, bottom) {\n      var padding = this.getPadding();\n      this.padding = {\n        left: Math.round(padding.left + (left || 0)),\n        top: Math.round(padding.top + (top || 0)),\n        bottom: Math.round(padding.bottom + (bottom || 0)),\n        right: Math.round(padding.right + (right || 0))\n      };\n      padding = this.padding;\n      this.$content.css({\n        width: padding.left + this.graph.options.width + padding.right,\n        height: padding.top + this.graph.options.height + padding.bottom\n      });\n      var container = this.graph.container;\n      container.style.left = \"\".concat(this.padding.left, \"px\");\n      container.style.top = \"\".concat(this.padding.top, \"px\");\n      return this;\n    }\n  }, {\n    key: \"getPadding\",\n    value: function getPadding() {\n      var padding = this.options.padding;\n\n      if (typeof padding === 'function') {\n        return NumberExt.normalizeSides(FunctionExt.call(padding, this, this));\n      }\n\n      return NumberExt.normalizeSides(padding);\n    }\n    /**\n     * Returns the untransformed size and origin of the current viewport.\n     */\n\n  }, {\n    key: \"getVisibleArea\",\n    value: function getVisibleArea() {\n      var ctm = this.graph.matrix();\n      var size = this.getClientSize();\n      var box = {\n        x: this.container.scrollLeft || 0,\n        y: this.container.scrollTop || 0,\n        width: size.width,\n        height: size.height\n      };\n      var area = Dom.transformRectangle(box, ctm.inverse());\n      area.x -= (this.padding.left || 0) / this.sx;\n      area.y -= (this.padding.top || 0) / this.sy;\n      return area;\n    }\n  }, {\n    key: \"isCellVisible\",\n    value: function isCellVisible(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var bbox = cell.getBBox();\n      var area = this.getVisibleArea();\n      return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n    }\n  }, {\n    key: \"isPointVisible\",\n    value: function isPointVisible(point) {\n      return this.getVisibleArea().containsPoint(point);\n    }\n    /**\n     * Lock the current viewport by disabling user scrolling.\n     */\n\n  }, {\n    key: \"lock\",\n    value: function lock() {\n      this.$container.css('overflow', 'hidden');\n      return this;\n    }\n    /**\n     * Enable user scrolling if previously locked.\n     */\n\n  }, {\n    key: \"unlock\",\n    value: function unlock() {\n      this.$container.css('overflow', 'scroll');\n      return this;\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.stopListening();\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.$(this.graph.container).insertBefore(this.$container);\n      this.remove();\n    }\n  }]);\n\n  return Scroller;\n}(View);\n\n__decorate([View.dispose()], Scroller.prototype, \"dispose\", null);\n\n(function (Scroller) {\n  var Background = /*#__PURE__*/function (_BackgroundManager) {\n    _inherits(Background, _BackgroundManager);\n\n    var _super2 = _createSuper(Background);\n\n    function Background(scroller) {\n      var _this5;\n\n      _classCallCheck(this, Background);\n\n      _this5 = _super2.call(this, scroller.graph);\n      _this5.scroller = scroller;\n\n      if (scroller.options.background) {\n        _this5.draw(scroller.options.background);\n      }\n\n      return _this5;\n    }\n\n    _createClass(Background, [{\n      key: \"elem\",\n      get: function get() {\n        return this.scroller.background;\n      }\n    }, {\n      key: \"init\",\n      value: function init() {\n        this.graph.on('scale', this.update, this);\n        this.graph.on('translate', this.update, this);\n      }\n    }, {\n      key: \"updateBackgroundOptions\",\n      value: function updateBackgroundOptions(options) {\n        this.scroller.options.background = options;\n      }\n    }]);\n\n    return Background;\n  }(BackgroundManager);\n\n  Scroller.Background = Background;\n})(Scroller || (Scroller = {}));\n\nvar Util;\n\n(function (Util) {\n  Util.containerClass = 'graph-scroller';\n  Util.panningClass = \"\".concat(Util.containerClass, \"-panning\");\n  Util.pannableClass = \"\".concat(Util.containerClass, \"-pannable\");\n  Util.pagedClass = \"\".concat(Util.containerClass, \"-paged\");\n  Util.contentClass = \"\".concat(Util.containerClass, \"-content\");\n  Util.backgroundClass = \"\".concat(Util.containerClass, \"-background\");\n  Util.transitionClassName = 'transition-in-progress';\n  Util.transitionEventName = 'transitionend.graph-scroller-transition';\n  Util.defaultOptions = {\n    padding: function padding() {\n      var size = this.getClientSize();\n      var minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1;\n      var minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1;\n      var left = Math.max(size.width - minWidth, 0);\n      var top = Math.max(size.height - minHeight, 0);\n      return {\n        left: left,\n        top: top,\n        right: left,\n        bottom: top\n      };\n    },\n    minVisibleWidth: 50,\n    minVisibleHeight: 50,\n    pageVisible: false,\n    pageBreak: false,\n    autoResize: true\n  };\n\n  function getOptions(options) {\n    var result = ObjectExt.merge({}, Util.defaultOptions, options);\n\n    if (result.pageWidth == null) {\n      result.pageWidth = options.graph.options.width;\n    }\n\n    if (result.pageHeight == null) {\n      result.pageHeight = options.graph.options.height;\n    }\n\n    return result;\n  }\n\n  Util.getOptions = getOptions;\n})(Util || (Util = {}));","map":{"version":3,"sources":["../../../src/addon/scroller/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { Platform, NumberExt, ObjectExt, Dom, FunctionExt } from '../../util';\nimport { Point, Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Renderer } from '../../graph/renderer';\nimport { GraphView } from '../../graph/view';\nimport { BackgroundManager } from '../../graph/background';\nexport class Scroller extends View {\n    constructor(options) {\n        super();\n        this.padding = { left: 0, top: 0, right: 0, bottom: 0 };\n        this.options = Util.getOptions(options);\n        const scale = this.graph.transform.getScale();\n        this.sx = scale.sx;\n        this.sy = scale.sy;\n        const width = this.options.width || this.graph.options.width;\n        const height = this.options.height || this.graph.options.height;\n        this.container = document.createElement('div');\n        this.$container = this.$(this.container)\n            .addClass(this.prefixClassName(Util.containerClass))\n            .css({ width, height });\n        if (this.options.pageVisible) {\n            this.$container.addClass(this.prefixClassName(Util.pagedClass));\n        }\n        if (this.options.className) {\n            this.$container.addClass(this.options.className);\n        }\n        const graphContainer = this.graph.container;\n        if (graphContainer.parentNode) {\n            this.$container.insertBefore(graphContainer);\n        }\n        // copy style\n        const style = graphContainer.getAttribute('style');\n        if (style) {\n            const obj = {};\n            const styles = style.split(';');\n            styles.forEach((item) => {\n                const section = item.trim();\n                if (section) {\n                    const pair = section.split(':');\n                    if (pair.length) {\n                        obj[pair[0].trim()] = pair[1] ? pair[1].trim() : '';\n                    }\n                }\n            });\n            Object.keys(obj).forEach((key) => {\n                if (key === 'width' || key === 'height') {\n                    return;\n                }\n                graphContainer.style[key] = '';\n                this.container.style[key] = obj[key];\n            });\n        }\n        this.content = document.createElement('div');\n        this.$content = this.$(this.content)\n            .addClass(this.prefixClassName(Util.contentClass))\n            .css({\n            width: this.graph.options.width,\n            height: this.graph.options.height,\n        });\n        // custom background\n        this.background = document.createElement('div');\n        this.$background = this.$(this.background).addClass(this.prefixClassName(Util.backgroundClass));\n        this.$content.append(this.background);\n        if (!this.options.pageVisible) {\n            this.$content.append(this.graph.view.grid);\n        }\n        this.$content.append(graphContainer);\n        this.$content.appendTo(this.container);\n        this.startListening();\n        if (!this.options.pageVisible) {\n            this.graph.grid.update();\n        }\n        this.backgroundManager = new Scroller.Background(this);\n        if (!this.options.autoResize) {\n            this.update();\n        }\n    }\n    get graph() {\n        return this.options.graph;\n    }\n    get model() {\n        return this.graph.model;\n    }\n    startListening() {\n        const graph = this.graph;\n        const model = this.model;\n        graph.on('scale', this.onScale, this);\n        graph.on('resize', this.onResize, this);\n        graph.on('before:print', this.storeScrollPosition, this);\n        graph.on('before:export', this.storeScrollPosition, this);\n        graph.on('after:print', this.restoreScrollPosition, this);\n        graph.on('after:export', this.restoreScrollPosition, this);\n        graph.on('render:done', this.onRenderDone, this);\n        graph.on('unfreeze', this.onUpdate, this);\n        model.on('reseted', this.onUpdate, this);\n        model.on('cell:added', this.onUpdate, this);\n        model.on('cell:removed', this.onUpdate, this);\n        model.on('cell:changed', this.onUpdate, this);\n        model.on('batch:stop', this.onBatchStop, this);\n        this.delegateBackgroundEvents();\n    }\n    stopListening() {\n        const graph = this.graph;\n        const model = this.model;\n        graph.off('scale', this.onScale, this);\n        graph.off('resize', this.onResize, this);\n        graph.off('beforeprint', this.storeScrollPosition, this);\n        graph.off('beforeexport', this.storeScrollPosition, this);\n        graph.off('afterprint', this.restoreScrollPosition, this);\n        graph.off('afterexport', this.restoreScrollPosition, this);\n        graph.off('render:done', this.onRenderDone, this);\n        graph.off('unfreeze', this.onUpdate, this);\n        model.off('reseted', this.onUpdate, this);\n        model.off('cell:added', this.onUpdate, this);\n        model.off('cell:removed', this.onUpdate, this);\n        model.off('cell:changed', this.onUpdate, this);\n        model.off('batch:stop', this.onBatchStop, this);\n        this.undelegateBackgroundEvents();\n    }\n    enableAutoResize() {\n        this.options.autoResize = true;\n    }\n    disableAutoResize() {\n        this.options.autoResize = false;\n    }\n    onUpdate() {\n        if (this.graph.isAsync() || !this.options.autoResize) {\n            return;\n        }\n        this.update();\n    }\n    onBatchStop(args) {\n        if (this.graph.isAsync() || !this.options.autoResize) {\n            return;\n        }\n        if (Renderer.UPDATE_DELAYING_BATCHES.includes(args.name)) {\n            this.update();\n        }\n    }\n    delegateBackgroundEvents(events) {\n        const evts = events || GraphView.events;\n        this.delegatedHandlers = Object.keys(evts).reduce((memo, name) => {\n            const handler = evts[name];\n            if (name.indexOf(' ') === -1) {\n                if (typeof handler === 'function') {\n                    memo[name] = handler;\n                }\n                else {\n                    let method = this.graph.view[handler];\n                    if (typeof method === 'function') {\n                        method = method.bind(this.graph.view);\n                        memo[name] = method;\n                    }\n                }\n            }\n            return memo;\n        }, {});\n        this.onBackgroundEvent = this.onBackgroundEvent.bind(this);\n        Object.keys(this.delegatedHandlers).forEach((name) => {\n            this.delegateEvent(name, {\n                guarded: false,\n            }, this.onBackgroundEvent);\n        });\n    }\n    undelegateBackgroundEvents() {\n        Object.keys(this.delegatedHandlers).forEach((name) => {\n            this.undelegateEvent(name, this.onBackgroundEvent);\n        });\n    }\n    onBackgroundEvent(e) {\n        let valid = false;\n        const target = e.target;\n        if (!this.options.pageVisible) {\n            const view = this.graph.view;\n            valid = view.background === target || view.grid === target;\n        }\n        else if (this.options.background) {\n            valid = this.background === target;\n        }\n        else {\n            valid = this.content === target;\n        }\n        if (valid) {\n            const handler = this.delegatedHandlers[e.type];\n            if (typeof handler === 'function') {\n                handler.apply(this.graph, arguments); // eslint-disable-line\n            }\n        }\n    }\n    onRenderDone({ stats }) {\n        if (this.options.autoResize && stats.priority < 2) {\n            this.update();\n        }\n    }\n    onResize() {\n        if (this.cachedCenterPoint) {\n            this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y);\n            this.updatePageBreak();\n        }\n    }\n    onScale({ sx, sy, ox, oy }) {\n        this.updateScale(sx, sy);\n        if (ox || oy) {\n            this.centerPoint(ox, oy);\n            this.updatePageBreak();\n        }\n        const autoResizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n        if (typeof autoResizeOptions === 'function') {\n            this.update();\n        }\n    }\n    storeScrollPosition() {\n        this.cachedScrollLeft = this.container.scrollLeft;\n        this.cachedScrollTop = this.container.scrollTop;\n    }\n    restoreScrollPosition() {\n        this.container.scrollLeft = this.cachedScrollLeft;\n        this.container.scrollTop = this.cachedScrollTop;\n        this.cachedScrollLeft = null;\n        this.cachedScrollTop = null;\n    }\n    storeClientSize() {\n        this.cachedClientSize = {\n            width: this.container.clientWidth,\n            height: this.container.clientHeight,\n        };\n    }\n    restoreClientSize() {\n        this.cachedClientSize = null;\n    }\n    beforeManipulation() {\n        if (Platform.IS_IE || Platform.IS_EDGE) {\n            this.$container.css('visibility', 'hidden');\n        }\n    }\n    afterManipulation() {\n        if (Platform.IS_IE || Platform.IS_EDGE) {\n            this.$container.css('visibility', 'visible');\n        }\n    }\n    updatePageSize(width, height) {\n        if (width != null) {\n            this.options.pageWidth = width;\n        }\n        if (height != null) {\n            this.options.pageHeight = height;\n        }\n        this.updatePageBreak();\n    }\n    updatePageBreak() {\n        if (this.pageBreak && this.pageBreak.parentNode) {\n            this.pageBreak.parentNode.removeChild(this.pageBreak);\n        }\n        this.pageBreak = null;\n        if (this.options.pageVisible && this.options.pageBreak) {\n            const graphWidth = this.graph.options.width;\n            const graphHeight = this.graph.options.height;\n            const pageWidth = this.options.pageWidth * this.sx;\n            const pageHeight = this.options.pageHeight * this.sy;\n            if (graphWidth > pageWidth || graphHeight > pageHeight) {\n                let hasPageBreak = false;\n                const container = document.createElement('div');\n                for (let i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {\n                    this.$('<div/>')\n                        .addClass(this.prefixClassName(`graph-pagebreak-vertical`))\n                        .css({ left: i * pageWidth })\n                        .appendTo(container);\n                    hasPageBreak = true;\n                }\n                for (let i = 1, l = Math.floor(graphHeight / pageHeight); i < l; i += 1) {\n                    this.$('<div/>')\n                        .addClass(this.prefixClassName(`graph-pagebreak-horizontal`))\n                        .css({ top: i * pageHeight })\n                        .appendTo(container);\n                    hasPageBreak = true;\n                }\n                if (hasPageBreak) {\n                    Dom.addClass(container, this.prefixClassName('graph-pagebreak'));\n                    this.$(this.graph.view.grid).after(container);\n                    this.pageBreak = container;\n                }\n            }\n        }\n    }\n    update() {\n        const size = this.getClientSize();\n        this.cachedCenterPoint = this.clientToLocalPoint(size.width / 2, size.height / 2);\n        let resizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n        if (typeof resizeOptions === 'function') {\n            resizeOptions = FunctionExt.call(resizeOptions, this, this);\n        }\n        const options = Object.assign({ gridWidth: this.options.pageWidth, gridHeight: this.options.pageHeight, allowNewOrigin: 'negative' }, resizeOptions);\n        this.graph.fitToContent(this.getFitToContentOptions(options));\n    }\n    getFitToContentOptions(options) {\n        const sx = this.sx;\n        const sy = this.sy;\n        options.gridWidth && (options.gridWidth *= sx);\n        options.gridHeight && (options.gridHeight *= sy);\n        options.minWidth && (options.minWidth *= sx);\n        options.minHeight && (options.minHeight *= sy);\n        if (typeof options.padding === 'object') {\n            options.padding = {\n                left: (options.padding.left || 0) * sx,\n                right: (options.padding.right || 0) * sx,\n                top: (options.padding.top || 0) * sy,\n                bottom: (options.padding.bottom || 0) * sy,\n            };\n        }\n        else if (typeof options.padding === 'number') {\n            options.padding *= sx;\n        }\n        if (!this.options.autoResize) {\n            options.contentArea = Rectangle.create();\n        }\n        return options;\n    }\n    updateScale(sx, sy) {\n        const options = this.graph.options;\n        const dx = sx / this.sx;\n        const dy = sy / this.sy;\n        this.sx = sx;\n        this.sy = sy;\n        this.graph.translate(options.x * dx, options.y * dy);\n        this.graph.resizeGraph(options.width * dx, options.height * dy);\n    }\n    scrollbarPosition(left, top, options) {\n        if (left == null && top == null) {\n            return {\n                left: this.container.scrollLeft,\n                top: this.container.scrollTop,\n            };\n        }\n        const prop = {};\n        if (typeof left === 'number') {\n            prop.scrollLeft = left;\n        }\n        if (typeof top === 'number') {\n            prop.scrollTop = top;\n        }\n        if (options && options.animation) {\n            this.$container.animate(prop, options.animation);\n        }\n        else {\n            this.$container.prop(prop);\n        }\n        return this;\n    }\n    /**\n     * Try to scroll to ensure that the position (x,y) on the graph (in local\n     * coordinates) is at the center of the viewport. If only one of the\n     * coordinates is specified, only scroll in the specified dimension and\n     * keep the other coordinate unchanged.\n     */\n    scrollToPoint(x, y, options) {\n        const size = this.getClientSize();\n        const ctm = this.graph.matrix();\n        const prop = {};\n        if (typeof x === 'number') {\n            prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0);\n        }\n        if (typeof y === 'number') {\n            prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0);\n        }\n        if (options && options.animation) {\n            this.$container.animate(prop, options.animation);\n        }\n        else {\n            this.$container.prop(prop);\n        }\n        return this;\n    }\n    /**\n     * Try to scroll to ensure that the center of graph content is at the\n     * center of the viewport.\n     */\n    scrollToContent(options) {\n        const sx = this.sx;\n        const sy = this.sy;\n        const center = this.graph.getContentArea().getCenter();\n        return this.scrollToPoint(center.x * sx, center.y * sy, options);\n    }\n    /**\n     * Try to scroll to ensure that the center of cell is at the center of\n     * the viewport.\n     */\n    scrollToCell(cell, options) {\n        const sx = this.sx;\n        const sy = this.sy;\n        const center = cell.getBBox().getCenter();\n        return this.scrollToPoint(center.x * sx, center.y * sy, options);\n    }\n    /**\n     * The center methods are more aggressive than the scroll methods. These\n     * methods position the graph so that a specific point on the graph lies\n     * at the center of the viewport, adding paddings around the paper if\n     * necessary (e.g. if the requested point lies in a corner of the paper).\n     * This means that the requested point will always move into the center\n     * of the viewport. (Use the scroll functions to avoid adding paddings\n     * and only scroll the viewport as far as the graph boundary.)\n     */\n    /**\n     * Position the center of graph to the center of the viewport.\n     */\n    center(optons) {\n        return this.centerPoint(optons);\n    }\n    centerPoint(x, y, options) {\n        const ctm = this.graph.matrix();\n        const sx = ctm.a;\n        const sy = ctm.d;\n        const tx = -ctm.e;\n        const ty = -ctm.f;\n        const tWidth = tx + this.graph.options.width;\n        const tHeight = ty + this.graph.options.height;\n        let localOptions;\n        this.storeClientSize(); // avoid multilple reflow\n        if (typeof x === 'number' || typeof y === 'number') {\n            localOptions = options;\n            const visibleCenter = this.getVisibleArea().getCenter();\n            if (typeof x === 'number') {\n                x *= sx; // eslint-disable-line\n            }\n            else {\n                x = visibleCenter.x; // eslint-disable-line\n            }\n            if (typeof y === 'number') {\n                y *= sy; // eslint-disable-line\n            }\n            else {\n                y = visibleCenter.y; // eslint-disable-line\n            }\n        }\n        else {\n            localOptions = x;\n            x = (tx + tWidth) / 2; // eslint-disable-line\n            y = (ty + tHeight) / 2; // eslint-disable-line\n        }\n        if (localOptions && localOptions.padding) {\n            return this.positionPoint({ x, y }, '50%', '50%', localOptions);\n        }\n        const padding = this.getPadding();\n        const clientSize = this.getClientSize();\n        const cx = clientSize.width / 2;\n        const cy = clientSize.height / 2;\n        const left = cx - padding.left - x + tx;\n        const right = cx - padding.right + x - tWidth;\n        const top = cy - padding.top - y + ty;\n        const bottom = cy - padding.bottom + y - tHeight;\n        this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));\n        const result = this.scrollToPoint(x, y, localOptions || undefined);\n        this.restoreClientSize();\n        return result;\n    }\n    centerContent(options) {\n        return this.positionContent('center', options);\n    }\n    centerCell(cell, options) {\n        return this.positionCell(cell, 'center', options);\n    }\n    /**\n     * The position methods are a more general version of the center methods.\n     * They position the graph so that a specific point on the graph lies at\n     * requested coordinates inside the viewport.\n     */\n    /**\n     *\n     */\n    positionContent(pos, options) {\n        const rect = this.graph.getContentArea(options);\n        return this.positionRect(rect, pos, options);\n    }\n    positionCell(cell, pos, options) {\n        const bbox = cell.getBBox();\n        return this.positionRect(bbox, pos, options);\n    }\n    positionRect(rect, pos, options) {\n        const bbox = Rectangle.create(rect);\n        switch (pos) {\n            case 'center':\n                return this.positionPoint(bbox.getCenter(), '50%', '50%', options);\n            case 'top':\n                return this.positionPoint(bbox.getTopCenter(), '50%', 0, options);\n            case 'top-right':\n                return this.positionPoint(bbox.getTopRight(), '100%', 0, options);\n            case 'right':\n                return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options);\n            case 'bottom-right':\n                return this.positionPoint(bbox.getBottomRight(), '100%', '100%', options);\n            case 'bottom':\n                return this.positionPoint(bbox.getBottomCenter(), '50%', '100%', options);\n            case 'bottom-left':\n                return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options);\n            case 'left':\n                return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options);\n            case 'top-left':\n                return this.positionPoint(bbox.getTopLeft(), 0, 0, options);\n            default:\n                return this;\n        }\n    }\n    positionPoint(point, x, y, options = {}) {\n        const { padding: pad } = options, localOptions = __rest(options, [\"padding\"]);\n        const padding = NumberExt.normalizeSides(pad);\n        const clientRect = Rectangle.fromSize(this.getClientSize());\n        const targetRect = clientRect.clone().moveAndExpand({\n            x: padding.left,\n            y: padding.top,\n            width: -padding.right - padding.left,\n            height: -padding.top - padding.bottom,\n        });\n        // eslint-disable-next-line\n        x = NumberExt.normalizePercentage(x, Math.max(0, targetRect.width));\n        if (x < 0) {\n            x = targetRect.width + x; // eslint-disable-line\n        }\n        // eslint-disable-next-line\n        y = NumberExt.normalizePercentage(y, Math.max(0, targetRect.height));\n        if (y < 0) {\n            y = targetRect.height + y; // eslint-disable-line\n        }\n        const origin = targetRect.getTopLeft().translate(x, y);\n        const diff = clientRect.getCenter().diff(origin);\n        const scale = this.zoom();\n        const rawDiff = diff.scale(1 / scale, 1 / scale);\n        const result = Point.create(point).translate(rawDiff);\n        return this.centerPoint(result.x, result.y, localOptions);\n    }\n    zoom(factor, options) {\n        if (factor == null) {\n            return this.sx;\n        }\n        options = options || {}; // eslint-disable-line\n        let cx;\n        let cy;\n        const clientSize = this.getClientSize();\n        const center = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n        let sx = factor;\n        let sy = factor;\n        if (!options.absolute) {\n            sx += this.sx;\n            sy += this.sy;\n        }\n        if (options.scaleGrid) {\n            sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;\n            sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;\n        }\n        if (options.maxScale) {\n            sx = Math.min(options.maxScale, sx);\n            sy = Math.min(options.maxScale, sy);\n        }\n        if (options.minScale) {\n            sx = Math.max(options.minScale, sx);\n            sy = Math.max(options.minScale, sy);\n        }\n        sx = this.graph.transform.clampScale(sx);\n        sy = this.graph.transform.clampScale(sy);\n        if (options.center) {\n            const fx = sx / this.sx;\n            const fy = sy / this.sy;\n            cx = options.center.x - (options.center.x - center.x) / fx;\n            cy = options.center.y - (options.center.y - center.y) / fy;\n        }\n        else {\n            cx = center.x;\n            cy = center.y;\n        }\n        this.beforeManipulation();\n        this.graph.transform.scale(sx, sy);\n        this.centerPoint(cx, cy);\n        this.afterManipulation();\n        return this;\n    }\n    zoomToRect(rect, options = {}) {\n        const area = Rectangle.create(rect);\n        const graph = this.graph;\n        options.contentArea = area;\n        if (options.viewportArea == null) {\n            options.viewportArea = {\n                x: graph.options.x,\n                y: graph.options.y,\n                width: this.$container.width(),\n                height: this.$container.height(),\n            };\n        }\n        this.beforeManipulation();\n        graph.transform.scaleContentToFitImpl(options, false);\n        const center = area.getCenter();\n        this.centerPoint(center.x, center.y);\n        this.afterManipulation();\n        return this;\n    }\n    zoomToFit(options = {}) {\n        return this.zoomToRect(this.graph.getContentArea(options), options);\n    }\n    transitionToPoint(x, y, options) {\n        if (typeof x === 'object') {\n            options = y; // eslint-disable-line\n            y = x.y; // eslint-disable-line\n            x = x.x; // eslint-disable-line\n        }\n        else {\n            y = y; // eslint-disable-line\n        }\n        if (options == null) {\n            options = {}; // eslint-disable-line\n        }\n        let transform;\n        let transformOrigin;\n        const scale = this.sx;\n        const targetScale = Math.max(options.scale || scale, 0.000001);\n        const clientSize = this.getClientSize();\n        const targetPoint = new Point(x, y);\n        const localPoint = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n        if (scale === targetScale) {\n            const translate = localPoint.diff(targetPoint).scale(scale, scale).round();\n            transform = `translate(${translate.x}px,${translate.y}px)`;\n        }\n        else {\n            const delta = (targetScale / (scale - targetScale)) * targetPoint.distance(localPoint);\n            const range = localPoint.clone().move(targetPoint, delta);\n            const origin = this.localToBackgroundPoint(range).round();\n            transform = `scale(${targetScale / scale})`;\n            transformOrigin = `${origin.x}px ${origin.y}px`;\n        }\n        const onTransitionEnd = options.onTransitionEnd;\n        this.$container.addClass(Util.transitionClassName);\n        this.$content\n            .off(Util.transitionEventName)\n            .on(Util.transitionEventName, (e) => {\n            this.syncTransition(targetScale, { x: x, y: y });\n            if (typeof onTransitionEnd === 'function') {\n                FunctionExt.call(onTransitionEnd, this, e.originalEvent);\n            }\n        })\n            .css({\n            transform,\n            transformOrigin,\n            transition: 'transform',\n            transitionDuration: options.duration || '1s',\n            transitionDelay: options.delay,\n            transitionTimingFunction: options.timing,\n        });\n        return this;\n    }\n    syncTransition(scale, p) {\n        this.beforeManipulation();\n        this.graph.scale(scale);\n        this.removeTransition();\n        this.centerPoint(p.x, p.y);\n        this.afterManipulation();\n        return this;\n    }\n    removeTransition() {\n        this.$container.removeClass(Util.transitionClassName);\n        this.$content.off(Util.transitionEventName).css({\n            transform: '',\n            transformOrigin: '',\n            transition: '',\n            transitionDuration: '',\n            transitionDelay: '',\n            transitionTimingFunction: '',\n        });\n        return this;\n    }\n    transitionToRect(rectangle, options = {}) {\n        const rect = Rectangle.create(rectangle);\n        const maxScale = options.maxScale || Infinity;\n        const minScale = options.minScale || Number.MIN_VALUE;\n        const scaleGrid = options.scaleGrid || null;\n        const PIXEL_SIZE = options.visibility || 1;\n        const center = options.center\n            ? Point.create(options.center)\n            : rect.getCenter();\n        const clientSize = this.getClientSize();\n        const w = clientSize.width * PIXEL_SIZE;\n        const h = clientSize.height * PIXEL_SIZE;\n        let scale = new Rectangle(center.x - w / 2, center.y - h / 2, w, h).getMaxUniformScaleToFit(rect, center);\n        scale = Math.min(scale, maxScale);\n        if (scaleGrid) {\n            scale = Math.floor(scale / scaleGrid) * scaleGrid;\n        }\n        scale = Math.max(minScale, scale);\n        return this.transitionToPoint(center, Object.assign({ scale }, options));\n    }\n    startPanning(evt) {\n        const e = this.normalizeEvent(evt);\n        this.clientX = e.clientX;\n        this.clientY = e.clientY;\n        this.trigger('pan:start', { e });\n        this.$(document.body).on({\n            'mousemove.panning touchmove.panning': this.pan.bind(this),\n            'mouseup.panning touchend.panning': this.stopPanning.bind(this),\n        });\n        this.$(window).on('mouseup.panning', this.stopPanning.bind(this));\n    }\n    pan(evt) {\n        const e = this.normalizeEvent(evt);\n        const dx = e.clientX - this.clientX;\n        const dy = e.clientY - this.clientY;\n        this.container.scrollTop -= dy;\n        this.container.scrollLeft -= dx;\n        this.clientX = e.clientX;\n        this.clientY = e.clientY;\n        this.trigger('panning', { e });\n    }\n    stopPanning(e) {\n        this.$(document.body).off('.panning');\n        this.$(window).off('.panning');\n        this.trigger('pan:stop', { e });\n    }\n    clientToLocalPoint(a, b) {\n        let x = typeof a === 'object' ? a.x : a;\n        let y = typeof a === 'object' ? a.y : b;\n        const ctm = this.graph.matrix();\n        x += this.container.scrollLeft - this.padding.left - ctm.e;\n        y += this.container.scrollTop - this.padding.top - ctm.f;\n        return new Point(x / ctm.a, y / ctm.d);\n    }\n    localToBackgroundPoint(x, y) {\n        const p = typeof x === 'object' ? Point.create(x) : new Point(x, y);\n        const ctm = this.graph.matrix();\n        const padding = this.padding;\n        return Dom.transformPoint(p, ctm).translate(padding.left, padding.top);\n    }\n    resize(width, height) {\n        let w = width != null ? width : this.container.clientWidth;\n        let h = height != null ? height : this.container.clientHeight;\n        if (typeof w === 'number') {\n            w = Math.round(w);\n        }\n        if (typeof h === 'number') {\n            h = Math.round(h);\n        }\n        this.options.width = w;\n        this.options.height = h;\n        this.$container.css({ width: w, height: h });\n        this.update();\n    }\n    getClientSize() {\n        if (this.cachedClientSize) {\n            return this.cachedClientSize;\n        }\n        return {\n            width: this.container.clientWidth,\n            height: this.container.clientHeight,\n        };\n    }\n    autoScroll(clientX, clientY) {\n        const buffer = 10;\n        const container = this.container;\n        const rect = container.getBoundingClientRect();\n        let dx = 0;\n        let dy = 0;\n        if (clientX <= rect.left + buffer) {\n            dx = -buffer;\n        }\n        if (clientY <= rect.top + buffer) {\n            dy = -buffer;\n        }\n        if (clientX >= rect.right - buffer) {\n            dx = buffer;\n        }\n        if (clientY >= rect.bottom - buffer) {\n            dy = buffer;\n        }\n        if (dx !== 0) {\n            container.scrollLeft += dx;\n        }\n        if (dy !== 0) {\n            container.scrollTop += dy;\n        }\n        return {\n            scrollerX: dx,\n            scrollerY: dy,\n        };\n    }\n    addPadding(left, right, top, bottom) {\n        let padding = this.getPadding();\n        this.padding = {\n            left: Math.round(padding.left + (left || 0)),\n            top: Math.round(padding.top + (top || 0)),\n            bottom: Math.round(padding.bottom + (bottom || 0)),\n            right: Math.round(padding.right + (right || 0)),\n        };\n        padding = this.padding;\n        this.$content.css({\n            width: padding.left + this.graph.options.width + padding.right,\n            height: padding.top + this.graph.options.height + padding.bottom,\n        });\n        const container = this.graph.container;\n        container.style.left = `${this.padding.left}px`;\n        container.style.top = `${this.padding.top}px`;\n        return this;\n    }\n    getPadding() {\n        const padding = this.options.padding;\n        if (typeof padding === 'function') {\n            return NumberExt.normalizeSides(FunctionExt.call(padding, this, this));\n        }\n        return NumberExt.normalizeSides(padding);\n    }\n    /**\n     * Returns the untransformed size and origin of the current viewport.\n     */\n    getVisibleArea() {\n        const ctm = this.graph.matrix();\n        const size = this.getClientSize();\n        const box = {\n            x: this.container.scrollLeft || 0,\n            y: this.container.scrollTop || 0,\n            width: size.width,\n            height: size.height,\n        };\n        const area = Dom.transformRectangle(box, ctm.inverse());\n        area.x -= (this.padding.left || 0) / this.sx;\n        area.y -= (this.padding.top || 0) / this.sy;\n        return area;\n    }\n    isCellVisible(cell, options = {}) {\n        const bbox = cell.getBBox();\n        const area = this.getVisibleArea();\n        return options.strict\n            ? area.containsRect(bbox)\n            : area.isIntersectWithRect(bbox);\n    }\n    isPointVisible(point) {\n        return this.getVisibleArea().containsPoint(point);\n    }\n    /**\n     * Lock the current viewport by disabling user scrolling.\n     */\n    lock() {\n        this.$container.css('overflow', 'hidden');\n        return this;\n    }\n    /**\n     * Enable user scrolling if previously locked.\n     */\n    unlock() {\n        this.$container.css('overflow', 'scroll');\n        return this;\n    }\n    onRemove() {\n        this.stopListening();\n    }\n    dispose() {\n        this.$(this.graph.container).insertBefore(this.$container);\n        this.remove();\n    }\n}\n__decorate([\n    View.dispose()\n], Scroller.prototype, \"dispose\", null);\n(function (Scroller) {\n    class Background extends BackgroundManager {\n        constructor(scroller) {\n            super(scroller.graph);\n            this.scroller = scroller;\n            if (scroller.options.background) {\n                this.draw(scroller.options.background);\n            }\n        }\n        get elem() {\n            return this.scroller.background;\n        }\n        init() {\n            this.graph.on('scale', this.update, this);\n            this.graph.on('translate', this.update, this);\n        }\n        updateBackgroundOptions(options) {\n            this.scroller.options.background = options;\n        }\n    }\n    Scroller.Background = Background;\n})(Scroller || (Scroller = {}));\nvar Util;\n(function (Util) {\n    Util.containerClass = 'graph-scroller';\n    Util.panningClass = `${Util.containerClass}-panning`;\n    Util.pannableClass = `${Util.containerClass}-pannable`;\n    Util.pagedClass = `${Util.containerClass}-paged`;\n    Util.contentClass = `${Util.containerClass}-content`;\n    Util.backgroundClass = `${Util.containerClass}-background`;\n    Util.transitionClassName = 'transition-in-progress';\n    Util.transitionEventName = 'transitionend.graph-scroller-transition';\n    Util.defaultOptions = {\n        padding() {\n            const size = this.getClientSize();\n            const minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1;\n            const minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1;\n            const left = Math.max(size.width - minWidth, 0);\n            const top = Math.max(size.height - minHeight, 0);\n            return { left, top, right: left, bottom: top };\n        },\n        minVisibleWidth: 50,\n        minVisibleHeight: 50,\n        pageVisible: false,\n        pageBreak: false,\n        autoResize: true,\n    };\n    function getOptions(options) {\n        const result = ObjectExt.merge({}, Util.defaultOptions, options);\n        if (result.pageWidth == null) {\n            result.pageWidth = options.graph.options.width;\n        }\n        if (result.pageHeight == null) {\n            result.pageHeight = options.graph.options.height;\n        }\n        return result;\n    }\n    Util.getOptions = getOptions;\n})(Util || (Util = {}));\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}