{"ast":null,"code":"import _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { FunctionExt } from '../util';\nimport { Basecoat, Dijkstra } from '../common';\nimport { Rectangle } from '../geometry';\nimport { Cell } from './cell';\nimport { Edge } from './edge';\nimport { Node } from './node';\nimport { Collection } from './collection';\nexport var Model = /*#__PURE__*/function (_Basecoat, _Symbol$toStringTag) {\n  _inherits(Model, _Basecoat);\n\n  var _super = _createSuper(Model);\n\n  function Model() {\n    var _this;\n\n    var cells = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n\n    _classCallCheck(this, Model);\n\n    _this = _super.call(this);\n    _this.batches = {};\n    _this.addings = new WeakMap();\n    _this.nodes = {};\n    _this.edges = {};\n    _this.outgoings = {};\n    _this.incomings = {};\n    _this.collection = new Collection(cells);\n\n    _this.setup();\n\n    return _this;\n  }\n\n  _createClass(Model, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Model.toStringTag;\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(name, args) {\n      this.trigger(name, args);\n      var graph = this.graph;\n\n      if (graph) {\n        if (name === 'sorted' || name === 'reseted' || name === 'updated') {\n          graph.trigger(\"model:\".concat(name), args);\n        } else {\n          graph.trigger(name, args);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this2 = this;\n\n      var collection = this.collection;\n      collection.on('sorted', function () {\n        return _this2.notify('sorted', null);\n      });\n      collection.on('updated', function (args) {\n        return _this2.notify('updated', args);\n      });\n      collection.on('cell:change:zIndex', function () {\n        return _this2.sortOnChangeZ();\n      });\n      collection.on('added', function (_ref) {\n        var cell = _ref.cell;\n\n        _this2.onCellAdded(cell);\n      });\n      collection.on('removed', function (args) {\n        var cell = args.cell;\n\n        _this2.onCellRemoved(cell, args.options); // Should trigger remove-event manually after cell was removed.\n\n\n        _this2.notify('cell:removed', args);\n\n        if (cell.isNode()) {\n          _this2.notify('node:removed', Object.assign(Object.assign({}, args), {\n            node: cell\n          }));\n        } else if (cell.isEdge()) {\n          _this2.notify('edge:removed', Object.assign(Object.assign({}, args), {\n            edge: cell\n          }));\n        }\n      });\n      collection.on('reseted', function (args) {\n        _this2.onReset(args.current);\n\n        _this2.notify('reseted', args);\n      });\n      collection.on('edge:change:source', function (_ref2) {\n        var edge = _ref2.edge;\n        return _this2.onEdgeTerminalChanged(edge, 'source');\n      });\n      collection.on('edge:change:target', function (_ref3) {\n        var edge = _ref3.edge;\n\n        _this2.onEdgeTerminalChanged(edge, 'target');\n      });\n    }\n  }, {\n    key: \"sortOnChangeZ\",\n    value: function sortOnChangeZ() {\n      this.collection.sort();\n    }\n  }, {\n    key: \"onCellAdded\",\n    value: function onCellAdded(cell) {\n      var cellId = cell.id;\n\n      if (cell.isEdge()) {\n        // Auto update edge's parent\n        cell.updateParent();\n        this.edges[cellId] = true;\n        this.onEdgeTerminalChanged(cell, 'source');\n        this.onEdgeTerminalChanged(cell, 'target');\n      } else {\n        this.nodes[cellId] = true;\n      }\n    }\n  }, {\n    key: \"onCellRemoved\",\n    value: function onCellRemoved(cell, options) {\n      var cellId = cell.id;\n\n      if (cell.isEdge()) {\n        delete this.edges[cellId];\n        var source = cell.getSource();\n        var target = cell.getTarget();\n\n        if (source && source.cell) {\n          var cache = this.outgoings[source.cell];\n          var index = cache ? cache.indexOf(cellId) : -1;\n\n          if (index >= 0) {\n            cache.splice(index, 1);\n\n            if (cache.length === 0) {\n              delete this.outgoings[source.cell];\n            }\n          }\n        }\n\n        if (target && target.cell) {\n          var _cache = this.incomings[target.cell];\n\n          var _index = _cache ? _cache.indexOf(cellId) : -1;\n\n          if (_index >= 0) {\n            _cache.splice(_index, 1);\n\n            if (_cache.length === 0) {\n              delete this.incomings[target.cell];\n            }\n          }\n        }\n      } else {\n        delete this.nodes[cellId];\n      }\n\n      if (!options.clear) {\n        if (options.disconnectEdges) {\n          this.disconnectConnectedEdges(cell, options);\n        } else {\n          this.removeConnectedEdges(cell, options);\n        }\n      }\n\n      if (cell.model === this) {\n        cell.model = null;\n      }\n    }\n  }, {\n    key: \"onReset\",\n    value: function onReset(cells) {\n      var _this3 = this;\n\n      this.nodes = {};\n      this.edges = {};\n      this.outgoings = {};\n      this.incomings = {};\n      cells.forEach(function (cell) {\n        return _this3.onCellAdded(cell);\n      });\n    }\n  }, {\n    key: \"onEdgeTerminalChanged\",\n    value: function onEdgeTerminalChanged(edge, type) {\n      var ref = type === 'source' ? this.outgoings : this.incomings;\n      var prev = edge.previous(type);\n\n      if (prev && prev.cell) {\n        var cache = ref[prev.cell];\n        var index = cache ? cache.indexOf(edge.id) : -1;\n\n        if (index >= 0) {\n          cache.splice(index, 1);\n\n          if (cache.length === 0) {\n            delete ref[prev.cell];\n          }\n        }\n      }\n\n      var terminal = edge.getTerminal(type);\n\n      if (terminal && terminal.cell) {\n        var _cache2 = ref[terminal.cell] || [];\n\n        var _index2 = _cache2.indexOf(edge.id);\n\n        if (_index2 === -1) {\n          _cache2.push(edge.id);\n        }\n\n        ref[terminal.cell] = _cache2;\n      }\n    }\n  }, {\n    key: \"prepareCell\",\n    value: function prepareCell(cell, options) {\n      if (!cell.model && (!options || !options.dryrun)) {\n        cell.model = this;\n      }\n\n      if (cell.zIndex == null) {\n        cell.setZIndex(this.getMaxZIndex() + 1, {\n          silent: true\n        });\n      }\n\n      return cell;\n    }\n  }, {\n    key: \"resetCells\",\n    value: function resetCells(cells) {\n      var _this4 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      // Do not update model at this time. Because if we just update the graph\n      // with the same json-data, the edge will reference to the old nodes.\n      cells.map(function (cell) {\n        return _this4.prepareCell(cell, Object.assign(Object.assign({}, options), {\n          dryrun: true\n        }));\n      });\n      this.collection.reset(cells, options); // Update model and trigger edge update it's references\n\n      cells.map(function (cell) {\n        return _this4.prepareCell(cell, {\n          options: options\n        });\n      });\n      return this;\n    }\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var raw = this.getCells();\n\n      if (raw.length === 0) {\n        return this;\n      }\n\n      var localOptions = Object.assign(Object.assign({}, options), {\n        clear: true\n      });\n      this.batchUpdate('clear', function () {\n        // The nodes come after the edges.\n        var cells = raw.sort(function (a, b) {\n          var v1 = a.isEdge() ? 1 : 2;\n          var v2 = b.isEdge() ? 1 : 2;\n          return v1 - v2;\n        });\n\n        while (cells.length > 0) {\n          // Note that all the edges are removed first, so it's safe to\n          // remove the nodes without removing the connected edges first.\n          var cell = cells.shift();\n\n          if (cell) {\n            cell.remove(localOptions);\n          }\n        }\n      }, localOptions);\n      return this;\n    }\n  }, {\n    key: \"addNode\",\n    value: function addNode(metadata) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var node = Node.isNode(metadata) ? metadata : this.createNode(metadata);\n      this.addCell(node, options);\n      return node;\n    }\n  }, {\n    key: \"createNode\",\n    value: function createNode(metadata) {\n      return Node.create(metadata);\n    }\n  }, {\n    key: \"addEdge\",\n    value: function addEdge(metadata) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var edge = Edge.isEdge(metadata) ? metadata : this.createEdge(metadata);\n      this.addCell(edge, options);\n      return edge;\n    }\n  }, {\n    key: \"createEdge\",\n    value: function createEdge(metadata) {\n      return Edge.create(metadata);\n    }\n  }, {\n    key: \"addCell\",\n    value: function addCell(cell) {\n      var _this5 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (Array.isArray(cell)) {\n        return this.addCells(cell, options);\n      }\n\n      if (!this.collection.has(cell) && !this.addings.has(cell)) {\n        this.addings.set(cell, true);\n        this.collection.add(this.prepareCell(cell, options), options);\n        cell.eachChild(function (child) {\n          return _this5.addCell(child, options);\n        });\n        this.addings.delete(cell);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"addCells\",\n    value: function addCells(cells) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var count = cells.length;\n\n      if (count === 0) {\n        return this;\n      }\n\n      var localOptions = Object.assign(Object.assign({}, options), {\n        position: count - 1,\n        maxPosition: count - 1\n      });\n      this.startBatch('add', Object.assign(Object.assign({}, localOptions), {\n        cells: cells\n      }));\n      cells.forEach(function (cell) {\n        _this6.addCell(cell, localOptions);\n\n        localOptions.position -= 1;\n      });\n      this.stopBatch('add', Object.assign(Object.assign({}, localOptions), {\n        cells: cells\n      }));\n      return this;\n    }\n  }, {\n    key: \"removeCell\",\n    value: function removeCell(obj) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var cell = typeof obj === 'string' ? this.getCell(obj) : obj;\n\n      if (cell && this.has(cell)) {\n        return this.collection.remove(cell, options);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"removeCells\",\n    value: function removeCells(cells) {\n      var _this7 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (cells.length) {\n        return this.batchUpdate('remove', function () {\n          return cells.map(function (cell) {\n            return _this7.removeCell(cell, options);\n          });\n        });\n      }\n\n      return [];\n    }\n  }, {\n    key: \"removeConnectedEdges\",\n    value: function removeConnectedEdges(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var edges = this.getConnectedEdges(cell);\n      edges.forEach(function (edge) {\n        edge.remove(options);\n      });\n      return edges;\n    }\n  }, {\n    key: \"disconnectConnectedEdges\",\n    value: function disconnectConnectedEdges(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var cellId = typeof cell === 'string' ? cell : cell.id;\n      this.getConnectedEdges(cell).forEach(function (edge) {\n        var sourceCell = edge.getSourceCell();\n        var targetCell = edge.getTargetCell();\n\n        if (sourceCell && sourceCell.id === cellId) {\n          edge.setSource({\n            x: 0,\n            y: 0\n          }, options);\n        }\n\n        if (targetCell && targetCell.id === cellId) {\n          edge.setTarget({\n            x: 0,\n            y: 0\n          }, options);\n        }\n      });\n    }\n  }, {\n    key: \"has\",\n    value: function has(obj) {\n      return this.collection.has(obj);\n    }\n  }, {\n    key: \"total\",\n    value: function total() {\n      return this.collection.length;\n    }\n  }, {\n    key: \"indexOf\",\n    value: function indexOf(cell) {\n      return this.collection.indexOf(cell);\n    }\n    /**\n     * Returns a cell from the graph by its id.\n     */\n\n  }, {\n    key: \"getCell\",\n    value: function getCell(id) {\n      return this.collection.get(id);\n    }\n    /**\n     * Returns all the nodes and edges in the graph.\n     */\n\n  }, {\n    key: \"getCells\",\n    value: function getCells() {\n      return this.collection.toArray();\n    }\n    /**\n     * Returns the first cell (node or edge) in the graph. The first cell is\n     * defined as the cell with the lowest `zIndex`.\n     */\n\n  }, {\n    key: \"getFirstCell\",\n    value: function getFirstCell() {\n      return this.collection.first();\n    }\n    /**\n     * Returns the last cell (node or edge) in the graph. The last cell is\n     * defined as the cell with the highest `zIndex`.\n     */\n\n  }, {\n    key: \"getLastCell\",\n    value: function getLastCell() {\n      return this.collection.last();\n    }\n    /**\n     * Returns the lowest `zIndex` value in the graph.\n     */\n\n  }, {\n    key: \"getMinZIndex\",\n    value: function getMinZIndex() {\n      var first = this.collection.first();\n      return first ? first.getZIndex() || 0 : 0;\n    }\n    /**\n     * Returns the highest `zIndex` value in the graph.\n     */\n\n  }, {\n    key: \"getMaxZIndex\",\n    value: function getMaxZIndex() {\n      var last = this.collection.last();\n      return last ? last.getZIndex() || 0 : 0;\n    }\n  }, {\n    key: \"getCellsFromCache\",\n    value: function getCellsFromCache(cache) {\n      var _this8 = this;\n\n      return cache ? Object.keys(cache).map(function (id) {\n        return _this8.getCell(id);\n      }).filter(function (cell) {\n        return cell != null;\n      }) : [];\n    }\n    /**\n     * Returns all the nodes in the graph.\n     */\n\n  }, {\n    key: \"getNodes\",\n    value: function getNodes() {\n      return this.getCellsFromCache(this.nodes);\n    }\n    /**\n     * Returns all the edges in the graph.\n     */\n\n  }, {\n    key: \"getEdges\",\n    value: function getEdges() {\n      return this.getCellsFromCache(this.edges);\n    }\n    /**\n     * Returns all outgoing edges for the node.\n     */\n\n  }, {\n    key: \"getOutgoingEdges\",\n    value: function getOutgoingEdges(cell) {\n      var _this9 = this;\n\n      var cellId = typeof cell === 'string' ? cell : cell.id;\n      var cellIds = this.outgoings[cellId];\n      return cellIds ? cellIds.map(function (id) {\n        return _this9.getCell(id);\n      }).filter(function (cell) {\n        return cell && cell.isEdge();\n      }) : null;\n    }\n    /**\n     * Returns all incoming edges for the node.\n     */\n\n  }, {\n    key: \"getIncomingEdges\",\n    value: function getIncomingEdges(cell) {\n      var _this10 = this;\n\n      var cellId = typeof cell === 'string' ? cell : cell.id;\n      var cellIds = this.incomings[cellId];\n      return cellIds ? cellIds.map(function (id) {\n        return _this10.getCell(id);\n      }).filter(function (cell) {\n        return cell && cell.isEdge();\n      }) : null;\n    }\n    /**\n     * Returns edges connected with cell.\n     */\n\n  }, {\n    key: \"getConnectedEdges\",\n    value: function getConnectedEdges(cell) {\n      var _this11 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var result = [];\n      var node = typeof cell === 'string' ? this.getCell(cell) : cell;\n\n      if (node == null) {\n        return result;\n      }\n\n      var cache = {};\n      var indirect = options.indirect;\n      var incoming = options.incoming;\n      var outgoing = options.outgoing;\n\n      if (incoming == null && outgoing == null) {\n        incoming = outgoing = true;\n      }\n\n      var collect = function collect(cell, isOutgoing) {\n        var edges = isOutgoing ? _this11.getOutgoingEdges(cell) : _this11.getIncomingEdges(cell);\n\n        if (edges != null) {\n          edges.forEach(function (edge) {\n            if (cache[edge.id]) {\n              return;\n            }\n\n            result.push(edge);\n            cache[edge.id] = true;\n\n            if (indirect) {\n              if (incoming) {\n                collect(edge, false);\n              }\n\n              if (outgoing) {\n                collect(edge, true);\n              }\n            }\n          });\n        }\n\n        if (indirect && cell.isEdge()) {\n          var terminal = isOutgoing ? cell.getTargetCell() : cell.getSourceCell();\n\n          if (terminal && terminal.isEdge()) {\n            if (!cache[terminal.id]) {\n              result.push(terminal);\n              collect(terminal, isOutgoing);\n            }\n          }\n        }\n      };\n\n      if (outgoing) {\n        collect(node, true);\n      }\n\n      if (incoming) {\n        collect(node, false);\n      }\n\n      if (options.deep) {\n        var descendants = node.getDescendants({\n          deep: true\n        });\n        var embedsCache = {};\n        descendants.forEach(function (cell) {\n          if (cell.isNode()) {\n            embedsCache[cell.id] = true;\n          }\n        });\n\n        var collectSub = function collectSub(cell, isOutgoing) {\n          var edges = isOutgoing ? _this11.getOutgoingEdges(cell.id) : _this11.getIncomingEdges(cell.id);\n\n          if (edges != null) {\n            edges.forEach(function (edge) {\n              if (!cache[edge.id]) {\n                var sourceCell = edge.getSourceCell();\n                var targetCell = edge.getTargetCell();\n\n                if (!options.enclosed && sourceCell && embedsCache[sourceCell.id] && targetCell && embedsCache[targetCell.id]) {\n                  return;\n                }\n\n                result.push(edge);\n                cache[edge.id] = true;\n              }\n            });\n          }\n        };\n\n        descendants.forEach(function (cell) {\n          if (cell.isEdge()) {\n            return;\n          }\n\n          if (outgoing) {\n            collectSub(cell, true);\n          }\n\n          if (incoming) {\n            collectSub(cell, false);\n          }\n        });\n      }\n\n      return result;\n    }\n  }, {\n    key: \"isBoundary\",\n    value: function isBoundary(cell, isOrigin) {\n      var node = typeof cell === 'string' ? this.getCell(cell) : cell;\n      var arr = isOrigin ? this.getIncomingEdges(node) : this.getOutgoingEdges(node);\n      return arr == null || arr.length === 0;\n    }\n  }, {\n    key: \"getBoundaryNodes\",\n    value: function getBoundaryNodes(isOrigin) {\n      var _this12 = this;\n\n      var result = [];\n      Object.keys(this.nodes).forEach(function (nodeId) {\n        if (_this12.isBoundary(nodeId, isOrigin)) {\n          var node = _this12.getCell(nodeId);\n\n          if (node) {\n            result.push(node);\n          }\n        }\n      });\n      return result;\n    }\n    /**\n     * Returns an array of all the roots of the graph.\n     */\n\n  }, {\n    key: \"getRoots\",\n    value: function getRoots() {\n      return this.getBoundaryNodes(true);\n    }\n    /**\n     * Returns an array of all the leafs of the graph.\n     */\n\n  }, {\n    key: \"getLeafs\",\n    value: function getLeafs() {\n      return this.getBoundaryNodes(false);\n    }\n    /**\n     * Returns `true` if the node is a root node, i.e. there is no edges\n     * coming to the node.\n     */\n\n  }, {\n    key: \"isRoot\",\n    value: function isRoot(cell) {\n      return this.isBoundary(cell, true);\n    }\n    /**\n     * Returns `true` if the node is a leaf node, i.e. there is no edges\n     * going out from the node.\n     */\n\n  }, {\n    key: \"isLeaf\",\n    value: function isLeaf(cell) {\n      return this.isBoundary(cell, false);\n    }\n    /**\n     * Returns all the neighbors of node in the graph. Neighbors are all\n     * the nodes connected to node via either incoming or outgoing edge.\n     */\n\n  }, {\n    key: \"getNeighbors\",\n    value: function getNeighbors(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var incoming = options.incoming;\n      var outgoing = options.outgoing;\n\n      if (incoming == null && outgoing == null) {\n        incoming = outgoing = true;\n      }\n\n      var edges = this.getConnectedEdges(cell, options);\n      var map = edges.reduce(function (memo, edge) {\n        var hasLoop = edge.hasLoop(options);\n        var sourceCell = edge.getSourceCell();\n        var targetCell = edge.getTargetCell();\n\n        if (incoming && sourceCell && sourceCell.isNode() && !memo[sourceCell.id]) {\n          if (hasLoop || sourceCell !== cell && (!options.deep || !sourceCell.isDescendantOf(cell))) {\n            memo[sourceCell.id] = sourceCell;\n          }\n        }\n\n        if (outgoing && targetCell && targetCell.isNode() && !memo[targetCell.id]) {\n          if (hasLoop || targetCell !== cell && (!options.deep || !targetCell.isDescendantOf(cell))) {\n            memo[targetCell.id] = targetCell;\n          }\n        }\n\n        return memo;\n      }, {});\n\n      if (cell.isEdge()) {\n        if (incoming) {\n          var sourceCell = cell.getSourceCell();\n\n          if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {\n            map[sourceCell.id] = sourceCell;\n          }\n        }\n\n        if (outgoing) {\n          var targetCell = cell.getTargetCell();\n\n          if (targetCell && targetCell.isNode() && !map[targetCell.id]) {\n            map[targetCell.id] = targetCell;\n          }\n        }\n      }\n\n      return Object.keys(map).map(function (id) {\n        return map[id];\n      });\n    }\n    /**\n     * Returns `true` if `cell2` is a neighbor of `cell1`.\n     */\n\n  }, {\n    key: \"isNeighbor\",\n    value: function isNeighbor(cell1, cell2) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var incoming = options.incoming;\n      var outgoing = options.outgoing;\n\n      if (incoming == null && outgoing == null) {\n        incoming = outgoing = true;\n      }\n\n      return this.getConnectedEdges(cell1, options).some(function (edge) {\n        var sourceCell = edge.getSourceCell();\n        var targetCell = edge.getTargetCell();\n\n        if (incoming && sourceCell && sourceCell.id === cell2.id) {\n          return true;\n        }\n\n        if (outgoing && targetCell && targetCell.id === cell2.id) {\n          return true;\n        }\n\n        return false;\n      });\n    }\n  }, {\n    key: \"getSuccessors\",\n    value: function getSuccessors(cell) {\n      var _this13 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var successors = [];\n      this.search(cell, function (curr, distance) {\n        if (curr !== cell && _this13.matchDistance(distance, options.distance)) {\n          successors.push(curr);\n        }\n      }, Object.assign(Object.assign({}, options), {\n        outgoing: true\n      }));\n      return successors;\n    }\n    /**\n     * Returns `true` if `cell2` is a successor of `cell1`.\n     */\n\n  }, {\n    key: \"isSuccessor\",\n    value: function isSuccessor(cell1, cell2) {\n      var _this14 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var result = false;\n      this.search(cell1, function (curr, distance) {\n        if (curr === cell2 && curr !== cell1 && _this14.matchDistance(distance, options.distance)) {\n          result = true;\n          return false;\n        }\n      }, Object.assign(Object.assign({}, options), {\n        outgoing: true\n      }));\n      return result;\n    }\n  }, {\n    key: \"getPredecessors\",\n    value: function getPredecessors(cell) {\n      var _this15 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var predecessors = [];\n      this.search(cell, function (curr, distance) {\n        if (curr !== cell && _this15.matchDistance(distance, options.distance)) {\n          predecessors.push(curr);\n        }\n      }, Object.assign(Object.assign({}, options), {\n        incoming: true\n      }));\n      return predecessors;\n    }\n    /**\n     * Returns `true` if `cell2` is a predecessor of `cell1`.\n     */\n\n  }, {\n    key: \"isPredecessor\",\n    value: function isPredecessor(cell1, cell2) {\n      var _this16 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var result = false;\n      this.search(cell1, function (curr, distance) {\n        if (curr === cell2 && curr !== cell1 && _this16.matchDistance(distance, options.distance)) {\n          result = true;\n          return false;\n        }\n      }, Object.assign(Object.assign({}, options), {\n        incoming: true\n      }));\n      return result;\n    }\n  }, {\n    key: \"matchDistance\",\n    value: function matchDistance(distance, preset) {\n      if (preset == null) {\n        return true;\n      }\n\n      if (typeof preset === 'function') {\n        return preset(distance);\n      }\n\n      if (Array.isArray(preset) && preset.includes(distance)) {\n        return true;\n      }\n\n      return distance === preset;\n    }\n    /**\n     * Returns the common ancestor of the passed cells.\n     */\n\n  }, {\n    key: \"getCommonAncestor\",\n    value: function getCommonAncestor() {\n      var arr = [];\n\n      for (var _len = arguments.length, cells = new Array(_len), _key = 0; _key < _len; _key++) {\n        cells[_key] = arguments[_key];\n      }\n\n      cells.forEach(function (item) {\n        if (item) {\n          if (Array.isArray(item)) {\n            arr.push.apply(arr, _toConsumableArray(item));\n          } else {\n            arr.push(item);\n          }\n        }\n      });\n      return Cell.getCommonAncestor.apply(Cell, arr);\n    }\n    /**\n     * Returns an array of cells that result from finding nodes/edges that\n     * are connected to any of the cells in the cells array. This function\n     * loops over cells and if the current cell is a edge, it collects its\n     * source/target nodes; if it is an node, it collects its incoming and\n     * outgoing edges if both the edge terminal (source/target) are in the\n     * cells array.\n     */\n\n  }, {\n    key: \"getSubGraph\",\n    value: function getSubGraph(cells) {\n      var _this17 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var subgraph = [];\n      var cache = {};\n      var nodes = [];\n      var edges = [];\n\n      var collect = function collect(cell) {\n        if (!cache[cell.id]) {\n          subgraph.push(cell);\n          cache[cell.id] = cell;\n\n          if (cell.isEdge()) {\n            edges.push(cell);\n          }\n\n          if (cell.isNode()) {\n            nodes.push(cell);\n          }\n        }\n      };\n\n      cells.forEach(function (cell) {\n        collect(cell);\n\n        if (options.deep) {\n          var descendants = cell.getDescendants({\n            deep: true\n          });\n          descendants.forEach(function (descendant) {\n            return collect(descendant);\n          });\n        }\n      });\n      edges.forEach(function (edge) {\n        // For edges, include their source & target\n        var sourceCell = edge.getSourceCell();\n        var targetCell = edge.getTargetCell();\n\n        if (sourceCell && !cache[sourceCell.id]) {\n          subgraph.push(sourceCell);\n          cache[sourceCell.id] = sourceCell;\n\n          if (sourceCell.isNode()) {\n            nodes.push(sourceCell);\n          }\n        }\n\n        if (targetCell && !cache[targetCell.id]) {\n          subgraph.push(targetCell);\n          cache[targetCell.id] = targetCell;\n\n          if (targetCell.isNode()) {\n            nodes.push(targetCell);\n          }\n        }\n      });\n      nodes.forEach(function (node) {\n        // For nodes, include their connected edges if their source/target\n        // is in the subgraph.\n        var edges = _this17.getConnectedEdges(node, options);\n\n        edges.forEach(function (edge) {\n          var sourceCell = edge.getSourceCell();\n          var targetCell = edge.getTargetCell();\n\n          if (!cache[edge.id] && sourceCell && cache[sourceCell.id] && targetCell && cache[targetCell.id]) {\n            subgraph.push(edge);\n            cache[edge.id] = edge;\n          }\n        });\n      });\n      return subgraph;\n    }\n    /**\n     * Clones the whole subgraph (including all the connected links whose\n     * source/target is in the subgraph). If `options.deep` is `true`, also\n     * take into account all the embedded cells of all the subgraph cells.\n     *\n     * Returns a map of the form: { [original cell ID]: [clone] }.\n     */\n\n  }, {\n    key: \"cloneSubGraph\",\n    value: function cloneSubGraph(cells) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var subgraph = this.getSubGraph(cells, options);\n      return this.cloneCells(subgraph);\n    }\n  }, {\n    key: \"cloneCells\",\n    value: function cloneCells(cells) {\n      return Cell.cloneCells(cells);\n    }\n  }, {\n    key: \"getNodesFromPoint\",\n    value: function getNodesFromPoint(x, y) {\n      var p = typeof x === 'number' ? {\n        x: x,\n        y: y || 0\n      } : x;\n      return this.getNodes().filter(function (node) {\n        return node.getBBox().containsPoint(p);\n      });\n    }\n  }, {\n    key: \"getNodesInArea\",\n    value: function getNodesInArea(x, y, w, h, options) {\n      var rect = typeof x === 'number' ? new Rectangle(x, y, w, h) : Rectangle.create(x);\n      var opts = typeof x === 'number' ? options : y;\n      var strict = opts && opts.strict;\n      return this.getNodes().filter(function (node) {\n        var bbox = node.getBBox();\n        return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);\n      });\n    }\n  }, {\n    key: \"getEdgesInArea\",\n    value: function getEdgesInArea(x, y, w, h, options) {\n      var rect = typeof x === 'number' ? new Rectangle(x, y, w, h) : Rectangle.create(x);\n      var opts = typeof x === 'number' ? options : y;\n      var strict = opts && opts.strict;\n      return this.getEdges().filter(function (edge) {\n        var bbox = edge.getBBox();\n\n        if (bbox.width === 0) {\n          bbox.inflate(1, 0);\n        } else if (bbox.height === 0) {\n          bbox.inflate(0, 1);\n        }\n\n        return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);\n      });\n    }\n  }, {\n    key: \"getNodesUnderNode\",\n    value: function getNodesUnderNode(node) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var bbox = node.getBBox();\n      var nodes = options.by == null || options.by === 'bbox' ? this.getNodesInArea(bbox) : this.getNodesFromPoint(bbox[options.by]);\n      return nodes.filter(function (curr) {\n        return node.id !== curr.id && !curr.isDescendantOf(node);\n      });\n    }\n    /**\n     * Returns the bounding box that surrounds all cells in the graph.\n     */\n\n  }, {\n    key: \"getAllCellsBBox\",\n    value: function getAllCellsBBox() {\n      return this.getCellsBBox(this.getCells());\n    }\n    /**\n     * Returns the bounding box that surrounds all the given cells.\n     */\n\n  }, {\n    key: \"getCellsBBox\",\n    value: function getCellsBBox(cells) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return Cell.getCellsBBox(cells, options);\n    } // #region search\n\n  }, {\n    key: \"search\",\n    value: function search(cell, iterator) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (options.breadthFirst) {\n        this.breadthFirstSearch(cell, iterator, options);\n      } else {\n        this.depthFirstSearch(cell, iterator, options);\n      }\n    }\n  }, {\n    key: \"breadthFirstSearch\",\n    value: function breadthFirstSearch(cell, iterator) {\n      var _this18 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var queue = [];\n      var visited = {};\n      var distance = {};\n      queue.push(cell);\n      distance[cell.id] = 0;\n\n      var _loop = function _loop() {\n        var next = queue.shift();\n\n        if (next == null || visited[next.id]) {\n          return \"continue\";\n        }\n\n        visited[next.id] = true;\n\n        if (FunctionExt.call(iterator, _this18, next, distance[next.id]) === false) {\n          return \"continue\";\n        }\n\n        var neighbors = _this18.getNeighbors(next, options);\n\n        neighbors.forEach(function (neighbor) {\n          distance[neighbor.id] = distance[next.id] + 1;\n          queue.push(neighbor);\n        });\n      };\n\n      while (queue.length > 0) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      }\n    }\n  }, {\n    key: \"depthFirstSearch\",\n    value: function depthFirstSearch(cell, iterator) {\n      var _this19 = this;\n\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var queue = [];\n      var visited = {};\n      var distance = {};\n      queue.push(cell);\n      distance[cell.id] = 0;\n\n      var _loop2 = function _loop2() {\n        var next = queue.pop();\n\n        if (next == null || visited[next.id]) {\n          return \"continue\";\n        }\n\n        visited[next.id] = true;\n\n        if (FunctionExt.call(iterator, _this19, next, distance[next.id]) === false) {\n          return \"continue\";\n        }\n\n        var neighbors = _this19.getNeighbors(next, options);\n\n        var lastIndex = queue.length;\n        neighbors.forEach(function (neighbor) {\n          distance[neighbor.id] = distance[next.id] + 1;\n          queue.splice(lastIndex, 0, neighbor);\n        });\n      };\n\n      while (queue.length > 0) {\n        var _ret2 = _loop2();\n\n        if (_ret2 === \"continue\") continue;\n      }\n    } // #endregion\n    // #region shortest path\n\n    /** *\n     * Returns an array of IDs of nodes on the shortest\n     * path between source and target.\n     */\n\n  }, {\n    key: \"getShortestPath\",\n    value: function getShortestPath(source, target) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var adjacencyList = {};\n      this.getEdges().forEach(function (edge) {\n        var sourceId = edge.getSourceCellId();\n        var targetId = edge.getTargetCellId();\n\n        if (sourceId && targetId) {\n          if (!adjacencyList[sourceId]) {\n            adjacencyList[sourceId] = [];\n          }\n\n          if (!adjacencyList[targetId]) {\n            adjacencyList[targetId] = [];\n          }\n\n          adjacencyList[sourceId].push(targetId);\n\n          if (!options.directed) {\n            adjacencyList[targetId].push(sourceId);\n          }\n        }\n      });\n      var sourceId = typeof source === 'string' ? source : source.id;\n      var previous = Dijkstra.run(adjacencyList, sourceId, options.weight);\n      var path = [];\n      var targetId = typeof target === 'string' ? target : target.id;\n\n      if (previous[targetId]) {\n        path.push(targetId);\n      }\n\n      while (targetId = previous[targetId]) {\n        path.unshift(targetId);\n      }\n\n      return path;\n    } // #endregion\n    // #region transform\n\n    /**\n     * Translate all cells in the graph by `tx` and `ty` pixels.\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty, options) {\n      this.getCells().filter(function (cell) {\n        return !cell.hasParent();\n      }).forEach(function (cell) {\n        return cell.translate(tx, ty, options);\n      });\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(width, height, options) {\n      return this.resizeCells(width, height, this.getCells(), options);\n    }\n  }, {\n    key: \"resizeCells\",\n    value: function resizeCells(width, height, cells) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var bbox = this.getCellsBBox(cells);\n\n      if (bbox) {\n        var sx = Math.max(width / bbox.width, 0);\n        var sy = Math.max(height / bbox.height, 0);\n        var origin = bbox.getOrigin();\n        cells.forEach(function (cell) {\n          return cell.scale(sx, sy, origin, options);\n        });\n      }\n\n      return this;\n    } // #endregion\n    // #region serialize/deserialize\n\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return Model.toJSON(this.getCells(), options);\n    }\n  }, {\n    key: \"parseJSON\",\n    value: function parseJSON(data) {\n      return Model.fromJSON(data);\n    }\n  }, {\n    key: \"fromJSON\",\n    value: function fromJSON(data) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var cells = this.parseJSON(data);\n      this.resetCells(cells, options);\n      return this;\n    } // #endregion\n    // #region batch\n\n  }, {\n    key: \"startBatch\",\n    value: function startBatch(name) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.batches[name] = (this.batches[name] || 0) + 1;\n      this.notify('batch:start', {\n        name: name,\n        data: data\n      });\n      return this;\n    }\n  }, {\n    key: \"stopBatch\",\n    value: function stopBatch(name) {\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.batches[name] = (this.batches[name] || 0) - 1;\n      this.notify('batch:stop', {\n        name: name,\n        data: data\n      });\n      return this;\n    }\n  }, {\n    key: \"batchUpdate\",\n    value: function batchUpdate(name, execute) {\n      var data = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.startBatch(name, data);\n      var result = execute();\n      this.stopBatch(name, data);\n      return result;\n    }\n  }, {\n    key: \"hasActiveBatch\",\n    value: function hasActiveBatch() {\n      var _this20 = this;\n\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : Object.keys(this.batches);\n      var names = Array.isArray(name) ? name : [name];\n      return names.some(function (batch) {\n        return _this20.batches[batch] > 0;\n      });\n    }\n  }]);\n\n  return Model;\n}(Basecoat, Symbol.toStringTag);\n\n(function (Model) {\n  Model.toStringTag = \"X6.\".concat(Model.name);\n\n  function isModel(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Model) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var model = instance;\n\n    if ((tag == null || tag === Model.toStringTag) && typeof model.addNode === 'function' && typeof model.addEdge === 'function' && model.collection != null) {\n      return true;\n    }\n\n    return false;\n  }\n\n  Model.isModel = isModel;\n})(Model || (Model = {}));\n\n(function (Model) {\n  function toJSON(cells) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    return {\n      cells: cells.map(function (cell) {\n        return cell.toJSON(options);\n      })\n    };\n  }\n\n  Model.toJSON = toJSON;\n\n  function fromJSON(data) {\n    var cells = [];\n\n    if (Array.isArray(data)) {\n      cells.push.apply(cells, _toConsumableArray(data));\n    } else {\n      if (data.cells) {\n        cells.push.apply(cells, _toConsumableArray(data.cells));\n      }\n\n      if (data.nodes) {\n        data.nodes.forEach(function (node) {\n          if (node.shape == null) {\n            node.shape = 'rect';\n          }\n\n          cells.push(node);\n        });\n      }\n\n      if (data.edges) {\n        data.edges.forEach(function (edge) {\n          if (edge.shape == null) {\n            edge.shape = 'edge';\n          }\n\n          cells.push(edge);\n        });\n      }\n    }\n\n    return cells.map(function (cell) {\n      var type = cell.shape;\n\n      if (type) {\n        if (Node.registry.exist(type)) {\n          return Node.create(cell);\n        }\n\n        if (Edge.registry.exist(type)) {\n          return Edge.create(cell);\n        }\n      }\n\n      throw new Error('The `shape` should be specipied when creating a node/edge instance');\n    });\n  }\n\n  Model.fromJSON = fromJSON;\n})(Model || (Model = {}));","map":{"version":3,"sources":["../../src/model/model.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { FunctionExt } from '../util';\nimport { Basecoat, Dijkstra } from '../common';\nimport { Rectangle } from '../geometry';\nimport { Cell } from './cell';\nimport { Edge } from './edge';\nimport { Node } from './node';\nimport { Collection } from './collection';\nexport class Model extends Basecoat {\n    constructor(cells = []) {\n        super();\n        this.batches = {};\n        this.addings = new WeakMap();\n        this.nodes = {};\n        this.edges = {};\n        this.outgoings = {};\n        this.incomings = {};\n        this.collection = new Collection(cells);\n        this.setup();\n    }\n    get [Symbol.toStringTag]() {\n        return Model.toStringTag;\n    }\n    notify(name, args) {\n        this.trigger(name, args);\n        const graph = this.graph;\n        if (graph) {\n            if (name === 'sorted' || name === 'reseted' || name === 'updated') {\n                graph.trigger(`model:${name}`, args);\n            }\n            else {\n                graph.trigger(name, args);\n            }\n        }\n        return this;\n    }\n    setup() {\n        const collection = this.collection;\n        collection.on('sorted', () => this.notify('sorted', null));\n        collection.on('updated', (args) => this.notify('updated', args));\n        collection.on('cell:change:zIndex', () => this.sortOnChangeZ());\n        collection.on('added', ({ cell }) => {\n            this.onCellAdded(cell);\n        });\n        collection.on('removed', (args) => {\n            const cell = args.cell;\n            this.onCellRemoved(cell, args.options);\n            // Should trigger remove-event manually after cell was removed.\n            this.notify('cell:removed', args);\n            if (cell.isNode()) {\n                this.notify('node:removed', Object.assign(Object.assign({}, args), { node: cell }));\n            }\n            else if (cell.isEdge()) {\n                this.notify('edge:removed', Object.assign(Object.assign({}, args), { edge: cell }));\n            }\n        });\n        collection.on('reseted', (args) => {\n            this.onReset(args.current);\n            this.notify('reseted', args);\n        });\n        collection.on('edge:change:source', ({ edge }) => this.onEdgeTerminalChanged(edge, 'source'));\n        collection.on('edge:change:target', ({ edge }) => {\n            this.onEdgeTerminalChanged(edge, 'target');\n        });\n    }\n    sortOnChangeZ() {\n        this.collection.sort();\n    }\n    onCellAdded(cell) {\n        const cellId = cell.id;\n        if (cell.isEdge()) {\n            // Auto update edge's parent\n            cell.updateParent();\n            this.edges[cellId] = true;\n            this.onEdgeTerminalChanged(cell, 'source');\n            this.onEdgeTerminalChanged(cell, 'target');\n        }\n        else {\n            this.nodes[cellId] = true;\n        }\n    }\n    onCellRemoved(cell, options) {\n        const cellId = cell.id;\n        if (cell.isEdge()) {\n            delete this.edges[cellId];\n            const source = cell.getSource();\n            const target = cell.getTarget();\n            if (source && source.cell) {\n                const cache = this.outgoings[source.cell];\n                const index = cache ? cache.indexOf(cellId) : -1;\n                if (index >= 0) {\n                    cache.splice(index, 1);\n                    if (cache.length === 0) {\n                        delete this.outgoings[source.cell];\n                    }\n                }\n            }\n            if (target && target.cell) {\n                const cache = this.incomings[target.cell];\n                const index = cache ? cache.indexOf(cellId) : -1;\n                if (index >= 0) {\n                    cache.splice(index, 1);\n                    if (cache.length === 0) {\n                        delete this.incomings[target.cell];\n                    }\n                }\n            }\n        }\n        else {\n            delete this.nodes[cellId];\n        }\n        if (!options.clear) {\n            if (options.disconnectEdges) {\n                this.disconnectConnectedEdges(cell, options);\n            }\n            else {\n                this.removeConnectedEdges(cell, options);\n            }\n        }\n        if (cell.model === this) {\n            cell.model = null;\n        }\n    }\n    onReset(cells) {\n        this.nodes = {};\n        this.edges = {};\n        this.outgoings = {};\n        this.incomings = {};\n        cells.forEach((cell) => this.onCellAdded(cell));\n    }\n    onEdgeTerminalChanged(edge, type) {\n        const ref = type === 'source' ? this.outgoings : this.incomings;\n        const prev = edge.previous(type);\n        if (prev && prev.cell) {\n            const cache = ref[prev.cell];\n            const index = cache ? cache.indexOf(edge.id) : -1;\n            if (index >= 0) {\n                cache.splice(index, 1);\n                if (cache.length === 0) {\n                    delete ref[prev.cell];\n                }\n            }\n        }\n        const terminal = edge.getTerminal(type);\n        if (terminal && terminal.cell) {\n            const cache = ref[terminal.cell] || [];\n            const index = cache.indexOf(edge.id);\n            if (index === -1) {\n                cache.push(edge.id);\n            }\n            ref[terminal.cell] = cache;\n        }\n    }\n    prepareCell(cell, options) {\n        if (!cell.model && (!options || !options.dryrun)) {\n            cell.model = this;\n        }\n        if (cell.zIndex == null) {\n            cell.setZIndex(this.getMaxZIndex() + 1, { silent: true });\n        }\n        return cell;\n    }\n    resetCells(cells, options = {}) {\n        // Do not update model at this time. Because if we just update the graph\n        // with the same json-data, the edge will reference to the old nodes.\n        cells.map((cell) => this.prepareCell(cell, Object.assign(Object.assign({}, options), { dryrun: true })));\n        this.collection.reset(cells, options);\n        // Update model and trigger edge update it's references\n        cells.map((cell) => this.prepareCell(cell, { options }));\n        return this;\n    }\n    clear(options = {}) {\n        const raw = this.getCells();\n        if (raw.length === 0) {\n            return this;\n        }\n        const localOptions = Object.assign(Object.assign({}, options), { clear: true });\n        this.batchUpdate('clear', () => {\n            // The nodes come after the edges.\n            const cells = raw.sort((a, b) => {\n                const v1 = a.isEdge() ? 1 : 2;\n                const v2 = b.isEdge() ? 1 : 2;\n                return v1 - v2;\n            });\n            while (cells.length > 0) {\n                // Note that all the edges are removed first, so it's safe to\n                // remove the nodes without removing the connected edges first.\n                const cell = cells.shift();\n                if (cell) {\n                    cell.remove(localOptions);\n                }\n            }\n        }, localOptions);\n        return this;\n    }\n    addNode(metadata, options = {}) {\n        const node = Node.isNode(metadata) ? metadata : this.createNode(metadata);\n        this.addCell(node, options);\n        return node;\n    }\n    createNode(metadata) {\n        return Node.create(metadata);\n    }\n    addEdge(metadata, options = {}) {\n        const edge = Edge.isEdge(metadata) ? metadata : this.createEdge(metadata);\n        this.addCell(edge, options);\n        return edge;\n    }\n    createEdge(metadata) {\n        return Edge.create(metadata);\n    }\n    addCell(cell, options = {}) {\n        if (Array.isArray(cell)) {\n            return this.addCells(cell, options);\n        }\n        if (!this.collection.has(cell) && !this.addings.has(cell)) {\n            this.addings.set(cell, true);\n            this.collection.add(this.prepareCell(cell, options), options);\n            cell.eachChild((child) => this.addCell(child, options));\n            this.addings.delete(cell);\n        }\n        return this;\n    }\n    addCells(cells, options = {}) {\n        const count = cells.length;\n        if (count === 0) {\n            return this;\n        }\n        const localOptions = Object.assign(Object.assign({}, options), { position: count - 1, maxPosition: count - 1 });\n        this.startBatch('add', Object.assign(Object.assign({}, localOptions), { cells }));\n        cells.forEach((cell) => {\n            this.addCell(cell, localOptions);\n            localOptions.position -= 1;\n        });\n        this.stopBatch('add', Object.assign(Object.assign({}, localOptions), { cells }));\n        return this;\n    }\n    removeCell(obj, options = {}) {\n        const cell = typeof obj === 'string' ? this.getCell(obj) : obj;\n        if (cell && this.has(cell)) {\n            return this.collection.remove(cell, options);\n        }\n        return null;\n    }\n    removeCells(cells, options = {}) {\n        if (cells.length) {\n            return this.batchUpdate('remove', () => {\n                return cells.map((cell) => this.removeCell(cell, options));\n            });\n        }\n        return [];\n    }\n    removeConnectedEdges(cell, options = {}) {\n        const edges = this.getConnectedEdges(cell);\n        edges.forEach((edge) => {\n            edge.remove(options);\n        });\n        return edges;\n    }\n    disconnectConnectedEdges(cell, options = {}) {\n        const cellId = typeof cell === 'string' ? cell : cell.id;\n        this.getConnectedEdges(cell).forEach((edge) => {\n            const sourceCell = edge.getSourceCell();\n            const targetCell = edge.getTargetCell();\n            if (sourceCell && sourceCell.id === cellId) {\n                edge.setSource({ x: 0, y: 0 }, options);\n            }\n            if (targetCell && targetCell.id === cellId) {\n                edge.setTarget({ x: 0, y: 0 }, options);\n            }\n        });\n    }\n    has(obj) {\n        return this.collection.has(obj);\n    }\n    total() {\n        return this.collection.length;\n    }\n    indexOf(cell) {\n        return this.collection.indexOf(cell);\n    }\n    /**\n     * Returns a cell from the graph by its id.\n     */\n    getCell(id) {\n        return this.collection.get(id);\n    }\n    /**\n     * Returns all the nodes and edges in the graph.\n     */\n    getCells() {\n        return this.collection.toArray();\n    }\n    /**\n     * Returns the first cell (node or edge) in the graph. The first cell is\n     * defined as the cell with the lowest `zIndex`.\n     */\n    getFirstCell() {\n        return this.collection.first();\n    }\n    /**\n     * Returns the last cell (node or edge) in the graph. The last cell is\n     * defined as the cell with the highest `zIndex`.\n     */\n    getLastCell() {\n        return this.collection.last();\n    }\n    /**\n     * Returns the lowest `zIndex` value in the graph.\n     */\n    getMinZIndex() {\n        const first = this.collection.first();\n        return first ? first.getZIndex() || 0 : 0;\n    }\n    /**\n     * Returns the highest `zIndex` value in the graph.\n     */\n    getMaxZIndex() {\n        const last = this.collection.last();\n        return last ? last.getZIndex() || 0 : 0;\n    }\n    getCellsFromCache(cache) {\n        return cache\n            ? Object.keys(cache)\n                .map((id) => this.getCell(id))\n                .filter((cell) => cell != null)\n            : [];\n    }\n    /**\n     * Returns all the nodes in the graph.\n     */\n    getNodes() {\n        return this.getCellsFromCache(this.nodes);\n    }\n    /**\n     * Returns all the edges in the graph.\n     */\n    getEdges() {\n        return this.getCellsFromCache(this.edges);\n    }\n    /**\n     * Returns all outgoing edges for the node.\n     */\n    getOutgoingEdges(cell) {\n        const cellId = typeof cell === 'string' ? cell : cell.id;\n        const cellIds = this.outgoings[cellId];\n        return cellIds\n            ? cellIds\n                .map((id) => this.getCell(id))\n                .filter((cell) => cell && cell.isEdge())\n            : null;\n    }\n    /**\n     * Returns all incoming edges for the node.\n     */\n    getIncomingEdges(cell) {\n        const cellId = typeof cell === 'string' ? cell : cell.id;\n        const cellIds = this.incomings[cellId];\n        return cellIds\n            ? cellIds\n                .map((id) => this.getCell(id))\n                .filter((cell) => cell && cell.isEdge())\n            : null;\n    }\n    /**\n     * Returns edges connected with cell.\n     */\n    getConnectedEdges(cell, options = {}) {\n        const result = [];\n        const node = typeof cell === 'string' ? this.getCell(cell) : cell;\n        if (node == null) {\n            return result;\n        }\n        const cache = {};\n        const indirect = options.indirect;\n        let incoming = options.incoming;\n        let outgoing = options.outgoing;\n        if (incoming == null && outgoing == null) {\n            incoming = outgoing = true;\n        }\n        const collect = (cell, isOutgoing) => {\n            const edges = isOutgoing\n                ? this.getOutgoingEdges(cell)\n                : this.getIncomingEdges(cell);\n            if (edges != null) {\n                edges.forEach((edge) => {\n                    if (cache[edge.id]) {\n                        return;\n                    }\n                    result.push(edge);\n                    cache[edge.id] = true;\n                    if (indirect) {\n                        if (incoming) {\n                            collect(edge, false);\n                        }\n                        if (outgoing) {\n                            collect(edge, true);\n                        }\n                    }\n                });\n            }\n            if (indirect && cell.isEdge()) {\n                const terminal = isOutgoing\n                    ? cell.getTargetCell()\n                    : cell.getSourceCell();\n                if (terminal && terminal.isEdge()) {\n                    if (!cache[terminal.id]) {\n                        result.push(terminal);\n                        collect(terminal, isOutgoing);\n                    }\n                }\n            }\n        };\n        if (outgoing) {\n            collect(node, true);\n        }\n        if (incoming) {\n            collect(node, false);\n        }\n        if (options.deep) {\n            const descendants = node.getDescendants({ deep: true });\n            const embedsCache = {};\n            descendants.forEach((cell) => {\n                if (cell.isNode()) {\n                    embedsCache[cell.id] = true;\n                }\n            });\n            const collectSub = (cell, isOutgoing) => {\n                const edges = isOutgoing\n                    ? this.getOutgoingEdges(cell.id)\n                    : this.getIncomingEdges(cell.id);\n                if (edges != null) {\n                    edges.forEach((edge) => {\n                        if (!cache[edge.id]) {\n                            const sourceCell = edge.getSourceCell();\n                            const targetCell = edge.getTargetCell();\n                            if (!options.enclosed &&\n                                sourceCell &&\n                                embedsCache[sourceCell.id] &&\n                                targetCell &&\n                                embedsCache[targetCell.id]) {\n                                return;\n                            }\n                            result.push(edge);\n                            cache[edge.id] = true;\n                        }\n                    });\n                }\n            };\n            descendants.forEach((cell) => {\n                if (cell.isEdge()) {\n                    return;\n                }\n                if (outgoing) {\n                    collectSub(cell, true);\n                }\n                if (incoming) {\n                    collectSub(cell, false);\n                }\n            });\n        }\n        return result;\n    }\n    isBoundary(cell, isOrigin) {\n        const node = typeof cell === 'string' ? this.getCell(cell) : cell;\n        const arr = isOrigin\n            ? this.getIncomingEdges(node)\n            : this.getOutgoingEdges(node);\n        return arr == null || arr.length === 0;\n    }\n    getBoundaryNodes(isOrigin) {\n        const result = [];\n        Object.keys(this.nodes).forEach((nodeId) => {\n            if (this.isBoundary(nodeId, isOrigin)) {\n                const node = this.getCell(nodeId);\n                if (node) {\n                    result.push(node);\n                }\n            }\n        });\n        return result;\n    }\n    /**\n     * Returns an array of all the roots of the graph.\n     */\n    getRoots() {\n        return this.getBoundaryNodes(true);\n    }\n    /**\n     * Returns an array of all the leafs of the graph.\n     */\n    getLeafs() {\n        return this.getBoundaryNodes(false);\n    }\n    /**\n     * Returns `true` if the node is a root node, i.e. there is no edges\n     * coming to the node.\n     */\n    isRoot(cell) {\n        return this.isBoundary(cell, true);\n    }\n    /**\n     * Returns `true` if the node is a leaf node, i.e. there is no edges\n     * going out from the node.\n     */\n    isLeaf(cell) {\n        return this.isBoundary(cell, false);\n    }\n    /**\n     * Returns all the neighbors of node in the graph. Neighbors are all\n     * the nodes connected to node via either incoming or outgoing edge.\n     */\n    getNeighbors(cell, options = {}) {\n        let incoming = options.incoming;\n        let outgoing = options.outgoing;\n        if (incoming == null && outgoing == null) {\n            incoming = outgoing = true;\n        }\n        const edges = this.getConnectedEdges(cell, options);\n        const map = edges.reduce((memo, edge) => {\n            const hasLoop = edge.hasLoop(options);\n            const sourceCell = edge.getSourceCell();\n            const targetCell = edge.getTargetCell();\n            if (incoming &&\n                sourceCell &&\n                sourceCell.isNode() &&\n                !memo[sourceCell.id]) {\n                if (hasLoop ||\n                    (sourceCell !== cell &&\n                        (!options.deep || !sourceCell.isDescendantOf(cell)))) {\n                    memo[sourceCell.id] = sourceCell;\n                }\n            }\n            if (outgoing &&\n                targetCell &&\n                targetCell.isNode() &&\n                !memo[targetCell.id]) {\n                if (hasLoop ||\n                    (targetCell !== cell &&\n                        (!options.deep || !targetCell.isDescendantOf(cell)))) {\n                    memo[targetCell.id] = targetCell;\n                }\n            }\n            return memo;\n        }, {});\n        if (cell.isEdge()) {\n            if (incoming) {\n                const sourceCell = cell.getSourceCell();\n                if (sourceCell && sourceCell.isNode() && !map[sourceCell.id]) {\n                    map[sourceCell.id] = sourceCell;\n                }\n            }\n            if (outgoing) {\n                const targetCell = cell.getTargetCell();\n                if (targetCell && targetCell.isNode() && !map[targetCell.id]) {\n                    map[targetCell.id] = targetCell;\n                }\n            }\n        }\n        return Object.keys(map).map((id) => map[id]);\n    }\n    /**\n     * Returns `true` if `cell2` is a neighbor of `cell1`.\n     */\n    isNeighbor(cell1, cell2, options = {}) {\n        let incoming = options.incoming;\n        let outgoing = options.outgoing;\n        if (incoming == null && outgoing == null) {\n            incoming = outgoing = true;\n        }\n        return this.getConnectedEdges(cell1, options).some((edge) => {\n            const sourceCell = edge.getSourceCell();\n            const targetCell = edge.getTargetCell();\n            if (incoming && sourceCell && sourceCell.id === cell2.id) {\n                return true;\n            }\n            if (outgoing && targetCell && targetCell.id === cell2.id) {\n                return true;\n            }\n            return false;\n        });\n    }\n    getSuccessors(cell, options = {}) {\n        const successors = [];\n        this.search(cell, (curr, distance) => {\n            if (curr !== cell && this.matchDistance(distance, options.distance)) {\n                successors.push(curr);\n            }\n        }, Object.assign(Object.assign({}, options), { outgoing: true }));\n        return successors;\n    }\n    /**\n     * Returns `true` if `cell2` is a successor of `cell1`.\n     */\n    isSuccessor(cell1, cell2, options = {}) {\n        let result = false;\n        this.search(cell1, (curr, distance) => {\n            if (curr === cell2 &&\n                curr !== cell1 &&\n                this.matchDistance(distance, options.distance)) {\n                result = true;\n                return false;\n            }\n        }, Object.assign(Object.assign({}, options), { outgoing: true }));\n        return result;\n    }\n    getPredecessors(cell, options = {}) {\n        const predecessors = [];\n        this.search(cell, (curr, distance) => {\n            if (curr !== cell && this.matchDistance(distance, options.distance)) {\n                predecessors.push(curr);\n            }\n        }, Object.assign(Object.assign({}, options), { incoming: true }));\n        return predecessors;\n    }\n    /**\n     * Returns `true` if `cell2` is a predecessor of `cell1`.\n     */\n    isPredecessor(cell1, cell2, options = {}) {\n        let result = false;\n        this.search(cell1, (curr, distance) => {\n            if (curr === cell2 &&\n                curr !== cell1 &&\n                this.matchDistance(distance, options.distance)) {\n                result = true;\n                return false;\n            }\n        }, Object.assign(Object.assign({}, options), { incoming: true }));\n        return result;\n    }\n    matchDistance(distance, preset) {\n        if (preset == null) {\n            return true;\n        }\n        if (typeof preset === 'function') {\n            return preset(distance);\n        }\n        if (Array.isArray(preset) && preset.includes(distance)) {\n            return true;\n        }\n        return distance === preset;\n    }\n    /**\n     * Returns the common ancestor of the passed cells.\n     */\n    getCommonAncestor(...cells) {\n        const arr = [];\n        cells.forEach((item) => {\n            if (item) {\n                if (Array.isArray(item)) {\n                    arr.push(...item);\n                }\n                else {\n                    arr.push(item);\n                }\n            }\n        });\n        return Cell.getCommonAncestor(...arr);\n    }\n    /**\n     * Returns an array of cells that result from finding nodes/edges that\n     * are connected to any of the cells in the cells array. This function\n     * loops over cells and if the current cell is a edge, it collects its\n     * source/target nodes; if it is an node, it collects its incoming and\n     * outgoing edges if both the edge terminal (source/target) are in the\n     * cells array.\n     */\n    getSubGraph(cells, options = {}) {\n        const subgraph = [];\n        const cache = {};\n        const nodes = [];\n        const edges = [];\n        const collect = (cell) => {\n            if (!cache[cell.id]) {\n                subgraph.push(cell);\n                cache[cell.id] = cell;\n                if (cell.isEdge()) {\n                    edges.push(cell);\n                }\n                if (cell.isNode()) {\n                    nodes.push(cell);\n                }\n            }\n        };\n        cells.forEach((cell) => {\n            collect(cell);\n            if (options.deep) {\n                const descendants = cell.getDescendants({ deep: true });\n                descendants.forEach((descendant) => collect(descendant));\n            }\n        });\n        edges.forEach((edge) => {\n            // For edges, include their source & target\n            const sourceCell = edge.getSourceCell();\n            const targetCell = edge.getTargetCell();\n            if (sourceCell && !cache[sourceCell.id]) {\n                subgraph.push(sourceCell);\n                cache[sourceCell.id] = sourceCell;\n                if (sourceCell.isNode()) {\n                    nodes.push(sourceCell);\n                }\n            }\n            if (targetCell && !cache[targetCell.id]) {\n                subgraph.push(targetCell);\n                cache[targetCell.id] = targetCell;\n                if (targetCell.isNode()) {\n                    nodes.push(targetCell);\n                }\n            }\n        });\n        nodes.forEach((node) => {\n            // For nodes, include their connected edges if their source/target\n            // is in the subgraph.\n            const edges = this.getConnectedEdges(node, options);\n            edges.forEach((edge) => {\n                const sourceCell = edge.getSourceCell();\n                const targetCell = edge.getTargetCell();\n                if (!cache[edge.id] &&\n                    sourceCell &&\n                    cache[sourceCell.id] &&\n                    targetCell &&\n                    cache[targetCell.id]) {\n                    subgraph.push(edge);\n                    cache[edge.id] = edge;\n                }\n            });\n        });\n        return subgraph;\n    }\n    /**\n     * Clones the whole subgraph (including all the connected links whose\n     * source/target is in the subgraph). If `options.deep` is `true`, also\n     * take into account all the embedded cells of all the subgraph cells.\n     *\n     * Returns a map of the form: { [original cell ID]: [clone] }.\n     */\n    cloneSubGraph(cells, options = {}) {\n        const subgraph = this.getSubGraph(cells, options);\n        return this.cloneCells(subgraph);\n    }\n    cloneCells(cells) {\n        return Cell.cloneCells(cells);\n    }\n    getNodesFromPoint(x, y) {\n        const p = typeof x === 'number' ? { x, y: y || 0 } : x;\n        return this.getNodes().filter((node) => {\n            return node.getBBox().containsPoint(p);\n        });\n    }\n    getNodesInArea(x, y, w, h, options) {\n        const rect = typeof x === 'number'\n            ? new Rectangle(x, y, w, h)\n            : Rectangle.create(x);\n        const opts = typeof x === 'number' ? options : y;\n        const strict = opts && opts.strict;\n        return this.getNodes().filter((node) => {\n            const bbox = node.getBBox();\n            return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);\n        });\n    }\n    getEdgesInArea(x, y, w, h, options) {\n        const rect = typeof x === 'number'\n            ? new Rectangle(x, y, w, h)\n            : Rectangle.create(x);\n        const opts = typeof x === 'number' ? options : y;\n        const strict = opts && opts.strict;\n        return this.getEdges().filter((edge) => {\n            const bbox = edge.getBBox();\n            if (bbox.width === 0) {\n                bbox.inflate(1, 0);\n            }\n            else if (bbox.height === 0) {\n                bbox.inflate(0, 1);\n            }\n            return strict ? rect.containsRect(bbox) : rect.isIntersectWithRect(bbox);\n        });\n    }\n    getNodesUnderNode(node, options = {}) {\n        const bbox = node.getBBox();\n        const nodes = options.by == null || options.by === 'bbox'\n            ? this.getNodesInArea(bbox)\n            : this.getNodesFromPoint(bbox[options.by]);\n        return nodes.filter((curr) => node.id !== curr.id && !curr.isDescendantOf(node));\n    }\n    /**\n     * Returns the bounding box that surrounds all cells in the graph.\n     */\n    getAllCellsBBox() {\n        return this.getCellsBBox(this.getCells());\n    }\n    /**\n     * Returns the bounding box that surrounds all the given cells.\n     */\n    getCellsBBox(cells, options = {}) {\n        return Cell.getCellsBBox(cells, options);\n    }\n    // #region search\n    search(cell, iterator, options = {}) {\n        if (options.breadthFirst) {\n            this.breadthFirstSearch(cell, iterator, options);\n        }\n        else {\n            this.depthFirstSearch(cell, iterator, options);\n        }\n    }\n    breadthFirstSearch(cell, iterator, options = {}) {\n        const queue = [];\n        const visited = {};\n        const distance = {};\n        queue.push(cell);\n        distance[cell.id] = 0;\n        while (queue.length > 0) {\n            const next = queue.shift();\n            if (next == null || visited[next.id]) {\n                continue;\n            }\n            visited[next.id] = true;\n            if (FunctionExt.call(iterator, this, next, distance[next.id]) === false) {\n                continue;\n            }\n            const neighbors = this.getNeighbors(next, options);\n            neighbors.forEach((neighbor) => {\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.push(neighbor);\n            });\n        }\n    }\n    depthFirstSearch(cell, iterator, options = {}) {\n        const queue = [];\n        const visited = {};\n        const distance = {};\n        queue.push(cell);\n        distance[cell.id] = 0;\n        while (queue.length > 0) {\n            const next = queue.pop();\n            if (next == null || visited[next.id]) {\n                continue;\n            }\n            visited[next.id] = true;\n            if (FunctionExt.call(iterator, this, next, distance[next.id]) === false) {\n                continue;\n            }\n            const neighbors = this.getNeighbors(next, options);\n            const lastIndex = queue.length;\n            neighbors.forEach((neighbor) => {\n                distance[neighbor.id] = distance[next.id] + 1;\n                queue.splice(lastIndex, 0, neighbor);\n            });\n        }\n    }\n    // #endregion\n    // #region shortest path\n    /** *\n     * Returns an array of IDs of nodes on the shortest\n     * path between source and target.\n     */\n    getShortestPath(source, target, options = {}) {\n        const adjacencyList = {};\n        this.getEdges().forEach((edge) => {\n            const sourceId = edge.getSourceCellId();\n            const targetId = edge.getTargetCellId();\n            if (sourceId && targetId) {\n                if (!adjacencyList[sourceId]) {\n                    adjacencyList[sourceId] = [];\n                }\n                if (!adjacencyList[targetId]) {\n                    adjacencyList[targetId] = [];\n                }\n                adjacencyList[sourceId].push(targetId);\n                if (!options.directed) {\n                    adjacencyList[targetId].push(sourceId);\n                }\n            }\n        });\n        const sourceId = typeof source === 'string' ? source : source.id;\n        const previous = Dijkstra.run(adjacencyList, sourceId, options.weight);\n        const path = [];\n        let targetId = typeof target === 'string' ? target : target.id;\n        if (previous[targetId]) {\n            path.push(targetId);\n        }\n        while ((targetId = previous[targetId])) {\n            path.unshift(targetId);\n        }\n        return path;\n    }\n    // #endregion\n    // #region transform\n    /**\n     * Translate all cells in the graph by `tx` and `ty` pixels.\n     */\n    translate(tx, ty, options) {\n        this.getCells()\n            .filter((cell) => !cell.hasParent())\n            .forEach((cell) => cell.translate(tx, ty, options));\n        return this;\n    }\n    resize(width, height, options) {\n        return this.resizeCells(width, height, this.getCells(), options);\n    }\n    resizeCells(width, height, cells, options = {}) {\n        const bbox = this.getCellsBBox(cells);\n        if (bbox) {\n            const sx = Math.max(width / bbox.width, 0);\n            const sy = Math.max(height / bbox.height, 0);\n            const origin = bbox.getOrigin();\n            cells.forEach((cell) => cell.scale(sx, sy, origin, options));\n        }\n        return this;\n    }\n    // #endregion\n    // #region serialize/deserialize\n    toJSON(options = {}) {\n        return Model.toJSON(this.getCells(), options);\n    }\n    parseJSON(data) {\n        return Model.fromJSON(data);\n    }\n    fromJSON(data, options = {}) {\n        const cells = this.parseJSON(data);\n        this.resetCells(cells, options);\n        return this;\n    }\n    // #endregion\n    // #region batch\n    startBatch(name, data = {}) {\n        this.batches[name] = (this.batches[name] || 0) + 1;\n        this.notify('batch:start', { name, data });\n        return this;\n    }\n    stopBatch(name, data = {}) {\n        this.batches[name] = (this.batches[name] || 0) - 1;\n        this.notify('batch:stop', { name, data });\n        return this;\n    }\n    batchUpdate(name, execute, data = {}) {\n        this.startBatch(name, data);\n        const result = execute();\n        this.stopBatch(name, data);\n        return result;\n    }\n    hasActiveBatch(name = Object.keys(this.batches)) {\n        const names = Array.isArray(name) ? name : [name];\n        return names.some((batch) => this.batches[batch] > 0);\n    }\n}\n(function (Model) {\n    Model.toStringTag = `X6.${Model.name}`;\n    function isModel(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Model) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const model = instance;\n        if ((tag == null || tag === Model.toStringTag) &&\n            typeof model.addNode === 'function' &&\n            typeof model.addEdge === 'function' &&\n            model.collection != null) {\n            return true;\n        }\n        return false;\n    }\n    Model.isModel = isModel;\n})(Model || (Model = {}));\n(function (Model) {\n    function toJSON(cells, options = {}) {\n        return {\n            cells: cells.map((cell) => cell.toJSON(options)),\n        };\n    }\n    Model.toJSON = toJSON;\n    function fromJSON(data) {\n        const cells = [];\n        if (Array.isArray(data)) {\n            cells.push(...data);\n        }\n        else {\n            if (data.cells) {\n                cells.push(...data.cells);\n            }\n            if (data.nodes) {\n                data.nodes.forEach((node) => {\n                    if (node.shape == null) {\n                        node.shape = 'rect';\n                    }\n                    cells.push(node);\n                });\n            }\n            if (data.edges) {\n                data.edges.forEach((edge) => {\n                    if (edge.shape == null) {\n                        edge.shape = 'edge';\n                    }\n                    cells.push(edge);\n                });\n            }\n        }\n        return cells.map((cell) => {\n            const type = cell.shape;\n            if (type) {\n                if (Node.registry.exist(type)) {\n                    return Node.create(cell);\n                }\n                if (Edge.registry.exist(type)) {\n                    return Edge.create(cell);\n                }\n            }\n            throw new Error('The `shape` should be specipied when creating a node/edge instance');\n        });\n    }\n    Model.fromJSON = fromJSON;\n})(Model || (Model = {}));\n//# sourceMappingURL=model.js.map"]},"metadata":{},"sourceType":"module"}