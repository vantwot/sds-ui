{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport BaseModel from '../../core/BaseModel';\nimport { PointExtrudeTriangulation } from '../../core/triangulation';\nvar heatmapGrid3dVert = \"precision highp float;\\n// \\u591A\\u8FB9\\u5F62\\u9876\\u70B9\\u5750\\u6807\\nattribute vec3 a_Position;\\n// \\u591A\\u8FB9\\u5F62\\u7ECF\\u7EAC\\u5EA6\\u5750\\u6807\\nattribute vec3 a_Pos;\\n\\nattribute vec3 a_Normal;\\nattribute float a_Size;\\nattribute vec4 a_Color;\\nuniform vec2 u_radius;\\nuniform float u_coverage: 0.9;\\nuniform float u_angle: 0;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_Mvp;\\nvarying vec4 v_color;\\n\\nuniform vec2 u_SceneCenterMKT;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"project\\\"\\n#pragma include \\\"light\\\"\\n#pragma include \\\"picking\\\"\\n\\n\\nvoid main() {\\n  mat2 rotationMatrix = mat2(cos(u_angle), sin(u_angle), -sin(u_angle), cos(u_angle));\\n  vec2 offset =(vec2(a_Position.xy * u_radius * rotationMatrix * u_coverage));\\n  // vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // \\u5B9E\\u9645\\u7684\\u7ECF\\u7EAC\\u5EA6\\n  // vec2 lnglat = (a_Pos.xy + offset); \\n  // vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\\n  // gl_Position = project_common_position_to_clipspace(project_pos);\\n  // float lightWeight = calc_lighting(project_pos);\\n  // v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\\n\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\n    // vec2 lnglat = (a_Pos.xy + offset); \\n    // vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\\n\\n    // float lightWeight = calc_lighting(project_pos);\\n    // v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\\n  \\n    // gl_Position = u_Mvp * vec4(lnglat , a_Position.z * a_Size, 1.0);\\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // \\u7ECF\\u7EAC\\u5EA6\\n    vec2 customLnglat = customProject(lnglat) - u_SceneCenterMKT; // \\u5C06\\u7ECF\\u7EAC\\u5EA6\\u8F6C\\u6362\\u4E3A\\u9AD8\\u5FB72.0\\u9700\\u8981\\u7684\\u5E73\\u9762\\u5750\\u6807\\n    vec4 project_pos = project_position(vec4(customLnglat, a_Position.z * a_Size, 1.0));\\n\\n    float lightWeight = calc_lighting(project_pos);\\n    v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\\n  \\n    gl_Position = u_Mvp * vec4(customLnglat , a_Position.z * a_Size, 1.0);\\n  } else {\\n    vec2 lnglat = unProjectFlat(a_Pos.xy + offset); // \\u5B9E\\u9645\\u7684\\u7ECF\\u7EAC\\u5EA6\\n    vec4 project_pos = project_position(vec4(lnglat, a_Position.z * a_Size, 1.0));\\n    \\n    float lightWeight = calc_lighting(project_pos);\\n    v_color =vec4(a_Color.rgb*lightWeight, a_Color.w);\\n    \\n    gl_Position = project_common_position_to_clipspace(project_pos);\\n  }\\n\\n\\n\\n  setPickingColor(a_PickingColor);\\n}\\n\";\nvar heatmapGridFrag = \"precision highp float;\\nvarying vec4 v_color;\\nuniform float u_opacity: 1;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n  gl_FragColor = v_color;\\n  gl_FragColor.a *= u_opacity;\\n\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\\n\";\n\nvar Grid3DModel = function (_BaseModel) {\n  _inherits(Grid3DModel, _BaseModel);\n\n  var _super = _createSuper(Grid3DModel);\n\n  function Grid3DModel() {\n    _classCallCheck(this, Grid3DModel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Grid3DModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          coverage = _ref.coverage,\n          angle = _ref.angle;\n\n      return {\n        u_opacity: opacity || 1.0,\n        u_coverage: coverage || 1.0,\n        u_angle: angle || 0,\n        u_radius: [this.layer.getSource().data.xOffset, this.layer.getSource().data.yOffset]\n      };\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      return this.buildModels();\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return [this.layer.buildLayerModel({\n        moduleName: 'grid3dheatmap',\n        vertexShader: heatmapGrid3dVert,\n        fragmentShader: heatmapGridFrag,\n        triangulation: PointExtrudeTriangulation,\n        depth: {\n          enable: true\n        },\n        blend: this.getBlend()\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var size = feature.size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'normal',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Normal',\n          buffer: {\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx, vertex, attributeIdx, normal) {\n            return normal;\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'pos',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Pos',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 3,\n          update: function update(feature, featureIdx) {\n            var coordinates = feature.version === 'GAODE2.x' ? feature.originCoordinates : feature.coordinates;\n            return [coordinates[0], coordinates[1], 0];\n          }\n        }\n      });\n    }\n  }]);\n\n  return Grid3DModel;\n}(BaseModel);\n\nexport { Grid3DModel as default };","map":{"version":3,"sources":["../../../src/heatmap/models/grid3d.ts"],"names":["Grid3DModel","BaseModel","opacity","coverage","angle","u_opacity","u_coverage","u_angle","u_radius","moduleName","vertexShader","fragmentShader","triangulation","depth","enable","blend","name","type","AttributeType","descriptor","buffer","usage","gl","data","FLOAT","size","update","feature","Array","coordinates"],"mappings":"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","sourcesContent":["import {\n  AttributeType,\n  gl,\n  IEncodeFeature,\n  IModel,\n  IModelUniform,\n} from '@antv/l7-core';\nimport { aProjectFlat, Satistics, unProjectFlat } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nimport { PointExtrudeTriangulation } from '../../core/triangulation';\nimport heatmapGrid3dVert from '../shaders/hexagon_3d_vert.glsl';\nimport heatmapGridFrag from '../shaders/hexagon_frag.glsl';\ninterface IHeatMapLayerStyleOptions {\n  opacity: number;\n  coverage: number;\n  angle: number;\n}\nexport default class Grid3DModel extends BaseModel {\n  public getUninforms(): IModelUniform {\n    const {\n      opacity,\n      coverage,\n      angle,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n    return {\n      u_opacity: opacity || 1.0,\n      u_coverage: coverage || 1.0,\n      u_angle: angle || 0,\n      u_radius: [\n        this.layer.getSource().data.xOffset,\n        this.layer.getSource().data.yOffset,\n      ],\n    };\n  }\n\n  public initModels(): IModel[] {\n    return this.buildModels();\n  }\n\n  public buildModels(): IModel[] {\n    return [\n      this.layer.buildLayerModel({\n        moduleName: 'grid3dheatmap',\n        vertexShader: heatmapGrid3dVert,\n        fragmentShader: heatmapGridFrag,\n        triangulation: PointExtrudeTriangulation,\n        depth: { enable: true },\n        blend: this.getBlend(),\n      }),\n    ];\n  }\n  protected registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { size } = feature;\n          return Array.isArray(size) ? [size[0]] : [size as number];\n        },\n      },\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'normal',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Normal',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 3,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n          normal: number[],\n        ) => {\n          return normal;\n        },\n      },\n    });\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'pos', // 顶点经纬度位置\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Pos',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 3,\n        update: (feature: IEncodeFeature, featureIdx: number) => {\n          const coordinates = (feature.version === 'GAODE2.x'\n            ? feature.originCoordinates\n            : feature.coordinates) as number[];\n          // const coordinates = feature.coordinates as number[];\n          // const coordinates = feature.originCoordinates as number[];\n          return [coordinates[0], coordinates[1], 0];\n        },\n      },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}