{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Dom, FunctionExt } from '../util';\nimport { Rectangle } from '../geometry';\nimport { Cell } from '../model';\nimport { View, CellView } from '../view';\nimport { Base } from './base';\nexport var Renderer = /*#__PURE__*/function (_Base) {\n  _inherits(Renderer, _Base);\n\n  var _super = _createSuper(Renderer);\n\n  function Renderer() {\n    _classCallCheck(this, Renderer);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(Renderer, [{\n    key: \"init\",\n    value: function init() {\n      this.resetUpdates();\n      this.startListening(); // Renders existing cells in the model.\n\n      this.resetViews(this.model.getCells()); // Starts rendering loop.\n\n      if (!this.isFrozen() && this.isAsync()) {\n        this.updateViewsAsync();\n      }\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      this.model.on('sorted', this.onSortModel, this);\n      this.model.on('reseted', this.onModelReseted, this);\n      this.model.on('batch:stop', this.onBatchStop, this);\n      this.model.on('cell:added', this.onCellAdded, this);\n      this.model.on('cell:removed', this.onCellRemoved, this);\n      this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);\n      this.model.on('cell:change:visible', this.onCellVisibleChanged, this);\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      this.model.off('sorted', this.onSortModel, this);\n      this.model.off('reseted', this.onModelReseted, this);\n      this.model.off('batch:stop', this.onBatchStop, this);\n      this.model.off('cell:added', this.onCellAdded, this);\n      this.model.off('cell:removed', this.onCellRemoved, this);\n      this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);\n      this.model.off('cell:change:visible', this.onCellVisibleChanged, this);\n    }\n  }, {\n    key: \"resetUpdates\",\n    value: function resetUpdates() {\n      this.updates = {\n        priorities: [{}, {}, {}],\n        mounted: {},\n        mountedCids: [],\n        unmounted: {},\n        unmountedCids: [],\n        count: 0,\n        sort: false,\n        frozen: false,\n        freezeKey: null,\n        animationId: null\n      };\n    }\n  }, {\n    key: \"onSortModel\",\n    value: function onSortModel() {\n      if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {\n        return;\n      }\n\n      this.sortViews();\n    }\n  }, {\n    key: \"onModelReseted\",\n    value: function onModelReseted(_ref) {\n      var options = _ref.options;\n      this.removeZPivots();\n      this.resetViews(this.model.getCells(), options);\n    }\n  }, {\n    key: \"onBatchStop\",\n    value: function onBatchStop(_ref2) {\n      var name = _ref2.name,\n          data = _ref2.data;\n\n      if (this.isFrozen()) {\n        return;\n      }\n\n      var model = this.model;\n\n      if (!this.isAsync()) {\n        var updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES;\n\n        if (updateDelayingBatches.includes(name) && !model.hasActiveBatch(updateDelayingBatches)) {\n          this.updateViews(data);\n        }\n      }\n\n      var sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES;\n\n      if (sortDelayingBatches.includes(name) && !model.hasActiveBatch(sortDelayingBatches)) {\n        this.sortViews();\n      }\n    }\n  }, {\n    key: \"onCellAdded\",\n    value: function onCellAdded(_ref3) {\n      var cell = _ref3.cell,\n          options = _ref3.options;\n      var position = options.position;\n\n      if (this.isAsync() || typeof position !== 'number') {\n        this.renderView(cell, options);\n      } else {\n        if (options.maxPosition === position) {\n          this.freeze({\n            key: 'addCells'\n          });\n        }\n\n        this.renderView(cell, options);\n\n        if (position === 0) {\n          this.unfreeze({\n            key: 'addCells'\n          });\n        }\n      }\n    }\n  }, {\n    key: \"onCellRemoved\",\n    value: function onCellRemoved(_ref4) {\n      var cell = _ref4.cell,\n          options = _ref4.options;\n      var view = this.findViewByCell(cell);\n\n      if (view) {\n        this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options);\n      }\n    }\n  }, {\n    key: \"onCellZIndexChanged\",\n    value: function onCellZIndexChanged(_ref5) {\n      var cell = _ref5.cell,\n          options = _ref5.options;\n\n      if (this.options.sorting === 'approx') {\n        var view = this.findViewByCell(cell);\n\n        if (view) {\n          this.requestViewUpdate(view, Renderer.FLAG_INSERT, view.priority, options);\n        }\n      }\n    }\n  }, {\n    key: \"onCellVisibleChanged\",\n    value: function onCellVisibleChanged(_ref6) {\n      var cell = _ref6.cell,\n          visible = _ref6.current,\n          options = _ref6.options;\n\n      // Hide connected edges before cell\n      if (!visible) {\n        this.processEdgeOnTerminalVisibleChanged(cell, false);\n      }\n\n      var view = this.findViewByCell(cell);\n\n      if (!visible && view) {\n        this.removeView(cell);\n      } else if (visible && view == null) {\n        this.renderView(cell, options);\n      } // Show connected edges after cell rendered\n\n\n      if (visible) {\n        this.processEdgeOnTerminalVisibleChanged(cell, true);\n      }\n    }\n  }, {\n    key: \"processEdgeOnTerminalVisibleChanged\",\n    value: function processEdgeOnTerminalVisibleChanged(node, visible) {\n      var getOpposite = function getOpposite(edge, currentTerminal) {\n        var sourceId = edge.getSourceCellId();\n\n        if (sourceId !== currentTerminal.id) {\n          return edge.getSourceCell();\n        }\n\n        var targetId = edge.getTargetCellId();\n\n        if (targetId !== currentTerminal.id) {\n          return edge.getTargetCell();\n        }\n\n        return null;\n      };\n\n      this.model.getConnectedEdges(node).forEach(function (edge) {\n        var opposite = getOpposite(edge, node);\n\n        if (opposite == null || opposite.isVisible()) {\n          visible ? edge.show() : edge.hide();\n        }\n      });\n    }\n  }, {\n    key: \"isEdgeTerminalVisible\",\n    value: function isEdgeTerminalVisible(edge, terminal) {\n      var cellId = terminal === 'source' ? edge.getSourceCellId() : edge.getTargetCellId();\n      var cell = cellId ? this.model.getCell(cellId) : null;\n\n      if (cell && !cell.isVisible()) {\n        return false;\n      }\n\n      return true;\n    }\n  }, {\n    key: \"requestConnectedEdgesUpdate\",\n    value: function requestConnectedEdgesUpdate(view) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (CellView.isCellView(view)) {\n        var cell = view.cell;\n        var edges = this.model.getConnectedEdges(cell);\n\n        for (var j = 0, n = edges.length; j < n; j += 1) {\n          var edge = edges[j];\n          var edgeView = this.findViewByCell(edge);\n\n          if (!edgeView) {\n            continue;\n          }\n\n          var flagLabels = ['update'];\n\n          if (edge.getTargetCell() === cell) {\n            flagLabels.push('target');\n          }\n\n          if (edge.getSourceCell() === cell) {\n            flagLabels.push('source');\n          }\n\n          this.scheduleViewUpdate(edgeView, edgeView.getFlag(flagLabels), edgeView.priority, options);\n        }\n      }\n    }\n  }, {\n    key: \"forcePostponedViewUpdate\",\n    value: function forcePostponedViewUpdate(view, flag) {\n      if (!view || !CellView.isCellView(view)) {\n        return false;\n      }\n\n      var cell = view.cell;\n\n      if (cell.isNode()) {\n        return false;\n      }\n\n      var edgeView = view;\n\n      if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {\n        // EdgeView is waiting for the source/target cellView to be rendered.\n        // This can happen when the cells are not in the viewport.\n        var sourceFlag = 0;\n        var sourceView = this.findViewByCell(cell.getSourceCell());\n\n        if (sourceView && !this.isViewMounted(sourceView)) {\n          sourceFlag = this.dumpView(sourceView);\n          edgeView.updateTerminalMagnet('source');\n        }\n\n        var targetFlag = 0;\n        var targetView = this.findViewByCell(cell.getTargetCell());\n\n        if (targetView && !this.isViewMounted(targetView)) {\n          targetFlag = this.dumpView(targetView);\n          edgeView.updateTerminalMagnet('target');\n        }\n\n        if (sourceFlag === 0 && targetFlag === 0) {\n          // If leftover flag is 0, all view updates were done.\n          return !this.dumpView(edgeView);\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"scheduleViewUpdate\",\n    value: function scheduleViewUpdate(view, flag, priority) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var cid = view.cid;\n      var updates = this.updates;\n      var cache = updates.priorities[priority];\n\n      if (!cache) {\n        cache = updates.priorities[priority] = {};\n      }\n\n      var currentFlag = cache[cid] || 0;\n\n      if ((currentFlag & flag) === flag) {\n        return;\n      }\n\n      if (!currentFlag) {\n        updates.count += 1;\n      }\n\n      if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {\n        // When a view is removed we need to remove the\n        // insert flag as this is a reinsert.\n        cache[cid] ^= Renderer.FLAG_INSERT;\n      } else if (flag & Renderer.FLAG_INSERT && currentFlag & Renderer.FLAG_REMOVE) {\n        // When a view is added we need to remove the remove\n        // flag as this is view was previously removed.\n        cache[cid] ^= Renderer.FLAG_REMOVE;\n      }\n\n      cache[cid] |= flag;\n      this.graph.hook.onViewUpdated(view, flag, options);\n    }\n  }, {\n    key: \"requestViewUpdate\",\n    value: function requestViewUpdate(view, flag, priority) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      this.scheduleViewUpdate(view, flag, priority, options);\n      var isAsync = this.isAsync();\n\n      if (this.isFrozen() || isAsync && options.async !== false || this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)) {\n        return;\n      }\n\n      var stats = this.updateViews(options);\n\n      if (isAsync) {\n        this.graph.trigger('render:done', {\n          stats: stats,\n          options: options\n        });\n      }\n    }\n    /**\n     * Adds view into the DOM and update it.\n     */\n\n  }, {\n    key: \"dumpView\",\n    value: function dumpView(view) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (view == null) {\n        return 0;\n      }\n\n      var cid = view.cid;\n      var updates = this.updates;\n      var cache = updates.priorities[view.priority];\n      var flag = this.registerMountedView(view) | cache[cid];\n      delete cache[cid];\n\n      if (!flag) {\n        return 0;\n      }\n\n      return this.updateView(view, flag, options);\n    }\n    /**\n     * Adds all views into the DOM and update them.\n     */\n\n  }, {\n    key: \"dumpViews\",\n    value: function dumpViews() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.checkView(options);\n      this.updateViews(options);\n    }\n    /**\n     * Ensure the view associated with the cell is attached\n     * to the DOM and updated.\n     */\n\n  }, {\n    key: \"requireView\",\n    value: function requireView(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var view = this.findViewByCell(cell);\n\n      if (view == null) {\n        return null;\n      }\n\n      this.dumpView(view, options);\n      return view;\n    }\n  }, {\n    key: \"updateView\",\n    value: function updateView(view, flag) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (view == null) {\n        return 0;\n      }\n\n      if (CellView.isCellView(view)) {\n        if (flag & Renderer.FLAG_REMOVE) {\n          this.removeView(view.cell);\n          return 0;\n        }\n\n        if (flag & Renderer.FLAG_INSERT) {\n          this.insertView(view);\n          flag ^= Renderer.FLAG_INSERT; // eslint-disable-line\n        }\n      }\n\n      if (!flag) {\n        return 0;\n      }\n\n      return view.confirmUpdate(flag, options);\n    }\n  }, {\n    key: \"updateViews\",\n    value: function updateViews() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var result;\n      var batchCount = 0;\n      var updatedCount = 0;\n      var priority = Renderer.MIN_PRIORITY;\n\n      do {\n        result = this.updateViewsBatch(options);\n        batchCount += 1;\n        updatedCount += result.updatedCount;\n        priority = Math.min(result.priority, priority);\n      } while (!result.empty);\n\n      return {\n        priority: priority,\n        batchCount: batchCount,\n        updatedCount: updatedCount\n      };\n    }\n  }, {\n    key: \"updateViewsBatch\",\n    value: function updateViewsBatch() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var updates = this.updates;\n      var priorities = updates.priorities;\n      var batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE;\n      var empty = true;\n      var priority = Renderer.MIN_PRIORITY;\n      var mountedCount = 0;\n      var unmountedCount = 0;\n      var updatedCount = 0;\n      var postponedCount = 0;\n      var checkView = options.checkView || this.options.checkView;\n\n      if (typeof checkView !== 'function') {\n        checkView = null;\n      } // eslint-disable-next-line\n\n\n      main: for (var p = 0, n = priorities.length; p < n; p += 1) {\n        var cache = priorities[p]; // eslint-disable-next-line\n\n        for (var cid in cache) {\n          if (updatedCount >= batchSize) {\n            empty = false; // goto next batch\n\n            break main; // eslint-disable-line no-labels\n          }\n\n          var view = View.views[cid];\n\n          if (!view) {\n            delete cache[cid];\n            continue;\n          }\n\n          var currentFlag = cache[cid]; // Do not check a view for viewport if we are about to remove the view.\n\n          if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {\n            var isUnmounted = (cid in updates.unmounted);\n\n            if (checkView && !FunctionExt.call(checkView, this.graph, {\n              view: view,\n              unmounted: isUnmounted\n            })) {\n              // Unmount view\n              if (!isUnmounted) {\n                this.registerUnmountedView(view);\n                view.unmount();\n              }\n\n              updates.unmounted[cid] |= currentFlag;\n              delete cache[cid];\n              unmountedCount += 1;\n              continue;\n            } // Mount view\n\n\n            if (isUnmounted) {\n              currentFlag |= Renderer.FLAG_INSERT;\n              mountedCount += 1;\n            }\n\n            currentFlag |= this.registerMountedView(view);\n          }\n\n          var cellView = view;\n          var leftoverFlag = this.updateView(view, currentFlag, options);\n\n          if (leftoverFlag > 0) {\n            var cell = cellView.cell;\n\n            if (cell && cell.isEdge()) {\n              // remove edge view when source cell is invisible\n              if (cellView.hasAction(leftoverFlag, 'source') && !this.isEdgeTerminalVisible(cell, 'source')) {\n                leftoverFlag = cellView.removeAction(leftoverFlag, 'source');\n                leftoverFlag |= Renderer.FLAG_REMOVE;\n              } // remove edge view when target cell is invisible\n\n\n              if (cellView.hasAction(leftoverFlag, 'target') && !this.isEdgeTerminalVisible(cell, 'target')) {\n                leftoverFlag = cellView.removeAction(leftoverFlag, 'target');\n                leftoverFlag |= Renderer.FLAG_REMOVE;\n              }\n            }\n          }\n\n          if (leftoverFlag > 0) {\n            // update has not finished\n            cache[cid] = leftoverFlag;\n\n            if (!this.graph.hook.onViewPostponed(cellView, leftoverFlag, options) || cache[cid]) {\n              postponedCount += 1;\n              empty = false;\n              continue;\n            }\n          }\n\n          if (priority > p) {\n            priority = p;\n          }\n\n          updatedCount += 1;\n          delete cache[cid];\n        }\n      }\n\n      return {\n        empty: empty,\n        priority: priority,\n        mountedCount: mountedCount,\n        unmountedCount: unmountedCount,\n        updatedCount: updatedCount,\n        postponedCount: postponedCount\n      };\n    }\n  }, {\n    key: \"updateViewsAsync\",\n    value: function updateViewsAsync() {\n      var _this = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n        processed: 0,\n        priority: Renderer.MIN_PRIORITY\n      };\n      var updates = this.updates;\n      var animationId = updates.animationId;\n\n      if (animationId) {\n        Dom.cancelAnimationFrame(animationId);\n\n        if (data.processed === 0) {\n          var beforeFn = options.before;\n\n          if (typeof beforeFn === 'function') {\n            FunctionExt.call(beforeFn, this.graph, this.graph);\n          }\n        }\n\n        var stats = this.updateViewsBatch(options);\n        var checkout = this.checkViewImpl({\n          checkView: options.checkView,\n          mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,\n          unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount\n        });\n        var processed = data.processed;\n        var total = updates.count;\n        var mountedCount = checkout.mountedCount;\n        var unmountedCount = checkout.unmountedCount;\n\n        if (stats.updatedCount > 0) {\n          // Some updates have been just processed\n          processed += stats.updatedCount + stats.unmountedCount;\n          data.priority = Math.min(stats.priority, data.priority);\n\n          if (stats.empty && mountedCount === 0) {\n            stats.priority = data.priority;\n            stats.mountedCount += mountedCount;\n            stats.unmountedCount += unmountedCount;\n            this.graph.trigger('render:done', {\n              stats: stats,\n              options: options\n            });\n            data.processed = 0;\n            updates.count = 0;\n          } else {\n            data.processed = processed;\n          }\n        } // Progress callback\n\n\n        var progressFn = options.progress;\n\n        if (total && typeof progressFn === 'function') {\n          FunctionExt.call(progressFn, this.graph, {\n            total: total,\n            done: stats.empty,\n            current: processed\n          });\n        } // The current frame could have been canceled in a callback\n\n\n        if (updates.animationId !== animationId) {\n          return;\n        }\n      }\n\n      updates.animationId = Dom.requestAnimationFrame(function () {\n        _this.updateViewsAsync(options, data);\n      });\n    }\n  }, {\n    key: \"registerMountedView\",\n    value: function registerMountedView(view) {\n      var cid = view.cid;\n      var updates = this.updates;\n\n      if (cid in updates.mounted) {\n        return 0;\n      }\n\n      updates.mounted[cid] = true;\n      updates.mountedCids.push(cid);\n      var flag = updates.unmounted[cid] || 0;\n      delete updates.unmounted[cid];\n      return flag;\n    }\n  }, {\n    key: \"registerUnmountedView\",\n    value: function registerUnmountedView(view) {\n      var cid = view.cid;\n      var updates = this.updates;\n\n      if (cid in updates.unmounted) {\n        return 0;\n      }\n\n      updates.unmounted[cid] |= Renderer.FLAG_INSERT;\n      var flag = updates.unmounted[cid];\n      updates.unmountedCids.push(cid);\n      delete updates.mounted[cid];\n      return flag;\n    }\n  }, {\n    key: \"isViewMounted\",\n    value: function isViewMounted(view) {\n      if (view == null) {\n        return false;\n      }\n\n      var cid = view.cid;\n      return cid in this.updates.mounted;\n    }\n  }, {\n    key: \"getMountedViews\",\n    value: function getMountedViews() {\n      return Object.keys(this.updates.mounted).map(function (cid) {\n        return CellView.views[cid];\n      });\n    }\n  }, {\n    key: \"getUnmountedViews\",\n    value: function getUnmountedViews() {\n      return Object.keys(this.updates.unmounted).map(function (cid) {\n        return CellView.views[cid];\n      });\n    }\n  }, {\n    key: \"checkMountedViews\",\n    value: function checkMountedViews(viewportFn, batchSize) {\n      var unmountCount = 0;\n\n      if (typeof viewportFn !== 'function') {\n        return unmountCount;\n      }\n\n      var updates = this.updates;\n      var mounted = updates.mounted;\n      var mountedCids = updates.mountedCids;\n      var size = batchSize == null ? mountedCids.length : Math.min(mountedCids.length, batchSize);\n\n      for (var i = 0; i < size; i += 1) {\n        var cid = mountedCids[i];\n\n        if (!(cid in mounted)) {\n          continue;\n        }\n\n        var view = CellView.views[cid];\n\n        if (view == null) {\n          continue;\n        }\n\n        var shouldMount = FunctionExt.call(viewportFn, this.graph, {\n          view: view,\n          unmounted: true\n        });\n\n        if (shouldMount) {\n          // Push at the end of all mounted ids\n          mountedCids.push(cid);\n          continue;\n        }\n\n        unmountCount += 1;\n        var flag = this.registerUnmountedView(view);\n\n        if (flag) {\n          view.unmount();\n        }\n      } // Get rid of views, that have been unmounted\n\n\n      mountedCids.splice(0, size);\n      return unmountCount;\n    }\n  }, {\n    key: \"checkUnmountedViews\",\n    value: function checkUnmountedViews(checkView, batchSize) {\n      var mountCount = 0;\n\n      if (typeof checkView !== 'function') {\n        checkView = null; // eslint-disable-line\n      }\n\n      var updates = this.updates;\n      var unmounted = updates.unmounted;\n      var unmountedCids = updates.unmountedCids;\n      var size = batchSize == null ? unmountedCids.length : Math.min(unmountedCids.length, batchSize);\n\n      for (var i = 0; i < size; i += 1) {\n        var cid = unmountedCids[i];\n\n        if (!(cid in unmounted)) {\n          continue;\n        }\n\n        var view = CellView.views[cid];\n\n        if (view == null) {\n          continue;\n        }\n\n        if (checkView && !FunctionExt.call(checkView, this.graph, {\n          view: view,\n          unmounted: false\n        })) {\n          unmountedCids.push(cid);\n          continue;\n        }\n\n        mountCount += 1;\n        var flag = this.registerMountedView(view);\n\n        if (flag) {\n          this.scheduleViewUpdate(view, flag, view.priority, {\n            mounting: true\n          });\n        }\n      } // Get rid of views, that have been mounted\n\n\n      unmountedCids.splice(0, size);\n      return mountCount;\n    }\n  }, {\n    key: \"checkViewImpl\",\n    value: function checkViewImpl() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n        mountedBatchSize: Number.MAX_SAFE_INTEGER,\n        unmountedBatchSize: Number.MAX_SAFE_INTEGER\n      };\n      var checkView = options.checkView || this.options.checkView;\n      var unmountedCount = this.checkMountedViews(checkView, options.unmountedBatchSize);\n      var mountedCount = this.checkUnmountedViews(checkView, // Do not check views, that have been just unmounted\n      // and pushed at the end of the cids array\n      unmountedCount > 0 ? Math.min(this.updates.unmountedCids.length - unmountedCount, options.mountedBatchSize) : options.mountedBatchSize);\n      return {\n        mountedCount: mountedCount,\n        unmountedCount: unmountedCount\n      };\n    }\n    /**\n     * Determine every view in the graph should be attached/detached.\n     */\n\n  }, {\n    key: \"checkView\",\n    value: function checkView() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.checkViewImpl(options);\n    }\n  }, {\n    key: \"isFrozen\",\n    value: function isFrozen() {\n      return !!this.options.frozen;\n    }\n    /**\n     * Freeze the graph then the graph does not automatically re-render upon\n     * changes in the graph. This is useful when adding large numbers of cells.\n     */\n\n  }, {\n    key: \"freeze\",\n    value: function freeze() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var key = options.key;\n      var updates = this.updates;\n      var frozen = this.options.frozen;\n      var freezeKey = updates.freezeKey;\n\n      if (key && key !== freezeKey) {\n        if (frozen && freezeKey) {\n          // key passed, but the graph is already freezed with another key\n          return;\n        }\n\n        updates.frozen = frozen;\n        updates.freezeKey = key;\n      }\n\n      this.options.frozen = true;\n      var animationId = updates.animationId;\n      updates.animationId = null;\n\n      if (this.isAsync() && animationId != null) {\n        Dom.cancelAnimationFrame(animationId);\n      }\n\n      this.graph.trigger('freeze', {\n        key: key\n      });\n    }\n  }, {\n    key: \"unfreeze\",\n    value: function unfreeze() {\n      var _this2 = this;\n\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var key = options.key;\n      var updates = this.updates;\n      var freezeKey = updates.freezeKey; // key passed, but the graph is already freezed with another key\n\n      if (key && freezeKey && key !== freezeKey) {\n        return;\n      }\n\n      updates.freezeKey = null; // key passed, but the graph is already freezed\n\n      if (key && key === freezeKey && updates.frozen) {\n        return;\n      }\n\n      var callback = function callback() {\n        _this2.options.frozen = updates.frozen = false;\n\n        if (updates.sort) {\n          _this2.sortViews();\n\n          updates.sort = false;\n        }\n\n        var afterFn = options.after;\n\n        if (afterFn) {\n          FunctionExt.call(afterFn, _this2.graph, _this2.graph);\n        }\n\n        _this2.graph.trigger('unfreeze', {\n          key: key\n        });\n      };\n\n      if (this.isAsync()) {\n        this.freeze();\n        var onProgress = options.progress;\n        this.updateViewsAsync(Object.assign(Object.assign({}, options), {\n          progress: function progress(_ref7) {\n            var done = _ref7.done,\n                current = _ref7.current,\n                total = _ref7.total;\n\n            if (onProgress) {\n              FunctionExt.call(onProgress, _this2.graph, {\n                done: done,\n                current: current,\n                total: total\n              });\n            } // sort views after async render\n\n\n            if (done) {\n              callback();\n            }\n          }\n        }));\n      } else {\n        this.updateViews(options);\n        callback();\n      }\n    }\n  }, {\n    key: \"isAsync\",\n    value: function isAsync() {\n      return !!this.options.async;\n    }\n  }, {\n    key: \"setAsync\",\n    value: function setAsync(async) {\n      this.options.async = async;\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.freeze();\n      this.removeViews();\n    }\n  }, {\n    key: \"resetViews\",\n    value: function resetViews() {\n      var cells = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.resetUpdates();\n      this.removeViews();\n      this.freeze({\n        key: 'reset'\n      });\n\n      for (var i = 0, n = cells.length; i < n; i += 1) {\n        this.renderView(cells[i], options);\n      }\n\n      this.unfreeze({\n        key: 'reset'\n      });\n      this.sortViews();\n    }\n  }, {\n    key: \"removeView\",\n    value: function removeView(cell) {\n      var view = this.views[cell.id];\n\n      if (view) {\n        var cid = view.cid;\n        var updates = this.updates;\n        var mounted = updates.mounted;\n        var unmounted = updates.unmounted;\n        view.remove();\n        delete this.views[cell.id];\n        delete mounted[cid];\n        delete unmounted[cid];\n      }\n\n      return view;\n    }\n  }, {\n    key: \"removeViews\",\n    value: function removeViews() {\n      var _this3 = this;\n\n      if (this.views) {\n        Object.keys(this.views).forEach(function (id) {\n          var view = _this3.views[id];\n\n          if (view) {\n            _this3.removeView(view.cell);\n          }\n        });\n      }\n\n      this.views = {};\n    }\n  }, {\n    key: \"renderView\",\n    value: function renderView(cell) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var id = cell.id;\n      var views = this.views;\n      var flag = 0;\n      var view = views[id];\n\n      if (!cell.isVisible()) {\n        return;\n      }\n\n      if (cell.isEdge()) {\n        if (!this.isEdgeTerminalVisible(cell, 'source') || !this.isEdgeTerminalVisible(cell, 'target')) {\n          return;\n        }\n      }\n\n      if (view) {\n        flag = Renderer.FLAG_INSERT;\n      } else {\n        var tmp = this.graph.hook.createCellView(cell);\n\n        if (tmp) {\n          view = views[cell.id] = tmp;\n          view.graph = this.graph;\n          flag = this.registerUnmountedView(view) | view.getBootstrapFlag();\n        }\n      }\n\n      if (view) {\n        this.requestViewUpdate(view, flag, view.priority, options);\n      }\n    }\n  }, {\n    key: \"isExactSorting\",\n    value: function isExactSorting() {\n      return this.options.sorting === 'exact';\n    }\n  }, {\n    key: \"sortViews\",\n    value: function sortViews() {\n      if (!this.isExactSorting()) {\n        return;\n      }\n\n      if (this.isFrozen()) {\n        // sort views once unfrozen\n        this.updates.sort = true;\n        return;\n      }\n\n      this.sortViewsExact();\n    }\n  }, {\n    key: \"sortElements\",\n    value: function sortElements(elems, comparator) {\n      // Highly inspired by the jquery.sortElements plugin by Padolsey.\n      // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n      var placements = elems.map(function (elem) {\n        var parentNode = elem.parentNode; // Since the element itself will change position, we have\n        // to have some way of storing it's original position in\n        // the DOM. The easiest way is to have a 'flag' node:\n\n        var nextSibling = parentNode.insertBefore(document.createTextNode(''), elem.nextSibling);\n        return function (targetNode) {\n          if (parentNode === targetNode) {\n            throw new Error(\"You can't sort elements if any one is a descendant of another.\");\n          } // Insert before flag\n\n\n          parentNode.insertBefore(targetNode, nextSibling); // Remove flag\n\n          parentNode.removeChild(nextSibling);\n        };\n      });\n      elems.sort(comparator).forEach(function (elem, index) {\n        return placements[index](elem);\n      });\n    }\n  }, {\n    key: \"sortViewsExact\",\n    value: function sortViewsExact() {\n      // const elems = this.view.stage.querySelectorAll('[data-cell-id]')\n      // const length = elems.length\n      // const cells = []\n      // for (let i = 0; i < length; i++) {\n      //   const cell = this.model.getCell(elems[i].getAttribute('data-cell-id') || '')\n      //   cells.push({\n      //     id: cell.id,\n      //     zIndex: cell.getZIndex() || 0,\n      //     elem: elems[i],\n      //   })\n      // }\n      // const sortedCells = [...cells].sort((cell1, cell2) => cell1.zIndex - cell2.zIndex)\n      // const moves = ArrayExt.diff(cells, sortedCells, 'zIndex').moves\n      // if (moves && moves.length) {\n      //   moves.forEach((move) => {\n      //     if (move.type) {\n      //       const elem = move.item.elem as Element\n      //       const parentNode = elem.parentNode\n      //       const index = move.index\n      //       if (parentNode) {\n      //         if (index === length - 1) {\n      //           parentNode.appendChild(elem)\n      //         } else if (index < length - 1) {\n      //           parentNode.insertBefore(elem, elems[index + 1])\n      //         }\n      //       }\n      //     }\n      //   })\n      // }\n      // Run insertion sort algorithm in order to efficiently sort DOM\n      // elements according to their associated cell `zIndex` attribute.\n      var elems = this.view.$(this.view.stage).children('[data-cell-id]').toArray();\n      var model = this.model;\n      this.sortElements(elems, function (a, b) {\n        var cellA = model.getCell(a.getAttribute('data-cell-id') || '');\n        var cellB = model.getCell(b.getAttribute('data-cell-id') || '');\n        var z1 = cellA.getZIndex() || 0;\n        var z2 = cellB.getZIndex() || 0;\n        return z1 === z2 ? 0 : z1 < z2 ? -1 : 1;\n      });\n    }\n  }, {\n    key: \"addZPivot\",\n    value: function addZPivot() {\n      var zIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      if (this.zPivots == null) {\n        this.zPivots = {};\n      }\n\n      var pivots = this.zPivots;\n      var pivot = pivots[zIndex];\n\n      if (pivot) {\n        return pivot;\n      }\n\n      pivot = pivots[zIndex] = document.createComment(\"z-index:\".concat(zIndex + 1));\n      var neighborZ = -Infinity; // eslint-disable-next-line\n\n      for (var key in pivots) {\n        var currentZ = +key;\n\n        if (currentZ < zIndex && currentZ > neighborZ) {\n          neighborZ = currentZ;\n\n          if (neighborZ === zIndex - 1) {\n            continue;\n          }\n        }\n      }\n\n      var layer = this.view.stage;\n\n      if (neighborZ !== -Infinity) {\n        var neighborPivot = pivots[neighborZ];\n        layer.insertBefore(pivot, neighborPivot.nextSibling);\n      } else {\n        layer.insertBefore(pivot, layer.firstChild);\n      }\n\n      return pivot;\n    }\n  }, {\n    key: \"removeZPivots\",\n    value: function removeZPivots() {\n      var _this4 = this;\n\n      if (this.zPivots) {\n        Object.keys(this.zPivots).forEach(function (z) {\n          var elem = _this4.zPivots[z];\n\n          if (elem && elem.parentNode) {\n            elem.parentNode.removeChild(elem);\n          }\n        });\n      }\n\n      this.zPivots = {};\n    }\n  }, {\n    key: \"insertView\",\n    value: function insertView(view) {\n      var stage = this.view.stage;\n\n      switch (this.options.sorting) {\n        case 'approx':\n          {\n            var zIndex = view.cell.getZIndex();\n            var pivot = this.addZPivot(zIndex);\n            stage.insertBefore(view.container, pivot);\n            break;\n          }\n\n        case 'exact':\n        default:\n          stage.appendChild(view.container);\n          break;\n      }\n    }\n  }, {\n    key: \"findViewByCell\",\n    value: function findViewByCell(cell) {\n      if (cell == null) {\n        return null;\n      }\n\n      var id = Cell.isCell(cell) ? cell.id : cell;\n      return this.views[id];\n    }\n  }, {\n    key: \"findViewByElem\",\n    value: function findViewByElem(elem) {\n      if (elem == null) {\n        return null;\n      }\n\n      var target = typeof elem === 'string' ? this.view.stage.querySelector(elem) : elem instanceof Element ? elem : elem[0];\n\n      if (target) {\n        var id = this.view.findAttr('data-cell-id', target);\n\n        if (id) {\n          return this.views[id];\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"findViewsFromPoint\",\n    value: function findViewsFromPoint(p) {\n      var _this5 = this;\n\n      var ref = {\n        x: p.x,\n        y: p.y\n      };\n      return this.model.getCells().map(function (cell) {\n        return _this5.findViewByCell(cell);\n      }).filter(function (view) {\n        if (view != null) {\n          return Dom.getBBox(view.container, {\n            target: _this5.view.stage\n          }).containsPoint(ref);\n        }\n\n        return false;\n      });\n    }\n  }, {\n    key: \"findEdgeViewsInArea\",\n    value: function findEdgeViewsInArea(rect) {\n      var _this6 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var area = Rectangle.create(rect);\n      return this.model.getEdges().map(function (edge) {\n        return _this6.findViewByCell(edge);\n      }).filter(function (view) {\n        if (view) {\n          var bbox = Dom.getBBox(view.container, {\n            target: _this6.view.stage\n          });\n\n          if (bbox.width === 0) {\n            bbox.inflate(1, 0);\n          } else if (bbox.height === 0) {\n            bbox.inflate(0, 1);\n          }\n\n          return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n        }\n\n        return false;\n      });\n    }\n  }, {\n    key: \"findViewsInArea\",\n    value: function findViewsInArea(rect) {\n      var _this7 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var area = Rectangle.create(rect);\n      return this.model.getNodes().map(function (node) {\n        return _this7.findViewByCell(node);\n      }).filter(function (view) {\n        if (view) {\n          var bbox = Dom.getBBox(view.container, {\n            target: _this7.view.stage\n          });\n          return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n        }\n\n        return false;\n      });\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.resetUpdates();\n      this.stopListening();\n    }\n  }]);\n\n  return Renderer;\n}(Base);\n\n__decorate([Base.dispose()], Renderer.prototype, \"dispose\", null);\n\n(function (Renderer) {\n  Renderer.FLAG_INSERT = 1 << 30;\n  Renderer.FLAG_REMOVE = 1 << 29;\n  Renderer.MOUNT_BATCH_SIZE = 1000;\n  Renderer.UPDATE_BATCH_SIZE = 1000;\n  Renderer.MIN_PRIORITY = 2;\n  Renderer.SORT_DELAYING_BATCHES = ['add', 'to-front', 'to-back'];\n  Renderer.UPDATE_DELAYING_BATCHES = ['translate'];\n})(Renderer || (Renderer = {}));","map":{"version":3,"sources":["../../src/graph/renderer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Dom, FunctionExt } from '../util';\nimport { Rectangle } from '../geometry';\nimport { Cell } from '../model';\nimport { View, CellView } from '../view';\nimport { Base } from './base';\nexport class Renderer extends Base {\n    init() {\n        this.resetUpdates();\n        this.startListening();\n        // Renders existing cells in the model.\n        this.resetViews(this.model.getCells());\n        // Starts rendering loop.\n        if (!this.isFrozen() && this.isAsync()) {\n            this.updateViewsAsync();\n        }\n    }\n    startListening() {\n        this.model.on('sorted', this.onSortModel, this);\n        this.model.on('reseted', this.onModelReseted, this);\n        this.model.on('batch:stop', this.onBatchStop, this);\n        this.model.on('cell:added', this.onCellAdded, this);\n        this.model.on('cell:removed', this.onCellRemoved, this);\n        this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);\n        this.model.on('cell:change:visible', this.onCellVisibleChanged, this);\n    }\n    stopListening() {\n        this.model.off('sorted', this.onSortModel, this);\n        this.model.off('reseted', this.onModelReseted, this);\n        this.model.off('batch:stop', this.onBatchStop, this);\n        this.model.off('cell:added', this.onCellAdded, this);\n        this.model.off('cell:removed', this.onCellRemoved, this);\n        this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);\n        this.model.off('cell:change:visible', this.onCellVisibleChanged, this);\n    }\n    resetUpdates() {\n        this.updates = {\n            priorities: [{}, {}, {}],\n            mounted: {},\n            mountedCids: [],\n            unmounted: {},\n            unmountedCids: [],\n            count: 0,\n            sort: false,\n            frozen: false,\n            freezeKey: null,\n            animationId: null,\n        };\n    }\n    onSortModel() {\n        if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {\n            return;\n        }\n        this.sortViews();\n    }\n    onModelReseted({ options }) {\n        this.removeZPivots();\n        this.resetViews(this.model.getCells(), options);\n    }\n    onBatchStop({ name, data }) {\n        if (this.isFrozen()) {\n            return;\n        }\n        const model = this.model;\n        if (!this.isAsync()) {\n            const updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES;\n            if (updateDelayingBatches.includes(name) &&\n                !model.hasActiveBatch(updateDelayingBatches)) {\n                this.updateViews(data);\n            }\n        }\n        const sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES;\n        if (sortDelayingBatches.includes(name) &&\n            !model.hasActiveBatch(sortDelayingBatches)) {\n            this.sortViews();\n        }\n    }\n    onCellAdded({ cell, options }) {\n        const position = options.position;\n        if (this.isAsync() || typeof position !== 'number') {\n            this.renderView(cell, options);\n        }\n        else {\n            if (options.maxPosition === position) {\n                this.freeze({ key: 'addCells' });\n            }\n            this.renderView(cell, options);\n            if (position === 0) {\n                this.unfreeze({ key: 'addCells' });\n            }\n        }\n    }\n    onCellRemoved({ cell, options }) {\n        const view = this.findViewByCell(cell);\n        if (view) {\n            this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options);\n        }\n    }\n    onCellZIndexChanged({ cell, options, }) {\n        if (this.options.sorting === 'approx') {\n            const view = this.findViewByCell(cell);\n            if (view) {\n                this.requestViewUpdate(view, Renderer.FLAG_INSERT, view.priority, options);\n            }\n        }\n    }\n    onCellVisibleChanged({ cell, current: visible, options, }) {\n        // Hide connected edges before cell\n        if (!visible) {\n            this.processEdgeOnTerminalVisibleChanged(cell, false);\n        }\n        const view = this.findViewByCell(cell);\n        if (!visible && view) {\n            this.removeView(cell);\n        }\n        else if (visible && view == null) {\n            this.renderView(cell, options);\n        }\n        // Show connected edges after cell rendered\n        if (visible) {\n            this.processEdgeOnTerminalVisibleChanged(cell, true);\n        }\n    }\n    processEdgeOnTerminalVisibleChanged(node, visible) {\n        const getOpposite = (edge, currentTerminal) => {\n            const sourceId = edge.getSourceCellId();\n            if (sourceId !== currentTerminal.id) {\n                return edge.getSourceCell();\n            }\n            const targetId = edge.getTargetCellId();\n            if (targetId !== currentTerminal.id) {\n                return edge.getTargetCell();\n            }\n            return null;\n        };\n        this.model.getConnectedEdges(node).forEach((edge) => {\n            const opposite = getOpposite(edge, node);\n            if (opposite == null || opposite.isVisible()) {\n                visible ? edge.show() : edge.hide();\n            }\n        });\n    }\n    isEdgeTerminalVisible(edge, terminal) {\n        const cellId = terminal === 'source' ? edge.getSourceCellId() : edge.getTargetCellId();\n        const cell = cellId ? this.model.getCell(cellId) : null;\n        if (cell && !cell.isVisible()) {\n            return false;\n        }\n        return true;\n    }\n    requestConnectedEdgesUpdate(view, options = {}) {\n        if (CellView.isCellView(view)) {\n            const cell = view.cell;\n            const edges = this.model.getConnectedEdges(cell);\n            for (let j = 0, n = edges.length; j < n; j += 1) {\n                const edge = edges[j];\n                const edgeView = this.findViewByCell(edge);\n                if (!edgeView) {\n                    continue;\n                }\n                const flagLabels = ['update'];\n                if (edge.getTargetCell() === cell) {\n                    flagLabels.push('target');\n                }\n                if (edge.getSourceCell() === cell) {\n                    flagLabels.push('source');\n                }\n                this.scheduleViewUpdate(edgeView, edgeView.getFlag(flagLabels), edgeView.priority, options);\n            }\n        }\n    }\n    forcePostponedViewUpdate(view, flag) {\n        if (!view || !CellView.isCellView(view)) {\n            return false;\n        }\n        const cell = view.cell;\n        if (cell.isNode()) {\n            return false;\n        }\n        const edgeView = view;\n        if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {\n            // EdgeView is waiting for the source/target cellView to be rendered.\n            // This can happen when the cells are not in the viewport.\n            let sourceFlag = 0;\n            const sourceView = this.findViewByCell(cell.getSourceCell());\n            if (sourceView && !this.isViewMounted(sourceView)) {\n                sourceFlag = this.dumpView(sourceView);\n                edgeView.updateTerminalMagnet('source');\n            }\n            let targetFlag = 0;\n            const targetView = this.findViewByCell(cell.getTargetCell());\n            if (targetView && !this.isViewMounted(targetView)) {\n                targetFlag = this.dumpView(targetView);\n                edgeView.updateTerminalMagnet('target');\n            }\n            if (sourceFlag === 0 && targetFlag === 0) {\n                // If leftover flag is 0, all view updates were done.\n                return !this.dumpView(edgeView);\n            }\n        }\n        return false;\n    }\n    scheduleViewUpdate(view, flag, priority, options = {}) {\n        const cid = view.cid;\n        const updates = this.updates;\n        let cache = updates.priorities[priority];\n        if (!cache) {\n            cache = updates.priorities[priority] = {};\n        }\n        const currentFlag = cache[cid] || 0;\n        if ((currentFlag & flag) === flag) {\n            return;\n        }\n        if (!currentFlag) {\n            updates.count += 1;\n        }\n        if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {\n            // When a view is removed we need to remove the\n            // insert flag as this is a reinsert.\n            cache[cid] ^= Renderer.FLAG_INSERT;\n        }\n        else if (flag & Renderer.FLAG_INSERT &&\n            currentFlag & Renderer.FLAG_REMOVE) {\n            // When a view is added we need to remove the remove\n            // flag as this is view was previously removed.\n            cache[cid] ^= Renderer.FLAG_REMOVE;\n        }\n        cache[cid] |= flag;\n        this.graph.hook.onViewUpdated(view, flag, options);\n    }\n    requestViewUpdate(view, flag, priority, options = {}) {\n        this.scheduleViewUpdate(view, flag, priority, options);\n        const isAsync = this.isAsync();\n        if (this.isFrozen() ||\n            (isAsync && options.async !== false) ||\n            this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)) {\n            return;\n        }\n        const stats = this.updateViews(options);\n        if (isAsync) {\n            this.graph.trigger('render:done', { stats, options });\n        }\n    }\n    /**\n     * Adds view into the DOM and update it.\n     */\n    dumpView(view, options = {}) {\n        if (view == null) {\n            return 0;\n        }\n        const cid = view.cid;\n        const updates = this.updates;\n        const cache = updates.priorities[view.priority];\n        const flag = this.registerMountedView(view) | cache[cid];\n        delete cache[cid];\n        if (!flag) {\n            return 0;\n        }\n        return this.updateView(view, flag, options);\n    }\n    /**\n     * Adds all views into the DOM and update them.\n     */\n    dumpViews(options = {}) {\n        this.checkView(options);\n        this.updateViews(options);\n    }\n    /**\n     * Ensure the view associated with the cell is attached\n     * to the DOM and updated.\n     */\n    requireView(cell, options = {}) {\n        const view = this.findViewByCell(cell);\n        if (view == null) {\n            return null;\n        }\n        this.dumpView(view, options);\n        return view;\n    }\n    updateView(view, flag, options = {}) {\n        if (view == null) {\n            return 0;\n        }\n        if (CellView.isCellView(view)) {\n            if (flag & Renderer.FLAG_REMOVE) {\n                this.removeView(view.cell);\n                return 0;\n            }\n            if (flag & Renderer.FLAG_INSERT) {\n                this.insertView(view);\n                flag ^= Renderer.FLAG_INSERT; // eslint-disable-line\n            }\n        }\n        if (!flag) {\n            return 0;\n        }\n        return view.confirmUpdate(flag, options);\n    }\n    updateViews(options = {}) {\n        let result;\n        let batchCount = 0;\n        let updatedCount = 0;\n        let priority = Renderer.MIN_PRIORITY;\n        do {\n            result = this.updateViewsBatch(options);\n            batchCount += 1;\n            updatedCount += result.updatedCount;\n            priority = Math.min(result.priority, priority);\n        } while (!result.empty);\n        return {\n            priority,\n            batchCount,\n            updatedCount,\n        };\n    }\n    updateViewsBatch(options = {}) {\n        const updates = this.updates;\n        const priorities = updates.priorities;\n        const batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE;\n        let empty = true;\n        let priority = Renderer.MIN_PRIORITY;\n        let mountedCount = 0;\n        let unmountedCount = 0;\n        let updatedCount = 0;\n        let postponedCount = 0;\n        let checkView = options.checkView || this.options.checkView;\n        if (typeof checkView !== 'function') {\n            checkView = null;\n        }\n        // eslint-disable-next-line\n        main: for (let p = 0, n = priorities.length; p < n; p += 1) {\n            const cache = priorities[p];\n            // eslint-disable-next-line\n            for (const cid in cache) {\n                if (updatedCount >= batchSize) {\n                    empty = false; // goto next batch\n                    break main; // eslint-disable-line no-labels\n                }\n                const view = View.views[cid];\n                if (!view) {\n                    delete cache[cid];\n                    continue;\n                }\n                let currentFlag = cache[cid];\n                // Do not check a view for viewport if we are about to remove the view.\n                if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {\n                    const isUnmounted = cid in updates.unmounted;\n                    if (checkView &&\n                        !FunctionExt.call(checkView, this.graph, {\n                            view: view,\n                            unmounted: isUnmounted,\n                        })) {\n                        // Unmount view\n                        if (!isUnmounted) {\n                            this.registerUnmountedView(view);\n                            view.unmount();\n                        }\n                        updates.unmounted[cid] |= currentFlag;\n                        delete cache[cid];\n                        unmountedCount += 1;\n                        continue;\n                    }\n                    // Mount view\n                    if (isUnmounted) {\n                        currentFlag |= Renderer.FLAG_INSERT;\n                        mountedCount += 1;\n                    }\n                    currentFlag |= this.registerMountedView(view);\n                }\n                const cellView = view;\n                let leftoverFlag = this.updateView(view, currentFlag, options);\n                if (leftoverFlag > 0) {\n                    const cell = cellView.cell;\n                    if (cell && cell.isEdge()) {\n                        // remove edge view when source cell is invisible\n                        if (cellView.hasAction(leftoverFlag, 'source') &&\n                            !this.isEdgeTerminalVisible(cell, 'source')) {\n                            leftoverFlag = cellView.removeAction(leftoverFlag, 'source');\n                            leftoverFlag |= Renderer.FLAG_REMOVE;\n                        }\n                        // remove edge view when target cell is invisible\n                        if (cellView.hasAction(leftoverFlag, 'target') &&\n                            !this.isEdgeTerminalVisible(cell, 'target')) {\n                            leftoverFlag = cellView.removeAction(leftoverFlag, 'target');\n                            leftoverFlag |= Renderer.FLAG_REMOVE;\n                        }\n                    }\n                }\n                if (leftoverFlag > 0) {\n                    // update has not finished\n                    cache[cid] = leftoverFlag;\n                    if (!this.graph.hook.onViewPostponed(cellView, leftoverFlag, options) ||\n                        cache[cid]) {\n                        postponedCount += 1;\n                        empty = false;\n                        continue;\n                    }\n                }\n                if (priority > p) {\n                    priority = p;\n                }\n                updatedCount += 1;\n                delete cache[cid];\n            }\n        }\n        return {\n            empty,\n            priority,\n            mountedCount,\n            unmountedCount,\n            updatedCount,\n            postponedCount,\n        };\n    }\n    updateViewsAsync(options = {}, data = {\n        processed: 0,\n        priority: Renderer.MIN_PRIORITY,\n    }) {\n        const updates = this.updates;\n        const animationId = updates.animationId;\n        if (animationId) {\n            Dom.cancelAnimationFrame(animationId);\n            if (data.processed === 0) {\n                const beforeFn = options.before;\n                if (typeof beforeFn === 'function') {\n                    FunctionExt.call(beforeFn, this.graph, this.graph);\n                }\n            }\n            const stats = this.updateViewsBatch(options);\n            const checkout = this.checkViewImpl({\n                checkView: options.checkView,\n                mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,\n                unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount,\n            });\n            let processed = data.processed;\n            const total = updates.count;\n            const mountedCount = checkout.mountedCount;\n            const unmountedCount = checkout.unmountedCount;\n            if (stats.updatedCount > 0) {\n                // Some updates have been just processed\n                processed += stats.updatedCount + stats.unmountedCount;\n                data.priority = Math.min(stats.priority, data.priority);\n                if (stats.empty && mountedCount === 0) {\n                    stats.priority = data.priority;\n                    stats.mountedCount += mountedCount;\n                    stats.unmountedCount += unmountedCount;\n                    this.graph.trigger('render:done', { stats, options });\n                    data.processed = 0;\n                    updates.count = 0;\n                }\n                else {\n                    data.processed = processed;\n                }\n            }\n            // Progress callback\n            const progressFn = options.progress;\n            if (total && typeof progressFn === 'function') {\n                FunctionExt.call(progressFn, this.graph, {\n                    total,\n                    done: stats.empty,\n                    current: processed,\n                });\n            }\n            // The current frame could have been canceled in a callback\n            if (updates.animationId !== animationId) {\n                return;\n            }\n        }\n        updates.animationId = Dom.requestAnimationFrame(() => {\n            this.updateViewsAsync(options, data);\n        });\n    }\n    registerMountedView(view) {\n        const cid = view.cid;\n        const updates = this.updates;\n        if (cid in updates.mounted) {\n            return 0;\n        }\n        updates.mounted[cid] = true;\n        updates.mountedCids.push(cid);\n        const flag = updates.unmounted[cid] || 0;\n        delete updates.unmounted[cid];\n        return flag;\n    }\n    registerUnmountedView(view) {\n        const cid = view.cid;\n        const updates = this.updates;\n        if (cid in updates.unmounted) {\n            return 0;\n        }\n        updates.unmounted[cid] |= Renderer.FLAG_INSERT;\n        const flag = updates.unmounted[cid];\n        updates.unmountedCids.push(cid);\n        delete updates.mounted[cid];\n        return flag;\n    }\n    isViewMounted(view) {\n        if (view == null) {\n            return false;\n        }\n        const cid = view.cid;\n        return cid in this.updates.mounted;\n    }\n    getMountedViews() {\n        return Object.keys(this.updates.mounted).map((cid) => CellView.views[cid]);\n    }\n    getUnmountedViews() {\n        return Object.keys(this.updates.unmounted).map((cid) => CellView.views[cid]);\n    }\n    checkMountedViews(viewportFn, batchSize) {\n        let unmountCount = 0;\n        if (typeof viewportFn !== 'function') {\n            return unmountCount;\n        }\n        const updates = this.updates;\n        const mounted = updates.mounted;\n        const mountedCids = updates.mountedCids;\n        const size = batchSize == null\n            ? mountedCids.length\n            : Math.min(mountedCids.length, batchSize);\n        for (let i = 0; i < size; i += 1) {\n            const cid = mountedCids[i];\n            if (!(cid in mounted)) {\n                continue;\n            }\n            const view = CellView.views[cid];\n            if (view == null) {\n                continue;\n            }\n            const shouldMount = FunctionExt.call(viewportFn, this.graph, {\n                view: view,\n                unmounted: true,\n            });\n            if (shouldMount) {\n                // Push at the end of all mounted ids\n                mountedCids.push(cid);\n                continue;\n            }\n            unmountCount += 1;\n            const flag = this.registerUnmountedView(view);\n            if (flag) {\n                view.unmount();\n            }\n        }\n        // Get rid of views, that have been unmounted\n        mountedCids.splice(0, size);\n        return unmountCount;\n    }\n    checkUnmountedViews(checkView, batchSize) {\n        let mountCount = 0;\n        if (typeof checkView !== 'function') {\n            checkView = null; // eslint-disable-line\n        }\n        const updates = this.updates;\n        const unmounted = updates.unmounted;\n        const unmountedCids = updates.unmountedCids;\n        const size = batchSize == null\n            ? unmountedCids.length\n            : Math.min(unmountedCids.length, batchSize);\n        for (let i = 0; i < size; i += 1) {\n            const cid = unmountedCids[i];\n            if (!(cid in unmounted)) {\n                continue;\n            }\n            const view = CellView.views[cid];\n            if (view == null) {\n                continue;\n            }\n            if (checkView &&\n                !FunctionExt.call(checkView, this.graph, { view, unmounted: false })) {\n                unmountedCids.push(cid);\n                continue;\n            }\n            mountCount += 1;\n            const flag = this.registerMountedView(view);\n            if (flag) {\n                this.scheduleViewUpdate(view, flag, view.priority, {\n                    mounting: true,\n                });\n            }\n        }\n        // Get rid of views, that have been mounted\n        unmountedCids.splice(0, size);\n        return mountCount;\n    }\n    checkViewImpl(options = {\n        mountedBatchSize: Number.MAX_SAFE_INTEGER,\n        unmountedBatchSize: Number.MAX_SAFE_INTEGER,\n    }) {\n        const checkView = options.checkView || this.options.checkView;\n        const unmountedCount = this.checkMountedViews(checkView, options.unmountedBatchSize);\n        const mountedCount = this.checkUnmountedViews(checkView, \n        // Do not check views, that have been just unmounted\n        // and pushed at the end of the cids array\n        unmountedCount > 0\n            ? Math.min(this.updates.unmountedCids.length - unmountedCount, options.mountedBatchSize)\n            : options.mountedBatchSize);\n        return { mountedCount, unmountedCount };\n    }\n    /**\n     * Determine every view in the graph should be attached/detached.\n     */\n    checkView(options = {}) {\n        return this.checkViewImpl(options);\n    }\n    isFrozen() {\n        return !!this.options.frozen;\n    }\n    /**\n     * Freeze the graph then the graph does not automatically re-render upon\n     * changes in the graph. This is useful when adding large numbers of cells.\n     */\n    freeze(options = {}) {\n        const key = options.key;\n        const updates = this.updates;\n        const frozen = this.options.frozen;\n        const freezeKey = updates.freezeKey;\n        if (key && key !== freezeKey) {\n            if (frozen && freezeKey) {\n                // key passed, but the graph is already freezed with another key\n                return;\n            }\n            updates.frozen = frozen;\n            updates.freezeKey = key;\n        }\n        this.options.frozen = true;\n        const animationId = updates.animationId;\n        updates.animationId = null;\n        if (this.isAsync() && animationId != null) {\n            Dom.cancelAnimationFrame(animationId);\n        }\n        this.graph.trigger('freeze', { key });\n    }\n    unfreeze(options = {}) {\n        const key = options.key;\n        const updates = this.updates;\n        const freezeKey = updates.freezeKey;\n        // key passed, but the graph is already freezed with another key\n        if (key && freezeKey && key !== freezeKey) {\n            return;\n        }\n        updates.freezeKey = null;\n        // key passed, but the graph is already freezed\n        if (key && key === freezeKey && updates.frozen) {\n            return;\n        }\n        const callback = () => {\n            this.options.frozen = updates.frozen = false;\n            if (updates.sort) {\n                this.sortViews();\n                updates.sort = false;\n            }\n            const afterFn = options.after;\n            if (afterFn) {\n                FunctionExt.call(afterFn, this.graph, this.graph);\n            }\n            this.graph.trigger('unfreeze', { key });\n        };\n        if (this.isAsync()) {\n            this.freeze();\n            const onProgress = options.progress;\n            this.updateViewsAsync(Object.assign(Object.assign({}, options), { progress: ({ done, current, total }) => {\n                    if (onProgress) {\n                        FunctionExt.call(onProgress, this.graph, { done, current, total });\n                    }\n                    // sort views after async render\n                    if (done) {\n                        callback();\n                    }\n                } }));\n        }\n        else {\n            this.updateViews(options);\n            callback();\n        }\n    }\n    isAsync() {\n        return !!this.options.async;\n    }\n    setAsync(async) {\n        this.options.async = async;\n    }\n    onRemove() {\n        this.freeze();\n        this.removeViews();\n    }\n    resetViews(cells = [], options = {}) {\n        this.resetUpdates();\n        this.removeViews();\n        this.freeze({ key: 'reset' });\n        for (let i = 0, n = cells.length; i < n; i += 1) {\n            this.renderView(cells[i], options);\n        }\n        this.unfreeze({ key: 'reset' });\n        this.sortViews();\n    }\n    removeView(cell) {\n        const view = this.views[cell.id];\n        if (view) {\n            const cid = view.cid;\n            const updates = this.updates;\n            const mounted = updates.mounted;\n            const unmounted = updates.unmounted;\n            view.remove();\n            delete this.views[cell.id];\n            delete mounted[cid];\n            delete unmounted[cid];\n        }\n        return view;\n    }\n    removeViews() {\n        if (this.views) {\n            Object.keys(this.views).forEach((id) => {\n                const view = this.views[id];\n                if (view) {\n                    this.removeView(view.cell);\n                }\n            });\n        }\n        this.views = {};\n    }\n    renderView(cell, options = {}) {\n        const id = cell.id;\n        const views = this.views;\n        let flag = 0;\n        let view = views[id];\n        if (!cell.isVisible()) {\n            return;\n        }\n        if (cell.isEdge()) {\n            if (!this.isEdgeTerminalVisible(cell, 'source') ||\n                !this.isEdgeTerminalVisible(cell, 'target')) {\n                return;\n            }\n        }\n        if (view) {\n            flag = Renderer.FLAG_INSERT;\n        }\n        else {\n            const tmp = this.graph.hook.createCellView(cell);\n            if (tmp) {\n                view = views[cell.id] = tmp;\n                view.graph = this.graph;\n                flag = this.registerUnmountedView(view) | view.getBootstrapFlag();\n            }\n        }\n        if (view) {\n            this.requestViewUpdate(view, flag, view.priority, options);\n        }\n    }\n    isExactSorting() {\n        return this.options.sorting === 'exact';\n    }\n    sortViews() {\n        if (!this.isExactSorting()) {\n            return;\n        }\n        if (this.isFrozen()) {\n            // sort views once unfrozen\n            this.updates.sort = true;\n            return;\n        }\n        this.sortViewsExact();\n    }\n    sortElements(elems, comparator) {\n        // Highly inspired by the jquery.sortElements plugin by Padolsey.\n        // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n        const placements = elems.map((elem) => {\n            const parentNode = elem.parentNode;\n            // Since the element itself will change position, we have\n            // to have some way of storing it's original position in\n            // the DOM. The easiest way is to have a 'flag' node:\n            const nextSibling = parentNode.insertBefore(document.createTextNode(''), elem.nextSibling);\n            return (targetNode) => {\n                if (parentNode === targetNode) {\n                    throw new Error(\"You can't sort elements if any one is a descendant of another.\");\n                }\n                // Insert before flag\n                parentNode.insertBefore(targetNode, nextSibling);\n                // Remove flag\n                parentNode.removeChild(nextSibling);\n            };\n        });\n        elems.sort(comparator).forEach((elem, index) => placements[index](elem));\n    }\n    sortViewsExact() {\n        // const elems = this.view.stage.querySelectorAll('[data-cell-id]')\n        // const length = elems.length\n        // const cells = []\n        // for (let i = 0; i < length; i++) {\n        //   const cell = this.model.getCell(elems[i].getAttribute('data-cell-id') || '')\n        //   cells.push({\n        //     id: cell.id,\n        //     zIndex: cell.getZIndex() || 0,\n        //     elem: elems[i],\n        //   })\n        // }\n        // const sortedCells = [...cells].sort((cell1, cell2) => cell1.zIndex - cell2.zIndex)\n        // const moves = ArrayExt.diff(cells, sortedCells, 'zIndex').moves\n        // if (moves && moves.length) {\n        //   moves.forEach((move) => {\n        //     if (move.type) {\n        //       const elem = move.item.elem as Element\n        //       const parentNode = elem.parentNode\n        //       const index = move.index\n        //       if (parentNode) {\n        //         if (index === length - 1) {\n        //           parentNode.appendChild(elem)\n        //         } else if (index < length - 1) {\n        //           parentNode.insertBefore(elem, elems[index + 1])\n        //         }\n        //       }\n        //     }\n        //   })\n        // }\n        // Run insertion sort algorithm in order to efficiently sort DOM\n        // elements according to their associated cell `zIndex` attribute.\n        const elems = this.view\n            .$(this.view.stage)\n            .children('[data-cell-id]')\n            .toArray();\n        const model = this.model;\n        this.sortElements(elems, (a, b) => {\n            const cellA = model.getCell(a.getAttribute('data-cell-id') || '');\n            const cellB = model.getCell(b.getAttribute('data-cell-id') || '');\n            const z1 = cellA.getZIndex() || 0;\n            const z2 = cellB.getZIndex() || 0;\n            return z1 === z2 ? 0 : z1 < z2 ? -1 : 1;\n        });\n    }\n    addZPivot(zIndex = 0) {\n        if (this.zPivots == null) {\n            this.zPivots = {};\n        }\n        const pivots = this.zPivots;\n        let pivot = pivots[zIndex];\n        if (pivot) {\n            return pivot;\n        }\n        pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);\n        let neighborZ = -Infinity;\n        // eslint-disable-next-line\n        for (const key in pivots) {\n            const currentZ = +key;\n            if (currentZ < zIndex && currentZ > neighborZ) {\n                neighborZ = currentZ;\n                if (neighborZ === zIndex - 1) {\n                    continue;\n                }\n            }\n        }\n        const layer = this.view.stage;\n        if (neighborZ !== -Infinity) {\n            const neighborPivot = pivots[neighborZ];\n            layer.insertBefore(pivot, neighborPivot.nextSibling);\n        }\n        else {\n            layer.insertBefore(pivot, layer.firstChild);\n        }\n        return pivot;\n    }\n    removeZPivots() {\n        if (this.zPivots) {\n            Object.keys(this.zPivots).forEach((z) => {\n                const elem = this.zPivots[z];\n                if (elem && elem.parentNode) {\n                    elem.parentNode.removeChild(elem);\n                }\n            });\n        }\n        this.zPivots = {};\n    }\n    insertView(view) {\n        const stage = this.view.stage;\n        switch (this.options.sorting) {\n            case 'approx': {\n                const zIndex = view.cell.getZIndex();\n                const pivot = this.addZPivot(zIndex);\n                stage.insertBefore(view.container, pivot);\n                break;\n            }\n            case 'exact':\n            default:\n                stage.appendChild(view.container);\n                break;\n        }\n    }\n    findViewByCell(cell) {\n        if (cell == null) {\n            return null;\n        }\n        const id = Cell.isCell(cell) ? cell.id : cell;\n        return this.views[id];\n    }\n    findViewByElem(elem) {\n        if (elem == null) {\n            return null;\n        }\n        const target = typeof elem === 'string'\n            ? this.view.stage.querySelector(elem)\n            : elem instanceof Element\n                ? elem\n                : elem[0];\n        if (target) {\n            const id = this.view.findAttr('data-cell-id', target);\n            if (id) {\n                return this.views[id];\n            }\n        }\n        return null;\n    }\n    findViewsFromPoint(p) {\n        const ref = { x: p.x, y: p.y };\n        return this.model\n            .getCells()\n            .map((cell) => this.findViewByCell(cell))\n            .filter((view) => {\n            if (view != null) {\n                return Dom.getBBox(view.container, {\n                    target: this.view.stage,\n                }).containsPoint(ref);\n            }\n            return false;\n        });\n    }\n    findEdgeViewsInArea(rect, options = {}) {\n        const area = Rectangle.create(rect);\n        return this.model\n            .getEdges()\n            .map((edge) => this.findViewByCell(edge))\n            .filter((view) => {\n            if (view) {\n                const bbox = Dom.getBBox(view.container, {\n                    target: this.view.stage,\n                });\n                if (bbox.width === 0) {\n                    bbox.inflate(1, 0);\n                }\n                else if (bbox.height === 0) {\n                    bbox.inflate(0, 1);\n                }\n                return options.strict\n                    ? area.containsRect(bbox)\n                    : area.isIntersectWithRect(bbox);\n            }\n            return false;\n        });\n    }\n    findViewsInArea(rect, options = {}) {\n        const area = Rectangle.create(rect);\n        return this.model\n            .getNodes()\n            .map((node) => this.findViewByCell(node))\n            .filter((view) => {\n            if (view) {\n                const bbox = Dom.getBBox(view.container, {\n                    target: this.view.stage,\n                });\n                return options.strict\n                    ? area.containsRect(bbox)\n                    : area.isIntersectWithRect(bbox);\n            }\n            return false;\n        });\n    }\n    dispose() {\n        this.resetUpdates();\n        this.stopListening();\n    }\n}\n__decorate([\n    Base.dispose()\n], Renderer.prototype, \"dispose\", null);\n(function (Renderer) {\n    Renderer.FLAG_INSERT = 1 << 30;\n    Renderer.FLAG_REMOVE = 1 << 29;\n    Renderer.MOUNT_BATCH_SIZE = 1000;\n    Renderer.UPDATE_BATCH_SIZE = 1000;\n    Renderer.MIN_PRIORITY = 2;\n    Renderer.SORT_DELAYING_BATCHES = [\n        'add',\n        'to-front',\n        'to-back',\n    ];\n    Renderer.UPDATE_DELAYING_BATCHES = ['translate'];\n})(Renderer || (Renderer = {}));\n//# sourceMappingURL=renderer.js.map"]},"metadata":{},"sourceType":"module"}