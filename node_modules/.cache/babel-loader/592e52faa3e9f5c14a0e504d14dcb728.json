{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport Point from '../../geo/point';\nimport { indexTouches } from '../handler_util';\n\nfunction getCentroid(points) {\n  var sum = new Point(0, 0);\n\n  var _iterator = _createForOfIteratorHelper(points),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var point = _step.value;\n\n      sum._add(point);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  return sum.div(points.length);\n}\n\nexport var MAX_TAP_INTERVAL = 500;\nexport var MAX_TOUCH_TIME = 500;\nexport var MAX_DIST = 30;\n\nvar SingleTapRecognizer = function () {\n  function SingleTapRecognizer(options) {\n    _classCallCheck(this, SingleTapRecognizer);\n\n    _defineProperty(this, \"numTouches\", void 0);\n\n    _defineProperty(this, \"centroid\", void 0);\n\n    _defineProperty(this, \"startTime\", void 0);\n\n    _defineProperty(this, \"aborted\", void 0);\n\n    _defineProperty(this, \"touches\", void 0);\n\n    this.reset();\n    this.numTouches = options.numTouches;\n  }\n\n  _createClass(SingleTapRecognizer, [{\n    key: \"reset\",\n    value: function reset() {\n      delete this.centroid;\n      delete this.startTime;\n      delete this.touches;\n      this.aborted = false;\n    }\n  }, {\n    key: \"touchstart\",\n    value: function touchstart(e, points, mapTouches) {\n      if (this.centroid || mapTouches.length > this.numTouches) {\n        this.aborted = true;\n      }\n\n      if (this.aborted) {\n        return;\n      }\n\n      if (this.startTime === undefined) {\n        this.startTime = e.timeStamp;\n      }\n\n      if (mapTouches.length === this.numTouches) {\n        this.centroid = getCentroid(points);\n        this.touches = indexTouches(mapTouches, points);\n      }\n    }\n  }, {\n    key: \"touchmove\",\n    value: function touchmove(e, points, mapTouches) {\n      if (this.aborted || !this.centroid) {\n        return;\n      }\n\n      var newTouches = indexTouches(mapTouches, points);\n\n      for (var id in this.touches) {\n        if (this.touches[id]) {\n          var prevPos = this.touches[id];\n          var pos = newTouches[id];\n\n          if (!pos || pos.dist(prevPos) > MAX_DIST) {\n            this.aborted = true;\n          }\n        }\n      }\n    }\n  }, {\n    key: \"touchend\",\n    value: function touchend(e, points, mapTouches) {\n      if (!this.centroid || e.timeStamp - this.startTime > MAX_TOUCH_TIME) {\n        this.aborted = true;\n      }\n\n      if (mapTouches.length === 0) {\n        var centroid = !this.aborted && this.centroid;\n        this.reset();\n\n        if (centroid) {\n          return centroid;\n        }\n      }\n    }\n  }]);\n\n  return SingleTapRecognizer;\n}();\n\nexport { SingleTapRecognizer as default };","map":{"version":3,"sources":["../../../src/handler/tap/single_tap_recognizer.ts"],"names":["sum","point","points","MAX_TAP_INTERVAL","MAX_TOUCH_TIME","MAX_DIST","SingleTapRecognizer","options","mapTouches","e","getCentroid","indexTouches","newTouches","prevPos","pos","centroid"],"mappings":"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","sourcesContent":["// @ts-ignore\nimport Point from '../../geo/point';\nimport { indexTouches } from '../handler_util';\n\nfunction getCentroid(points: Point[]) {\n  const sum = new Point(0, 0);\n  for (const point of points) {\n    sum._add(point);\n  }\n  // @ts-ignore\n  return sum.div(points.length);\n}\n\nexport const MAX_TAP_INTERVAL = 500;\nexport const MAX_TOUCH_TIME = 500;\nexport const MAX_DIST = 30;\n\nexport default class SingleTapRecognizer {\n  public numTouches: number;\n  public centroid: Point;\n  public startTime: number;\n  public aborted: boolean;\n  public touches: { [key: string]: Point };\n\n  constructor(options: { numTouches: number }) {\n    this.reset();\n    this.numTouches = options.numTouches;\n  }\n\n  public reset() {\n    delete this.centroid;\n    delete this.startTime;\n    delete this.touches;\n    this.aborted = false;\n  }\n\n  public touchstart(e: TouchEvent, points: Point[], mapTouches: Touch[]) {\n    if (this.centroid || mapTouches.length > this.numTouches) {\n      this.aborted = true;\n    }\n    if (this.aborted) {\n      return;\n    }\n\n    if (this.startTime === undefined) {\n      this.startTime = e.timeStamp;\n    }\n\n    if (mapTouches.length === this.numTouches) {\n      this.centroid = getCentroid(points);\n      this.touches = indexTouches(mapTouches, points);\n    }\n  }\n\n  public touchmove(e: TouchEvent, points: Point[], mapTouches: Touch[]) {\n    if (this.aborted || !this.centroid) {\n      return;\n    }\n\n    const newTouches = indexTouches(mapTouches, points);\n    for (const id in this.touches) {\n      if (this.touches[id]) {\n        const prevPos = this.touches[id];\n        const pos = newTouches[id];\n        if (!pos || pos.dist(prevPos) > MAX_DIST) {\n          this.aborted = true;\n        }\n      }\n    }\n  }\n\n  public touchend(e: TouchEvent, points: Point[], mapTouches: Touch[]) {\n    if (!this.centroid || e.timeStamp - this.startTime > MAX_TOUCH_TIME) {\n      this.aborted = true;\n    }\n\n    if (mapTouches.length === 0) {\n      const centroid = !this.aborted && this.centroid;\n      this.reset();\n      if (centroid) {\n        return centroid;\n      }\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}