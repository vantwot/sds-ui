{"ast":null,"code":"import { FunctionExt } from '../../../util';\nimport { Point, Rectangle } from '../../../geometry';\nimport { SortedSet } from './sorted-set';\nimport { ObstacleMap } from './obstacle-map';\nimport * as util from './util';\nimport { resolveOptions } from './options';\n/**\n * Finds the route between two points (`from`, `to`).\n */\n\nfunction findRoute(edgeView, from, to, map, options) {\n  const precision = options.precision;\n  let sourceEndpoint;\n  let targetEndpoint;\n\n  if (Rectangle.isRectangle(from)) {\n    sourceEndpoint = util.round(util.getSourceEndpoint(edgeView, options).clone(), precision);\n  } else {\n    sourceEndpoint = util.round(from.clone(), precision);\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    targetEndpoint = util.round(util.getTargetEndpoint(edgeView, options).clone(), precision);\n  } else {\n    targetEndpoint = util.round(to.clone(), precision);\n  } // Get grid for this route.\n\n\n  const grid = util.getGrid(options.step, sourceEndpoint, targetEndpoint); // Get pathfinding points.\n  // -----------------------\n\n  const startPoint = sourceEndpoint;\n  const endPoint = targetEndpoint;\n  let startPoints;\n  let endPoints;\n\n  if (Rectangle.isRectangle(from)) {\n    startPoints = util.getRectPoints(startPoint, from, options.startDirections, grid, options);\n  } else {\n    startPoints = [startPoint];\n  }\n\n  if (Rectangle.isRectangle(to)) {\n    endPoints = util.getRectPoints(targetEndpoint, to, options.endDirections, grid, options);\n  } else {\n    endPoints = [endPoint];\n  } // take into account only accessible rect points (those not under obstacles)\n\n\n  startPoints = startPoints.filter(p => map.isAccessible(p));\n  endPoints = endPoints.filter(p => map.isAccessible(p)); // There is an accessible route point on both sides.\n\n  if (startPoints.length > 0 && endPoints.length > 0) {\n    const openSet = new SortedSet(); // Keeps the actual points for given nodes of the open set.\n\n    const points = {}; // Keeps the point that is immediate predecessor of given element.\n\n    const parents = {}; // Cost from start to a point along best known path.\n\n    const costs = {};\n\n    for (let i = 0, n = startPoints.length; i < n; i += 1) {\n      // startPoint is assumed to be aligned already\n      const startPoint = startPoints[i];\n      const key = util.getKey(startPoint);\n      openSet.add(key, util.getCost(startPoint, endPoints));\n      points[key] = startPoint;\n      costs[key] = 0;\n    }\n\n    const previousRouteDirectionAngle = options.previousDirectionAngle; // undefined for first route\n\n    const isPathBeginning = previousRouteDirectionAngle === undefined; // directions\n\n    let direction;\n    let directionChange;\n    const directions = util.getGridOffsets(grid, options);\n    const numDirections = directions.length;\n    const endPointsKeys = endPoints.reduce((res, endPoint) => {\n      const key = util.getKey(endPoint);\n      res.push(key);\n      return res;\n    }, []); // main route finding loop\n\n    const sameStartEndPoints = Point.equalPoints(startPoints, endPoints);\n    let loopsRemaining = options.maxLoopCount;\n\n    while (!openSet.isEmpty() && loopsRemaining > 0) {\n      // Get the closest item and mark it CLOSED\n      const currentKey = openSet.pop();\n      const currentPoint = points[currentKey];\n      const currentParent = parents[currentKey];\n      const currentCost = costs[currentKey];\n      const isStartPoint = currentPoint.equals(startPoint);\n      const isRouteBeginning = currentParent == null;\n      let previousDirectionAngle;\n\n      if (!isRouteBeginning) {\n        previousDirectionAngle = util.getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);\n      } else if (!isPathBeginning) {\n        // a vertex on the route\n        previousDirectionAngle = previousRouteDirectionAngle;\n      } else if (!isStartPoint) {\n        // beginning of route on the path\n        previousDirectionAngle = util.getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);\n      } else {\n        previousDirectionAngle = null;\n      } // Check if we reached any endpoint\n\n\n      const skipEndCheck = isRouteBeginning && sameStartEndPoints;\n\n      if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n        options.previousDirectionAngle = previousDirectionAngle;\n        return util.reconstructRoute(parents, points, currentPoint, startPoint, endPoint);\n      } // Go over all possible directions and find neighbors\n\n\n      for (let i = 0; i < numDirections; i += 1) {\n        direction = directions[i];\n        const directionAngle = direction.angle;\n        directionChange = util.getDirectionChange(previousDirectionAngle, directionAngle); // Don't use the point changed rapidly.\n\n        if (!(isPathBeginning && isStartPoint) && directionChange > options.maxDirectionChange) {\n          continue;\n        }\n\n        const neighborPoint = util.align(currentPoint.clone().translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);\n        const neighborKey = util.getKey(neighborPoint); // Closed points were already evaluated.\n\n        if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {\n          continue;\n        } // Neighbor is an end point.\n\n\n        if (endPointsKeys.indexOf(neighborKey) >= 0) {\n          const isEndPoint = neighborPoint.equals(endPoint);\n\n          if (!isEndPoint) {\n            const endDirectionAngle = util.getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);\n            const endDirectionChange = util.getDirectionChange(directionAngle, endDirectionAngle);\n\n            if (endDirectionChange > options.maxDirectionChange) {\n              continue;\n            }\n          }\n        } // The current direction is ok.\n        // ----------------------------\n\n\n        const neighborCost = direction.cost;\n        const neighborPenalty = isStartPoint ? 0 : options.penalties[directionChange];\n        const costFromStart = currentCost + neighborCost + neighborPenalty; // Neighbor point has not been processed yet or the cost of\n        // the path from start is lower than previously calculated.\n\n        if (!openSet.isOpen(neighborKey) || costFromStart < costs[neighborKey]) {\n          points[neighborKey] = neighborPoint;\n          parents[neighborKey] = currentPoint;\n          costs[neighborKey] = costFromStart;\n          openSet.add(neighborKey, costFromStart + util.getCost(neighborPoint, endPoints));\n        }\n      }\n\n      loopsRemaining -= 1;\n    }\n  }\n\n  if (options.fallbackRoute) {\n    return FunctionExt.call(options.fallbackRoute, this, startPoint, endPoint, options);\n  }\n\n  return null;\n}\n\nexport const router = function (vertices, optionsRaw, edgeView) {\n  const options = resolveOptions(optionsRaw);\n  const sourceBBox = util.getSourceBBox(edgeView, options);\n  const targetBBox = util.getTargetBBox(edgeView, options);\n  const sourceEndpoint = util.getSourceEndpoint(edgeView, options); // pathfinding\n\n  const map = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);\n  const oldVertices = vertices.map(p => Point.create(p));\n  const newVertices = []; // The origin of first route's grid, does not need snapping\n\n  let tailPoint = sourceEndpoint;\n  let from;\n  let to;\n\n  for (let i = 0, len = oldVertices.length; i <= len; i += 1) {\n    let partialRoute = null;\n    from = to || sourceBBox;\n    to = oldVertices[i]; // This is the last iteration\n\n    if (to == null) {\n      to = targetBBox; // If the target is a point, we should use dragging route\n      // instead of main routing method if it has been provided.\n\n      const edge = edgeView.cell;\n      const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;\n\n      if (isEndingAtPoint && typeof options.draggingRouter === 'function') {\n        const dragFrom = from === sourceBBox ? sourceEndpoint : from;\n        const dragTo = to.getOrigin();\n        partialRoute = FunctionExt.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);\n      }\n    } // Find the partial route\n\n\n    if (partialRoute == null) {\n      partialRoute = findRoute(edgeView, from, to, map, options);\n    } // Cannot found the partial route.\n\n\n    if (partialRoute === null) {\n      return FunctionExt.call(options.fallbackRouter, this, vertices, options, edgeView);\n    } // Remove the first point if the previous partial route has\n    // the same point as last.\n\n\n    const leadPoint = partialRoute[0];\n\n    if (leadPoint && leadPoint.equals(tailPoint)) {\n      partialRoute.shift();\n    } // Save tailPoint for next iteration\n\n\n    tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n    newVertices.push(...partialRoute);\n  }\n\n  return newVertices;\n};","map":{"version":3,"sources":["../../../../src/registry/router/manhattan/router.ts"],"names":[],"mappings":"AACA,SAAS,WAAT,QAA4B,eAA5B;AACA,SAAS,KAAT,EAAgB,SAAhB,QAAiC,mBAAjC;AAGA,SAAS,SAAT,QAA0B,cAA1B;AACA,SAAS,WAAT,QAA4B,gBAA5B;AACA,OAAO,KAAK,IAAZ,MAAsB,QAAtB;AACA,SACE,cADF,QAIO,WAJP;AAMA;;AAEG;;AACH,SAAS,SAAT,CACE,QADF,EAEE,IAFF,EAGE,EAHF,EAIE,GAJF,EAKE,OALF,EAK0B;AAExB,QAAM,SAAS,GAAG,OAAO,CAAC,SAA1B;AAEA,MAAI,cAAJ;AACA,MAAI,cAAJ;;AAEA,MAAI,SAAS,CAAC,WAAV,CAAsB,IAAtB,CAAJ,EAAiC;AAC/B,IAAA,cAAc,GAAG,IAAI,CAAC,KAAL,CACf,IAAI,CAAC,iBAAL,CAAuB,QAAvB,EAAiC,OAAjC,EAA0C,KAA1C,EADe,EAEf,SAFe,CAAjB;AAID,GALD,MAKO;AACL,IAAA,cAAc,GAAG,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,KAAL,EAAX,EAAyB,SAAzB,CAAjB;AACD;;AAED,MAAI,SAAS,CAAC,WAAV,CAAsB,EAAtB,CAAJ,EAA+B;AAC7B,IAAA,cAAc,GAAG,IAAI,CAAC,KAAL,CACf,IAAI,CAAC,iBAAL,CAAuB,QAAvB,EAAiC,OAAjC,EAA0C,KAA1C,EADe,EAEf,SAFe,CAAjB;AAID,GALD,MAKO;AACL,IAAA,cAAc,GAAG,IAAI,CAAC,KAAL,CAAW,EAAE,CAAC,KAAH,EAAX,EAAuB,SAAvB,CAAjB;AACD,GAvBuB,CAyBxB;;;AACA,QAAM,IAAI,GAAG,IAAI,CAAC,OAAL,CAAa,OAAO,CAAC,IAArB,EAA2B,cAA3B,EAA2C,cAA3C,CAAb,CA1BwB,CA4BxB;AACA;;AAEA,QAAM,UAAU,GAAG,cAAnB;AACA,QAAM,QAAQ,GAAG,cAAjB;AACA,MAAI,WAAJ;AACA,MAAI,SAAJ;;AAEA,MAAI,SAAS,CAAC,WAAV,CAAsB,IAAtB,CAAJ,EAAiC;AAC/B,IAAA,WAAW,GAAG,IAAI,CAAC,aAAL,CACZ,UADY,EAEZ,IAFY,EAGZ,OAAO,CAAC,eAHI,EAIZ,IAJY,EAKZ,OALY,CAAd;AAOD,GARD,MAQO;AACL,IAAA,WAAW,GAAG,CAAC,UAAD,CAAd;AACD;;AAED,MAAI,SAAS,CAAC,WAAV,CAAsB,EAAtB,CAAJ,EAA+B;AAC7B,IAAA,SAAS,GAAG,IAAI,CAAC,aAAL,CACV,cADU,EAEV,EAFU,EAGV,OAAO,CAAC,aAHE,EAIV,IAJU,EAKV,OALU,CAAZ;AAOD,GARD,MAQO;AACL,IAAA,SAAS,GAAG,CAAC,QAAD,CAAZ;AACD,GA1DuB,CA4DxB;;;AACA,EAAA,WAAW,GAAG,WAAW,CAAC,MAAZ,CAAoB,CAAD,IAAO,GAAG,CAAC,YAAJ,CAAiB,CAAjB,CAA1B,CAAd;AACA,EAAA,SAAS,GAAG,SAAS,CAAC,MAAV,CAAkB,CAAD,IAAO,GAAG,CAAC,YAAJ,CAAiB,CAAjB,CAAxB,CAAZ,CA9DwB,CAgExB;;AACA,MAAI,WAAW,CAAC,MAAZ,GAAqB,CAArB,IAA0B,SAAS,CAAC,MAAV,GAAmB,CAAjD,EAAoD;AAClD,UAAM,OAAO,GAAG,IAAI,SAAJ,EAAhB,CADkD,CAElD;;AACA,UAAM,MAAM,GAAoB,EAAhC,CAHkD,CAIlD;;AACA,UAAM,OAAO,GAAoB,EAAjC,CALkD,CAMlD;;AACA,UAAM,KAAK,GAAqB,EAAhC;;AAEA,SAAK,IAAI,CAAC,GAAG,CAAR,EAAW,CAAC,GAAG,WAAW,CAAC,MAAhC,EAAwC,CAAC,GAAG,CAA5C,EAA+C,CAAC,IAAI,CAApD,EAAuD;AACrD;AACA,YAAM,UAAU,GAAG,WAAW,CAAC,CAAD,CAA9B;AACA,YAAM,GAAG,GAAG,IAAI,CAAC,MAAL,CAAY,UAAZ,CAAZ;AACA,MAAA,OAAO,CAAC,GAAR,CAAY,GAAZ,EAAiB,IAAI,CAAC,OAAL,CAAa,UAAb,EAAyB,SAAzB,CAAjB;AACA,MAAA,MAAM,CAAC,GAAD,CAAN,GAAc,UAAd;AACA,MAAA,KAAK,CAAC,GAAD,CAAL,GAAa,CAAb;AACD;;AAED,UAAM,2BAA2B,GAAG,OAAO,CAAC,sBAA5C,CAlBkD,CAmBlD;;AACA,UAAM,eAAe,GAAG,2BAA2B,KAAK,SAAxD,CApBkD,CAsBlD;;AACA,QAAI,SAAJ;AACA,QAAI,eAAJ;AACA,UAAM,UAAU,GAAG,IAAI,CAAC,cAAL,CAAoB,IAApB,EAA0B,OAA1B,CAAnB;AACA,UAAM,aAAa,GAAG,UAAU,CAAC,MAAjC;AACA,UAAM,aAAa,GAAG,SAAS,CAAC,MAAV,CAA2B,CAAC,GAAD,EAAM,QAAN,KAAkB;AACjE,YAAM,GAAG,GAAG,IAAI,CAAC,MAAL,CAAY,QAAZ,CAAZ;AACA,MAAA,GAAG,CAAC,IAAJ,CAAS,GAAT;AACA,aAAO,GAAP;AACD,KAJqB,EAInB,EAJmB,CAAtB,CA3BkD,CAiClD;;AACA,UAAM,kBAAkB,GAAG,KAAK,CAAC,WAAN,CAAkB,WAAlB,EAA+B,SAA/B,CAA3B;AACA,QAAI,cAAc,GAAG,OAAO,CAAC,YAA7B;;AACA,WAAO,CAAC,OAAO,CAAC,OAAR,EAAD,IAAsB,cAAc,GAAG,CAA9C,EAAiD;AAC/C;AACA,YAAM,UAAU,GAAG,OAAO,CAAC,GAAR,EAAnB;AACA,YAAM,YAAY,GAAG,MAAM,CAAC,UAAD,CAA3B;AACA,YAAM,aAAa,GAAG,OAAO,CAAC,UAAD,CAA7B;AACA,YAAM,WAAW,GAAG,KAAK,CAAC,UAAD,CAAzB;AAEA,YAAM,YAAY,GAAG,YAAY,CAAC,MAAb,CAAoB,UAApB,CAArB;AACA,YAAM,gBAAgB,GAAG,aAAa,IAAI,IAA1C;AAEA,UAAI,sBAAJ;;AACA,UAAI,CAAC,gBAAL,EAAuB;AACrB,QAAA,sBAAsB,GAAG,IAAI,CAAC,iBAAL,CACvB,aADuB,EAEvB,YAFuB,EAGvB,aAHuB,EAIvB,IAJuB,EAKvB,OALuB,CAAzB;AAOD,OARD,MAQO,IAAI,CAAC,eAAL,EAAsB;AAC3B;AACA,QAAA,sBAAsB,GAAG,2BAAzB;AACD,OAHM,MAGA,IAAI,CAAC,YAAL,EAAmB;AACxB;AACA,QAAA,sBAAsB,GAAG,IAAI,CAAC,iBAAL,CACvB,UADuB,EAEvB,YAFuB,EAGvB,aAHuB,EAIvB,IAJuB,EAKvB,OALuB,CAAzB;AAOD,OATM,MASA;AACL,QAAA,sBAAsB,GAAG,IAAzB;AACD,OAjC8C,CAmC/C;;;AACA,YAAM,YAAY,GAAG,gBAAgB,IAAI,kBAAzC;;AACA,UAAI,CAAC,YAAD,IAAiB,aAAa,CAAC,OAAd,CAAsB,UAAtB,KAAqC,CAA1D,EAA6D;AAC3D,QAAA,OAAO,CAAC,sBAAR,GAAiC,sBAAjC;AACA,eAAO,IAAI,CAAC,gBAAL,CACL,OADK,EAEL,MAFK,EAGL,YAHK,EAIL,UAJK,EAKL,QALK,CAAP;AAOD,OA9C8C,CAgD/C;;;AACA,WAAK,IAAI,CAAC,GAAG,CAAb,EAAgB,CAAC,GAAG,aAApB,EAAmC,CAAC,IAAI,CAAxC,EAA2C;AACzC,QAAA,SAAS,GAAG,UAAU,CAAC,CAAD,CAAtB;AAEA,cAAM,cAAc,GAAG,SAAS,CAAC,KAAjC;AACA,QAAA,eAAe,GAAG,IAAI,CAAC,kBAAL,CAChB,sBADgB,EAEhB,cAFgB,CAAlB,CAJyC,CASzC;;AACA,YACE,EAAE,eAAe,IAAI,YAArB,KACA,eAAe,GAAG,OAAO,CAAC,kBAF5B,EAGE;AACA;AACD;;AAED,cAAM,aAAa,GAAG,IAAI,CAAC,KAAL,CACpB,YAAY,CACT,KADH,GAEG,SAFH,CAEa,SAAS,CAAC,WAAV,IAAyB,CAFtC,EAEyC,SAAS,CAAC,WAAV,IAAyB,CAFlE,CADoB,EAIpB,IAJoB,EAKpB,SALoB,CAAtB;AAOA,cAAM,WAAW,GAAG,IAAI,CAAC,MAAL,CAAY,aAAZ,CAApB,CAxByC,CA0BzC;;AACA,YAAI,OAAO,CAAC,OAAR,CAAgB,WAAhB,KAAgC,CAAC,GAAG,CAAC,YAAJ,CAAiB,aAAjB,CAArC,EAAsE;AACpE;AACD,SA7BwC,CA+BzC;;;AACA,YAAI,aAAa,CAAC,OAAd,CAAsB,WAAtB,KAAsC,CAA1C,EAA6C;AAC3C,gBAAM,UAAU,GAAG,aAAa,CAAC,MAAd,CAAqB,QAArB,CAAnB;;AACA,cAAI,CAAC,UAAL,EAAiB;AACf,kBAAM,iBAAiB,GAAG,IAAI,CAAC,iBAAL,CACxB,aADwB,EAExB,QAFwB,EAGxB,aAHwB,EAIxB,IAJwB,EAKxB,OALwB,CAA1B;AAQA,kBAAM,kBAAkB,GAAG,IAAI,CAAC,kBAAL,CACzB,cADyB,EAEzB,iBAFyB,CAA3B;;AAKA,gBAAI,kBAAkB,GAAG,OAAO,CAAC,kBAAjC,EAAqD;AACnD;AACD;AACF;AACF,SApDwC,CAsDzC;AACA;;;AAEA,cAAM,YAAY,GAAG,SAAS,CAAC,IAA/B;AACA,cAAM,eAAe,GAAG,YAAY,GAChC,CADgC,GAEhC,OAAO,CAAC,SAAR,CAAkB,eAAlB,CAFJ;AAGA,cAAM,aAAa,GAAG,WAAW,GAAG,YAAd,GAA6B,eAAnD,CA7DyC,CA+DzC;AACA;;AACA,YACE,CAAC,OAAO,CAAC,MAAR,CAAe,WAAf,CAAD,IACA,aAAa,GAAG,KAAK,CAAC,WAAD,CAFvB,EAGE;AACA,UAAA,MAAM,CAAC,WAAD,CAAN,GAAsB,aAAtB;AACA,UAAA,OAAO,CAAC,WAAD,CAAP,GAAuB,YAAvB;AACA,UAAA,KAAK,CAAC,WAAD,CAAL,GAAqB,aAArB;AACA,UAAA,OAAO,CAAC,GAAR,CACE,WADF,EAEE,aAAa,GAAG,IAAI,CAAC,OAAL,CAAa,aAAb,EAA4B,SAA5B,CAFlB;AAID;AACF;;AAED,MAAA,cAAc,IAAI,CAAlB;AACD;AACF;;AAED,MAAI,OAAO,CAAC,aAAZ,EAA2B;AACzB,WAAO,WAAW,CAAC,IAAZ,CACL,OAAO,CAAC,aADH,EAEL,IAFK,EAGL,UAHK,EAIL,QAJK,EAKL,OALK,CAAP;AAOD;;AAED,SAAO,IAAP;AACD;;AAED,OAAO,MAAM,MAAM,GAA8C,UAC/D,QAD+D,EAE/D,UAF+D,EAG/D,QAH+D,EAGvD;AAER,QAAM,OAAO,GAAG,cAAc,CAAC,UAAD,CAA9B;AACA,QAAM,UAAU,GAAG,IAAI,CAAC,aAAL,CAAmB,QAAnB,EAA6B,OAA7B,CAAnB;AACA,QAAM,UAAU,GAAG,IAAI,CAAC,aAAL,CAAmB,QAAnB,EAA6B,OAA7B,CAAnB;AACA,QAAM,cAAc,GAAG,IAAI,CAAC,iBAAL,CAAuB,QAAvB,EAAiC,OAAjC,CAAvB,CALQ,CAOR;;AACA,QAAM,GAAG,GAAG,IAAI,WAAJ,CAAgB,OAAhB,EAAyB,KAAzB,CACV,QAAQ,CAAC,KAAT,CAAe,KADL,EAEV,QAAQ,CAAC,IAFC,CAAZ;AAKA,QAAM,WAAW,GAAG,QAAQ,CAAC,GAAT,CAAc,CAAD,IAAO,KAAK,CAAC,MAAN,CAAa,CAAb,CAApB,CAApB;AACA,QAAM,WAAW,GAAY,EAA7B,CAdQ,CAgBR;;AACA,MAAI,SAAS,GAAG,cAAhB;AAEA,MAAI,IAAJ;AACA,MAAI,EAAJ;;AAEA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,GAAG,GAAG,WAAW,CAAC,MAAlC,EAA0C,CAAC,IAAI,GAA/C,EAAoD,CAAC,IAAI,CAAzD,EAA4D;AAC1D,QAAI,YAAY,GAAmB,IAAnC;AAEA,IAAA,IAAI,GAAG,EAAE,IAAI,UAAb;AACA,IAAA,EAAE,GAAG,WAAW,CAAC,CAAD,CAAhB,CAJ0D,CAM1D;;AACA,QAAI,EAAE,IAAI,IAAV,EAAgB;AACd,MAAA,EAAE,GAAG,UAAL,CADc,CAGd;AACA;;AACA,YAAM,IAAI,GAAG,QAAQ,CAAC,IAAtB;AACA,YAAM,eAAe,GACnB,IAAI,CAAC,eAAL,MAA0B,IAA1B,IAAkC,IAAI,CAAC,eAAL,MAA0B,IAD9D;;AAGA,UAAI,eAAe,IAAI,OAAO,OAAO,CAAC,cAAf,KAAkC,UAAzD,EAAqE;AACnE,cAAM,QAAQ,GAAG,IAAI,KAAK,UAAT,GAAsB,cAAtB,GAAuC,IAAxD;AACA,cAAM,MAAM,GAAG,EAAE,CAAC,SAAH,EAAf;AACA,QAAA,YAAY,GAAG,WAAW,CAAC,IAAZ,CACb,OAAO,CAAC,cADK,EAEb,QAFa,EAGb,QAHa,EAIb,MAJa,EAKb,OALa,CAAf;AAOD;AACF,KA3ByD,CA6B1D;;;AACA,QAAI,YAAY,IAAI,IAApB,EAA0B;AACxB,MAAA,YAAY,GAAG,SAAS,CAAC,QAAD,EAAW,IAAX,EAAiB,EAAjB,EAAqB,GAArB,EAA0B,OAA1B,CAAxB;AACD,KAhCyD,CAkC1D;;;AACA,QAAI,YAAY,KAAK,IAArB,EAA2B;AACzB,aAAO,WAAW,CAAC,IAAZ,CACL,OAAO,CAAC,cADH,EAEL,IAFK,EAGL,QAHK,EAIL,OAJK,EAKL,QALK,CAAP;AAOD,KA3CyD,CA6C1D;AACA;;;AACA,UAAM,SAAS,GAAG,YAAY,CAAC,CAAD,CAA9B;;AACA,QAAI,SAAS,IAAI,SAAS,CAAC,MAAV,CAAiB,SAAjB,CAAjB,EAA8C;AAC5C,MAAA,YAAY,CAAC,KAAb;AACD,KAlDyD,CAoD1D;;;AACA,IAAA,SAAS,GAAG,YAAY,CAAC,YAAY,CAAC,MAAb,GAAsB,CAAvB,CAAZ,IAAyC,SAArD;AACA,IAAA,WAAW,CAAC,IAAZ,CAAiB,GAAG,YAApB;AACD;;AAED,SAAO,WAAP;AACD,CAnFM","sourceRoot":"","sourcesContent":["import { FunctionExt } from '../../../util';\nimport { Point, Rectangle } from '../../../geometry';\nimport { SortedSet } from './sorted-set';\nimport { ObstacleMap } from './obstacle-map';\nimport * as util from './util';\nimport { resolveOptions, } from './options';\n/**\n * Finds the route between two points (`from`, `to`).\n */\nfunction findRoute(edgeView, from, to, map, options) {\n    const precision = options.precision;\n    let sourceEndpoint;\n    let targetEndpoint;\n    if (Rectangle.isRectangle(from)) {\n        sourceEndpoint = util.round(util.getSourceEndpoint(edgeView, options).clone(), precision);\n    }\n    else {\n        sourceEndpoint = util.round(from.clone(), precision);\n    }\n    if (Rectangle.isRectangle(to)) {\n        targetEndpoint = util.round(util.getTargetEndpoint(edgeView, options).clone(), precision);\n    }\n    else {\n        targetEndpoint = util.round(to.clone(), precision);\n    }\n    // Get grid for this route.\n    const grid = util.getGrid(options.step, sourceEndpoint, targetEndpoint);\n    // Get pathfinding points.\n    // -----------------------\n    const startPoint = sourceEndpoint;\n    const endPoint = targetEndpoint;\n    let startPoints;\n    let endPoints;\n    if (Rectangle.isRectangle(from)) {\n        startPoints = util.getRectPoints(startPoint, from, options.startDirections, grid, options);\n    }\n    else {\n        startPoints = [startPoint];\n    }\n    if (Rectangle.isRectangle(to)) {\n        endPoints = util.getRectPoints(targetEndpoint, to, options.endDirections, grid, options);\n    }\n    else {\n        endPoints = [endPoint];\n    }\n    // take into account only accessible rect points (those not under obstacles)\n    startPoints = startPoints.filter((p) => map.isAccessible(p));\n    endPoints = endPoints.filter((p) => map.isAccessible(p));\n    // There is an accessible route point on both sides.\n    if (startPoints.length > 0 && endPoints.length > 0) {\n        const openSet = new SortedSet();\n        // Keeps the actual points for given nodes of the open set.\n        const points = {};\n        // Keeps the point that is immediate predecessor of given element.\n        const parents = {};\n        // Cost from start to a point along best known path.\n        const costs = {};\n        for (let i = 0, n = startPoints.length; i < n; i += 1) {\n            // startPoint is assumed to be aligned already\n            const startPoint = startPoints[i];\n            const key = util.getKey(startPoint);\n            openSet.add(key, util.getCost(startPoint, endPoints));\n            points[key] = startPoint;\n            costs[key] = 0;\n        }\n        const previousRouteDirectionAngle = options.previousDirectionAngle;\n        // undefined for first route\n        const isPathBeginning = previousRouteDirectionAngle === undefined;\n        // directions\n        let direction;\n        let directionChange;\n        const directions = util.getGridOffsets(grid, options);\n        const numDirections = directions.length;\n        const endPointsKeys = endPoints.reduce((res, endPoint) => {\n            const key = util.getKey(endPoint);\n            res.push(key);\n            return res;\n        }, []);\n        // main route finding loop\n        const sameStartEndPoints = Point.equalPoints(startPoints, endPoints);\n        let loopsRemaining = options.maxLoopCount;\n        while (!openSet.isEmpty() && loopsRemaining > 0) {\n            // Get the closest item and mark it CLOSED\n            const currentKey = openSet.pop();\n            const currentPoint = points[currentKey];\n            const currentParent = parents[currentKey];\n            const currentCost = costs[currentKey];\n            const isStartPoint = currentPoint.equals(startPoint);\n            const isRouteBeginning = currentParent == null;\n            let previousDirectionAngle;\n            if (!isRouteBeginning) {\n                previousDirectionAngle = util.getDirectionAngle(currentParent, currentPoint, numDirections, grid, options);\n            }\n            else if (!isPathBeginning) {\n                // a vertex on the route\n                previousDirectionAngle = previousRouteDirectionAngle;\n            }\n            else if (!isStartPoint) {\n                // beginning of route on the path\n                previousDirectionAngle = util.getDirectionAngle(startPoint, currentPoint, numDirections, grid, options);\n            }\n            else {\n                previousDirectionAngle = null;\n            }\n            // Check if we reached any endpoint\n            const skipEndCheck = isRouteBeginning && sameStartEndPoints;\n            if (!skipEndCheck && endPointsKeys.indexOf(currentKey) >= 0) {\n                options.previousDirectionAngle = previousDirectionAngle;\n                return util.reconstructRoute(parents, points, currentPoint, startPoint, endPoint);\n            }\n            // Go over all possible directions and find neighbors\n            for (let i = 0; i < numDirections; i += 1) {\n                direction = directions[i];\n                const directionAngle = direction.angle;\n                directionChange = util.getDirectionChange(previousDirectionAngle, directionAngle);\n                // Don't use the point changed rapidly.\n                if (!(isPathBeginning && isStartPoint) &&\n                    directionChange > options.maxDirectionChange) {\n                    continue;\n                }\n                const neighborPoint = util.align(currentPoint\n                    .clone()\n                    .translate(direction.gridOffsetX || 0, direction.gridOffsetY || 0), grid, precision);\n                const neighborKey = util.getKey(neighborPoint);\n                // Closed points were already evaluated.\n                if (openSet.isClose(neighborKey) || !map.isAccessible(neighborPoint)) {\n                    continue;\n                }\n                // Neighbor is an end point.\n                if (endPointsKeys.indexOf(neighborKey) >= 0) {\n                    const isEndPoint = neighborPoint.equals(endPoint);\n                    if (!isEndPoint) {\n                        const endDirectionAngle = util.getDirectionAngle(neighborPoint, endPoint, numDirections, grid, options);\n                        const endDirectionChange = util.getDirectionChange(directionAngle, endDirectionAngle);\n                        if (endDirectionChange > options.maxDirectionChange) {\n                            continue;\n                        }\n                    }\n                }\n                // The current direction is ok.\n                // ----------------------------\n                const neighborCost = direction.cost;\n                const neighborPenalty = isStartPoint\n                    ? 0\n                    : options.penalties[directionChange];\n                const costFromStart = currentCost + neighborCost + neighborPenalty;\n                // Neighbor point has not been processed yet or the cost of\n                // the path from start is lower than previously calculated.\n                if (!openSet.isOpen(neighborKey) ||\n                    costFromStart < costs[neighborKey]) {\n                    points[neighborKey] = neighborPoint;\n                    parents[neighborKey] = currentPoint;\n                    costs[neighborKey] = costFromStart;\n                    openSet.add(neighborKey, costFromStart + util.getCost(neighborPoint, endPoints));\n                }\n            }\n            loopsRemaining -= 1;\n        }\n    }\n    if (options.fallbackRoute) {\n        return FunctionExt.call(options.fallbackRoute, this, startPoint, endPoint, options);\n    }\n    return null;\n}\nexport const router = function (vertices, optionsRaw, edgeView) {\n    const options = resolveOptions(optionsRaw);\n    const sourceBBox = util.getSourceBBox(edgeView, options);\n    const targetBBox = util.getTargetBBox(edgeView, options);\n    const sourceEndpoint = util.getSourceEndpoint(edgeView, options);\n    // pathfinding\n    const map = new ObstacleMap(options).build(edgeView.graph.model, edgeView.cell);\n    const oldVertices = vertices.map((p) => Point.create(p));\n    const newVertices = [];\n    // The origin of first route's grid, does not need snapping\n    let tailPoint = sourceEndpoint;\n    let from;\n    let to;\n    for (let i = 0, len = oldVertices.length; i <= len; i += 1) {\n        let partialRoute = null;\n        from = to || sourceBBox;\n        to = oldVertices[i];\n        // This is the last iteration\n        if (to == null) {\n            to = targetBBox;\n            // If the target is a point, we should use dragging route\n            // instead of main routing method if it has been provided.\n            const edge = edgeView.cell;\n            const isEndingAtPoint = edge.getSourceCellId() == null || edge.getTargetCellId() == null;\n            if (isEndingAtPoint && typeof options.draggingRouter === 'function') {\n                const dragFrom = from === sourceBBox ? sourceEndpoint : from;\n                const dragTo = to.getOrigin();\n                partialRoute = FunctionExt.call(options.draggingRouter, edgeView, dragFrom, dragTo, options);\n            }\n        }\n        // Find the partial route\n        if (partialRoute == null) {\n            partialRoute = findRoute(edgeView, from, to, map, options);\n        }\n        // Cannot found the partial route.\n        if (partialRoute === null) {\n            return FunctionExt.call(options.fallbackRouter, this, vertices, options, edgeView);\n        }\n        // Remove the first point if the previous partial route has\n        // the same point as last.\n        const leadPoint = partialRoute[0];\n        if (leadPoint && leadPoint.equals(tailPoint)) {\n            partialRoute.shift();\n        }\n        // Save tailPoint for next iteration\n        tailPoint = partialRoute[partialRoute.length - 1] || tailPoint;\n        newVertices.push(...partialRoute);\n    }\n    return newVertices;\n};\n//# sourceMappingURL=router.js.map"]},"metadata":{},"sourceType":"module"}