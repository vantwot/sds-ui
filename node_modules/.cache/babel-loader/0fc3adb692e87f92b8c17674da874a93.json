{"ast":null,"code":"/**\n * @upsetjs/model\n * https://github.com/upsetjs/upsetjs\n *\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\n */\nfunction len(a) {\n  return a instanceof Set ? a.size : a.length;\n}\n\nfunction setOverlapFactory(a, toElemKey) {\n  const elems = !toElemKey ? a instanceof Set ? a : new Set(a) : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));\n  const setA = elems.size;\n  const same = {\n    setA,\n    setB: setA,\n    union: setA,\n    intersection: setA\n  };\n  return b => {\n    if (b === a) {\n      return same;\n    }\n\n    let intersection = 0;\n    b.forEach(e => {\n      if (toElemKey && elems.has(toElemKey(e)) || !toElemKey && elems.has(e)) {\n        intersection++;\n      }\n    });\n    const setB = len(b);\n    return {\n      setA,\n      setB,\n      intersection,\n      union: setA + setB - intersection\n    };\n  };\n}\n\nfunction setOverlap(a, b, toElemKey) {\n  if (len(a) < len(b) || a instanceof Set) {\n    return setOverlapFactory(a, toElemKey)(b);\n  }\n\n  const r = setOverlapFactory(b, toElemKey)(a);\n  return Object.assign({}, r, {\n    setA: r.setB,\n    setB: r.setA\n  });\n}\n\nfunction setElemOverlapFactory(a, toElemKey) {\n  const elems = !toElemKey ? a instanceof Set ? a : new Set(a) : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));\n  const setA = Array.isArray(a) ? a : Array.from(a);\n  const same = {\n    setA,\n    setB: setA,\n    union: setA,\n    intersection: setA\n  };\n  return b => {\n    if (b === a) {\n      return same;\n    }\n\n    const intersection = [];\n    const union = setA.slice();\n    b.forEach(e => {\n      if (toElemKey && elems.has(toElemKey(e)) || !toElemKey && elems.has(e)) {\n        intersection.push(e);\n      } else {\n        union.push(e);\n      }\n    });\n    return {\n      setA: setA,\n      setB: Array.isArray(b) ? b : Array.from(b),\n      intersection,\n      union\n    };\n  };\n}\n\nfunction setElemOverlap(a, b, toElemKey) {\n  if (len(a) < len(b) || a instanceof Set) {\n    return setElemOverlapFactory(a, toElemKey)(b);\n  }\n\n  const r = setElemOverlapFactory(b, toElemKey)(a);\n  return Object.assign({}, r, {\n    setA: r.setB,\n    setB: r.setA\n  });\n}\n\nfunction setElemIntersectionFactory(a, toElemKey) {\n  const arr = a instanceof Set ? Array.from(a) : a;\n  const elems = !toElemKey ? a instanceof Set ? a : new Set(a) : new Set(arr.map(toElemKey));\n  return b => {\n    if (b === a) {\n      return arr;\n    }\n\n    const intersection = [];\n    b.forEach(e => {\n      if (toElemKey && elems.has(toElemKey(e)) || !toElemKey && elems.has(e)) {\n        intersection.push(e);\n      }\n    });\n    return intersection;\n  };\n}\n\nfunction isElemQuery(q) {\n  return Array.isArray(q.elems);\n}\n\nfunction isCalcQuery(q) {\n  return typeof q.overlap === 'function';\n}\n\nfunction isSetQuery(q) {\n  return q.set != null;\n}\n\nfunction queryOverlap(query, what, toElemKey) {\n  if (isCalcQuery(query)) {\n    return query.overlap;\n  }\n\n  if (isSetQuery(query) && query.set.overlap) {\n    return query.set.overlap;\n  }\n\n  const f = setOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);\n  return s => {\n    if (s.overlap && isElemQuery(query) && Array.isArray(query.elems)) {\n      return s.overlap(query.elems);\n    }\n\n    if (s.overlap && isSetQuery(query)) {\n      return s.overlap(query.set);\n    }\n\n    return f(s.elems)[what];\n  };\n}\n\nfunction queryElemOverlap(query, what, toElemKey) {\n  if (isCalcQuery(query)) {\n    return () => null;\n  }\n\n  if (what === 'intersection') {\n    const f = setElemIntersectionFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);\n    return s => f(s.elems);\n  }\n\n  const f = setElemOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);\n  return s => {\n    return f(s.elems)[what];\n  };\n}\n\nfunction isBaseSet(v) {\n  const vt = v;\n  return v != null && typeof vt.cardinality === 'number' && typeof v.name === 'string' && Array.isArray(v.elems);\n}\n\nfunction isSet(v) {\n  return isBaseSet(v) && v.type === 'set';\n}\n\nfunction isSetCombination(v) {\n  const vt = v;\n  return isBaseSet(v) && ['composite', 'union', 'intersection', 'distinctIntersection'].includes(vt.type) && vt.sets instanceof Set && typeof vt.degree === 'number';\n}\n\nfunction isSetLike(v) {\n  return isSet(v) || isSetCombination(v);\n}\n\nfunction isGenerateSetCombinationOptions(v) {\n  const vt = v;\n  return v != null && (vt.type == null || ['intersection', 'union'].includes(vt.type));\n}\n\nfunction isUpSetQuery(v) {\n  const vt = v;\n  return v != null && typeof vt.name === 'string' && typeof vt.color === 'string' && (isElemQuery(vt) || isSetQuery(vt) || isCalcQuery(vt));\n}\n\nfunction byName(a, b) {\n  return a.name.localeCompare(b.name);\n}\n\nfunction byCardinality(a, b) {\n  return b.cardinality - a.cardinality;\n}\n\nfunction byDegree(a, b) {\n  return a.degree - b.degree;\n}\n\nfunction byComposite(func) {\n  return (a, b) => {\n    return func.reduce((acc, f) => acc === 0 ? f(a, b) : acc, 0);\n  };\n}\n\nfunction negate(func) {\n  return (a, b) => -func(a, b);\n}\n\nfunction byGroup(sets) {\n  return (a, b) => {\n    const fixNotFound = v => v < 0 ? Number.POSITIVE_INFINITY : v;\n\n    const aIndex = fixNotFound(sets.findIndex(s => a.sets.has(s)));\n    const bIndex = fixNotFound(sets.findIndex(s => b.sets.has(s)));\n    return aIndex - bIndex;\n  };\n}\n\nfunction fromSetName(sets) {\n  let symbol = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : /[∩∪&|]/;\n  const byName = new Map(sets.map(s => [s.name, s]));\n  return s => {\n    return s.name.split(symbol).map(setName => byName.get(setName.trim()));\n  };\n}\n\nfunction toOrder(sets, order) {\n  if (!order) {\n    return byName;\n  }\n\n  const arr = Array.isArray(order) ? order : [order];\n\n  if (arr.length === 0) {\n    return byName;\n  }\n\n  return byComposite(arr.map(o => {\n    switch (o) {\n      case 'cardinality':\n      case 'cardinality:desc':\n        return byCardinality;\n\n      case 'cardinality:asc':\n        return negate(byCardinality);\n\n      case 'name:desc':\n        return negate(byName);\n\n      case 'degree':\n      case 'degree:asc':\n        return byDegree;\n\n      case 'degree:desc':\n        return negate(byDegree);\n\n      case 'group':\n      case 'group:asc':\n        return byGroup(sets);\n\n      case 'group:desc':\n        return negate(byGroup(sets));\n\n      default:\n        return byName;\n    }\n  }));\n}\n\nfunction postprocessCombinations(sets, combinations) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  let r = combinations;\n\n  if (options.order) {\n    r = r.sort(toOrder(sets, options.order));\n  }\n\n  if (options.limit != null) {\n    return r.slice(0, options.limit);\n  }\n\n  return r;\n}\n\nfunction asCombination(set, type, toSets) {\n  const sets = toSets(set);\n  return Object.assign({\n    type,\n    cardinality: set.elems.length,\n    sets: new Set(sets),\n    degree: sets.length\n  }, set);\n}\n\nfunction asCombinations(sets, type, toSets) {\n  return sets.map(set => asCombination(set, type, toSets));\n}\n\nconst SET_JOINERS = {\n  distinctIntersection: ' ∩ ',\n  intersection: ' ∩ ',\n  union: ' ∪ ',\n  composite: ','\n};\n\nfunction parseColor(color) {\n  if (!color) {\n    return [255, 255, 255];\n  }\n\n  const hex = color.match(/#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})/i);\n\n  if (hex) {\n    return [Number.parseInt(hex[1], 16), Number.parseInt(hex[2], 16), Number.parseInt(hex[3], 16)];\n  }\n\n  const rgb = color.match(/\\(([\\d]+)[, ]([\\d]+)[, ]([\\d]+)\\)/i);\n\n  if (rgb) {\n    return [Number.parseInt(rgb[1], 10), Number.parseInt(rgb[2], 10), Number.parseInt(rgb[3], 10)];\n  }\n\n  return [255, 255, 255];\n}\n\nfunction mergeColors(colors) {\n  if (colors.length === 1) {\n    return colors[0];\n  }\n\n  if (colors.every(d => d == null)) {\n    return undefined;\n  }\n\n  const rgb = colors.map(parseColor);\n  const r = Math.floor(rgb.reduce((acc, v) => acc + v[0], 0) / rgb.length);\n  const g = Math.floor(rgb.reduce((acc, v) => acc + v[1], 0) / rgb.length);\n  const b = Math.floor(rgb.reduce((acc, v) => acc + v[2], 0) / rgb.length);\n  return `#${r.toString(16)}${g.toString(16)}${b.toString(16)}`;\n}\n\nfunction generateName(combo, setIndex, joiner) {\n  const sorted = Array.from(combo).sort((a, b) => setIndex.get(a) - setIndex.get(b));\n  return sorted.length === 1 ? sorted[0].name : `(${sorted.map(d => d.name).join(joiner)})`;\n}\n\nfunction generateSet(type, name, combo, elems, mergeColors) {\n  return {\n    type: combo.size === 0 ? 'composite' : type,\n    elems,\n    color: mergeColors(Array.from(combo).map(s => s.color)),\n    sets: combo,\n    name,\n    cardinality: elems.length,\n    degree: combo.size\n  };\n}\n\nfunction mergeIntersection(a, b, lookup, toKey, setIndex, type, mergeColors) {\n  const merged = new Set(a.sets);\n  b.sets.forEach(s => merged.add(s));\n  const name = generateName(merged, setIndex, SET_JOINERS[type]);\n\n  if (a.cardinality === 0 || b.cardinality === 0) {\n    return generateSet(type, name, merged, [], mergeColors);\n  }\n\n  let small = a;\n  let big = b;\n\n  if (a.cardinality > b.cardinality) {\n    small = b;\n    big = a;\n  }\n\n  const keySet = new Set();\n  const bigLookup = lookup.get(big);\n  const elems = [];\n  const l = small.elems.length;\n\n  for (let i = 0; i < l; i++) {\n    const e = small.elems[i];\n    const key = toKey(e);\n\n    if (!bigLookup.has(key)) {\n      continue;\n    }\n\n    keySet.add(key);\n    elems.push(e);\n  }\n\n  const r = generateSet(type, name, merged, elems, mergeColors);\n  lookup.set(r, keySet);\n  return r;\n}\n\nfunction mergeUnion(a, b, lookup, toKey, setIndex, type, mergeColors) {\n  const merged = new Set(a.sets);\n  b.sets.forEach(s => merged.add(s));\n  const name = generateName(merged, setIndex, SET_JOINERS[type]);\n\n  if (a.cardinality === 0) {\n    const r = generateSet(type, name, merged, b.elems, mergeColors);\n    lookup.set(r, lookup.get(b));\n    return r;\n  }\n\n  if (b.cardinality === 0) {\n    const r = generateSet(type, name, merged, a.elems, mergeColors);\n    lookup.set(r, lookup.get(a));\n    return r;\n  }\n\n  let small = a;\n  let big = b;\n\n  if (a.cardinality > b.cardinality) {\n    small = b;\n    big = a;\n  }\n\n  const keySet = new Set(lookup.get(big));\n  const bigLookup = lookup.get(big);\n  const elems = big.elems.slice();\n  small.elems.forEach(e => {\n    const key = toKey(e);\n\n    if (bigLookup.has(key)) {\n      return;\n    }\n\n    keySet.add(key);\n    elems.push(e);\n  });\n  const r = generateSet(type, name, merged, elems, mergeColors);\n  lookup.set(r, keySet);\n  return r;\n}\n\nfunction generateEmptySet(type, notPartOfAnySet, allElements, lookup, toKey, mergeColors) {\n  if (typeof notPartOfAnySet === 'number') {\n    return {\n      type: 'composite',\n      elems: [],\n      color: mergeColors ? mergeColors([]) : undefined,\n      sets: new Set(),\n      name: '()',\n      cardinality: notPartOfAnySet,\n\n      overlap(s) {\n        return s === this || isSetLike(s) && s.name === this.name && s.cardinality === this.cardinality ? this.cardinality : 0;\n      },\n\n      degree: 0\n    };\n  }\n\n  if (Array.isArray(notPartOfAnySet)) {\n    return generateSet(type, '()', new Set(), notPartOfAnySet, mergeColors);\n  }\n\n  const lookupArr = Array.from(lookup.values());\n  const elems = allElements.filter(e => {\n    const k = toKey(e);\n    return lookupArr.every(s => !s.has(k));\n  });\n  return generateSet(type, '()', new Set(), elems, mergeColors);\n}\n\nfunction generateCombinations(sets) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const {\n    type = 'intersection',\n    min = 0,\n    max = Infinity,\n    empty = false,\n    elems: allElements = [],\n    notPartOfAnySet,\n    toElemKey,\n    mergeColors: mergeColors$1 = mergeColors\n  } = options;\n  const combinations = [];\n  const setIndex = new Map(sets.map((s, i) => [s, i]));\n  const setElems = new Map(sets.map(s => [s, toElemKey ? new Set(s.elems.map(toElemKey)) : new Set(s.elems)]));\n  const setDirectElems = toElemKey ? null : setElems;\n  const setKeyElems = toElemKey ? setElems : null;\n  const calc = type === 'union' ? mergeUnion : mergeIntersection;\n\n  function push(s) {\n    if (s.degree < min || s.degree > max || s.cardinality === 0 && !empty) {\n      return;\n    }\n\n    if (type !== 'distinctIntersection') {\n      combinations.push(s);\n      return;\n    }\n\n    const others = sets.filter(d => !s.sets.has(d));\n    let elems = [];\n\n    if (toElemKey) {\n      const othersSets = others.map(o => setKeyElems.get(o));\n      elems = s.elems.filter(e => {\n        const key = toElemKey(e);\n        return othersSets.every(o => !o.has(key));\n      });\n    } else {\n      const othersSets = others.map(o => setDirectElems.get(o));\n      elems = s.elems.filter(e => othersSets.every(o => !o.has(e)));\n    }\n\n    if (elems.length === s.cardinality) {\n      combinations.push(s);\n      return;\n    }\n\n    const sDistinct = generateSet(type, s.name, s.sets, elems, mergeColors$1);\n\n    if (sDistinct.cardinality === 0 && !empty) {\n      return;\n    }\n\n    combinations.push(sDistinct);\n  }\n\n  function generateLevel(arr, degree, lookup, toKey) {\n    if (degree > max) {\n      return;\n    }\n\n    const l = arr.length;\n\n    for (let i = 0; i < l; i++) {\n      const a = arr[i];\n      const sub = [];\n\n      for (let j = i + 1; j < l; j++) {\n        const b = arr[j];\n        const ab = calc(a, b, lookup, toKey, setIndex, type, mergeColors$1);\n        push(ab);\n\n        if (type === 'union' || ab.cardinality > 0 || empty) {\n          sub.push(ab);\n        }\n      }\n\n      if (sub.length > 1) {\n        generateLevel(sub, degree + 1, lookup, toKey);\n      }\n    }\n  }\n\n  if (min <= 0) {\n    if (toElemKey) {\n      push(generateEmptySet(type, notPartOfAnySet, allElements, setKeyElems, toElemKey, mergeColors$1));\n    } else {\n      push(generateEmptySet(type, notPartOfAnySet, allElements, setDirectElems, v => v, mergeColors$1));\n    }\n  }\n\n  const degree1 = sets.map(s => {\n    const r = generateSet(type, s.name, new Set([s]), s.elems, mergeColors$1);\n    setElems.set(r, setElems.get(s));\n    push(r);\n    return r;\n  });\n\n  if (toElemKey) {\n    generateLevel(degree1, 2, setKeyElems, toElemKey);\n  } else {\n    generateLevel(degree1, 2, setDirectElems, v => v);\n  }\n\n  return postprocessCombinations(sets, combinations, options);\n}\n\nfunction asSet(set) {\n  return Object.assign({\n    type: 'set',\n    cardinality: set.elems.length\n  }, set);\n}\n\nfunction toOrder$1(order) {\n  if (!order) {\n    return byName;\n  }\n\n  switch (order) {\n    case 'cardinality':\n    case 'cardinality:desc':\n      return byComposite([byCardinality, byName]);\n\n    case 'cardinality:asc':\n      return byComposite([negate(byCardinality), byName]);\n\n    case 'name:desc':\n      return negate(byName);\n\n    default:\n      return byName;\n  }\n}\n\nfunction postprocessSets(sets) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let r = sets;\n\n  if (options.order) {\n    const order = toOrder$1(options.order);\n    r = r.slice().sort(order);\n  }\n\n  if (options.limit != null) {\n    return r.slice(0, options.limit);\n  }\n\n  return r;\n}\n\nfunction asSets(sets) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  return postprocessSets(sets.map(asSet), options);\n}\n\nfunction extractFromExpression(combinations, accOrOptions) {\n  let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a, _b, _c;\n\n  const acc = typeof accOrOptions === 'function' ? accOrOptions : e => e.sets;\n  const options = (_a = typeof accOrOptions !== 'function' ? accOrOptions : o) !== null && _a !== void 0 ? _a : {};\n  const type = (_b = options.type) !== null && _b !== void 0 ? _b : 'intersection';\n  const joiner = (_c = options.joiner) !== null && _c !== void 0 ? _c : SET_JOINERS[type];\n  const sets = [];\n  const setLookup = new Map();\n  const cs = combinations.map(c => {\n    const containedSets = acc(c);\n    const containedSetsObjects = containedSets.map(s => {\n      if (setLookup.has(s)) {\n        return setLookup.get(s);\n      }\n\n      const set = {\n        cardinality: 0,\n        elems: [],\n        name: s,\n        type: 'set'\n      };\n      sets.push(set);\n      setLookup.set(set.name, set);\n      return set;\n    });\n\n    if (type === 'distinctIntersection') {\n      for (const s of containedSetsObjects) {\n        s.cardinality += c.cardinality;\n      }\n    } else if (containedSets.length === 1) {\n      Object.assign(containedSetsObjects[0], {\n        cardinality: c.cardinality\n      }, c);\n    } else if (type === 'intersection') {\n      for (const s of containedSetsObjects) {\n        s.cardinality = Math.max(s.cardinality, c.cardinality);\n      }\n    } else if (type === 'union') {\n      for (const s of containedSetsObjects) {\n        s.cardinality = Math.min(s.cardinality, c.cardinality);\n      }\n    }\n\n    const name = containedSets.join(joiner);\n    return Object.assign({\n      type,\n      elems: [],\n      name\n    }, c, {\n      cardinality: c.cardinality,\n      degree: containedSets.length,\n      sets: new Set(containedSetsObjects)\n    });\n  });\n  const sortedSets = postprocessSets(sets, {\n    order: options.setOrder\n  });\n  const sortedCombinations = postprocessCombinations(sortedSets, cs, {\n    order: options.combinationOrder\n  });\n  return {\n    sets: sortedSets,\n    combinations: sortedCombinations\n  };\n}\n\nfunction extractSets(elements, accOrOptions) {\n  let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a;\n\n  const acc = typeof accOrOptions === 'function' ? accOrOptions : e => e.sets;\n  const options = (_a = typeof accOrOptions !== 'function' ? accOrOptions : o) !== null && _a !== void 0 ? _a : {};\n  const sets = Object.create(null);\n  elements.forEach(elem => {\n    acc(elem).forEach(set => {\n      const s = typeof set === 'string' ? set : String(set);\n      const r = sets[s];\n\n      if (r == null) {\n        sets[s] = [elem];\n      } else {\n        r.push(elem);\n      }\n    });\n  });\n  return postprocessSets(Object.entries(sets).map(_ref => {\n    let [set, elems] = _ref;\n    const r = {\n      type: 'set',\n      elems,\n      name: String(set),\n      cardinality: elems.length\n    };\n    return r;\n  }), options);\n}\n\nfunction createTree(byDegree, getOrCreateCombination) {\n  const children = new Map();\n  byDegree.slice().reverse().forEach(csOfDegree => {\n    if (csOfDegree.length === 0 || csOfDegree[0].degree === 1) {\n      return;\n    }\n\n    csOfDegree.forEach(c => {\n      const sets = Array.from(c.sets).map(d => d.name);\n\n      for (let i = 0; i < sets.length; i++) {\n        const subSet = sets.slice();\n        subSet.splice(i, 1);\n        const parent = getOrCreateCombination(subSet);\n\n        if (children.has(parent)) {\n          children.get(parent).push(c);\n        } else {\n          children.set(parent, [c]);\n        }\n      }\n    });\n  });\n  return children;\n}\n\nfunction extractCombinations(elements, accOrOptions) {\n  let o = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  var _a, _b, _c, _d;\n\n  const acc = typeof accOrOptions === 'function' ? accOrOptions : e => e.sets;\n  const options = (_a = typeof accOrOptions !== 'function' ? accOrOptions : o) !== null && _a !== void 0 ? _a : {};\n  const type = (_b = options.type) !== null && _b !== void 0 ? _b : 'intersection';\n  const sets = (_c = options.sets) !== null && _c !== void 0 ? _c : extractSets(elements, acc, {\n    limit: options.setLimit,\n    order: options.setOrder\n  });\n\n  if (type === 'union') {\n    return {\n      sets,\n      combinations: generateCombinations(sets, {\n        type: 'union',\n        limit: options.combinationLimit,\n        order: options.combinationOrder\n      })\n    };\n  }\n\n  const setLookup = Object.create(null);\n  sets.forEach((set, i) => {\n    setLookup[set.name] = [set, i];\n  });\n  const isSortedAlphabetically = sets.map(d => d.name).sort().every((d, i) => sets[i].name === d);\n  const bySet = isSortedAlphabetically ? undefined : (a, b) => {\n    var _a, _b, _c, _d;\n\n    const ai = (_b = (_a = setLookup[a]) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : -1;\n    const bi = (_d = (_c = setLookup[b]) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : -1;\n    return ai - bi;\n  };\n  const validSet = options.sets == null && options.setLimit == null ? null : new Set(sets.map(d => d.name));\n  const joiner = (_d = options.joiner) !== null && _d !== void 0 ? _d : SET_JOINERS[type];\n  const cs = [];\n  const csLookup = Object.create(null);\n  const byDegree = Array(sets.length + 1).fill(0).map(_ => []);\n\n  function genName(setsOfElem) {\n    switch (setsOfElem.length) {\n      case 0:\n        return '()';\n\n      case 1:\n        return setsOfElem[0];\n\n      default:\n        const sorted = setsOfElem.slice().sort(bySet);\n        const joined = sorted.join(joiner);\n        return '(' + joined + ')';\n    }\n  }\n\n  function genKey(setsOfElem) {\n    switch (setsOfElem.length) {\n      case 0:\n        return '';\n\n      case 1:\n        return setsOfElem[0];\n\n      case 2:\n        {\n          if (bySet != null && bySet(setsOfElem[0], setsOfElem[1]) > 0 || bySet == null && setsOfElem[1] > setsOfElem[0]) {\n            return setsOfElem[1] + '&' + setsOfElem[0];\n          }\n\n          return setsOfElem[0] + '&' + setsOfElem[1];\n        }\n\n      default:\n        const sorted = setsOfElem.slice().sort(bySet);\n        return sorted.join('&');\n    }\n  }\n\n  function getOrCreateCombination(setsOfElem) {\n    const key = genKey(setsOfElem);\n    let entry = csLookup[key];\n\n    if (entry) {\n      return entry;\n    }\n\n    const newEntry = {\n      type,\n      name: genName(setsOfElem),\n      degree: setsOfElem.length,\n      sets: new Set(setsOfElem.map(s => setLookup[s][0])),\n      cardinality: 0,\n      elems: []\n    };\n    csLookup[key] = newEntry;\n    cs.push(newEntry);\n    byDegree[newEntry.degree].push(newEntry);\n    return newEntry;\n  }\n\n  elements.forEach(elem => {\n    let setsOfElem = acc(elem);\n\n    if (validSet) {\n      setsOfElem = setsOfElem.filter(d => validSet.has(d));\n    }\n\n    const c = getOrCreateCombination(setsOfElem);\n    c.elems.push(elem);\n    c.cardinality++;\n  });\n\n  const finalize = () => {\n    return {\n      sets,\n      combinations: postprocessCombinations(sets, cs, {\n        order: options.combinationOrder,\n        limit: options.combinationLimit\n      })\n    };\n  };\n\n  if (type === 'distinctIntersection') {\n    return finalize();\n  }\n\n  const children = createTree(byDegree, getOrCreateCombination);\n\n  function visit(node, visited, agg) {\n    var _a;\n\n    if (visited.has(node)) {\n      return;\n    }\n\n    visited.add(node);\n\n    if (node.elems.length < 1000) {\n      agg[0].push(...node.elems);\n    } else {\n      agg.push(node.elems);\n    }\n\n    ((_a = children.get(node)) !== null && _a !== void 0 ? _a : []).forEach(child => visit(child, visited, agg));\n  }\n\n  byDegree.slice(1).forEach(level => {\n    level.forEach(node => {\n      var _a;\n\n      const visited = new Set();\n      const agg = [node.elems];\n      ((_a = children.get(node)) !== null && _a !== void 0 ? _a : []).forEach(child => {\n        visit(child, visited, agg);\n      });\n      const elems = agg.length === 1 ? agg[0] : agg.flat();\n      Object.assign(node, {\n        elems,\n        cardinality: elems.length\n      });\n    });\n  });\n  return finalize();\n}\n\nfunction toKey(s) {\n  return `${s.name}:${s.type}#${s.cardinality}`;\n}\n\nfunction isUniverse(s) {\n  return s.sets.size === 0;\n}\n\nfunction common(a, b) {\n  let toKey$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toKey;\n  const r = {\n    done: null,\n    aKey: '',\n    bKey: '',\n    aIsSet: false,\n    bIsSet: false,\n    toKey: toKey$1\n  };\n\n  if (a === b) {\n    r.done = a.cardinality;\n    return r;\n  }\n\n  if (a.cardinality === 0 || b.cardinality === 0) {\n    r.done = 0;\n    return r;\n  }\n\n  r.aKey = toKey$1(a);\n  r.bKey = toKey$1(b);\n\n  if (r.aKey === r.bKey) {\n    r.done = a.cardinality;\n    return r;\n  }\n\n  r.aIsSet = isSet(a);\n  r.bIsSet = isSet(b);\n\n  if (!r.aIsSet && isUniverse(a) || !r.bIsSet && isUniverse(b)) {\n    r.done = 0;\n    return r;\n  }\n\n  return r;\n}\n\nfunction aInB(b, r) {\n  if (r.bIsSet || !r.aIsSet) {\n    return false;\n  }\n\n  return Array.from(b.sets).map(r.toKey).includes(r.aKey);\n}\n\nfunction bInA(a, r) {\n  if (!r.bIsSet || r.aIsSet) {\n    return false;\n  }\n\n  return Array.from(a.sets).map(r.toKey).includes(r.bKey);\n}\n\nfunction keyedCombinations(combinations) {\n  let toKey$1 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : toKey;\n  return combinations.map(c => {\n    const s = Array.from(c.sets).map(toKey$1).sort();\n    return {\n      key: s.join('&'),\n      s,\n      sets: new Set(s),\n      degree: c.degree,\n      cardinality: c.cardinality\n    };\n  });\n}\n\nfunction combinedKey(a, b, r) {\n  const sets = new Set();\n\n  if (r.aIsSet) {\n    sets.add(r.aKey);\n  } else {\n    for (const s of Array.from(a.sets)) {\n      sets.add(r.toKey(s));\n    }\n  }\n\n  if (r.bIsSet) {\n    sets.add(r.bKey);\n  } else {\n    for (const s of Array.from(b.sets)) {\n      sets.add(r.toKey(s));\n    }\n  }\n\n  return Array.from(sets).sort().join('&');\n}\n\nfunction generateDistinctOverlapFunction(combinations, fallback) {\n  let toKey$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toKey;\n  const combinationsBySet = new Map();\n\n  for (const c of keyedCombinations(combinations, toKey$1)) {\n    for (const s of c.s) {\n      if (combinationsBySet.has(s)) {\n        combinationsBySet.get(s).push(c);\n      } else {\n        combinationsBySet.set(s, [c]);\n      }\n    }\n  }\n\n  return (a, b) => {\n    const r = common(a, b, toKey$1);\n\n    if (r.done != null) {\n      return r.done;\n    }\n\n    if (!r.aIsSet && !r.bIsSet) {\n      return 0;\n    }\n\n    if (r.aIsSet && !r.bIsSet) {\n      return aInB(b, r) ? b.cardinality : 0;\n    }\n\n    if (!r.aIsSet && r.bIsSet) {\n      return bInA(a, r) ? a.cardinality : 0;\n    }\n\n    const hasA = combinationsBySet.get(r.aKey);\n    const hasB = combinationsBySet.get(r.bKey);\n\n    if (!hasA || !hasB) {\n      return fallback(a, b);\n    }\n\n    if (hasA.length < hasB.length) {\n      return hasA.reduce((acc, c) => acc + (c.sets.has(r.bKey) ? c.cardinality : 0), 0);\n    }\n\n    return hasB.reduce((acc, c) => acc + (c.sets.has(r.aKey) ? c.cardinality : 0), 0);\n  };\n}\n\nfunction generateIntersectionOverlapFunction(combinations, fallback) {\n  let toKey$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toKey;\n  const combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map(d => [d.key, d.cardinality]));\n  return (a, b) => {\n    const r = common(a, b, toKey$1);\n\n    if (r.done != null) {\n      return r.done;\n    }\n\n    if (r.aIsSet && !r.bIsSet && aInB(b, r)) {\n      return b.cardinality;\n    }\n\n    if (!r.aIsSet && r.bIsSet && bInA(a, r)) {\n      return a.cardinality;\n    }\n\n    const key = combinedKey(a, b, r);\n\n    if (!combinationsByKey.has(key)) {\n      return fallback(a, b);\n    }\n\n    return combinationsByKey.get(key);\n  };\n}\n\nfunction generateUnionOverlapFunction(combinations, fallback) {\n  let toKey$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toKey;\n  const combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map(d => [d.key, d.cardinality]));\n  return (a, b) => {\n    const r = common(a, b, toKey$1);\n\n    if (r.done != null) {\n      return r.done;\n    }\n\n    if (r.aIsSet && !r.bIsSet && aInB(b, r)) {\n      return a.cardinality;\n    }\n\n    if (!r.aIsSet && r.bIsSet && bInA(a, r)) {\n      return b.cardinality;\n    }\n\n    const key = combinedKey(a, b, r);\n\n    if (!combinationsByKey.has(key)) {\n      return fallback(a, b);\n    }\n\n    return a.cardinality + b.cardinality - combinationsByKey.get(key);\n  };\n}\n\nfunction generateOverlapFunction(combinations, fallback) {\n  let toKey$1 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : toKey;\n\n  if (combinations.length === 0) {\n    return fallback;\n  }\n\n  const firstType = combinations[0].type;\n\n  if (combinations.some(s => s.type !== firstType)) {\n    return fallback;\n  }\n\n  switch (firstType) {\n    case 'union':\n      return generateUnionOverlapFunction(combinations, fallback, toKey$1);\n\n    case 'intersection':\n      return generateIntersectionOverlapFunction(combinations, fallback, toKey$1);\n\n    case 'distinctIntersection':\n      return generateDistinctOverlapFunction(combinations, fallback, toKey$1);\n  }\n\n  return fallback;\n}\n\nfunction compressLine(line) {\n  if (line.length === 0) {\n    return '';\n  }\n\n  const r = [];\n  let start = line[0];\n  let len = 1;\n\n  for (let i = 1; i < line.length; i++) {\n    const v = line[i];\n\n    if (v === start) {\n      len++;\n    } else {\n      if (len > 1) {\n        r.push(`${start}=${len - 1}`);\n      } else if (start === 0) {\n        r.push('');\n      } else {\n        r.push(start.toString());\n      }\n\n      start = v;\n      len = 1;\n    }\n  }\n\n  if (len > 1) {\n    r.push(`${start}=${len}`);\n  } else if (start === 0) {\n    r.push('');\n  } else {\n    r.push(start.toString());\n  }\n\n  return r.join(',');\n}\n\nfunction decompressLine(line) {\n  if (line.length === 0) {\n    return [];\n  }\n\n  return line.split(',').map(v => {\n    if (v === '') {\n      return 0;\n    }\n\n    if (v.includes('=')) {\n      const [value, length] = v.split('=').map(v => Number.parseInt(v, 10));\n      return Array(length + 1).fill(value);\n    }\n\n    return Number.parseInt(v, 10);\n  }).flat();\n}\n\nfunction compressMatrix(matrix) {\n  if (matrix.length === 0) {\n    return '';\n  }\n\n  const rows = matrix.length;\n  const flat = matrix.flat();\n  return `${rows};${compressLine(flat)}`;\n}\n\nfunction decompressMatrix(matrix) {\n  if (matrix.length === 0) {\n    return [];\n  }\n\n  const [rowsInfo, data] = matrix.split(';');\n  const rows = Number.parseInt(rowsInfo, 10);\n  const values = decompressLine(data);\n  const r = [];\n  let acc = 0;\n\n  for (let i = rows; i > 0; i--) {\n    r.push(values.slice(acc, acc + i));\n    acc += i;\n  }\n\n  return r;\n}\n\nfunction generateOverlapLookup(sets, combinations) {\n  let {\n    toElemKey,\n    what = 'intersection',\n    compress = 'auto'\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const data = sets.concat(combinations);\n\n  function overlapF(set) {\n    if (set.overlap) {\n      return set.overlap;\n    }\n\n    const f = setOverlapFactory(set.elems, toElemKey);\n    return v => {\n      if (v.overlap) {\n        return v.overlap(set);\n      }\n\n      return f(v.elems)[what];\n    };\n  }\n\n  const matrix = data.map((set, i) => {\n    const overlap = overlapF(set);\n    const r = [];\n\n    for (let j = i + 1; j < data.length; j++) {\n      r.push(overlap(data[j]));\n    }\n\n    return r;\n  });\n  matrix.pop();\n\n  if (compress === 'no') {\n    return matrix;\n  }\n\n  const compressed = compressMatrix(matrix);\n\n  if (compress === 'yes') {\n    return compressed;\n  }\n\n  const encodedLength = JSON.stringify(matrix).length;\n  const compressedLength = compressed.length + 2;\n  return compressedLength < encodedLength * 0.6 ? compressed : matrix;\n}\n\nfunction generateOverlapLookupFunction(matrix, sets, combinations) {\n  let toKey$1 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : toKey;\n  const lookup = typeof matrix == 'string' ? decompressMatrix(matrix) : matrix;\n  const setIndex = new Map(sets.map((set, i) => [toKey$1(set), i]));\n  const combinationIndex = new Map(combinations.map((set, i) => [toKey$1(set), i + sets.length]));\n\n  const compute = (a, b) => {\n    if (a === b) {\n      return a.cardinality;\n    }\n\n    const aKey = toKey$1(a);\n    const bKey = toKey$1(b);\n    const aIndex = setIndex.has(aKey) ? setIndex.get(aKey) : combinationIndex.get(aKey);\n    const bIndex = setIndex.has(bKey) ? setIndex.get(bKey) : combinationIndex.get(bKey);\n\n    if (aIndex === bIndex) {\n      return a.cardinality;\n    }\n\n    const row = Math.min(aIndex, bIndex);\n    const col = Math.max(aIndex, bIndex) - row - 1;\n\n    if (row < 0 || row >= lookup.length || col < 0 || col >= lookup[row].length) {\n      return 0;\n    }\n\n    return lookup[row][col];\n  };\n\n  return {\n    setIndex,\n    compute,\n    combinationIndex\n  };\n}\n\nconst bandScale = (domain, size, padding) => {\n  const blocks = domain.length + padding;\n  const step = size / Math.max(1, blocks);\n  const start = size - step * domain.length;\n  const lookup = new Map(domain.map((d, i) => [d, i]));\n  const bandwidth = step / (1 + padding);\n\n  const scale = v => {\n    const index = lookup.get(v);\n\n    if (index == null) {\n      return undefined;\n    }\n\n    return start + step * index;\n  };\n\n  scale.bandwidth = () => bandwidth;\n\n  return scale;\n};\n\nfunction hasOverlap(positions, heights) {\n  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n\n  for (let i = 0; i < positions.length - stride; i += stride) {\n    const pos_i = positions[i];\n    const pos_n = positions[i + 1];\n\n    if (pos_i < pos_n) {\n      const right = pos_i + heights[i] / 2;\n      const left = pos_n - heights[i + 1] / 2;\n\n      if (right > left) {\n        return true;\n      }\n    } else {\n      const left = pos_i - heights[i] / 2;\n      const right = pos_n + heights[i + 1] / 2;\n\n      if (right > left) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}\n\nfunction ensureLast(ticks, max, scale, heightPerTick, toStr) {\n  let last = ticks[ticks.length - 1];\n\n  if (!last.label) {\n    for (let j = ticks.length - 2; j > 0; --j) {\n      if (ticks[j].label) {\n        last = ticks[j];\n        break;\n      }\n    }\n  }\n\n  if (last.value < max) {\n    const pos_l = scale(last.value);\n    const pos_max = scale(max);\n\n    if (pos_l < pos_max) {\n      const right = pos_l + heightPerTick(last.value) / 2;\n      const left = pos_max - heightPerTick(max) / 2;\n\n      if (right < left) {\n        ticks.push({\n          value: max,\n          label: toStr(max)\n        });\n      }\n    } else {\n      const left = pos_l - heightPerTick(last.value) / 2;\n      const right = pos_max + heightPerTick(max) / 2;\n\n      if (right < left) {\n        ticks.push({\n          value: max,\n          label: toStr(max)\n        });\n      }\n    }\n  }\n\n  return ticks;\n}\n\nfunction genTicks(values) {\n  let toStr = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : String;\n  let stride = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n  return values.map((v, i) => ({\n    value: v,\n    label: stride === 1 || i % stride === 0 ? toStr(v) : undefined\n  }));\n}\n\nfunction checkValues(values, scale, heightPerTick, max, toStr) {\n  const positions = values.map(v => scale(v));\n  const heights = values.map(v => heightPerTick(v));\n\n  if (!hasOverlap(positions, heights)) {\n    return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);\n  }\n\n  if (!hasOverlap(positions, heights, 2)) {\n    return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);\n  }\n\n  return null;\n}\n\nfunction toStr(v) {\n  return v.toLocaleString();\n}\n\nfunction niceFactors(max) {\n  let maxCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 11;\n  const digits = Math.max(0, Math.floor(Math.log10(max) - 0.5));\n  const factor = Math.pow(10, digits);\n  const factors = [1, 2, 5];\n  const r = factors.map(f => f * factor);\n\n  if (digits > 0) {\n    r.unshift(factors[factors.length - 1] * Math.pow(10, digits - 1));\n  }\n\n  r.push(factors[0] * Math.pow(10, digits + 1));\n  const lower = Math.ceil(max / maxCount);\n  return r.filter(d => d >= lower && d <= max);\n}\n\nfunction range(max) {\n  let inc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n  const values = [];\n\n  for (let v = 0; v <= max; v += inc) {\n    values.push(v);\n  }\n\n  return values;\n}\n\nfunction distributeTicks(max, maxCount, scale, heightPerTick) {\n  if (maxCount <= 0) {\n    return [];\n  }\n\n  const factors = niceFactors(max, maxCount);\n\n  for (let i = 0; i < factors.length; i++) {\n    const values = range(max, factors[i]);\n    const r = checkValues(values, scale, heightPerTick, max, toStr);\n\n    if (r) {\n      return r;\n    }\n  }\n\n  return genTicks([0, max], toStr);\n}\n\nconst linearScale = (max, range, options) => {\n  const size = range[1] - range[0];\n  const domain = max;\n\n  const scale = v => {\n    const cv = Math.max(0, Math.min(v, domain));\n    const n = cv / domain;\n    return range[0] + n * size;\n  };\n\n  scale.ticks = function () {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n\n    if (options.orientation === 'vertical') {\n      const heightPerTick = Math.ceil(options.fontSizeHint * 1.4);\n      return distributeTicks(max, count + 1, scale, () => heightPerTick);\n    }\n\n    const widthPerChar = options.fontSizeHint / 1.4;\n    return distributeTicks(max, count + 1, scale, v => Math.ceil(toStr(v).length * widthPerChar));\n  };\n\n  scale.tickFormat = () => toStr;\n\n  return scale;\n};\n\nfunction toStr$1(v) {\n  const orders = ['', 'k', 'M', 'G'];\n  const order = Math.max(0, Math.min(Math.floor(Math.log10(v) / 3), orders.length - 1));\n  const vi = Math.round(v / Math.pow(10, order * 3 - 1)) / 10;\n  return `${vi.toLocaleString()}${orders[order]}`;\n}\n\nfunction range$1(max, factor) {\n  const values = [];\n  const inc = Math.pow(10, factor);\n\n  for (let v = 1; v <= max; v *= inc) {\n    values.push(v);\n  }\n\n  return values;\n}\n\nfunction generateInnerTicks(max, factor) {\n  const values = [];\n  const inc = 10;\n\n  for (let v = 1, i = 0; v <= max; v *= inc, i++) {\n    values.push({\n      value: v,\n      label: factor === 1 || i % factor === 0 ? toStr$1(v) : undefined\n    });\n\n    for (let vv = v + v; vv < v * inc && vv < max; vv += v * factor) {\n      values.push({\n        value: vv\n      });\n    }\n  }\n\n  return values;\n}\n\nfunction distributeTicks$1(max, maxCount, scale, heightPerTick) {\n  if (maxCount <= 0) {\n    return [];\n  }\n\n  for (const factor of [1, 2, 5]) {\n    const values = range$1(max, factor);\n    const r = checkValues(values, scale, heightPerTick, max, toStr$1);\n\n    if (r) {\n      return ensureLast(generateInnerTicks(max, factor), max, scale, heightPerTick, toStr$1);\n    }\n  }\n\n  return genTicks([0, max], toStr$1);\n}\n\nconst logScale = (max, range, options) => {\n  const size = range[1] - range[0];\n  const domain = max < 1 ? 1 : Math.log10(max);\n\n  const scale = v => {\n    const cv = Math.max(0, Math.min(v, domain));\n    const n = cv <= 1 ? 0 : Math.log10(cv) / domain;\n    return range[0] + n * size;\n  };\n\n  scale.ticks = function () {\n    let count = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 10;\n\n    if (options.orientation === 'vertical') {\n      const heightPerTick = Math.ceil(options.fontSizeHint * 1.4);\n      return distributeTicks$1(max, count + 1, scale, () => heightPerTick);\n    }\n\n    const widthPerChar = options.fontSizeHint / 1.4;\n    return distributeTicks$1(max, count + 1, scale, v => Math.ceil(toStr$1(v).length * widthPerChar));\n  };\n\n  scale.tickFormat = () => toStr$1;\n\n  return scale;\n};\n\nfunction compressIndicesArray(arr) {\n  if (arr.length === 0) {\n    return '';\n  }\n\n  const encoded = [];\n  let startIndex = 0;\n\n  const push = i => {\n    if (i === startIndex + 1) {\n      encoded.push(arr[startIndex].toString());\n    } else if (i === startIndex + 2 && i < 10) {\n      encoded.push(`${arr[startIndex]},${arr[startIndex + 1]}`);\n    } else {\n      encoded.push(`${arr[startIndex]}+${i - startIndex - 1}`);\n    }\n\n    return i;\n  };\n\n  for (let i = 1; i < arr.length; i++) {\n    const expected = arr[i - 1] + 1;\n    const v = arr[i];\n\n    if (v !== expected) {\n      startIndex = push(i);\n      startIndex = i;\n    }\n  }\n\n  push(arr.length);\n  return encoded.join(',');\n}\n\nfunction toIndicesArray(arr, toIndex) {\n  let {\n    sortAble,\n    compress = 'auto'\n  } = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (arr.length === 0) {\n    return [];\n  }\n\n  const base = arr.map(v => toIndex(v));\n\n  if (compress === 'no') {\n    return base;\n  }\n\n  if (sortAble) {\n    base.sort((a, b) => a - b);\n  }\n\n  const encoded = compressIndicesArray(base);\n  const baseLength = JSON.stringify(base).length;\n  const encodedLength = encoded.length + 2;\n\n  if (encodedLength < baseLength * 0.6 || baseLength - encodedLength > 50 || compress === 'yes' && encodedLength < baseLength) {\n    return encoded;\n  }\n\n  return base;\n}\n\nfunction fromIndicesArray(indices, elements) {\n  if (typeof indices === 'string') {\n    if (indices.length === 0) {\n      return [];\n    }\n\n    return indices.split(',').map(s => {\n      if (s.includes('+')) {\n        const [start, length] = s.split('+').map(si => Number.parseInt(si, 10));\n        return elements.slice(start, start + length + 1);\n      }\n\n      return elements[Number.parseInt(s, 10)];\n    }).flat();\n  }\n\n  return indices.map(i => elements[i]);\n}\n\nfunction withColor(v, s) {\n  if (s.color) {\n    v.color = s.color;\n  }\n\n  return v;\n}\n\nfunction fromDump(dump, elems) {\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n  const sets = dump.sets.map(set => asSet(Object.assign(Object.assign({}, set), {\n    elems: fromIndicesArray(set.elems, elems)\n  })));\n\n  const gen = () => {\n    var _a;\n\n    return generateCombinations(sets, Object.assign({\n      type: 'intersection',\n      elems,\n      toElemKey: options.toElemKey\n    }, (_a = dump.combinationOptions) !== null && _a !== void 0 ? _a : {}));\n  };\n\n  const combinations = dump.combinations ? dump.combinations.map(c => asCombination(Object.assign(Object.assign({}, c), {\n    elems: fromIndicesArray(c.elems, elems)\n  }), c.type, v => v.sets.map(i => sets[i]))) : gen();\n\n  function fromSetRef(ref) {\n    if (ref.type === 'set') {\n      return sets[ref.index];\n    }\n\n    return combinations[ref.index];\n  }\n\n  return {\n    sets,\n    combinations,\n    selection: dump.selection ? typeof dump.selection === 'string' || Array.isArray(dump.selection) ? fromIndicesArray(dump.selection, elems) : fromSetRef(dump.selection) : undefined,\n    queries: dump.queries.map(query => {\n      if (query.set) {\n        return {\n          name: query.name,\n          color: query.color,\n          set: fromSetRef(query.set)\n        };\n      }\n\n      return {\n        name: query.name,\n        color: query.color,\n        elems: fromIndicesArray(query.elems, elems)\n      };\n    })\n  };\n}\n\nfunction toDump(data) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  const indicesOptions = Object.assign({\n    sortAble: true\n  }, config);\n  const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;\n  const bySetKey = new Map(data.sets.map((s, i) => [toKey$1(s), i]));\n  const byCombinationKey = new Map(data.combinations.map((s, i) => [toKey$1(s), i]));\n\n  const toSetRef = s => {\n    if (s.type === 'set') {\n      return {\n        type: s.type,\n        index: bySetKey.get(toKey$1(s))\n      };\n    }\n\n    const index = byCombinationKey.get(toKey$1(s));\n\n    if (index == null || index < 0) {\n      return toIndicesArray(s.elems, data.toElemIndex, indicesOptions);\n    }\n\n    return {\n      type: s.type,\n      index\n    };\n  };\n\n  const setLookup = data.sets.map((s, i) => ({\n    key: toKey$1(s),\n    i\n  }));\n  return {\n    sets: data.sets.map(set => withColor({\n      name: set.name,\n      cardinality: set.cardinality,\n      elems: toIndicesArray(set.elems, data.toElemIndex, indicesOptions)\n    }, set)),\n    combinations: config.compress === 'no' ? data.combinations.map(c => {\n      const setKeys = new Set(Array.from(c.sets).map(toKey$1));\n      return withColor({\n        name: c.name,\n        type: c.type,\n        cardinality: c.cardinality,\n        degree: c.degree,\n        sets: setLookup.filter(_ref2 => {\n          let {\n            key\n          } = _ref2;\n          return setKeys.has(key);\n        }).map(_ref3 => {\n          let {\n            i\n          } = _ref3;\n          return i;\n        }),\n        elems: toIndicesArray(c.elems, data.toElemIndex, indicesOptions)\n      }, c);\n    }) : undefined,\n    combinationOptions: data.combinationOptions,\n    selection: data.selection ? Array.isArray(data.selection) ? toIndicesArray(data.selection, data.toElemIndex, indicesOptions) : toSetRef(data.selection) : undefined,\n    queries: data.queries.map(query => {\n      const elems = isSetQuery(query) ? toSetRef(query.set) : toIndicesArray(Array.from(query.elems), data.toElemIndex, indicesOptions);\n      return {\n        name: query.name,\n        color: query.color,\n        set: typeof elems === 'string' || Array.isArray(elems) ? undefined : elems,\n        elems: typeof elems === 'string' || Array.isArray(elems) ? elems : undefined\n      };\n    })\n  };\n}\n\nfunction generateName$1(sets, type) {\n  if (sets.length === 1) {\n    return sets[0].name;\n  }\n\n  return `(${sets.map(set => set.name).join(SET_JOINERS[type])})`;\n}\n\nfunction toStaticDump(data) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;\n  const bySetKey = new Map(data.sets.map((s, i) => [toKey$1(s), i]));\n  const byCombinationKey = new Map(data.combinations.map((s, i) => [toKey$1(s), i]));\n\n  const toSelectionSetRef = s => {\n    if (isSetLike(s)) {\n      if (s.type === 'set') {\n        return {\n          type: s.type,\n          index: bySetKey.get(toKey$1(s))\n        };\n      }\n\n      const index = byCombinationKey.get(toKey$1(s));\n\n      if (index != null && index >= 0) {\n        return {\n          type: s.type,\n          index\n        };\n      }\n    }\n\n    const overlapF = setOverlapFactory(isSetLike(s) ? s.elems : s);\n    return data.sets.map(set => overlapF(set.elems).intersection).concat(data.combinations.map(set => overlapF(set.elems).intersection));\n  };\n\n  const setIndex = new Map(data.sets.map((set, i) => [toKey$1(set), i]));\n  const overlaps = generateOverlapLookup(data.sets, data.combinations, config);\n  const shortNames = config.compress === 'yes';\n\n  const compressCombination = set => {\n    const partOf = Array.from(set.sets).map(s => setIndex.get(toKey$1(s))).sort((a, b) => a - b);\n    const r = {\n      c: set.cardinality,\n      s: partOf.reduce((acc, i) => acc + Math.pow(2, i), 0)\n    };\n\n    if (set.name !== generateName$1(partOf.map(i => data.sets[i]), set.type)) {\n      r.n = set.name;\n    }\n\n    if (set.type !== 'intersection') {\n      r.type = set.type[0];\n    }\n\n    if (set.color) {\n      r.cc = set.color;\n    }\n\n    return r;\n  };\n\n  return {\n    sets: shortNames ? data.sets.map(set => ({\n      n: set.name,\n      cc: set.color,\n      c: set.cardinality\n    })) : data.sets.map(set => withColor({\n      name: set.name,\n      cardinality: set.cardinality\n    }, set)),\n    combinations: shortNames ? data.combinations.map(compressCombination) : data.combinations.map(set => withColor({\n      name: set.name,\n      cardinality: set.cardinality,\n      type: set.type,\n      sets: Array.from(set.sets).map(s => setIndex.get(toKey$1(s))).sort((a, b) => a - b)\n    }, set)),\n    overlaps,\n    selection: data.selection ? toSelectionSetRef(data.selection) : undefined,\n    queries: data.queries.map(query => {\n      if (isSetQuery(query)) {\n        const ref = toSelectionSetRef(query.set);\n\n        if (Array.isArray(ref)) {\n          return {\n            name: query.name,\n            color: query.color,\n            overlaps: ref\n          };\n        }\n\n        return {\n          name: query.name,\n          color: query.color,\n          set: ref\n        };\n      }\n\n      const overlapF = setOverlapFactory(query.elems);\n      const overlaps = data.sets.map(set => overlapF(set.elems).intersection).concat(data.combinations.map(set => overlapF(set.elems).intersection));\n      return {\n        name: query.name,\n        color: query.color,\n        overlaps\n      };\n    })\n  };\n}\n\nfunction isCompressed(s) {\n  return typeof s.c === 'number';\n}\n\nfunction isCompressedSet(s) {\n  return typeof s.c === 'number';\n}\n\nfunction fromStaticDump(dump) {\n  let config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n  var _a;\n\n  const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;\n\n  let computeF = () => 0;\n\n  function withOverlap(s) {\n    s.overlap = b => computeF(s, b);\n\n    return s;\n  }\n\n  const sets = dump.sets.map(set => withOverlap({\n    name: isCompressedSet(set) ? set.n : set.name,\n    cardinality: isCompressedSet(set) ? set.c : set.cardinality,\n    type: 'set',\n    elems: []\n  }));\n\n  const fromBit = v => {\n    return sets.filter((_, i) => {\n      const position = Math.pow(2, i);\n      return (v & position) === position;\n    });\n  };\n\n  const combinations = dump.combinations.map(set => {\n    var _a, _b;\n\n    const partOf = isCompressed(set) ? fromBit(set.s) : set.sets.map(i => sets[i]);\n    const lookup = {\n      i: 'intersection',\n      u: 'union',\n      c: 'composite',\n      d: 'distinctIntersection'\n    };\n    const type = lookup[((_a = set.type) !== null && _a !== void 0 ? _a : 'i')[0]];\n    return withOverlap({\n      name: isCompressed(set) ? (_b = set.n) !== null && _b !== void 0 ? _b : generateName$1(partOf, type) : set.name,\n      cardinality: isCompressed(set) ? set.c : set.cardinality,\n      type,\n      degree: partOf.length,\n      sets: new Set(partOf),\n      elems: []\n    });\n  });\n  const {\n    setIndex,\n    combinationIndex,\n    compute\n  } = generateOverlapLookupFunction(dump.overlaps, sets, combinations, toKey$1);\n  computeF = compute;\n\n  function fromSetRef(ref) {\n    if (ref.type === 'set') {\n      return sets[ref.index];\n    }\n\n    return combinations[ref.index];\n  }\n\n  function generateOverlap(lookup) {\n    return v => {\n      const key = toKey$1(v);\n      const index = setIndex.has(key) ? setIndex.get(key) : combinationIndex.get(key);\n      return index == null || index < 0 || index >= lookup.length ? 0 : lookup[index];\n    };\n  }\n\n  return {\n    sets,\n    combinations,\n    selection: dump.selection ? Array.isArray(dump.selection) ? generateOverlap(dump.selection) : fromSetRef(dump.selection) : undefined,\n    queries: dump.queries.map(query => {\n      if (query.set) {\n        return {\n          name: query.name,\n          color: query.color,\n          set: fromSetRef(query.set)\n        };\n      }\n\n      return {\n        name: query.name,\n        color: query.color,\n        overlap: generateOverlap(query.overlaps)\n      };\n    })\n  };\n}\n\nexport { asCombination, asCombinations, asSet, asSets, bandScale, extractCombinations, extractFromExpression, extractSets, fromDump, fromIndicesArray, fromSetName, fromStaticDump, generateCombinations, generateDistinctOverlapFunction, generateIntersectionOverlapFunction, generateOverlapFunction, generateOverlapLookup, generateOverlapLookupFunction, generateUnionOverlapFunction, isCalcQuery, isElemQuery, isGenerateSetCombinationOptions, isSet, isSetCombination, isSetLike, isSetQuery, isUpSetQuery, linearScale, logScale, mergeColors, parseColor, queryElemOverlap, queryOverlap, setElemIntersectionFactory, setElemOverlap, setElemOverlapFactory, setOverlap, setOverlapFactory, toDump, toIndicesArray, toKey, toStaticDump };","map":{"version":3,"sources":["../src/data/setOverlap.ts","../src/queries.ts","../src/validators.ts","../src/data/utils.ts","../src/data/asCombinations.ts","../src/data/constants.ts","../src/colors.ts","../src/data/generateCombinations.ts","../src/data/asSets.ts","../src/data/extractFromExpression.ts","../src/data/extractSets.ts","../src/data/extractCombinations.ts","../src/model.ts","../src/data/generateOverlapFunction.ts","../src/data/generateOverlapLookup.ts","../src/scales/band.ts","../src/scales/numeric.ts","../src/scales/linear.ts","../src/scales/log.ts","../src/array.ts","../src/dump/utils.ts","../src/dump/dump.ts","../src/dump/staticDump.ts"],"names":["mergeColors","mergeDefaultColors","toOrder","toKey","toDefaultKey","toKeyImpl","toStr","range","distributeTicks","generateName"],"mappings":"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","sourcesContent":["/**\n * @upsetjs/model\n * https://github.com/upsetjs/upsetjs\n *\n * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>\n */\n\nfunction len(a) {\r\n    return a instanceof Set ? a.size : a.length;\r\n}\r\nfunction setOverlapFactory(a, toElemKey) {\r\n    const elems = !toElemKey\r\n        ? a instanceof Set\r\n            ? a\r\n            : new Set(a)\r\n        : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));\r\n    const setA = elems.size;\r\n    const same = {\r\n        setA,\r\n        setB: setA,\r\n        union: setA,\r\n        intersection: setA,\r\n    };\r\n    return (b) => {\r\n        if (b === a) {\r\n            return same;\r\n        }\r\n        let intersection = 0;\r\n        b.forEach((e) => {\r\n            if ((toElemKey && elems.has(toElemKey(e))) || (!toElemKey && elems.has(e))) {\r\n                intersection++;\r\n            }\r\n        });\r\n        const setB = len(b);\r\n        return {\r\n            setA,\r\n            setB,\r\n            intersection,\r\n            union: setA + setB - intersection,\r\n        };\r\n    };\r\n}\r\nfunction setOverlap(a, b, toElemKey) {\r\n    if (len(a) < len(b) || a instanceof Set) {\r\n        return setOverlapFactory(a, toElemKey)(b);\r\n    }\r\n    const r = setOverlapFactory(b, toElemKey)(a);\r\n    return Object.assign({}, r, {\r\n        setA: r.setB,\r\n        setB: r.setA,\r\n    });\r\n}\r\nfunction setElemOverlapFactory(a, toElemKey) {\r\n    const elems = !toElemKey\r\n        ? a instanceof Set\r\n            ? a\r\n            : new Set(a)\r\n        : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));\r\n    const setA = Array.isArray(a) ? a : Array.from(a);\r\n    const same = {\r\n        setA,\r\n        setB: setA,\r\n        union: setA,\r\n        intersection: setA,\r\n    };\r\n    return (b) => {\r\n        if (b === a) {\r\n            return same;\r\n        }\r\n        const intersection = [];\r\n        const union = setA.slice();\r\n        b.forEach((e) => {\r\n            if ((toElemKey && elems.has(toElemKey(e))) || (!toElemKey && elems.has(e))) {\r\n                intersection.push(e);\r\n            }\r\n            else {\r\n                union.push(e);\r\n            }\r\n        });\r\n        return {\r\n            setA: setA,\r\n            setB: Array.isArray(b) ? b : Array.from(b),\r\n            intersection,\r\n            union,\r\n        };\r\n    };\r\n}\r\nfunction setElemOverlap(a, b, toElemKey) {\r\n    if (len(a) < len(b) || a instanceof Set) {\r\n        return setElemOverlapFactory(a, toElemKey)(b);\r\n    }\r\n    const r = setElemOverlapFactory(b, toElemKey)(a);\r\n    return Object.assign({}, r, {\r\n        setA: r.setB,\r\n        setB: r.setA,\r\n    });\r\n}\r\nfunction setElemIntersectionFactory(a, toElemKey) {\r\n    const arr = a instanceof Set ? Array.from(a) : a;\r\n    const elems = !toElemKey ? (a instanceof Set ? a : new Set(a)) : new Set(arr.map(toElemKey));\r\n    return (b) => {\r\n        if (b === a) {\r\n            return arr;\r\n        }\r\n        const intersection = [];\r\n        b.forEach((e) => {\r\n            if ((toElemKey && elems.has(toElemKey(e))) || (!toElemKey && elems.has(e))) {\r\n                intersection.push(e);\r\n            }\r\n        });\r\n        return intersection;\r\n    };\r\n}\n\nfunction isElemQuery(q) {\r\n    return Array.isArray(q.elems);\r\n}\r\nfunction isCalcQuery(q) {\r\n    return typeof q.overlap === 'function';\r\n}\r\nfunction isSetQuery(q) {\r\n    return q.set != null;\r\n}\r\nfunction queryOverlap(query, what, toElemKey) {\r\n    if (isCalcQuery(query)) {\r\n        return query.overlap;\r\n    }\r\n    if (isSetQuery(query) && query.set.overlap) {\r\n        return query.set.overlap;\r\n    }\r\n    const f = setOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);\r\n    return (s) => {\r\n        if (s.overlap && isElemQuery(query) && Array.isArray(query.elems)) {\r\n            return s.overlap(query.elems);\r\n        }\r\n        if (s.overlap && isSetQuery(query)) {\r\n            return s.overlap(query.set);\r\n        }\r\n        return f(s.elems)[what];\r\n    };\r\n}\r\nfunction queryElemOverlap(query, what, toElemKey) {\r\n    if (isCalcQuery(query)) {\r\n        return () => null;\r\n    }\r\n    if (what === 'intersection') {\r\n        const f = setElemIntersectionFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);\r\n        return (s) => f(s.elems);\r\n    }\r\n    const f = setElemOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);\r\n    return (s) => {\r\n        return f(s.elems)[what];\r\n    };\r\n}\n\nfunction isBaseSet(v) {\r\n    const vt = v;\r\n    return v != null && typeof vt.cardinality === 'number' && typeof v.name === 'string' && Array.isArray(v.elems);\r\n}\r\nfunction isSet(v) {\r\n    return isBaseSet(v) && v.type === 'set';\r\n}\r\nfunction isSetCombination(v) {\r\n    const vt = v;\r\n    return (isBaseSet(v) &&\r\n        ['composite', 'union', 'intersection', 'distinctIntersection'].includes(vt.type) &&\r\n        vt.sets instanceof Set &&\r\n        typeof vt.degree === 'number');\r\n}\r\nfunction isSetLike(v) {\r\n    return isSet(v) || isSetCombination(v);\r\n}\r\nfunction isGenerateSetCombinationOptions(v) {\r\n    const vt = v;\r\n    return v != null && (vt.type == null || ['intersection', 'union'].includes(vt.type));\r\n}\r\nfunction isUpSetQuery(v) {\r\n    const vt = v;\r\n    return (v != null &&\r\n        typeof vt.name === 'string' &&\r\n        typeof vt.color === 'string' &&\r\n        (isElemQuery(vt) || isSetQuery(vt) || isCalcQuery(vt)));\r\n}\n\nfunction byName(a, b) {\r\n    return a.name.localeCompare(b.name);\r\n}\r\nfunction byCardinality(a, b) {\r\n    return b.cardinality - a.cardinality;\r\n}\r\nfunction byDegree(a, b) {\r\n    return a.degree - b.degree;\r\n}\r\nfunction byComposite(func) {\r\n    return (a, b) => {\r\n        return func.reduce((acc, f) => (acc === 0 ? f(a, b) : acc), 0);\r\n    };\r\n}\r\nfunction negate(func) {\r\n    return (a, b) => -func(a, b);\r\n}\r\nfunction byGroup(sets) {\r\n    return (a, b) => {\r\n        const fixNotFound = (v) => (v < 0 ? Number.POSITIVE_INFINITY : v);\r\n        const aIndex = fixNotFound(sets.findIndex((s) => a.sets.has(s)));\r\n        const bIndex = fixNotFound(sets.findIndex((s) => b.sets.has(s)));\r\n        return aIndex - bIndex;\r\n    };\r\n}\n\nfunction fromSetName(sets, symbol = /[∩∪&|]/) {\r\n    const byName = new Map(sets.map((s) => [s.name, s]));\r\n    return (s) => {\r\n        return s.name.split(symbol).map((setName) => byName.get(setName.trim()));\r\n    };\r\n}\r\nfunction toOrder(sets, order) {\r\n    if (!order) {\r\n        return byName;\r\n    }\r\n    const arr = (Array.isArray(order) ? order : [order]);\r\n    if (arr.length === 0) {\r\n        return byName;\r\n    }\r\n    return byComposite(arr.map((o) => {\r\n        switch (o) {\r\n            case 'cardinality':\r\n            case 'cardinality:desc':\r\n                return byCardinality;\r\n            case 'cardinality:asc':\r\n                return negate(byCardinality);\r\n            case 'name:desc':\r\n                return negate(byName);\r\n            case 'degree':\r\n            case 'degree:asc':\r\n                return byDegree;\r\n            case 'degree:desc':\r\n                return negate(byDegree);\r\n            case 'group':\r\n            case 'group:asc':\r\n                return byGroup(sets);\r\n            case 'group:desc':\r\n                return negate(byGroup(sets));\r\n            default:\r\n                return byName;\r\n        }\r\n    }));\r\n}\r\nfunction postprocessCombinations(sets, combinations, options = {}) {\r\n    let r = combinations;\r\n    if (options.order) {\r\n        r = r.sort(toOrder(sets, options.order));\r\n    }\r\n    if (options.limit != null) {\r\n        return r.slice(0, options.limit);\r\n    }\r\n    return r;\r\n}\r\nfunction asCombination(set, type, toSets) {\r\n    const sets = toSets(set);\r\n    return Object.assign({\r\n        type,\r\n        cardinality: set.elems.length,\r\n        sets: new Set(sets),\r\n        degree: sets.length,\r\n    }, set);\r\n}\r\nfunction asCombinations(sets, type, toSets) {\r\n    return sets.map((set) => asCombination(set, type, toSets));\r\n}\n\nconst SET_JOINERS = {\r\n    distinctIntersection: ' ∩ ',\r\n    intersection: ' ∩ ',\r\n    union: ' ∪ ',\r\n    composite: ',',\r\n};\n\nfunction parseColor(color) {\r\n    if (!color) {\r\n        return [255, 255, 255];\r\n    }\r\n    const hex = color.match(/#([\\da-f]{2})([\\da-f]{2})([\\da-f]{2})/i);\r\n    if (hex) {\r\n        return [Number.parseInt(hex[1], 16), Number.parseInt(hex[2], 16), Number.parseInt(hex[3], 16)];\r\n    }\r\n    const rgb = color.match(/\\(([\\d]+)[, ]([\\d]+)[, ]([\\d]+)\\)/i);\r\n    if (rgb) {\r\n        return [Number.parseInt(rgb[1], 10), Number.parseInt(rgb[2], 10), Number.parseInt(rgb[3], 10)];\r\n    }\r\n    return [255, 255, 255];\r\n}\r\nfunction mergeColors(colors) {\r\n    if (colors.length === 1) {\r\n        return colors[0];\r\n    }\r\n    if (colors.every((d) => d == null)) {\r\n        return undefined;\r\n    }\r\n    const rgb = colors.map(parseColor);\r\n    const r = Math.floor(rgb.reduce((acc, v) => acc + v[0], 0) / rgb.length);\r\n    const g = Math.floor(rgb.reduce((acc, v) => acc + v[1], 0) / rgb.length);\r\n    const b = Math.floor(rgb.reduce((acc, v) => acc + v[2], 0) / rgb.length);\r\n    return `#${r.toString(16)}${g.toString(16)}${b.toString(16)}`;\r\n}\n\nfunction generateName(combo, setIndex, joiner) {\r\n    const sorted = Array.from(combo).sort((a, b) => setIndex.get(a) - setIndex.get(b));\r\n    return sorted.length === 1 ? sorted[0].name : `(${sorted.map((d) => d.name).join(joiner)})`;\r\n}\r\nfunction generateSet(type, name, combo, elems, mergeColors) {\r\n    return {\r\n        type: combo.size === 0 ? 'composite' : type,\r\n        elems,\r\n        color: mergeColors(Array.from(combo).map((s) => s.color)),\r\n        sets: combo,\r\n        name,\r\n        cardinality: elems.length,\r\n        degree: combo.size,\r\n    };\r\n}\r\nfunction mergeIntersection(a, b, lookup, toKey, setIndex, type, mergeColors) {\r\n    const merged = new Set(a.sets);\r\n    b.sets.forEach((s) => merged.add(s));\r\n    const name = generateName(merged, setIndex, SET_JOINERS[type]);\r\n    if (a.cardinality === 0 || b.cardinality === 0) {\r\n        return generateSet(type, name, merged, [], mergeColors);\r\n    }\r\n    let small = a;\r\n    let big = b;\r\n    if (a.cardinality > b.cardinality) {\r\n        small = b;\r\n        big = a;\r\n    }\r\n    const keySet = new Set();\r\n    const bigLookup = lookup.get(big);\r\n    const elems = [];\r\n    const l = small.elems.length;\r\n    for (let i = 0; i < l; i++) {\r\n        const e = small.elems[i];\r\n        const key = toKey(e);\r\n        if (!bigLookup.has(key)) {\r\n            continue;\r\n        }\r\n        keySet.add(key);\r\n        elems.push(e);\r\n    }\r\n    const r = generateSet(type, name, merged, elems, mergeColors);\r\n    lookup.set(r, keySet);\r\n    return r;\r\n}\r\nfunction mergeUnion(a, b, lookup, toKey, setIndex, type, mergeColors) {\r\n    const merged = new Set(a.sets);\r\n    b.sets.forEach((s) => merged.add(s));\r\n    const name = generateName(merged, setIndex, SET_JOINERS[type]);\r\n    if (a.cardinality === 0) {\r\n        const r = generateSet(type, name, merged, b.elems, mergeColors);\r\n        lookup.set(r, lookup.get(b));\r\n        return r;\r\n    }\r\n    if (b.cardinality === 0) {\r\n        const r = generateSet(type, name, merged, a.elems, mergeColors);\r\n        lookup.set(r, lookup.get(a));\r\n        return r;\r\n    }\r\n    let small = a;\r\n    let big = b;\r\n    if (a.cardinality > b.cardinality) {\r\n        small = b;\r\n        big = a;\r\n    }\r\n    const keySet = new Set(lookup.get(big));\r\n    const bigLookup = lookup.get(big);\r\n    const elems = big.elems.slice();\r\n    small.elems.forEach((e) => {\r\n        const key = toKey(e);\r\n        if (bigLookup.has(key)) {\r\n            return;\r\n        }\r\n        keySet.add(key);\r\n        elems.push(e);\r\n    });\r\n    const r = generateSet(type, name, merged, elems, mergeColors);\r\n    lookup.set(r, keySet);\r\n    return r;\r\n}\r\nfunction generateEmptySet(type, notPartOfAnySet, allElements, lookup, toKey, mergeColors) {\r\n    if (typeof notPartOfAnySet === 'number') {\r\n        return {\r\n            type: 'composite',\r\n            elems: [],\r\n            color: mergeColors ? mergeColors([]) : undefined,\r\n            sets: new Set(),\r\n            name: '()',\r\n            cardinality: notPartOfAnySet,\r\n            overlap(s) {\r\n                return s === this || (isSetLike(s) && s.name === this.name && s.cardinality === this.cardinality)\r\n                    ? this.cardinality\r\n                    : 0;\r\n            },\r\n            degree: 0,\r\n        };\r\n    }\r\n    if (Array.isArray(notPartOfAnySet)) {\r\n        return generateSet(type, '()', new Set(), notPartOfAnySet, mergeColors);\r\n    }\r\n    const lookupArr = Array.from(lookup.values());\r\n    const elems = allElements.filter((e) => {\r\n        const k = toKey(e);\r\n        return lookupArr.every((s) => !s.has(k));\r\n    });\r\n    return generateSet(type, '()', new Set(), elems, mergeColors);\r\n}\r\nfunction generateCombinations(sets, options = {}) {\r\n    const { type = 'intersection', min = 0, max = Infinity, empty = false, elems: allElements = [], notPartOfAnySet, toElemKey, mergeColors: mergeColors$1 = mergeColors, } = options;\r\n    const combinations = [];\r\n    const setIndex = new Map(sets.map((s, i) => [s, i]));\r\n    const setElems = new Map(sets.map((s) => [s, toElemKey ? new Set(s.elems.map(toElemKey)) : new Set(s.elems)]));\r\n    const setDirectElems = toElemKey ? null : setElems;\r\n    const setKeyElems = toElemKey ? setElems : null;\r\n    const calc = type === 'union' ? mergeUnion : mergeIntersection;\r\n    function push(s) {\r\n        if (s.degree < min || s.degree > max || (s.cardinality === 0 && !empty)) {\r\n            return;\r\n        }\r\n        if (type !== 'distinctIntersection') {\r\n            combinations.push(s);\r\n            return;\r\n        }\r\n        const others = sets.filter((d) => !s.sets.has(d));\r\n        let elems = [];\r\n        if (toElemKey) {\r\n            const othersSets = others.map((o) => setKeyElems.get(o));\r\n            elems = s.elems.filter((e) => {\r\n                const key = toElemKey(e);\r\n                return othersSets.every((o) => !o.has(key));\r\n            });\r\n        }\r\n        else {\r\n            const othersSets = others.map((o) => setDirectElems.get(o));\r\n            elems = s.elems.filter((e) => othersSets.every((o) => !o.has(e)));\r\n        }\r\n        if (elems.length === s.cardinality) {\r\n            combinations.push(s);\r\n            return;\r\n        }\r\n        const sDistinct = generateSet(type, s.name, s.sets, elems, mergeColors$1);\r\n        if (sDistinct.cardinality === 0 && !empty) {\r\n            return;\r\n        }\r\n        combinations.push(sDistinct);\r\n    }\r\n    function generateLevel(arr, degree, lookup, toKey) {\r\n        if (degree > max) {\r\n            return;\r\n        }\r\n        const l = arr.length;\r\n        for (let i = 0; i < l; i++) {\r\n            const a = arr[i];\r\n            const sub = [];\r\n            for (let j = i + 1; j < l; j++) {\r\n                const b = arr[j];\r\n                const ab = calc(a, b, lookup, toKey, setIndex, type, mergeColors$1);\r\n                push(ab);\r\n                if (type === 'union' || ab.cardinality > 0 || empty) {\r\n                    sub.push(ab);\r\n                }\r\n            }\r\n            if (sub.length > 1) {\r\n                generateLevel(sub, degree + 1, lookup, toKey);\r\n            }\r\n        }\r\n    }\r\n    if (min <= 0) {\r\n        if (toElemKey) {\r\n            push(generateEmptySet(type, notPartOfAnySet, allElements, setKeyElems, toElemKey, mergeColors$1));\r\n        }\r\n        else {\r\n            push(generateEmptySet(type, notPartOfAnySet, allElements, setDirectElems, (v) => v, mergeColors$1));\r\n        }\r\n    }\r\n    const degree1 = sets.map((s) => {\r\n        const r = generateSet(type, s.name, new Set([s]), s.elems, mergeColors$1);\r\n        setElems.set(r, setElems.get(s));\r\n        push(r);\r\n        return r;\r\n    });\r\n    if (toElemKey) {\r\n        generateLevel(degree1, 2, setKeyElems, toElemKey);\r\n    }\r\n    else {\r\n        generateLevel(degree1, 2, setDirectElems, (v) => v);\r\n    }\r\n    return postprocessCombinations(sets, combinations, options);\r\n}\n\nfunction asSet(set) {\r\n    return Object.assign({\r\n        type: 'set',\r\n        cardinality: set.elems.length,\r\n    }, set);\r\n}\r\nfunction toOrder$1(order) {\r\n    if (!order) {\r\n        return byName;\r\n    }\r\n    switch (order) {\r\n        case 'cardinality':\r\n        case 'cardinality:desc':\r\n            return byComposite([byCardinality, byName]);\r\n        case 'cardinality:asc':\r\n            return byComposite([negate(byCardinality), byName]);\r\n        case 'name:desc':\r\n            return negate(byName);\r\n        default:\r\n            return byName;\r\n    }\r\n}\r\nfunction postprocessSets(sets, options = {}) {\r\n    let r = sets;\r\n    if (options.order) {\r\n        const order = toOrder$1(options.order);\r\n        r = r.slice().sort(order);\r\n    }\r\n    if (options.limit != null) {\r\n        return r.slice(0, options.limit);\r\n    }\r\n    return r;\r\n}\r\nfunction asSets(sets, options = {}) {\r\n    return postprocessSets(sets.map(asSet), options);\r\n}\n\nfunction extractFromExpression(combinations, accOrOptions, o = {}) {\r\n    var _a, _b, _c;\r\n    const acc = typeof accOrOptions === 'function' ? accOrOptions : (e) => e.sets;\r\n    const options = (_a = (typeof accOrOptions !== 'function' ? accOrOptions : o)) !== null && _a !== void 0 ? _a : {};\r\n    const type = (_b = options.type) !== null && _b !== void 0 ? _b : 'intersection';\r\n    const joiner = (_c = options.joiner) !== null && _c !== void 0 ? _c : SET_JOINERS[type];\r\n    const sets = [];\r\n    const setLookup = new Map();\r\n    const cs = combinations.map((c) => {\r\n        const containedSets = acc(c);\r\n        const containedSetsObjects = containedSets.map((s) => {\r\n            if (setLookup.has(s)) {\r\n                return setLookup.get(s);\r\n            }\r\n            const set = {\r\n                cardinality: 0,\r\n                elems: [],\r\n                name: s,\r\n                type: 'set',\r\n            };\r\n            sets.push(set);\r\n            setLookup.set(set.name, set);\r\n            return set;\r\n        });\r\n        if (type === 'distinctIntersection') {\r\n            for (const s of containedSetsObjects) {\r\n                s.cardinality += c.cardinality;\r\n            }\r\n        }\r\n        else if (containedSets.length === 1) {\r\n            Object.assign(containedSetsObjects[0], {\r\n                cardinality: c.cardinality,\r\n            }, c);\r\n        }\r\n        else if (type === 'intersection') {\r\n            for (const s of containedSetsObjects) {\r\n                s.cardinality = Math.max(s.cardinality, c.cardinality);\r\n            }\r\n        }\r\n        else if (type === 'union') {\r\n            for (const s of containedSetsObjects) {\r\n                s.cardinality = Math.min(s.cardinality, c.cardinality);\r\n            }\r\n        }\r\n        const name = containedSets.join(joiner);\r\n        return Object.assign({\r\n            type,\r\n            elems: [],\r\n            name,\r\n        }, c, {\r\n            cardinality: c.cardinality,\r\n            degree: containedSets.length,\r\n            sets: new Set(containedSetsObjects),\r\n        });\r\n    });\r\n    const sortedSets = postprocessSets(sets, {\r\n        order: options.setOrder,\r\n    });\r\n    const sortedCombinations = postprocessCombinations(sortedSets, cs, {\r\n        order: options.combinationOrder,\r\n    });\r\n    return {\r\n        sets: sortedSets,\r\n        combinations: sortedCombinations,\r\n    };\r\n}\n\nfunction extractSets(elements, accOrOptions, o = {}) {\r\n    var _a;\r\n    const acc = typeof accOrOptions === 'function' ? accOrOptions : (e) => e.sets;\r\n    const options = (_a = (typeof accOrOptions !== 'function' ? accOrOptions : o)) !== null && _a !== void 0 ? _a : {};\r\n    const sets = Object.create(null);\r\n    elements.forEach((elem) => {\r\n        acc(elem).forEach((set) => {\r\n            const s = typeof set === 'string' ? set : String(set);\r\n            const r = sets[s];\r\n            if (r == null) {\r\n                sets[s] = [elem];\r\n            }\r\n            else {\r\n                r.push(elem);\r\n            }\r\n        });\r\n    });\r\n    return postprocessSets(Object.entries(sets).map(([set, elems]) => {\r\n        const r = {\r\n            type: 'set',\r\n            elems,\r\n            name: String(set),\r\n            cardinality: elems.length,\r\n        };\r\n        return r;\r\n    }), options);\r\n}\n\nfunction createTree(byDegree, getOrCreateCombination) {\r\n    const children = new Map();\r\n    byDegree\r\n        .slice()\r\n        .reverse()\r\n        .forEach((csOfDegree) => {\r\n        if (csOfDegree.length === 0 || csOfDegree[0].degree === 1) {\r\n            return;\r\n        }\r\n        csOfDegree.forEach((c) => {\r\n            const sets = Array.from(c.sets).map((d) => d.name);\r\n            for (let i = 0; i < sets.length; i++) {\r\n                const subSet = sets.slice();\r\n                subSet.splice(i, 1);\r\n                const parent = getOrCreateCombination(subSet);\r\n                if (children.has(parent)) {\r\n                    children.get(parent).push(c);\r\n                }\r\n                else {\r\n                    children.set(parent, [c]);\r\n                }\r\n            }\r\n        });\r\n    });\r\n    return children;\r\n}\r\nfunction extractCombinations(elements, accOrOptions, o = {}) {\r\n    var _a, _b, _c, _d;\r\n    const acc = typeof accOrOptions === 'function' ? accOrOptions : (e) => e.sets;\r\n    const options = (_a = (typeof accOrOptions !== 'function' ? accOrOptions : o)) !== null && _a !== void 0 ? _a : {};\r\n    const type = (_b = options.type) !== null && _b !== void 0 ? _b : 'intersection';\r\n    const sets = (_c = options.sets) !== null && _c !== void 0 ? _c : extractSets(elements, acc, {\r\n        limit: options.setLimit,\r\n        order: options.setOrder,\r\n    });\r\n    if (type === 'union') {\r\n        return {\r\n            sets,\r\n            combinations: generateCombinations(sets, {\r\n                type: 'union',\r\n                limit: options.combinationLimit,\r\n                order: options.combinationOrder,\r\n            }),\r\n        };\r\n    }\r\n    const setLookup = Object.create(null);\r\n    sets.forEach((set, i) => {\r\n        setLookup[set.name] = [set, i];\r\n    });\r\n    const isSortedAlphabetically = sets\r\n        .map((d) => d.name)\r\n        .sort()\r\n        .every((d, i) => sets[i].name === d);\r\n    const bySet = isSortedAlphabetically\r\n        ? undefined\r\n        : (a, b) => {\r\n            var _a, _b, _c, _d;\r\n            const ai = (_b = (_a = setLookup[a]) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : -1;\r\n            const bi = (_d = (_c = setLookup[b]) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : -1;\r\n            return ai - bi;\r\n        };\r\n    const validSet = options.sets == null && options.setLimit == null ? null : new Set(sets.map((d) => d.name));\r\n    const joiner = (_d = options.joiner) !== null && _d !== void 0 ? _d : SET_JOINERS[type];\r\n    const cs = [];\r\n    const csLookup = Object.create(null);\r\n    const byDegree = Array(sets.length + 1)\r\n        .fill(0)\r\n        .map((_) => []);\r\n    function genName(setsOfElem) {\r\n        switch (setsOfElem.length) {\r\n            case 0:\r\n                return '()';\r\n            case 1:\r\n                return setsOfElem[0];\r\n            default:\r\n                const sorted = setsOfElem.slice().sort(bySet);\r\n                const joined = sorted.join(joiner);\r\n                return '(' + joined + ')';\r\n        }\r\n    }\r\n    function genKey(setsOfElem) {\r\n        switch (setsOfElem.length) {\r\n            case 0:\r\n                return '';\r\n            case 1:\r\n                return setsOfElem[0];\r\n            case 2: {\r\n                if ((bySet != null && bySet(setsOfElem[0], setsOfElem[1]) > 0) ||\r\n                    (bySet == null && setsOfElem[1] > setsOfElem[0])) {\r\n                    return setsOfElem[1] + '&' + setsOfElem[0];\r\n                }\r\n                return setsOfElem[0] + '&' + setsOfElem[1];\r\n            }\r\n            default:\r\n                const sorted = setsOfElem.slice().sort(bySet);\r\n                return sorted.join('&');\r\n        }\r\n    }\r\n    function getOrCreateCombination(setsOfElem) {\r\n        const key = genKey(setsOfElem);\r\n        let entry = csLookup[key];\r\n        if (entry) {\r\n            return entry;\r\n        }\r\n        const newEntry = {\r\n            type,\r\n            name: genName(setsOfElem),\r\n            degree: setsOfElem.length,\r\n            sets: new Set(setsOfElem.map((s) => setLookup[s][0])),\r\n            cardinality: 0,\r\n            elems: [],\r\n        };\r\n        csLookup[key] = newEntry;\r\n        cs.push(newEntry);\r\n        byDegree[newEntry.degree].push(newEntry);\r\n        return newEntry;\r\n    }\r\n    elements.forEach((elem) => {\r\n        let setsOfElem = acc(elem);\r\n        if (validSet) {\r\n            setsOfElem = setsOfElem.filter((d) => validSet.has(d));\r\n        }\r\n        const c = getOrCreateCombination(setsOfElem);\r\n        c.elems.push(elem);\r\n        c.cardinality++;\r\n    });\r\n    const finalize = () => {\r\n        return {\r\n            sets,\r\n            combinations: postprocessCombinations(sets, cs, {\r\n                order: options.combinationOrder,\r\n                limit: options.combinationLimit,\r\n            }),\r\n        };\r\n    };\r\n    if (type === 'distinctIntersection') {\r\n        return finalize();\r\n    }\r\n    const children = createTree(byDegree, getOrCreateCombination);\r\n    function visit(node, visited, agg) {\r\n        var _a;\r\n        if (visited.has(node)) {\r\n            return;\r\n        }\r\n        visited.add(node);\r\n        if (node.elems.length < 1000) {\r\n            agg[0].push(...node.elems);\r\n        }\r\n        else {\r\n            agg.push(node.elems);\r\n        }\r\n        ((_a = children.get(node)) !== null && _a !== void 0 ? _a : []).forEach((child) => visit(child, visited, agg));\r\n    }\r\n    byDegree.slice(1).forEach((level) => {\r\n        level.forEach((node) => {\r\n            var _a;\r\n            const visited = new Set();\r\n            const agg = [node.elems];\r\n            ((_a = children.get(node)) !== null && _a !== void 0 ? _a : []).forEach((child) => {\r\n                visit(child, visited, agg);\r\n            });\r\n            const elems = agg.length === 1 ? agg[0] : agg.flat();\r\n            Object.assign(node, { elems, cardinality: elems.length });\r\n        });\r\n    });\r\n    return finalize();\r\n}\n\nfunction toKey(s) {\r\n    return `${s.name}:${s.type}#${s.cardinality}`;\r\n}\n\nfunction isUniverse(s) {\r\n    return s.sets.size === 0;\r\n}\r\nfunction common(a, b, toKey$1 = toKey) {\r\n    const r = {\r\n        done: null,\r\n        aKey: '',\r\n        bKey: '',\r\n        aIsSet: false,\r\n        bIsSet: false,\r\n        toKey: toKey$1,\r\n    };\r\n    if (a === b) {\r\n        r.done = a.cardinality;\r\n        return r;\r\n    }\r\n    if (a.cardinality === 0 || b.cardinality === 0) {\r\n        r.done = 0;\r\n        return r;\r\n    }\r\n    r.aKey = toKey$1(a);\r\n    r.bKey = toKey$1(b);\r\n    if (r.aKey === r.bKey) {\r\n        r.done = a.cardinality;\r\n        return r;\r\n    }\r\n    r.aIsSet = isSet(a);\r\n    r.bIsSet = isSet(b);\r\n    if ((!r.aIsSet && isUniverse(a)) || (!r.bIsSet && isUniverse(b))) {\r\n        r.done = 0;\r\n        return r;\r\n    }\r\n    return r;\r\n}\r\nfunction aInB(b, r) {\r\n    if (r.bIsSet || !r.aIsSet) {\r\n        return false;\r\n    }\r\n    return Array.from(b.sets)\r\n        .map(r.toKey)\r\n        .includes(r.aKey);\r\n}\r\nfunction bInA(a, r) {\r\n    if (!r.bIsSet || r.aIsSet) {\r\n        return false;\r\n    }\r\n    return Array.from(a.sets)\r\n        .map(r.toKey)\r\n        .includes(r.bKey);\r\n}\r\nfunction keyedCombinations(combinations, toKey$1 = toKey) {\r\n    return combinations.map((c) => {\r\n        const s = Array.from(c.sets).map(toKey$1).sort();\r\n        return {\r\n            key: s.join('&'),\r\n            s,\r\n            sets: new Set(s),\r\n            degree: c.degree,\r\n            cardinality: c.cardinality,\r\n        };\r\n    });\r\n}\r\nfunction combinedKey(a, b, r) {\r\n    const sets = new Set();\r\n    if (r.aIsSet) {\r\n        sets.add(r.aKey);\r\n    }\r\n    else {\r\n        for (const s of Array.from(a.sets)) {\r\n            sets.add(r.toKey(s));\r\n        }\r\n    }\r\n    if (r.bIsSet) {\r\n        sets.add(r.bKey);\r\n    }\r\n    else {\r\n        for (const s of Array.from(b.sets)) {\r\n            sets.add(r.toKey(s));\r\n        }\r\n    }\r\n    return Array.from(sets).sort().join('&');\r\n}\r\nfunction generateDistinctOverlapFunction(combinations, fallback, toKey$1 = toKey) {\r\n    const combinationsBySet = new Map();\r\n    for (const c of keyedCombinations(combinations, toKey$1)) {\r\n        for (const s of c.s) {\r\n            if (combinationsBySet.has(s)) {\r\n                combinationsBySet.get(s).push(c);\r\n            }\r\n            else {\r\n                combinationsBySet.set(s, [c]);\r\n            }\r\n        }\r\n    }\r\n    return (a, b) => {\r\n        const r = common(a, b, toKey$1);\r\n        if (r.done != null) {\r\n            return r.done;\r\n        }\r\n        if (!r.aIsSet && !r.bIsSet) {\r\n            return 0;\r\n        }\r\n        if (r.aIsSet && !r.bIsSet) {\r\n            return aInB(b, r) ? b.cardinality : 0;\r\n        }\r\n        if (!r.aIsSet && r.bIsSet) {\r\n            return bInA(a, r) ? a.cardinality : 0;\r\n        }\r\n        const hasA = combinationsBySet.get(r.aKey);\r\n        const hasB = combinationsBySet.get(r.bKey);\r\n        if (!hasA || !hasB) {\r\n            return fallback(a, b);\r\n        }\r\n        if (hasA.length < hasB.length) {\r\n            return hasA.reduce((acc, c) => acc + (c.sets.has(r.bKey) ? c.cardinality : 0), 0);\r\n        }\r\n        return hasB.reduce((acc, c) => acc + (c.sets.has(r.aKey) ? c.cardinality : 0), 0);\r\n    };\r\n}\r\nfunction generateIntersectionOverlapFunction(combinations, fallback, toKey$1 = toKey) {\r\n    const combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map((d) => [d.key, d.cardinality]));\r\n    return (a, b) => {\r\n        const r = common(a, b, toKey$1);\r\n        if (r.done != null) {\r\n            return r.done;\r\n        }\r\n        if (r.aIsSet && !r.bIsSet && aInB(b, r)) {\r\n            return b.cardinality;\r\n        }\r\n        if (!r.aIsSet && r.bIsSet && bInA(a, r)) {\r\n            return a.cardinality;\r\n        }\r\n        const key = combinedKey(a, b, r);\r\n        if (!combinationsByKey.has(key)) {\r\n            return fallback(a, b);\r\n        }\r\n        return combinationsByKey.get(key);\r\n    };\r\n}\r\nfunction generateUnionOverlapFunction(combinations, fallback, toKey$1 = toKey) {\r\n    const combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map((d) => [d.key, d.cardinality]));\r\n    return (a, b) => {\r\n        const r = common(a, b, toKey$1);\r\n        if (r.done != null) {\r\n            return r.done;\r\n        }\r\n        if (r.aIsSet && !r.bIsSet && aInB(b, r)) {\r\n            return a.cardinality;\r\n        }\r\n        if (!r.aIsSet && r.bIsSet && bInA(a, r)) {\r\n            return b.cardinality;\r\n        }\r\n        const key = combinedKey(a, b, r);\r\n        if (!combinationsByKey.has(key)) {\r\n            return fallback(a, b);\r\n        }\r\n        return a.cardinality + b.cardinality - combinationsByKey.get(key);\r\n    };\r\n}\r\nfunction generateOverlapFunction(combinations, fallback, toKey$1 = toKey) {\r\n    if (combinations.length === 0) {\r\n        return fallback;\r\n    }\r\n    const firstType = combinations[0].type;\r\n    if (combinations.some((s) => s.type !== firstType)) {\r\n        return fallback;\r\n    }\r\n    switch (firstType) {\r\n        case 'union':\r\n            return generateUnionOverlapFunction(combinations, fallback, toKey$1);\r\n        case 'intersection':\r\n            return generateIntersectionOverlapFunction(combinations, fallback, toKey$1);\r\n        case 'distinctIntersection':\r\n            return generateDistinctOverlapFunction(combinations, fallback, toKey$1);\r\n    }\r\n    return fallback;\r\n}\n\nfunction compressLine(line) {\r\n    if (line.length === 0) {\r\n        return '';\r\n    }\r\n    const r = [];\r\n    let start = line[0];\r\n    let len = 1;\r\n    for (let i = 1; i < line.length; i++) {\r\n        const v = line[i];\r\n        if (v === start) {\r\n            len++;\r\n        }\r\n        else {\r\n            if (len > 1) {\r\n                r.push(`${start}=${len - 1}`);\r\n            }\r\n            else if (start === 0) {\r\n                r.push('');\r\n            }\r\n            else {\r\n                r.push(start.toString());\r\n            }\r\n            start = v;\r\n            len = 1;\r\n        }\r\n    }\r\n    if (len > 1) {\r\n        r.push(`${start}=${len}`);\r\n    }\r\n    else if (start === 0) {\r\n        r.push('');\r\n    }\r\n    else {\r\n        r.push(start.toString());\r\n    }\r\n    return r.join(',');\r\n}\r\nfunction decompressLine(line) {\r\n    if (line.length === 0) {\r\n        return [];\r\n    }\r\n    return line\r\n        .split(',')\r\n        .map((v) => {\r\n        if (v === '') {\r\n            return 0;\r\n        }\r\n        if (v.includes('=')) {\r\n            const [value, length] = v.split('=').map((v) => Number.parseInt(v, 10));\r\n            return Array(length + 1).fill(value);\r\n        }\r\n        return Number.parseInt(v, 10);\r\n    })\r\n        .flat();\r\n}\r\nfunction compressMatrix(matrix) {\r\n    if (matrix.length === 0) {\r\n        return '';\r\n    }\r\n    const rows = matrix.length;\r\n    const flat = matrix.flat();\r\n    return `${rows};${compressLine(flat)}`;\r\n}\r\nfunction decompressMatrix(matrix) {\r\n    if (matrix.length === 0) {\r\n        return [];\r\n    }\r\n    const [rowsInfo, data] = matrix.split(';');\r\n    const rows = Number.parseInt(rowsInfo, 10);\r\n    const values = decompressLine(data);\r\n    const r = [];\r\n    let acc = 0;\r\n    for (let i = rows; i > 0; i--) {\r\n        r.push(values.slice(acc, acc + i));\r\n        acc += i;\r\n    }\r\n    return r;\r\n}\r\nfunction generateOverlapLookup(sets, combinations, { toElemKey, what = 'intersection', compress = 'auto' } = {}) {\r\n    const data = sets.concat(combinations);\r\n    function overlapF(set) {\r\n        if (set.overlap) {\r\n            return set.overlap;\r\n        }\r\n        const f = setOverlapFactory(set.elems, toElemKey);\r\n        return (v) => {\r\n            if (v.overlap) {\r\n                return v.overlap(set);\r\n            }\r\n            return f(v.elems)[what];\r\n        };\r\n    }\r\n    const matrix = data.map((set, i) => {\r\n        const overlap = overlapF(set);\r\n        const r = [];\r\n        for (let j = i + 1; j < data.length; j++) {\r\n            r.push(overlap(data[j]));\r\n        }\r\n        return r;\r\n    });\r\n    matrix.pop();\r\n    if (compress === 'no') {\r\n        return matrix;\r\n    }\r\n    const compressed = compressMatrix(matrix);\r\n    if (compress === 'yes') {\r\n        return compressed;\r\n    }\r\n    const encodedLength = JSON.stringify(matrix).length;\r\n    const compressedLength = compressed.length + 2;\r\n    return compressedLength < encodedLength * 0.6 ? compressed : matrix;\r\n}\r\nfunction generateOverlapLookupFunction(matrix, sets, combinations, toKey$1 = toKey) {\r\n    const lookup = typeof matrix == 'string' ? decompressMatrix(matrix) : matrix;\r\n    const setIndex = new Map(sets.map((set, i) => [toKey$1(set), i]));\r\n    const combinationIndex = new Map(combinations.map((set, i) => [toKey$1(set), i + sets.length]));\r\n    const compute = (a, b) => {\r\n        if (a === b) {\r\n            return a.cardinality;\r\n        }\r\n        const aKey = toKey$1(a);\r\n        const bKey = toKey$1(b);\r\n        const aIndex = setIndex.has(aKey) ? setIndex.get(aKey) : combinationIndex.get(aKey);\r\n        const bIndex = setIndex.has(bKey) ? setIndex.get(bKey) : combinationIndex.get(bKey);\r\n        if (aIndex === bIndex) {\r\n            return a.cardinality;\r\n        }\r\n        const row = Math.min(aIndex, bIndex);\r\n        const col = Math.max(aIndex, bIndex) - row - 1;\r\n        if (row < 0 || row >= lookup.length || col < 0 || col >= lookup[row].length) {\r\n            return 0;\r\n        }\r\n        return lookup[row][col];\r\n    };\r\n    return {\r\n        setIndex,\r\n        compute,\r\n        combinationIndex,\r\n    };\r\n}\n\nconst bandScale = (domain, size, padding) => {\r\n    const blocks = domain.length + padding;\r\n    const step = size / Math.max(1, blocks);\r\n    const start = size - step * domain.length;\r\n    const lookup = new Map(domain.map((d, i) => [d, i]));\r\n    const bandwidth = step / (1 + padding);\r\n    const scale = (v) => {\r\n        const index = lookup.get(v);\r\n        if (index == null) {\r\n            return undefined;\r\n        }\r\n        return start + step * index;\r\n    };\r\n    scale.bandwidth = () => bandwidth;\r\n    return scale;\r\n};\n\nfunction hasOverlap(positions, heights, stride = 1) {\r\n    for (let i = 0; i < positions.length - stride; i += stride) {\r\n        const pos_i = positions[i];\r\n        const pos_n = positions[i + 1];\r\n        if (pos_i < pos_n) {\r\n            const right = pos_i + heights[i] / 2;\r\n            const left = pos_n - heights[i + 1] / 2;\r\n            if (right > left) {\r\n                return true;\r\n            }\r\n        }\r\n        else {\r\n            const left = pos_i - heights[i] / 2;\r\n            const right = pos_n + heights[i + 1] / 2;\r\n            if (right > left) {\r\n                return true;\r\n            }\r\n        }\r\n    }\r\n    return false;\r\n}\r\nfunction ensureLast(ticks, max, scale, heightPerTick, toStr) {\r\n    let last = ticks[ticks.length - 1];\r\n    if (!last.label) {\r\n        for (let j = ticks.length - 2; j > 0; --j) {\r\n            if (ticks[j].label) {\r\n                last = ticks[j];\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    if (last.value < max) {\r\n        const pos_l = scale(last.value);\r\n        const pos_max = scale(max);\r\n        if (pos_l < pos_max) {\r\n            const right = pos_l + heightPerTick(last.value) / 2;\r\n            const left = pos_max - heightPerTick(max) / 2;\r\n            if (right < left) {\r\n                ticks.push({ value: max, label: toStr(max) });\r\n            }\r\n        }\r\n        else {\r\n            const left = pos_l - heightPerTick(last.value) / 2;\r\n            const right = pos_max + heightPerTick(max) / 2;\r\n            if (right < left) {\r\n                ticks.push({ value: max, label: toStr(max) });\r\n            }\r\n        }\r\n    }\r\n    return ticks;\r\n}\r\nfunction genTicks(values, toStr = String, stride = 1) {\r\n    return values.map((v, i) => ({\r\n        value: v,\r\n        label: stride === 1 || i % stride === 0 ? toStr(v) : undefined,\r\n    }));\r\n}\r\nfunction checkValues(values, scale, heightPerTick, max, toStr) {\r\n    const positions = values.map((v) => scale(v));\r\n    const heights = values.map((v) => heightPerTick(v));\r\n    if (!hasOverlap(positions, heights)) {\r\n        return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);\r\n    }\r\n    if (!hasOverlap(positions, heights, 2)) {\r\n        return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);\r\n    }\r\n    return null;\r\n}\n\nfunction toStr(v) {\r\n    return v.toLocaleString();\r\n}\r\nfunction niceFactors(max, maxCount = 11) {\r\n    const digits = Math.max(0, Math.floor(Math.log10(max) - 0.5));\r\n    const factor = Math.pow(10, digits);\r\n    const factors = [1, 2, 5];\r\n    const r = factors.map((f) => f * factor);\r\n    if (digits > 0) {\r\n        r.unshift(factors[factors.length - 1] * Math.pow(10, digits - 1));\r\n    }\r\n    r.push(factors[0] * Math.pow(10, digits + 1));\r\n    const lower = Math.ceil(max / maxCount);\r\n    return r.filter((d) => d >= lower && d <= max);\r\n}\r\nfunction range(max, inc = 1) {\r\n    const values = [];\r\n    for (let v = 0; v <= max; v += inc) {\r\n        values.push(v);\r\n    }\r\n    return values;\r\n}\r\nfunction distributeTicks(max, maxCount, scale, heightPerTick) {\r\n    if (maxCount <= 0) {\r\n        return [];\r\n    }\r\n    const factors = niceFactors(max, maxCount);\r\n    for (let i = 0; i < factors.length; i++) {\r\n        const values = range(max, factors[i]);\r\n        const r = checkValues(values, scale, heightPerTick, max, toStr);\r\n        if (r) {\r\n            return r;\r\n        }\r\n    }\r\n    return genTicks([0, max], toStr);\r\n}\r\nconst linearScale = (max, range, options) => {\r\n    const size = range[1] - range[0];\r\n    const domain = max;\r\n    const scale = (v) => {\r\n        const cv = Math.max(0, Math.min(v, domain));\r\n        const n = cv / domain;\r\n        return range[0] + n * size;\r\n    };\r\n    scale.ticks = (count = 10) => {\r\n        if (options.orientation === 'vertical') {\r\n            const heightPerTick = Math.ceil(options.fontSizeHint * 1.4);\r\n            return distributeTicks(max, count + 1, scale, () => heightPerTick);\r\n        }\r\n        const widthPerChar = options.fontSizeHint / 1.4;\r\n        return distributeTicks(max, count + 1, scale, (v) => Math.ceil(toStr(v).length * widthPerChar));\r\n    };\r\n    scale.tickFormat = () => toStr;\r\n    return scale;\r\n};\n\nfunction toStr$1(v) {\r\n    const orders = ['', 'k', 'M', 'G'];\r\n    const order = Math.max(0, Math.min(Math.floor(Math.log10(v) / 3), orders.length - 1));\r\n    const vi = Math.round(v / Math.pow(10, order * 3 - 1)) / 10;\r\n    return `${vi.toLocaleString()}${orders[order]}`;\r\n}\r\nfunction range$1(max, factor) {\r\n    const values = [];\r\n    const inc = Math.pow(10, factor);\r\n    for (let v = 1; v <= max; v *= inc) {\r\n        values.push(v);\r\n    }\r\n    return values;\r\n}\r\nfunction generateInnerTicks(max, factor) {\r\n    const values = [];\r\n    const inc = 10;\r\n    for (let v = 1, i = 0; v <= max; v *= inc, i++) {\r\n        values.push({\r\n            value: v,\r\n            label: factor === 1 || i % factor === 0 ? toStr$1(v) : undefined,\r\n        });\r\n        for (let vv = v + v; vv < v * inc && vv < max; vv += v * factor) {\r\n            values.push({ value: vv });\r\n        }\r\n    }\r\n    return values;\r\n}\r\nfunction distributeTicks$1(max, maxCount, scale, heightPerTick) {\r\n    if (maxCount <= 0) {\r\n        return [];\r\n    }\r\n    for (const factor of [1, 2, 5]) {\r\n        const values = range$1(max, factor);\r\n        const r = checkValues(values, scale, heightPerTick, max, toStr$1);\r\n        if (r) {\r\n            return ensureLast(generateInnerTicks(max, factor), max, scale, heightPerTick, toStr$1);\r\n        }\r\n    }\r\n    return genTicks([0, max], toStr$1);\r\n}\r\nconst logScale = (max, range, options) => {\r\n    const size = range[1] - range[0];\r\n    const domain = max < 1 ? 1 : Math.log10(max);\r\n    const scale = (v) => {\r\n        const cv = Math.max(0, Math.min(v, domain));\r\n        const n = cv <= 1 ? 0 : Math.log10(cv) / domain;\r\n        return range[0] + n * size;\r\n    };\r\n    scale.ticks = (count = 10) => {\r\n        if (options.orientation === 'vertical') {\r\n            const heightPerTick = Math.ceil(options.fontSizeHint * 1.4);\r\n            return distributeTicks$1(max, count + 1, scale, () => heightPerTick);\r\n        }\r\n        const widthPerChar = options.fontSizeHint / 1.4;\r\n        return distributeTicks$1(max, count + 1, scale, (v) => Math.ceil(toStr$1(v).length * widthPerChar));\r\n    };\r\n    scale.tickFormat = () => toStr$1;\r\n    return scale;\r\n};\n\nfunction compressIndicesArray(arr) {\r\n    if (arr.length === 0) {\r\n        return '';\r\n    }\r\n    const encoded = [];\r\n    let startIndex = 0;\r\n    const push = (i) => {\r\n        if (i === startIndex + 1) {\r\n            encoded.push(arr[startIndex].toString());\r\n        }\r\n        else if (i === startIndex + 2 && i < 10) {\r\n            encoded.push(`${arr[startIndex]},${arr[startIndex + 1]}`);\r\n        }\r\n        else {\r\n            encoded.push(`${arr[startIndex]}+${i - startIndex - 1}`);\r\n        }\r\n        return i;\r\n    };\r\n    for (let i = 1; i < arr.length; i++) {\r\n        const expected = arr[i - 1] + 1;\r\n        const v = arr[i];\r\n        if (v !== expected) {\r\n            startIndex = push(i);\r\n            startIndex = i;\r\n        }\r\n    }\r\n    push(arr.length);\r\n    return encoded.join(',');\r\n}\r\nfunction toIndicesArray(arr, toIndex, { sortAble, compress = 'auto' } = {}) {\r\n    if (arr.length === 0) {\r\n        return [];\r\n    }\r\n    const base = arr.map((v) => toIndex(v));\r\n    if (compress === 'no') {\r\n        return base;\r\n    }\r\n    if (sortAble) {\r\n        base.sort((a, b) => a - b);\r\n    }\r\n    const encoded = compressIndicesArray(base);\r\n    const baseLength = JSON.stringify(base).length;\r\n    const encodedLength = encoded.length + 2;\r\n    if (encodedLength < baseLength * 0.6 ||\r\n        baseLength - encodedLength > 50 ||\r\n        (compress === 'yes' && encodedLength < baseLength)) {\r\n        return encoded;\r\n    }\r\n    return base;\r\n}\r\nfunction fromIndicesArray(indices, elements) {\r\n    if (typeof indices === 'string') {\r\n        if (indices.length === 0) {\r\n            return [];\r\n        }\r\n        return indices\r\n            .split(',')\r\n            .map((s) => {\r\n            if (s.includes('+')) {\r\n                const [start, length] = s.split('+').map((si) => Number.parseInt(si, 10));\r\n                return elements.slice(start, start + length + 1);\r\n            }\r\n            return elements[Number.parseInt(s, 10)];\r\n        })\r\n            .flat();\r\n    }\r\n    return indices.map((i) => elements[i]);\r\n}\n\nfunction withColor(v, s) {\r\n    if (s.color) {\r\n        v.color = s.color;\r\n    }\r\n    return v;\r\n}\n\nfunction fromDump(dump, elems, options = {}) {\r\n    const sets = dump.sets.map((set) => asSet(Object.assign(Object.assign({}, set), { elems: fromIndicesArray(set.elems, elems) })));\r\n    const gen = () => {\r\n        var _a;\r\n        return generateCombinations(sets, Object.assign({ type: 'intersection', elems, toElemKey: options.toElemKey }, (_a = dump.combinationOptions) !== null && _a !== void 0 ? _a : {}));\r\n    };\r\n    const combinations = dump.combinations\r\n        ? dump.combinations.map((c) => asCombination(Object.assign(Object.assign({}, c), { elems: fromIndicesArray(c.elems, elems) }), c.type, (v) => v.sets.map((i) => sets[i])))\r\n        : gen();\r\n    function fromSetRef(ref) {\r\n        if (ref.type === 'set') {\r\n            return sets[ref.index];\r\n        }\r\n        return combinations[ref.index];\r\n    }\r\n    return {\r\n        sets,\r\n        combinations,\r\n        selection: dump.selection\r\n            ? typeof dump.selection === 'string' || Array.isArray(dump.selection)\r\n                ? fromIndicesArray(dump.selection, elems)\r\n                : fromSetRef(dump.selection)\r\n            : undefined,\r\n        queries: dump.queries.map((query) => {\r\n            if (query.set) {\r\n                return {\r\n                    name: query.name,\r\n                    color: query.color,\r\n                    set: fromSetRef(query.set),\r\n                };\r\n            }\r\n            return {\r\n                name: query.name,\r\n                color: query.color,\r\n                elems: fromIndicesArray(query.elems, elems),\r\n            };\r\n        }),\r\n    };\r\n}\r\nfunction toDump(data, config = {}) {\r\n    var _a;\r\n    const indicesOptions = Object.assign({ sortAble: true }, config);\r\n    const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;\r\n    const bySetKey = new Map(data.sets.map((s, i) => [toKey$1(s), i]));\r\n    const byCombinationKey = new Map(data.combinations.map((s, i) => [toKey$1(s), i]));\r\n    const toSetRef = (s) => {\r\n        if (s.type === 'set') {\r\n            return {\r\n                type: s.type,\r\n                index: bySetKey.get(toKey$1(s)),\r\n            };\r\n        }\r\n        const index = byCombinationKey.get(toKey$1(s));\r\n        if (index == null || index < 0) {\r\n            return toIndicesArray(s.elems, data.toElemIndex, indicesOptions);\r\n        }\r\n        return {\r\n            type: s.type,\r\n            index,\r\n        };\r\n    };\r\n    const setLookup = data.sets.map((s, i) => ({\r\n        key: toKey$1(s),\r\n        i,\r\n    }));\r\n    return {\r\n        sets: data.sets.map((set) => withColor({\r\n            name: set.name,\r\n            cardinality: set.cardinality,\r\n            elems: toIndicesArray(set.elems, data.toElemIndex, indicesOptions),\r\n        }, set)),\r\n        combinations: config.compress === 'no'\r\n            ? data.combinations.map((c) => {\r\n                const setKeys = new Set(Array.from(c.sets).map(toKey$1));\r\n                return withColor({\r\n                    name: c.name,\r\n                    type: c.type,\r\n                    cardinality: c.cardinality,\r\n                    degree: c.degree,\r\n                    sets: setLookup.filter(({ key }) => setKeys.has(key)).map(({ i }) => i),\r\n                    elems: toIndicesArray(c.elems, data.toElemIndex, indicesOptions),\r\n                }, c);\r\n            })\r\n            : undefined,\r\n        combinationOptions: data.combinationOptions,\r\n        selection: data.selection\r\n            ? Array.isArray(data.selection)\r\n                ? toIndicesArray(data.selection, data.toElemIndex, indicesOptions)\r\n                : toSetRef(data.selection)\r\n            : undefined,\r\n        queries: data.queries.map((query) => {\r\n            const elems = isSetQuery(query)\r\n                ? toSetRef(query.set)\r\n                : toIndicesArray(Array.from(query.elems), data.toElemIndex, indicesOptions);\r\n            return {\r\n                name: query.name,\r\n                color: query.color,\r\n                set: typeof elems === 'string' || Array.isArray(elems) ? undefined : elems,\r\n                elems: typeof elems === 'string' || Array.isArray(elems) ? elems : undefined,\r\n            };\r\n        }),\r\n    };\r\n}\n\nfunction generateName$1(sets, type) {\r\n    if (sets.length === 1) {\r\n        return sets[0].name;\r\n    }\r\n    return `(${sets.map((set) => set.name).join(SET_JOINERS[type])})`;\r\n}\r\nfunction toStaticDump(data, config = {}) {\r\n    var _a;\r\n    const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;\r\n    const bySetKey = new Map(data.sets.map((s, i) => [toKey$1(s), i]));\r\n    const byCombinationKey = new Map(data.combinations.map((s, i) => [toKey$1(s), i]));\r\n    const toSelectionSetRef = (s) => {\r\n        if (isSetLike(s)) {\r\n            if (s.type === 'set') {\r\n                return {\r\n                    type: s.type,\r\n                    index: bySetKey.get(toKey$1(s)),\r\n                };\r\n            }\r\n            const index = byCombinationKey.get(toKey$1(s));\r\n            if (index != null && index >= 0) {\r\n                return {\r\n                    type: s.type,\r\n                    index,\r\n                };\r\n            }\r\n        }\r\n        const overlapF = setOverlapFactory(isSetLike(s) ? s.elems : s);\r\n        return data.sets\r\n            .map((set) => overlapF(set.elems).intersection)\r\n            .concat(data.combinations.map((set) => overlapF(set.elems).intersection));\r\n    };\r\n    const setIndex = new Map(data.sets.map((set, i) => [toKey$1(set), i]));\r\n    const overlaps = generateOverlapLookup(data.sets, data.combinations, config);\r\n    const shortNames = config.compress === 'yes';\r\n    const compressCombination = (set) => {\r\n        const partOf = Array.from(set.sets)\r\n            .map((s) => setIndex.get(toKey$1(s)))\r\n            .sort((a, b) => a - b);\r\n        const r = {\r\n            c: set.cardinality,\r\n            s: partOf.reduce((acc, i) => acc + Math.pow(2, i), 0),\r\n        };\r\n        if (set.name !==\r\n            generateName$1(partOf.map((i) => data.sets[i]), set.type)) {\r\n            r.n = set.name;\r\n        }\r\n        if (set.type !== 'intersection') {\r\n            r.type = set.type[0];\r\n        }\r\n        if (set.color) {\r\n            r.cc = set.color;\r\n        }\r\n        return r;\r\n    };\r\n    return {\r\n        sets: shortNames\r\n            ? data.sets.map((set) => ({ n: set.name, cc: set.color, c: set.cardinality }))\r\n            : data.sets.map((set) => withColor({ name: set.name, cardinality: set.cardinality }, set)),\r\n        combinations: shortNames\r\n            ? data.combinations.map(compressCombination)\r\n            : data.combinations.map((set) => withColor({\r\n                name: set.name,\r\n                cardinality: set.cardinality,\r\n                type: set.type,\r\n                sets: Array.from(set.sets)\r\n                    .map((s) => setIndex.get(toKey$1(s)))\r\n                    .sort((a, b) => a - b),\r\n            }, set)),\r\n        overlaps,\r\n        selection: data.selection ? toSelectionSetRef(data.selection) : undefined,\r\n        queries: data.queries.map((query) => {\r\n            if (isSetQuery(query)) {\r\n                const ref = toSelectionSetRef(query.set);\r\n                if (Array.isArray(ref)) {\r\n                    return {\r\n                        name: query.name,\r\n                        color: query.color,\r\n                        overlaps: ref,\r\n                    };\r\n                }\r\n                return {\r\n                    name: query.name,\r\n                    color: query.color,\r\n                    set: ref,\r\n                };\r\n            }\r\n            const overlapF = setOverlapFactory(query.elems);\r\n            const overlaps = data.sets\r\n                .map((set) => overlapF(set.elems).intersection)\r\n                .concat(data.combinations.map((set) => overlapF(set.elems).intersection));\r\n            return {\r\n                name: query.name,\r\n                color: query.color,\r\n                overlaps,\r\n            };\r\n        }),\r\n    };\r\n}\r\nfunction isCompressed(s) {\r\n    return typeof s.c === 'number';\r\n}\r\nfunction isCompressedSet(s) {\r\n    return typeof s.c === 'number';\r\n}\r\nfunction fromStaticDump(dump, config = {}) {\r\n    var _a;\r\n    const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;\r\n    let computeF = () => 0;\r\n    function withOverlap(s) {\r\n        s.overlap = (b) => computeF(s, b);\r\n        return s;\r\n    }\r\n    const sets = dump.sets.map((set) => withOverlap({\r\n        name: isCompressedSet(set) ? set.n : set.name,\r\n        cardinality: isCompressedSet(set) ? set.c : set.cardinality,\r\n        type: 'set',\r\n        elems: [],\r\n    }));\r\n    const fromBit = (v) => {\r\n        return sets.filter((_, i) => {\r\n            const position = Math.pow(2, i);\r\n            return (v & position) === position;\r\n        });\r\n    };\r\n    const combinations = dump.combinations.map((set) => {\r\n        var _a, _b;\r\n        const partOf = isCompressed(set) ? fromBit(set.s) : set.sets.map((i) => sets[i]);\r\n        const lookup = {\r\n            i: 'intersection',\r\n            u: 'union',\r\n            c: 'composite',\r\n            d: 'distinctIntersection',\r\n        };\r\n        const type = lookup[((_a = set.type) !== null && _a !== void 0 ? _a : 'i')[0]];\r\n        return withOverlap({\r\n            name: isCompressed(set) ? (_b = set.n) !== null && _b !== void 0 ? _b : generateName$1(partOf, type) : set.name,\r\n            cardinality: isCompressed(set) ? set.c : set.cardinality,\r\n            type,\r\n            degree: partOf.length,\r\n            sets: new Set(partOf),\r\n            elems: [],\r\n        });\r\n    });\r\n    const { setIndex, combinationIndex, compute } = generateOverlapLookupFunction(dump.overlaps, sets, combinations, toKey$1);\r\n    computeF = compute;\r\n    function fromSetRef(ref) {\r\n        if (ref.type === 'set') {\r\n            return sets[ref.index];\r\n        }\r\n        return combinations[ref.index];\r\n    }\r\n    function generateOverlap(lookup) {\r\n        return (v) => {\r\n            const key = toKey$1(v);\r\n            const index = setIndex.has(key) ? setIndex.get(key) : combinationIndex.get(key);\r\n            return index == null || index < 0 || index >= lookup.length ? 0 : lookup[index];\r\n        };\r\n    }\r\n    return {\r\n        sets,\r\n        combinations,\r\n        selection: dump.selection\r\n            ? Array.isArray(dump.selection)\r\n                ? generateOverlap(dump.selection)\r\n                : fromSetRef(dump.selection)\r\n            : undefined,\r\n        queries: dump.queries.map((query) => {\r\n            if (query.set) {\r\n                return {\r\n                    name: query.name,\r\n                    color: query.color,\r\n                    set: fromSetRef(query.set),\r\n                };\r\n            }\r\n            return {\r\n                name: query.name,\r\n                color: query.color,\r\n                overlap: generateOverlap(query.overlaps),\r\n            };\r\n        }),\r\n    };\r\n}\n\nexport { asCombination, asCombinations, asSet, asSets, bandScale, extractCombinations, extractFromExpression, extractSets, fromDump, fromIndicesArray, fromSetName, fromStaticDump, generateCombinations, generateDistinctOverlapFunction, generateIntersectionOverlapFunction, generateOverlapFunction, generateOverlapLookup, generateOverlapLookupFunction, generateUnionOverlapFunction, isCalcQuery, isElemQuery, isGenerateSetCombinationOptions, isSet, isSetCombination, isSetLike, isSetQuery, isUpSetQuery, linearScale, logScale, mergeColors, parseColor, queryElemOverlap, queryOverlap, setElemIntersectionFactory, setElemOverlap, setElemOverlapFactory, setOverlap, setOverlapFactory, toDump, toIndicesArray, toKey, toStaticDump };\n//# sourceMappingURL=index.js.map\n"]},"metadata":{},"sourceType":"module"}