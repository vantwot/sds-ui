{"ast":null,"code":"import _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nvar _excluded = [\"buffer\", \"update\", \"name\"];\n\nvar _bytesPerElementMap, _dec, _dec2, _class, _class2, _descriptor;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { TYPES } from '../../types';\nimport { gl } from '../renderer/gl';\nimport StyleAttribute from './StyleAttribute';\n\nfunction sleep(ms) {\n  return new Promise(function (resolve) {\n    return setTimeout(resolve, ms);\n  });\n}\n\nvar bytesPerElementMap = (_bytesPerElementMap = {}, _defineProperty(_bytesPerElementMap, gl.FLOAT, 4), _defineProperty(_bytesPerElementMap, gl.UNSIGNED_BYTE, 1), _defineProperty(_bytesPerElementMap, gl.UNSIGNED_SHORT, 2), _bytesPerElementMap);\nvar StyleAttributeService = (_dec = injectable(), _dec2 = inject(TYPES.IRendererService), _dec(_class = (_class2 = function () {\n  function StyleAttributeService() {\n    _classCallCheck(this, StyleAttributeService);\n\n    _defineProperty(this, \"attributesAndIndices\", void 0);\n\n    _initializerDefineProperty(this, \"rendererService\", _descriptor, this);\n\n    _defineProperty(this, \"attributes\", []);\n\n    _defineProperty(this, \"triangulation\", void 0);\n\n    _defineProperty(this, \"featureLayout\", {\n      sizePerElement: 0,\n      elements: []\n    });\n  }\n\n  _createClass(StyleAttributeService, [{\n    key: \"registerStyleAttribute\",\n    value: function registerStyleAttribute(options) {\n      var attributeToUpdate = this.getLayerStyleAttribute(options.name || '');\n\n      if (attributeToUpdate) {\n        attributeToUpdate.setProps(options);\n      } else {\n        attributeToUpdate = new StyleAttribute(options);\n        this.attributes.push(attributeToUpdate);\n      }\n\n      return attributeToUpdate;\n    }\n  }, {\n    key: \"updateStyleAttribute\",\n    value: function updateStyleAttribute(attributeName, options, updateOptions) {\n      var attributeToUpdate = this.getLayerStyleAttribute(attributeName);\n\n      if (!attributeToUpdate) {\n        attributeToUpdate = this.registerStyleAttribute(_objectSpread(_objectSpread({}, options), {}, {\n          name: attributeName\n        }));\n      }\n\n      var scale = options.scale;\n\n      if (scale && attributeToUpdate) {\n        attributeToUpdate.scale = scale;\n        attributeToUpdate.needRescale = true;\n        attributeToUpdate.needRemapping = true;\n        attributeToUpdate.needRegenerateVertices = true;\n\n        if (updateOptions && updateOptions.featureRange) {\n          attributeToUpdate.featureRange = updateOptions.featureRange;\n        }\n      }\n    }\n  }, {\n    key: \"getLayerStyleAttributes\",\n    value: function getLayerStyleAttributes() {\n      return this.attributes;\n    }\n  }, {\n    key: \"getLayerStyleAttribute\",\n    value: function getLayerStyleAttribute(attributeName) {\n      return this.attributes.find(function (attribute) {\n        return attribute.name === attributeName;\n      });\n    }\n  }, {\n    key: \"getLayerAttributeScale\",\n    value: function getLayerAttributeScale(name) {\n      var _attribute$scale;\n\n      var attribute = this.getLayerStyleAttribute(name);\n      var scale = attribute === null || attribute === void 0 ? void 0 : (_attribute$scale = attribute.scale) === null || _attribute$scale === void 0 ? void 0 : _attribute$scale.scalers;\n\n      if (scale && scale[0]) {\n        return scale[0].func;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"updateAttributeByFeatureRange\",\n    value: function updateAttributeByFeatureRange(attributeName, features) {\n      var startFeatureIdx = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var endFeatureIdx = arguments.length > 3 ? arguments[3] : undefined;\n      var attributeToUpdate = this.attributes.find(function (attribute) {\n        return attribute.name === attributeName;\n      });\n\n      if (attributeToUpdate && attributeToUpdate.descriptor) {\n        var descriptor = attributeToUpdate.descriptor;\n        var update = descriptor.update,\n            buffer = descriptor.buffer,\n            _descriptor$size = descriptor.size,\n            size = _descriptor$size === void 0 ? 0 : _descriptor$size;\n        var bytesPerElement = bytesPerElementMap[buffer.type || gl.FLOAT];\n\n        if (update) {\n          var _this$featureLayout = this.featureLayout,\n              elements = _this$featureLayout.elements,\n              sizePerElement = _this$featureLayout.sizePerElement;\n          var featuresToUpdate = elements.slice(startFeatureIdx, endFeatureIdx);\n\n          if (!featuresToUpdate.length) {\n            return;\n          }\n\n          var offset = featuresToUpdate[0].offset;\n          var bufferOffsetInBytes = offset * size * bytesPerElement;\n          var updatedBufferData = featuresToUpdate.map(function (_ref, attributeIdx) {\n            var featureIdx = _ref.featureIdx,\n                vertices = _ref.vertices,\n                normals = _ref.normals;\n            var verticesNumForCurrentFeature = vertices.length / sizePerElement;\n            var featureData = [];\n\n            for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {\n              var normal = normals ? normals.slice(vertexIdx * 3, vertexIdx * 3 + 3) : [];\n              featureData.push.apply(featureData, _toConsumableArray(update(features[featureIdx], featureIdx, vertices.slice(vertexIdx * sizePerElement, vertexIdx * sizePerElement + sizePerElement), attributeIdx, normal)));\n            }\n\n            return featureData;\n          }).reduce(function (prev, cur) {\n            prev.push.apply(prev, _toConsumableArray(cur));\n            return prev;\n          }, []);\n          attributeToUpdate.vertexAttribute.updateBuffer({\n            data: updatedBufferData,\n            offset: bufferOffsetInBytes\n          });\n        }\n      }\n    }\n  }, {\n    key: \"createAttributesAndIndices\",\n    value: function createAttributesAndIndices(features, triangulation, segmentNumber) {\n      var _this = this;\n\n      this.featureLayout = {\n        sizePerElement: 0,\n        elements: []\n      };\n\n      if (triangulation) {\n        this.triangulation = triangulation;\n      }\n\n      var descriptors = this.attributes.map(function (attr) {\n        attr.resetDescriptor();\n        return attr.descriptor;\n      });\n      var verticesNum = 0;\n      var vertices = [];\n      var indices = [];\n      var normals = [];\n      var size = 3;\n      features.forEach(function (feature, featureIdx) {\n        var _this$triangulation = _this.triangulation(feature, segmentNumber),\n            indicesForCurrentFeature = _this$triangulation.indices,\n            verticesForCurrentFeature = _this$triangulation.vertices,\n            normalsForCurrentFeature = _this$triangulation.normals,\n            vertexSize = _this$triangulation.size;\n\n        indicesForCurrentFeature.forEach(function (i) {\n          indices.push(i + verticesNum);\n        });\n        size = vertexSize;\n        var verticesNumForCurrentFeature = verticesForCurrentFeature.length / vertexSize;\n        _this.featureLayout.sizePerElement = size;\n\n        _this.featureLayout.elements.push({\n          featureIdx: featureIdx,\n          vertices: verticesForCurrentFeature,\n          normals: normalsForCurrentFeature,\n          offset: verticesNum\n        });\n\n        verticesNum += verticesNumForCurrentFeature;\n\n        var _loop = function _loop(vertexIdx) {\n          var normal = (normalsForCurrentFeature === null || normalsForCurrentFeature === void 0 ? void 0 : normalsForCurrentFeature.slice(vertexIdx * 3, vertexIdx * 3 + 3)) || [];\n          var vertice = verticesForCurrentFeature.slice(vertexIdx * vertexSize, vertexIdx * vertexSize + vertexSize);\n          descriptors.forEach(function (descriptor, attributeIdx) {\n            if (descriptor && descriptor.update) {\n              var _ref2;\n\n              (_ref2 = descriptor.buffer.data).push.apply(_ref2, _toConsumableArray(descriptor.update(feature, featureIdx, vertice, vertexIdx, normal)));\n            }\n          });\n        };\n\n        for (var vertexIdx = 0; vertexIdx < verticesNumForCurrentFeature; vertexIdx++) {\n          _loop(vertexIdx);\n        }\n      });\n      var _this$rendererService = this.rendererService,\n          createAttribute = _this$rendererService.createAttribute,\n          createBuffer = _this$rendererService.createBuffer,\n          createElements = _this$rendererService.createElements;\n      var attributes = {};\n      descriptors.forEach(function (descriptor, attributeIdx) {\n        if (descriptor) {\n          var buffer = descriptor.buffer,\n              update = descriptor.update,\n              name = descriptor.name,\n              rest = _objectWithoutProperties(descriptor, _excluded);\n\n          var vertexAttribute = createAttribute(_objectSpread({\n            buffer: createBuffer(buffer)\n          }, rest));\n          attributes[descriptor.name || ''] = vertexAttribute;\n          _this.attributes[attributeIdx].vertexAttribute = vertexAttribute;\n        }\n      });\n      var elements = createElements({\n        data: indices,\n        type: gl.UNSIGNED_INT,\n        count: indices.length\n      });\n      this.attributesAndIndices = {\n        attributes: attributes,\n        elements: elements\n      };\n      return this.attributesAndIndices;\n    }\n  }, {\n    key: \"clearAllAttributes\",\n    value: function clearAllAttributes() {\n      var _this$attributesAndIn;\n\n      this.attributes.forEach(function (attribute) {\n        if (attribute.vertexAttribute) {\n          attribute.vertexAttribute.destroy();\n        }\n      });\n      (_this$attributesAndIn = this.attributesAndIndices) === null || _this$attributesAndIn === void 0 ? void 0 : _this$attributesAndIn.elements.destroy();\n      this.attributes = [];\n    }\n  }]);\n\n  return StyleAttributeService;\n}(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"rendererService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);\nexport { StyleAttributeService as default };","map":{"version":3,"sources":["../../../src/services/layer/StyleAttributeService.ts"],"names":["setTimeout","bytesPerElementMap","gl","injectable","StyleAttributeService","inject","TYPES","sizePerElement","elements","attributeToUpdate","options","name","attributeName","scale","updateOptions","attribute","startFeatureIdx","endFeatureIdx","descriptor","update","buffer","size","bytesPerElement","featuresToUpdate","offset","bufferOffsetInBytes","updatedBufferData","featureIdx","vertices","normals","verticesNumForCurrentFeature","featureData","vertexIdx","normal","features","prev","data","descriptors","attr","verticesNum","indices","indicesForCurrentFeature","verticesForCurrentFeature","normalsForCurrentFeature","vertexSize","i","vertice","createAttribute","createBuffer","createElements","attributes","rest","vertexAttribute","type","count","length"],"mappings":"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","sourcesContent":["import { inject, injectable, optional } from 'inversify';\nimport 'reflect-metadata';\nimport { TYPES } from '../../types';\nimport { gl } from '../renderer/gl';\nimport { IAttribute } from '../renderer/IAttribute';\nimport { IElements } from '../renderer/IElements';\nimport { IRendererService } from '../renderer/IRendererService';\nimport { IParseDataItem } from '../source/ISourceService';\nimport { ILayer } from './ILayerService';\nimport {\n  IAttributeScale,\n  IEncodeFeature,\n  IStyleAttribute,\n  IStyleAttributeInitializationOptions,\n  IStyleAttributeService,\n  IStyleAttributeUpdateOptions,\n  IVertexAttributeDescriptor,\n  Triangulation,\n} from './IStyleAttributeService';\nimport StyleAttribute from './StyleAttribute';\n\nfunction sleep(ms: number) {\n  return new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nconst bytesPerElementMap = {\n  [gl.FLOAT]: 4,\n  [gl.UNSIGNED_BYTE]: 1,\n  [gl.UNSIGNED_SHORT]: 2,\n};\n\n/**\n * 每个 Layer 都拥有一个，用于管理样式属性的注册和更新\n */\n@injectable()\nexport default class StyleAttributeService implements IStyleAttributeService {\n  public attributesAndIndices: {\n    attributes: {\n      [attributeName: string]: IAttribute;\n    };\n    elements: IElements;\n  };\n  @inject(TYPES.IRendererService)\n  private readonly rendererService: IRendererService;\n\n  private attributes: IStyleAttribute[] = [];\n  private triangulation: Triangulation;\n\n  private featureLayout: {\n    sizePerElement: number;\n    elements: Array<{\n      featureIdx: number;\n      vertices: number[];\n      normals: number[];\n      offset: number;\n    }>;\n  } = {\n    sizePerElement: 0,\n    elements: [],\n  };\n  public registerStyleAttribute(\n    options: Partial<IStyleAttributeInitializationOptions>,\n  ) {\n    let attributeToUpdate = this.getLayerStyleAttribute(options.name || '');\n    if (attributeToUpdate) {\n      attributeToUpdate.setProps(options);\n    } else {\n      attributeToUpdate = new StyleAttribute(options);\n      this.attributes.push(attributeToUpdate);\n    }\n    return attributeToUpdate;\n  }\n\n  public updateStyleAttribute(\n    attributeName: string,\n    options: Partial<IStyleAttributeInitializationOptions>,\n    updateOptions?: Partial<IStyleAttributeUpdateOptions>,\n  ) {\n    let attributeToUpdate = this.getLayerStyleAttribute(attributeName);\n    if (!attributeToUpdate) {\n      attributeToUpdate = this.registerStyleAttribute({\n        ...options,\n        name: attributeName,\n      });\n    }\n    const { scale } = options;\n    if (scale && attributeToUpdate) {\n      // TODO: 需要比较新旧值确定是否需要 rescale\n      // 需要重新 scale，肯定也需要重新进行数据映射\n      attributeToUpdate.scale = scale;\n      attributeToUpdate.needRescale = true;\n      attributeToUpdate.needRemapping = true;\n      attributeToUpdate.needRegenerateVertices = true;\n      if (updateOptions && updateOptions.featureRange) {\n        attributeToUpdate.featureRange = updateOptions.featureRange;\n      }\n    }\n  }\n\n  public getLayerStyleAttributes(): IStyleAttribute[] | undefined {\n    return this.attributes;\n  }\n\n  public getLayerStyleAttribute(\n    attributeName: string,\n  ): IStyleAttribute | undefined {\n    return this.attributes.find(\n      (attribute) => attribute.name === attributeName,\n    );\n  }\n\n  public getLayerAttributeScale(name: string) {\n    const attribute = this.getLayerStyleAttribute(name);\n    const scale = attribute?.scale?.scalers as IAttributeScale[];\n    if (scale && scale[0]) {\n      return scale[0].func;\n    }\n    return null;\n  }\n\n  public updateAttributeByFeatureRange(\n    attributeName: string,\n    features: IEncodeFeature[],\n    startFeatureIdx: number = 0,\n    endFeatureIdx?: number,\n  ) {\n    const attributeToUpdate = this.attributes.find(\n      (attribute) => attribute.name === attributeName,\n    );\n    if (attributeToUpdate && attributeToUpdate.descriptor) {\n      const { descriptor } = attributeToUpdate;\n      const { update, buffer, size = 0 } = descriptor;\n      const bytesPerElement = bytesPerElementMap[buffer.type || gl.FLOAT];\n      if (update) {\n        const { elements, sizePerElement } = this.featureLayout;\n        // 截取待更新的 feature 范围\n        const featuresToUpdate = elements.slice(startFeatureIdx, endFeatureIdx);\n        // [n, n] 中断更新\n        if (!featuresToUpdate.length) {\n          return;\n        }\n        const { offset } = featuresToUpdate[0];\n        // 以 byte 为单位计算 buffer 中的偏移\n        const bufferOffsetInBytes = offset * size * bytesPerElement;\n        const updatedBufferData = featuresToUpdate\n          .map(({ featureIdx, vertices, normals }, attributeIdx) => {\n            const verticesNumForCurrentFeature =\n              vertices.length / sizePerElement;\n            const featureData: number[] = [];\n            for (\n              let vertexIdx = 0;\n              vertexIdx < verticesNumForCurrentFeature;\n              vertexIdx++\n            ) {\n              const normal = normals\n                ? normals!.slice(vertexIdx * 3, vertexIdx * 3 + 3)\n                : [];\n              featureData.push(\n                ...update(\n                  features[featureIdx],\n                  featureIdx,\n                  vertices.slice(\n                    vertexIdx * sizePerElement,\n                    vertexIdx * sizePerElement + sizePerElement,\n                  ),\n                  attributeIdx,\n                  normal,\n                ),\n              );\n            }\n            return featureData;\n          })\n          .reduce((prev, cur) => {\n            prev.push(...cur);\n            return prev;\n          }, []);\n\n        // 更新底层 IAttribute 中包含的 IBuffer，使用 subdata\n        attributeToUpdate.vertexAttribute.updateBuffer({\n          data: updatedBufferData,\n          offset: bufferOffsetInBytes,\n        });\n      }\n    }\n  }\n\n  public createAttributesAndIndices(\n    features: IEncodeFeature[],\n    triangulation: Triangulation,\n    segmentNumber: number,\n  ): {\n    attributes: {\n      [attributeName: string]: IAttribute;\n    };\n    elements: IElements;\n  } {\n    // 每次创建的初始化化 LayerOut\n    this.featureLayout = {\n      sizePerElement: 0,\n      elements: [],\n    };\n    if (triangulation) {\n      this.triangulation = triangulation;\n    }\n    const descriptors = this.attributes.map((attr) => {\n      attr.resetDescriptor();\n      return attr.descriptor;\n    });\n    let verticesNum = 0;\n    const vertices: number[] = [];\n    const indices: number[] = [];\n    const normals: number[] = [];\n    let size = 3;\n    features.forEach((feature, featureIdx) => {\n      // 逐 feature 进行三角化\n      const {\n        indices: indicesForCurrentFeature,\n        vertices: verticesForCurrentFeature,\n        normals: normalsForCurrentFeature,\n        size: vertexSize,\n      } = this.triangulation(feature, segmentNumber);\n      indicesForCurrentFeature.forEach((i) => {\n        indices.push(i + verticesNum);\n      });\n      size = vertexSize;\n      const verticesNumForCurrentFeature =\n        verticesForCurrentFeature.length / vertexSize;\n\n      // 记录三角化结果，用于后续精确更新指定 feature\n      this.featureLayout.sizePerElement = size;\n      this.featureLayout.elements.push({\n        featureIdx,\n        vertices: verticesForCurrentFeature,\n        normals: normalsForCurrentFeature as number[],\n        offset: verticesNum,\n      });\n\n      verticesNum += verticesNumForCurrentFeature;\n      // 根据 position 顶点生成其他顶点数据\n      for (\n        let vertexIdx = 0;\n        vertexIdx < verticesNumForCurrentFeature;\n        vertexIdx++\n      ) {\n        const normal =\n          normalsForCurrentFeature?.slice(vertexIdx * 3, vertexIdx * 3 + 3) ||\n          [];\n        const vertice = verticesForCurrentFeature.slice(\n          vertexIdx * vertexSize,\n          vertexIdx * vertexSize + vertexSize,\n        );\n        descriptors.forEach((descriptor, attributeIdx) => {\n          if (descriptor && descriptor.update) {\n            (descriptor.buffer.data as number[]).push(\n              ...descriptor.update(\n                feature,\n                featureIdx,\n                vertice,\n                vertexIdx, // 当前顶点所在feature索引\n                normal,\n                // TODO: 传入顶点索引 vertexIdx\n              ),\n            );\n          } // end if\n        }); // end for each\n      } // end for\n    }); // end features for Each\n    const {\n      createAttribute,\n      createBuffer,\n      createElements,\n    } = this.rendererService;\n\n    const attributes: {\n      [attributeName: string]: IAttribute;\n    } = {};\n    descriptors.forEach((descriptor, attributeIdx) => {\n      if (descriptor) {\n        // IAttribute 参数透传\n        const { buffer, update, name, ...rest } = descriptor;\n\n        const vertexAttribute = createAttribute({\n          // IBuffer 参数透传\n          buffer: createBuffer(buffer),\n          ...rest,\n        });\n        attributes[descriptor.name || ''] = vertexAttribute;\n\n        // 在 StyleAttribute 上保存对 VertexAttribute 的引用\n        this.attributes[attributeIdx].vertexAttribute = vertexAttribute;\n      }\n    });\n\n    const elements = createElements({\n      data: indices,\n      type: gl.UNSIGNED_INT,\n      count: indices.length,\n    });\n    this.attributesAndIndices = {\n      attributes,\n      elements,\n    };\n    return this.attributesAndIndices;\n  }\n  public clearAllAttributes() {\n    // 销毁关联的 vertex attribute buffer objects\n    this.attributes.forEach((attribute) => {\n      if (attribute.vertexAttribute) {\n        attribute.vertexAttribute.destroy();\n      }\n    });\n\n    this.attributesAndIndices?.elements.destroy();\n    this.attributes = [];\n  }\n}\n"]},"metadata":{},"sourceType":"module"}