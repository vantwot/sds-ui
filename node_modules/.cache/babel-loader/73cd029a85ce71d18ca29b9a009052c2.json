{"ast":null,"code":"import { Angle, Point, Line, Rectangle, Polyline } from '../../geometry';\nimport { createSvgElement } from './elem';\nvar svgDocument = createSvgElement('svg');\nvar transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi;\nvar transformSeparatorRegex = /[ ,]+/;\nvar transformationListRegex = /^(\\w+)\\((.*)\\)/;\n/**\n * Returns a SVG point object initialized with the `x` and `y` coordinates.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint\n */\n\nexport function createSVGPoint(x, y) {\n  var p = svgDocument.createSVGPoint();\n  p.x = x;\n  p.y = y;\n  return p;\n}\n/**\n * Returns the SVG transformation matrix initialized with the given matrix.\n *\n * The given matrix is an object of the form:\n * {\n *   a: number\n *   b: number\n *   c: number\n *   d: number\n *   e: number\n *   f: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\n\nexport function createSVGMatrix(matrix) {\n  var mat = svgDocument.createSVGMatrix();\n\n  if (matrix != null) {\n    var source = matrix;\n    var target = mat; // eslint-disable-next-line\n\n    for (var key in source) {\n      target[key] = source[key];\n    }\n  }\n\n  return mat;\n}\n/**\n * Returns a SVG transform object.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform\n */\n\nexport function createSVGTransform(matrix) {\n  if (matrix != null) {\n    if (!(matrix instanceof DOMMatrix)) {\n      matrix = createSVGMatrix(matrix); // eslint-disable-line\n    }\n\n    return svgDocument.createSVGTransformFromMatrix(matrix);\n  }\n\n  return svgDocument.createSVGTransform();\n}\n/**\n * Returns the SVG transformation matrix built from the `transformString`.\n *\n * E.g. 'translate(10,10) scale(2,2)' will result in matrix:\n * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`\n */\n\nexport function transformStringToMatrix(transform) {\n  var mat = createSVGMatrix();\n  var matches = transform != null && transform.match(transformRegex);\n\n  if (!matches) {\n    return mat;\n  }\n\n  for (var i = 0, n = matches.length; i < n; i += 1) {\n    var transformationString = matches[i];\n    var transformationMatch = transformationString.match(transformationListRegex);\n\n    if (transformationMatch) {\n      var sx = void 0;\n      var sy = void 0;\n      var tx = void 0;\n      var ty = void 0;\n      var angle = void 0;\n      var ctm = createSVGMatrix();\n      var args = transformationMatch[2].split(transformSeparatorRegex);\n\n      switch (transformationMatch[1].toLowerCase()) {\n        case 'scale':\n          sx = parseFloat(args[0]);\n          sy = args[1] === undefined ? sx : parseFloat(args[1]);\n          ctm = ctm.scaleNonUniform(sx, sy);\n          break;\n\n        case 'translate':\n          tx = parseFloat(args[0]);\n          ty = parseFloat(args[1]);\n          ctm = ctm.translate(tx, ty);\n          break;\n\n        case 'rotate':\n          angle = parseFloat(args[0]);\n          tx = parseFloat(args[1]) || 0;\n          ty = parseFloat(args[2]) || 0;\n\n          if (tx !== 0 || ty !== 0) {\n            ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n          } else {\n            ctm = ctm.rotate(angle);\n          }\n\n          break;\n\n        case 'skewx':\n          angle = parseFloat(args[0]);\n          ctm = ctm.skewX(angle);\n          break;\n\n        case 'skewy':\n          angle = parseFloat(args[0]);\n          ctm = ctm.skewY(angle);\n          break;\n\n        case 'matrix':\n          ctm.a = parseFloat(args[0]);\n          ctm.b = parseFloat(args[1]);\n          ctm.c = parseFloat(args[2]);\n          ctm.d = parseFloat(args[3]);\n          ctm.e = parseFloat(args[4]);\n          ctm.f = parseFloat(args[5]);\n          break;\n\n        default:\n          continue;\n      }\n\n      mat = mat.multiply(ctm);\n    }\n  }\n\n  return mat;\n}\nexport function matrixToTransformString(matrix) {\n  var m = matrix || {};\n  var a = m.a != null ? m.a : 1;\n  var b = m.b != null ? m.b : 0;\n  var c = m.c != null ? m.c : 0;\n  var d = m.d != null ? m.d : 1;\n  var e = m.e != null ? m.e : 0;\n  var f = m.f != null ? m.f : 0;\n  return \"matrix(\".concat(a, \",\").concat(b, \",\").concat(c, \",\").concat(d, \",\").concat(e, \",\").concat(f, \")\");\n}\nexport function parseTransformString(transform) {\n  var translation;\n  var rotation;\n  var scale;\n\n  if (transform) {\n    var separator = transformSeparatorRegex; // Allow reading transform string with a single matrix\n\n    if (transform.trim().indexOf('matrix') >= 0) {\n      var matrix = transformStringToMatrix(transform);\n      var decomposedMatrix = decomposeMatrix(matrix);\n      translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n      rotation = [decomposedMatrix.rotation];\n      scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n      var transformations = [];\n\n      if (translation[0] !== 0 || translation[1] !== 0) {\n        transformations.push(\"translate(\".concat(translation.join(','), \")\"));\n      }\n\n      if (scale[0] !== 1 || scale[1] !== 1) {\n        transformations.push(\"scale(\".concat(scale.join(','), \")\"));\n      }\n\n      if (rotation[0] !== 0) {\n        transformations.push(\"rotate(\".concat(rotation[0], \")\"));\n      }\n\n      transform = transformations.join(' '); // eslint-disable-line\n    } else {\n      var translateMatch = transform.match(/translate\\((.*?)\\)/);\n\n      if (translateMatch) {\n        translation = translateMatch[1].split(separator);\n      }\n\n      var rotateMatch = transform.match(/rotate\\((.*?)\\)/);\n\n      if (rotateMatch) {\n        rotation = rotateMatch[1].split(separator);\n      }\n\n      var scaleMatch = transform.match(/scale\\((.*?)\\)/);\n\n      if (scaleMatch) {\n        scale = scaleMatch[1].split(separator);\n      }\n    }\n  }\n\n  var sx = scale && scale[0] ? parseFloat(scale[0]) : 1;\n  return {\n    raw: transform || '',\n    translation: {\n      tx: translation && translation[0] ? parseInt(translation[0], 10) : 0,\n      ty: translation && translation[1] ? parseInt(translation[1], 10) : 0\n    },\n    rotation: {\n      angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,\n      cx: rotation && rotation[1] ? parseInt(rotation[1], 10) : undefined,\n      cy: rotation && rotation[2] ? parseInt(rotation[2], 10) : undefined\n    },\n    scale: {\n      sx: sx,\n      sy: scale && scale[1] ? parseFloat(scale[1]) : sx\n    }\n  };\n}\n\nfunction deltaTransformPoint(matrix, point) {\n  var dx = point.x * matrix.a + point.y * matrix.c + 0;\n  var dy = point.x * matrix.b + point.y * matrix.d + 0;\n  return {\n    x: dx,\n    y: dy\n  };\n}\n/**\n * Decomposes the SVG transformation matrix into separate transformations.\n *\n * Returns an object of the form:\n * {\n *   translateX: number\n *   translateY: number\n *   scaleX: number\n *   scaleY: number\n *   skewX: number\n *   skewY: number\n *   rotation: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\n\n\nexport function decomposeMatrix(matrix) {\n  // @see https://gist.github.com/2052247\n  var px = deltaTransformPoint(matrix, {\n    x: 0,\n    y: 1\n  });\n  var py = deltaTransformPoint(matrix, {\n    x: 1,\n    y: 0\n  });\n  var skewX = 180 / Math.PI * Math.atan2(px.y, px.x) - 90;\n  var skewY = 180 / Math.PI * Math.atan2(py.y, py.x);\n  return {\n    skewX: skewX,\n    skewY: skewY,\n    translateX: matrix.e,\n    translateY: matrix.f,\n    scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n    scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n    rotation: skewX\n  };\n}\nexport function matrixToScale(matrix) {\n  var a;\n  var b;\n  var c;\n  var d;\n\n  if (matrix) {\n    a = matrix.a == null ? 1 : matrix.a;\n    d = matrix.d == null ? 1 : matrix.d;\n    b = matrix.b;\n    c = matrix.c;\n  } else {\n    a = d = 1;\n  }\n\n  return {\n    sx: b ? Math.sqrt(a * a + b * b) : a,\n    sy: c ? Math.sqrt(c * c + d * d) : d\n  };\n}\nexport function matrixToRotation(matrix) {\n  var p = {\n    x: 0,\n    y: 1\n  };\n\n  if (matrix) {\n    p = deltaTransformPoint(matrix, p);\n  }\n\n  return {\n    angle: Angle.normalize(Angle.toDeg(Math.atan2(p.y, p.x)) - 90)\n  };\n}\nexport function matrixToTranslation(matrix) {\n  return {\n    tx: matrix && matrix.e || 0,\n    ty: matrix && matrix.f || 0\n  };\n}\n/**\n * Transforms point by an SVG transformation represented by `matrix`.\n */\n\nexport function transformPoint(point, matrix) {\n  var ret = createSVGPoint(point.x, point.y).matrixTransform(matrix);\n  return new Point(ret.x, ret.y);\n}\n/**\n * Transforms line by an SVG transformation represented by `matrix`.\n */\n\nexport function transformLine(line, matrix) {\n  return new Line(transformPoint(line.start, matrix), transformPoint(line.end, matrix));\n}\n/**\n * Transforms polyline by an SVG transformation represented by `matrix`.\n */\n\nexport function transformPolyline(polyline, matrix) {\n  var points = polyline instanceof Polyline ? polyline.points : polyline;\n\n  if (!Array.isArray(points)) {\n    points = [];\n  }\n\n  return new Polyline(points.map(function (p) {\n    return transformPoint(p, matrix);\n  }));\n}\nexport function transformRectangle(rect, matrix) {\n  var p = svgDocument.createSVGPoint();\n  p.x = rect.x;\n  p.y = rect.y;\n  var corner1 = p.matrixTransform(matrix);\n  p.x = rect.x + rect.width;\n  p.y = rect.y;\n  var corner2 = p.matrixTransform(matrix);\n  p.x = rect.x + rect.width;\n  p.y = rect.y + rect.height;\n  var corner3 = p.matrixTransform(matrix);\n  p.x = rect.x;\n  p.y = rect.y + rect.height;\n  var corner4 = p.matrixTransform(matrix);\n  var minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);\n  var maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);\n  var minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);\n  var maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);\n  return new Rectangle(minX, minY, maxX - minX, maxY - minY);\n}","map":{"version":3,"sources":["../../../src/util/dom/matrix.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Angle, Point, Line, Rectangle, Polyline } from '../../geometry';\nimport { createSvgElement } from './elem';\nconst svgDocument = createSvgElement('svg');\nconst transformRegex = /(\\w+)\\(([^,)]+),?([^)]+)?\\)/gi;\nconst transformSeparatorRegex = /[ ,]+/;\nconst transformationListRegex = /^(\\w+)\\((.*)\\)/;\n/**\n * Returns a SVG point object initialized with the `x` and `y` coordinates.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGPoint\n */\nexport function createSVGPoint(x, y) {\n    const p = svgDocument.createSVGPoint();\n    p.x = x;\n    p.y = y;\n    return p;\n}\n/**\n * Returns the SVG transformation matrix initialized with the given matrix.\n *\n * The given matrix is an object of the form:\n * {\n *   a: number\n *   b: number\n *   c: number\n *   d: number\n *   e: number\n *   f: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\nexport function createSVGMatrix(matrix) {\n    const mat = svgDocument.createSVGMatrix();\n    if (matrix != null) {\n        const source = matrix;\n        const target = mat;\n        // eslint-disable-next-line\n        for (const key in source) {\n            target[key] = source[key];\n        }\n    }\n    return mat;\n}\n/**\n * Returns a SVG transform object.\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGTransform\n */\nexport function createSVGTransform(matrix) {\n    if (matrix != null) {\n        if (!(matrix instanceof DOMMatrix)) {\n            matrix = createSVGMatrix(matrix); // eslint-disable-line\n        }\n        return svgDocument.createSVGTransformFromMatrix(matrix);\n    }\n    return svgDocument.createSVGTransform();\n}\n/**\n * Returns the SVG transformation matrix built from the `transformString`.\n *\n * E.g. 'translate(10,10) scale(2,2)' will result in matrix:\n * `{ a: 2, b: 0, c: 0, d: 2, e: 10, f: 10}`\n */\nexport function transformStringToMatrix(transform) {\n    let mat = createSVGMatrix();\n    const matches = transform != null && transform.match(transformRegex);\n    if (!matches) {\n        return mat;\n    }\n    for (let i = 0, n = matches.length; i < n; i += 1) {\n        const transformationString = matches[i];\n        const transformationMatch = transformationString.match(transformationListRegex);\n        if (transformationMatch) {\n            let sx;\n            let sy;\n            let tx;\n            let ty;\n            let angle;\n            let ctm = createSVGMatrix();\n            const args = transformationMatch[2].split(transformSeparatorRegex);\n            switch (transformationMatch[1].toLowerCase()) {\n                case 'scale':\n                    sx = parseFloat(args[0]);\n                    sy = args[1] === undefined ? sx : parseFloat(args[1]);\n                    ctm = ctm.scaleNonUniform(sx, sy);\n                    break;\n                case 'translate':\n                    tx = parseFloat(args[0]);\n                    ty = parseFloat(args[1]);\n                    ctm = ctm.translate(tx, ty);\n                    break;\n                case 'rotate':\n                    angle = parseFloat(args[0]);\n                    tx = parseFloat(args[1]) || 0;\n                    ty = parseFloat(args[2]) || 0;\n                    if (tx !== 0 || ty !== 0) {\n                        ctm = ctm.translate(tx, ty).rotate(angle).translate(-tx, -ty);\n                    }\n                    else {\n                        ctm = ctm.rotate(angle);\n                    }\n                    break;\n                case 'skewx':\n                    angle = parseFloat(args[0]);\n                    ctm = ctm.skewX(angle);\n                    break;\n                case 'skewy':\n                    angle = parseFloat(args[0]);\n                    ctm = ctm.skewY(angle);\n                    break;\n                case 'matrix':\n                    ctm.a = parseFloat(args[0]);\n                    ctm.b = parseFloat(args[1]);\n                    ctm.c = parseFloat(args[2]);\n                    ctm.d = parseFloat(args[3]);\n                    ctm.e = parseFloat(args[4]);\n                    ctm.f = parseFloat(args[5]);\n                    break;\n                default:\n                    continue;\n            }\n            mat = mat.multiply(ctm);\n        }\n    }\n    return mat;\n}\nexport function matrixToTransformString(matrix) {\n    const m = matrix || {};\n    const a = m.a != null ? m.a : 1;\n    const b = m.b != null ? m.b : 0;\n    const c = m.c != null ? m.c : 0;\n    const d = m.d != null ? m.d : 1;\n    const e = m.e != null ? m.e : 0;\n    const f = m.f != null ? m.f : 0;\n    return `matrix(${a},${b},${c},${d},${e},${f})`;\n}\nexport function parseTransformString(transform) {\n    let translation;\n    let rotation;\n    let scale;\n    if (transform) {\n        const separator = transformSeparatorRegex;\n        // Allow reading transform string with a single matrix\n        if (transform.trim().indexOf('matrix') >= 0) {\n            const matrix = transformStringToMatrix(transform);\n            const decomposedMatrix = decomposeMatrix(matrix);\n            translation = [decomposedMatrix.translateX, decomposedMatrix.translateY];\n            rotation = [decomposedMatrix.rotation];\n            scale = [decomposedMatrix.scaleX, decomposedMatrix.scaleY];\n            const transformations = [];\n            if (translation[0] !== 0 || translation[1] !== 0) {\n                transformations.push(`translate(${translation.join(',')})`);\n            }\n            if (scale[0] !== 1 || scale[1] !== 1) {\n                transformations.push(`scale(${scale.join(',')})`);\n            }\n            if (rotation[0] !== 0) {\n                transformations.push(`rotate(${rotation[0]})`);\n            }\n            transform = transformations.join(' '); // eslint-disable-line\n        }\n        else {\n            const translateMatch = transform.match(/translate\\((.*?)\\)/);\n            if (translateMatch) {\n                translation = translateMatch[1].split(separator);\n            }\n            const rotateMatch = transform.match(/rotate\\((.*?)\\)/);\n            if (rotateMatch) {\n                rotation = rotateMatch[1].split(separator);\n            }\n            const scaleMatch = transform.match(/scale\\((.*?)\\)/);\n            if (scaleMatch) {\n                scale = scaleMatch[1].split(separator);\n            }\n        }\n    }\n    const sx = scale && scale[0] ? parseFloat(scale[0]) : 1;\n    return {\n        raw: transform || '',\n        translation: {\n            tx: translation && translation[0]\n                ? parseInt(translation[0], 10)\n                : 0,\n            ty: translation && translation[1]\n                ? parseInt(translation[1], 10)\n                : 0,\n        },\n        rotation: {\n            angle: rotation && rotation[0] ? parseInt(rotation[0], 10) : 0,\n            cx: rotation && rotation[1]\n                ? parseInt(rotation[1], 10)\n                : undefined,\n            cy: rotation && rotation[2]\n                ? parseInt(rotation[2], 10)\n                : undefined,\n        },\n        scale: {\n            sx,\n            sy: scale && scale[1] ? parseFloat(scale[1]) : sx,\n        },\n    };\n}\nfunction deltaTransformPoint(matrix, point) {\n    const dx = point.x * matrix.a + point.y * matrix.c + 0;\n    const dy = point.x * matrix.b + point.y * matrix.d + 0;\n    return { x: dx, y: dy };\n}\n/**\n * Decomposes the SVG transformation matrix into separate transformations.\n *\n * Returns an object of the form:\n * {\n *   translateX: number\n *   translateY: number\n *   scaleX: number\n *   scaleY: number\n *   skewX: number\n *   skewY: number\n *   rotation: number\n * }\n *\n * @see https://developer.mozilla.org/en/docs/Web/API/SVGMatrix\n */\nexport function decomposeMatrix(matrix) {\n    // @see https://gist.github.com/2052247\n    const px = deltaTransformPoint(matrix, { x: 0, y: 1 });\n    const py = deltaTransformPoint(matrix, { x: 1, y: 0 });\n    const skewX = (180 / Math.PI) * Math.atan2(px.y, px.x) - 90;\n    const skewY = (180 / Math.PI) * Math.atan2(py.y, py.x);\n    return {\n        skewX,\n        skewY,\n        translateX: matrix.e,\n        translateY: matrix.f,\n        scaleX: Math.sqrt(matrix.a * matrix.a + matrix.b * matrix.b),\n        scaleY: Math.sqrt(matrix.c * matrix.c + matrix.d * matrix.d),\n        rotation: skewX,\n    };\n}\nexport function matrixToScale(matrix) {\n    let a;\n    let b;\n    let c;\n    let d;\n    if (matrix) {\n        a = matrix.a == null ? 1 : matrix.a;\n        d = matrix.d == null ? 1 : matrix.d;\n        b = matrix.b;\n        c = matrix.c;\n    }\n    else {\n        a = d = 1;\n    }\n    return {\n        sx: b ? Math.sqrt(a * a + b * b) : a,\n        sy: c ? Math.sqrt(c * c + d * d) : d,\n    };\n}\nexport function matrixToRotation(matrix) {\n    let p = { x: 0, y: 1 };\n    if (matrix) {\n        p = deltaTransformPoint(matrix, p);\n    }\n    return {\n        angle: Angle.normalize(Angle.toDeg(Math.atan2(p.y, p.x)) - 90),\n    };\n}\nexport function matrixToTranslation(matrix) {\n    return {\n        tx: (matrix && matrix.e) || 0,\n        ty: (matrix && matrix.f) || 0,\n    };\n}\n/**\n * Transforms point by an SVG transformation represented by `matrix`.\n */\nexport function transformPoint(point, matrix) {\n    const ret = createSVGPoint(point.x, point.y).matrixTransform(matrix);\n    return new Point(ret.x, ret.y);\n}\n/**\n * Transforms line by an SVG transformation represented by `matrix`.\n */\nexport function transformLine(line, matrix) {\n    return new Line(transformPoint(line.start, matrix), transformPoint(line.end, matrix));\n}\n/**\n * Transforms polyline by an SVG transformation represented by `matrix`.\n */\nexport function transformPolyline(polyline, matrix) {\n    let points = polyline instanceof Polyline ? polyline.points : polyline;\n    if (!Array.isArray(points)) {\n        points = [];\n    }\n    return new Polyline(points.map((p) => transformPoint(p, matrix)));\n}\nexport function transformRectangle(rect, matrix) {\n    const p = svgDocument.createSVGPoint();\n    p.x = rect.x;\n    p.y = rect.y;\n    const corner1 = p.matrixTransform(matrix);\n    p.x = rect.x + rect.width;\n    p.y = rect.y;\n    const corner2 = p.matrixTransform(matrix);\n    p.x = rect.x + rect.width;\n    p.y = rect.y + rect.height;\n    const corner3 = p.matrixTransform(matrix);\n    p.x = rect.x;\n    p.y = rect.y + rect.height;\n    const corner4 = p.matrixTransform(matrix);\n    const minX = Math.min(corner1.x, corner2.x, corner3.x, corner4.x);\n    const maxX = Math.max(corner1.x, corner2.x, corner3.x, corner4.x);\n    const minY = Math.min(corner1.y, corner2.y, corner3.y, corner4.y);\n    const maxY = Math.max(corner1.y, corner2.y, corner3.y, corner4.y);\n    return new Rectangle(minX, minY, maxX - minX, maxY - minY);\n}\n//# sourceMappingURL=matrix.js.map"]},"metadata":{},"sourceType":"module"}