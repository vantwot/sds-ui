{"ast":null,"code":"import { ArrayExt } from '../util';\nimport { Basecoat } from '../common';\nexport class Collection extends Basecoat {\n  constructor(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    super();\n    this.length = 0;\n    this.comparator = options.comparator || 'zIndex';\n    this.clean();\n\n    if (cells) {\n      this.reset(cells, {\n        silent: true\n      });\n    }\n  }\n\n  toJSON() {\n    return this.cells.map(cell => cell.toJSON());\n  }\n\n  add(cells, index, options) {\n    let localIndex;\n    let localOptions;\n\n    if (typeof index === 'number') {\n      localIndex = index;\n      localOptions = Object.assign({\n        merge: false\n      }, options);\n    } else {\n      localIndex = this.length;\n      localOptions = Object.assign({\n        merge: false\n      }, index);\n    }\n\n    if (localIndex > this.length) {\n      localIndex = this.length;\n    }\n\n    if (localIndex < 0) {\n      localIndex += this.length + 1;\n    }\n\n    const entities = Array.isArray(cells) ? cells : [cells];\n    const sortable = this.comparator && typeof index !== 'number' && localOptions.sort !== false;\n    const sortAttr = this.comparator || null;\n    let sort = false;\n    const added = [];\n    const merged = [];\n    entities.forEach(cell => {\n      const existing = this.get(cell);\n\n      if (existing) {\n        if (localOptions.merge && !cell.isSameStore(existing)) {\n          existing.setProp(cell.getProp(), options); // merge\n\n          merged.push(existing);\n\n          if (sortable && !sort) {\n            if (sortAttr == null || typeof sortAttr === 'function') {\n              sort = existing.hasChanged();\n            } else if (typeof sortAttr === 'string') {\n              sort = existing.hasChanged(sortAttr);\n            } else {\n              sort = sortAttr.some(key => existing.hasChanged(key));\n            }\n          }\n        }\n      } else {\n        added.push(cell);\n        this.reference(cell);\n      }\n    });\n\n    if (added.length) {\n      if (sortable) {\n        sort = true;\n      }\n\n      this.cells.splice(localIndex, 0, ...added);\n      this.length = this.cells.length;\n    }\n\n    if (sort) {\n      this.sort({\n        silent: true\n      });\n    }\n\n    if (!localOptions.silent) {\n      added.forEach((cell, i) => {\n        const args = {\n          cell,\n          index: localIndex + i,\n          options: localOptions\n        };\n        this.trigger('added', args);\n\n        if (!localOptions.dryrun) {\n          cell.notify('added', Object.assign({}, args));\n        }\n      });\n\n      if (sort) {\n        this.trigger('sorted');\n      }\n\n      if (added.length || merged.length) {\n        this.trigger('updated', {\n          added,\n          merged,\n          removed: [],\n          options: localOptions\n        });\n      }\n    }\n\n    return this;\n  }\n\n  remove(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const arr = Array.isArray(cells) ? cells : [cells];\n    const removed = this.removeCells(arr, options);\n\n    if (!options.silent && removed.length > 0) {\n      this.trigger('updated', {\n        options,\n        removed,\n        added: [],\n        merged: []\n      });\n    }\n\n    return Array.isArray(cells) ? removed : removed[0];\n  }\n\n  removeCells(cells, options) {\n    const removed = [];\n\n    for (let i = 0; i < cells.length; i += 1) {\n      const cell = this.get(cells[i]);\n\n      if (cell == null) {\n        continue;\n      }\n\n      const index = this.cells.indexOf(cell);\n      this.cells.splice(index, 1);\n      this.length -= 1;\n      delete this.map[cell.id];\n      removed.push(cell);\n      this.unreference(cell);\n\n      if (!options.dryrun) {\n        cell.remove();\n      }\n\n      if (!options.silent) {\n        this.trigger('removed', {\n          cell,\n          index,\n          options\n        });\n\n        if (!options.dryrun) {\n          cell.notify('removed', {\n            cell,\n            index,\n            options\n          });\n        }\n      }\n    }\n\n    return removed;\n  }\n\n  reset(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const previous = this.cells.slice();\n    previous.forEach(cell => this.unreference(cell));\n    this.clean();\n    this.add(cells, Object.assign({\n      silent: true\n    }, options));\n\n    if (!options.silent) {\n      const current = this.cells.slice();\n      this.trigger('reseted', {\n        options,\n        previous,\n        current\n      });\n      const added = [];\n      const removed = [];\n      current.forEach(a => {\n        const exist = previous.some(b => b.id === a.id);\n\n        if (!exist) {\n          added.push(a);\n        }\n      });\n      previous.forEach(a => {\n        const exist = current.some(b => b.id === a.id);\n\n        if (!exist) {\n          removed.push(a);\n        }\n      });\n      this.trigger('updated', {\n        options,\n        added,\n        removed,\n        merged: []\n      });\n    }\n\n    return this;\n  }\n\n  push(cell, options) {\n    return this.add(cell, this.length, options);\n  }\n\n  pop(options) {\n    const cell = this.at(this.length - 1);\n    return this.remove(cell, options);\n  }\n\n  unshift(cell, options) {\n    return this.add(cell, 0, options);\n  }\n\n  shift(options) {\n    const cell = this.at(0);\n    return this.remove(cell, options);\n  }\n\n  get(cell) {\n    if (cell == null) {\n      return null;\n    }\n\n    const id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;\n    return this.map[id] || null;\n  }\n\n  has(cell) {\n    return this.get(cell) != null;\n  }\n\n  at(index) {\n    if (index < 0) {\n      index += this.length; // eslint-disable-line\n    }\n\n    return this.cells[index] || null;\n  }\n\n  first() {\n    return this.at(0);\n  }\n\n  last() {\n    return this.at(-1);\n  }\n\n  indexOf(cell) {\n    return this.cells.indexOf(cell);\n  }\n\n  toArray() {\n    return this.cells.slice();\n  }\n\n  sort() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.comparator != null) {\n      this.cells = ArrayExt.sortBy(this.cells, this.comparator);\n\n      if (!options.silent) {\n        this.trigger('sorted');\n      }\n    }\n\n    return this;\n  }\n\n  clone() {\n    const constructor = this.constructor;\n    return new constructor(this.cells.slice(), {\n      comparator: this.comparator\n    });\n  }\n\n  reference(cell) {\n    this.map[cell.id] = cell;\n    cell.on('*', this.notifyCellEvent, this);\n  }\n\n  unreference(cell) {\n    cell.off('*', this.notifyCellEvent, this);\n    delete this.map[cell.id];\n  }\n\n  notifyCellEvent(name, args) {\n    const cell = args.cell;\n    this.trigger(`cell:${name}`, args);\n\n    if (cell) {\n      if (cell.isNode()) {\n        this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), {\n          node: cell\n        }));\n      } else if (cell.isEdge()) {\n        this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), {\n          edge: cell\n        }));\n      }\n    }\n  }\n\n  clean() {\n    this.length = 0;\n    this.cells = [];\n    this.map = {};\n  }\n\n}","map":{"version":3,"sources":["../../src/model/collection.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ArrayExt } from '../util';\nimport { Basecoat } from '../common';\nexport class Collection extends Basecoat {\n    constructor(cells, options = {}) {\n        super();\n        this.length = 0;\n        this.comparator = options.comparator || 'zIndex';\n        this.clean();\n        if (cells) {\n            this.reset(cells, { silent: true });\n        }\n    }\n    toJSON() {\n        return this.cells.map((cell) => cell.toJSON());\n    }\n    add(cells, index, options) {\n        let localIndex;\n        let localOptions;\n        if (typeof index === 'number') {\n            localIndex = index;\n            localOptions = Object.assign({ merge: false }, options);\n        }\n        else {\n            localIndex = this.length;\n            localOptions = Object.assign({ merge: false }, index);\n        }\n        if (localIndex > this.length) {\n            localIndex = this.length;\n        }\n        if (localIndex < 0) {\n            localIndex += this.length + 1;\n        }\n        const entities = Array.isArray(cells) ? cells : [cells];\n        const sortable = this.comparator &&\n            typeof index !== 'number' &&\n            localOptions.sort !== false;\n        const sortAttr = this.comparator || null;\n        let sort = false;\n        const added = [];\n        const merged = [];\n        entities.forEach((cell) => {\n            const existing = this.get(cell);\n            if (existing) {\n                if (localOptions.merge && !cell.isSameStore(existing)) {\n                    existing.setProp(cell.getProp(), options); // merge\n                    merged.push(existing);\n                    if (sortable && !sort) {\n                        if (sortAttr == null || typeof sortAttr === 'function') {\n                            sort = existing.hasChanged();\n                        }\n                        else if (typeof sortAttr === 'string') {\n                            sort = existing.hasChanged(sortAttr);\n                        }\n                        else {\n                            sort = sortAttr.some((key) => existing.hasChanged(key));\n                        }\n                    }\n                }\n            }\n            else {\n                added.push(cell);\n                this.reference(cell);\n            }\n        });\n        if (added.length) {\n            if (sortable) {\n                sort = true;\n            }\n            this.cells.splice(localIndex, 0, ...added);\n            this.length = this.cells.length;\n        }\n        if (sort) {\n            this.sort({ silent: true });\n        }\n        if (!localOptions.silent) {\n            added.forEach((cell, i) => {\n                const args = {\n                    cell,\n                    index: localIndex + i,\n                    options: localOptions,\n                };\n                this.trigger('added', args);\n                if (!localOptions.dryrun) {\n                    cell.notify('added', Object.assign({}, args));\n                }\n            });\n            if (sort) {\n                this.trigger('sorted');\n            }\n            if (added.length || merged.length) {\n                this.trigger('updated', {\n                    added,\n                    merged,\n                    removed: [],\n                    options: localOptions,\n                });\n            }\n        }\n        return this;\n    }\n    remove(cells, options = {}) {\n        const arr = Array.isArray(cells) ? cells : [cells];\n        const removed = this.removeCells(arr, options);\n        if (!options.silent && removed.length > 0) {\n            this.trigger('updated', {\n                options,\n                removed,\n                added: [],\n                merged: [],\n            });\n        }\n        return Array.isArray(cells) ? removed : removed[0];\n    }\n    removeCells(cells, options) {\n        const removed = [];\n        for (let i = 0; i < cells.length; i += 1) {\n            const cell = this.get(cells[i]);\n            if (cell == null) {\n                continue;\n            }\n            const index = this.cells.indexOf(cell);\n            this.cells.splice(index, 1);\n            this.length -= 1;\n            delete this.map[cell.id];\n            removed.push(cell);\n            this.unreference(cell);\n            if (!options.dryrun) {\n                cell.remove();\n            }\n            if (!options.silent) {\n                this.trigger('removed', { cell, index, options });\n                if (!options.dryrun) {\n                    cell.notify('removed', { cell, index, options });\n                }\n            }\n        }\n        return removed;\n    }\n    reset(cells, options = {}) {\n        const previous = this.cells.slice();\n        previous.forEach((cell) => this.unreference(cell));\n        this.clean();\n        this.add(cells, Object.assign({ silent: true }, options));\n        if (!options.silent) {\n            const current = this.cells.slice();\n            this.trigger('reseted', {\n                options,\n                previous,\n                current,\n            });\n            const added = [];\n            const removed = [];\n            current.forEach((a) => {\n                const exist = previous.some((b) => b.id === a.id);\n                if (!exist) {\n                    added.push(a);\n                }\n            });\n            previous.forEach((a) => {\n                const exist = current.some((b) => b.id === a.id);\n                if (!exist) {\n                    removed.push(a);\n                }\n            });\n            this.trigger('updated', { options, added, removed, merged: [] });\n        }\n        return this;\n    }\n    push(cell, options) {\n        return this.add(cell, this.length, options);\n    }\n    pop(options) {\n        const cell = this.at(this.length - 1);\n        return this.remove(cell, options);\n    }\n    unshift(cell, options) {\n        return this.add(cell, 0, options);\n    }\n    shift(options) {\n        const cell = this.at(0);\n        return this.remove(cell, options);\n    }\n    get(cell) {\n        if (cell == null) {\n            return null;\n        }\n        const id = typeof cell === 'string' || typeof cell === 'number' ? cell : cell.id;\n        return this.map[id] || null;\n    }\n    has(cell) {\n        return this.get(cell) != null;\n    }\n    at(index) {\n        if (index < 0) {\n            index += this.length; // eslint-disable-line\n        }\n        return this.cells[index] || null;\n    }\n    first() {\n        return this.at(0);\n    }\n    last() {\n        return this.at(-1);\n    }\n    indexOf(cell) {\n        return this.cells.indexOf(cell);\n    }\n    toArray() {\n        return this.cells.slice();\n    }\n    sort(options = {}) {\n        if (this.comparator != null) {\n            this.cells = ArrayExt.sortBy(this.cells, this.comparator);\n            if (!options.silent) {\n                this.trigger('sorted');\n            }\n        }\n        return this;\n    }\n    clone() {\n        const constructor = this.constructor;\n        return new constructor(this.cells.slice(), {\n            comparator: this.comparator,\n        });\n    }\n    reference(cell) {\n        this.map[cell.id] = cell;\n        cell.on('*', this.notifyCellEvent, this);\n    }\n    unreference(cell) {\n        cell.off('*', this.notifyCellEvent, this);\n        delete this.map[cell.id];\n    }\n    notifyCellEvent(name, args) {\n        const cell = args.cell;\n        this.trigger(`cell:${name}`, args);\n        if (cell) {\n            if (cell.isNode()) {\n                this.trigger(`node:${name}`, Object.assign(Object.assign({}, args), { node: cell }));\n            }\n            else if (cell.isEdge()) {\n                this.trigger(`edge:${name}`, Object.assign(Object.assign({}, args), { edge: cell }));\n            }\n        }\n    }\n    clean() {\n        this.length = 0;\n        this.cells = [];\n        this.map = {};\n    }\n}\n//# sourceMappingURL=collection.js.map"]},"metadata":{},"sourceType":"module"}