{"ast":null,"code":"import { Point } from '../point';\nconst regexSupportedData = new RegExp(`^[\\\\s\\\\dLMCZz,.]*$`);\nexport function isValid(data) {\n  if (typeof data !== 'string') {\n    return false;\n  }\n\n  return regexSupportedData.test(data);\n}\n/**\n * Returns the remainder of division of `n` by `m`. You should use this\n * instead of the built-in operation as the built-in operation does not\n * properly handle negative numbers.\n */\n\nfunction mod(n, m) {\n  return (n % m + m) % m;\n}\n\nfunction draw(points, round, initialMove, close, exclude) {\n  const data = [];\n  const end = points[points.length - 1];\n  const rounded = round != null && round > 0;\n  const arcSize = round || 0; // Adds virtual waypoint in the center between start and end point\n\n  if (close && rounded) {\n    points = points.slice(); // eslint-disable-line\n\n    const p0 = points[0];\n    const wp = new Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);\n    points.splice(0, 0, wp);\n  }\n\n  let pt = points[0];\n  let i = 1; // Draws the line segments\n\n  if (initialMove) {\n    data.push('M', pt.x, pt.y);\n  } else {\n    data.push('L', pt.x, pt.y);\n  }\n\n  while (i < (close ? points.length : points.length - 1)) {\n    let tmp = points[mod(i, points.length)];\n    let dx = pt.x - tmp.x;\n    let dy = pt.y - tmp.y;\n\n    if (rounded && (dx !== 0 || dy !== 0) && (exclude == null || exclude.indexOf(i - 1) < 0)) {\n      // Draws a line from the last point to the current\n      // point with a spacing of size off the current point\n      // into direction of the last point\n      let dist = Math.sqrt(dx * dx + dy * dy);\n      const nx1 = dx * Math.min(arcSize, dist / 2) / dist;\n      const ny1 = dy * Math.min(arcSize, dist / 2) / dist;\n      const x1 = tmp.x + nx1;\n      const y1 = tmp.y + ny1;\n      data.push('L', x1, y1); // Draws a curve from the last point to the current\n      // point with a spacing of size off the current point\n      // into direction of the next point\n\n      let next = points[mod(i + 1, points.length)]; // Uses next non-overlapping point\n\n      while (i < points.length - 2 && Math.round(next.x - tmp.x) === 0 && Math.round(next.y - tmp.y) === 0) {\n        next = points[mod(i + 2, points.length)];\n        i += 1;\n      }\n\n      dx = next.x - tmp.x;\n      dy = next.y - tmp.y;\n      dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n      const nx2 = dx * Math.min(arcSize, dist / 2) / dist;\n      const ny2 = dy * Math.min(arcSize, dist / 2) / dist;\n      const x2 = tmp.x + nx2;\n      const y2 = tmp.y + ny2;\n      data.push('Q', tmp.x, tmp.y, x2, y2);\n      tmp = new Point(x2, y2);\n    } else {\n      data.push('L', tmp.x, tmp.y);\n    }\n\n    pt = tmp;\n    i += 1;\n  }\n\n  if (close) {\n    data.push('Z');\n  } else {\n    data.push('L', end.x, end.y);\n  }\n\n  return data.map(v => typeof v === 'string' ? v : +v.toFixed(3)).join(' ');\n}\n\nexport function drawPoints(points) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  const pts = [];\n\n  if (points && points.length) {\n    points.forEach(p => {\n      if (Array.isArray(p)) {\n        pts.push({\n          x: p[0],\n          y: p[1]\n        });\n      } else {\n        pts.push({\n          x: p.x,\n          y: p.y\n        });\n      }\n    });\n  }\n\n  return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);\n}\n/**\n * Converts the given arc to a series of curves.\n */\n\nexport function arcToCurves(x0, y0, r1, r2) {\n  let angle = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let largeArcFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  let sweepFlag = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let x = arguments.length > 7 ? arguments[7] : undefined;\n  let y = arguments.length > 8 ? arguments[8] : undefined;\n\n  if (r1 === 0 || r2 === 0) {\n    return [];\n  }\n\n  x -= x0; // eslint-disable-line\n\n  y -= y0; // eslint-disable-line\n\n  r1 = Math.abs(r1); // eslint-disable-line\n\n  r2 = Math.abs(r2); // eslint-disable-line\n\n  const ctx = -x / 2;\n  const cty = -y / 2;\n  const cpsi = Math.cos(angle * Math.PI / 180);\n  const spsi = Math.sin(angle * Math.PI / 180);\n  const rxd = cpsi * ctx + spsi * cty;\n  const ryd = -1 * spsi * ctx + cpsi * cty;\n  const rxdd = rxd * rxd;\n  const rydd = ryd * ryd;\n  const r1x = r1 * r1;\n  const r2y = r2 * r2;\n  const lamda = rxdd / r1x + rydd / r2y;\n  let sds;\n\n  if (lamda > 1) {\n    r1 = Math.sqrt(lamda) * r1; // eslint-disable-line\n\n    r2 = Math.sqrt(lamda) * r2; // eslint-disable-line\n\n    sds = 0;\n  } else {\n    let seif = 1;\n\n    if (largeArcFlag === sweepFlag) {\n      seif = -1;\n    }\n\n    sds = seif * Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));\n  }\n\n  const txd = sds * r1 * ryd / r2;\n  const tyd = -1 * sds * r2 * rxd / r1;\n  const tx = cpsi * txd - spsi * tyd + x / 2;\n  const ty = spsi * txd + cpsi * tyd + y / 2;\n  let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);\n  let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;\n  rad = Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) - Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);\n  let dr = rad >= 0 ? rad : 2 * Math.PI + rad;\n\n  if (sweepFlag === 0 && dr > 0) {\n    dr -= 2 * Math.PI;\n  } else if (sweepFlag !== 0 && dr < 0) {\n    dr += 2 * Math.PI;\n  }\n\n  const sse = dr * 2 / Math.PI;\n  const seg = Math.ceil(sse < 0 ? -1 * sse : sse);\n  const segr = dr / seg;\n  const t = 8 / 3 * Math.sin(segr / 4) * Math.sin(segr / 4) / Math.sin(segr / 2);\n  const cpsir1 = cpsi * r1;\n  const cpsir2 = cpsi * r2;\n  const spsir1 = spsi * r1;\n  const spsir2 = spsi * r2;\n  let mc = Math.cos(s1);\n  let ms = Math.sin(s1);\n  let x2 = -t * (cpsir1 * ms + spsir2 * mc);\n  let y2 = -t * (spsir1 * ms - cpsir2 * mc);\n  let x3 = 0;\n  let y3 = 0;\n  const result = [];\n\n  for (let n = 0; n < seg; n += 1) {\n    s1 += segr;\n    mc = Math.cos(s1);\n    ms = Math.sin(s1);\n    x3 = cpsir1 * mc - spsir2 * ms + tx;\n    y3 = spsir1 * mc + cpsir2 * ms + ty;\n    const dx = -t * (cpsir1 * ms + spsir2 * mc);\n    const dy = -t * (spsir1 * ms - cpsir2 * mc); // CurveTo updates x0, y0 so need to restore it\n\n    const index = n * 6;\n    result[index] = Number(x2 + x0);\n    result[index + 1] = Number(y2 + y0);\n    result[index + 2] = Number(x3 - dx + x0);\n    result[index + 3] = Number(y3 - dy + y0);\n    result[index + 4] = Number(x3 + x0);\n    result[index + 5] = Number(y3 + y0);\n    x2 = x3 + dx;\n    y2 = y3 + dy;\n  }\n\n  return result.map(num => +num.toFixed(2));\n}\nexport function drawArc(startX, startY, rx, ry) {\n  let xAxisRotation = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n  let largeArcFlag = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;\n  let sweepFlag = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : 0;\n  let stopX = arguments.length > 7 ? arguments[7] : undefined;\n  let stopY = arguments.length > 8 ? arguments[8] : undefined;\n  const data = [];\n  const points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);\n\n  if (points != null) {\n    for (let i = 0, ii = points.length; i < ii; i += 6) {\n      data.push('C', points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n    }\n  }\n\n  return data.join(' ');\n}","map":{"version":3,"sources":["../../../src/geometry/path/util.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Point } from '../point';\nconst regexSupportedData = new RegExp(`^[\\\\s\\\\dLMCZz,.]*$`);\nexport function isValid(data) {\n    if (typeof data !== 'string') {\n        return false;\n    }\n    return regexSupportedData.test(data);\n}\n/**\n * Returns the remainder of division of `n` by `m`. You should use this\n * instead of the built-in operation as the built-in operation does not\n * properly handle negative numbers.\n */\nfunction mod(n, m) {\n    return ((n % m) + m) % m;\n}\nfunction draw(points, round, initialMove, close, exclude) {\n    const data = [];\n    const end = points[points.length - 1];\n    const rounded = round != null && round > 0;\n    const arcSize = round || 0;\n    // Adds virtual waypoint in the center between start and end point\n    if (close && rounded) {\n        points = points.slice(); // eslint-disable-line\n        const p0 = points[0];\n        const wp = new Point(end.x + (p0.x - end.x) / 2, end.y + (p0.y - end.y) / 2);\n        points.splice(0, 0, wp);\n    }\n    let pt = points[0];\n    let i = 1;\n    // Draws the line segments\n    if (initialMove) {\n        data.push('M', pt.x, pt.y);\n    }\n    else {\n        data.push('L', pt.x, pt.y);\n    }\n    while (i < (close ? points.length : points.length - 1)) {\n        let tmp = points[mod(i, points.length)];\n        let dx = pt.x - tmp.x;\n        let dy = pt.y - tmp.y;\n        if (rounded &&\n            (dx !== 0 || dy !== 0) &&\n            (exclude == null || exclude.indexOf(i - 1) < 0)) {\n            // Draws a line from the last point to the current\n            // point with a spacing of size off the current point\n            // into direction of the last point\n            let dist = Math.sqrt(dx * dx + dy * dy);\n            const nx1 = (dx * Math.min(arcSize, dist / 2)) / dist;\n            const ny1 = (dy * Math.min(arcSize, dist / 2)) / dist;\n            const x1 = tmp.x + nx1;\n            const y1 = tmp.y + ny1;\n            data.push('L', x1, y1);\n            // Draws a curve from the last point to the current\n            // point with a spacing of size off the current point\n            // into direction of the next point\n            let next = points[mod(i + 1, points.length)];\n            // Uses next non-overlapping point\n            while (i < points.length - 2 &&\n                Math.round(next.x - tmp.x) === 0 &&\n                Math.round(next.y - tmp.y) === 0) {\n                next = points[mod(i + 2, points.length)];\n                i += 1;\n            }\n            dx = next.x - tmp.x;\n            dy = next.y - tmp.y;\n            dist = Math.max(1, Math.sqrt(dx * dx + dy * dy));\n            const nx2 = (dx * Math.min(arcSize, dist / 2)) / dist;\n            const ny2 = (dy * Math.min(arcSize, dist / 2)) / dist;\n            const x2 = tmp.x + nx2;\n            const y2 = tmp.y + ny2;\n            data.push('Q', tmp.x, tmp.y, x2, y2);\n            tmp = new Point(x2, y2);\n        }\n        else {\n            data.push('L', tmp.x, tmp.y);\n        }\n        pt = tmp;\n        i += 1;\n    }\n    if (close) {\n        data.push('Z');\n    }\n    else {\n        data.push('L', end.x, end.y);\n    }\n    return data.map((v) => (typeof v === 'string' ? v : +v.toFixed(3))).join(' ');\n}\nexport function drawPoints(points, options = {}) {\n    const pts = [];\n    if (points && points.length) {\n        points.forEach((p) => {\n            if (Array.isArray(p)) {\n                pts.push({ x: p[0], y: p[1] });\n            }\n            else {\n                pts.push({ x: p.x, y: p.y });\n            }\n        });\n    }\n    return draw(pts, options.round, options.initialMove == null || options.initialMove, options.close, options.exclude);\n}\n/**\n * Converts the given arc to a series of curves.\n */\nexport function arcToCurves(x0, y0, r1, r2, angle = 0, largeArcFlag = 0, sweepFlag = 0, x, y) {\n    if (r1 === 0 || r2 === 0) {\n        return [];\n    }\n    x -= x0; // eslint-disable-line\n    y -= y0; // eslint-disable-line\n    r1 = Math.abs(r1); // eslint-disable-line\n    r2 = Math.abs(r2); // eslint-disable-line\n    const ctx = -x / 2;\n    const cty = -y / 2;\n    const cpsi = Math.cos((angle * Math.PI) / 180);\n    const spsi = Math.sin((angle * Math.PI) / 180);\n    const rxd = cpsi * ctx + spsi * cty;\n    const ryd = -1 * spsi * ctx + cpsi * cty;\n    const rxdd = rxd * rxd;\n    const rydd = ryd * ryd;\n    const r1x = r1 * r1;\n    const r2y = r2 * r2;\n    const lamda = rxdd / r1x + rydd / r2y;\n    let sds;\n    if (lamda > 1) {\n        r1 = Math.sqrt(lamda) * r1; // eslint-disable-line\n        r2 = Math.sqrt(lamda) * r2; // eslint-disable-line\n        sds = 0;\n    }\n    else {\n        let seif = 1;\n        if (largeArcFlag === sweepFlag) {\n            seif = -1;\n        }\n        sds =\n            seif *\n                Math.sqrt((r1x * r2y - r1x * rydd - r2y * rxdd) / (r1x * rydd + r2y * rxdd));\n    }\n    const txd = (sds * r1 * ryd) / r2;\n    const tyd = (-1 * sds * r2 * rxd) / r1;\n    const tx = cpsi * txd - spsi * tyd + x / 2;\n    const ty = spsi * txd + cpsi * tyd + y / 2;\n    let rad = Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1) - Math.atan2(0, 1);\n    let s1 = rad >= 0 ? rad : 2 * Math.PI + rad;\n    rad =\n        Math.atan2((-ryd - tyd) / r2, (-rxd - txd) / r1) -\n            Math.atan2((ryd - tyd) / r2, (rxd - txd) / r1);\n    let dr = rad >= 0 ? rad : 2 * Math.PI + rad;\n    if (sweepFlag === 0 && dr > 0) {\n        dr -= 2 * Math.PI;\n    }\n    else if (sweepFlag !== 0 && dr < 0) {\n        dr += 2 * Math.PI;\n    }\n    const sse = (dr * 2) / Math.PI;\n    const seg = Math.ceil(sse < 0 ? -1 * sse : sse);\n    const segr = dr / seg;\n    const t = ((8 / 3) * Math.sin(segr / 4) * Math.sin(segr / 4)) / Math.sin(segr / 2);\n    const cpsir1 = cpsi * r1;\n    const cpsir2 = cpsi * r2;\n    const spsir1 = spsi * r1;\n    const spsir2 = spsi * r2;\n    let mc = Math.cos(s1);\n    let ms = Math.sin(s1);\n    let x2 = -t * (cpsir1 * ms + spsir2 * mc);\n    let y2 = -t * (spsir1 * ms - cpsir2 * mc);\n    let x3 = 0;\n    let y3 = 0;\n    const result = [];\n    for (let n = 0; n < seg; n += 1) {\n        s1 += segr;\n        mc = Math.cos(s1);\n        ms = Math.sin(s1);\n        x3 = cpsir1 * mc - spsir2 * ms + tx;\n        y3 = spsir1 * mc + cpsir2 * ms + ty;\n        const dx = -t * (cpsir1 * ms + spsir2 * mc);\n        const dy = -t * (spsir1 * ms - cpsir2 * mc);\n        // CurveTo updates x0, y0 so need to restore it\n        const index = n * 6;\n        result[index] = Number(x2 + x0);\n        result[index + 1] = Number(y2 + y0);\n        result[index + 2] = Number(x3 - dx + x0);\n        result[index + 3] = Number(y3 - dy + y0);\n        result[index + 4] = Number(x3 + x0);\n        result[index + 5] = Number(y3 + y0);\n        x2 = x3 + dx;\n        y2 = y3 + dy;\n    }\n    return result.map((num) => +num.toFixed(2));\n}\nexport function drawArc(startX, startY, rx, ry, xAxisRotation = 0, largeArcFlag = 0, sweepFlag = 0, stopX, stopY) {\n    const data = [];\n    const points = arcToCurves(startX, startY, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, stopX, stopY);\n    if (points != null) {\n        for (let i = 0, ii = points.length; i < ii; i += 6) {\n            data.push('C', points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n        }\n    }\n    return data.join(' ');\n}\n//# sourceMappingURL=util.js.map"]},"metadata":{},"sourceType":"module"}