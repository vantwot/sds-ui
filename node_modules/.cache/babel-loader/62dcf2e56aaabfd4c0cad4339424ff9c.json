{"ast":null,"code":"import { bbox } from './bbox';\nimport { offset, getStrokeWidth } from './util';\nimport { FunctionExt } from '../../util';\n/**\n * Places the connection point at the intersection between the\n * link path end segment and the element's unrotated bbox.\n */\n\nexport const rect = function (line, view, magnet, options, type) {\n  const cell = view.cell;\n  const angle = cell.isNode() ? cell.getAngle() : 0;\n\n  if (angle === 0) {\n    return FunctionExt.call(bbox, this, line, view, magnet, options, type);\n  }\n\n  const bboxRaw = view.getUnrotatedBBoxOfElement(magnet);\n\n  if (options.stroked) {\n    bboxRaw.inflate(getStrokeWidth(magnet) / 2);\n  }\n\n  const center = bboxRaw.getCenter();\n  const lineRaw = line.clone().rotate(angle, center);\n  const intersections = lineRaw.setLength(1e6).intersect(bboxRaw);\n  const p = intersections && intersections.length ? lineRaw.start.closest(intersections).rotate(-angle, center) : line.end;\n  return offset(p, line.start, options.offset);\n};","map":{"version":3,"sources":["../../../src/registry/connection-point/rect.ts"],"names":[],"mappings":"AAAA,SAAS,IAAT,QAAqB,QAArB;AACA,SAAS,MAAT,EAAiB,cAAjB,QAAuC,QAAvC;AAEA,SAAS,WAAT,QAA4B,YAA5B;AAIA;;;AAGG;;AACH,OAAO,MAAM,IAAI,GAAiD,UAChE,IADgE,EAEhE,IAFgE,EAGhE,MAHgE,EAIhE,OAJgE,EAKhE,IALgE,EAK5D;AAEJ,QAAM,IAAI,GAAG,IAAI,CAAC,IAAlB;AACA,QAAM,KAAK,GAAG,IAAI,CAAC,MAAL,KAAgB,IAAI,CAAC,QAAL,EAAhB,GAAkC,CAAhD;;AACA,MAAI,KAAK,KAAK,CAAd,EAAiB;AACf,WAAO,WAAW,CAAC,IAAZ,CAAiB,IAAjB,EAAuB,IAAvB,EAA6B,IAA7B,EAAmC,IAAnC,EAAyC,MAAzC,EAAiD,OAAjD,EAA0D,IAA1D,CAAP;AACD;;AAED,QAAM,OAAO,GAAG,IAAI,CAAC,yBAAL,CAA+B,MAA/B,CAAhB;;AACA,MAAI,OAAO,CAAC,OAAZ,EAAqB;AACnB,IAAA,OAAO,CAAC,OAAR,CAAgB,cAAc,CAAC,MAAD,CAAd,GAAyB,CAAzC;AACD;;AACD,QAAM,MAAM,GAAG,OAAO,CAAC,SAAR,EAAf;AACA,QAAM,OAAO,GAAG,IAAI,CAAC,KAAL,GAAa,MAAb,CAAoB,KAApB,EAA2B,MAA3B,CAAhB;AACA,QAAM,aAAa,GAAG,OAAO,CAAC,SAAR,CAAkB,GAAlB,EAAuB,SAAvB,CAAiC,OAAjC,CAAtB;AACA,QAAM,CAAC,GACL,aAAa,IAAI,aAAa,CAAC,MAA/B,GACI,OAAO,CAAC,KAAR,CAAc,OAAd,CAAsB,aAAtB,EAAsC,MAAtC,CAA6C,CAAC,KAA9C,EAAqD,MAArD,CADJ,GAEI,IAAI,CAAC,GAHX;AAIA,SAAO,MAAM,CAAC,CAAD,EAAI,IAAI,CAAC,KAAT,EAAgB,OAAO,CAAC,MAAxB,CAAb;AACD,CAzBM","sourceRoot":"","sourcesContent":["import { bbox } from './bbox';\nimport { offset, getStrokeWidth } from './util';\nimport { FunctionExt } from '../../util';\n/**\n * Places the connection point at the intersection between the\n * link path end segment and the element's unrotated bbox.\n */\nexport const rect = function (line, view, magnet, options, type) {\n    const cell = view.cell;\n    const angle = cell.isNode() ? cell.getAngle() : 0;\n    if (angle === 0) {\n        return FunctionExt.call(bbox, this, line, view, magnet, options, type);\n    }\n    const bboxRaw = view.getUnrotatedBBoxOfElement(magnet);\n    if (options.stroked) {\n        bboxRaw.inflate(getStrokeWidth(magnet) / 2);\n    }\n    const center = bboxRaw.getCenter();\n    const lineRaw = line.clone().rotate(angle, center);\n    const intersections = lineRaw.setLength(1e6).intersect(bboxRaw);\n    const p = intersections && intersections.length\n        ? lineRaw.start.closest(intersections).rotate(-angle, center)\n        : line.end;\n    return offset(p, line.start, options.offset);\n};\n//# sourceMappingURL=rect.js.map"]},"metadata":{},"sourceType":"module"}