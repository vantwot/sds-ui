{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport LngLat, { earthRadius } from '../geo/lng_lat';\nvar earthCircumfrence = 2 * Math.PI * earthRadius;\n\nfunction circumferenceAtLatitude(latitude) {\n  return earthCircumfrence * Math.cos(latitude * Math.PI / 180);\n}\n\nexport function mercatorXfromLng(lng) {\n  return (180 + lng) / 360;\n}\nexport function mercatorYfromLat(lat) {\n  return (180 - 180 / Math.PI * Math.log(Math.tan(Math.PI / 4 + lat * Math.PI / 360))) / 360;\n}\nexport function mercatorZfromAltitude(altitude, lat) {\n  return altitude / circumferenceAtLatitude(lat);\n}\nexport function lngFromMercatorX(x) {\n  return x * 360 - 180;\n}\nexport function latFromMercatorY(y) {\n  var y2 = 180 - y * 360;\n  return 360 / Math.PI * Math.atan(Math.exp(y2 * Math.PI / 180)) - 90;\n}\nexport function altitudeFromMercatorZ(z, y) {\n  return z * circumferenceAtLatitude(latFromMercatorY(y));\n}\nexport function mercatorScale(lat) {\n  return 1 / Math.cos(lat * Math.PI / 180);\n}\n\nvar MercatorCoordinate = function () {\n  function MercatorCoordinate(x, y) {\n    var z = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n\n    _classCallCheck(this, MercatorCoordinate);\n\n    _defineProperty(this, \"x\", void 0);\n\n    _defineProperty(this, \"y\", void 0);\n\n    _defineProperty(this, \"z\", void 0);\n\n    this.x = +x;\n    this.y = +y;\n    this.z = +z;\n  }\n\n  _createClass(MercatorCoordinate, [{\n    key: \"toLngLat\",\n    value: function toLngLat() {\n      return new LngLat(lngFromMercatorX(this.x), latFromMercatorY(this.y));\n    }\n  }, {\n    key: \"toAltitude\",\n    value: function toAltitude() {\n      return altitudeFromMercatorZ(this.z, this.y);\n    }\n  }, {\n    key: \"meterInMercatorCoordinateUnits\",\n    value: function meterInMercatorCoordinateUnits() {\n      return 1 / earthCircumfrence * mercatorScale(latFromMercatorY(this.y));\n    }\n  }], [{\n    key: \"fromLngLat\",\n    value: function fromLngLat(lngLatLike) {\n      var altitude = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var lngLat = LngLat.convert(lngLatLike);\n      return new MercatorCoordinate(mercatorXfromLng(lngLat.lng), mercatorYfromLat(lngLat.lat), mercatorZfromAltitude(altitude, lngLat.lat));\n    }\n  }]);\n\n  return MercatorCoordinate;\n}();\n\nexport { MercatorCoordinate as default };","map":{"version":3,"sources":["../../src/geo/mercator.ts"],"names":["earthCircumfrence","Math","latitude","lat","altitude","circumferenceAtLatitude","x","y2","y","z","latFromMercatorY","MercatorCoordinate","lngLat","LngLat","mercatorXfromLng","mercatorYfromLat","mercatorZfromAltitude","lngFromMercatorX","altitudeFromMercatorZ","mercatorScale"],"mappings":"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","sourcesContent":["import LngLat, { earthRadius, LngLatLike } from '../geo/lng_lat';\n\n/*\n * The average circumference of the world in meters.\n */\nconst earthCircumfrence = 2 * Math.PI * earthRadius; // meters\n\n/*\n * The circumference at a line of latitude in meters.\n */\nfunction circumferenceAtLatitude(latitude: number) {\n  return earthCircumfrence * Math.cos((latitude * Math.PI) / 180);\n}\n\nexport function mercatorXfromLng(lng: number) {\n  return (180 + lng) / 360;\n}\n\nexport function mercatorYfromLat(lat: number) {\n  return (\n    (180 -\n      (180 / Math.PI) *\n        Math.log(Math.tan(Math.PI / 4 + (lat * Math.PI) / 360))) /\n    360\n  );\n}\n\nexport function mercatorZfromAltitude(altitude: number, lat: number) {\n  return altitude / circumferenceAtLatitude(lat);\n}\n\nexport function lngFromMercatorX(x: number) {\n  return x * 360 - 180;\n}\n\nexport function latFromMercatorY(y: number) {\n  const y2 = 180 - y * 360;\n  return (360 / Math.PI) * Math.atan(Math.exp((y2 * Math.PI) / 180)) - 90;\n}\n\nexport function altitudeFromMercatorZ(z: number, y: number) {\n  return z * circumferenceAtLatitude(latFromMercatorY(y));\n}\n\n/**\n * Determine the Mercator scale factor for a given latitude, see\n * https://en.wikipedia.org/wiki/Mercator_projection#Scale_factor\n *\n * At the equator the scale factor will be 1, which increases at higher latitudes.\n *\n * @param {number} lat Latitude\n * @returns {number} scale factor\n * @private\n */\nexport function mercatorScale(lat: number) {\n  return 1 / Math.cos((lat * Math.PI) / 180);\n}\n\nexport default class MercatorCoordinate {\n  public static fromLngLat(lngLatLike: LngLatLike, altitude: number = 0) {\n    const lngLat = LngLat.convert(lngLatLike);\n\n    return new MercatorCoordinate(\n      mercatorXfromLng(lngLat.lng),\n      mercatorYfromLat(lngLat.lat),\n      mercatorZfromAltitude(altitude, lngLat.lat),\n    );\n  }\n  public x: number;\n  public y: number;\n  public z: number;\n\n  constructor(x: number, y: number, z: number = 0) {\n    this.x = +x;\n    this.y = +y;\n    this.z = +z;\n  }\n\n  public toLngLat() {\n    return new LngLat(lngFromMercatorX(this.x), latFromMercatorY(this.y));\n  }\n\n  public toAltitude() {\n    return altitudeFromMercatorZ(this.z, this.y);\n  }\n\n  public meterInMercatorCoordinateUnits() {\n    // 1 meter / circumference at equator in meters * Mercator projection scale factor at this latitude\n    return (1 / earthCircumfrence) * mercatorScale(latFromMercatorY(this.y));\n  }\n}\n"]},"metadata":{},"sourceType":"module"}