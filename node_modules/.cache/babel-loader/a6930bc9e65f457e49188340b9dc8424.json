{"ast":null,"code":"import { Point, Path } from '../../geometry';\nexport const rounded = function (sourcePoint, targetPoint, routePoints) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  const path = new Path();\n  path.appendSegment(Path.createSegment('M', sourcePoint));\n  const f13 = 1 / 3;\n  const f23 = 2 / 3;\n  const radius = options.radius || 10;\n  let prevDistance;\n  let nextDistance;\n\n  for (let i = 0, ii = routePoints.length; i < ii; i += 1) {\n    const curr = Point.create(routePoints[i]);\n    const prev = routePoints[i - 1] || sourcePoint;\n    const next = routePoints[i + 1] || targetPoint;\n    prevDistance = nextDistance || curr.distance(prev) / 2;\n    nextDistance = curr.distance(next) / 2;\n    const startMove = -Math.min(radius, prevDistance);\n    const endMove = -Math.min(radius, nextDistance);\n    const roundedStart = curr.clone().move(prev, startMove).round();\n    const roundedEnd = curr.clone().move(next, endMove).round();\n    const control1 = new Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);\n    const control2 = new Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);\n    path.appendSegment(Path.createSegment('L', roundedStart));\n    path.appendSegment(Path.createSegment('C', control1, control2, roundedEnd));\n  }\n\n  path.appendSegment(Path.createSegment('L', targetPoint));\n  return options.raw ? path : path.serialize();\n};","map":{"version":3,"sources":["../../../src/registry/connector/rounded.ts"],"names":[],"mappings":"AAAA,SAAS,KAAT,EAAgB,IAAhB,QAA4B,gBAA5B;AAOA,OAAO,MAAM,OAAO,GAAkD,UACpE,WADoE,EAEpE,WAFoE,EAGpE,WAHoE,EAIxD;AAAA,MAAZ,OAAY,uEAAF,EAAE;AAEZ,QAAM,IAAI,GAAG,IAAI,IAAJ,EAAb;AAEA,EAAA,IAAI,CAAC,aAAL,CAAmB,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,WAAxB,CAAnB;AAEA,QAAM,GAAG,GAAG,IAAI,CAAhB;AACA,QAAM,GAAG,GAAG,IAAI,CAAhB;AACA,QAAM,MAAM,GAAG,OAAO,CAAC,MAAR,IAAkB,EAAjC;AAEA,MAAI,YAAJ;AACA,MAAI,YAAJ;;AACA,OAAK,IAAI,CAAC,GAAG,CAAR,EAAW,EAAE,GAAG,WAAW,CAAC,MAAjC,EAAyC,CAAC,GAAG,EAA7C,EAAiD,CAAC,IAAI,CAAtD,EAAyD;AACvD,UAAM,IAAI,GAAG,KAAK,CAAC,MAAN,CAAa,WAAW,CAAC,CAAD,CAAxB,CAAb;AACA,UAAM,IAAI,GAAG,WAAW,CAAC,CAAC,GAAG,CAAL,CAAX,IAAsB,WAAnC;AACA,UAAM,IAAI,GAAG,WAAW,CAAC,CAAC,GAAG,CAAL,CAAX,IAAsB,WAAnC;AAEA,IAAA,YAAY,GAAG,YAAY,IAAI,IAAI,CAAC,QAAL,CAAc,IAAd,IAAsB,CAArD;AACA,IAAA,YAAY,GAAG,IAAI,CAAC,QAAL,CAAc,IAAd,IAAsB,CAArC;AAEA,UAAM,SAAS,GAAG,CAAC,IAAI,CAAC,GAAL,CAAS,MAAT,EAAiB,YAAjB,CAAnB;AACA,UAAM,OAAO,GAAG,CAAC,IAAI,CAAC,GAAL,CAAS,MAAT,EAAiB,YAAjB,CAAjB;AAEA,UAAM,YAAY,GAAG,IAAI,CAAC,KAAL,GAAa,IAAb,CAAkB,IAAlB,EAAwB,SAAxB,EAAmC,KAAnC,EAArB;AACA,UAAM,UAAU,GAAG,IAAI,CAAC,KAAL,GAAa,IAAb,CAAkB,IAAlB,EAAwB,OAAxB,EAAiC,KAAjC,EAAnB;AAEA,UAAM,QAAQ,GAAG,IAAI,KAAJ,CACf,GAAG,GAAG,YAAY,CAAC,CAAnB,GAAuB,GAAG,GAAG,IAAI,CAAC,CADnB,EAEf,GAAG,GAAG,IAAI,CAAC,CAAX,GAAe,GAAG,GAAG,YAAY,CAAC,CAFnB,CAAjB;AAIA,UAAM,QAAQ,GAAG,IAAI,KAAJ,CACf,GAAG,GAAG,UAAU,CAAC,CAAjB,GAAqB,GAAG,GAAG,IAAI,CAAC,CADjB,EAEf,GAAG,GAAG,IAAI,CAAC,CAAX,GAAe,GAAG,GAAG,UAAU,CAAC,CAFjB,CAAjB;AAKA,IAAA,IAAI,CAAC,aAAL,CAAmB,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,YAAxB,CAAnB;AACA,IAAA,IAAI,CAAC,aAAL,CAAmB,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,QAAxB,EAAkC,QAAlC,EAA4C,UAA5C,CAAnB;AACD;;AAED,EAAA,IAAI,CAAC,aAAL,CAAmB,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,WAAxB,CAAnB;AAEA,SAAO,OAAO,CAAC,GAAR,GAAc,IAAd,GAAqB,IAAI,CAAC,SAAL,EAA5B;AACD,CA9CM","sourceRoot":"","sourcesContent":["import { Point, Path } from '../../geometry';\nexport const rounded = function (sourcePoint, targetPoint, routePoints, options = {}) {\n    const path = new Path();\n    path.appendSegment(Path.createSegment('M', sourcePoint));\n    const f13 = 1 / 3;\n    const f23 = 2 / 3;\n    const radius = options.radius || 10;\n    let prevDistance;\n    let nextDistance;\n    for (let i = 0, ii = routePoints.length; i < ii; i += 1) {\n        const curr = Point.create(routePoints[i]);\n        const prev = routePoints[i - 1] || sourcePoint;\n        const next = routePoints[i + 1] || targetPoint;\n        prevDistance = nextDistance || curr.distance(prev) / 2;\n        nextDistance = curr.distance(next) / 2;\n        const startMove = -Math.min(radius, prevDistance);\n        const endMove = -Math.min(radius, nextDistance);\n        const roundedStart = curr.clone().move(prev, startMove).round();\n        const roundedEnd = curr.clone().move(next, endMove).round();\n        const control1 = new Point(f13 * roundedStart.x + f23 * curr.x, f23 * curr.y + f13 * roundedStart.y);\n        const control2 = new Point(f13 * roundedEnd.x + f23 * curr.x, f23 * curr.y + f13 * roundedEnd.y);\n        path.appendSegment(Path.createSegment('L', roundedStart));\n        path.appendSegment(Path.createSegment('C', control1, control2, roundedEnd));\n    }\n    path.appendSegment(Path.createSegment('L', targetPoint));\n    return options.raw ? path : path.serialize();\n};\n//# sourceMappingURL=rounded.js.map"]},"metadata":{},"sourceType":"module"}