{"ast":null,"code":"import { hasClass } from './class';\nlet idCounter = 0;\nexport function uniqueId() {\n  idCounter += 1;\n  return `v${idCounter}`;\n}\nexport function ensureId(elem) {\n  if (elem.id == null || elem.id === '') {\n    elem.id = uniqueId();\n  }\n\n  return elem.id;\n}\n/**\n * Returns true if object is an instance of SVGGraphicsElement.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n */\n\nexport function isSVGGraphicsElement(elem) {\n  if (elem == null) {\n    return false;\n  }\n\n  return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement;\n}\nexport const ns = {\n  svg: 'http://www.w3.org/2000/svg',\n  xmlns: 'http://www.w3.org/2000/xmlns/',\n  xml: 'http://www.w3.org/XML/1998/namespace',\n  xlink: 'http://www.w3.org/1999/xlink',\n  xhtml: 'http://www.w3.org/1999/xhtml'\n};\nexport const svgVersion = '1.1';\nexport function createElement(tagName) {\n  let doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  return doc.createElement(tagName);\n}\nexport function createElementNS(tagName) {\n  let namespaceURI = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : ns.xhtml;\n  let doc = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : document;\n  return doc.createElementNS(namespaceURI, tagName);\n}\nexport function createSvgElement(tagName) {\n  let doc = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : document;\n  return createElementNS(tagName, ns.svg, doc);\n}\nexport function createSvgDocument(content) {\n  if (content) {\n    const xml = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${svgVersion}\">${content}</svg>`; // lgtm[js/html-constructed-from-input]\n\n    const {\n      documentElement\n    } = parseXML(xml, {\n      async: false\n    });\n    return documentElement;\n  }\n\n  const svg = document.createElementNS(ns.svg, 'svg');\n  svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n  svg.setAttribute('version', svgVersion);\n  return svg;\n}\nexport function parseXML(data) {\n  let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n  let xml;\n\n  try {\n    const parser = new DOMParser();\n\n    if (options.async != null) {\n      const instance = parser;\n      instance.async = options.async;\n    }\n\n    xml = parser.parseFromString(data, options.mimeType || 'text/xml');\n  } catch (error) {\n    xml = undefined;\n  }\n\n  if (!xml || xml.getElementsByTagName('parsererror').length) {\n    throw new Error(`Invalid XML: ${data}`);\n  }\n\n  return xml;\n}\nexport function tagName(node) {\n  let lowercase = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n  const nodeName = node.nodeName;\n  return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();\n}\nexport function index(elem) {\n  let index = 0;\n  let node = elem.previousSibling;\n\n  while (node) {\n    if (node.nodeType === 1) {\n      index += 1;\n    }\n\n    node = node.previousSibling;\n  }\n\n  return index;\n}\nexport function find(elem, selector) {\n  return elem.querySelectorAll(selector);\n}\nexport function findOne(elem, selector) {\n  return elem.querySelector(selector);\n}\nexport function findParentByClass(elem, className, terminator) {\n  const ownerSVGElement = elem.ownerSVGElement;\n  let node = elem.parentNode;\n\n  while (node && node !== terminator && node !== ownerSVGElement) {\n    if (hasClass(node, className)) {\n      return node;\n    }\n\n    node = node.parentNode;\n  }\n\n  return null;\n}\nexport function contains(parent, child) {\n  const bup = child && child.parentNode;\n  return parent === bup || !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise\n  ;\n}\nexport function remove(elem) {\n  if (elem.parentNode) {\n    elem.parentNode.removeChild(elem);\n  }\n}\nexport function empty(elem) {\n  while (elem.firstChild) {\n    elem.removeChild(elem.firstChild);\n  }\n}\nexport function append(elem, elems) {\n  const arr = Array.isArray(elems) ? elems : [elems];\n  arr.forEach(child => {\n    if (child != null) {\n      elem.appendChild(child);\n    }\n  });\n}\nexport function prepend(elem, elems) {\n  const child = elem.firstChild;\n  return child ? before(child, elems) : append(elem, elems);\n}\nexport function before(elem, elems) {\n  const parent = elem.parentNode;\n\n  if (parent) {\n    const arr = Array.isArray(elems) ? elems : [elems];\n    arr.forEach(child => {\n      if (child != null) {\n        parent.insertBefore(child, elem);\n      }\n    });\n  }\n}\nexport function appendTo(elem, target) {\n  if (target != null) {\n    target.appendChild(elem);\n  }\n} // Determines whether a node is an HTML node\n\nexport function isHTMLElement(elem) {\n  try {\n    // Using W3 DOM2 (works for FF, Opera and Chrome)\n    return elem instanceof HTMLElement;\n  } catch (e) {\n    // Browsers not supporting W3 DOM2 don't have HTMLElement and\n    // an exception is thrown and we end up here. Testing some\n    // properties that all elements have (works on IE7)\n    return typeof elem === 'object' && elem.nodeType === 1 && typeof elem.style === 'object' && typeof elem.ownerDocument === 'object';\n  }\n}","map":{"version":3,"sources":["../../../src/util/dom/elem.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { hasClass } from './class';\nlet idCounter = 0;\nexport function uniqueId() {\n    idCounter += 1;\n    return `v${idCounter}`;\n}\nexport function ensureId(elem) {\n    if (elem.id == null || elem.id === '') {\n        elem.id = uniqueId();\n    }\n    return elem.id;\n}\n/**\n * Returns true if object is an instance of SVGGraphicsElement.\n * @see https://developer.mozilla.org/en-US/docs/Web/API/SVGGraphicsElement\n */\nexport function isSVGGraphicsElement(elem) {\n    if (elem == null) {\n        return false;\n    }\n    return typeof elem.getScreenCTM === 'function' && elem instanceof SVGElement;\n}\nexport const ns = {\n    svg: 'http://www.w3.org/2000/svg',\n    xmlns: 'http://www.w3.org/2000/xmlns/',\n    xml: 'http://www.w3.org/XML/1998/namespace',\n    xlink: 'http://www.w3.org/1999/xlink',\n    xhtml: 'http://www.w3.org/1999/xhtml',\n};\nexport const svgVersion = '1.1';\nexport function createElement(tagName, doc = document) {\n    return doc.createElement(tagName);\n}\nexport function createElementNS(tagName, namespaceURI = ns.xhtml, doc = document) {\n    return doc.createElementNS(namespaceURI, tagName);\n}\nexport function createSvgElement(tagName, doc = document) {\n    return createElementNS(tagName, ns.svg, doc);\n}\nexport function createSvgDocument(content) {\n    if (content) {\n        const xml = `<svg xmlns=\"${ns.svg}\" xmlns:xlink=\"${ns.xlink}\" version=\"${svgVersion}\">${content}</svg>`; // lgtm[js/html-constructed-from-input]\n        const { documentElement } = parseXML(xml, { async: false });\n        return documentElement;\n    }\n    const svg = document.createElementNS(ns.svg, 'svg');\n    svg.setAttributeNS(ns.xmlns, 'xmlns:xlink', ns.xlink);\n    svg.setAttribute('version', svgVersion);\n    return svg;\n}\nexport function parseXML(data, options = {}) {\n    let xml;\n    try {\n        const parser = new DOMParser();\n        if (options.async != null) {\n            const instance = parser;\n            instance.async = options.async;\n        }\n        xml = parser.parseFromString(data, options.mimeType || 'text/xml');\n    }\n    catch (error) {\n        xml = undefined;\n    }\n    if (!xml || xml.getElementsByTagName('parsererror').length) {\n        throw new Error(`Invalid XML: ${data}`);\n    }\n    return xml;\n}\nexport function tagName(node, lowercase = true) {\n    const nodeName = node.nodeName;\n    return lowercase ? nodeName.toLowerCase() : nodeName.toUpperCase();\n}\nexport function index(elem) {\n    let index = 0;\n    let node = elem.previousSibling;\n    while (node) {\n        if (node.nodeType === 1) {\n            index += 1;\n        }\n        node = node.previousSibling;\n    }\n    return index;\n}\nexport function find(elem, selector) {\n    return elem.querySelectorAll(selector);\n}\nexport function findOne(elem, selector) {\n    return elem.querySelector(selector);\n}\nexport function findParentByClass(elem, className, terminator) {\n    const ownerSVGElement = elem.ownerSVGElement;\n    let node = elem.parentNode;\n    while (node && node !== terminator && node !== ownerSVGElement) {\n        if (hasClass(node, className)) {\n            return node;\n        }\n        node = node.parentNode;\n    }\n    return null;\n}\nexport function contains(parent, child) {\n    const bup = child && child.parentNode;\n    return (parent === bup ||\n        !!(bup && bup.nodeType === 1 && parent.compareDocumentPosition(bup) & 16) // eslint-disable-line no-bitwise\n    );\n}\nexport function remove(elem) {\n    if (elem.parentNode) {\n        elem.parentNode.removeChild(elem);\n    }\n}\nexport function empty(elem) {\n    while (elem.firstChild) {\n        elem.removeChild(elem.firstChild);\n    }\n}\nexport function append(elem, elems) {\n    const arr = Array.isArray(elems) ? elems : [elems];\n    arr.forEach((child) => {\n        if (child != null) {\n            elem.appendChild(child);\n        }\n    });\n}\nexport function prepend(elem, elems) {\n    const child = elem.firstChild;\n    return child ? before(child, elems) : append(elem, elems);\n}\nexport function before(elem, elems) {\n    const parent = elem.parentNode;\n    if (parent) {\n        const arr = Array.isArray(elems) ? elems : [elems];\n        arr.forEach((child) => {\n            if (child != null) {\n                parent.insertBefore(child, elem);\n            }\n        });\n    }\n}\nexport function appendTo(elem, target) {\n    if (target != null) {\n        target.appendChild(elem);\n    }\n}\n// Determines whether a node is an HTML node\nexport function isHTMLElement(elem) {\n    try {\n        // Using W3 DOM2 (works for FF, Opera and Chrome)\n        return elem instanceof HTMLElement;\n    }\n    catch (e) {\n        // Browsers not supporting W3 DOM2 don't have HTMLElement and\n        // an exception is thrown and we end up here. Testing some\n        // properties that all elements have (works on IE7)\n        return (typeof elem === 'object' &&\n            elem.nodeType === 1 &&\n            typeof elem.style === 'object' &&\n            typeof elem.ownerDocument === 'object');\n    }\n}\n//# sourceMappingURL=elem.js.map"]},"metadata":{},"sourceType":"module"}