{"ast":null,"code":"import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Line } from './line';\nimport { Geometry } from './geometry';\nexport class Polyline extends Geometry {\n  constructor(points) {\n    super();\n\n    if (points != null) {\n      if (typeof points === 'string') {\n        return Polyline.parse(points);\n      }\n\n      this.points = points.map(p => Point.create(p));\n    } else {\n      this.points = [];\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return Polyline.toStringTag;\n  }\n\n  get start() {\n    if (this.points.length === 0) {\n      return null;\n    }\n\n    return this.points[0];\n  }\n\n  get end() {\n    if (this.points.length === 0) {\n      return null;\n    }\n\n    return this.points[this.points.length - 1];\n  }\n\n  scale(sx, sy) {\n    let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    this.points.forEach(p => p.scale(sx, sy, origin));\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.points.forEach(p => p.rotate(angle, origin));\n    return this;\n  }\n\n  translate(dx, dy) {\n    const t = Point.create(dx, dy);\n    this.points.forEach(p => p.translate(t.x, t.y));\n    return this;\n  }\n\n  bbox() {\n    if (this.points.length === 0) {\n      return new Rectangle();\n    }\n\n    let x1 = Infinity;\n    let x2 = -Infinity;\n    let y1 = Infinity;\n    let y2 = -Infinity;\n    const points = this.points;\n\n    for (let i = 0, ii = points.length; i < ii; i += 1) {\n      const point = points[i];\n      const x = point.x;\n      const y = point.y;\n      if (x < x1) x1 = x;\n      if (x > x2) x2 = x;\n      if (y < y1) y1 = y;\n      if (y > y2) y2 = y;\n    }\n\n    return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n  }\n\n  closestPoint(p) {\n    const cpLength = this.closestPointLength(p);\n    return this.pointAtLength(cpLength);\n  }\n\n  closestPointLength(p) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0 || count === 1) {\n      return 0;\n    }\n\n    let length = 0;\n    let cpLength = 0;\n    let minSqrDistance = Infinity;\n\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const line = new Line(points[i], points[i + 1]);\n      const lineLength = line.length();\n      const cpNormalizedLength = line.closestPointNormalizedLength(p);\n      const cp = line.pointAt(cpNormalizedLength);\n      const sqrDistance = cp.squaredDistance(p);\n\n      if (sqrDistance < minSqrDistance) {\n        minSqrDistance = sqrDistance;\n        cpLength = length + cpNormalizedLength * lineLength;\n      }\n\n      length += lineLength;\n    }\n\n    return cpLength;\n  }\n\n  closestPointNormalizedLength(p) {\n    const cpLength = this.closestPointLength(p);\n\n    if (cpLength === 0) {\n      return 0;\n    }\n\n    const length = this.length();\n\n    if (length === 0) {\n      return 0;\n    }\n\n    return cpLength / length;\n  }\n\n  closestPointTangent(p) {\n    const cpLength = this.closestPointLength(p);\n    return this.tangentAtLength(cpLength);\n  }\n\n  containsPoint(p) {\n    if (this.points.length === 0) {\n      return false;\n    }\n\n    const ref = Point.clone(p);\n    const x = ref.x;\n    const y = ref.y;\n    const points = this.points;\n    const count = points.length;\n    let startIndex = count - 1;\n    let intersectionCount = 0;\n\n    for (let endIndex = 0; endIndex < count; endIndex += 1) {\n      const start = points[startIndex];\n      const end = points[endIndex];\n\n      if (ref.equals(start)) {\n        return true;\n      }\n\n      const segment = new Line(start, end);\n\n      if (segment.containsPoint(p)) {\n        return true;\n      } // do we have an intersection?\n\n\n      if (y <= start.y && y > end.y || y > start.y && y <= end.y) {\n        // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n        // (when `y === start.y === end.y`)\n        // this conditional branch IS entered when `segment` touches `ray` at only one point\n        // (e.g. when `y === start.y !== end.y`)\n        // since this branch is entered again for the following segment, the two touches cancel out\n        const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n\n        if (xDifference >= 0) {\n          // segment lies at least partially to the right of `p`\n          const rayEnd = new Point(x + xDifference, y); // right\n\n          const ray = new Line(p, rayEnd);\n\n          if (segment.intersectsWithLine(ray)) {\n            // an intersection was detected to the right of `p`\n            intersectionCount += 1;\n          }\n        } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n\n      } // move to check the next polyline segment\n\n\n      startIndex = endIndex;\n    } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n    return intersectionCount % 2 === 1;\n  }\n\n  intersectsWithLine(line) {\n    const intersections = [];\n\n    for (let i = 0, n = this.points.length - 1; i < n; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      const int = line.intersectsWithLine(new Line(a, b));\n\n      if (int) {\n        intersections.push(int);\n      }\n    }\n\n    return intersections.length > 0 ? intersections : null;\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      const line = new Line(a, b);\n\n      if (line.isDifferentiable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  length() {\n    let len = 0;\n\n    for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n      const a = this.points[i];\n      const b = this.points[i + 1];\n      len += a.distance(b);\n    }\n\n    return len;\n  }\n\n  pointAt(ratio) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    if (count === 1) {\n      return points[0].clone();\n    }\n\n    if (ratio <= 0) {\n      return points[0].clone();\n    }\n\n    if (ratio >= 1) {\n      return points[count - 1].clone();\n    }\n\n    const total = this.length();\n    const length = total * ratio;\n    return this.pointAtLength(length);\n  }\n\n  pointAtLength(length) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    if (count === 1) {\n      return points[0].clone();\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    let tmp = 0;\n\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const a = points[index];\n      const b = points[index + 1];\n      const l = new Line(a, b);\n      const d = a.distance(b);\n\n      if (length <= tmp + d) {\n        return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));\n      }\n\n      tmp += d;\n    }\n\n    const lastPoint = fromStart ? points[count - 1] : points[0];\n    return lastPoint.clone();\n  }\n\n  tangentAt(ratio) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0 || count === 1) {\n      return null;\n    }\n\n    if (ratio < 0) {\n      ratio = 0; // eslint-disable-line\n    }\n\n    if (ratio > 1) {\n      ratio = 1; // eslint-disable-line\n    }\n\n    const total = this.length();\n    const length = total * ratio;\n    return this.tangentAtLength(length);\n  }\n\n  tangentAtLength(length) {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0 || count === 1) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    let lastValidLine;\n    let tmp = 0;\n\n    for (let i = 0, ii = count - 1; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const a = points[index];\n      const b = points[index + 1];\n      const l = new Line(a, b);\n      const d = a.distance(b);\n\n      if (l.isDifferentiable()) {\n        // has a tangent line (line length is not 0)\n        if (length <= tmp + d) {\n          return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));\n        }\n\n        lastValidLine = l;\n      }\n\n      tmp += d;\n    }\n\n    if (lastValidLine) {\n      const ratio = fromStart ? 1 : 0;\n      return lastValidLine.tangentAt(ratio);\n    }\n\n    return null;\n  }\n\n  simplify() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const points = this.points; // we need at least 3 points\n\n    if (points.length < 3) {\n      return this;\n    }\n\n    const threshold = options.threshold || 0; // start at the beginning of the polyline and go forward\n\n    let currentIndex = 0; // we need at least one intermediate point (3 points) in every iteration\n    // as soon as that stops being true, we know we reached the end of the polyline\n\n    while (points[currentIndex + 2]) {\n      const firstIndex = currentIndex;\n      const middleIndex = currentIndex + 1;\n      const lastIndex = currentIndex + 2;\n      const firstPoint = points[firstIndex];\n      const middlePoint = points[middleIndex];\n      const lastPoint = points[lastIndex];\n      const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n\n      const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n\n      const closestPointDistance = closestPoint.distance(middlePoint);\n\n      if (closestPointDistance <= threshold) {\n        // middle point is close enough to the chord = simplify\n        // 1) remove middle point:\n        points.splice(middleIndex, 1); // 2) in next iteration, investigate the newly-created triplet of points\n        //    - do not change `currentIndex`\n        //    = (first point stays, point after removed point becomes middle point)\n      } else {\n        // middle point is far from the chord\n        // 1) preserve middle point\n        // 2) in next iteration, move `currentIndex` by one step:\n        currentIndex += 1; //    = (point after first point becomes first point)\n      }\n    } // `points` array was modified in-place\n\n\n    return this;\n  }\n\n  toHull() {\n    const points = this.points;\n    const count = points.length;\n\n    if (count === 0) {\n      return new Polyline();\n    } // Step 1: find the starting point -- point with\n    // the lowest y (if equality, highest x).\n\n\n    let startPoint = points[0];\n\n    for (let i = 1; i < count; i += 1) {\n      if (points[i].y < startPoint.y) {\n        startPoint = points[i];\n      } else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n        startPoint = points[i];\n      }\n    } // Step 2: sort the list of points by angle between line\n    // from start point to current point and the x-axis (theta).\n    // Step 2a: create the point records = [point, originalIndex, angle]\n\n\n    const sortedRecords = [];\n\n    for (let i = 0; i < count; i += 1) {\n      let angle = startPoint.theta(points[i]);\n\n      if (angle === 0) {\n        // Give highest angle to start point.\n        // The start point will end up at end of sorted list.\n        // The start point will end up at beginning of hull points list.\n        angle = 360;\n      }\n\n      sortedRecords.push([points[i], i, angle]);\n    } // Step 2b: sort the list in place\n\n\n    sortedRecords.sort((record1, record2) => {\n      let ret = record1[2] - record2[2];\n\n      if (ret === 0) {\n        ret = record2[1] - record1[1];\n      }\n\n      return ret;\n    }); // Step 2c: duplicate start record from the top of\n    // the stack to the bottom of the stack.\n\n    if (sortedRecords.length > 2) {\n      const startPoint = sortedRecords[sortedRecords.length - 1];\n      sortedRecords.unshift(startPoint);\n    } // Step 3\n    // ------\n    // Step 3a: go through sorted points in order and find those with\n    // right turns, and we want to get our results in clockwise order.\n    // Dictionary of points with left turns - cannot be on the hull.\n\n\n    const insidePoints = {}; // Stack of records with right turns - hull point candidates.\n\n    const hullRecords = [];\n\n    const getKey = record => `${record[0].toString()}@${record[1]}`;\n\n    while (sortedRecords.length !== 0) {\n      const currentRecord = sortedRecords.pop();\n      const currentPoint = currentRecord[0]; // Check if point has already been discarded.\n\n      if (insidePoints[getKey(currentRecord)]) {\n        continue;\n      }\n\n      let correctTurnFound = false;\n\n      while (!correctTurnFound) {\n        if (hullRecords.length < 2) {\n          // Not enough points for comparison, just add current point.\n          hullRecords.push(currentRecord);\n          correctTurnFound = true;\n        } else {\n          const lastHullRecord = hullRecords.pop();\n          const lastHullPoint = lastHullRecord[0];\n          const secondLastHullRecord = hullRecords.pop();\n          const secondLastHullPoint = secondLastHullRecord[0];\n          const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n\n          if (crossProduct < 0) {\n            // Found a right turn.\n            hullRecords.push(secondLastHullRecord);\n            hullRecords.push(lastHullRecord);\n            hullRecords.push(currentRecord);\n            correctTurnFound = true;\n          } else if (crossProduct === 0) {\n            // the three points are collinear\n            // three options:\n            // there may be a 180 or 0 degree angle at lastHullPoint\n            // or two of the three points are coincident\n            // we have to take rounding errors into account\n            const THRESHOLD = 1e-10;\n            const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n\n            if (Math.abs(angleBetween - 180) < THRESHOLD) {\n              // rouding around 180 to 180\n              // if the cross product is 0 because the angle is 180 degrees\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n              hullRecords.push(secondLastHullRecord); // do not do anything with current point\n              // correct turn not found\n            } else if (lastHullPoint.equals(currentPoint) || secondLastHullPoint.equals(lastHullPoint)) {\n              // if the cross product is 0 because two points are the same\n              // discard last hull point (add to insidePoints)\n              // insidePoints.unshift(lastHullPoint);\n              insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter)\n\n              hullRecords.push(secondLastHullRecord); // do not do anything with current point\n              // correct turn not found\n            } else if (Math.abs((angleBetween + 1) % 360 - 1) < THRESHOLD) {\n              // rounding around 0 and 360 to 0\n              // if the cross product is 0 because the angle is 0 degrees\n              // remove last hull point from hull BUT do not discard it\n              // reenter second-to-last hull point (will be last at next iter)\n              hullRecords.push(secondLastHullRecord); // put last hull point back into the sorted point records list\n\n              sortedRecords.push(lastHullRecord); // we are switching the order of the 0deg and 180deg points\n              // correct turn not found\n            }\n          } else {\n            // found a left turn\n            // discard last hull point (add to insidePoints)\n            // insidePoints.unshift(lastHullPoint);\n            insidePoints[getKey(lastHullRecord)] = lastHullPoint; // reenter second-to-last hull point (will be last at next iter of loop)\n\n            hullRecords.push(secondLastHullRecord); // do not do anything with current point\n            // correct turn not found\n          }\n        }\n      }\n    } // At this point, hullPointRecords contains the output points in clockwise order\n    // the points start with lowest-y,highest-x startPoint, and end at the same point\n    // Step 3b: remove duplicated startPointRecord from the end of the array\n\n\n    if (hullRecords.length > 2) {\n      hullRecords.pop();\n    } // Step 4: find the lowest originalIndex record and put it at the beginning of hull\n\n\n    let lowestHullIndex; // the lowest originalIndex on the hull\n\n    let indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n\n    for (let i = 0, n = hullRecords.length; i < n; i += 1) {\n      const currentHullIndex = hullRecords[i][1];\n\n      if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n        lowestHullIndex = currentHullIndex;\n        indexOfLowestHullIndexRecord = i;\n      }\n    }\n\n    let hullPointRecordsReordered = [];\n\n    if (indexOfLowestHullIndexRecord > 0) {\n      const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);\n      const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);\n      hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n    } else {\n      hullPointRecordsReordered = hullRecords;\n    }\n\n    const hullPoints = [];\n\n    for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {\n      hullPoints.push(hullPointRecordsReordered[i][0]);\n    }\n\n    return new Polyline(hullPoints);\n  }\n\n  equals(p) {\n    if (p == null) {\n      return false;\n    }\n\n    if (p.points.length !== this.points.length) {\n      return false;\n    }\n\n    return p.points.every((a, i) => a.equals(this.points[i]));\n  }\n\n  clone() {\n    return new Polyline(this.points.map(p => p.clone()));\n  }\n\n  toJSON() {\n    return this.points.map(p => p.toJSON());\n  }\n\n  serialize() {\n    return this.points.map(p => `${p.x}, ${p.y}`).join(' ');\n  }\n\n}\n\n(function (Polyline) {\n  Polyline.toStringTag = `X6.Geometry.${Polyline.name}`;\n\n  function isPolyline(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Polyline) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const polyline = instance;\n\n    if ((tag == null || tag === Polyline.toStringTag) && typeof polyline.toHull === 'function' && typeof polyline.simplify === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Polyline.isPolyline = isPolyline;\n})(Polyline || (Polyline = {}));\n\n(function (Polyline) {\n  function parse(svgString) {\n    const str = svgString.trim();\n\n    if (str === '') {\n      return new Polyline();\n    }\n\n    const points = [];\n    const coords = str.split(/\\s*,\\s*|\\s+/);\n\n    for (let i = 0, ii = coords.length; i < ii; i += 2) {\n      points.push({\n        x: +coords[i],\n        y: +coords[i + 1]\n      });\n    }\n\n    return new Polyline(points);\n  }\n\n  Polyline.parse = parse;\n})(Polyline || (Polyline = {}));","map":{"version":3,"sources":["../../src/geometry/polyline.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Line } from './line';\nimport { Geometry } from './geometry';\nexport class Polyline extends Geometry {\n    constructor(points) {\n        super();\n        if (points != null) {\n            if (typeof points === 'string') {\n                return Polyline.parse(points);\n            }\n            this.points = points.map((p) => Point.create(p));\n        }\n        else {\n            this.points = [];\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return Polyline.toStringTag;\n    }\n    get start() {\n        if (this.points.length === 0) {\n            return null;\n        }\n        return this.points[0];\n    }\n    get end() {\n        if (this.points.length === 0) {\n            return null;\n        }\n        return this.points[this.points.length - 1];\n    }\n    scale(sx, sy, origin = new Point()) {\n        this.points.forEach((p) => p.scale(sx, sy, origin));\n        return this;\n    }\n    rotate(angle, origin) {\n        this.points.forEach((p) => p.rotate(angle, origin));\n        return this;\n    }\n    translate(dx, dy) {\n        const t = Point.create(dx, dy);\n        this.points.forEach((p) => p.translate(t.x, t.y));\n        return this;\n    }\n    bbox() {\n        if (this.points.length === 0) {\n            return new Rectangle();\n        }\n        let x1 = Infinity;\n        let x2 = -Infinity;\n        let y1 = Infinity;\n        let y2 = -Infinity;\n        const points = this.points;\n        for (let i = 0, ii = points.length; i < ii; i += 1) {\n            const point = points[i];\n            const x = point.x;\n            const y = point.y;\n            if (x < x1)\n                x1 = x;\n            if (x > x2)\n                x2 = x;\n            if (y < y1)\n                y1 = y;\n            if (y > y2)\n                y2 = y;\n        }\n        return new Rectangle(x1, y1, x2 - x1, y2 - y1);\n    }\n    closestPoint(p) {\n        const cpLength = this.closestPointLength(p);\n        return this.pointAtLength(cpLength);\n    }\n    closestPointLength(p) {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0 || count === 1) {\n            return 0;\n        }\n        let length = 0;\n        let cpLength = 0;\n        let minSqrDistance = Infinity;\n        for (let i = 0, ii = count - 1; i < ii; i += 1) {\n            const line = new Line(points[i], points[i + 1]);\n            const lineLength = line.length();\n            const cpNormalizedLength = line.closestPointNormalizedLength(p);\n            const cp = line.pointAt(cpNormalizedLength);\n            const sqrDistance = cp.squaredDistance(p);\n            if (sqrDistance < minSqrDistance) {\n                minSqrDistance = sqrDistance;\n                cpLength = length + cpNormalizedLength * lineLength;\n            }\n            length += lineLength;\n        }\n        return cpLength;\n    }\n    closestPointNormalizedLength(p) {\n        const cpLength = this.closestPointLength(p);\n        if (cpLength === 0) {\n            return 0;\n        }\n        const length = this.length();\n        if (length === 0) {\n            return 0;\n        }\n        return cpLength / length;\n    }\n    closestPointTangent(p) {\n        const cpLength = this.closestPointLength(p);\n        return this.tangentAtLength(cpLength);\n    }\n    containsPoint(p) {\n        if (this.points.length === 0) {\n            return false;\n        }\n        const ref = Point.clone(p);\n        const x = ref.x;\n        const y = ref.y;\n        const points = this.points;\n        const count = points.length;\n        let startIndex = count - 1;\n        let intersectionCount = 0;\n        for (let endIndex = 0; endIndex < count; endIndex += 1) {\n            const start = points[startIndex];\n            const end = points[endIndex];\n            if (ref.equals(start)) {\n                return true;\n            }\n            const segment = new Line(start, end);\n            if (segment.containsPoint(p)) {\n                return true;\n            }\n            // do we have an intersection?\n            if ((y <= start.y && y > end.y) || (y > start.y && y <= end.y)) {\n                // this conditional branch IS NOT entered when `segment` is collinear/coincident with `ray`\n                // (when `y === start.y === end.y`)\n                // this conditional branch IS entered when `segment` touches `ray` at only one point\n                // (e.g. when `y === start.y !== end.y`)\n                // since this branch is entered again for the following segment, the two touches cancel out\n                const xDifference = start.x - x > end.x - x ? start.x - x : end.x - x;\n                if (xDifference >= 0) {\n                    // segment lies at least partially to the right of `p`\n                    const rayEnd = new Point(x + xDifference, y); // right\n                    const ray = new Line(p, rayEnd);\n                    if (segment.intersectsWithLine(ray)) {\n                        // an intersection was detected to the right of `p`\n                        intersectionCount += 1;\n                    }\n                } // else: `segment` lies completely to the left of `p` (i.e. no intersection to the right)\n            }\n            // move to check the next polyline segment\n            startIndex = endIndex;\n        }\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return intersectionCount % 2 === 1;\n    }\n    intersectsWithLine(line) {\n        const intersections = [];\n        for (let i = 0, n = this.points.length - 1; i < n; i += 1) {\n            const a = this.points[i];\n            const b = this.points[i + 1];\n            const int = line.intersectsWithLine(new Line(a, b));\n            if (int) {\n                intersections.push(int);\n            }\n        }\n        return intersections.length > 0 ? intersections : null;\n    }\n    isDifferentiable() {\n        for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n            const a = this.points[i];\n            const b = this.points[i + 1];\n            const line = new Line(a, b);\n            if (line.isDifferentiable()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    length() {\n        let len = 0;\n        for (let i = 0, ii = this.points.length - 1; i < ii; i += 1) {\n            const a = this.points[i];\n            const b = this.points[i + 1];\n            len += a.distance(b);\n        }\n        return len;\n    }\n    pointAt(ratio) {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0) {\n            return null;\n        }\n        if (count === 1) {\n            return points[0].clone();\n        }\n        if (ratio <= 0) {\n            return points[0].clone();\n        }\n        if (ratio >= 1) {\n            return points[count - 1].clone();\n        }\n        const total = this.length();\n        const length = total * ratio;\n        return this.pointAtLength(length);\n    }\n    pointAtLength(length) {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0) {\n            return null;\n        }\n        if (count === 1) {\n            return points[0].clone();\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        let tmp = 0;\n        for (let i = 0, ii = count - 1; i < ii; i += 1) {\n            const index = fromStart ? i : ii - 1 - i;\n            const a = points[index];\n            const b = points[index + 1];\n            const l = new Line(a, b);\n            const d = a.distance(b);\n            if (length <= tmp + d) {\n                return l.pointAtLength((fromStart ? 1 : -1) * (length - tmp));\n            }\n            tmp += d;\n        }\n        const lastPoint = fromStart ? points[count - 1] : points[0];\n        return lastPoint.clone();\n    }\n    tangentAt(ratio) {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0 || count === 1) {\n            return null;\n        }\n        if (ratio < 0) {\n            ratio = 0; // eslint-disable-line\n        }\n        if (ratio > 1) {\n            ratio = 1; // eslint-disable-line\n        }\n        const total = this.length();\n        const length = total * ratio;\n        return this.tangentAtLength(length);\n    }\n    tangentAtLength(length) {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0 || count === 1) {\n            return null;\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        let lastValidLine;\n        let tmp = 0;\n        for (let i = 0, ii = count - 1; i < ii; i += 1) {\n            const index = fromStart ? i : ii - 1 - i;\n            const a = points[index];\n            const b = points[index + 1];\n            const l = new Line(a, b);\n            const d = a.distance(b);\n            if (l.isDifferentiable()) {\n                // has a tangent line (line length is not 0)\n                if (length <= tmp + d) {\n                    return l.tangentAtLength((fromStart ? 1 : -1) * (length - tmp));\n                }\n                lastValidLine = l;\n            }\n            tmp += d;\n        }\n        if (lastValidLine) {\n            const ratio = fromStart ? 1 : 0;\n            return lastValidLine.tangentAt(ratio);\n        }\n        return null;\n    }\n    simplify(\n    // TODO: Accept startIndex and endIndex to specify where to start and end simplification\n    options = {}) {\n        const points = this.points;\n        // we need at least 3 points\n        if (points.length < 3) {\n            return this;\n        }\n        const threshold = options.threshold || 0;\n        // start at the beginning of the polyline and go forward\n        let currentIndex = 0;\n        // we need at least one intermediate point (3 points) in every iteration\n        // as soon as that stops being true, we know we reached the end of the polyline\n        while (points[currentIndex + 2]) {\n            const firstIndex = currentIndex;\n            const middleIndex = currentIndex + 1;\n            const lastIndex = currentIndex + 2;\n            const firstPoint = points[firstIndex];\n            const middlePoint = points[middleIndex];\n            const lastPoint = points[lastIndex];\n            const chord = new Line(firstPoint, lastPoint); // = connection between first and last point\n            const closestPoint = chord.closestPoint(middlePoint); // = closest point on chord from middle point\n            const closestPointDistance = closestPoint.distance(middlePoint);\n            if (closestPointDistance <= threshold) {\n                // middle point is close enough to the chord = simplify\n                // 1) remove middle point:\n                points.splice(middleIndex, 1);\n                // 2) in next iteration, investigate the newly-created triplet of points\n                //    - do not change `currentIndex`\n                //    = (first point stays, point after removed point becomes middle point)\n            }\n            else {\n                // middle point is far from the chord\n                // 1) preserve middle point\n                // 2) in next iteration, move `currentIndex` by one step:\n                currentIndex += 1;\n                //    = (point after first point becomes first point)\n            }\n        }\n        // `points` array was modified in-place\n        return this;\n    }\n    toHull() {\n        const points = this.points;\n        const count = points.length;\n        if (count === 0) {\n            return new Polyline();\n        }\n        // Step 1: find the starting point -- point with\n        // the lowest y (if equality, highest x).\n        let startPoint = points[0];\n        for (let i = 1; i < count; i += 1) {\n            if (points[i].y < startPoint.y) {\n                startPoint = points[i];\n            }\n            else if (points[i].y === startPoint.y && points[i].x > startPoint.x) {\n                startPoint = points[i];\n            }\n        }\n        // Step 2: sort the list of points by angle between line\n        // from start point to current point and the x-axis (theta).\n        // Step 2a: create the point records = [point, originalIndex, angle]\n        const sortedRecords = [];\n        for (let i = 0; i < count; i += 1) {\n            let angle = startPoint.theta(points[i]);\n            if (angle === 0) {\n                // Give highest angle to start point.\n                // The start point will end up at end of sorted list.\n                // The start point will end up at beginning of hull points list.\n                angle = 360;\n            }\n            sortedRecords.push([points[i], i, angle]);\n        }\n        // Step 2b: sort the list in place\n        sortedRecords.sort((record1, record2) => {\n            let ret = record1[2] - record2[2];\n            if (ret === 0) {\n                ret = record2[1] - record1[1];\n            }\n            return ret;\n        });\n        // Step 2c: duplicate start record from the top of\n        // the stack to the bottom of the stack.\n        if (sortedRecords.length > 2) {\n            const startPoint = sortedRecords[sortedRecords.length - 1];\n            sortedRecords.unshift(startPoint);\n        }\n        // Step 3\n        // ------\n        // Step 3a: go through sorted points in order and find those with\n        // right turns, and we want to get our results in clockwise order.\n        // Dictionary of points with left turns - cannot be on the hull.\n        const insidePoints = {};\n        // Stack of records with right turns - hull point candidates.\n        const hullRecords = [];\n        const getKey = (record) => `${record[0].toString()}@${record[1]}`;\n        while (sortedRecords.length !== 0) {\n            const currentRecord = sortedRecords.pop();\n            const currentPoint = currentRecord[0];\n            // Check if point has already been discarded.\n            if (insidePoints[getKey(currentRecord)]) {\n                continue;\n            }\n            let correctTurnFound = false;\n            while (!correctTurnFound) {\n                if (hullRecords.length < 2) {\n                    // Not enough points for comparison, just add current point.\n                    hullRecords.push(currentRecord);\n                    correctTurnFound = true;\n                }\n                else {\n                    const lastHullRecord = hullRecords.pop();\n                    const lastHullPoint = lastHullRecord[0];\n                    const secondLastHullRecord = hullRecords.pop();\n                    const secondLastHullPoint = secondLastHullRecord[0];\n                    const crossProduct = secondLastHullPoint.cross(lastHullPoint, currentPoint);\n                    if (crossProduct < 0) {\n                        // Found a right turn.\n                        hullRecords.push(secondLastHullRecord);\n                        hullRecords.push(lastHullRecord);\n                        hullRecords.push(currentRecord);\n                        correctTurnFound = true;\n                    }\n                    else if (crossProduct === 0) {\n                        // the three points are collinear\n                        // three options:\n                        // there may be a 180 or 0 degree angle at lastHullPoint\n                        // or two of the three points are coincident\n                        // we have to take rounding errors into account\n                        const THRESHOLD = 1e-10;\n                        const angleBetween = lastHullPoint.angleBetween(secondLastHullPoint, currentPoint);\n                        if (Math.abs(angleBetween - 180) < THRESHOLD) {\n                            // rouding around 180 to 180\n                            // if the cross product is 0 because the angle is 180 degrees\n                            // discard last hull point (add to insidePoints)\n                            // insidePoints.unshift(lastHullPoint);\n                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;\n                            // reenter second-to-last hull point (will be last at next iter)\n                            hullRecords.push(secondLastHullRecord);\n                            // do not do anything with current point\n                            // correct turn not found\n                        }\n                        else if (lastHullPoint.equals(currentPoint) ||\n                            secondLastHullPoint.equals(lastHullPoint)) {\n                            // if the cross product is 0 because two points are the same\n                            // discard last hull point (add to insidePoints)\n                            // insidePoints.unshift(lastHullPoint);\n                            insidePoints[getKey(lastHullRecord)] = lastHullPoint;\n                            // reenter second-to-last hull point (will be last at next iter)\n                            hullRecords.push(secondLastHullRecord);\n                            // do not do anything with current point\n                            // correct turn not found\n                        }\n                        else if (Math.abs(((angleBetween + 1) % 360) - 1) < THRESHOLD) {\n                            // rounding around 0 and 360 to 0\n                            // if the cross product is 0 because the angle is 0 degrees\n                            // remove last hull point from hull BUT do not discard it\n                            // reenter second-to-last hull point (will be last at next iter)\n                            hullRecords.push(secondLastHullRecord);\n                            // put last hull point back into the sorted point records list\n                            sortedRecords.push(lastHullRecord);\n                            // we are switching the order of the 0deg and 180deg points\n                            // correct turn not found\n                        }\n                    }\n                    else {\n                        // found a left turn\n                        // discard last hull point (add to insidePoints)\n                        // insidePoints.unshift(lastHullPoint);\n                        insidePoints[getKey(lastHullRecord)] = lastHullPoint;\n                        // reenter second-to-last hull point (will be last at next iter of loop)\n                        hullRecords.push(secondLastHullRecord);\n                        // do not do anything with current point\n                        // correct turn not found\n                    }\n                }\n            }\n        }\n        // At this point, hullPointRecords contains the output points in clockwise order\n        // the points start with lowest-y,highest-x startPoint, and end at the same point\n        // Step 3b: remove duplicated startPointRecord from the end of the array\n        if (hullRecords.length > 2) {\n            hullRecords.pop();\n        }\n        // Step 4: find the lowest originalIndex record and put it at the beginning of hull\n        let lowestHullIndex; // the lowest originalIndex on the hull\n        let indexOfLowestHullIndexRecord = -1; // the index of the record with lowestHullIndex\n        for (let i = 0, n = hullRecords.length; i < n; i += 1) {\n            const currentHullIndex = hullRecords[i][1];\n            if (lowestHullIndex === undefined || currentHullIndex < lowestHullIndex) {\n                lowestHullIndex = currentHullIndex;\n                indexOfLowestHullIndexRecord = i;\n            }\n        }\n        let hullPointRecordsReordered = [];\n        if (indexOfLowestHullIndexRecord > 0) {\n            const newFirstChunk = hullRecords.slice(indexOfLowestHullIndexRecord);\n            const newSecondChunk = hullRecords.slice(0, indexOfLowestHullIndexRecord);\n            hullPointRecordsReordered = newFirstChunk.concat(newSecondChunk);\n        }\n        else {\n            hullPointRecordsReordered = hullRecords;\n        }\n        const hullPoints = [];\n        for (let i = 0, n = hullPointRecordsReordered.length; i < n; i += 1) {\n            hullPoints.push(hullPointRecordsReordered[i][0]);\n        }\n        return new Polyline(hullPoints);\n    }\n    equals(p) {\n        if (p == null) {\n            return false;\n        }\n        if (p.points.length !== this.points.length) {\n            return false;\n        }\n        return p.points.every((a, i) => a.equals(this.points[i]));\n    }\n    clone() {\n        return new Polyline(this.points.map((p) => p.clone()));\n    }\n    toJSON() {\n        return this.points.map((p) => p.toJSON());\n    }\n    serialize() {\n        return this.points.map((p) => `${p.x}, ${p.y}`).join(' ');\n    }\n}\n(function (Polyline) {\n    Polyline.toStringTag = `X6.Geometry.${Polyline.name}`;\n    function isPolyline(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Polyline) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const polyline = instance;\n        if ((tag == null || tag === Polyline.toStringTag) &&\n            typeof polyline.toHull === 'function' &&\n            typeof polyline.simplify === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Polyline.isPolyline = isPolyline;\n})(Polyline || (Polyline = {}));\n(function (Polyline) {\n    function parse(svgString) {\n        const str = svgString.trim();\n        if (str === '') {\n            return new Polyline();\n        }\n        const points = [];\n        const coords = str.split(/\\s*,\\s*|\\s+/);\n        for (let i = 0, ii = coords.length; i < ii; i += 2) {\n            points.push({ x: +coords[i], y: +coords[i + 1] });\n        }\n        return new Polyline(points);\n    }\n    Polyline.parse = parse;\n})(Polyline || (Polyline = {}));\n//# sourceMappingURL=polyline.js.map"]},"metadata":{},"sourceType":"module"}