{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __metadata = this && this.__metadata || function (k, v) {\n  if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n/* eslint-disable @typescript-eslint/no-redeclare */\n\n\nimport 'reflect-metadata';\n/** Application 扩展依赖 */\n\nimport { ICommandHandler, IGraphCommandFactory, IGraphCommandContribution } from '../command/interface';\nimport { inject, singleton } from 'mana-syringe';\nimport { IHookContribution } from '../hooks/interface';\nimport { Disposable, DisposableCollection } from '../common/disposable';\n/** Commands */\n\nimport { registerNodeCommand, hookhubList as nodeHooks } from './node';\nimport { registerGraphCommand, hookhubList as graphHooks } from './graph';\nimport { registerEdgeCommand, hookhubList as edgeHooks } from './edge';\nimport { registerGroupCommand, hookhubList as groupHooks } from './group';\nimport { registerModelServiceCommand, hookhubList as observablesHooks } from './models';\n/** Command Hooks*/\n\nimport { HookHub } from '@antv/xflow-hook';\nimport { CommandConfig } from './config';\n/** Commands 配置项目*/\n\nconst hookhubList = [...nodeHooks, ...edgeHooks, ...groupHooks, ...graphHooks, ...observablesHooks];\n\nconst defaultHookFactory = () => new HookHub();\n\nlet XFlowCommandContribution = class XFlowCommandContribution {\n  constructor() {\n    /** 注册钩子 */\n    this.registerHook = hooks => __awaiter(this, void 0, void 0, function* () {\n      const d = hooks.x6Events.registerHook({\n        name: 'bind group node move event',\n        handler: args => __awaiter(this, void 0, void 0, function* () {\n          const event = {\n            eventName: 'node:moving',\n            callback: _ref => {\n              let {\n                node\n              } = _ref;\n              return __awaiter(this, void 0, void 0, function* () {\n                const isGroup = node.prop('isGroup');\n\n                if (isGroup) {\n                  node.prop('originPosition', node.getPosition());\n                  return;\n                }\n\n                const graph = node.model.graph;\n                const {\n                  group: groupId\n                } = node.getData();\n                const group = graph.getNodes().find(cell => cell.id === groupId);\n\n                if (!group) {\n                  return;\n                }\n\n                const isCollapsed = group.getProp('isCollapsed');\n                let originSize = group.getProp('originSize');\n                let hasChange = false;\n\n                if (originSize == null) {\n                  originSize = group.size();\n                  group.prop('originSize', originSize);\n                }\n\n                let originPosition = group.prop('originPosition');\n\n                if (originPosition == null) {\n                  originPosition = group.getPosition();\n                  group.prop('originPosition', originPosition);\n                }\n\n                let x = originPosition.x;\n                let y = originPosition.y;\n                let cornerX = originPosition.x + originSize.width;\n                let cornerY = originPosition.y + originSize.height;\n                const childs = group.getChildren();\n\n                if (childs) {\n                  childs.forEach(child => {\n                    const bbox = child.getBBox().inflate(12);\n                    const corner = bbox.getCorner();\n\n                    if (bbox.x < x) {\n                      x = bbox.x;\n                      hasChange = true;\n                    }\n\n                    if (bbox.y < y) {\n                      y = bbox.y;\n                      hasChange = true;\n                    }\n\n                    if (corner.x > cornerX) {\n                      cornerX = corner.x;\n                      hasChange = true;\n                    }\n\n                    if (corner.y > cornerY) {\n                      cornerY = corner.y;\n                      hasChange = true;\n                    }\n                  });\n                }\n\n                if (hasChange) {\n                  group.prop({\n                    position: {\n                      x,\n                      y\n                    },\n                    size: {\n                      width: cornerX - x,\n                      height: cornerY - y\n                    }\n                  });\n                  const groupData = Object.assign(Object.assign({}, group.getData()), {\n                    x,\n                    y,\n                    width: cornerX - x,\n                    height: cornerY - y\n                  });\n\n                  if (isCollapsed !== true) {\n                    groupData.groupChildrenSize = {\n                      width: cornerX - x,\n                      height: cornerY - y\n                    };\n                  }\n\n                  group.setData(groupData);\n                }\n                /**\n                 *  updateNodeData:\n                 *  1. 折叠时移动更新xy，size需要更新，childrenSize不变\n                 *  2. 展开时\n                 *      - 移动Group更新xy，size不需要更新，childrenSize不更新\n                 *      - 移动children, 更新xy, size childrenSize\n                 */\n\n              });\n            }\n          };\n          args.push(event);\n        })\n      });\n      return Disposable.create(() => {\n        d.dispose();\n      });\n    });\n    /** 注册钩子 */\n\n\n    this.registerHookHub = registry => __awaiter(this, void 0, void 0, function* () {\n      const toDispose = new DisposableCollection();\n      hookhubList.forEach(_ref2 => {\n        let {\n          hookKey,\n          createHook = defaultHookFactory\n        } = _ref2;\n        const d = registry.registerHookHub(hookKey, createHook());\n        toDispose.push(d);\n      });\n      this.commandConfig.getConfig().then(_ref3 => {\n        let {\n          getContributions\n        } = _ref3;\n        const CommandContributions = getContributions();\n        CommandContributions.forEach(_ref4 => {\n          let {\n            hookKey,\n            createHook = defaultHookFactory\n          } = _ref4;\n          const d = registry.registerHookHub(hookKey, createHook());\n          toDispose.push(d);\n        });\n      });\n      return toDispose;\n    });\n  }\n  /** 注册画布节点命令 */\n\n\n  registerGraphCommands(registry) {\n    /** 注册内置的命令 */\n    hookhubList.forEach(_ref5 => {\n      let {\n        command\n      } = _ref5;\n      registry.registerCommand(command, {\n        createCommand: this.commandFactory\n      });\n    });\n    /** 注册外部传入的命令 */\n\n    this.commandConfig.getConfig().then(_ref6 => {\n      let {\n        getContributions\n      } = _ref6;\n      const CommandContributions = getContributions();\n      CommandContributions.forEach(cmd => {\n        registry.registerCommand(cmd.command, {\n          createCommand: this.commandFactory\n        });\n      });\n    });\n  }\n\n};\n\n__decorate([inject(IGraphCommandFactory), __metadata(\"design:type\", Function)], XFlowCommandContribution.prototype, \"commandFactory\", void 0);\n\n__decorate([inject(CommandConfig), __metadata(\"design:type\", CommandConfig\n/** 注册画布节点命令 */\n)], XFlowCommandContribution.prototype, \"commandConfig\", void 0);\n\nXFlowCommandContribution = __decorate([singleton({\n  contrib: [IGraphCommandContribution, IHookContribution]\n})], XFlowCommandContribution);\nexport { XFlowCommandContribution };\nexport const registerXFlowCommandContribution = (register, commandConfig) => {\n  /** 扩展 用户自定义命令 */\n  const configContributions = commandConfig.getCommandContributions();\n  configContributions.forEach(execution => {\n    const {\n      CommandHandler,\n      command\n    } = execution;\n    register({\n      token: {\n        token: ICommandHandler,\n        named: command.id\n      },\n      useClass: CommandHandler\n    });\n  });\n  /** 扩展 Graph 命令 */\n\n  registerGraphCommand(register);\n  /** 扩展 Node 命令 */\n\n  registerNodeCommand(register);\n  /** 扩展 Edge 命令 */\n\n  registerEdgeCommand(register);\n  /** 扩展 Edge 命令 */\n\n  registerGroupCommand(register);\n  /** 扩展 Observable 命令 */\n\n  registerModelServiceCommand(register);\n  /** 注册 XFlowCommandContribution */\n\n  register(XFlowCommandContribution);\n};","map":{"version":3,"sources":["../../src/command-contributions/command-contribution.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __metadata = (this && this.__metadata) || function (k, v) {\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(k, v);\n};\nvar __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n/* eslint-disable @typescript-eslint/no-redeclare */\nimport 'reflect-metadata';\n/** Application 扩展依赖 */\nimport { ICommandHandler, IGraphCommandFactory, IGraphCommandContribution, } from '../command/interface';\nimport { inject, singleton } from 'mana-syringe';\nimport { IHookContribution } from '../hooks/interface';\nimport { Disposable, DisposableCollection } from '../common/disposable';\n/** Commands */\nimport { registerNodeCommand, hookhubList as nodeHooks } from './node';\nimport { registerGraphCommand, hookhubList as graphHooks } from './graph';\nimport { registerEdgeCommand, hookhubList as edgeHooks } from './edge';\nimport { registerGroupCommand, hookhubList as groupHooks } from './group';\nimport { registerModelServiceCommand, hookhubList as observablesHooks } from './models';\n/** Command Hooks*/\nimport { HookHub } from '@antv/xflow-hook';\nimport { CommandConfig } from './config';\n/** Commands 配置项目*/\nconst hookhubList = [...nodeHooks, ...edgeHooks, ...groupHooks, ...graphHooks, ...observablesHooks];\nconst defaultHookFactory = () => new HookHub();\nlet XFlowCommandContribution = class XFlowCommandContribution {\n    constructor() {\n        /** 注册钩子 */\n        this.registerHook = (hooks) => __awaiter(this, void 0, void 0, function* () {\n            const d = hooks.x6Events.registerHook({\n                name: 'bind group node move event',\n                handler: (args) => __awaiter(this, void 0, void 0, function* () {\n                    const event = {\n                        eventName: 'node:moving',\n                        callback: ({ node }) => __awaiter(this, void 0, void 0, function* () {\n                            const isGroup = node.prop('isGroup');\n                            if (isGroup) {\n                                node.prop('originPosition', node.getPosition());\n                                return;\n                            }\n                            const graph = node.model.graph;\n                            const { group: groupId } = node.getData();\n                            const group = graph.getNodes().find(cell => cell.id === groupId);\n                            if (!group) {\n                                return;\n                            }\n                            const isCollapsed = group.getProp('isCollapsed');\n                            let originSize = group.getProp('originSize');\n                            let hasChange = false;\n                            if (originSize == null) {\n                                originSize = group.size();\n                                group.prop('originSize', originSize);\n                            }\n                            let originPosition = group.prop('originPosition');\n                            if (originPosition == null) {\n                                originPosition = group.getPosition();\n                                group.prop('originPosition', originPosition);\n                            }\n                            let x = originPosition.x;\n                            let y = originPosition.y;\n                            let cornerX = originPosition.x + originSize.width;\n                            let cornerY = originPosition.y + originSize.height;\n                            const childs = group.getChildren();\n                            if (childs) {\n                                childs.forEach(child => {\n                                    const bbox = child.getBBox().inflate(12);\n                                    const corner = bbox.getCorner();\n                                    if (bbox.x < x) {\n                                        x = bbox.x;\n                                        hasChange = true;\n                                    }\n                                    if (bbox.y < y) {\n                                        y = bbox.y;\n                                        hasChange = true;\n                                    }\n                                    if (corner.x > cornerX) {\n                                        cornerX = corner.x;\n                                        hasChange = true;\n                                    }\n                                    if (corner.y > cornerY) {\n                                        cornerY = corner.y;\n                                        hasChange = true;\n                                    }\n                                });\n                            }\n                            if (hasChange) {\n                                group.prop({\n                                    position: { x, y },\n                                    size: { width: cornerX - x, height: cornerY - y },\n                                });\n                                const groupData = Object.assign(Object.assign({}, group.getData()), { x,\n                                    y, width: cornerX - x, height: cornerY - y });\n                                if (isCollapsed !== true) {\n                                    groupData.groupChildrenSize = { width: cornerX - x, height: cornerY - y };\n                                }\n                                group.setData(groupData);\n                            }\n                            /**\n                             *  updateNodeData:\n                             *  1. 折叠时移动更新xy，size需要更新，childrenSize不变\n                             *  2. 展开时\n                             *      - 移动Group更新xy，size不需要更新，childrenSize不更新\n                             *      - 移动children, 更新xy, size childrenSize\n                             */\n                        }),\n                    };\n                    args.push(event);\n                }),\n            });\n            return Disposable.create(() => {\n                d.dispose();\n            });\n        });\n        /** 注册钩子 */\n        this.registerHookHub = (registry) => __awaiter(this, void 0, void 0, function* () {\n            const toDispose = new DisposableCollection();\n            hookhubList.forEach(({ hookKey, createHook = defaultHookFactory }) => {\n                const d = registry.registerHookHub(hookKey, createHook());\n                toDispose.push(d);\n            });\n            this.commandConfig.getConfig().then(({ getContributions }) => {\n                const CommandContributions = getContributions();\n                CommandContributions.forEach(({ hookKey, createHook = defaultHookFactory }) => {\n                    const d = registry.registerHookHub(hookKey, createHook());\n                    toDispose.push(d);\n                });\n            });\n            return toDispose;\n        });\n    }\n    /** 注册画布节点命令 */\n    registerGraphCommands(registry) {\n        /** 注册内置的命令 */\n        hookhubList.forEach(({ command }) => {\n            registry.registerCommand(command, {\n                createCommand: this.commandFactory,\n            });\n        });\n        /** 注册外部传入的命令 */\n        this.commandConfig.getConfig().then(({ getContributions }) => {\n            const CommandContributions = getContributions();\n            CommandContributions.forEach(cmd => {\n                registry.registerCommand(cmd.command, {\n                    createCommand: this.commandFactory,\n                });\n            });\n        });\n    }\n};\n__decorate([\n    inject(IGraphCommandFactory),\n    __metadata(\"design:type\", Function)\n], XFlowCommandContribution.prototype, \"commandFactory\", void 0);\n__decorate([\n    inject(CommandConfig),\n    __metadata(\"design:type\", CommandConfig\n    /** 注册画布节点命令 */\n    )\n], XFlowCommandContribution.prototype, \"commandConfig\", void 0);\nXFlowCommandContribution = __decorate([\n    singleton({ contrib: [IGraphCommandContribution, IHookContribution] })\n], XFlowCommandContribution);\nexport { XFlowCommandContribution };\nexport const registerXFlowCommandContribution = (register, commandConfig) => {\n    /** 扩展 用户自定义命令 */\n    const configContributions = commandConfig.getCommandContributions();\n    configContributions.forEach(execution => {\n        const { CommandHandler, command } = execution;\n        register({\n            token: { token: ICommandHandler, named: command.id },\n            useClass: CommandHandler,\n        });\n    });\n    /** 扩展 Graph 命令 */\n    registerGraphCommand(register);\n    /** 扩展 Node 命令 */\n    registerNodeCommand(register);\n    /** 扩展 Edge 命令 */\n    registerEdgeCommand(register);\n    /** 扩展 Edge 命令 */\n    registerGroupCommand(register);\n    /** 扩展 Observable 命令 */\n    registerModelServiceCommand(register);\n    /** 注册 XFlowCommandContribution */\n    register(XFlowCommandContribution);\n};\n//# sourceMappingURL=command-contribution.js.map"]},"metadata":{},"sourceType":"module"}