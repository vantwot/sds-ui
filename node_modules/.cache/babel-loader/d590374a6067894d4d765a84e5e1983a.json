{"ast":null,"code":"function _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction getAnchorAlignment(anchor) {\n  var horizontalAlign = 0.5;\n  var verticalAlign = 0.5;\n\n  switch (anchor) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n      horizontalAlign = 1;\n      break;\n\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n      horizontalAlign = 0;\n      break;\n\n    default:\n      horizontalAlign = 0.5;\n  }\n\n  switch (anchor) {\n    case 'bottom':\n    case 'bottom-right':\n    case 'bottom-left':\n      verticalAlign = 1;\n      break;\n\n    case 'top':\n    case 'top-right':\n    case 'top-left':\n      verticalAlign = 0;\n      break;\n\n    default:\n      verticalAlign = 0.5;\n  }\n\n  return {\n    horizontalAlign: horizontalAlign,\n    verticalAlign: verticalAlign\n  };\n}\n\nfunction justifyLine(positionedGlyphs, glyphMap, start, end, justify) {\n  if (!justify) {\n    return;\n  }\n\n  var lastPositionedGlyph = positionedGlyphs[end];\n  var glyph = lastPositionedGlyph.glyph;\n\n  if (glyph) {\n    var lastAdvance = glyphMap[glyph].advance * lastPositionedGlyph.scale;\n    var lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;\n\n    for (var j = start; j <= end; j++) {\n      positionedGlyphs[j].x -= lineIndent;\n    }\n  }\n}\n\nfunction align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lineCount) {\n  var shiftX = (justify - horizontalAlign) * maxLineLength;\n  var shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;\n\n  var _iterator = _createForOfIteratorHelper(positionedGlyphs),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var glyphs = _step.value;\n      glyphs.x += shiftX;\n      glyphs.y += shiftY;\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n}\n\nfunction shapeLines(shaping, glyphMap, lines, lineHeight, textAnchor, textJustify, spacing) {\n  var yOffset = -8;\n  var x = 0;\n  var y = yOffset;\n  var maxLineLength = 0;\n  var positionedGlyphs = shaping.positionedGlyphs;\n  var justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;\n  var lineStartIndex = positionedGlyphs.length;\n  lines.forEach(function (line) {\n    line.split('').forEach(function (char) {\n      var glyph = glyphMap[char];\n      var baselineOffset = 0;\n\n      if (glyph) {\n        positionedGlyphs.push({\n          glyph: char,\n          x: x,\n          y: y + baselineOffset,\n          vertical: false,\n          scale: 1,\n          metrics: glyph\n        });\n        x += glyph.advance + spacing;\n      }\n    });\n\n    if (positionedGlyphs.length !== lineStartIndex) {\n      var lineLength = x - spacing;\n      maxLineLength = Math.max(lineLength, maxLineLength);\n      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n    }\n\n    x = 0;\n    y -= lineHeight + 5;\n  });\n\n  var _getAnchorAlignment = getAnchorAlignment(textAnchor),\n      horizontalAlign = _getAnchorAlignment.horizontalAlign,\n      verticalAlign = _getAnchorAlignment.verticalAlign;\n\n  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, lines.length);\n  var height = y - yOffset;\n  shaping.top += -verticalAlign * height;\n  shaping.bottom = shaping.top - height;\n  shaping.left += -horizontalAlign * maxLineLength;\n  shaping.right = shaping.left + maxLineLength;\n}\n\nfunction shapeIconFont(shaping, glyphMap, iconfonts, lineHeight, textAnchor, textJustify, spacing) {\n  var yOffset = -8;\n  var x = 0;\n  var y = yOffset;\n  var maxLineLength = 0;\n  var positionedGlyphs = shaping.positionedGlyphs;\n  var justify = textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;\n  var lineStartIndex = positionedGlyphs.length;\n  iconfonts.forEach(function (iconfont) {\n    var glyph = glyphMap[iconfont];\n    var baselineOffset = 0;\n\n    if (glyph) {\n      positionedGlyphs.push({\n        glyph: iconfont,\n        x: x,\n        y: y + baselineOffset,\n        vertical: false,\n        scale: 1,\n        metrics: glyph\n      });\n      x += glyph.advance + spacing;\n    }\n\n    if (positionedGlyphs.length !== lineStartIndex) {\n      var lineLength = x - spacing;\n      maxLineLength = Math.max(lineLength, maxLineLength);\n      justifyLine(positionedGlyphs, glyphMap, lineStartIndex, positionedGlyphs.length - 1, justify);\n    }\n\n    x = 0;\n    y -= lineHeight + 5;\n  });\n\n  var _getAnchorAlignment2 = getAnchorAlignment(textAnchor),\n      horizontalAlign = _getAnchorAlignment2.horizontalAlign,\n      verticalAlign = _getAnchorAlignment2.verticalAlign;\n\n  align(positionedGlyphs, justify, horizontalAlign, verticalAlign, maxLineLength, lineHeight, iconfonts.length);\n  var height = y - yOffset;\n  shaping.top += -verticalAlign * height;\n  shaping.bottom = shaping.top - height;\n  shaping.left += -horizontalAlign * maxLineLength;\n  shaping.right = shaping.left + maxLineLength;\n}\n\nexport function shapeText(text, glyphs, lineHeight, textAnchor, textJustify, spacing) {\n  var translate = arguments.length > 6 && arguments[6] !== undefined ? arguments[6] : [0, 0];\n  var isIconFont = arguments.length > 7 ? arguments[7] : undefined;\n  var lines = text.split('\\n');\n  var positionedGlyphs = [];\n  var shaping = {\n    positionedGlyphs: positionedGlyphs,\n    top: translate[1],\n    bottom: translate[1],\n    left: translate[0],\n    right: translate[0],\n    lineCount: lines.length,\n    text: text\n  };\n  isIconFont ? shapeIconFont(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing) : shapeLines(shaping, glyphs, lines, lineHeight, textAnchor, textJustify, spacing);\n\n  if (!positionedGlyphs.length) {\n    return false;\n  }\n\n  return shaping;\n}\nexport function getGlyphQuads(shaping) {\n  var textOffset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [0, 0];\n  var alongLine = arguments.length > 2 ? arguments[2] : undefined;\n  var _shaping$positionedGl = shaping.positionedGlyphs,\n      positionedGlyphs = _shaping$positionedGl === void 0 ? [] : _shaping$positionedGl;\n  var quads = [];\n\n  var _iterator2 = _createForOfIteratorHelper(positionedGlyphs),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var positionedGlyph = _step2.value;\n      var rect = positionedGlyph.metrics;\n      var rectBuffer = 4;\n      var halfAdvance = rect.advance * positionedGlyph.scale / 2;\n      var glyphOffset = alongLine ? [positionedGlyph.x + halfAdvance, positionedGlyph.y] : [0, 0];\n      var builtInOffset = alongLine ? [0, 0] : [positionedGlyph.x + halfAdvance + textOffset[0], positionedGlyph.y + textOffset[1]];\n      var x1 = (0 - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];\n      var y1 = (0 - rectBuffer) * positionedGlyph.scale + builtInOffset[1];\n      var x2 = x1 + rect.width * positionedGlyph.scale;\n      var y2 = y1 + rect.height * positionedGlyph.scale;\n      var tl = {\n        x: x1,\n        y: y1\n      };\n      var tr = {\n        x: x2,\n        y: y1\n      };\n      var bl = {\n        x: x1,\n        y: y2\n      };\n      var br = {\n        x: x2,\n        y: y2\n      };\n      quads.push({\n        tl: tl,\n        tr: tr,\n        bl: bl,\n        br: br,\n        tex: rect,\n        glyphOffset: glyphOffset\n      });\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n\n  return quads;\n}","map":{"version":3,"sources":["../../src/utils/symbol-layout.ts"],"names":["horizontalAlign","verticalAlign","lastPositionedGlyph","positionedGlyphs","glyph","lastAdvance","glyphMap","lineIndent","j","shiftX","justify","shiftY","glyphs","yOffset","x","y","maxLineLength","shaping","textJustify","lineStartIndex","lines","line","baselineOffset","vertical","scale","metrics","lineLength","Math","justifyLine","lineHeight","getAnchorAlignment","align","height","iconfonts","translate","isIconFont","text","top","bottom","left","right","lineCount","shapeIconFont","shapeLines","textOffset","alongLine","quads","positionedGlyph","rect","rectBuffer","halfAdvance","glyphOffset","builtInOffset","x1","y1","x2","y2","tl","tr","bl","br","tex"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAyCA,SAAA,kBAAA,CAAA,MAAA,EAAgD;AAC9C,MAAIA,eAAe,GAAnB,GAAA;AACA,MAAIC,aAAa,GAAjB,GAAA;;AACA,UAAA,MAAA;AACE,SAAA,OAAA;AACA,SAAA,WAAA;AACA,SAAA,cAAA;AACED,MAAAA,eAAe,GAAfA,CAAAA;AACA;;AACF,SAAA,MAAA;AACA,SAAA,UAAA;AACA,SAAA,aAAA;AACEA,MAAAA,eAAe,GAAfA,CAAAA;AACA;;AACF;AACEA,MAAAA,eAAe,GAAfA,GAAAA;AAZJ;;AAeA,UAAA,MAAA;AACE,SAAA,QAAA;AACA,SAAA,cAAA;AACA,SAAA,aAAA;AACEC,MAAAA,aAAa,GAAbA,CAAAA;AACA;;AACF,SAAA,KAAA;AACA,SAAA,WAAA;AACA,SAAA,UAAA;AACEA,MAAAA,aAAa,GAAbA,CAAAA;AACA;;AACF;AACEA,MAAAA,aAAa,GAAbA,GAAAA;AAZJ;;AAeA,SAAO;AAAED,IAAAA,eAAe,EAAjB,eAAA;AAAmBC,IAAAA,aAAa,EAAbA;AAAnB,GAAP;AACD;;AAGD,SAAA,WAAA,CAAA,gBAAA,EAAA,QAAA,EAAA,KAAA,EAAA,GAAA,EAAA,OAAA,EAME;AACA,MAAI,CAAJ,OAAA,EAAc;AACZ;AACD;;AAED,MAAMC,mBAAmB,GAAGC,gBAAgB,CAA5C,GAA4C,CAA5C;AACA,MAAMC,KAAK,GAAGF,mBAAmB,CAAjC,KAAA;;AACA,MAAA,KAAA,EAAW;AACT,QAAMG,WAAW,GAAGC,QAAQ,CAARA,KAAQ,CAARA,CAAAA,OAAAA,GAA0BJ,mBAAmB,CAAjE,KAAA;AACA,QAAMK,UAAU,GAAG,CAACJ,gBAAgB,CAAhBA,GAAgB,CAAhBA,CAAAA,CAAAA,GAAD,WAAA,IAAnB,OAAA;;AAEA,SAAK,IAAIK,CAAC,GAAV,KAAA,EAAoBA,CAAC,IAArB,GAAA,EAA8BA,CAA9B,EAAA,EAAmC;AACjCL,MAAAA,gBAAgB,CAAhBA,CAAgB,CAAhBA,CAAAA,CAAAA,IAAAA,UAAAA;AACD;AACF;AACF;;AAKD,SAAA,KAAA,CAAA,gBAAA,EAAA,OAAA,EAAA,eAAA,EAAA,aAAA,EAAA,aAAA,EAAA,UAAA,EAAA,SAAA,EAQE;AACA,MAAMM,MAAM,GAAG,CAACC,OAAO,GAAR,eAAA,IAAf,aAAA;AACA,MAAMC,MAAM,GAAG,CAAC,CAAA,aAAA,GAAA,SAAA,GAAD,GAAA,IAAf,UAAA;;AAFA,MAAA,SAAA,GAAA,0BAAA,CAAA,gBAAA,CAAA;AAAA,MAAA,KAAA;;AAAA,MAAA;AAIA,SAAA,SAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,KAAA,GAAA,SAAA,CAAA,CAAA,EAAA,EAAA,IAAA,GAAuC;AAAA,UAA5BC,MAA4B,GAAA,KAAA,CAAA,KAAA;AACrCA,MAAAA,MAAM,CAANA,CAAAA,IAAAA,MAAAA;AACAA,MAAAA,MAAM,CAANA,CAAAA,IAAAA,MAAAA;AACD;AAPD,GAAA,CAAA,OAAA,GAAA,EAAA;AAAA,IAAA,SAAA,CAAA,CAAA,CAAA,GAAA;AAAA,GAAA,SAAA;AAAA,IAAA,SAAA,CAAA,CAAA;AAAA;AAQD;;AAED,SAAA,UAAA,CAAA,OAAA,EAAA,QAAA,EAAA,KAAA,EAAA,UAAA,EAAA,UAAA,EAAA,WAAA,EAAA,OAAA,EAQE;AAEA,MAAMC,OAAO,GAAG,CAAhB,CAAA;AAEA,MAAIC,CAAC,GAAL,CAAA;AACA,MAAIC,CAAC,GAAL,OAAA;AAEA,MAAIC,aAAa,GAAjB,CAAA;AACA,MAAMb,gBAAgB,GAAGc,OAAO,CAAhC,gBAAA;AAEA,MAAMP,OAAO,GACXQ,WAAW,KAAXA,OAAAA,GAAAA,CAAAA,GAA8BA,WAAW,KAAXA,MAAAA,GAAAA,CAAAA,GADhC,GAAA;AAGA,MAAMC,cAAc,GAAGhB,gBAAgB,CAAvC,MAAA;AACAiB,EAAAA,KAAK,CAALA,OAAAA,CAAc,UAAA,IAAA,EAAU;AACtBC,IAAAA,IAAI,CAAJA,KAAAA,CAAAA,EAAAA,EAAAA,OAAAA,CAAuB,UAAA,IAAA,EAAkB;AACvC,UAAMjB,KAAK,GAAGE,QAAQ,CAAtB,IAAsB,CAAtB;AACA,UAAMgB,cAAc,GAApB,CAAA;;AAEA,UAAA,KAAA,EAAW;AACTnB,QAAAA,gBAAgB,CAAhBA,IAAAA,CAAsB;AACpBC,UAAAA,KAAK,EADe,IAAA;AAEpBU,UAAAA,CAAC,EAFmB,CAAA;AAGpBC,UAAAA,CAAC,EAAEA,CAAC,GAHgB,cAAA;AAIpBQ,UAAAA,QAAQ,EAJY,KAAA;AAKpBC,UAAAA,KAAK,EALe,CAAA;AAMpBC,UAAAA,OAAO,EAAErB;AANW,SAAtBD;AAQAW,QAAAA,CAAC,IAAIV,KAAK,CAALA,OAAAA,GAALU,OAAAA;AACD;AAdHO,KAAAA;;AAkBA,QAAIlB,gBAAgB,CAAhBA,MAAAA,KAAJ,cAAA,EAAgD;AAC9C,UAAMuB,UAAU,GAAGZ,CAAC,GAApB,OAAA;AACAE,MAAAA,aAAa,GAAGW,IAAI,CAAJA,GAAAA,CAAAA,UAAAA,EAAhBX,aAAgBW,CAAhBX;AACAY,MAAAA,WAAW,CAAA,gBAAA,EAAA,QAAA,EAAA,cAAA,EAITzB,gBAAgB,CAAhBA,MAAAA,GAJS,CAAA,EAAXyB,OAAW,CAAXA;AAOD;;AAEDd,IAAAA,CAAC,GAADA,CAAAA;AACAC,IAAAA,CAAC,IAAIc,UAAU,GAAfd,CAAAA;AAhCFK,GAAAA;;AAmCA,MAAA,mBAAA,GAA2CU,kBAAkB,CAA7D,UAA6D,CAA7D;AAAA,MAAQ9B,eAAR,GAAA,mBAAA,CAAA,eAAA;AAAA,MAAyBC,aAAzB,GAAA,mBAAA,CAAA,aAAA;;AACA8B,EAAAA,KAAK,CAAA,gBAAA,EAAA,OAAA,EAAA,eAAA,EAAA,aAAA,EAAA,aAAA,EAAA,UAAA,EAOHX,KAAK,CAPPW,MAAK,CAALA;AAWA,MAAMC,MAAM,GAAGjB,CAAC,GAAhB,OAAA;AAEAE,EAAAA,OAAO,CAAPA,GAAAA,IAAe,CAAA,aAAA,GAAfA,MAAAA;AACAA,EAAAA,OAAO,CAAPA,MAAAA,GAAiBA,OAAO,CAAPA,GAAAA,GAAjBA,MAAAA;AACAA,EAAAA,OAAO,CAAPA,IAAAA,IAAgB,CAAA,eAAA,GAAhBA,aAAAA;AACAA,EAAAA,OAAO,CAAPA,KAAAA,GAAgBA,OAAO,CAAPA,IAAAA,GAAhBA,aAAAA;AACD;;AAED,SAAA,aAAA,CAAA,OAAA,EAAA,QAAA,EAAA,SAAA,EAAA,UAAA,EAAA,UAAA,EAAA,WAAA,EAAA,OAAA,EAQE;AAEA,MAAMJ,OAAO,GAAG,CAAhB,CAAA;AAEA,MAAIC,CAAC,GAAL,CAAA;AACA,MAAIC,CAAC,GAAL,OAAA;AAEA,MAAIC,aAAa,GAAjB,CAAA;AACA,MAAMb,gBAAgB,GAAGc,OAAO,CAAhC,gBAAA;AAEA,MAAMP,OAAO,GACXQ,WAAW,KAAXA,OAAAA,GAAAA,CAAAA,GAA8BA,WAAW,KAAXA,MAAAA,GAAAA,CAAAA,GADhC,GAAA;AAGA,MAAMC,cAAc,GAAGhB,gBAAgB,CAAvC,MAAA;AACA8B,EAAAA,SAAS,CAATA,OAAAA,CAAkB,UAAA,QAAA,EAAc;AAC9B,QAAM7B,KAAK,GAAGE,QAAQ,CAAtB,QAAsB,CAAtB;AACA,QAAMgB,cAAc,GAApB,CAAA;;AAEA,QAAA,KAAA,EAAW;AACTnB,MAAAA,gBAAgB,CAAhBA,IAAAA,CAAsB;AACpBC,QAAAA,KAAK,EADe,QAAA;AAEpBU,QAAAA,CAAC,EAFmB,CAAA;AAGpBC,QAAAA,CAAC,EAAEA,CAAC,GAHgB,cAAA;AAIpBQ,QAAAA,QAAQ,EAJY,KAAA;AAKpBC,QAAAA,KAAK,EALe,CAAA;AAMpBC,QAAAA,OAAO,EAAErB;AANW,OAAtBD;AAQAW,MAAAA,CAAC,IAAIV,KAAK,CAALA,OAAAA,GAALU,OAAAA;AACD;;AAGD,QAAIX,gBAAgB,CAAhBA,MAAAA,KAAJ,cAAA,EAAgD;AAC9C,UAAMuB,UAAU,GAAGZ,CAAC,GAApB,OAAA;AACAE,MAAAA,aAAa,GAAGW,IAAI,CAAJA,GAAAA,CAAAA,UAAAA,EAAhBX,aAAgBW,CAAhBX;AACAY,MAAAA,WAAW,CAAA,gBAAA,EAAA,QAAA,EAAA,cAAA,EAITzB,gBAAgB,CAAhBA,MAAAA,GAJS,CAAA,EAAXyB,OAAW,CAAXA;AAOD;;AAEDd,IAAAA,CAAC,GAADA,CAAAA;AACAC,IAAAA,CAAC,IAAIc,UAAU,GAAfd,CAAAA;AA9BFkB,GAAAA;;AAiCA,MAAA,oBAAA,GAA2CH,kBAAkB,CAA7D,UAA6D,CAA7D;AAAA,MAAQ9B,eAAR,GAAA,oBAAA,CAAA,eAAA;AAAA,MAAyBC,aAAzB,GAAA,oBAAA,CAAA,aAAA;;AACA8B,EAAAA,KAAK,CAAA,gBAAA,EAAA,OAAA,EAAA,eAAA,EAAA,aAAA,EAAA,aAAA,EAAA,UAAA,EAOHE,SAAS,CAPXF,MAAK,CAALA;AAWA,MAAMC,MAAM,GAAGjB,CAAC,GAAhB,OAAA;AAEAE,EAAAA,OAAO,CAAPA,GAAAA,IAAe,CAAA,aAAA,GAAfA,MAAAA;AACAA,EAAAA,OAAO,CAAPA,MAAAA,GAAiBA,OAAO,CAAPA,GAAAA,GAAjBA,MAAAA;AACAA,EAAAA,OAAO,CAAPA,IAAAA,IAAgB,CAAA,eAAA,GAAhBA,aAAAA;AACAA,EAAAA,OAAO,CAAPA,KAAAA,GAAgBA,OAAO,CAAPA,IAAAA,GAAhBA,aAAAA;AACD;;AAeD,OAAO,SAAA,SAAA,CAAA,IAAA,EAAA,MAAA,EAAA,UAAA,EAAA,UAAA,EAAA,WAAA,EAAA,OAAA,EASL;AAAA,MAFAiB,SAEA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAF8B,CAAA,CAAA,EAAA,CAAA,CAE9B;AAAA,MADAC,UACA,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;AAEA,MAAMf,KAAK,GAAGgB,IAAI,CAAJA,KAAAA,CAAd,IAAcA,CAAd;AAEA,MAAMjC,gBAAuB,GAA7B,EAAA;AACA,MAAMc,OAAO,GAAG;AACdd,IAAAA,gBAAgB,EADF,gBAAA;AAEdkC,IAAAA,GAAG,EAAEH,SAAS,CAFA,CAEA,CAFA;AAGdI,IAAAA,MAAM,EAAEJ,SAAS,CAHH,CAGG,CAHH;AAIdK,IAAAA,IAAI,EAAEL,SAAS,CAJD,CAIC,CAJD;AAKdM,IAAAA,KAAK,EAAEN,SAAS,CALF,CAKE,CALF;AAMdO,IAAAA,SAAS,EAAErB,KAAK,CANF,MAAA;AAOdgB,IAAAA,IAAI,EAAJA;AAPc,GAAhB;AASAD,EAAAA,UAAU,GACNO,aAAa,CAAA,OAAA,EAAA,MAAA,EAAA,KAAA,EAAA,UAAA,EAAA,UAAA,EAAA,WAAA,EADP,OACO,CADP,GAUNC,UAAU,CAAA,OAAA,EAAA,MAAA,EAAA,KAAA,EAAA,UAAA,EAAA,UAAA,EAAA,WAAA,EAVdR,OAUc,CAVdA;;AAmBA,MAAI,CAAChC,gBAAgB,CAArB,MAAA,EAA8B;AAC5B,WAAA,KAAA;AACD;;AAED,SAAA,OAAA;AACD;AAED,OAAO,SAAA,aAAA,CAAA,OAAA,EAIS;AAAA,MAFdyC,UAEc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,IAAA,SAAA,CAAA,CAAA,CAAA,KAAA,SAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAFiB,CAAA,CAAA,EAAA,CAAA,CAEjB;AAAA,MADdC,SACc,GAAA,SAAA,CAAA,MAAA,GAAA,CAAA,GAAA,SAAA,CAAA,CAAA,CAAA,GAAA,SAAA;AACd,MAAA,qBAAA,GAAkC5B,OAAlC,CAAA,gBAAA;AAAA,MAAQd,gBAAR,GAAA,qBAAA,KAAA,KAAA,CAAA,GAAA,EAAA,GAAA,qBAAA;AACA,MAAM2C,KAAmB,GAAzB,EAAA;;AAFc,MAAA,UAAA,GAAA,0BAAA,CAAA,gBAAA,CAAA;AAAA,MAAA,MAAA;;AAAA,MAAA;AAId,SAAA,UAAA,CAAA,CAAA,EAAA,EAAA,CAAA,CAAA,MAAA,GAAA,UAAA,CAAA,CAAA,EAAA,EAAA,IAAA,GAAgD;AAAA,UAArCC,eAAqC,GAAA,MAAA,CAAA,KAAA;AAC9C,UAAMC,IAAI,GAAGD,eAAe,CAA5B,OAAA;AAGA,UAAME,UAAU,GAAhB,CAAA;AAEA,UAAMC,WAAW,GAAIF,IAAI,CAAJA,OAAAA,GAAeD,eAAe,CAA/B,KAACC,GAArB,CAAA;AAEA,UAAMG,WAA6B,GAAGN,SAAS,GAC3C,CAACE,eAAe,CAAfA,CAAAA,GAAD,WAAA,EAAkCA,eAAe,CADN,CAC3C,CAD2C,GAE3C,CAAA,CAAA,EAFJ,CAEI,CAFJ;AAIA,UAAMK,aAAa,GAAGP,SAAS,GAC3B,CAAA,CAAA,EAD2B,CAC3B,CAD2B,GAE3B,CACEE,eAAe,CAAfA,CAAAA,GAAAA,WAAAA,GAAkCH,UAAU,CAD9C,CAC8C,CAD9C,EAEEG,eAAe,CAAfA,CAAAA,GAAoBH,UAAU,CAJpC,CAIoC,CAFhC,CAFJ;AAOA,UAAMS,EAAE,GACN,CAAC,IAAD,UAAA,IAAmBN,eAAe,CAAlC,KAAA,GAAA,WAAA,GAAyDK,aAAa,CADxE,CACwE,CADxE;AAEA,UAAME,EAAE,GAAG,CAAC,IAAD,UAAA,IAAmBP,eAAe,CAAlC,KAAA,GAA2CK,aAAa,CAAnE,CAAmE,CAAnE;AACA,UAAMG,EAAE,GAAGF,EAAE,GAAGL,IAAI,CAAJA,KAAAA,GAAaD,eAAe,CAA5C,KAAA;AACA,UAAMS,EAAE,GAAGF,EAAE,GAAGN,IAAI,CAAJA,MAAAA,GAAcD,eAAe,CAA7C,KAAA;AAEA,UAAMU,EAAE,GAAG;AAAE3C,QAAAA,CAAC,EAAH,EAAA;AAASC,QAAAA,CAAC,EAAEuC;AAAZ,OAAX;AACA,UAAMI,EAAE,GAAG;AAAE5C,QAAAA,CAAC,EAAH,EAAA;AAASC,QAAAA,CAAC,EAAEuC;AAAZ,OAAX;AACA,UAAMK,EAAE,GAAG;AAAE7C,QAAAA,CAAC,EAAH,EAAA;AAASC,QAAAA,CAAC,EAAEyC;AAAZ,OAAX;AACA,UAAMI,EAAE,GAAG;AAAE9C,QAAAA,CAAC,EAAH,EAAA;AAASC,QAAAA,CAAC,EAAEyC;AAAZ,OAAX;AAIAV,MAAAA,KAAK,CAALA,IAAAA,CAAW;AAAEW,QAAAA,EAAE,EAAJ,EAAA;AAAMC,QAAAA,EAAE,EAAR,EAAA;AAAUC,QAAAA,EAAE,EAAZ,EAAA;AAAcC,QAAAA,EAAE,EAAhB,EAAA;AAAkBC,QAAAA,GAAG,EAArB,IAAA;AAA6BV,QAAAA,WAAW,EAAXA;AAA7B,OAAXL;AACD;AArCa,GAAA,CAAA,OAAA,GAAA,EAAA;AAAA,IAAA,UAAA,CAAA,CAAA,CAAA,GAAA;AAAA,GAAA,SAAA;AAAA,IAAA,UAAA,CAAA,CAAA;AAAA;;AAuCd,SAAA,KAAA;AACD","sourcesContent":["import { type } from 'os';\n\ninterface IPoint {\n  x: number;\n  y: number;\n}\nexport type anchorType =\n  | 'right'\n  | 'top-right'\n  | 'left'\n  | 'bottom-right'\n  | 'left'\n  | 'top-left'\n  | 'bottom-left'\n  | 'bottom'\n  | 'bottom-right'\n  | 'bottom-left'\n  | 'top'\n  | 'top-right'\n  | 'top-left'\n  | 'center';\nexport interface IGlyphQuad {\n  tr: IPoint;\n  tl: IPoint;\n  bl: IPoint;\n  br: IPoint;\n  tex: {\n    x: number;\n    y: number;\n    height: number;\n    width: number;\n    advance: number;\n  };\n  glyphOffset: [number, number];\n}\n\n/**\n * 返回文本相对锚点位置\n * @param {string} anchor 锚点位置\n * @return {alignment} alignment\n */\nfunction getAnchorAlignment(anchor: anchorType) {\n  let horizontalAlign = 0.5;\n  let verticalAlign = 0.5;\n  switch (anchor) {\n    case 'right':\n    case 'top-right':\n    case 'bottom-right':\n      horizontalAlign = 1;\n      break;\n    case 'left':\n    case 'top-left':\n    case 'bottom-left':\n      horizontalAlign = 0;\n      break;\n    default:\n      horizontalAlign = 0.5;\n  }\n\n  switch (anchor) {\n    case 'bottom':\n    case 'bottom-right':\n    case 'bottom-left':\n      verticalAlign = 1;\n      break;\n    case 'top':\n    case 'top-right':\n    case 'top-left':\n      verticalAlign = 0;\n      break;\n    default:\n      verticalAlign = 0.5;\n  }\n\n  return { horizontalAlign, verticalAlign };\n}\n\n// justify right = 1, left = 0, center = 0.5\nfunction justifyLine(\n  positionedGlyphs: any,\n  glyphMap: any,\n  start: number,\n  end: number,\n  justify: number,\n) {\n  if (!justify) {\n    return;\n  }\n\n  const lastPositionedGlyph = positionedGlyphs[end];\n  const glyph = lastPositionedGlyph.glyph;\n  if (glyph) {\n    const lastAdvance = glyphMap[glyph].advance * lastPositionedGlyph.scale;\n    const lineIndent = (positionedGlyphs[end].x + lastAdvance) * justify;\n\n    for (let j = start; j <= end; j++) {\n      positionedGlyphs[j].x -= lineIndent;\n    }\n  }\n}\n\n// justify right=1 left=0 center=0.5\n// horizontalAlign right=1 left=0 center=0.5\n// verticalAlign right=1 left=0 center=0.5\nfunction align(\n  positionedGlyphs: any[],\n  justify: number,\n  horizontalAlign: number,\n  verticalAlign: number,\n  maxLineLength: number,\n  lineHeight: number,\n  lineCount: number,\n) {\n  const shiftX = (justify - horizontalAlign) * maxLineLength;\n  const shiftY = (-verticalAlign * lineCount + 0.5) * lineHeight;\n\n  for (const glyphs of positionedGlyphs) {\n    glyphs.x += shiftX;\n    glyphs.y += shiftY;\n  }\n}\n\nfunction shapeLines(\n  shaping: any,\n  glyphMap: any,\n  lines: any[],\n  lineHeight: number,\n  textAnchor: anchorType,\n  textJustify: string,\n  spacing: number,\n) {\n  // buffer 为 4\n  const yOffset = -8;\n\n  let x = 0;\n  let y = yOffset;\n\n  let maxLineLength = 0;\n  const positionedGlyphs = shaping.positionedGlyphs;\n\n  const justify =\n    textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;\n\n  const lineStartIndex = positionedGlyphs.length;\n  lines.forEach((line) => {\n    line.split('').forEach((char: string) => {\n      const glyph = glyphMap[char];\n      const baselineOffset = 0;\n\n      if (glyph) {\n        positionedGlyphs.push({\n          glyph: char,\n          x,\n          y: y + baselineOffset,\n          vertical: false, // TODO：目前只支持水平方向\n          scale: 1,\n          metrics: glyph,\n        });\n        x += glyph.advance + spacing;\n      }\n    });\n\n    // 左右对齐\n    if (positionedGlyphs.length !== lineStartIndex) {\n      const lineLength = x - spacing;\n      maxLineLength = Math.max(lineLength, maxLineLength);\n      justifyLine(\n        positionedGlyphs,\n        glyphMap,\n        lineStartIndex,\n        positionedGlyphs.length - 1,\n        justify,\n      );\n    }\n\n    x = 0;\n    y -= lineHeight + 5;\n  });\n\n  const { horizontalAlign, verticalAlign } = getAnchorAlignment(textAnchor);\n  align(\n    positionedGlyphs,\n    justify,\n    horizontalAlign,\n    verticalAlign,\n    maxLineLength,\n    lineHeight,\n    lines.length,\n  );\n\n  // 计算包围盒\n  const height = y - yOffset;\n\n  shaping.top += -verticalAlign * height;\n  shaping.bottom = shaping.top - height;\n  shaping.left += -horizontalAlign * maxLineLength;\n  shaping.right = shaping.left + maxLineLength;\n}\n\nfunction shapeIconFont(\n  shaping: any,\n  glyphMap: any,\n  iconfonts: any[],\n  lineHeight: number,\n  textAnchor: anchorType,\n  textJustify: string,\n  spacing: number,\n) {\n  // buffer 为 4\n  const yOffset = -8;\n\n  let x = 0;\n  let y = yOffset;\n\n  let maxLineLength = 0;\n  const positionedGlyphs = shaping.positionedGlyphs;\n\n  const justify =\n    textJustify === 'right' ? 1 : textJustify === 'left' ? 0 : 0.5;\n\n  const lineStartIndex = positionedGlyphs.length;\n  iconfonts.forEach((iconfont) => {\n    const glyph = glyphMap[iconfont];\n    const baselineOffset = 0;\n\n    if (glyph) {\n      positionedGlyphs.push({\n        glyph: iconfont,\n        x,\n        y: y + baselineOffset,\n        vertical: false, // TODO：目前只支持水平方向\n        scale: 1,\n        metrics: glyph,\n      });\n      x += glyph.advance + spacing;\n    }\n\n    // 左右对齐\n    if (positionedGlyphs.length !== lineStartIndex) {\n      const lineLength = x - spacing;\n      maxLineLength = Math.max(lineLength, maxLineLength);\n      justifyLine(\n        positionedGlyphs,\n        glyphMap,\n        lineStartIndex,\n        positionedGlyphs.length - 1,\n        justify,\n      );\n    }\n\n    x = 0;\n    y -= lineHeight + 5;\n  });\n\n  const { horizontalAlign, verticalAlign } = getAnchorAlignment(textAnchor);\n  align(\n    positionedGlyphs,\n    justify,\n    horizontalAlign,\n    verticalAlign,\n    maxLineLength,\n    lineHeight,\n    iconfonts.length,\n  );\n\n  // 计算包围盒\n  const height = y - yOffset;\n\n  shaping.top += -verticalAlign * height;\n  shaping.bottom = shaping.top - height;\n  shaping.left += -horizontalAlign * maxLineLength;\n  shaping.right = shaping.left + maxLineLength;\n}\n\n/**\n * 计算文本中每个独立字符相对锚点的位置\n *\n * @param {string} text 原始文本\n * @param {*} glyphs mapping\n * @param {number} lineHeight 行高\n * @param {string} textAnchor 文本相对于锚点的位置\n * @param {string} textJustify 左右对齐\n * @param {number} spacing 字符间距\n * @param {[number, number]} translate 文本水平 & 垂直偏移量\n * @param {[boolean]} isIconFont 是否是 iconfont\n * @return {boolean|shaping} 每个字符相对于锚点的位置\n */\nexport function shapeText(\n  text: string,\n  glyphs: any,\n  lineHeight: number,\n  textAnchor: anchorType,\n  textJustify: string,\n  spacing: number,\n  translate: [number, number] = [0, 0],\n  isIconFont: boolean,\n) {\n  // TODO：处理换行\n  const lines = text.split('\\n');\n\n  const positionedGlyphs: any[] = [];\n  const shaping = {\n    positionedGlyphs,\n    top: translate[1],\n    bottom: translate[1],\n    left: translate[0],\n    right: translate[0],\n    lineCount: lines.length,\n    text,\n  };\n  isIconFont\n    ? shapeIconFont(\n        shaping,\n        glyphs,\n        lines,\n        lineHeight,\n        textAnchor,\n        textJustify,\n        spacing,\n      )\n    : shapeLines(\n        shaping,\n        glyphs,\n        lines,\n        lineHeight,\n        textAnchor,\n        textJustify,\n        spacing,\n      );\n  if (!positionedGlyphs.length) {\n    return false;\n  }\n\n  return shaping;\n}\n\nexport function getGlyphQuads(\n  shaping: any,\n  textOffset: [number, number] = [0, 0],\n  alongLine: boolean,\n): IGlyphQuad[] {\n  const { positionedGlyphs = [] } = shaping;\n  const quads: IGlyphQuad[] = [];\n\n  for (const positionedGlyph of positionedGlyphs) {\n    const rect = positionedGlyph.metrics;\n\n    // The rects have an addditional buffer that is not included in their size.\n    const rectBuffer = 4;\n\n    const halfAdvance = (rect.advance * positionedGlyph.scale) / 2;\n\n    const glyphOffset: [number, number] = alongLine\n      ? [positionedGlyph.x + halfAdvance, positionedGlyph.y]\n      : [0, 0];\n\n    const builtInOffset = alongLine\n      ? [0, 0]\n      : [\n          positionedGlyph.x + halfAdvance + textOffset[0],\n          positionedGlyph.y + textOffset[1],\n        ];\n\n    const x1 =\n      (0 - rectBuffer) * positionedGlyph.scale - halfAdvance + builtInOffset[0];\n    const y1 = (0 - rectBuffer) * positionedGlyph.scale + builtInOffset[1];\n    const x2 = x1 + rect.width * positionedGlyph.scale;\n    const y2 = y1 + rect.height * positionedGlyph.scale;\n\n    const tl = { x: x1, y: y1 };\n    const tr = { x: x2, y: y1 };\n    const bl = { x: x1, y: y2 };\n    const br = { x: x2, y: y2 };\n\n    // TODO：处理字符旋转的情况\n\n    quads.push({ tl, tr, bl, br, tex: rect, glyphOffset });\n  }\n\n  return quads;\n}\n"]},"metadata":{},"sourceType":"module"}