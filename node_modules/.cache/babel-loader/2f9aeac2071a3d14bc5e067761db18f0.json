{"ast":null,"code":"import _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { clamp, squaredLength } from '../util';\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Curve } from '../curve';\nimport { Polyline } from '../polyline';\nimport { Rectangle } from '../rectangle';\nimport { Geometry } from '../geometry';\nimport { Close } from './close';\nimport { LineTo } from './lineto';\nimport { MoveTo } from './moveto';\nimport { CurveTo } from './curveto';\nimport { normalizePathData } from './normalize';\nimport * as Util from './util';\nexport var Path = /*#__PURE__*/function (_Geometry, _Symbol$toStringTag) {\n  _inherits(Path, _Geometry);\n\n  var _super = _createSuper(Path);\n\n  function Path(args) {\n    var _this;\n\n    _classCallCheck(this, Path);\n\n    _this = _super.call(this);\n    _this.PRECISION = 3;\n    _this.segments = [];\n\n    if (Array.isArray(args)) {\n      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n        var previousObj = null;\n        var arr = args;\n        arr.forEach(function (o, i) {\n          if (i === 0) {\n            _this.appendSegment(Path.createSegment('M', o.start));\n          }\n\n          if (previousObj != null && !previousObj.end.equals(o.start)) {\n            _this.appendSegment(Path.createSegment('M', o.start));\n          }\n\n          if (Line.isLine(o)) {\n            _this.appendSegment(Path.createSegment('L', o.end));\n          } else if (Curve.isCurve(o)) {\n            _this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));\n          }\n\n          previousObj = o;\n        });\n      } else {\n        var _arr = args;\n\n        _arr.forEach(function (s) {\n          if (s.isSegment) {\n            _this.appendSegment(s);\n          }\n        });\n      }\n    } else if (args != null) {\n      if (Line.isLine(args)) {\n        _this.appendSegment(Path.createSegment('M', args.start));\n\n        _this.appendSegment(Path.createSegment('L', args.end));\n      } else if (Curve.isCurve(args)) {\n        _this.appendSegment(Path.createSegment('M', args.start));\n\n        _this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));\n      } else if (Polyline.isPolyline(args)) {\n        if (args.points && args.points.length) {\n          args.points.forEach(function (point, index) {\n            var segment = index === 0 ? Path.createSegment('M', point) : Path.createSegment('L', point);\n\n            _this.appendSegment(segment);\n          });\n        }\n      } else if (args.isSegment) {\n        _this.appendSegment(args);\n      }\n    }\n\n    return _this;\n  }\n\n  _createClass(Path, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Path.toStringTag;\n    }\n  }, {\n    key: \"start\",\n    get: function get() {\n      var segments = this.segments;\n      var count = segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      for (var i = 0; i < count; i += 1) {\n        var segment = segments[i];\n\n        if (segment.isVisible) {\n          return segment.start;\n        }\n      } // if no visible segment, return last segment end point\n\n\n      return segments[count - 1].end;\n    }\n  }, {\n    key: \"end\",\n    get: function get() {\n      var segments = this.segments;\n      var count = segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      for (var i = count - 1; i >= 0; i -= 1) {\n        var segment = segments[i];\n\n        if (segment.isVisible) {\n          return segment.end;\n        }\n      } // if no visible segment, return last segment end point\n\n\n      return segments[count - 1].end;\n    }\n  }, {\n    key: \"moveTo\",\n    value: function moveTo() {\n      var _MoveTo$create;\n\n      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n        args[_key] = arguments[_key];\n      }\n\n      return this.appendSegment((_MoveTo$create = MoveTo.create).call.apply(_MoveTo$create, [null].concat(args)));\n    }\n  }, {\n    key: \"lineTo\",\n    value: function lineTo() {\n      var _LineTo$create;\n\n      for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n        args[_key2] = arguments[_key2];\n      }\n\n      return this.appendSegment((_LineTo$create = LineTo.create).call.apply(_LineTo$create, [null].concat(args)));\n    }\n  }, {\n    key: \"curveTo\",\n    value: function curveTo() {\n      var _CurveTo$create;\n\n      for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n        args[_key3] = arguments[_key3];\n      }\n\n      return this.appendSegment((_CurveTo$create = CurveTo.create).call.apply(_CurveTo$create, [null].concat(args)));\n    }\n  }, {\n    key: \"arcTo\",\n    value: function arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {\n      var start = this.end || new Point();\n      var points = typeof endX === 'number' ? Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) : Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);\n\n      if (points != null) {\n        for (var i = 0, ii = points.length; i < ii; i += 6) {\n          this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"quadTo\",\n    value: function quadTo(x1, y1, x, y) {\n      var start = this.end || new Point();\n      var data = ['M', start.x, start.y];\n\n      if (typeof x1 === 'number') {\n        data.push('Q', x1, y1, x, y);\n      } else {\n        var p = y1;\n        data.push(\"Q\", x1.x, x1.y, p.x, p.y);\n      }\n\n      var path = Path.parse(data.join(' '));\n      this.appendSegment(path.segments.slice(1));\n      return this;\n    }\n  }, {\n    key: \"close\",\n    value: function close() {\n      return this.appendSegment(Close.create());\n    }\n  }, {\n    key: \"drawPoints\",\n    value: function drawPoints(points) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var raw = Util.drawPoints(points, options);\n      var sub = Path.parse(raw);\n\n      if (sub && sub.segments) {\n        this.appendSegment(sub.segments);\n      }\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var segments = this.segments;\n      var count = segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      var bbox;\n\n      for (var i = 0; i < count; i += 1) {\n        var segment = segments[i];\n\n        if (segment.isVisible) {\n          var segmentBBox = segment.bbox();\n\n          if (segmentBBox != null) {\n            bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n          }\n        }\n      }\n\n      if (bbox != null) {\n        return bbox;\n      } // if the path has only invisible elements, return end point of last segment\n\n\n      var lastSegment = segments[count - 1];\n      return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    }\n  }, {\n    key: \"appendSegment\",\n    value: function appendSegment(seg) {\n      var count = this.segments.length;\n      var previousSegment = count !== 0 ? this.segments[count - 1] : null;\n      var currentSegment;\n      var nextSegment = null;\n\n      if (Array.isArray(seg)) {\n        for (var i = 0, ii = seg.length; i < ii; i += 1) {\n          var segment = seg[i];\n          currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n          this.segments.push(currentSegment);\n          previousSegment = currentSegment;\n        }\n      } else if (seg != null && seg.isSegment) {\n        currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n        this.segments.push(currentSegment);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"insertSegment\",\n    value: function insertSegment(index, seg) {\n      var count = this.segments.length;\n\n      if (index < 0) {\n        index = count + index + 1; // eslint-disable-line\n      }\n\n      if (index > count || index < 0) {\n        throw new Error('Index out of range.');\n      }\n\n      var currentSegment;\n      var previousSegment = null;\n      var nextSegment = null;\n\n      if (count !== 0) {\n        if (index >= 1) {\n          previousSegment = this.segments[index - 1];\n          nextSegment = previousSegment.nextSegment;\n        } else {\n          previousSegment = null;\n          nextSegment = this.segments[0];\n        }\n      }\n\n      if (!Array.isArray(seg)) {\n        currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n        this.segments.splice(index, 0, currentSegment);\n      } else {\n        for (var i = 0, ii = seg.length; i < ii; i += 1) {\n          var segment = seg[i];\n          currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n          this.segments.splice(index + i, 0, currentSegment);\n          previousSegment = currentSegment;\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeSegment\",\n    value: function removeSegment(index) {\n      var idx = this.fixIndex(index);\n      var removedSegment = this.segments.splice(idx, 1)[0];\n      var previousSegment = removedSegment.previousSegment;\n      var nextSegment = removedSegment.nextSegment; // link the previous and next segments together (if present)\n\n      if (previousSegment) {\n        previousSegment.nextSegment = nextSegment;\n      }\n\n      if (nextSegment) {\n        nextSegment.previousSegment = previousSegment;\n      }\n\n      if (removedSegment.isSubpathStart && nextSegment) {\n        this.updateSubpathStartSegment(nextSegment);\n      }\n\n      return removedSegment;\n    }\n  }, {\n    key: \"replaceSegment\",\n    value: function replaceSegment(index, seg) {\n      var idx = this.fixIndex(index);\n      var currentSegment;\n      var replacedSegment = this.segments[idx];\n      var previousSegment = replacedSegment.previousSegment;\n      var nextSegment = replacedSegment.nextSegment;\n      var updateSubpathStart = replacedSegment.isSubpathStart;\n\n      if (!Array.isArray(seg)) {\n        currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n        this.segments.splice(idx, 1, currentSegment);\n\n        if (updateSubpathStart && currentSegment.isSubpathStart) {\n          // already updated by `prepareSegment`\n          updateSubpathStart = false;\n        }\n      } else {\n        this.segments.splice(index, 1);\n\n        for (var i = 0, ii = seg.length; i < ii; i += 1) {\n          var segment = seg[i];\n          currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n          this.segments.splice(index + i, 0, currentSegment);\n          previousSegment = currentSegment;\n\n          if (updateSubpathStart && currentSegment.isSubpathStart) {\n            updateSubpathStart = false;\n          }\n        }\n      }\n\n      if (updateSubpathStart && nextSegment) {\n        this.updateSubpathStartSegment(nextSegment);\n      }\n    }\n  }, {\n    key: \"getSegment\",\n    value: function getSegment(index) {\n      var idx = this.fixIndex(index);\n      return this.segments[idx];\n    }\n  }, {\n    key: \"fixIndex\",\n    value: function fixIndex(index) {\n      var length = this.segments.length;\n\n      if (length === 0) {\n        throw new Error('Path has no segments.');\n      }\n\n      var i = index;\n\n      while (i < 0) {\n        i = length + i;\n      }\n\n      if (i >= length || i < 0) {\n        throw new Error('Index out of range.');\n      }\n\n      return i;\n    }\n  }, {\n    key: \"segmentAt\",\n    value: function segmentAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = this.segmentIndexAt(ratio, options);\n\n      if (!index) {\n        return null;\n      }\n\n      return this.getSegment(index);\n    }\n  }, {\n    key: \"segmentAtLength\",\n    value: function segmentAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = this.segmentIndexAtLength(length, options);\n      if (!index) return null;\n      return this.getSegment(index);\n    }\n  }, {\n    key: \"segmentIndexAt\",\n    value: function segmentIndexAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var rate = clamp(ratio, 0, 1);\n      var opt = this.getOptions(options);\n      var len = this.length(opt);\n      var length = len * rate;\n      return this.segmentIndexAtLength(length, opt);\n    }\n  }, {\n    key: \"segmentIndexAtLength\",\n    value: function segmentIndexAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var count = this.segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var memo = 0;\n      var lastVisibleIndex = null;\n\n      for (var i = 0; i < count; i += 1) {\n        var index = fromStart ? i : count - 1 - i;\n        var segment = this.segments[index];\n        var subdivisions = segmentSubdivisions[index];\n        var len = segment.length({\n          precision: precision,\n          subdivisions: subdivisions\n        });\n\n        if (segment.isVisible) {\n          if (length <= memo + len) {\n            return index;\n          }\n\n          lastVisibleIndex = index;\n        }\n\n        memo += len;\n      } // If length requested is higher than the length of the path, return\n      // last visible segment index. If no visible segment, return null.\n\n\n      return lastVisibleIndex;\n    }\n  }, {\n    key: \"getSegmentSubdivisions\",\n    value: function getSegmentSubdivisions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = [];\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var segment = this.segments[i];\n        var subdivisions = segment.getSubdivisions({\n          precision: precision\n        });\n        segmentSubdivisions.push(subdivisions);\n      }\n\n      return segmentSubdivisions;\n    }\n  }, {\n    key: \"updateSubpathStartSegment\",\n    value: function updateSubpathStartSegment(segment) {\n      var previous = segment.previousSegment;\n      var current = segment;\n\n      while (current && !current.isSubpathStart) {\n        // assign previous segment's subpath start segment to this segment\n        if (previous != null) {\n          current.subpathStartSegment = previous.subpathStartSegment;\n        } else {\n          current.subpathStartSegment = null;\n        }\n\n        previous = current;\n        current = current.nextSegment;\n      }\n    }\n  }, {\n    key: \"prepareSegment\",\n    value: function prepareSegment(segment, previousSegment, nextSegment) {\n      segment.previousSegment = previousSegment;\n      segment.nextSegment = nextSegment;\n\n      if (previousSegment != null) {\n        previousSegment.nextSegment = segment;\n      }\n\n      if (nextSegment != null) {\n        nextSegment.previousSegment = segment;\n      }\n\n      var updateSubpathStart = segment;\n\n      if (segment.isSubpathStart) {\n        // move to\n        segment.subpathStartSegment = segment;\n        updateSubpathStart = nextSegment;\n      } // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\n\n      if (updateSubpathStart != null) {\n        this.updateSubpathStartSegment(updateSubpathStart);\n      }\n\n      return segment;\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var t = this.closestPointT(p, options);\n\n      if (!t) {\n        return null;\n      }\n\n      return this.pointAtT(t);\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var opts = this.getOptions(options);\n      var t = this.closestPointT(p, opts);\n\n      if (!t) {\n        return 0;\n      }\n\n      return this.lengthAtT(t, opts);\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var opts = this.getOptions(options);\n      var cpLength = this.closestPointLength(p, opts);\n\n      if (cpLength === 0) {\n        return 0;\n      }\n\n      var length = this.length(opts);\n\n      if (length === 0) {\n        return 0;\n      }\n\n      return cpLength / length;\n    }\n  }, {\n    key: \"closestPointT\",\n    value: function closestPointT(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var closestPointT;\n      var minSquaredDistance = Infinity;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var segment = this.segments[i];\n        var subdivisions = segmentSubdivisions[i];\n\n        if (segment.isVisible) {\n          var segmentClosestPointT = segment.closestPointT(p, {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n          var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n          var squaredDistance = squaredLength(segmentClosestPoint, p);\n\n          if (squaredDistance < minSquaredDistance) {\n            closestPointT = {\n              segmentIndex: i,\n              value: segmentClosestPointT\n            };\n            minSquaredDistance = squaredDistance;\n          }\n        }\n      }\n\n      if (closestPointT) {\n        return closestPointT;\n      }\n\n      return {\n        segmentIndex: this.segments.length - 1,\n        value: 1\n      };\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var closestPointTangent;\n      var minSquaredDistance = Infinity;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var segment = this.segments[i];\n        var subdivisions = segmentSubdivisions[i];\n\n        if (segment.isDifferentiable()) {\n          var segmentClosestPointT = segment.closestPointT(p, {\n            precision: precision,\n            subdivisions: subdivisions\n          });\n          var segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n          var squaredDistance = squaredLength(segmentClosestPoint, p);\n\n          if (squaredDistance < minSquaredDistance) {\n            closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n            minSquaredDistance = squaredDistance;\n          }\n        }\n      }\n\n      if (closestPointTangent) {\n        return closestPointTangent;\n      }\n\n      return null;\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var polylines = this.toPolylines(options);\n\n      if (!polylines) {\n        return false;\n      }\n\n      var numIntersections = 0;\n\n      for (var i = 0, ii = polylines.length; i < ii; i += 1) {\n        var polyline = polylines[i];\n\n        if (polyline.containsPoint(p)) {\n          numIntersections += 1;\n        }\n      } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n      return numIntersections % 2 === 1;\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      if (ratio <= 0) {\n        return this.start.clone();\n      }\n\n      if (ratio >= 1) {\n        return this.end.clone();\n      }\n\n      var opts = this.getOptions(options);\n      var pathLength = this.length(opts);\n      var length = pathLength * ratio;\n      return this.pointAtLength(length, opts);\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      if (length === 0) {\n        return this.start.clone();\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var lastVisibleSegment;\n      var memo = 0;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var index = fromStart ? i : ii - 1 - i;\n        var segment = this.segments[index];\n        var subdivisions = segmentSubdivisions[index];\n        var d = segment.length({\n          precision: precision,\n          subdivisions: subdivisions\n        });\n\n        if (segment.isVisible) {\n          if (length <= memo + d) {\n            return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n              precision: precision,\n              subdivisions: subdivisions\n            });\n          }\n\n          lastVisibleSegment = segment;\n        }\n\n        memo += d;\n      } // if length requested is higher than the length of the path,\n      // return last visible segment endpoint\n\n\n      if (lastVisibleSegment) {\n        return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n      } // if no visible segment, return last segment end point\n\n\n      var lastSegment = this.segments[this.segments.length - 1];\n      return lastSegment.end.clone();\n    }\n  }, {\n    key: \"pointAtT\",\n    value: function pointAtT(t) {\n      var segments = this.segments;\n      var numSegments = segments.length;\n      if (numSegments === 0) return null; // if segments is an empty array\n\n      var segmentIndex = t.segmentIndex;\n      if (segmentIndex < 0) return segments[0].pointAtT(0);\n\n      if (segmentIndex >= numSegments) {\n        return segments[numSegments - 1].pointAtT(1);\n      }\n\n      var tValue = clamp(t.value, 0, 1);\n      return segments[segmentIndex].pointAtT(tValue);\n    }\n  }, {\n    key: \"divideAt\",\n    value: function divideAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var rate = clamp(ratio, 0, 1);\n      var opts = this.getOptions(options);\n      var len = this.length(opts);\n      var length = len * rate;\n      return this.divideAtLength(length, opts);\n    }\n  }, {\n    key: \"divideAtLength\",\n    value: function divideAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var memo = 0;\n      var divided;\n      var dividedSegmentIndex;\n      var lastValidSegment;\n      var lastValidSegmentIndex;\n      var t;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var _index = fromStart ? i : ii - 1 - i;\n\n        var segment = this.getSegment(_index);\n        var subdivisions = segmentSubdivisions[_index];\n        var opts = {\n          precision: precision,\n          subdivisions: subdivisions\n        };\n        var len = segment.length(opts);\n\n        if (segment.isDifferentiable()) {\n          lastValidSegment = segment;\n          lastValidSegmentIndex = _index;\n\n          if (length <= memo + len) {\n            dividedSegmentIndex = _index;\n            divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);\n            break;\n          }\n        }\n\n        memo += len;\n      }\n\n      if (!lastValidSegment) {\n        return null;\n      }\n\n      if (!divided) {\n        dividedSegmentIndex = lastValidSegmentIndex;\n        t = fromStart ? 1 : 0;\n        divided = lastValidSegment.divideAtT(t);\n      } // create a copy of this path and replace the identified segment with its two divided parts:\n\n\n      var pathCopy = this.clone();\n      var index = dividedSegmentIndex;\n      pathCopy.replaceSegment(index, divided);\n      var divisionStartIndex = index;\n      var divisionMidIndex = index + 1;\n      var divisionEndIndex = index + 2; // do not insert the part if it looks like a point\n\n      if (!divided[0].isDifferentiable()) {\n        pathCopy.removeSegment(divisionStartIndex);\n        divisionMidIndex -= 1;\n        divisionEndIndex -= 1;\n      } // insert a Moveto segment to ensure secondPath will be valid:\n\n\n      var movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n      pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n      divisionEndIndex += 1; // do not insert the part if it looks like a point\n\n      if (!divided[1].isDifferentiable()) {\n        pathCopy.removeSegment(divisionEndIndex - 1);\n        divisionEndIndex -= 1;\n      } // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\n      var secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\n      for (var _i = divisionEndIndex, _ii = pathCopy.segments.length; _i < _ii; _i += 1) {\n        var originalSegment = this.getSegment(_i - secondPathSegmentIndexConversion);\n\n        var _segment = pathCopy.getSegment(_i);\n\n        if (_segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(_segment.subpathStartSegment.end)) {\n          // pathCopy segment's subpathStartSegment is different from original segment's one\n          // convert this Closepath segment to a Lineto and replace it in pathCopy\n          var convertedSegment = Path.createSegment('L', originalSegment.end);\n          pathCopy.replaceSegment(_i, convertedSegment);\n        }\n      } // distribute pathCopy segments into two paths and return those:\n\n\n      var firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n      var secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n      return [firstPath, secondPath];\n    }\n  }, {\n    key: \"intersectsWithLine\",\n    value: function intersectsWithLine(line) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var polylines = this.toPolylines(options);\n\n      if (polylines == null) {\n        return null;\n      }\n\n      var intersections = null;\n\n      for (var i = 0, ii = polylines.length; i < ii; i += 1) {\n        var polyline = polylines[i];\n        var intersection = line.intersect(polyline);\n\n        if (intersection) {\n          if (intersections == null) {\n            intersections = [];\n          }\n\n          if (Array.isArray(intersection)) {\n            var _intersections;\n\n            (_intersections = intersections).push.apply(_intersections, _toConsumableArray(intersection));\n          } else {\n            intersections.push(intersection);\n          }\n        }\n      }\n\n      return intersections;\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var segment = this.segments[i];\n\n        if (segment.isDifferentiable()) {\n          return true;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"isValid\",\n    value: function isValid() {\n      var segments = this.segments;\n      var isValid = segments.length === 0 || segments[0].type === 'M';\n      return isValid;\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (this.segments.length === 0) {\n        return 0;\n      }\n\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var length = 0;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var segment = this.segments[i];\n        var subdivisions = segmentSubdivisions[i];\n        length += segment.length({\n          subdivisions: subdivisions\n        });\n      }\n\n      return length;\n    }\n  }, {\n    key: \"lengthAtT\",\n    value: function lengthAtT(t) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var count = this.segments.length;\n\n      if (count === 0) {\n        return 0;\n      }\n\n      var segmentIndex = t.segmentIndex;\n\n      if (segmentIndex < 0) {\n        return 0;\n      }\n\n      var tValue = clamp(t.value, 0, 1);\n\n      if (segmentIndex >= count) {\n        segmentIndex = count - 1;\n        tValue = 1;\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var length = 0;\n\n      for (var i = 0; i < segmentIndex; i += 1) {\n        var _segment2 = this.segments[i];\n        var _subdivisions = segmentSubdivisions[i];\n        length += _segment2.length({\n          precision: precision,\n          subdivisions: _subdivisions\n        });\n      }\n\n      var segment = this.segments[segmentIndex];\n      var subdivisions = segmentSubdivisions[segmentIndex];\n      length += segment.lengthAtT(tValue, {\n        precision: precision,\n        subdivisions: subdivisions\n      });\n      return length;\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var rate = clamp(ratio, 0, 1);\n      var opts = this.getOptions(options);\n      var len = this.length(opts);\n      var length = len * rate;\n      return this.tangentAtLength(length, opts);\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (this.segments.length === 0) {\n        return null;\n      }\n\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var lastValidSegment;\n      var memo = 0;\n\n      for (var i = 0, ii = this.segments.length; i < ii; i += 1) {\n        var index = fromStart ? i : ii - 1 - i;\n        var segment = this.segments[index];\n        var subdivisions = segmentSubdivisions[index];\n        var len = segment.length({\n          precision: precision,\n          subdivisions: subdivisions\n        });\n\n        if (segment.isDifferentiable()) {\n          if (length <= memo + len) {\n            return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {\n              precision: precision,\n              subdivisions: subdivisions\n            });\n          }\n\n          lastValidSegment = segment;\n        }\n\n        memo += len;\n      } // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\n\n      if (lastValidSegment) {\n        var t = fromStart ? 1 : 0;\n        return lastValidSegment.tangentAtT(t);\n      } // if no valid segment, return null\n\n\n      return null;\n    }\n  }, {\n    key: \"tangentAtT\",\n    value: function tangentAtT(t) {\n      var count = this.segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      var segmentIndex = t.segmentIndex;\n\n      if (segmentIndex < 0) {\n        return this.segments[0].tangentAtT(0);\n      }\n\n      if (segmentIndex >= count) {\n        return this.segments[count - 1].tangentAtT(1);\n      }\n\n      var tValue = clamp(t.value, 0, 1);\n      return this.segments[segmentIndex].tangentAtT(tValue);\n    }\n  }, {\n    key: \"getPrecision\",\n    value: function getPrecision() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return options.precision == null ? this.PRECISION : options.precision;\n    }\n  }, {\n    key: \"getSubdivisions\",\n    value: function getSubdivisions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.segmentSubdivisions == null) {\n        var precision = this.getPrecision(options);\n        return this.getSegmentSubdivisions({\n          precision: precision\n        });\n      }\n\n      return options.segmentSubdivisions;\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var precision = this.getPrecision(options);\n      var segmentSubdivisions = this.getSubdivisions(options);\n      return {\n        precision: precision,\n        segmentSubdivisions: segmentSubdivisions\n      };\n    }\n  }, {\n    key: \"toPoints\",\n    value: function toPoints() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var segments = this.segments;\n      var count = segments.length;\n\n      if (count === 0) {\n        return null;\n      }\n\n      var segmentSubdivisions = this.getSubdivisions(options);\n      var points = [];\n      var partialPoints = [];\n\n      for (var i = 0; i < count; i += 1) {\n        var segment = segments[i];\n\n        if (segment.isVisible) {\n          var divisions = segmentSubdivisions[i];\n\n          if (divisions.length > 0) {\n            // eslint-disable-next-line no-loop-func\n            divisions.forEach(function (c) {\n              return partialPoints.push(c.start);\n            });\n          } else {\n            partialPoints.push(segment.start);\n          }\n        } else if (partialPoints.length > 0) {\n          partialPoints.push(segments[i - 1].end);\n          points.push(partialPoints);\n          partialPoints = [];\n        }\n      }\n\n      if (partialPoints.length > 0) {\n        partialPoints.push(this.end);\n        points.push(partialPoints);\n      }\n\n      return points;\n    }\n  }, {\n    key: \"toPolylines\",\n    value: function toPolylines() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var points = this.toPoints(options);\n\n      if (!points) {\n        return null;\n      }\n\n      return points.map(function (arr) {\n        return new Polyline(arr);\n      });\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      this.segments.forEach(function (s) {\n        return s.scale(sx, sy, origin);\n      });\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.segments.forEach(function (segment) {\n        return segment.rotate(angle, origin);\n      });\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      if (typeof tx === 'number') {\n        this.segments.forEach(function (s) {\n          return s.translate(tx, ty);\n        });\n      } else {\n        this.segments.forEach(function (s) {\n          return s.translate(tx);\n        });\n      }\n\n      return this;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      var path = new Path();\n      this.segments.forEach(function (s) {\n        return path.appendSegment(s.clone());\n      });\n      return path;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(p) {\n      if (p == null) {\n        return false;\n      }\n\n      var segments = this.segments;\n      var otherSegments = p.segments;\n      var count = segments.length;\n\n      if (otherSegments.length !== count) {\n        return false;\n      }\n\n      for (var i = 0; i < count; i += 1) {\n        var a = segments[i];\n        var b = otherSegments[i];\n\n        if (a.type !== b.type || !a.equals(b)) {\n          return false;\n        }\n      }\n\n      return true;\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return this.segments.map(function (s) {\n        return s.toJSON();\n      });\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      if (!this.isValid()) {\n        throw new Error('Invalid path segments.');\n      }\n\n      return this.segments.map(function (s) {\n        return s.serialize();\n      }).join(' ');\n    }\n  }, {\n    key: \"toString\",\n    value: function toString() {\n      return this.serialize();\n    }\n  }]);\n\n  return Path;\n}(Geometry, Symbol.toStringTag);\n\n(function (Path) {\n  Path.toStringTag = \"X6.Geometry.\".concat(Path.name);\n\n  function isPath(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Path) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var path = instance;\n\n    if ((tag == null || tag === Path.toStringTag) && Array.isArray(path.segments) && typeof path.moveTo === 'function' && typeof path.lineTo === 'function' && typeof path.curveTo === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Path.isPath = isPath;\n})(Path || (Path = {}));\n\n(function (Path) {\n  function parse(pathData) {\n    if (!pathData) {\n      return new Path();\n    }\n\n    var path = new Path();\n    var commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    var commands = Path.normalize(pathData).match(commandRe);\n\n    if (commands != null) {\n      for (var i = 0, ii = commands.length; i < ii; i += 1) {\n        var command = commands[i];\n        var argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g; // args = [type, coordinate1, coordinate2...]\n\n        var args = command.match(argRe);\n\n        if (args != null) {\n          var type = args[0];\n          var coords = args.slice(1).map(function (a) {\n            return +a;\n          });\n          var segment = createSegment.call.apply(createSegment, [null, type].concat(_toConsumableArray(coords)));\n          path.appendSegment(segment);\n        }\n      }\n    }\n\n    return path;\n  }\n\n  Path.parse = parse;\n\n  function createSegment(type) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n\n    if (type === 'M') {\n      var _MoveTo$create2;\n\n      return (_MoveTo$create2 = MoveTo.create).call.apply(_MoveTo$create2, [null].concat(args));\n    }\n\n    if (type === 'L') {\n      var _LineTo$create2;\n\n      return (_LineTo$create2 = LineTo.create).call.apply(_LineTo$create2, [null].concat(args));\n    }\n\n    if (type === 'C') {\n      var _CurveTo$create2;\n\n      return (_CurveTo$create2 = CurveTo.create).call.apply(_CurveTo$create2, [null].concat(args));\n    }\n\n    if (type === 'z' || type === 'Z') {\n      return Close.create();\n    }\n\n    throw new Error(\"Invalid path segment type \\\"\".concat(type, \"\\\"\"));\n  }\n\n  Path.createSegment = createSegment;\n})(Path || (Path = {}));\n\n(function (Path) {\n  Path.normalize = normalizePathData;\n  Path.isValid = Util.isValid;\n  Path.drawArc = Util.drawArc;\n  Path.drawPoints = Util.drawPoints;\n  Path.arcToCurves = Util.arcToCurves;\n})(Path || (Path = {}));","map":{"version":3,"sources":["../../../src/geometry/path/path.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { clamp, squaredLength } from '../util';\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Curve } from '../curve';\nimport { Polyline } from '../polyline';\nimport { Rectangle } from '../rectangle';\nimport { Geometry } from '../geometry';\nimport { Close } from './close';\nimport { LineTo } from './lineto';\nimport { MoveTo } from './moveto';\nimport { CurveTo } from './curveto';\nimport { normalizePathData } from './normalize';\nimport * as Util from './util';\nexport class Path extends Geometry {\n    constructor(args) {\n        super();\n        this.PRECISION = 3;\n        this.segments = [];\n        if (Array.isArray(args)) {\n            if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n                let previousObj = null;\n                const arr = args;\n                arr.forEach((o, i) => {\n                    if (i === 0) {\n                        this.appendSegment(Path.createSegment('M', o.start));\n                    }\n                    if (previousObj != null && !previousObj.end.equals(o.start)) {\n                        this.appendSegment(Path.createSegment('M', o.start));\n                    }\n                    if (Line.isLine(o)) {\n                        this.appendSegment(Path.createSegment('L', o.end));\n                    }\n                    else if (Curve.isCurve(o)) {\n                        this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));\n                    }\n                    previousObj = o;\n                });\n            }\n            else {\n                const arr = args;\n                arr.forEach((s) => {\n                    if (s.isSegment) {\n                        this.appendSegment(s);\n                    }\n                });\n            }\n        }\n        else if (args != null) {\n            if (Line.isLine(args)) {\n                this.appendSegment(Path.createSegment('M', args.start));\n                this.appendSegment(Path.createSegment('L', args.end));\n            }\n            else if (Curve.isCurve(args)) {\n                this.appendSegment(Path.createSegment('M', args.start));\n                this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));\n            }\n            else if (Polyline.isPolyline(args)) {\n                if (args.points && args.points.length) {\n                    args.points.forEach((point, index) => {\n                        const segment = index === 0\n                            ? Path.createSegment('M', point)\n                            : Path.createSegment('L', point);\n                        this.appendSegment(segment);\n                    });\n                }\n            }\n            else if (args.isSegment) {\n                this.appendSegment(args);\n            }\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return Path.toStringTag;\n    }\n    get start() {\n        const segments = this.segments;\n        const count = segments.length;\n        if (count === 0) {\n            return null;\n        }\n        for (let i = 0; i < count; i += 1) {\n            const segment = segments[i];\n            if (segment.isVisible) {\n                return segment.start;\n            }\n        }\n        // if no visible segment, return last segment end point\n        return segments[count - 1].end;\n    }\n    get end() {\n        const segments = this.segments;\n        const count = segments.length;\n        if (count === 0) {\n            return null;\n        }\n        for (let i = count - 1; i >= 0; i -= 1) {\n            const segment = segments[i];\n            if (segment.isVisible) {\n                return segment.end;\n            }\n        }\n        // if no visible segment, return last segment end point\n        return segments[count - 1].end;\n    }\n    moveTo(...args) {\n        return this.appendSegment(MoveTo.create.call(null, ...args));\n    }\n    lineTo(...args) {\n        return this.appendSegment(LineTo.create.call(null, ...args));\n    }\n    curveTo(...args) {\n        return this.appendSegment(CurveTo.create.call(null, ...args));\n    }\n    arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {\n        const start = this.end || new Point();\n        const points = typeof endX === 'number'\n            ? Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY)\n            : Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);\n        if (points != null) {\n            for (let i = 0, ii = points.length; i < ii; i += 6) {\n                this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n            }\n        }\n        return this;\n    }\n    quadTo(x1, y1, x, y) {\n        const start = this.end || new Point();\n        const data = ['M', start.x, start.y];\n        if (typeof x1 === 'number') {\n            data.push('Q', x1, y1, x, y);\n        }\n        else {\n            const p = y1;\n            data.push(`Q`, x1.x, x1.y, p.x, p.y);\n        }\n        const path = Path.parse(data.join(' '));\n        this.appendSegment(path.segments.slice(1));\n        return this;\n    }\n    close() {\n        return this.appendSegment(Close.create());\n    }\n    drawPoints(points, options = {}) {\n        const raw = Util.drawPoints(points, options);\n        const sub = Path.parse(raw);\n        if (sub && sub.segments) {\n            this.appendSegment(sub.segments);\n        }\n    }\n    bbox() {\n        const segments = this.segments;\n        const count = segments.length;\n        if (count === 0) {\n            return null;\n        }\n        let bbox;\n        for (let i = 0; i < count; i += 1) {\n            const segment = segments[i];\n            if (segment.isVisible) {\n                const segmentBBox = segment.bbox();\n                if (segmentBBox != null) {\n                    bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n                }\n            }\n        }\n        if (bbox != null) {\n            return bbox;\n        }\n        // if the path has only invisible elements, return end point of last segment\n        const lastSegment = segments[count - 1];\n        return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    }\n    appendSegment(seg) {\n        const count = this.segments.length;\n        let previousSegment = count !== 0 ? this.segments[count - 1] : null;\n        let currentSegment;\n        const nextSegment = null;\n        if (Array.isArray(seg)) {\n            for (let i = 0, ii = seg.length; i < ii; i += 1) {\n                const segment = seg[i];\n                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n                this.segments.push(currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n        else if (seg != null && seg.isSegment) {\n            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n            this.segments.push(currentSegment);\n        }\n        return this;\n    }\n    insertSegment(index, seg) {\n        const count = this.segments.length;\n        if (index < 0) {\n            index = count + index + 1; // eslint-disable-line\n        }\n        if (index > count || index < 0) {\n            throw new Error('Index out of range.');\n        }\n        let currentSegment;\n        let previousSegment = null;\n        let nextSegment = null;\n        if (count !== 0) {\n            if (index >= 1) {\n                previousSegment = this.segments[index - 1];\n                nextSegment = previousSegment.nextSegment;\n            }\n            else {\n                previousSegment = null;\n                nextSegment = this.segments[0];\n            }\n        }\n        if (!Array.isArray(seg)) {\n            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n            this.segments.splice(index, 0, currentSegment);\n        }\n        else {\n            for (let i = 0, ii = seg.length; i < ii; i += 1) {\n                const segment = seg[i];\n                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n                this.segments.splice(index + i, 0, currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n        return this;\n    }\n    removeSegment(index) {\n        const idx = this.fixIndex(index);\n        const removedSegment = this.segments.splice(idx, 1)[0];\n        const previousSegment = removedSegment.previousSegment;\n        const nextSegment = removedSegment.nextSegment;\n        // link the previous and next segments together (if present)\n        if (previousSegment) {\n            previousSegment.nextSegment = nextSegment;\n        }\n        if (nextSegment) {\n            nextSegment.previousSegment = previousSegment;\n        }\n        if (removedSegment.isSubpathStart && nextSegment) {\n            this.updateSubpathStartSegment(nextSegment);\n        }\n        return removedSegment;\n    }\n    replaceSegment(index, seg) {\n        const idx = this.fixIndex(index);\n        let currentSegment;\n        const replacedSegment = this.segments[idx];\n        let previousSegment = replacedSegment.previousSegment;\n        const nextSegment = replacedSegment.nextSegment;\n        let updateSubpathStart = replacedSegment.isSubpathStart;\n        if (!Array.isArray(seg)) {\n            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n            this.segments.splice(idx, 1, currentSegment);\n            if (updateSubpathStart && currentSegment.isSubpathStart) {\n                // already updated by `prepareSegment`\n                updateSubpathStart = false;\n            }\n        }\n        else {\n            this.segments.splice(index, 1);\n            for (let i = 0, ii = seg.length; i < ii; i += 1) {\n                const segment = seg[i];\n                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n                this.segments.splice(index + i, 0, currentSegment);\n                previousSegment = currentSegment;\n                if (updateSubpathStart && currentSegment.isSubpathStart) {\n                    updateSubpathStart = false;\n                }\n            }\n        }\n        if (updateSubpathStart && nextSegment) {\n            this.updateSubpathStartSegment(nextSegment);\n        }\n    }\n    getSegment(index) {\n        const idx = this.fixIndex(index);\n        return this.segments[idx];\n    }\n    fixIndex(index) {\n        const length = this.segments.length;\n        if (length === 0) {\n            throw new Error('Path has no segments.');\n        }\n        let i = index;\n        while (i < 0) {\n            i = length + i;\n        }\n        if (i >= length || i < 0) {\n            throw new Error('Index out of range.');\n        }\n        return i;\n    }\n    segmentAt(ratio, options = {}) {\n        const index = this.segmentIndexAt(ratio, options);\n        if (!index) {\n            return null;\n        }\n        return this.getSegment(index);\n    }\n    segmentAtLength(length, options = {}) {\n        const index = this.segmentIndexAtLength(length, options);\n        if (!index)\n            return null;\n        return this.getSegment(index);\n    }\n    segmentIndexAt(ratio, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        const rate = clamp(ratio, 0, 1);\n        const opt = this.getOptions(options);\n        const len = this.length(opt);\n        const length = len * rate;\n        return this.segmentIndexAtLength(length, opt);\n    }\n    segmentIndexAtLength(length, options = {}) {\n        const count = this.segments.length;\n        if (count === 0) {\n            return null;\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let memo = 0;\n        let lastVisibleIndex = null;\n        for (let i = 0; i < count; i += 1) {\n            const index = fromStart ? i : count - 1 - i;\n            const segment = this.segments[index];\n            const subdivisions = segmentSubdivisions[index];\n            const len = segment.length({ precision, subdivisions });\n            if (segment.isVisible) {\n                if (length <= memo + len) {\n                    return index;\n                }\n                lastVisibleIndex = index;\n            }\n            memo += len;\n        }\n        // If length requested is higher than the length of the path, return\n        // last visible segment index. If no visible segment, return null.\n        return lastVisibleIndex;\n    }\n    getSegmentSubdivisions(options = {}) {\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = [];\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const segment = this.segments[i];\n            const subdivisions = segment.getSubdivisions({ precision });\n            segmentSubdivisions.push(subdivisions);\n        }\n        return segmentSubdivisions;\n    }\n    updateSubpathStartSegment(segment) {\n        let previous = segment.previousSegment;\n        let current = segment;\n        while (current && !current.isSubpathStart) {\n            // assign previous segment's subpath start segment to this segment\n            if (previous != null) {\n                current.subpathStartSegment = previous.subpathStartSegment;\n            }\n            else {\n                current.subpathStartSegment = null;\n            }\n            previous = current;\n            current = current.nextSegment;\n        }\n    }\n    prepareSegment(segment, previousSegment, nextSegment) {\n        segment.previousSegment = previousSegment;\n        segment.nextSegment = nextSegment;\n        if (previousSegment != null) {\n            previousSegment.nextSegment = segment;\n        }\n        if (nextSegment != null) {\n            nextSegment.previousSegment = segment;\n        }\n        let updateSubpathStart = segment;\n        if (segment.isSubpathStart) {\n            // move to\n            segment.subpathStartSegment = segment;\n            updateSubpathStart = nextSegment;\n        }\n        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n        if (updateSubpathStart != null) {\n            this.updateSubpathStartSegment(updateSubpathStart);\n        }\n        return segment;\n    }\n    closestPoint(p, options = {}) {\n        const t = this.closestPointT(p, options);\n        if (!t) {\n            return null;\n        }\n        return this.pointAtT(t);\n    }\n    closestPointLength(p, options = {}) {\n        const opts = this.getOptions(options);\n        const t = this.closestPointT(p, opts);\n        if (!t) {\n            return 0;\n        }\n        return this.lengthAtT(t, opts);\n    }\n    closestPointNormalizedLength(p, options = {}) {\n        const opts = this.getOptions(options);\n        const cpLength = this.closestPointLength(p, opts);\n        if (cpLength === 0) {\n            return 0;\n        }\n        const length = this.length(opts);\n        if (length === 0) {\n            return 0;\n        }\n        return cpLength / length;\n    }\n    closestPointT(p, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let closestPointT;\n        let minSquaredDistance = Infinity;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const segment = this.segments[i];\n            const subdivisions = segmentSubdivisions[i];\n            if (segment.isVisible) {\n                const segmentClosestPointT = segment.closestPointT(p, {\n                    precision,\n                    subdivisions,\n                });\n                const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                const squaredDistance = squaredLength(segmentClosestPoint, p);\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n        if (closestPointT) {\n            return closestPointT;\n        }\n        return { segmentIndex: this.segments.length - 1, value: 1 };\n    }\n    closestPointTangent(p, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let closestPointTangent;\n        let minSquaredDistance = Infinity;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const segment = this.segments[i];\n            const subdivisions = segmentSubdivisions[i];\n            if (segment.isDifferentiable()) {\n                const segmentClosestPointT = segment.closestPointT(p, {\n                    precision,\n                    subdivisions,\n                });\n                const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                const squaredDistance = squaredLength(segmentClosestPoint, p);\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n        if (closestPointTangent) {\n            return closestPointTangent;\n        }\n        return null;\n    }\n    containsPoint(p, options = {}) {\n        const polylines = this.toPolylines(options);\n        if (!polylines) {\n            return false;\n        }\n        let numIntersections = 0;\n        for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n            const polyline = polylines[i];\n            if (polyline.containsPoint(p)) {\n                numIntersections += 1;\n            }\n        }\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return numIntersections % 2 === 1;\n    }\n    pointAt(ratio, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        if (ratio <= 0) {\n            return this.start.clone();\n        }\n        if (ratio >= 1) {\n            return this.end.clone();\n        }\n        const opts = this.getOptions(options);\n        const pathLength = this.length(opts);\n        const length = pathLength * ratio;\n        return this.pointAtLength(length, opts);\n    }\n    pointAtLength(length, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        if (length === 0) {\n            return this.start.clone();\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let lastVisibleSegment;\n        let memo = 0;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const index = fromStart ? i : ii - 1 - i;\n            const segment = this.segments[index];\n            const subdivisions = segmentSubdivisions[index];\n            const d = segment.length({\n                precision,\n                subdivisions,\n            });\n            if (segment.isVisible) {\n                if (length <= memo + d) {\n                    return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n                        precision,\n                        subdivisions,\n                    });\n                }\n                lastVisibleSegment = segment;\n            }\n            memo += d;\n        }\n        // if length requested is higher than the length of the path,\n        // return last visible segment endpoint\n        if (lastVisibleSegment) {\n            return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n        }\n        // if no visible segment, return last segment end point\n        const lastSegment = this.segments[this.segments.length - 1];\n        return lastSegment.end.clone();\n    }\n    pointAtT(t) {\n        const segments = this.segments;\n        const numSegments = segments.length;\n        if (numSegments === 0)\n            return null; // if segments is an empty array\n        const segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0)\n            return segments[0].pointAtT(0);\n        if (segmentIndex >= numSegments) {\n            return segments[numSegments - 1].pointAtT(1);\n        }\n        const tValue = clamp(t.value, 0, 1);\n        return segments[segmentIndex].pointAtT(tValue);\n    }\n    divideAt(ratio, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        const rate = clamp(ratio, 0, 1);\n        const opts = this.getOptions(options);\n        const len = this.length(opts);\n        const length = len * rate;\n        return this.divideAtLength(length, opts);\n    }\n    divideAtLength(length, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let memo = 0;\n        let divided;\n        let dividedSegmentIndex;\n        let lastValidSegment;\n        let lastValidSegmentIndex;\n        let t;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const index = fromStart ? i : ii - 1 - i;\n            const segment = this.getSegment(index);\n            const subdivisions = segmentSubdivisions[index];\n            const opts = { precision, subdivisions };\n            const len = segment.length(opts);\n            if (segment.isDifferentiable()) {\n                lastValidSegment = segment;\n                lastValidSegmentIndex = index;\n                if (length <= memo + len) {\n                    dividedSegmentIndex = index;\n                    divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);\n                    break;\n                }\n            }\n            memo += len;\n        }\n        if (!lastValidSegment) {\n            return null;\n        }\n        if (!divided) {\n            dividedSegmentIndex = lastValidSegmentIndex;\n            t = fromStart ? 1 : 0;\n            divided = lastValidSegment.divideAtT(t);\n        }\n        // create a copy of this path and replace the identified segment with its two divided parts:\n        const pathCopy = this.clone();\n        const index = dividedSegmentIndex;\n        pathCopy.replaceSegment(index, divided);\n        const divisionStartIndex = index;\n        let divisionMidIndex = index + 1;\n        let divisionEndIndex = index + 2;\n        // do not insert the part if it looks like a point\n        if (!divided[0].isDifferentiable()) {\n            pathCopy.removeSegment(divisionStartIndex);\n            divisionMidIndex -= 1;\n            divisionEndIndex -= 1;\n        }\n        // insert a Moveto segment to ensure secondPath will be valid:\n        const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n        divisionEndIndex += 1;\n        // do not insert the part if it looks like a point\n        if (!divided[1].isDifferentiable()) {\n            pathCopy.removeSegment(divisionEndIndex - 1);\n            divisionEndIndex -= 1;\n        }\n        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n        const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n        for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {\n            const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n            const segment = pathCopy.getSegment(i);\n            if (segment.type === 'Z' &&\n                !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                // pathCopy segment's subpathStartSegment is different from original segment's one\n                // convert this Closepath segment to a Lineto and replace it in pathCopy\n                const convertedSegment = Path.createSegment('L', originalSegment.end);\n                pathCopy.replaceSegment(i, convertedSegment);\n            }\n        }\n        // distribute pathCopy segments into two paths and return those:\n        const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n        const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n        return [firstPath, secondPath];\n    }\n    intersectsWithLine(line, options = {}) {\n        const polylines = this.toPolylines(options);\n        if (polylines == null) {\n            return null;\n        }\n        let intersections = null;\n        for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n            const polyline = polylines[i];\n            const intersection = line.intersect(polyline);\n            if (intersection) {\n                if (intersections == null) {\n                    intersections = [];\n                }\n                if (Array.isArray(intersection)) {\n                    intersections.push(...intersection);\n                }\n                else {\n                    intersections.push(intersection);\n                }\n            }\n        }\n        return intersections;\n    }\n    isDifferentiable() {\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const segment = this.segments[i];\n            if (segment.isDifferentiable()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isValid() {\n        const segments = this.segments;\n        const isValid = segments.length === 0 || segments[0].type === 'M';\n        return isValid;\n    }\n    length(options = {}) {\n        if (this.segments.length === 0) {\n            return 0;\n        }\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let length = 0;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const segment = this.segments[i];\n            const subdivisions = segmentSubdivisions[i];\n            length += segment.length({ subdivisions });\n        }\n        return length;\n    }\n    lengthAtT(t, options = {}) {\n        const count = this.segments.length;\n        if (count === 0) {\n            return 0;\n        }\n        let segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) {\n            return 0;\n        }\n        let tValue = clamp(t.value, 0, 1);\n        if (segmentIndex >= count) {\n            segmentIndex = count - 1;\n            tValue = 1;\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let length = 0;\n        for (let i = 0; i < segmentIndex; i += 1) {\n            const segment = this.segments[i];\n            const subdivisions = segmentSubdivisions[i];\n            length += segment.length({ precision, subdivisions });\n        }\n        const segment = this.segments[segmentIndex];\n        const subdivisions = segmentSubdivisions[segmentIndex];\n        length += segment.lengthAtT(tValue, { precision, subdivisions });\n        return length;\n    }\n    tangentAt(ratio, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        const rate = clamp(ratio, 0, 1);\n        const opts = this.getOptions(options);\n        const len = this.length(opts);\n        const length = len * rate;\n        return this.tangentAtLength(length, opts);\n    }\n    tangentAtLength(length, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let lastValidSegment;\n        let memo = 0;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const index = fromStart ? i : ii - 1 - i;\n            const segment = this.segments[index];\n            const subdivisions = segmentSubdivisions[index];\n            const len = segment.length({ precision, subdivisions });\n            if (segment.isDifferentiable()) {\n                if (length <= memo + len) {\n                    return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {\n                        precision,\n                        subdivisions,\n                    });\n                }\n                lastValidSegment = segment;\n            }\n            memo += len;\n        }\n        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n        if (lastValidSegment) {\n            const t = fromStart ? 1 : 0;\n            return lastValidSegment.tangentAtT(t);\n        }\n        // if no valid segment, return null\n        return null;\n    }\n    tangentAtT(t) {\n        const count = this.segments.length;\n        if (count === 0) {\n            return null;\n        }\n        const segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) {\n            return this.segments[0].tangentAtT(0);\n        }\n        if (segmentIndex >= count) {\n            return this.segments[count - 1].tangentAtT(1);\n        }\n        const tValue = clamp(t.value, 0, 1);\n        return this.segments[segmentIndex].tangentAtT(tValue);\n    }\n    getPrecision(options = {}) {\n        return options.precision == null ? this.PRECISION : options.precision;\n    }\n    getSubdivisions(options = {}) {\n        if (options.segmentSubdivisions == null) {\n            const precision = this.getPrecision(options);\n            return this.getSegmentSubdivisions({ precision });\n        }\n        return options.segmentSubdivisions;\n    }\n    getOptions(options = {}) {\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        return { precision, segmentSubdivisions };\n    }\n    toPoints(options = {}) {\n        const segments = this.segments;\n        const count = segments.length;\n        if (count === 0) {\n            return null;\n        }\n        const segmentSubdivisions = this.getSubdivisions(options);\n        const points = [];\n        let partialPoints = [];\n        for (let i = 0; i < count; i += 1) {\n            const segment = segments[i];\n            if (segment.isVisible) {\n                const divisions = segmentSubdivisions[i];\n                if (divisions.length > 0) {\n                    // eslint-disable-next-line no-loop-func\n                    divisions.forEach((c) => partialPoints.push(c.start));\n                }\n                else {\n                    partialPoints.push(segment.start);\n                }\n            }\n            else if (partialPoints.length > 0) {\n                partialPoints.push(segments[i - 1].end);\n                points.push(partialPoints);\n                partialPoints = [];\n            }\n        }\n        if (partialPoints.length > 0) {\n            partialPoints.push(this.end);\n            points.push(partialPoints);\n        }\n        return points;\n    }\n    toPolylines(options = {}) {\n        const points = this.toPoints(options);\n        if (!points) {\n            return null;\n        }\n        return points.map((arr) => new Polyline(arr));\n    }\n    scale(sx, sy, origin) {\n        this.segments.forEach((s) => s.scale(sx, sy, origin));\n        return this;\n    }\n    rotate(angle, origin) {\n        this.segments.forEach((segment) => segment.rotate(angle, origin));\n        return this;\n    }\n    translate(tx, ty) {\n        if (typeof tx === 'number') {\n            this.segments.forEach((s) => s.translate(tx, ty));\n        }\n        else {\n            this.segments.forEach((s) => s.translate(tx));\n        }\n        return this;\n    }\n    clone() {\n        const path = new Path();\n        this.segments.forEach((s) => path.appendSegment(s.clone()));\n        return path;\n    }\n    equals(p) {\n        if (p == null) {\n            return false;\n        }\n        const segments = this.segments;\n        const otherSegments = p.segments;\n        const count = segments.length;\n        if (otherSegments.length !== count) {\n            return false;\n        }\n        for (let i = 0; i < count; i += 1) {\n            const a = segments[i];\n            const b = otherSegments[i];\n            if (a.type !== b.type || !a.equals(b)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toJSON() {\n        return this.segments.map((s) => s.toJSON());\n    }\n    serialize() {\n        if (!this.isValid()) {\n            throw new Error('Invalid path segments.');\n        }\n        return this.segments.map((s) => s.serialize()).join(' ');\n    }\n    toString() {\n        return this.serialize();\n    }\n}\n(function (Path) {\n    Path.toStringTag = `X6.Geometry.${Path.name}`;\n    function isPath(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Path) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const path = instance;\n        if ((tag == null || tag === Path.toStringTag) &&\n            Array.isArray(path.segments) &&\n            typeof path.moveTo === 'function' &&\n            typeof path.lineTo === 'function' &&\n            typeof path.curveTo === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Path.isPath = isPath;\n})(Path || (Path = {}));\n(function (Path) {\n    function parse(pathData) {\n        if (!pathData) {\n            return new Path();\n        }\n        const path = new Path();\n        const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n        const commands = Path.normalize(pathData).match(commandRe);\n        if (commands != null) {\n            for (let i = 0, ii = commands.length; i < ii; i += 1) {\n                const command = commands[i];\n                const argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n                // args = [type, coordinate1, coordinate2...]\n                const args = command.match(argRe);\n                if (args != null) {\n                    const type = args[0];\n                    const coords = args.slice(1).map((a) => +a);\n                    const segment = createSegment.call(null, type, ...coords);\n                    path.appendSegment(segment);\n                }\n            }\n        }\n        return path;\n    }\n    Path.parse = parse;\n    function createSegment(type, ...args) {\n        if (type === 'M') {\n            return MoveTo.create.call(null, ...args);\n        }\n        if (type === 'L') {\n            return LineTo.create.call(null, ...args);\n        }\n        if (type === 'C') {\n            return CurveTo.create.call(null, ...args);\n        }\n        if (type === 'z' || type === 'Z') {\n            return Close.create();\n        }\n        throw new Error(`Invalid path segment type \"${type}\"`);\n    }\n    Path.createSegment = createSegment;\n})(Path || (Path = {}));\n(function (Path) {\n    Path.normalize = normalizePathData;\n    Path.isValid = Util.isValid;\n    Path.drawArc = Util.drawArc;\n    Path.drawPoints = Util.drawPoints;\n    Path.arcToCurves = Util.arcToCurves;\n})(Path || (Path = {}));\n//# sourceMappingURL=path.js.map"]},"metadata":{},"sourceType":"module"}