{"ast":null,"code":"import { Path } from '../../geometry';\nimport * as Dom from '../dom/core';\nexport class Vector {\n  constructor(elem, attrs, children) {\n    if (!elem) {\n      throw new TypeError('Invalid element to create vector');\n    }\n\n    let node;\n\n    if (Vector.isVector(elem)) {\n      node = elem.node;\n    } else if (typeof elem === 'string') {\n      if (elem.toLowerCase() === 'svg') {\n        node = Dom.createSvgDocument();\n      } else if (elem[0] === '<') {\n        const doc = Dom.createSvgDocument(elem); // only import the first child\n\n        node = document.importNode(doc.firstChild, true);\n      } else {\n        node = document.createElementNS(Dom.ns.svg, elem);\n      }\n    } else {\n      node = elem;\n    }\n\n    this.node = node;\n\n    if (attrs) {\n      this.setAttributes(attrs);\n    }\n\n    if (children) {\n      this.append(children);\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return Vector.toStringTag;\n  }\n\n  get type() {\n    return this.node.nodeName;\n  }\n\n  get id() {\n    return this.node.id;\n  }\n\n  set id(id) {\n    this.node.id = id;\n  }\n\n  transform(matrix, options) {\n    if (matrix == null) {\n      return Dom.transform(this.node);\n    }\n\n    Dom.transform(this.node, matrix, options);\n    return this;\n  }\n\n  translate(tx) {\n    let ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (tx == null) {\n      return Dom.translate(this.node);\n    }\n\n    Dom.translate(this.node, tx, ty, options);\n    return this;\n  }\n\n  rotate(angle, cx, cy) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    if (angle == null) {\n      return Dom.rotate(this.node);\n    }\n\n    Dom.rotate(this.node, angle, cx, cy, options);\n    return this;\n  }\n\n  scale(sx, sy) {\n    if (sx == null) {\n      return Dom.scale(this.node);\n    }\n\n    Dom.scale(this.node, sx, sy);\n    return this;\n  }\n  /**\n   * Returns an SVGMatrix that specifies the transformation necessary\n   * to convert this coordinate system into `target` coordinate system.\n   */\n\n\n  getTransformToElement(target) {\n    const ref = Vector.toNode(target);\n    return Dom.getTransformToElement(this.node, ref);\n  }\n\n  removeAttribute(name) {\n    Dom.removeAttribute(this.node, name);\n    return this;\n  }\n\n  getAttribute(name) {\n    return Dom.getAttribute(this.node, name);\n  }\n\n  setAttribute(name, value) {\n    Dom.setAttribute(this.node, name, value);\n    return this;\n  }\n\n  setAttributes(attrs) {\n    Dom.setAttributes(this.node, attrs);\n    return this;\n  }\n\n  attr(name, value) {\n    if (name == null) {\n      return Dom.attr(this.node);\n    }\n\n    if (typeof name === 'string' && value === undefined) {\n      return Dom.attr(this.node, name);\n    }\n\n    if (typeof name === 'object') {\n      Dom.attr(this.node, name);\n    } else {\n      Dom.attr(this.node, name, value);\n    }\n\n    return this;\n  }\n\n  svg() {\n    return this.node instanceof SVGSVGElement ? this : Vector.create(this.node.ownerSVGElement);\n  }\n\n  defs() {\n    const context = this.svg() || this;\n    const defsNode = context.node.getElementsByTagName('defs')[0];\n\n    if (defsNode) {\n      return Vector.create(defsNode);\n    }\n\n    return Vector.create('defs').appendTo(context);\n  }\n\n  text(content) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    Dom.text(this.node, content, options);\n    return this;\n  }\n\n  tagName() {\n    return Dom.tagName(this.node);\n  }\n\n  clone() {\n    return Vector.create(this.node.cloneNode(true));\n  }\n\n  remove() {\n    Dom.remove(this.node);\n    return this;\n  }\n\n  empty() {\n    Dom.empty(this.node);\n    return this;\n  }\n\n  append(elems) {\n    Dom.append(this.node, Vector.toNodes(elems));\n    return this;\n  }\n\n  appendTo(target) {\n    Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target);\n    return this;\n  }\n\n  prepend(elems) {\n    Dom.prepend(this.node, Vector.toNodes(elems));\n    return this;\n  }\n\n  before(elems) {\n    Dom.before(this.node, Vector.toNodes(elems));\n    return this;\n  }\n\n  replace(elem) {\n    if (this.node.parentNode) {\n      this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);\n    }\n\n    return Vector.create(elem);\n  }\n\n  first() {\n    return this.node.firstChild ? Vector.create(this.node.firstChild) : null;\n  }\n\n  last() {\n    return this.node.lastChild ? Vector.create(this.node.lastChild) : null;\n  }\n\n  get(index) {\n    const child = this.node.childNodes[index];\n    return child ? Vector.create(child) : null;\n  }\n\n  indexOf(elem) {\n    const children = Array.prototype.slice.call(this.node.childNodes);\n    return children.indexOf(Vector.toNode(elem));\n  }\n\n  find(selector) {\n    const vels = [];\n    const nodes = Dom.find(this.node, selector);\n\n    if (nodes) {\n      for (let i = 0, ii = nodes.length; i < ii; i += 1) {\n        vels.push(Vector.create(nodes[i]));\n      }\n    }\n\n    return vels;\n  }\n\n  findOne(selector) {\n    const found = Dom.findOne(this.node, selector);\n    return found ? Vector.create(found) : null;\n  }\n\n  findParentByClass(className, terminator) {\n    const node = Dom.findParentByClass(this.node, className, terminator);\n    return node ? Vector.create(node) : null;\n  }\n\n  matches(selector) {\n    const node = this.node;\n    const matches = this.node.matches;\n    const matcher = node.matches || node.matchesSelector || node.msMatchesSelector || node.mozMatchesSelector || node.webkitMatchesSelector || node.oMatchesSelector || null;\n    return matcher && matcher.call(node, selector);\n  }\n\n  contains(child) {\n    return Dom.contains(this.node, Vector.isVector(child) ? child.node : child);\n  }\n\n  wrap(node) {\n    const vel = Vector.create(node);\n    const parentNode = this.node.parentNode;\n\n    if (parentNode != null) {\n      parentNode.insertBefore(vel.node, this.node);\n    }\n\n    return vel.append(this);\n  }\n\n  parent(type) {\n    let parent = this; // eslint-disable-line @typescript-eslint/no-this-alias\n    // check for parent\n\n    if (parent.node.parentNode == null) {\n      return null;\n    } // get parent element\n\n\n    parent = Vector.create(parent.node.parentNode);\n\n    if (type == null) {\n      return parent;\n    } // loop trough ancestors if type is given\n\n\n    do {\n      if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {\n        return parent;\n      }\n    } while (parent = Vector.create(parent.node.parentNode));\n\n    return parent;\n  }\n\n  children() {\n    const children = this.node.childNodes;\n    const vels = [];\n\n    for (let i = 0; i < children.length; i += 1) {\n      const currentChild = children[i];\n\n      if (currentChild.nodeType === 1) {\n        vels.push(Vector.create(children[i]));\n      }\n    }\n\n    return vels;\n  }\n\n  eachChild(fn, deep) {\n    const children = this.children();\n\n    for (let i = 0, l = children.length; i < l; i += 1) {\n      fn.call(children[i], children[i], i, children);\n\n      if (deep) {\n        children[i].eachChild(fn, deep);\n      }\n    }\n\n    return this;\n  }\n\n  index() {\n    return Dom.index(this.node);\n  }\n\n  hasClass(className) {\n    return Dom.hasClass(this.node, className);\n  }\n\n  addClass(className) {\n    Dom.addClass(this.node, className);\n    return this;\n  }\n\n  removeClass(className) {\n    Dom.removeClass(this.node, className);\n    return this;\n  }\n\n  toggleClass(className, stateVal) {\n    Dom.toggleClass(this.node, className, stateVal);\n    return this;\n  }\n\n  toLocalPoint(x, y) {\n    return Dom.toLocalPoint(this.node, x, y);\n  }\n\n  toGeometryShape() {\n    return Dom.toGeometryShape(this.node);\n  }\n\n  translateCenterToPoint(p) {\n    const bbox = this.getBBox({\n      target: this.svg()\n    });\n    const center = bbox.getCenter();\n    this.translate(p.x - center.x, p.y - center.y);\n    return this;\n  }\n\n  translateAndAutoOrient(position, reference, target) {\n    Dom.translateAndAutoOrient(this.node, position, reference, target);\n    return this;\n  }\n\n  animate(options) {\n    return Dom.animate(this.node, options);\n  }\n\n  animateTransform(options) {\n    return Dom.animateTransform(this.node, options);\n  }\n\n  animateAlongPath(options, path) {\n    return Dom.animateAlongPath(this.node, options, path);\n  }\n  /**\n   * Normalize this element's d attribute. SVGPathElements without\n   * a path data attribute obtain a value of 'M 0 0'.\n   */\n\n\n  normalizePath() {\n    const tagName = this.tagName();\n\n    if (tagName === 'path') {\n      this.attr('d', Path.normalize(this.attr('d')));\n    }\n\n    return this;\n  }\n  /**\n   * Returns the bounding box of the element after transformations are applied.\n   * If `withoutTransformations` is `true`, transformations of the element\n   * will not be considered when computing the bounding box. If `target` is\n   * specified, bounding box will be computed relatively to the target element.\n   */\n\n\n  bbox(withoutTransformations, target) {\n    return Dom.bbox(this.node, withoutTransformations, target);\n  }\n\n  getBBox() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return Dom.getBBox(this.node, {\n      recursive: options.recursive,\n      target: options.target ? Vector.toNode(options.target) : null\n    });\n  }\n  /**\n   * Samples the underlying SVG element (it currently works only on\n   * paths - where it is most useful anyway). Returns an array of objects\n   * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n   * objects represent a point on the path. This basically creates a discrete\n   * representation of the path (which is possible a curve). The sampling\n   * interval defines the accuracy of the sampling. In other words, we travel\n   * from the beginning of the path to the end by interval distance (on the\n   * path, not between the resulting points) and collect the discrete points\n   * on the path. This is very useful in many situations. For example, SVG\n   * does not provide a built-in mechanism to find intersections between two\n   * paths. Using sampling, we can just generate bunch of points for each of\n   * the path and find the closest ones from each set.\n   */\n\n\n  sample() {\n    let interval = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1;\n\n    if (this.node instanceof SVGPathElement) {\n      return Dom.sample(this.node, interval);\n    }\n\n    return [];\n  }\n\n  toPath() {\n    return Vector.create(Dom.toPath(this.node));\n  }\n\n  toPathData() {\n    return Dom.toPathData(this.node);\n  }\n\n}\n\n(function (Vector) {\n  Vector.toStringTag = `X6.${Vector.name}`;\n\n  function isVector(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Vector) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const vector = instance;\n\n    if ((tag == null || tag === Vector.toStringTag) && vector.node instanceof SVGElement && typeof vector.animate === 'function' && typeof vector.sample === 'function' && typeof vector.normalizePath === 'function' && typeof vector.toPath === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Vector.isVector = isVector;\n\n  function create(elem, attrs, children) {\n    return new Vector(elem, attrs, children);\n  }\n\n  Vector.create = create;\n\n  function createVectors(markup) {\n    if (markup[0] === '<') {\n      const svgDoc = Dom.createSvgDocument(markup);\n      const vels = [];\n\n      for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n        const childNode = svgDoc.childNodes[i];\n        vels.push(create(document.importNode(childNode, true)));\n      }\n\n      return vels;\n    }\n\n    return [create(markup)];\n  }\n\n  Vector.createVectors = createVectors;\n\n  function toNode(elem) {\n    if (isVector(elem)) {\n      return elem.node;\n    }\n\n    return elem;\n  }\n\n  Vector.toNode = toNode;\n\n  function toNodes(elems) {\n    if (Array.isArray(elems)) {\n      return elems.map(elem => toNode(elem));\n    }\n\n    return [toNode(elems)];\n  }\n\n  Vector.toNodes = toNodes;\n})(Vector || (Vector = {}));","map":{"version":3,"sources":["../../../src/util/vector/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Path } from '../../geometry';\nimport * as Dom from '../dom/core';\nexport class Vector {\n    constructor(elem, attrs, children) {\n        if (!elem) {\n            throw new TypeError('Invalid element to create vector');\n        }\n        let node;\n        if (Vector.isVector(elem)) {\n            node = elem.node;\n        }\n        else if (typeof elem === 'string') {\n            if (elem.toLowerCase() === 'svg') {\n                node = Dom.createSvgDocument();\n            }\n            else if (elem[0] === '<') {\n                const doc = Dom.createSvgDocument(elem);\n                // only import the first child\n                node = document.importNode(doc.firstChild, true);\n            }\n            else {\n                node = document.createElementNS(Dom.ns.svg, elem);\n            }\n        }\n        else {\n            node = elem;\n        }\n        this.node = node;\n        if (attrs) {\n            this.setAttributes(attrs);\n        }\n        if (children) {\n            this.append(children);\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return Vector.toStringTag;\n    }\n    get type() {\n        return this.node.nodeName;\n    }\n    get id() {\n        return this.node.id;\n    }\n    set id(id) {\n        this.node.id = id;\n    }\n    transform(matrix, options) {\n        if (matrix == null) {\n            return Dom.transform(this.node);\n        }\n        Dom.transform(this.node, matrix, options);\n        return this;\n    }\n    translate(tx, ty = 0, options = {}) {\n        if (tx == null) {\n            return Dom.translate(this.node);\n        }\n        Dom.translate(this.node, tx, ty, options);\n        return this;\n    }\n    rotate(angle, cx, cy, options = {}) {\n        if (angle == null) {\n            return Dom.rotate(this.node);\n        }\n        Dom.rotate(this.node, angle, cx, cy, options);\n        return this;\n    }\n    scale(sx, sy) {\n        if (sx == null) {\n            return Dom.scale(this.node);\n        }\n        Dom.scale(this.node, sx, sy);\n        return this;\n    }\n    /**\n     * Returns an SVGMatrix that specifies the transformation necessary\n     * to convert this coordinate system into `target` coordinate system.\n     */\n    getTransformToElement(target) {\n        const ref = Vector.toNode(target);\n        return Dom.getTransformToElement(this.node, ref);\n    }\n    removeAttribute(name) {\n        Dom.removeAttribute(this.node, name);\n        return this;\n    }\n    getAttribute(name) {\n        return Dom.getAttribute(this.node, name);\n    }\n    setAttribute(name, value) {\n        Dom.setAttribute(this.node, name, value);\n        return this;\n    }\n    setAttributes(attrs) {\n        Dom.setAttributes(this.node, attrs);\n        return this;\n    }\n    attr(name, value) {\n        if (name == null) {\n            return Dom.attr(this.node);\n        }\n        if (typeof name === 'string' && value === undefined) {\n            return Dom.attr(this.node, name);\n        }\n        if (typeof name === 'object') {\n            Dom.attr(this.node, name);\n        }\n        else {\n            Dom.attr(this.node, name, value);\n        }\n        return this;\n    }\n    svg() {\n        return this.node instanceof SVGSVGElement\n            ? this\n            : Vector.create(this.node.ownerSVGElement);\n    }\n    defs() {\n        const context = this.svg() || this;\n        const defsNode = context.node.getElementsByTagName('defs')[0];\n        if (defsNode) {\n            return Vector.create(defsNode);\n        }\n        return Vector.create('defs').appendTo(context);\n    }\n    text(content, options = {}) {\n        Dom.text(this.node, content, options);\n        return this;\n    }\n    tagName() {\n        return Dom.tagName(this.node);\n    }\n    clone() {\n        return Vector.create(this.node.cloneNode(true));\n    }\n    remove() {\n        Dom.remove(this.node);\n        return this;\n    }\n    empty() {\n        Dom.empty(this.node);\n        return this;\n    }\n    append(elems) {\n        Dom.append(this.node, Vector.toNodes(elems));\n        return this;\n    }\n    appendTo(target) {\n        Dom.appendTo(this.node, Vector.isVector(target) ? target.node : target);\n        return this;\n    }\n    prepend(elems) {\n        Dom.prepend(this.node, Vector.toNodes(elems));\n        return this;\n    }\n    before(elems) {\n        Dom.before(this.node, Vector.toNodes(elems));\n        return this;\n    }\n    replace(elem) {\n        if (this.node.parentNode) {\n            this.node.parentNode.replaceChild(Vector.toNode(elem), this.node);\n        }\n        return Vector.create(elem);\n    }\n    first() {\n        return this.node.firstChild\n            ? Vector.create(this.node.firstChild)\n            : null;\n    }\n    last() {\n        return this.node.lastChild\n            ? Vector.create(this.node.lastChild)\n            : null;\n    }\n    get(index) {\n        const child = this.node.childNodes[index];\n        return child ? Vector.create(child) : null;\n    }\n    indexOf(elem) {\n        const children = Array.prototype.slice.call(this.node.childNodes);\n        return children.indexOf(Vector.toNode(elem));\n    }\n    find(selector) {\n        const vels = [];\n        const nodes = Dom.find(this.node, selector);\n        if (nodes) {\n            for (let i = 0, ii = nodes.length; i < ii; i += 1) {\n                vels.push(Vector.create(nodes[i]));\n            }\n        }\n        return vels;\n    }\n    findOne(selector) {\n        const found = Dom.findOne(this.node, selector);\n        return found ? Vector.create(found) : null;\n    }\n    findParentByClass(className, terminator) {\n        const node = Dom.findParentByClass(this.node, className, terminator);\n        return node ? Vector.create(node) : null;\n    }\n    matches(selector) {\n        const node = this.node;\n        const matches = this.node.matches;\n        const matcher = node.matches ||\n            node.matchesSelector ||\n            node.msMatchesSelector ||\n            node.mozMatchesSelector ||\n            node.webkitMatchesSelector ||\n            node.oMatchesSelector ||\n            null;\n        return matcher && matcher.call(node, selector);\n    }\n    contains(child) {\n        return Dom.contains(this.node, Vector.isVector(child) ? child.node : child);\n    }\n    wrap(node) {\n        const vel = Vector.create(node);\n        const parentNode = this.node.parentNode;\n        if (parentNode != null) {\n            parentNode.insertBefore(vel.node, this.node);\n        }\n        return vel.append(this);\n    }\n    parent(type) {\n        let parent = this; // eslint-disable-line @typescript-eslint/no-this-alias\n        // check for parent\n        if (parent.node.parentNode == null) {\n            return null;\n        }\n        // get parent element\n        parent = Vector.create(parent.node.parentNode);\n        if (type == null) {\n            return parent;\n        }\n        // loop trough ancestors if type is given\n        do {\n            if (typeof type === 'string' ? parent.matches(type) : parent instanceof type) {\n                return parent;\n            }\n        } while ((parent = Vector.create(parent.node.parentNode)));\n        return parent;\n    }\n    children() {\n        const children = this.node.childNodes;\n        const vels = [];\n        for (let i = 0; i < children.length; i += 1) {\n            const currentChild = children[i];\n            if (currentChild.nodeType === 1) {\n                vels.push(Vector.create(children[i]));\n            }\n        }\n        return vels;\n    }\n    eachChild(fn, deep) {\n        const children = this.children();\n        for (let i = 0, l = children.length; i < l; i += 1) {\n            fn.call(children[i], children[i], i, children);\n            if (deep) {\n                children[i].eachChild(fn, deep);\n            }\n        }\n        return this;\n    }\n    index() {\n        return Dom.index(this.node);\n    }\n    hasClass(className) {\n        return Dom.hasClass(this.node, className);\n    }\n    addClass(className) {\n        Dom.addClass(this.node, className);\n        return this;\n    }\n    removeClass(className) {\n        Dom.removeClass(this.node, className);\n        return this;\n    }\n    toggleClass(className, stateVal) {\n        Dom.toggleClass(this.node, className, stateVal);\n        return this;\n    }\n    toLocalPoint(x, y) {\n        return Dom.toLocalPoint(this.node, x, y);\n    }\n    toGeometryShape() {\n        return Dom.toGeometryShape(this.node);\n    }\n    translateCenterToPoint(p) {\n        const bbox = this.getBBox({ target: this.svg() });\n        const center = bbox.getCenter();\n        this.translate(p.x - center.x, p.y - center.y);\n        return this;\n    }\n    translateAndAutoOrient(position, reference, target) {\n        Dom.translateAndAutoOrient(this.node, position, reference, target);\n        return this;\n    }\n    animate(options) {\n        return Dom.animate(this.node, options);\n    }\n    animateTransform(options) {\n        return Dom.animateTransform(this.node, options);\n    }\n    animateAlongPath(options, path) {\n        return Dom.animateAlongPath(this.node, options, path);\n    }\n    /**\n     * Normalize this element's d attribute. SVGPathElements without\n     * a path data attribute obtain a value of 'M 0 0'.\n     */\n    normalizePath() {\n        const tagName = this.tagName();\n        if (tagName === 'path') {\n            this.attr('d', Path.normalize(this.attr('d')));\n        }\n        return this;\n    }\n    /**\n     * Returns the bounding box of the element after transformations are applied.\n     * If `withoutTransformations` is `true`, transformations of the element\n     * will not be considered when computing the bounding box. If `target` is\n     * specified, bounding box will be computed relatively to the target element.\n     */\n    bbox(withoutTransformations, target) {\n        return Dom.bbox(this.node, withoutTransformations, target);\n    }\n    getBBox(options = {}) {\n        return Dom.getBBox(this.node, {\n            recursive: options.recursive,\n            target: options.target ? Vector.toNode(options.target) : null,\n        });\n    }\n    /**\n     * Samples the underlying SVG element (it currently works only on\n     * paths - where it is most useful anyway). Returns an array of objects\n     * of the form `{ x: Number, y: Number, distance: Number }`. Each of these\n     * objects represent a point on the path. This basically creates a discrete\n     * representation of the path (which is possible a curve). The sampling\n     * interval defines the accuracy of the sampling. In other words, we travel\n     * from the beginning of the path to the end by interval distance (on the\n     * path, not between the resulting points) and collect the discrete points\n     * on the path. This is very useful in many situations. For example, SVG\n     * does not provide a built-in mechanism to find intersections between two\n     * paths. Using sampling, we can just generate bunch of points for each of\n     * the path and find the closest ones from each set.\n     */\n    sample(interval = 1) {\n        if (this.node instanceof SVGPathElement) {\n            return Dom.sample(this.node, interval);\n        }\n        return [];\n    }\n    toPath() {\n        return Vector.create(Dom.toPath(this.node));\n    }\n    toPathData() {\n        return Dom.toPathData(this.node);\n    }\n}\n(function (Vector) {\n    Vector.toStringTag = `X6.${Vector.name}`;\n    function isVector(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Vector) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const vector = instance;\n        if ((tag == null || tag === Vector.toStringTag) &&\n            vector.node instanceof SVGElement &&\n            typeof vector.animate === 'function' &&\n            typeof vector.sample === 'function' &&\n            typeof vector.normalizePath === 'function' &&\n            typeof vector.toPath === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Vector.isVector = isVector;\n    function create(elem, attrs, children) {\n        return new Vector(elem, attrs, children);\n    }\n    Vector.create = create;\n    function createVectors(markup) {\n        if (markup[0] === '<') {\n            const svgDoc = Dom.createSvgDocument(markup);\n            const vels = [];\n            for (let i = 0, ii = svgDoc.childNodes.length; i < ii; i += 1) {\n                const childNode = svgDoc.childNodes[i];\n                vels.push(create(document.importNode(childNode, true)));\n            }\n            return vels;\n        }\n        return [create(markup)];\n    }\n    Vector.createVectors = createVectors;\n    function toNode(elem) {\n        if (isVector(elem)) {\n            return elem.node;\n        }\n        return elem;\n    }\n    Vector.toNode = toNode;\n    function toNodes(elems) {\n        if (Array.isArray(elems)) {\n            return elems.map((elem) => toNode(elem));\n        }\n        return [toNode(elems)];\n    }\n    Vector.toNodes = toNodes;\n})(Vector || (Vector = {}));\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}