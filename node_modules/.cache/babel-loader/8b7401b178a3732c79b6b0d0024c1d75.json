{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport React, { useCallback } from 'react';\nimport { XFlowGraphCommands, MODELS, XFlowNodeCommands, XFlowEdgeCommands } from '@antv/xflow-core';\nimport { onConfigChange } from '../flowchart-canvas/utils';\nimport { FormItemWrapper } from '../canvas-json-schema-form';\nimport { usePanelContext } from '../base-panel/context';\nimport useAsync from './useAsync';\nexport const FlowchartFormWrapper = props => {\n  const {\n    controlSchema,\n    children,\n    type: formType = 'node'\n  } = props;\n  const {\n    commandService,\n    modelService\n  } = usePanelContext();\n  const getSelectNode = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    const {\n      data\n    } = yield MODELS.SELECTED_NODE.useValue(modelService);\n    return data;\n  }), [modelService]);\n  const getSelectEdge = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n    const cell = yield MODELS.SELECTED_CELL.useValue(modelService);\n    const data = cell.getData();\n    return Object.assign({\n      id: cell.id\n    }, data);\n  }), [modelService]);\n  const {\n    data,\n    loading\n  } = useAsync(formType === 'edge' ? getSelectEdge : getSelectNode);\n  React.useEffect(() => {\n    commandService.executeCommand(XFlowGraphCommands.SAVE_GRAPH_DATA.id, {\n      saveGraphDataService: (meta, graph) => __awaiter(void 0, void 0, void 0, function* () {\n        return {\n          err: null,\n          data: graph,\n          meta\n        };\n      })\n    });\n  }, [commandService, props]);\n\n  const updateNode = value => __awaiter(void 0, void 0, void 0, function* () {\n    const currentNodeData = yield getSelectNode();\n    const nodeConfig = Object.assign(Object.assign({}, currentNodeData), value);\n    yield commandService.executeCommand(XFlowNodeCommands.UPDATE_NODE.id, {\n      nodeConfig\n    });\n    onConfigChange({\n      type: 'update:node',\n      config: nodeConfig\n    });\n  });\n\n  const updateEdge = function (value) {\n    let type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'line';\n    let key = arguments.length > 2 ? arguments[2] : undefined;\n    return __awaiter(void 0, void 0, void 0, function* () {\n      var _a;\n\n      const currentEdgeData = yield getSelectEdge(); // 更新线、文本样式\n\n      const edgeConfig = Object.assign(Object.assign(Object.assign({}, currentEdgeData), key ? value[key] : value), {\n        attrs: Object.assign(Object.assign({}, currentEdgeData.attrs), {\n          [type]: Object.assign(Object.assign({}, (_a = currentEdgeData.attrs) === null || _a === void 0 ? void 0 : _a[type]), key ? value[key] : value)\n        })\n      });\n      yield commandService.executeCommand(XFlowEdgeCommands.UPDATE_EDGE.id, {\n        edgeConfig\n      });\n      onConfigChange({\n        type: 'update:edge',\n        config: edgeConfig\n      });\n    });\n  };\n\n  const updateGroup = value => __awaiter(void 0, void 0, void 0, function* () {\n    const currentGroupData = yield getSelectNode();\n    const nodeConfig = Object.assign(Object.assign({}, currentGroupData), value);\n    yield commandService.executeCommand(XFlowNodeCommands.UPDATE_NODE.id, {\n      nodeConfig\n    });\n    onConfigChange({\n      type: 'update:group',\n      config: nodeConfig\n    });\n  });\n\n  if (loading) {\n    return null;\n  }\n\n  return React.createElement(FormItemWrapper, {\n    schema: controlSchema\n  }, () => {\n    return children(Object.assign({}, data), {\n      updateNode,\n      updateEdge,\n      updateGroup\n    });\n  });\n};","map":{"version":3,"sources":["../../src/flowchart-editor-panel/form-wrapper.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport React, { useCallback } from 'react';\nimport { XFlowGraphCommands, MODELS, XFlowNodeCommands, XFlowEdgeCommands } from '@antv/xflow-core';\nimport { onConfigChange } from '../flowchart-canvas/utils';\nimport { FormItemWrapper } from '../canvas-json-schema-form';\nimport { usePanelContext } from '../base-panel/context';\nimport useAsync from './useAsync';\nexport const FlowchartFormWrapper = props => {\n    const { controlSchema, children, type: formType = 'node' } = props;\n    const { commandService, modelService } = usePanelContext();\n    const getSelectNode = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        const { data } = yield MODELS.SELECTED_NODE.useValue(modelService);\n        return data;\n    }), [modelService]);\n    const getSelectEdge = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        const cell = yield MODELS.SELECTED_CELL.useValue(modelService);\n        const data = cell.getData();\n        return Object.assign({ id: cell.id }, data);\n    }), [modelService]);\n    const { data, loading } = useAsync(formType === 'edge' ? getSelectEdge : getSelectNode);\n    React.useEffect(() => {\n        commandService.executeCommand(XFlowGraphCommands.SAVE_GRAPH_DATA.id, {\n            saveGraphDataService: (meta, graph) => __awaiter(void 0, void 0, void 0, function* () {\n                return { err: null, data: graph, meta };\n            }),\n        });\n    }, [commandService, props]);\n    const updateNode = (value) => __awaiter(void 0, void 0, void 0, function* () {\n        const currentNodeData = yield getSelectNode();\n        const nodeConfig = Object.assign(Object.assign({}, currentNodeData), value);\n        yield commandService.executeCommand(XFlowNodeCommands.UPDATE_NODE.id, {\n            nodeConfig,\n        });\n        onConfigChange({ type: 'update:node', config: nodeConfig });\n    });\n    const updateEdge = (value, type = 'line', key) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        const currentEdgeData = yield getSelectEdge();\n        // 更新线、文本样式\n        const edgeConfig = Object.assign(Object.assign(Object.assign({}, currentEdgeData), (key ? value[key] : value)), { attrs: Object.assign(Object.assign({}, currentEdgeData.attrs), { [type]: Object.assign(Object.assign({}, (_a = currentEdgeData.attrs) === null || _a === void 0 ? void 0 : _a[type]), (key ? value[key] : value)) }) });\n        yield commandService.executeCommand(XFlowEdgeCommands.UPDATE_EDGE.id, { edgeConfig });\n        onConfigChange({ type: 'update:edge', config: edgeConfig });\n    });\n    const updateGroup = (value) => __awaiter(void 0, void 0, void 0, function* () {\n        const currentGroupData = yield getSelectNode();\n        const nodeConfig = Object.assign(Object.assign({}, currentGroupData), value);\n        yield commandService.executeCommand(XFlowNodeCommands.UPDATE_NODE.id, {\n            nodeConfig,\n        });\n        onConfigChange({ type: 'update:group', config: nodeConfig });\n    });\n    if (loading) {\n        return null;\n    }\n    return (React.createElement(FormItemWrapper, { schema: controlSchema }, () => {\n        return children(Object.assign({}, data), { updateNode, updateEdge, updateGroup });\n    }));\n};\n//# sourceMappingURL=form-wrapper.js.map"]},"metadata":{},"sourceType":"module"}