{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nexport var LRUCache = function () {\n  function LRUCache() {\n    var limit = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 50;\n    var destroy = arguments.length > 1 ? arguments[1] : undefined;\n\n    _classCallCheck(this, LRUCache);\n\n    _defineProperty(this, \"limit\", void 0);\n\n    _defineProperty(this, \"cache\", void 0);\n\n    _defineProperty(this, \"destroy\", void 0);\n\n    _defineProperty(this, \"order\", void 0);\n\n    this.limit = limit;\n    this.destroy = destroy || this.defaultDestroy;\n    this.order = [];\n    this.clear();\n  }\n\n  _createClass(LRUCache, [{\n    key: \"clear\",\n    value: function clear() {\n      var _this = this;\n\n      this.order.forEach(function (key) {\n        _this.delete(key);\n      });\n      this.cache = {};\n      this.order = [];\n    }\n  }, {\n    key: \"get\",\n    value: function get(key) {\n      var value = this.cache[key];\n\n      if (value) {\n        this.deleteOrder(key);\n        this.appendOrder(key);\n      }\n\n      return value;\n    }\n  }, {\n    key: \"set\",\n    value: function set(key, value) {\n      if (!this.cache[key]) {\n        if (Object.keys(this.cache).length === this.limit) {\n          this.delete(this.order[0]);\n        }\n\n        this.cache[key] = value;\n        this.appendOrder(key);\n      } else {\n        this.delete(key);\n        this.cache[key] = value;\n        this.appendOrder(key);\n      }\n    }\n  }, {\n    key: \"delete\",\n    value: function _delete(key) {\n      var value = this.cache[key];\n\n      if (value) {\n        this.deleteCache(key);\n        this.deleteOrder(key);\n        this.destroy(value, key);\n      }\n    }\n  }, {\n    key: \"deleteCache\",\n    value: function deleteCache(key) {\n      delete this.cache[key];\n    }\n  }, {\n    key: \"deleteOrder\",\n    value: function deleteOrder(key) {\n      var index = this.order.findIndex(function (o) {\n        return o === key;\n      });\n\n      if (index >= 0) {\n        this.order.splice(index, 1);\n      }\n    }\n  }, {\n    key: \"appendOrder\",\n    value: function appendOrder(key) {\n      this.order.push(key);\n    }\n  }, {\n    key: \"defaultDestroy\",\n    value: function defaultDestroy(value, key) {\n      return null;\n    }\n  }]);\n\n  return LRUCache;\n}();","map":{"version":3,"sources":["../src/lru_cache.ts"],"names":["LRUCache","limit","destroy","value","Object","index","o"],"mappings":"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","sourcesContent":["/**\n * LRU Cache class with limit\n *\n * Update order for each get/set operation\n * Delete oldest when reach given limit\n */\ntype callback = (...args: any[]) => void;\ninterface ICache {\n  [key: string]: any;\n}\nexport class LRUCache {\n  private limit: number;\n  private cache: ICache;\n  private destroy: (value: any, key: string) => void;\n  private order: any[];\n  constructor(limit = 50, destroy?: callback) {\n    this.limit = limit;\n    this.destroy = destroy || this.defaultDestroy;\n    this.order = [];\n    this.clear();\n  }\n\n  public clear() {\n    this.order.forEach((key) => {\n      this.delete(key);\n    });\n    this.cache = {};\n    // access/update order, first item is oldest, last item is newest\n    this.order = [];\n  }\n\n  public get(key: string) {\n    const value = this.cache[key];\n    if (value) {\n      // update order\n      this.deleteOrder(key);\n      this.appendOrder(key);\n    }\n    return value;\n  }\n\n  public set(key: string, value: any) {\n    if (!this.cache[key]) {\n      // if reach limit, delete the oldest\n      if (Object.keys(this.cache).length === this.limit) {\n        this.delete(this.order[0]);\n      }\n\n      this.cache[key] = value;\n      this.appendOrder(key);\n    } else {\n      // if found in cache, delete the old one, insert new one to the first of list\n      this.delete(key);\n\n      this.cache[key] = value;\n      this.appendOrder(key);\n    }\n  }\n\n  public delete(key: string) {\n    const value = this.cache[key];\n    if (value) {\n      this.deleteCache(key);\n      this.deleteOrder(key);\n      this.destroy(value, key);\n    }\n  }\n\n  private deleteCache(key: string) {\n    delete this.cache[key];\n  }\n\n  private deleteOrder(key: string) {\n    const index = this.order.findIndex((o) => o === key);\n    if (index >= 0) {\n      this.order.splice(index, 1);\n    }\n  }\n\n  private appendOrder(key: string) {\n    this.order.push(key);\n  }\n  private defaultDestroy(value: any, key: string) {\n    return null;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}