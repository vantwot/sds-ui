{"ast":null,"code":"import React from 'react';\nimport { ConfigProvider, Tooltip } from 'antd';\nimport ReactDOM from 'react-dom';\nimport classnames from 'classnames';\nimport { createGraphConfig } from '@antv/xflow-core';\nimport { Shape } from '@antv/x6';\nimport { NODE_HEIGHT, ASPECTRATIONODE, setNodeRender, setGroupRender } from '../flowchart-node-panel';\nimport { movedNode, resizeNode, changePortsVisible, addTools, removeTools, setProps } from './utils';\n/** 自定义React节点 */\n\nvar ANT_PREFIX = 'ant';\nexport var NsAddEdgeEvent;\n\n(function (NsAddEdgeEvent) {\n  NsAddEdgeEvent.EVENT_NAME = 'ADD_FLOWCHART_EDGE_CMD_EVENT';\n})(NsAddEdgeEvent || (NsAddEdgeEvent = {}));\n\nvar XFlowEdge = Shape.Edge.registry.register('xflow', Shape.Edge.define({\n  zIndex: 1,\n  highlight: true,\n  shape: 'EDGE1',\n  name: 'custom-edge',\n  label: '',\n  anchor: {\n    name: 'midSide',\n    args: {\n      dx: 10\n    }\n  },\n  attrs: {\n    line: {\n      stroke: '#A2B1C3',\n      targetMarker: {\n        name: 'block',\n        width: 12,\n        height: 8\n      },\n      strokeDasharray: '5 5',\n      strokeWidth: 1\n    }\n  },\n  data: {\n    label: ''\n  }\n}), true);\nexport var useGraphConfig = createGraphConfig(function (config, proxy) {\n  var _proxy$getValue = proxy.getValue(),\n      _proxy$getValue$confi = _proxy$getValue.config,\n      canvasConfig = _proxy$getValue$confi === void 0 ? {} : _proxy$getValue$confi;\n\n  config.setEdgeTypeParser(function (edge) {\n    return edge === null || edge === void 0 ? void 0 : edge.renderKey;\n  });\n  setNodeRender(config);\n  setGroupRender(config);\n  /** 这里比较黑，props 共享*/\n\n  setProps(Object.assign(Object.assign({}, proxy.getValue()), {\n    graphConfig: config\n  }));\n  config.setX6Config(Object.assign({\n    grid: true,\n    history: true,\n    resizing: {\n      enabled: true,\n      minWidth: NODE_HEIGHT,\n      minHeight: NODE_HEIGHT,\n      preserveAspectRatio: function preserveAspectRatio(shape) {\n        var data = shape.data;\n        return ASPECTRATIONODE.includes(data.name);\n      }\n    },\n    snapline: {\n      enabled: true\n    },\n    connecting: {\n      router: 'manhattan',\n      connector: {\n        name: 'rounded',\n        args: {\n          radius: 8\n        }\n      },\n      anchor: 'center',\n      connectionPoint: 'anchor',\n      allowBlank: false,\n      snap: {\n        radius: 20\n      },\n      createEdge: function createEdge() {\n        var _this = this;\n\n        var tempEdge = new XFlowEdge({});\n        this.once('edge:connected', function (args) {\n          var edge = args.edge,\n              isNew = args.isNew;\n\n          if (isNew && edge.isEdge()) {\n            var targetNode = edge.getTargetCell();\n\n            if (targetNode && targetNode.isNode()) {\n              var targetPortId = edge.getTargetPortId();\n              var sourcePortId = edge.getSourcePortId();\n              var sourceCellId = edge.getSourceCellId();\n              var targetCellId = edge.getTargetCellId();\n\n              _this.trigger(NsAddEdgeEvent.EVENT_NAME, {\n                targetPortId: targetPortId,\n                sourcePortId: sourcePortId,\n                source: sourceCellId,\n                target: targetCellId,\n                edge: edge\n              });\n            }\n          }\n        });\n        return tempEdge;\n      },\n      validateEdge: function validateEdge(args) {\n        var _a;\n\n        var edge = args.edge;\n        return !!((_a = edge === null || edge === void 0 ? void 0 : edge.target) === null || _a === void 0 ? void 0 : _a.port);\n      },\n      // 是否触发交互事件\n      validateMagnet: function validateMagnet() {\n        // 所有锚点均可触发\n        return true;\n      },\n      // 显示可用的链接桩\n      validateConnection: function validateConnection(_ref) {\n        var sourceView = _ref.sourceView,\n            targetView = _ref.targetView,\n            targetMagnet = _ref.targetMagnet;\n\n        // 不允许连接到自己\n        if (sourceView === targetView) {\n          return false;\n        }\n\n        var node = targetView.cell; // 判断目标链接桩是否可连接\n\n        if (targetMagnet) {\n          var portId = targetMagnet.getAttribute('port');\n          var port = node.getPort(portId);\n          return !(port && port.connected);\n        }\n\n        return;\n      }\n    },\n    highlighting: {\n      nodeAvailable: {\n        name: 'className',\n        args: {\n          className: 'available'\n        }\n      },\n      magnetAvailable: {\n        name: 'className',\n        args: {\n          className: 'available'\n        }\n      },\n      magnetAdsorbed: {\n        name: 'className',\n        args: {\n          className: 'adsorbed'\n        }\n      }\n    },\n    onPortRendered: function onPortRendered(args) {\n      var port = args.port;\n      var contentSelectors = args.contentSelectors;\n      var container = contentSelectors && contentSelectors.content;\n      var placement = port.group;\n      var clz = classnames('xflow-port', {\n        connected: port.connected\n      });\n\n      if (container) {\n        ReactDOM.render(React.createElement(ConfigProvider, {\n          prefixCls: ANT_PREFIX\n        }, React.createElement(Tooltip, {\n          title: port.tooltip,\n          placement: placement\n        }, React.createElement(\"span\", {\n          className: clz\n        }))), container);\n      }\n    }\n  }, canvasConfig));\n  /** 内交互，上层通过实例绑定 */\n\n  config.setEvents([{\n    eventName: 'node:selected',\n    callback: function callback() {\n      changePortsVisible(false);\n    }\n  }, {\n    eventName: 'edge:dblclick',\n    callback: function callback(e) {\n      addTools(e);\n    }\n  }, {\n    eventName: 'edge:mouseleave',\n    callback: function callback(e, cmds) {\n      removeTools(e, cmds);\n    }\n  }, {\n    eventName: 'node:mouseenter',\n    callback: function callback(e) {\n      changePortsVisible(true, e);\n    }\n  }, {\n    eventName: 'node:mouseleave',\n    callback: function callback(e) {\n      changePortsVisible(false, e);\n    }\n  }, {\n    eventName: 'node:moved',\n    callback: function callback(e, cmds) {\n      movedNode(e, cmds);\n    }\n  }, {\n    eventName: 'node:resized',\n    callback: function callback(e, cmds) {\n      resizeNode(e, cmds);\n    }\n  }]);\n});","map":{"version":3,"sources":["../../src/flowchart-canvas/config-graph.tsx"],"names":[],"mappings":"AAAA,OAAO,KAAP,MAAkB,OAAlB;AACA,SAAS,cAAT,EAAyB,OAAzB,QAAwC,MAAxC;AAEA,OAAO,QAAP,MAAqB,WAArB;AACA,OAAO,UAAP,MAAuB,YAAvB;AAEA,SAAS,iBAAT,QAAkC,kBAAlC;AAEA,SAAS,KAAT,QAAsB,UAAtB;AACA,SACE,WADF,EAEE,eAFF,EAGE,aAHF,EAIE,cAJF,QAKO,yBALP;AAMA,SAAS,SAAT,EAAoB,UAApB,EAAgC,kBAAhC,EAAoD,QAApD,EAA8D,WAA9D,EAA2E,QAA3E,QAA2F,SAA3F;AAEA;;AACA,IAAM,UAAU,GAAG,KAAnB;AACA,OAAM,IAAW,cAAX;;AAAN,CAAA,UAAiB,cAAjB,EAA+B;AAChB,EAAA,cAAA,CAAA,UAAA,GAAa,8BAAb;AAQd,CATD,EAAiB,cAAc,KAAd,cAAc,GAAA,EAAA,CAA/B;;AAWA,IAAM,SAAS,GAAG,KAAK,CAAC,IAAN,CAAW,QAAX,CAAoB,QAApB,CAChB,OADgB,EAEhB,KAAK,CAAC,IAAN,CAAW,MAAX,CAAkB;AAChB,EAAA,MAAM,EAAE,CADQ;AAEhB,EAAA,SAAS,EAAE,IAFK;AAGhB,EAAA,KAAK,EAAE,OAHS;AAIhB,EAAA,IAAI,EAAE,aAJU;AAKhB,EAAA,KAAK,EAAE,EALS;AAMhB,EAAA,MAAM,EAAE;AACN,IAAA,IAAI,EAAE,SADA;AAEN,IAAA,IAAI,EAAE;AACJ,MAAA,EAAE,EAAE;AADA;AAFA,GANQ;AAYhB,EAAA,KAAK,EAAE;AACL,IAAA,IAAI,EAAE;AACJ,MAAA,MAAM,EAAE,SADJ;AAEJ,MAAA,YAAY,EAAE;AACZ,QAAA,IAAI,EAAE,OADM;AAEZ,QAAA,KAAK,EAAE,EAFK;AAGZ,QAAA,MAAM,EAAE;AAHI,OAFV;AAOJ,MAAA,eAAe,EAAE,KAPb;AAQJ,MAAA,WAAW,EAAE;AART;AADD,GAZS;AAwBhB,EAAA,IAAI,EAAE;AACJ,IAAA,KAAK,EAAE;AADH;AAxBU,CAAlB,CAFgB,EA8BhB,IA9BgB,CAAlB;AAiCA,OAAO,IAAM,cAAc,GAAG,iBAAiB,CAAC,UAAC,MAAD,EAAS,KAAT,EAAkB;AAChE,wBAAsC,KAAK,CAAC,QAAN,EAAtC;AAAA,8CAAQ,MAAR;AAAA,MAAgB,YAAhB,sCAA+B,EAA/B;;AACA,EAAA,MAAM,CAAC,iBAAP,CAAyB,UAAA,IAAI;AAAA,WAAI,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,SAAV;AAAA,GAA7B;AACA,EAAA,aAAa,CAAC,MAAD,CAAb;AACA,EAAA,cAAc,CAAC,MAAD,CAAd;AACA;;AACA,EAAA,QAAQ,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACH,KAAK,CAAC,QAAN,EADG,CAAA,EACa;AACnB,IAAA,WAAW,EAAE;AADM,GADb,CAAA,CAAR;AAIA,EAAA,MAAM,CAAC,WAAP,CAAkB,MAAA,CAAA,MAAA,CAAA;AAChB,IAAA,IAAI,EAAE,IADU;AAEhB,IAAA,OAAO,EAAE,IAFO;AAGhB,IAAA,QAAQ,EAAE;AACR,MAAA,OAAO,EAAE,IADD;AAER,MAAA,QAAQ,EAAE,WAFF;AAGR,MAAA,SAAS,EAAE,WAHH;AAIR,MAAA,mBAAmB,EAAE,6BAAA,KAAK,EAAG;AAC3B,YAAQ,IAAR,GAAiB,KAAjB,CAAQ,IAAR;AACA,eAAO,eAAe,CAAC,QAAhB,CAAyB,IAAI,CAAC,IAA9B,CAAP;AACD;AAPO,KAHM;AAYhB,IAAA,QAAQ,EAAE;AACR,MAAA,OAAO,EAAE;AADD,KAZM;AAehB,IAAA,UAAU,EAAE;AACV,MAAA,MAAM,EAAE,WADE;AAEV,MAAA,SAAS,EAAE;AACT,QAAA,IAAI,EAAE,SADG;AAET,QAAA,IAAI,EAAE;AACJ,UAAA,MAAM,EAAE;AADJ;AAFG,OAFD;AAQV,MAAA,MAAM,EAAE,QARE;AASV,MAAA,eAAe,EAAE,QATP;AAUV,MAAA,UAAU,EAAE,KAVF;AAWV,MAAA,IAAI,EAAE;AACJ,QAAA,MAAM,EAAE;AADJ,OAXI;AAcV,MAAA,UAdU,wBAcA;AAAA;;AACR,YAAM,QAAQ,GAAG,IAAI,SAAJ,CAAc,EAAd,CAAjB;AACA,aAAK,IAAL,CAAU,gBAAV,EAA4B,UAAA,IAAI,EAAG;AACjC,cAAQ,IAAR,GAAwB,IAAxB,CAAQ,IAAR;AAAA,cAAc,KAAd,GAAwB,IAAxB,CAAc,KAAd;;AACA,cAAI,KAAK,IAAI,IAAI,CAAC,MAAL,EAAb,EAA4B;AAC1B,gBAAM,UAAU,GAAG,IAAI,CAAC,aAAL,EAAnB;;AACA,gBAAI,UAAU,IAAI,UAAU,CAAC,MAAX,EAAlB,EAAuC;AACrC,kBAAM,YAAY,GAAG,IAAI,CAAC,eAAL,EAArB;AACA,kBAAM,YAAY,GAAG,IAAI,CAAC,eAAL,EAArB;AACA,kBAAM,YAAY,GAAG,IAAI,CAAC,eAAL,EAArB;AACA,kBAAM,YAAY,GAAG,IAAI,CAAC,eAAL,EAArB;;AACA,cAAA,KAAI,CAAC,OAAL,CAAa,cAAc,CAAC,UAA5B,EAAwC;AACtC,gBAAA,YAAY,EAAZ,YADsC;AAEtC,gBAAA,YAAY,EAAZ,YAFsC;AAGtC,gBAAA,MAAM,EAAE,YAH8B;AAItC,gBAAA,MAAM,EAAE,YAJ8B;AAKtC,gBAAA,IAAI,EAAE;AALgC,eAAxC;AAOD;AACF;AACF,SAlBD;AAmBA,eAAO,QAAP;AACD,OApCS;AAqCV,MAAA,YAAY,EAAE,sBAAA,IAAI,EAAG;;;AACnB,YAAQ,IAAR,GAAiB,IAAjB,CAAQ,IAAR;AACA,eAAO,CAAC,EAAC,CAAA,EAAA,GAAC,IAAI,KAAA,IAAJ,IAAA,IAAI,KAAA,KAAA,CAAJ,GAAI,KAAA,CAAJ,GAAA,IAAI,CAAE,MAAP,MAAqB,IAArB,IAAqB,EAAA,KAAA,KAAA,CAArB,GAAqB,KAAA,CAArB,GAAqB,EAAA,CAAE,IAAxB,CAAR;AACD,OAxCS;AAyCV;AACA,MAAA,cA1CU,4BA0CI;AACZ;AACA,eAAO,IAAP;AACD,OA7CS;AA8CV;AACA,MAAA,kBA/CU,oCA+CiD;AAAA,YAAtC,UAAsC,QAAtC,UAAsC;AAAA,YAA1B,UAA0B,QAA1B,UAA0B;AAAA,YAAd,YAAc,QAAd,YAAc;;AACzD;AACA,YAAI,UAAU,KAAK,UAAnB,EAA+B;AAC7B,iBAAO,KAAP;AACD;;AACD,YAAM,IAAI,GAAG,UAAW,CAAC,IAAzB,CALyD,CAMzD;;AACA,YAAI,YAAJ,EAAkB;AAChB,cAAM,MAAM,GAAG,YAAY,CAAC,YAAb,CAA0B,MAA1B,CAAf;AACA,cAAM,IAAI,GAAG,IAAI,CAAC,OAAL,CAAa,MAAb,CAAb;AACA,iBAAO,EAAE,IAAI,IAAI,IAAI,CAAC,SAAf,CAAP;AACD;;AACD;AACD;AA5DS,KAfI;AA6EhB,IAAA,YAAY,EAAE;AACZ,MAAA,aAAa,EAAE;AACb,QAAA,IAAI,EAAE,WADO;AAEb,QAAA,IAAI,EAAE;AACJ,UAAA,SAAS,EAAE;AADP;AAFO,OADH;AAOZ,MAAA,eAAe,EAAE;AACf,QAAA,IAAI,EAAE,WADS;AAEf,QAAA,IAAI,EAAE;AACJ,UAAA,SAAS,EAAE;AADP;AAFS,OAPL;AAaZ,MAAA,cAAc,EAAE;AACd,QAAA,IAAI,EAAE,WADQ;AAEd,QAAA,IAAI,EAAE;AACJ,UAAA,SAAS,EAAE;AADP;AAFQ;AAbJ,KA7EE;AAiGhB,IAAA,cAjGgB,0BAiGD,IAjGC,EAiGG;AACjB,UAAQ,IAAR,GAAiB,IAAjB,CAAQ,IAAR;AACA,UAAQ,gBAAR,GAA6B,IAA7B,CAAQ,gBAAR;AACA,UAAM,SAAS,GAAG,gBAAgB,IAAI,gBAAgB,CAAC,OAAvD;AACA,UAAM,SAAS,GAAG,IAAI,CAAC,KAAvB;AACA,UAAM,GAAG,GAAG,UAAU,CAAC,YAAD,EAAe;AAAE,QAAA,SAAS,EAAG,IAAY,CAAC;AAA3B,OAAf,CAAtB;;AACA,UAAI,SAAJ,EAAe;AACb,QAAA,QAAQ,CAAC,MAAT,CAEI,KAAA,CAAA,aAAA,CAAC,cAAD,EAAe;AAAC,UAAA,SAAS,EAAE;AAAZ,SAAf,EACE,KAAA,CAAA,aAAA,CAAC,OAAD,EAAQ;AAAC,UAAA,KAAK,EAAG,IAAY,CAAC,OAAtB;AAA+B,UAAA,SAAS,EAAE;AAA1C,SAAR,EACE,KAAA,CAAA,aAAA,CAAA,MAAA,EAAA;AAAM,UAAA,SAAS,EAAE;AAAjB,SAAA,CADF,CADF,CAFJ,EAQE,SARF;AAUD;AACF;AAnHe,GAAA,EAoHb,YApHa,CAAlB;AAsHA;;AACA,EAAA,MAAM,CAAC,SAAP,CAAiB,CACf;AACE,IAAA,SAAS,EAAE,eADb;AAEE,IAAA,QAAQ,EAAE,oBAAK;AACb,MAAA,kBAAkB,CAAC,KAAD,CAAlB;AACD;AAJH,GADe,EAOf;AACE,IAAA,SAAS,EAAE,eADb;AAEE,IAAA,QAAQ,EAAE,kBAAA,CAAC,EAAG;AACZ,MAAA,QAAQ,CAAC,CAAD,CAAR;AACD;AAJH,GAPe,EAaf;AACE,IAAA,SAAS,EAAE,iBADb;AAEE,IAAA,QAAQ,EAAE,kBAAC,CAAD,EAAI,IAAJ,EAAY;AACpB,MAAA,WAAW,CAAC,CAAD,EAAI,IAAJ,CAAX;AACD;AAJH,GAbe,EAmBf;AACE,IAAA,SAAS,EAAE,iBADb;AAEE,IAAA,QAAQ,EAAE,kBAAA,CAAC,EAAG;AACZ,MAAA,kBAAkB,CAAC,IAAD,EAAO,CAAP,CAAlB;AACD;AAJH,GAnBe,EAyBf;AACE,IAAA,SAAS,EAAE,iBADb;AAEE,IAAA,QAAQ,EAAE,kBAAA,CAAC,EAAG;AACZ,MAAA,kBAAkB,CAAC,KAAD,EAAQ,CAAR,CAAlB;AACD;AAJH,GAzBe,EA+Bf;AACE,IAAA,SAAS,EAAE,YADb;AAEE,IAAA,QAAQ,EAAE,kBAAC,CAAD,EAAI,IAAJ,EAAY;AACpB,MAAA,SAAS,CAAC,CAAD,EAAI,IAAJ,CAAT;AACD;AAJH,GA/Be,EAqCf;AACE,IAAA,SAAS,EAAE,cADb;AAEE,IAAA,QAAQ,EAAE,kBAAC,CAAD,EAAI,IAAJ,EAAY;AACpB,MAAA,UAAU,CAAC,CAAD,EAAI,IAAJ,CAAV;AACD;AAJH,GArCe,CAAjB;AA4CD,CA7K8C,CAAxC","sourceRoot":"","sourcesContent":["import React from 'react';\nimport { ConfigProvider, Tooltip } from 'antd';\nimport ReactDOM from 'react-dom';\nimport classnames from 'classnames';\nimport { createGraphConfig } from '@antv/xflow-core';\nimport { Shape } from '@antv/x6';\nimport { NODE_HEIGHT, ASPECTRATIONODE, setNodeRender, setGroupRender, } from '../flowchart-node-panel';\nimport { movedNode, resizeNode, changePortsVisible, addTools, removeTools, setProps } from './utils';\n/** 自定义React节点 */\nconst ANT_PREFIX = 'ant';\nexport var NsAddEdgeEvent;\n(function (NsAddEdgeEvent) {\n    NsAddEdgeEvent.EVENT_NAME = 'ADD_FLOWCHART_EDGE_CMD_EVENT';\n})(NsAddEdgeEvent || (NsAddEdgeEvent = {}));\nconst XFlowEdge = Shape.Edge.registry.register('xflow', Shape.Edge.define({\n    zIndex: 1,\n    highlight: true,\n    shape: 'EDGE1',\n    name: 'custom-edge',\n    label: '',\n    anchor: {\n        name: 'midSide',\n        args: {\n            dx: 10,\n        },\n    },\n    attrs: {\n        line: {\n            stroke: '#A2B1C3',\n            targetMarker: {\n                name: 'block',\n                width: 12,\n                height: 8,\n            },\n            strokeDasharray: '5 5',\n            strokeWidth: 1,\n        },\n    },\n    data: {\n        label: '',\n    },\n}), true);\nexport const useGraphConfig = createGraphConfig((config, proxy) => {\n    const { config: canvasConfig = {} } = proxy.getValue();\n    config.setEdgeTypeParser(edge => edge === null || edge === void 0 ? void 0 : edge.renderKey);\n    setNodeRender(config);\n    setGroupRender(config);\n    /** 这里比较黑，props 共享*/\n    setProps(Object.assign(Object.assign({}, proxy.getValue()), { graphConfig: config }));\n    config.setX6Config(Object.assign({ grid: true, history: true, resizing: {\n            enabled: true,\n            minWidth: NODE_HEIGHT,\n            minHeight: NODE_HEIGHT,\n            preserveAspectRatio: shape => {\n                const { data } = shape;\n                return ASPECTRATIONODE.includes(data.name);\n            },\n        }, snapline: {\n            enabled: true,\n        }, connecting: {\n            router: 'manhattan',\n            connector: {\n                name: 'rounded',\n                args: {\n                    radius: 8,\n                },\n            },\n            anchor: 'center',\n            connectionPoint: 'anchor',\n            allowBlank: false,\n            snap: {\n                radius: 20,\n            },\n            createEdge() {\n                const tempEdge = new XFlowEdge({});\n                this.once('edge:connected', args => {\n                    const { edge, isNew } = args;\n                    if (isNew && edge.isEdge()) {\n                        const targetNode = edge.getTargetCell();\n                        if (targetNode && targetNode.isNode()) {\n                            const targetPortId = edge.getTargetPortId();\n                            const sourcePortId = edge.getSourcePortId();\n                            const sourceCellId = edge.getSourceCellId();\n                            const targetCellId = edge.getTargetCellId();\n                            this.trigger(NsAddEdgeEvent.EVENT_NAME, {\n                                targetPortId,\n                                sourcePortId,\n                                source: sourceCellId,\n                                target: targetCellId,\n                                edge: edge,\n                            });\n                        }\n                    }\n                });\n                return tempEdge;\n            },\n            validateEdge: args => {\n                var _a;\n                const { edge } = args;\n                return !!((_a = edge === null || edge === void 0 ? void 0 : edge.target) === null || _a === void 0 ? void 0 : _a.port);\n            },\n            // 是否触发交互事件\n            validateMagnet() {\n                // 所有锚点均可触发\n                return true;\n            },\n            // 显示可用的链接桩\n            validateConnection({ sourceView, targetView, targetMagnet }) {\n                // 不允许连接到自己\n                if (sourceView === targetView) {\n                    return false;\n                }\n                const node = targetView.cell;\n                // 判断目标链接桩是否可连接\n                if (targetMagnet) {\n                    const portId = targetMagnet.getAttribute('port');\n                    const port = node.getPort(portId);\n                    return !(port && port.connected);\n                }\n                return;\n            },\n        }, highlighting: {\n            nodeAvailable: {\n                name: 'className',\n                args: {\n                    className: 'available',\n                },\n            },\n            magnetAvailable: {\n                name: 'className',\n                args: {\n                    className: 'available',\n                },\n            },\n            magnetAdsorbed: {\n                name: 'className',\n                args: {\n                    className: 'adsorbed',\n                },\n            },\n        }, onPortRendered(args) {\n            const { port } = args;\n            const { contentSelectors } = args;\n            const container = contentSelectors && contentSelectors.content;\n            const placement = port.group;\n            const clz = classnames('xflow-port', { connected: port.connected });\n            if (container) {\n                ReactDOM.render((React.createElement(ConfigProvider, { prefixCls: ANT_PREFIX },\n                    React.createElement(Tooltip, { title: port.tooltip, placement: placement },\n                        React.createElement(\"span\", { className: clz })))), container);\n            }\n        } }, canvasConfig));\n    /** 内交互，上层通过实例绑定 */\n    config.setEvents([\n        {\n            eventName: 'node:selected',\n            callback: () => {\n                changePortsVisible(false);\n            },\n        },\n        {\n            eventName: 'edge:dblclick',\n            callback: e => {\n                addTools(e);\n            },\n        },\n        {\n            eventName: 'edge:mouseleave',\n            callback: (e, cmds) => {\n                removeTools(e, cmds);\n            },\n        },\n        {\n            eventName: 'node:mouseenter',\n            callback: e => {\n                changePortsVisible(true, e);\n            },\n        },\n        {\n            eventName: 'node:mouseleave',\n            callback: e => {\n                changePortsVisible(false, e);\n            },\n        },\n        {\n            eventName: 'node:moved',\n            callback: (e, cmds) => {\n                movedNode(e, cmds);\n            },\n        },\n        {\n            eventName: 'node:resized',\n            callback: (e, cmds) => {\n                resizeNode(e, cmds);\n            },\n        },\n    ]);\n});\n//# sourceMappingURL=config-graph.js.map"]},"metadata":{},"sourceType":"module"}