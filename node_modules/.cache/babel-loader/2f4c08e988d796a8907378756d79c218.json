{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _uniq from \"lodash/uniq\";\n\nvar _dec, _class;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { extractUniforms } from '../../utils/shader-module';\nvar common = \"#define PI 3.14159265359\";\nvar decode = \"#define SHIFT_RIGHT17 1.0 / 131072.0\\n#define SHIFT_RIGHT18 1.0 / 262144.0\\n#define SHIFT_RIGHT19 1.0 / 524288.0\\n#define SHIFT_RIGHT20 1.0 / 1048576.0\\n#define SHIFT_RIGHT21 1.0 / 2097152.0\\n#define SHIFT_RIGHT22 1.0 / 4194304.0\\n#define SHIFT_RIGHT23 1.0 / 8388608.0\\n#define SHIFT_RIGHT24 1.0 / 16777216.0\\n\\n#define SHIFT_LEFT17 131072.0\\n#define SHIFT_LEFT18 262144.0\\n#define SHIFT_LEFT19 524288.0\\n#define SHIFT_LEFT20 1048576.0\\n#define SHIFT_LEFT21 2097152.0\\n#define SHIFT_LEFT22 4194304.0\\n#define SHIFT_LEFT23 8388608.0\\n#define SHIFT_LEFT24 16777216.0\\n\\nvec2 unpack_float(float packedValue) {\\n  int packedIntValue = int(packedValue);\\n  int v0 = packedIntValue / 256;\\n  return vec2(v0, packedIntValue - v0 * 256);\\n}\\n\\nvec4 decode_color(vec2 encodedColor) {\\n  return vec4(\\n    unpack_float(encodedColor[0]) / 255.0,\\n    unpack_float(encodedColor[1]) / 255.0\\n  );\\n}\\n\";\nvar light = \"#define ambientRatio 0.5\\n#define diffuseRatio 0.3\\n#define specularRatio 0.2\\n\\n\\nfloat calc_lighting(vec4 pos) {\\n\\n    vec3 worldPos = vec3(pos * u_ModelMatrix);\\n\\n    vec3 worldNormal = a_Normal;\\n      // //cal light weight\\n    vec3 viewDir = normalize(u_CameraPosition - worldPos);\\n\\n    vec3 lightDir = normalize(vec3(1, -10.5, 12));\\n\\n    vec3 halfDir = normalize(viewDir+lightDir);\\n      // //lambert\\n    float lambert = dot(worldNormal, lightDir);\\n        //specular\\n    float specular = pow(max(0.0, dot(worldNormal, halfDir)), 32.0);\\n        //sum to light weight\\n    float lightWeight = ambientRatio + diffuseRatio * lambert + specularRatio * specular;\\n\\n    return lightWeight;\\n}\\n\";\nvar lighting = \"// Blinn-Phong model\\n// apply lighting in vertex shader instead of fragment shader\\n// @see https://learnopengl.com/Advanced-Lighting/Advanced-Lighting\\nuniform float u_Ambient : 1.0;\\nuniform float u_Diffuse : 1.0;\\nuniform float u_Specular : 1.0;\\nuniform int u_NumOfDirectionalLights : 1;\\nuniform int u_NumOfSpotLights : 0;\\n\\n#define SHININESS 32.0\\n#define MAX_NUM_OF_DIRECTIONAL_LIGHTS 3\\n#define MAX_NUM_OF_SPOT_LIGHTS 3\\n\\nstruct DirectionalLight {\\n  vec3 direction;\\n  vec3 ambient;\\n  vec3 diffuse;\\n  vec3 specular;\\n};\\n\\nstruct SpotLight {\\n  vec3 position;\\n  vec3 direction;\\n  vec3 ambient;\\n  vec3 diffuse;\\n  vec3 specular;\\n  float constant;\\n  float linear;\\n  float quadratic;\\n  float angle;\\n  float blur;\\n  float exponent;\\n};\\n\\nuniform DirectionalLight u_DirectionalLights[MAX_NUM_OF_DIRECTIONAL_LIGHTS];\\nuniform SpotLight u_SpotLights[MAX_NUM_OF_SPOT_LIGHTS];\\n\\nvec3 calc_directional_light(DirectionalLight light, vec3 normal, vec3 viewDir) {\\n  vec3 lightDir = normalize(light.direction);\\n  // diffuse shading\\n  float diff = max(dot(normal, lightDir), 0.0);\\n  // Blinn-Phong specular shading\\n  vec3 halfwayDir = normalize(lightDir + viewDir);\\n  float spec = pow(max(dot(normal, halfwayDir), 0.0), SHININESS);\\n\\n  vec3 ambient = light.ambient * u_Ambient;\\n  vec3 diffuse = light.diffuse * diff * u_Diffuse;\\n  vec3 specular = light.specular * spec * u_Specular;\\n\\n  return ambient + diffuse + specular;\\n}\\n\\n// vec3 calc_spot_light(SpotLight light, vec3 normal, vec3 fragPos, vec3 viewDir) {\\n//   vec3 lightDir = normalize(light.position - fragPos);\\n//   // diffuse shading\\n//   float diff = max(dot(normal, lightDir), 0.0);\\n//   // specular shading\\n//   vec3 reflectDir = reflect(-lightDir, normal);\\n//   float spec = pow(max(dot(viewDir, reflectDir), 0.0), SHININESS);\\n//   // attenuation\\n//   float distance = length(light.position - fragPos);\\n//   float attenuation = 1.0 / (light.constant + light.linear * distance +\\n//           light.quadratic * (distance * distance));\\n\\n//   vec3 ambient = light.ambient * u_Ambient;\\n//   vec3 diffuse = light.diffuse * diff * u_Diffuse;\\n//   vec3 specular = light.specular * spec * u_Specular;\\n\\n//   float spotEffect = dot(normalize(light.direction), -lightDir);\\n//   float spotCosCutoff = cos(light.angle / 180.0 * PI);\\n//   float spotCosOuterCutoff = cos((light.angle + light.blur) / 180.0 * PI);\\n//   float spotCosInnerCutoff = cos((light.angle - light.blur) / 180.0 * PI);\\n//   if (spotEffect > spotCosCutoff) {\\n//     spotEffect = pow(smoothstep(spotCosOuterCutoff, spotCosInnerCutoff, spotEffect), light.exponent);\\n//   } else {\\n//     spotEffect = 0.0;\\n//   }\\n\\n//   return ambient + attenuation * (spotEffect * diffuse + specular);\\n// }\\n\\nvec3 calc_lighting(vec3 position, vec3 normal, vec3 viewDir) {\\n  vec3 weight = vec3(0.0);\\n  for (int i = 0; i < MAX_NUM_OF_DIRECTIONAL_LIGHTS; i++) {\\n    if (i >= u_NumOfDirectionalLights) {\\n      break;\\n    }\\n    weight += calc_directional_light(u_DirectionalLights[i], normal, viewDir);\\n  }\\n  // for (int i = 0; i < MAX_NUM_OF_SPOT_LIGHTS; i++) {\\n  //   if (i >= u_NumOfSpotLights) {\\n  //     break;\\n  //   }\\n  //   weight += calc_spot_light(u_SpotLights[i], normal, position, viewDir);\\n  // }\\n  return weight;\\n}\\n\";\nvar pickingFrag = \"varying vec4 v_PickingResult;\\nuniform vec4 u_HighlightColor : [0, 0, 0, 0];\\nuniform float u_PickingStage : 0.0;\\nuniform float u_Dragging;\\n\\n#define PICKING_NONE 0.0\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\n/*\\n * Returns highlight color if this item is selected.\\n */\\nvec4 filterHighlightColor(vec4 color) {\\n  bool selected = bool(v_PickingResult.a);\\n\\n  if (selected) {\\n    vec4 highLightColor = u_HighlightColor * COLOR_SCALE;\\n\\n    float highLightAlpha = highLightColor.a;\\n    float highLightRatio = highLightAlpha / (highLightAlpha + color.a * (1.0 - highLightAlpha));\\n\\n    vec3 resultRGB = mix(color.rgb, highLightColor.rgb, highLightRatio);\\n    return vec4(resultRGB, color.a);\\n  } else {\\n    return color;\\n  }\\n}\\n\\n/*\\n * Returns picking color if picking enabled else unmodified argument.\\n */\\nvec4 filterPickingColor(vec4 color) {\\n  vec3 pickingColor = v_PickingResult.rgb;\\n  if (u_PickingStage == PICKING_ENCODE && length(pickingColor) < 0.001) {\\n    discard;\\n  }\\n  return u_PickingStage == PICKING_ENCODE ? vec4(pickingColor, step(0.001,color.a)): color;\\n}\\n\\n/*\\n * Returns picking color if picking is enabled if not\\n * highlight color if this item is selected, otherwise unmodified argument.\\n */\\nvec4 filterColor(vec4 color) {\\n  // TODO: \\u8FC7\\u6EE4\\u591A\\u4F59\\u7684 shader \\u8BA1\\u7B97\\n  // if(u_Dragging > 0.0) return color; // \\u6682\\u65F6\\u53BB\\u9664 \\u76F4\\u63A5\\u53D6\\u6D88\\u8BA1\\u7B97\\u5728\\u9009\\u4E2D\\u65F6\\u62D6\\u62FD\\u5730\\u56FE\\u4F1A\\u6709\\u95EE\\u9898\\n  return filterPickingColor(filterHighlightColor(color));\\n}\\n\";\nvar pickingVert = \"attribute vec3 a_PickingColor;\\nvarying vec4 v_PickingResult;\\n\\nuniform vec3 u_PickingColor : [0, 0, 0];\\nuniform vec4 u_HighlightColor : [0, 0, 0, 0];\\nuniform float u_PickingStage : 0.0;\\nuniform float u_PickingThreshold : 1.0;\\nuniform float u_PickingBuffer: 0.0;\\n\\n#define PICKING_NONE 0.0\\n#define PICKING_ENCODE 1.0\\n#define PICKING_HIGHLIGHT 2.0\\n#define COLOR_SCALE 1. / 255.\\n\\nbool isVertexPicked(vec3 vertexColor) {\\n  return\\n    abs(vertexColor.r - u_PickingColor.r) < u_PickingThreshold &&\\n    abs(vertexColor.g - u_PickingColor.g) < u_PickingThreshold &&\\n    abs(vertexColor.b - u_PickingColor.b) < u_PickingThreshold;\\n}\\n\\nvoid setPickingColor(vec3 pickingColor) {\\n  // compares only in highlight stage\\n  v_PickingResult.a = float((u_PickingStage == PICKING_HIGHLIGHT) && isVertexPicked(pickingColor));\\n\\n  // Stores the picking color so that the fragment shader can render it during picking\\n  v_PickingResult.rgb = pickingColor * COLOR_SCALE;\\n}\\n\\nfloat setPickingSize(float x) {\\n   return u_PickingStage == PICKING_ENCODE ? x + u_PickingBuffer : x;\\n}\\n\\nfloat setPickingOrder(float z) {\\n   bool selected = bool(v_PickingResult.a);\\n   return selected ? z + 1. : 0.;\\n}\\n\";\nvar project = \"\\n#define E 2.718281828459045\\nvec2 ProjectFlat(vec2 lnglat){\\n  float maxs=85.0511287798;\\n  float lat=max(min(maxs,lnglat.y),-maxs);\\n  float scale= 268435456.;\\n  float d=PI/180.;\\n  float x=lnglat.x*d;\\n  float y=lat*d;\\n  y=log(tan((PI/4.)+(y/2.)));\\n\\n  float a=.5/PI,\\n  b=.5,\\n  c=-.5/PI;\\n  d=.5;\\n  x=scale*(a*x+b);\\n  y=scale*(c*y+d);\\n  return vec2(x,y);\\n}\\n\\nvec2 unProjectFlat(vec2 px){\\n  float a=.5/PI;\\n  float b=.5;\\n  float c=-.5/PI;\\n  float d=.5;\\n  float scale = 268435456.;\\n  float x=(px.x/scale-b)/a;\\n  float y=(px.y/scale-d)/c;\\n  y=(atan(pow(E,y))-(PI/4.))*2.;\\n  d=PI/180.;\\n  float lat=y/d;\\n  float lng=x/d;\\n  return vec2(lng,lat);\\n}\\n\\nfloat pixelDistance(vec2 from, vec2 to) {\\n vec2 a1 = ProjectFlat(from);\\n vec2 b1 = ProjectFlat(to);\\n return distance(a1, b1);\\n}\\n\\n// gaode2.0\\nvec2 customProject(vec2 lnglat) { // \\u7ECF\\u7EAC\\u5EA6 => \\u5E73\\u9762\\u5750\\u6807\\n  float t = lnglat.x;\\n  float e = lnglat.y;\\n  float Sm = 180.0 / PI;\\n  float Tm = 6378137.0;\\n  float Rm = PI / 180.0;\\n  float r = 85.0511287798;\\n  e = max(min(r, e), -r);\\n  t *= Rm;\\n  e *= Rm;\\n  e = log(tan(PI / 4.0 + e / 2.0));\\n  return vec2(t * Tm, e * Tm);\\n}\\n\\nvec2 unProjCustomCoord(vec2 point) { // \\u5E73\\u9762\\u5750\\u6807 => \\u7ECF\\u7EAC\\u5EA6\\n  float Sm = 57.29577951308232; //180 / Math.PI\\n  float Tm = 6378137.0;\\n  float t = point.x;\\n  float e = point.y;\\n  return vec2(t / Tm * Sm, (2.0 * atan(exp(e / Tm)) - PI / 2.0) * Sm);\\n}\\n\\n\\nfloat customPixelDistance(vec2 from, vec2 to) {\\n vec2 a1 = ProjectFlat(from);\\n vec2 b1 = ProjectFlat(to);\\n return distance(a1, b1);\\n}\";\nvar projection = \"#define TILE_SIZE 512.0\\n#define PI 3.1415926536\\n#define WORLD_SCALE TILE_SIZE / (PI * 2.0)\\n\\n#define COORDINATE_SYSTEM_LNGLAT 1.0\\n#define COORDINATE_SYSTEM_LNGLAT_OFFSET 2.0\\n#define COORDINATE_SYSTEM_VECTOR_TILE 3.0\\n#define COORDINATE_SYSTEM_IDENTITY 4.0\\n#define COORDINATE_SYSTEM_P20 5.0\\n#define COORDINATE_SYSTEM_P20_OFFSET 6.0\\n#define COORDINATE_SYSTEM_METER_OFFSET 7.0\\n\\n#define COORDINATE_SYSTEM_P20_2 8.0\\n\\nuniform mat4 u_ViewMatrix;\\nuniform mat4 u_ProjectionMatrix;\\nuniform mat4 u_ViewProjectionMatrix;\\nuniform float u_Zoom : 1;\\nuniform float u_ZoomScale : 1;\\n\\nuniform float u_CoordinateSystem;\\nuniform vec2 u_ViewportCenter;\\nuniform vec4 u_ViewportCenterProjection;\\nuniform vec3 u_PixelsPerDegree;\\nuniform vec3 u_PixelsPerDegree2;\\nuniform vec3 u_PixelsPerMeter;\\n\\nuniform vec2 u_ViewportSize;\\nuniform float u_DevicePixelRatio;\\nuniform float u_FocalDistance;\\nuniform vec3 u_CameraPosition;\\n\\n// uniform mat4 u_Mvp;\\n\\n// web mercator coords -> world coords\\nvec2 project_mercator(vec2 lnglat) {\\n  float x = lnglat.x;\\n  return vec2(\\n    radians(x) + PI,\\n    PI - log(tan(PI * 0.25 + radians(lnglat.y) * 0.5))\\n  );\\n}\\n\\nfloat project_scale(float meters) {\\n  return meters * u_PixelsPerMeter.z;\\n}\\n\\n\\n// offset coords -> world coords\\nvec4 project_offset(vec4 offset) {\\n  float dy = offset.y;\\n  dy = clamp(dy, -1., 1.);\\n  vec3 pixels_per_unit = u_PixelsPerDegree + u_PixelsPerDegree2 * dy;\\n  return vec4(offset.xyz * pixels_per_unit, offset.w);\\n}\\n\\nvec3 project_normal(vec3 normal) {\\n  vec4 normal_modelspace = u_ModelMatrix * vec4(normal, 0.0);\\n  return normalize(normal_modelspace.xyz * u_PixelsPerMeter);\\n}\\n\\nvec3 project_offset_normal(vec3 vector) {\\n  if (u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_LNGLAT - 0.01\\n    || u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // normals generated by the polygon tesselator are in lnglat offsets instead of meters\\n    return normalize(vector * u_PixelsPerDegree);\\n  }\\n  return project_normal(vector);\\n}\\n// || u_CoordinateSystem < COORDINATE_SYSTEM_P20_OFFSET + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_P20_OFFSET - 0.01\\n// reverse Y\\nvec3 reverse_offset_normal(vec3 vector) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 ||u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET ) {\\n    return vector * vec3(1.0, -1.0, 1.0);\\n  }\\n\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.0\\n    return vector;\\n  }\\n  return vector;\\n}\\n\\nvec4 project_position(vec4 position) {\\n  float a = COORDINATE_SYSTEM_LNGLAT_OFFSET;\\n  float b = COORDINATE_SYSTEM_P20_OFFSET;\\n  float c = COORDINATE_SYSTEM_LNGLAT;\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET\\n    || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    float X = position.x - u_ViewportCenter.x;\\n    float Y = position.y - u_ViewportCenter.y;\\n    return project_offset(vec4(X, Y, position.z, position.w));\\n  }\\n  if (u_CoordinateSystem < COORDINATE_SYSTEM_LNGLAT + 0.01 && u_CoordinateSystem >COORDINATE_SYSTEM_LNGLAT - 0.01) {\\n    return vec4(\\n      project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale,\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20) {\\n    return vec4(\\n      (project_mercator(position.xy) * WORLD_SCALE * u_ZoomScale - vec2(215440491., 106744817.)) * vec2(1., -1.),\\n      project_scale(position.z),\\n      position.w\\n    );\\n  }\\n\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // return vec4(\\n    //   (position.xy * WORLD_SCALE * u_ZoomScale) * vec2(1., -1.), \\n    //   project_scale(position.z), \\n    //   position.w);\\n\\n     return vec4(\\n      position.xy, \\n      project_scale(position.z), \\n      position.w);\\n  }\\n  return position;\\n\\n  // TODO: \\u74E6\\u7247\\u5750\\u6807\\u7CFB & \\u5E38\\u89C4\\u4E16\\u754C\\u5750\\u6807\\u7CFB\\n}\\nvec2 project_pixel_size_to_clipspace(vec2 pixels) {\\n  vec2 offset = pixels / u_ViewportSize * u_DevicePixelRatio * 2.0;\\n  return offset * u_FocalDistance;\\n}\\n\\nfloat project_pixel_allmap(float pixel) {\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT) {\\n    return pixel * pow(2.0, u_Zoom);\\n  }\\n  return pixel;\\n}\\n\\nfloat project_pixel(float pixel) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    // P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom));\\n  }\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // P20_2 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF3\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom));\\n  }\\n  return pixel;\\n}\\nvec2 project_pixel(vec2 pixel) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_P20 || u_CoordinateSystem == COORDINATE_SYSTEM_P20_OFFSET) {\\n    // P20 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF1\\n    return pixel * pow(2.0, (19.0 - u_Zoom));\\n  }\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) {\\n    // P20_2 \\u5750\\u6807\\u7CFB\\u4E0B\\uFF0C\\u4E3A\\u4E86\\u548C Web \\u58A8\\u5361\\u6258\\u5750\\u6807\\u7CFB\\u7EDF\\u4E00\\uFF0Czoom \\u9ED8\\u8BA4\\u51CF3\\n    return pixel * pow(2.0, (19.0 - 3.0 - u_Zoom));\\n  }\\n  return pixel * -1.;\\n}\\n\\nvec4 project_common_position_to_clipspace(vec4 position, mat4 viewProjectionMatrix, vec4 center) {\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // Needs to be divided with project_uCommonUnitsPerMeter\\n    position.w *= u_PixelsPerMeter.z;\\n  }\\n\\n  return viewProjectionMatrix * position + center;\\n}\\n\\n// Projects from common space coordinates to clip space\\nvec4 project_common_position_to_clipspace(vec4 position) {\\n  return project_common_position_to_clipspace(\\n    position,\\n    u_ViewProjectionMatrix,\\n    u_ViewportCenterProjection\\n  );\\n}\\n\\nvec4 unproject_clipspace_to_position(vec4 clipspacePos, mat4 u_InverseViewProjectionMatrix) {\\n  vec4 pos = u_InverseViewProjectionMatrix * (clipspacePos - u_ViewportCenterProjection);\\n\\n  if (u_CoordinateSystem == COORDINATE_SYSTEM_METER_OFFSET ||\\n    u_CoordinateSystem == COORDINATE_SYSTEM_LNGLAT_OFFSET) {\\n    // Needs to be divided with project_uCommonUnitsPerMeter\\n     pos.w = pos.w / u_PixelsPerMeter.z;\\n  }\\n  return pos;\\n}\\n\\n\\nbool isEqual( float a,  float b) {\\n    return  a< b + 0.001 && a > b - 0.001;\\n}\";\nvar sdf2d = \"/**\\n * 2D signed distance field functions\\n * @see http://www.iquilezles.org/www/articles/distfunctions2d/distfunctions2d.htm\\n */\\n\\nfloat ndot(vec2 a, vec2 b ) { return a.x*b.x - a.y*b.y; }\\n\\nfloat sdCircle(vec2 p, float r) {\\n  return length(p) - r;\\n}\\n\\nfloat sdEquilateralTriangle(vec2 p) {\\n  float k = sqrt(3.0);\\n  p.x = abs(p.x) - 1.0;\\n  p.y = p.y + 1.0/k;\\n  if( p.x + k*p.y > 0.0 ) p = vec2(p.x-k*p.y,-k*p.x-p.y)/2.0;\\n  p.x -= clamp( p.x, -2.0, 0.0 );\\n  return -length(p)*sign(p.y);\\n}\\n\\nfloat sdBox(vec2 p, vec2 b) {\\n  vec2 d = abs(p)-b;\\n  return length(max(d,vec2(0))) + min(max(d.x,d.y),0.0);\\n}\\n\\nfloat sdPentagon(vec2 p, float r) {\\n  vec3 k = vec3(0.809016994,0.587785252,0.726542528);\\n  p.x = abs(p.x);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= vec2(clamp(p.x,-r*k.z,r*k.z),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagon(vec2 p, float r) {\\n  vec3 k = vec3(-0.866025404,0.5,0.577350269);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdOctogon(vec2 p, float r) {\\n  vec3 k = vec3(-0.9238795325, 0.3826834323, 0.4142135623 );\\n  p = abs(p);\\n  p -= 2.0*min(dot(vec2( k.x,k.y),p),0.0)*vec2( k.x,k.y);\\n  p -= 2.0*min(dot(vec2(-k.x,k.y),p),0.0)*vec2(-k.x,k.y);\\n  p -= vec2(clamp(p.x, -k.z*r, k.z*r), r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdHexagram(vec2 p, float r) {\\n  vec4 k=vec4(-0.5,0.8660254038,0.5773502692,1.7320508076);\\n  p = abs(p);\\n  p -= 2.0*min(dot(k.xy,p),0.0)*k.xy;\\n  p -= 2.0*min(dot(k.yx,p),0.0)*k.yx;\\n  p -= vec2(clamp(p.x,r*k.z,r*k.w),r);\\n  return length(p)*sign(p.y);\\n}\\n\\nfloat sdRhombus(vec2 p, vec2 b) {\\n  vec2 q = abs(p);\\n  float h = clamp((-2.0*ndot(q,b)+ndot(b,b))/dot(b,b),-1.0,1.0);\\n  float d = length( q - 0.5*b*vec2(1.0-h,1.0+h) );\\n  return d * sign( q.x*b.y + q.y*b.x - b.x*b.y );\\n}\\n\\nfloat sdVesica(vec2 p, float r, float d) {\\n  p = abs(p);\\n  float b = sqrt(r*r-d*d); // can delay this sqrt\\n  return ((p.y-b)*d>p.x*b)\\n          ? length(p-vec2(0.0,b))\\n          : length(p-vec2(-d,0.0))-r;\\n}\\n\";\nvar styleMapping = \"attribute float a_vertexId;\\n\\nuniform mat4 u_cellTypeLayout;      // \\u63CF\\u8FF0\\u6570\\u636E\\u7EB9\\u7406 cell \\u7ED3\\u6784\\u7684\\u77E9\\u9635\\nuniform sampler2D u_dataTexture;    // \\u6570\\u636E\\u7EB9\\u7406\\n\\nbool hasOpacity() { // \\u5224\\u65AD cell \\u4E2D\\u662F\\u5426\\u5B58\\u5728 opacity \\u7684\\u6570\\u636E\\n  return u_cellTypeLayout[1][0] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\\n}\\n\\nbool hasStrokeOpacity() { // \\u5224\\u65AD cell \\u4E2D\\u662F\\u5426\\u5B58\\u5728 strokeOpacity \\u7684\\u6570\\u636E\\n  return u_cellTypeLayout[1][1] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\\n}\\n\\nbool hasStrokeWidth() { // \\u5224\\u65AD cell \\u4E2D\\u662F\\u5426\\u5B58\\u5728 strokeWidth \\u7684\\u6570\\u636E\\n  return u_cellTypeLayout[1][2] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\\n}\\n\\nbool hasStroke() { // \\u5224\\u65AD cell \\u4E2D\\u662F\\u5426\\u5B58\\u5728 stroke \\u7684\\u6570\\u636E\\n  return u_cellTypeLayout[1][3] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\\n}\\n\\nbool hasOffsets() { // \\u5224\\u65AD cell \\u4E2D\\u662F\\u5426\\u5B58\\u5728 offsets \\u7684\\u6570\\u636E\\n  return u_cellTypeLayout[2][0] > 0.0 && u_cellTypeLayout[3][3] > 0.0;\\n}\\n\\n// \\u6839\\u636E\\u5750\\u6807\\u4F4D\\u7F6E\\u5148\\u662F\\u8BA1\\u7B97 uv \\uFF0C\\u7136\\u540E\\u6839\\u636E uv \\u4ECE\\u6570\\u636E\\u7EB9\\u7406\\u4E2D\\u53D6\\u503C\\nfloat pos2value(vec2 pos, float columnWidth, float rowHeight) {\\n  float u = (pos.r - 1.0) * columnWidth + columnWidth/2.0;\\n  float v = 1.0 - ((pos.g - 1.0) * rowHeight + rowHeight/2.0);\\n  return texture2D(u_dataTexture, vec2(u, v)).r;\\n}\\n\\n/*\\n  currentRow \\u5F53\\u524D\\u884C\\n  currentColumn \\u5F53\\u524D\\u5217\\n  columnCount \\u6709\\u591A\\u5C11\\u5217\\n  nextStep \\u9700\\u8981\\u8BA1\\u7B97\\u5F53\\u524D cell \\u540E\\u7684\\u7B2C\\u51E0\\u4E2A cell \\uFF08\\u5F53\\u524D cell \\u5219 nextStep = 0\\uFF09\\n*/\\nvec2 nextPos(float currentRow, float currentColumn, float columnCount, float nextStep) {\\n  float nextColumn = currentColumn;\\n  float nextRow = currentRow;\\n  if(currentColumn + nextStep <= columnCount){\\n    nextColumn = currentColumn + nextStep;\\n  } else {\\n    nextColumn = mod(currentColumn + nextStep, columnCount); // \\u4E0D\\u4F1A\\u51FA\\u73B0\\u8DE8\\u4E24\\u884C\\n    nextRow = currentRow + 1.0;\\n  }\\n  return vec2(nextColumn, nextRow);\\n}\\n\\n// \\u8BA1\\u7B97\\u5F53\\u524D\\u5355\\u4E2A cell \\u7684\\u5927\\u5C0F\\nfloat calCellCount() { \\n  //   u_cellTypeLayout\\n  //   cal_height, WIDTH, 0.0, 0.0, // rowCount columnCount - \\u51E0\\u884C\\u51E0\\u5217\\n  //   1.0, 1.0, 1.0, 0.0, // opacity strokeOpacity strokeWidth stroke - 1.0 \\u8868\\u793A\\u6709\\u6570\\u636E\\u6620\\u5C04\\u30010.0 \\u8868\\u793A\\u6CA1\\u6709\\n  //   1.0, 0.0, 0.0, 0.0, // offsets\\n  //   0.0, 0.0, 0.0, 0.0\\n  \\n  return  u_cellTypeLayout[1][0] +        // opacity\\n          u_cellTypeLayout[1][1] +        // strokeOpacity\\n          u_cellTypeLayout[1][2] +        // strokeWidth\\n          u_cellTypeLayout[1][3] * 4.0 +  // stroke\\n          u_cellTypeLayout[2][0] * 2.0;   // offsets\\n}\";\nvar styleMappingCalOpacity = \"\\n// \\u8BA1\\u7B97 opacity \\u548C\\u6807\\u793A\\u5728 cell \\u4E2D\\u53D6\\u503C\\u4F4D\\u7F6E\\u7684\\u504F\\u79FB\\u91CF textureOffset\\nvec2 calOpacityAndOffset(float cellCurrentRow, float cellCurrentColumn, float columnCount, float textureOffset, float columnWidth, float rowHeight) {\\n  if(!hasOpacity()) { // \\u6570\\u636E\\u7EB9\\u7406\\u4E2D\\u4E0D\\u5B58\\u5728 opacity \\u7684\\u65F6\\u5019\\u53D6\\u9ED8\\u8BA4\\u503C\\uFF08\\u7528\\u6237\\u5728 style \\u4E2D\\u4F20\\u5165\\u7684\\u662F\\u5E38\\u91CF\\uFF09\\n    return vec2(u_opacity, textureOffset);\\n  } else {\\n    vec2 valuePos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\\n    float textureOpacity = pos2value(valuePos, columnWidth, rowHeight);\\n    return vec2(textureOpacity, textureOffset + 1.0);\\n  }\\n}\\n\";\nvar styleMappingCalStrokeOpacity = \"\\n// \\u8BA1\\u7B97 strokeOpaicty \\u548C\\u6807\\u793A\\u5728 cell \\u4E2D\\u53D6\\u503C\\u4F4D\\u7F6E\\u7684\\u504F\\u79FB\\u91CF textureOffset\\nvec2 calStrokeOpacityAndOffset(float cellCurrentRow, float cellCurrentColumn, float columnCount, float textureOffset, float columnWidth, float rowHeight) {\\n  if(!hasStrokeOpacity()) {\\n    return vec2(u_stroke_opacity, textureOffset);\\n  } else {\\n    vec2 valuePos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\\n    float textureStrokeOpacity = pos2value(valuePos, columnWidth, rowHeight);\\n    return vec2(textureStrokeOpacity, textureOffset + 1.0);\\n  }\\n}\\n\";\nvar styleMappingCalStrokeWidth = \"\\n// \\u8BA1\\u7B97 strokeWidth \\u548C\\u6807\\u793A\\u5728 cell \\u4E2D\\u53D6\\u503C\\u4F4D\\u7F6E\\u7684\\u504F\\u79FB\\u91CF textureOffset\\nvec2 calStrokeWidthAndOffset(float cellCurrentRow, float cellCurrentColumn, float columnCount, float textureOffset, float columnWidth, float rowHeight) {\\n  if(!hasStrokeWidth()) {\\n    return vec2(u_stroke_width, textureOffset);\\n  } else {\\n    vec2 valuePos = nextPos(cellCurrentRow, cellCurrentColumn, columnCount, textureOffset);\\n    float textureStrokeWidth = pos2value(valuePos, columnWidth, rowHeight);\\n    return vec2(textureStrokeWidth, textureOffset + 1.0);\\n  }\\n}\\n\";\nvar precisionRegExp = /precision\\s+(high|low|medium)p\\s+float/;\nvar globalDefaultprecision = '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif\\n';\nvar includeRegExp = /#pragma include ([\"^+\"]?[\"\\ \"[a-zA-Z_0-9](.*)\"]*?)/g;\nvar ShaderModuleService = (_dec = injectable(), _dec(_class = function () {\n  function ShaderModuleService() {\n    _classCallCheck(this, ShaderModuleService);\n\n    _defineProperty(this, \"moduleCache\", {});\n\n    _defineProperty(this, \"rawContentCache\", {});\n  }\n\n  _createClass(ShaderModuleService, [{\n    key: \"registerBuiltinModules\",\n    value: function registerBuiltinModules() {\n      this.destroy();\n      this.registerModule('common', {\n        vs: common,\n        fs: common\n      });\n      this.registerModule('decode', {\n        vs: decode,\n        fs: ''\n      });\n      this.registerModule('projection', {\n        vs: projection,\n        fs: ''\n      });\n      this.registerModule('project', {\n        vs: project,\n        fs: ''\n      });\n      this.registerModule('sdf_2d', {\n        vs: '',\n        fs: sdf2d\n      });\n      this.registerModule('lighting', {\n        vs: lighting,\n        fs: ''\n      });\n      this.registerModule('light', {\n        vs: light,\n        fs: ''\n      });\n      this.registerModule('picking', {\n        vs: pickingVert,\n        fs: pickingFrag\n      });\n      this.registerModule('styleMapping', {\n        vs: styleMapping,\n        fs: ''\n      });\n      this.registerModule('styleMappingCalOpacity', {\n        vs: styleMappingCalOpacity,\n        fs: ''\n      });\n      this.registerModule('styleMappingCalStrokeOpacity', {\n        vs: styleMappingCalStrokeOpacity,\n        fs: ''\n      });\n      this.registerModule('styleMappingCalStrokeWidth', {\n        vs: styleMappingCalStrokeWidth,\n        fs: ''\n      });\n    }\n  }, {\n    key: \"registerModule\",\n    value: function registerModule(moduleName, moduleParams) {\n      if (this.rawContentCache[moduleName]) {\n        return;\n      }\n\n      var vs = moduleParams.vs,\n          fs = moduleParams.fs,\n          declaredUniforms = moduleParams.uniforms;\n\n      var _extractUniforms = extractUniforms(vs),\n          extractedVS = _extractUniforms.content,\n          vsUniforms = _extractUniforms.uniforms;\n\n      var _extractUniforms2 = extractUniforms(fs),\n          extractedFS = _extractUniforms2.content,\n          fsUniforms = _extractUniforms2.uniforms;\n\n      this.rawContentCache[moduleName] = {\n        fs: extractedFS,\n        uniforms: _objectSpread(_objectSpread(_objectSpread({}, vsUniforms), fsUniforms), declaredUniforms),\n        vs: extractedVS\n      };\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.moduleCache = {};\n      this.rawContentCache = {};\n    }\n  }, {\n    key: \"getModule\",\n    value: function getModule(moduleName) {\n      var _this = this;\n\n      if (this.moduleCache[moduleName]) {\n        return this.moduleCache[moduleName];\n      }\n\n      var rawVS = this.rawContentCache[moduleName].vs;\n      var rawFS = this.rawContentCache[moduleName].fs;\n\n      var _this$processModule = this.processModule(rawVS, [], 'vs'),\n          vs = _this$processModule.content,\n          vsIncludeList = _this$processModule.includeList;\n\n      var _this$processModule2 = this.processModule(rawFS, [], 'fs'),\n          fs = _this$processModule2.content,\n          fsIncludeList = _this$processModule2.includeList;\n\n      var compiledFs = fs;\n\n      var uniforms = _uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce(function (prev, cur) {\n        return _objectSpread(_objectSpread({}, prev), _this.rawContentCache[cur].uniforms);\n      }, {});\n\n      if (!precisionRegExp.test(fs)) {\n        compiledFs = globalDefaultprecision + fs;\n      }\n\n      this.moduleCache[moduleName] = {\n        fs: compiledFs.trim(),\n        uniforms: uniforms,\n        vs: vs.trim()\n      };\n      return this.moduleCache[moduleName];\n    }\n  }, {\n    key: \"processModule\",\n    value: function processModule(rawContent, includeList, type) {\n      var _this2 = this;\n\n      var compiled = rawContent.replace(includeRegExp, function (_, strMatch) {\n        var includeOpt = strMatch.split(' ');\n        var includeName = includeOpt[0].replace(/\"/g, '');\n\n        if (includeList.indexOf(includeName) > -1) {\n          return '';\n        }\n\n        var txt = _this2.rawContentCache[includeName][type];\n        includeList.push(includeName);\n\n        var _this2$processModule = _this2.processModule(txt, includeList, type),\n            content = _this2$processModule.content;\n\n        return content;\n      });\n      return {\n        content: compiled,\n        includeList: includeList\n      };\n    }\n  }]);\n\n  return ShaderModuleService;\n}()) || _class);\nexport { ShaderModuleService as default };","map":{"version":3,"sources":["../../../src/services/shader/ShaderModuleService.ts"],"names":["precisionRegExp","globalDefaultprecision","includeRegExp","injectable","ShaderModuleService","vs","fs","common","sdf2d","pickingFrag","declaredUniforms","moduleParams","extractedVS","vsUniforms","extractUniforms","extractedFS","fsUniforms","uniforms","rawVS","rawFS","vsIncludeList","fsIncludeList","compiledFs","compiled","includeOpt","strMatch","includeName","includeList","txt","content"],"mappings":"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","sourcesContent":["import { inject, injectable } from 'inversify';\nimport { uniq } from 'lodash';\nimport 'reflect-metadata';\nimport { extractUniforms } from '../../utils/shader-module';\nimport { IModuleParams, IShaderModuleService } from './IShaderModuleService';\n\nimport common from '../../shaders/common.glsl';\nimport decode from '../../shaders/decode.glsl';\nimport light from '../../shaders/light2.glsl';\nimport lighting from '../../shaders/lighting.glsl';\nimport pickingFrag from '../../shaders/picking.frag.glsl';\nimport pickingVert from '../../shaders/picking.vert.glsl';\nimport project from '../../shaders/project.glsl';\nimport projection from '../../shaders/projection.glsl';\nimport sdf2d from '../../shaders/sdf_2d.glsl';\nimport styleMapping from '../../shaders/styleMapping.glsl';\nimport styleMappingCalOpacity from '../../shaders/styleMappingCalOpacity.glsl';\nimport styleMappingCalStrokeOpacity from '../../shaders/styleMappingCalStrokeOpacity.glsl';\nimport styleMappingCalStrokeWidth from '../../shaders/styleMappingCalStrokeWidth.glsl';\n\nconst precisionRegExp = /precision\\s+(high|low|medium)p\\s+float/;\nconst globalDefaultprecision =\n  '#ifdef GL_FRAGMENT_PRECISION_HIGH\\n precision highp float;\\n #else\\n precision mediump float;\\n#endif\\n';\nconst includeRegExp = /#pragma include ([\"^+\"]?[\"\\ \"[a-zA-Z_0-9](.*)\"]*?)/g;\n\n@injectable()\nexport default class ShaderModuleService implements IShaderModuleService {\n  private moduleCache: { [key: string]: IModuleParams } = {};\n  private rawContentCache: { [key: string]: IModuleParams } = {};\n\n  public registerBuiltinModules() {\n    this.destroy();\n    this.registerModule('common', { vs: common, fs: common });\n    this.registerModule('decode', { vs: decode, fs: '' });\n    this.registerModule('projection', { vs: projection, fs: '' });\n    this.registerModule('project', { vs: project, fs: '' });\n    this.registerModule('sdf_2d', { vs: '', fs: sdf2d });\n    this.registerModule('lighting', { vs: lighting, fs: '' });\n    this.registerModule('light', { vs: light, fs: '' });\n    this.registerModule('picking', { vs: pickingVert, fs: pickingFrag });\n    this.registerModule('styleMapping', { vs: styleMapping, fs: '' });\n    this.registerModule('styleMappingCalOpacity', {\n      vs: styleMappingCalOpacity,\n      fs: '',\n    });\n    this.registerModule('styleMappingCalStrokeOpacity', {\n      vs: styleMappingCalStrokeOpacity,\n      fs: '',\n    });\n    this.registerModule('styleMappingCalStrokeWidth', {\n      vs: styleMappingCalStrokeWidth,\n      fs: '',\n    });\n  }\n\n  public registerModule(moduleName: string, moduleParams: IModuleParams) {\n    // prevent registering the same module multiple times\n    if (this.rawContentCache[moduleName]) {\n      return;\n    }\n\n    const { vs, fs, uniforms: declaredUniforms } = moduleParams;\n    const { content: extractedVS, uniforms: vsUniforms } = extractUniforms(vs);\n    const { content: extractedFS, uniforms: fsUniforms } = extractUniforms(fs);\n\n    this.rawContentCache[moduleName] = {\n      fs: extractedFS,\n      uniforms: {\n        ...vsUniforms,\n        ...fsUniforms,\n        ...declaredUniforms,\n      },\n      vs: extractedVS,\n    };\n  }\n  public destroy() {\n    this.moduleCache = {};\n    this.rawContentCache = {};\n  }\n  public getModule(moduleName: string): IModuleParams {\n    if (this.moduleCache[moduleName]) {\n      return this.moduleCache[moduleName];\n    }\n\n    const rawVS = this.rawContentCache[moduleName].vs;\n    const rawFS = this.rawContentCache[moduleName].fs;\n\n    const { content: vs, includeList: vsIncludeList } = this.processModule(\n      rawVS,\n      [],\n      'vs',\n    );\n    const { content: fs, includeList: fsIncludeList } = this.processModule(\n      rawFS,\n      [],\n      'fs',\n    );\n    let compiledFs = fs;\n    // TODO: extract uniforms and their default values from GLSL\n    const uniforms: {\n      [key: string]: any;\n    } = uniq(vsIncludeList.concat(fsIncludeList).concat(moduleName)).reduce(\n      (prev, cur: string) => {\n        return {\n          ...prev,\n          ...this.rawContentCache[cur].uniforms,\n        };\n      },\n      {},\n    );\n\n    /**\n     * set default precision for fragment shader\n     * https://stackoverflow.com/questions/28540290/why-it-is-necessary-to-set-precision-for-the-fragment-shader\n     */\n    if (!precisionRegExp.test(fs)) {\n      compiledFs = globalDefaultprecision + fs;\n    }\n\n    this.moduleCache[moduleName] = {\n      fs: compiledFs.trim(),\n      uniforms,\n      vs: vs.trim(),\n    };\n    return this.moduleCache[moduleName];\n  }\n\n  private processModule(\n    rawContent: string,\n    includeList: string[],\n    type: 'vs' | 'fs',\n  ): {\n    content: string;\n    includeList: string[];\n  } {\n    const compiled = rawContent.replace(includeRegExp, (_, strMatch) => {\n      const includeOpt = strMatch.split(' ');\n      const includeName = includeOpt[0].replace(/\"/g, '');\n\n      if (includeList.indexOf(includeName) > -1) {\n        return '';\n      }\n\n      const txt = this.rawContentCache[includeName][type];\n      includeList.push(includeName);\n\n      const { content } = this.processModule(txt, includeList, type);\n      return content;\n    });\n\n    return {\n      content: compiled,\n      includeList,\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}