{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _dec, _class;\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { $window } from '@antv/l7-utils';\nimport { EventEmitter } from 'eventemitter3';\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { buildIconMaping } from '../../utils/font_util';\nvar BUFFER = 3;\nvar MAX_CANVAS_WIDTH = 1024;\nvar imageSize = 64;\nvar IconService = (_dec = injectable(), _dec(_class = function (_EventEmitter) {\n  _inherits(IconService, _EventEmitter);\n\n  var _super = _createSuper(IconService);\n\n  function IconService() {\n    var _this;\n\n    _classCallCheck(this, IconService);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"canvasHeight\", 128);\n\n    _defineProperty(_assertThisInitialized(_this), \"texture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"canvas\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"iconData\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"iconMap\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"ctx\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"loadingImageCount\", 0);\n\n    return _this;\n  }\n\n  _createClass(IconService, [{\n    key: \"isLoading\",\n    value: function isLoading() {\n      return this.loadingImageCount === 0;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.iconData = [];\n      this.iconMap = {};\n      this.canvas = $window.document.createElement('canvas');\n      this.ctx = this.canvas.getContext('2d');\n    }\n  }, {\n    key: \"addImage\",\n    value: function addImage(id, image) {\n      var _this2 = this;\n\n      var imagedata = new Image();\n      this.loadingImageCount++;\n\n      if (this.hasImage(id)) {\n        throw new Error('Image Id already exists');\n      }\n\n      this.iconData.push({\n        id: id,\n        size: imageSize\n      });\n      this.updateIconMap();\n      this.loadImage(image).then(function (img) {\n        imagedata = img;\n\n        var iconImage = _this2.iconData.find(function (icon) {\n          return icon.id === id;\n        });\n\n        if (iconImage) {\n          iconImage.image = imagedata;\n          iconImage.width = imagedata.width;\n          iconImage.height = imagedata.height;\n        }\n\n        _this2.update();\n      });\n    }\n  }, {\n    key: \"addImageMini\",\n    value: function addImageMini(id, image, sceneService) {\n      var _this3 = this;\n\n      var canvas = sceneService.getSceneConfig().canvas;\n      var imagedata = canvas.createImage();\n      this.loadingImageCount++;\n\n      if (this.hasImage(id)) {\n        throw new Error('Image Id already exists');\n      }\n\n      this.iconData.push({\n        id: id,\n        size: imageSize\n      });\n      this.updateIconMap();\n      this.loadImageMini(image, canvas).then(function (img) {\n        imagedata = img;\n\n        var iconImage = _this3.iconData.find(function (icon) {\n          return icon.id === id;\n        });\n\n        if (iconImage) {\n          iconImage.image = imagedata;\n          iconImage.width = imagedata.width;\n          iconImage.height = imagedata.height;\n        }\n\n        _this3.update();\n      });\n    }\n  }, {\n    key: \"getTexture\",\n    value: function getTexture() {\n      return this.texture;\n    }\n  }, {\n    key: \"getIconMap\",\n    value: function getIconMap() {\n      return this.iconMap;\n    }\n  }, {\n    key: \"getCanvas\",\n    value: function getCanvas() {\n      return this.canvas;\n    }\n  }, {\n    key: \"hasImage\",\n    value: function hasImage(id) {\n      return this.iconMap.hasOwnProperty(id);\n    }\n  }, {\n    key: \"removeImage\",\n    value: function removeImage(id) {\n      if (this.hasImage(id)) {\n        this.iconData = this.iconData.filter(function (icon) {\n          return icon.id !== id;\n        });\n        delete this.iconMap[id];\n        this.update();\n      }\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.iconData = [];\n      this.iconMap = {};\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.updateIconMap();\n      this.updateIconAtlas();\n      this.loadingImageCount--;\n\n      if (this.loadingImageCount === 0) {\n        this.emit('imageUpdate');\n      }\n    }\n  }, {\n    key: \"updateIconAtlas\",\n    value: function updateIconAtlas() {\n      var _this4 = this;\n\n      this.canvas.width = MAX_CANVAS_WIDTH;\n      this.canvas.height = this.canvasHeight;\n      Object.keys(this.iconMap).forEach(function (item) {\n        var _this4$iconMap$item = _this4.iconMap[item],\n            x = _this4$iconMap$item.x,\n            y = _this4$iconMap$item.y,\n            image = _this4$iconMap$item.image,\n            _this4$iconMap$item$w = _this4$iconMap$item.width,\n            width = _this4$iconMap$item$w === void 0 ? 64 : _this4$iconMap$item$w,\n            _this4$iconMap$item$h = _this4$iconMap$item.height,\n            height = _this4$iconMap$item$h === void 0 ? 64 : _this4$iconMap$item$h;\n        var max = Math.max(width, height);\n        var ratio = max / imageSize;\n        var drawHeight = height / ratio;\n        var drawWidth = width / ratio;\n\n        if (image) {\n          _this4.ctx.drawImage(image, x + (imageSize - drawWidth) / 2, y + (imageSize - drawHeight) / 2, drawWidth, drawHeight);\n        }\n      });\n    }\n  }, {\n    key: \"updateIconMap\",\n    value: function updateIconMap() {\n      var _buildIconMaping = buildIconMaping(this.iconData, BUFFER, MAX_CANVAS_WIDTH),\n          mapping = _buildIconMaping.mapping,\n          canvasHeight = _buildIconMaping.canvasHeight;\n\n      this.iconMap = mapping;\n      this.canvasHeight = canvasHeight;\n    }\n  }, {\n    key: \"loadImage\",\n    value: function loadImage(url) {\n      return new Promise(function (resolve, reject) {\n        if (url instanceof HTMLImageElement) {\n          resolve(url);\n          return;\n        }\n\n        var image = new Image();\n        image.crossOrigin = 'anonymous';\n\n        image.onload = function () {\n          resolve(image);\n        };\n\n        image.onerror = function () {\n          reject(new Error('Could not load image at ' + url));\n        };\n\n        image.src = url instanceof File ? URL.createObjectURL(url) : url;\n      });\n    }\n  }, {\n    key: \"loadImageMini\",\n    value: function loadImageMini(url, canvas) {\n      return new Promise(function (resolve, reject) {\n        var image = canvas.createImage();\n        image.crossOrigin = 'anonymous';\n\n        image.onload = function () {\n          resolve(image);\n        };\n\n        image.onerror = function () {\n          reject(new Error('Could not load image at ' + url));\n        };\n\n        image.src = url;\n      });\n    }\n  }]);\n\n  return IconService;\n}(EventEmitter)) || _class);\nexport { IconService as default };","map":{"version":3,"sources":["../../../src/services/asset/IconService.ts"],"names":["BUFFER","MAX_CANVAS_WIDTH","imageSize","injectable","IconService","EventEmitter","$window","imagedata","id","size","iconImage","icon","canvas","sceneService","Object","x","y","image","width","height","max","Math","ratio","drawHeight","drawWidth","mapping","canvasHeight","buildIconMaping","url","resolve","reject","URL"],"mappings":"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","sourcesContent":["import { $window } from '@antv/l7-utils';\nimport { EventEmitter } from 'eventemitter3';\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { buildIconMaping } from '../../utils/font_util';\nimport { ITexture2D } from '../renderer/ITexture2D';\nimport { ISceneService } from '../scene/ISceneService';\nimport {\n  IIcon,\n  IICONMap,\n  IIconService,\n  IIconValue,\n  IImage,\n} from './IIconService';\nconst BUFFER = 3;\nconst MAX_CANVAS_WIDTH = 1024;\nconst imageSize = 64;\n@injectable()\nexport default class IconService extends EventEmitter implements IIconService {\n  public canvasHeight: number = 128;\n  private texture: ITexture2D;\n  private canvas: HTMLCanvasElement;\n  private iconData: IIcon[];\n  private iconMap: IICONMap;\n  private ctx: CanvasRenderingContext2D;\n  private loadingImageCount = 0;\n\n  public isLoading() {\n    return this.loadingImageCount === 0;\n  }\n  public init() {\n    this.iconData = [];\n    this.iconMap = {};\n    this.canvas = $window.document.createElement('canvas');\n    this.ctx = this.canvas.getContext('2d') as CanvasRenderingContext2D;\n  }\n\n  public addImage(id: string, image: IImage) {\n    let imagedata = new Image();\n    this.loadingImageCount++;\n    if (this.hasImage(id)) {\n      throw new Error('Image Id already exists');\n    }\n    this.iconData.push({\n      id,\n      size: imageSize,\n    });\n    this.updateIconMap();\n    this.loadImage(image).then((img) => {\n      imagedata = img as HTMLImageElement;\n      const iconImage = this.iconData.find((icon: IIcon) => {\n        return icon.id === id;\n      });\n      if (iconImage) {\n        iconImage.image = imagedata;\n        iconImage.width = imagedata.width;\n        iconImage.height = imagedata.height;\n      }\n      this.update();\n    });\n  }\n\n  /**\n   * 适配小程序\n   * @param id\n   * @param image\n   * @param sceneService\n   */\n  public addImageMini(id: string, image: IImage, sceneService: ISceneService) {\n    const canvas = sceneService.getSceneConfig().canvas;\n    // @ts-ignore\n    let imagedata = canvas.createImage();\n    this.loadingImageCount++;\n    if (this.hasImage(id)) {\n      throw new Error('Image Id already exists');\n    }\n    this.iconData.push({\n      id,\n      size: imageSize,\n    });\n    this.updateIconMap();\n    this.loadImageMini(image, canvas as HTMLCanvasElement).then((img) => {\n      imagedata = img as HTMLImageElement;\n      const iconImage = this.iconData.find((icon: IIcon) => {\n        return icon.id === id;\n      });\n      if (iconImage) {\n        iconImage.image = imagedata;\n        iconImage.width = imagedata.width;\n        iconImage.height = imagedata.height;\n      }\n      this.update();\n    });\n  }\n\n  public getTexture(): ITexture2D {\n    return this.texture;\n  }\n\n  public getIconMap() {\n    return this.iconMap;\n  }\n\n  public getCanvas() {\n    return this.canvas;\n  }\n\n  public hasImage(id: string): boolean {\n    return this.iconMap.hasOwnProperty(id);\n  }\n\n  public removeImage(id: string): void {\n    if (this.hasImage(id)) {\n      this.iconData = this.iconData.filter((icon) => {\n        return icon.id !== id;\n      });\n      delete this.iconMap[id];\n      this.update();\n    }\n  }\n  public destroy(): void {\n    this.iconData = [];\n    this.iconMap = {};\n  }\n  private update() {\n    this.updateIconMap();\n    this.updateIconAtlas();\n    this.loadingImageCount--;\n    if (this.loadingImageCount === 0) {\n      this.emit('imageUpdate');\n    }\n  }\n\n  /**\n   * 将新增的 icon 图像存储到画布上（正方形）\n   */\n  private updateIconAtlas() {\n    this.canvas.width = MAX_CANVAS_WIDTH;\n    this.canvas.height = this.canvasHeight;\n    Object.keys(this.iconMap).forEach((item: string) => {\n      const { x, y, image, width = 64, height = 64 } = this.iconMap[item];\n      const max = Math.max(width as number, height as number);\n      const ratio = max / imageSize;\n      const drawHeight = height / ratio;\n      const drawWidth = width / ratio;\n      if (image) {\n        this.ctx.drawImage(\n          image,\n          x + (imageSize - drawWidth) / 2,\n          y + (imageSize - drawHeight) / 2,\n          drawWidth,\n          drawHeight,\n        );\n      }\n    });\n  }\n\n  /**\n   * 计算 icon 在画布上的排布（是否需要换行）\n   */\n  private updateIconMap() {\n    const { mapping, canvasHeight } = buildIconMaping(\n      this.iconData,\n      BUFFER,\n      MAX_CANVAS_WIDTH,\n    );\n    this.iconMap = mapping;\n    this.canvasHeight = canvasHeight;\n  }\n\n  private loadImage(url: IImage) {\n    return new Promise((resolve, reject) => {\n      if (url instanceof HTMLImageElement) {\n        resolve(url);\n        return;\n      }\n      const image = new Image();\n      image.crossOrigin = 'anonymous';\n      image.onload = () => {\n        resolve(image);\n      };\n      image.onerror = () => {\n        reject(new Error('Could not load image at ' + url));\n      };\n      image.src = url instanceof File ? URL.createObjectURL(url) : url;\n    });\n  }\n\n  /**\n   * 适配小程序\n   * @param url\n   * @returns\n   */\n  private loadImageMini(url: IImage, canvas: HTMLCanvasElement) {\n    return new Promise((resolve, reject) => {\n      // @ts-ignore\n      const image = canvas.createImage();\n      image.crossOrigin = 'anonymous';\n      image.onload = () => {\n        resolve(image);\n      };\n      image.onerror = () => {\n        reject(new Error('Could not load image at ' + url));\n      };\n      image.src = url as string;\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}