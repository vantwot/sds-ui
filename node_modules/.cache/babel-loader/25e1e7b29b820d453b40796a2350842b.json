{"ast":null,"code":"import _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt, StringExt } from '../util';\nimport { Point, Polyline } from '../geometry';\nimport { Registry } from '../registry';\nimport { Markup } from '../view/markup';\nimport { ShareRegistry } from './registry';\nimport { Cell } from './cell';\nexport var Edge = /*#__PURE__*/function (_Cell, _Symbol$toStringTag) {\n  _inherits(Edge, _Cell);\n\n  var _super = _createSuper(Edge);\n\n  function Edge() {\n    var metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Edge);\n\n    return _super.call(this, metadata);\n  }\n\n  _createClass(Edge, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Edge.toStringTag;\n    }\n  }, {\n    key: \"preprocess\",\n    value: function preprocess(metadata, ignoreIdCheck) {\n      var source = metadata.source,\n          sourceCell = metadata.sourceCell,\n          sourcePort = metadata.sourcePort,\n          sourcePoint = metadata.sourcePoint,\n          target = metadata.target,\n          targetCell = metadata.targetCell,\n          targetPort = metadata.targetPort,\n          targetPoint = metadata.targetPoint,\n          others = __rest(metadata, [\"source\", \"sourceCell\", \"sourcePort\", \"sourcePoint\", \"target\", \"targetCell\", \"targetPort\", \"targetPoint\"]);\n\n      var data = others;\n\n      var isValidId = function isValidId(val) {\n        return typeof val === 'string' || typeof val === 'number';\n      };\n\n      if (source != null) {\n        if (Cell.isCell(source)) {\n          data.source = {\n            cell: source.id\n          };\n        } else if (isValidId(source)) {\n          data.source = {\n            cell: source\n          };\n        } else if (Point.isPoint(source)) {\n          data.source = source.toJSON();\n        } else if (Array.isArray(source)) {\n          data.source = {\n            x: source[0],\n            y: source[1]\n          };\n        } else {\n          var cell = source.cell;\n\n          if (Cell.isCell(cell)) {\n            data.source = Object.assign(Object.assign({}, source), {\n              cell: cell.id\n            });\n          } else {\n            data.source = source;\n          }\n        }\n      }\n\n      if (sourceCell != null || sourcePort != null) {\n        var terminal = data.source;\n\n        if (sourceCell != null) {\n          var id = isValidId(sourceCell) ? sourceCell : sourceCell.id;\n\n          if (terminal) {\n            terminal.cell = id;\n          } else {\n            terminal = data.source = {\n              cell: id\n            };\n          }\n        }\n\n        if (sourcePort != null && terminal) {\n          terminal.port = sourcePort;\n        }\n      } else if (sourcePoint != null) {\n        data.source = Point.create(sourcePoint).toJSON();\n      }\n\n      if (target != null) {\n        if (Cell.isCell(target)) {\n          data.target = {\n            cell: target.id\n          };\n        } else if (isValidId(target)) {\n          data.target = {\n            cell: target\n          };\n        } else if (Point.isPoint(target)) {\n          data.target = target.toJSON();\n        } else if (Array.isArray(target)) {\n          data.target = {\n            x: target[0],\n            y: target[1]\n          };\n        } else {\n          var _cell = target.cell;\n\n          if (Cell.isCell(_cell)) {\n            data.target = Object.assign(Object.assign({}, target), {\n              cell: _cell.id\n            });\n          } else {\n            data.target = target;\n          }\n        }\n      }\n\n      if (targetCell != null || targetPort != null) {\n        var _terminal = data.target;\n\n        if (targetCell != null) {\n          var _id = isValidId(targetCell) ? targetCell : targetCell.id;\n\n          if (_terminal) {\n            _terminal.cell = _id;\n          } else {\n            _terminal = data.target = {\n              cell: _id\n            };\n          }\n        }\n\n        if (targetPort != null && _terminal) {\n          _terminal.port = targetPort;\n        }\n      } else if (targetPoint != null) {\n        data.target = Point.create(targetPoint).toJSON();\n      }\n\n      return _get(_getPrototypeOf(Edge.prototype), \"preprocess\", this).call(this, data, ignoreIdCheck);\n    }\n  }, {\n    key: \"setup\",\n    value: function setup() {\n      var _this = this;\n\n      _get(_getPrototypeOf(Edge.prototype), \"setup\", this).call(this);\n\n      this.on('change:labels', function (args) {\n        return _this.onLabelsChanged(args);\n      });\n      this.on('change:vertices', function (args) {\n        return _this.onVertexsChanged(args);\n      });\n    }\n  }, {\n    key: \"isEdge\",\n    value: function isEdge() {\n      return true;\n    } // #region terminal\n\n  }, {\n    key: \"disconnect\",\n    value: function disconnect() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.set({\n        source: {\n          x: 0,\n          y: 0\n        },\n        target: {\n          x: 0,\n          y: 0\n        }\n      }, options);\n      return this;\n    }\n  }, {\n    key: \"source\",\n    get: function get() {\n      return this.getSource();\n    }\n  }, {\n    key: \"source\",\n    set: function set(data) {\n      this.setSource(data);\n    }\n  }, {\n    key: \"getSource\",\n    value: function getSource() {\n      return this.getTerminal('source');\n    }\n  }, {\n    key: \"getSourceCellId\",\n    value: function getSourceCellId() {\n      return this.source.cell;\n    }\n  }, {\n    key: \"getSourcePortId\",\n    value: function getSourcePortId() {\n      return this.source.port;\n    }\n  }, {\n    key: \"setSource\",\n    value: function setSource(source, args) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.setTerminal('source', source, args, options);\n    }\n  }, {\n    key: \"target\",\n    get: function get() {\n      return this.getTarget();\n    }\n  }, {\n    key: \"target\",\n    set: function set(data) {\n      this.setTarget(data);\n    }\n  }, {\n    key: \"getTarget\",\n    value: function getTarget() {\n      return this.getTerminal('target');\n    }\n  }, {\n    key: \"getTargetCellId\",\n    value: function getTargetCellId() {\n      return this.target.cell;\n    }\n  }, {\n    key: \"getTargetPortId\",\n    value: function getTargetPortId() {\n      return this.target.port;\n    }\n  }, {\n    key: \"setTarget\",\n    value: function setTarget(target, args) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      return this.setTerminal('target', target, args, options);\n    }\n  }, {\n    key: \"getTerminal\",\n    value: function getTerminal(type) {\n      return Object.assign({}, this.store.get(type));\n    }\n  }, {\n    key: \"setTerminal\",\n    value: function setTerminal(type, terminal, args) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n      // `terminal` is a cell\n      if (Cell.isCell(terminal)) {\n        this.store.set(type, ObjectExt.merge({}, args, {\n          cell: terminal.id\n        }), options);\n        return this;\n      } // `terminal` is a point-like object\n\n\n      var p = terminal;\n\n      if (Point.isPoint(terminal) || p.x != null && p.y != null) {\n        this.store.set(type, ObjectExt.merge({}, args, {\n          x: p.x,\n          y: p.y\n        }), options);\n        return this;\n      } // `terminal` is an object\n\n\n      this.store.set(type, ObjectExt.cloneDeep(terminal), options);\n      return this;\n    }\n  }, {\n    key: \"getSourcePoint\",\n    value: function getSourcePoint() {\n      return this.getTerminalPoint('source');\n    }\n  }, {\n    key: \"getTargetPoint\",\n    value: function getTargetPoint() {\n      return this.getTerminalPoint('target');\n    }\n  }, {\n    key: \"getTerminalPoint\",\n    value: function getTerminalPoint(type) {\n      var terminal = this[type];\n\n      if (Point.isPointLike(terminal)) {\n        return Point.create(terminal);\n      }\n\n      var cell = this.getTerminalCell(type);\n\n      if (cell) {\n        return cell.getConnectionPoint(this, type);\n      }\n\n      return new Point();\n    }\n  }, {\n    key: \"getSourceCell\",\n    value: function getSourceCell() {\n      return this.getTerminalCell('source');\n    }\n  }, {\n    key: \"getTargetCell\",\n    value: function getTargetCell() {\n      return this.getTerminalCell('target');\n    }\n  }, {\n    key: \"getTerminalCell\",\n    value: function getTerminalCell(type) {\n      if (this.model) {\n        var cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();\n\n        if (cellId) {\n          return this.model.getCell(cellId);\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"getSourceNode\",\n    value: function getSourceNode() {\n      return this.getTerminalNode('source');\n    }\n  }, {\n    key: \"getTargetNode\",\n    value: function getTargetNode() {\n      return this.getTerminalNode('target');\n    }\n  }, {\n    key: \"getTerminalNode\",\n    value: function getTerminalNode(type) {\n      var cell = this; // eslint-disable-line\n\n      var visited = {};\n\n      while (cell && cell.isEdge()) {\n        if (visited[cell.id]) {\n          return null;\n        }\n\n        visited[cell.id] = true;\n        cell = cell.getTerminalCell(type);\n      }\n\n      return cell && cell.isNode() ? cell : null;\n    } // #endregion\n    // #region router\n\n  }, {\n    key: \"router\",\n    get: function get() {\n      return this.getRouter();\n    }\n  }, {\n    key: \"router\",\n    set: function set(data) {\n      if (data == null) {\n        this.removeRouter();\n      } else {\n        this.setRouter(data);\n      }\n    }\n  }, {\n    key: \"getRouter\",\n    value: function getRouter() {\n      return this.store.get('router');\n    }\n  }, {\n    key: \"setRouter\",\n    value: function setRouter(name, args, options) {\n      if (typeof name === 'object') {\n        this.store.set('router', name, args);\n      } else {\n        this.store.set('router', {\n          name: name,\n          args: args\n        }, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeRouter\",\n    value: function removeRouter() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.store.remove('router', options);\n      return this;\n    } // #endregion\n    // #region connector\n\n  }, {\n    key: \"connector\",\n    get: function get() {\n      return this.getConnector();\n    }\n  }, {\n    key: \"connector\",\n    set: function set(data) {\n      if (data == null) {\n        this.removeConnector();\n      } else {\n        this.setConnector(data);\n      }\n    }\n  }, {\n    key: \"getConnector\",\n    value: function getConnector() {\n      return this.store.get('connector');\n    }\n  }, {\n    key: \"setConnector\",\n    value: function setConnector(name, args, options) {\n      if (typeof name === 'object') {\n        this.store.set('connector', name, args);\n      } else {\n        this.store.set('connector', {\n          name: name,\n          args: args\n        }, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeConnector\",\n    value: function removeConnector() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.store.remove('connector', options);\n    } // #endregion\n    // #region strategy\n\n  }, {\n    key: \"strategy\",\n    get: function get() {\n      return this.getStrategy();\n    }\n  }, {\n    key: \"strategy\",\n    set: function set(data) {\n      if (data == null) {\n        this.removeStrategy();\n      } else {\n        this.setStrategy(data);\n      }\n    }\n  }, {\n    key: \"getStrategy\",\n    value: function getStrategy() {\n      return this.store.get('strategy');\n    }\n  }, {\n    key: \"setStrategy\",\n    value: function setStrategy(name, args, options) {\n      if (typeof name === 'object') {\n        this.store.set('strategy', name, args);\n      } else {\n        this.store.set('strategy', {\n          name: name,\n          args: args\n        }, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeStrategy\",\n    value: function removeStrategy() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return this.store.remove('strategy', options);\n    } // #endregion\n    // #region labels\n\n  }, {\n    key: \"getDefaultLabel\",\n    value: function getDefaultLabel() {\n      var ctor = this.constructor;\n      var defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};\n      return ObjectExt.cloneDeep(defaults);\n    }\n  }, {\n    key: \"labels\",\n    get: function get() {\n      return this.getLabels();\n    }\n  }, {\n    key: \"labels\",\n    set: function set(labels) {\n      this.setLabels(labels);\n    }\n  }, {\n    key: \"getLabels\",\n    value: function getLabels() {\n      var _this2 = this;\n\n      return _toConsumableArray(this.store.get('labels', [])).map(function (item) {\n        return _this2.parseLabel(item);\n      });\n    }\n  }, {\n    key: \"setLabels\",\n    value: function setLabels(labels) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);\n      return this;\n    }\n  }, {\n    key: \"insertLabel\",\n    value: function insertLabel(label, index) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var labels = this.getLabels();\n      var len = labels.length;\n      var idx = index != null && Number.isFinite(index) ? index : len;\n\n      if (idx < 0) {\n        idx = len + idx + 1;\n      }\n\n      labels.splice(idx, 0, this.parseLabel(label));\n      return this.setLabels(labels, options);\n    }\n  }, {\n    key: \"appendLabel\",\n    value: function appendLabel(label) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.insertLabel(label, -1, options);\n    }\n  }, {\n    key: \"getLabelAt\",\n    value: function getLabelAt(index) {\n      var labels = this.getLabels();\n\n      if (index != null && Number.isFinite(index)) {\n        return this.parseLabel(labels[index]);\n      }\n\n      return null;\n    }\n  }, {\n    key: \"setLabelAt\",\n    value: function setLabelAt(index, label) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (index != null && Number.isFinite(index)) {\n        var labels = this.getLabels();\n        labels[index] = this.parseLabel(label);\n        this.setLabels(labels, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeLabelAt\",\n    value: function removeLabelAt(index) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var labels = this.getLabels();\n      var idx = index != null && Number.isFinite(index) ? index : -1;\n      var removed = labels.splice(idx, 1);\n      this.setLabels(labels, options);\n      return removed.length ? removed[0] : null;\n    }\n  }, {\n    key: \"parseLabel\",\n    value: function parseLabel(label) {\n      if (typeof label === 'string') {\n        var ctor = this.constructor;\n        return ctor.parseStringLabel(label);\n      }\n\n      return label;\n    }\n  }, {\n    key: \"onLabelsChanged\",\n    value: function onLabelsChanged(_ref) {\n      var previous = _ref.previous,\n          current = _ref.current;\n      var added = previous && current ? current.filter(function (label1) {\n        if (!previous.find(function (label2) {\n          return label1 === label2 || ObjectExt.isEqual(label1, label2);\n        })) {\n          return label1;\n        }\n\n        return null;\n      }) : current ? _toConsumableArray(current) : [];\n      var removed = previous && current ? previous.filter(function (label1) {\n        if (!current.find(function (label2) {\n          return label1 === label2 || ObjectExt.isEqual(label1, label2);\n        })) {\n          return label1;\n        }\n\n        return null;\n      }) : previous ? _toConsumableArray(previous) : [];\n\n      if (added.length > 0) {\n        this.notify('labels:added', {\n          added: added,\n          cell: this,\n          edge: this\n        });\n      }\n\n      if (removed.length > 0) {\n        this.notify('labels:removed', {\n          removed: removed,\n          cell: this,\n          edge: this\n        });\n      }\n    } // #endregion\n    // #region vertices\n\n  }, {\n    key: \"vertexMarkup\",\n    get: function get() {\n      return this.getVertexMarkup();\n    }\n  }, {\n    key: \"vertexMarkup\",\n    set: function set(markup) {\n      this.setVertexMarkup(markup);\n    }\n  }, {\n    key: \"getDefaultVertexMarkup\",\n    value: function getDefaultVertexMarkup() {\n      return this.store.get('defaultVertexMarkup') || Markup.getEdgeVertexMarkup();\n    }\n  }, {\n    key: \"getVertexMarkup\",\n    value: function getVertexMarkup() {\n      return this.store.get('vertexMarkup') || this.getDefaultVertexMarkup();\n    }\n  }, {\n    key: \"setVertexMarkup\",\n    value: function setVertexMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('vertexMarkup', Markup.clone(markup), options);\n      return this;\n    }\n  }, {\n    key: \"vertices\",\n    get: function get() {\n      return this.getVertices();\n    }\n  }, {\n    key: \"vertices\",\n    set: function set(vertices) {\n      this.setVertices(vertices);\n    }\n  }, {\n    key: \"getVertices\",\n    value: function getVertices() {\n      return _toConsumableArray(this.store.get('vertices', []));\n    }\n  }, {\n    key: \"setVertices\",\n    value: function setVertices(vertices) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var points = Array.isArray(vertices) ? vertices : [vertices];\n      this.store.set('vertices', points.map(function (p) {\n        return Point.toJSON(p);\n      }), options);\n      return this;\n    }\n  }, {\n    key: \"insertVertex\",\n    value: function insertVertex(vertice, index) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var vertices = this.getVertices();\n      var len = vertices.length;\n      var idx = index != null && Number.isFinite(index) ? index : len;\n\n      if (idx < 0) {\n        idx = len + idx + 1;\n      }\n\n      vertices.splice(idx, 0, Point.toJSON(vertice));\n      return this.setVertices(vertices, options);\n    }\n  }, {\n    key: \"appendVertex\",\n    value: function appendVertex(vertex) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.insertVertex(vertex, -1, options);\n    }\n  }, {\n    key: \"getVertexAt\",\n    value: function getVertexAt(index) {\n      if (index != null && Number.isFinite(index)) {\n        var vertices = this.getVertices();\n        return vertices[index];\n      }\n\n      return null;\n    }\n  }, {\n    key: \"setVertexAt\",\n    value: function setVertexAt(index, vertice) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (index != null && Number.isFinite(index)) {\n        var vertices = this.getVertices();\n        vertices[index] = vertice;\n        this.setVertices(vertices, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removeVertexAt\",\n    value: function removeVertexAt(index) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var vertices = this.getVertices();\n      var idx = index != null && Number.isFinite(index) ? index : -1;\n      vertices.splice(idx, 1);\n      return this.setVertices(vertices, options);\n    }\n  }, {\n    key: \"onVertexsChanged\",\n    value: function onVertexsChanged(_ref2) {\n      var previous = _ref2.previous,\n          current = _ref2.current;\n      var added = previous && current ? current.filter(function (p1) {\n        if (!previous.find(function (p2) {\n          return Point.equals(p1, p2);\n        })) {\n          return p1;\n        }\n\n        return null;\n      }) : current ? _toConsumableArray(current) : [];\n      var removed = previous && current ? previous.filter(function (p1) {\n        if (!current.find(function (p2) {\n          return Point.equals(p1, p2);\n        })) {\n          return p1;\n        }\n\n        return null;\n      }) : previous ? _toConsumableArray(previous) : [];\n\n      if (added.length > 0) {\n        this.notify('vertexs:added', {\n          added: added,\n          cell: this,\n          edge: this\n        });\n      }\n\n      if (removed.length > 0) {\n        this.notify('vertexs:removed', {\n          removed: removed,\n          cell: this,\n          edge: this\n        });\n      }\n    } // #endregion\n    // #region markup\n\n  }, {\n    key: \"getDefaultMarkup\",\n    value: function getDefaultMarkup() {\n      return this.store.get('defaultMarkup') || Markup.getEdgeMarkup();\n    }\n  }, {\n    key: \"getMarkup\",\n    value: function getMarkup() {\n      return _get(_getPrototypeOf(Edge.prototype), \"getMarkup\", this).call(this) || this.getDefaultMarkup();\n    } // #endregion\n    // #region toolMarkup\n\n  }, {\n    key: \"toolMarkup\",\n    get: function get() {\n      return this.getToolMarkup();\n    }\n  }, {\n    key: \"toolMarkup\",\n    set: function set(markup) {\n      this.setToolMarkup(markup);\n    }\n  }, {\n    key: \"getDefaultToolMarkup\",\n    value: function getDefaultToolMarkup() {\n      return this.store.get('defaultToolMarkup') || Markup.getEdgeToolMarkup();\n    }\n  }, {\n    key: \"getToolMarkup\",\n    value: function getToolMarkup() {\n      return this.store.get('toolMarkup') || this.getDefaultToolMarkup();\n    }\n  }, {\n    key: \"setToolMarkup\",\n    value: function setToolMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('toolMarkup', markup, options);\n      return this;\n    }\n  }, {\n    key: \"doubleToolMarkup\",\n    get: function get() {\n      return this.getDoubleToolMarkup();\n    }\n  }, {\n    key: \"doubleToolMarkup\",\n    set: function set(markup) {\n      this.setDoubleToolMarkup(markup);\n    }\n  }, {\n    key: \"getDefaultDoubleToolMarkup\",\n    value: function getDefaultDoubleToolMarkup() {\n      return this.store.get('defaultDoubleToolMarkup');\n    }\n  }, {\n    key: \"getDoubleToolMarkup\",\n    value: function getDoubleToolMarkup() {\n      return this.store.get('doubleToolMarkup') || this.getDefaultDoubleToolMarkup();\n    }\n  }, {\n    key: \"setDoubleToolMarkup\",\n    value: function setDoubleToolMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('doubleToolMarkup', markup, options);\n      return this;\n    } // #endregion\n    // #region arrowheadMarkup\n\n  }, {\n    key: \"arrowheadMarkup\",\n    get: function get() {\n      return this.getArrowheadMarkup();\n    }\n  }, {\n    key: \"arrowheadMarkup\",\n    set: function set(markup) {\n      this.setArrowheadMarkup(markup);\n    }\n  }, {\n    key: \"getDefaultArrowheadMarkup\",\n    value: function getDefaultArrowheadMarkup() {\n      return this.store.get('defaultArrowheadMarkup') || Markup.getEdgeArrowheadMarkup();\n    }\n  }, {\n    key: \"getArrowheadMarkup\",\n    value: function getArrowheadMarkup() {\n      return this.store.get('arrowheadMarkup') || this.getDefaultArrowheadMarkup();\n    }\n  }, {\n    key: \"setArrowheadMarkup\",\n    value: function setArrowheadMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('arrowheadMarkup', markup, options);\n      return this;\n    } // #endregion\n    // #region transform\n\n    /**\n     * Translate the edge vertices (and source and target if they are points)\n     * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.\n     */\n\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      options.translateBy = options.translateBy || this.id;\n      options.tx = tx;\n      options.ty = ty;\n      return this.applyToPoints(function (p) {\n        return {\n          x: (p.x || 0) + tx,\n          y: (p.y || 0) + ty\n        };\n      }, options);\n    }\n    /**\n     * Scales the edge's points (vertices) relative to the given origin.\n     */\n\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      return this.applyToPoints(function (p) {\n        return Point.create(p).scale(sx, sy, origin).toJSON();\n      }, options);\n    }\n  }, {\n    key: \"applyToPoints\",\n    value: function applyToPoints(worker) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var attrs = {};\n      var source = this.getSource();\n      var target = this.getTarget();\n\n      if (Point.isPointLike(source)) {\n        attrs.source = worker(source);\n      }\n\n      if (Point.isPointLike(target)) {\n        attrs.target = worker(target);\n      }\n\n      var vertices = this.getVertices();\n\n      if (vertices.length > 0) {\n        attrs.vertices = vertices.map(worker);\n      }\n\n      this.store.set(attrs, options);\n      return this;\n    } // #endregion\n    // #region common\n\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      return this.getPolyline().bbox();\n    }\n  }, {\n    key: \"getConnectionPoint\",\n    value: function getConnectionPoint() {\n      return this.getPolyline().pointAt(0.5);\n    }\n  }, {\n    key: \"getPolyline\",\n    value: function getPolyline() {\n      var points = [this.getSourcePoint(), this.getTargetPoint()];\n      var vertices = this.getVertices();\n      vertices.forEach(function (p) {\n        return points.push(Point.create(p));\n      });\n      return new Polyline(points);\n    }\n  }, {\n    key: \"updateParent\",\n    value: function updateParent(options) {\n      var newParent = null;\n      var source = this.getSourceCell();\n      var target = this.getTargetCell();\n      var prevParent = this.getParent();\n\n      if (source && target) {\n        if (source === target || source.isDescendantOf(target)) {\n          newParent = target;\n        } else if (target.isDescendantOf(source)) {\n          newParent = source;\n        } else {\n          newParent = Cell.getCommonAncestor(source, target);\n        }\n      } // Unembeds the edge if source and target has no common\n      // ancestor or common ancestor changed\n\n\n      if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n        prevParent.unembed(this, options);\n      }\n\n      if (newParent) {\n        newParent.embed(this, options);\n      }\n\n      return newParent;\n    }\n  }, {\n    key: \"hasLoop\",\n    value: function hasLoop() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var source = this.getSource();\n      var target = this.getTarget();\n      var sourceId = source.cell;\n      var targetId = target.cell;\n\n      if (!sourceId || !targetId) {\n        return false;\n      }\n\n      var loop = sourceId === targetId; // Note that there in the deep mode a edge can have a loop,\n      // even if it connects only a parent and its embed.\n      // A loop \"target equals source\" is valid in both shallow and deep mode.\n      // eslint-disable-next-line\n\n      if (!loop && options.deep && this._model) {\n        var sourceCell = this.getSourceCell();\n        var targetCell = this.getTargetCell();\n\n        if (sourceCell && targetCell) {\n          loop = sourceCell.isAncestorOf(targetCell, options) || targetCell.isAncestorOf(sourceCell, options);\n        }\n      }\n\n      return loop;\n    }\n  }, {\n    key: \"getFragmentAncestor\",\n    value: function getFragmentAncestor() {\n      var cells = [this, this.getSourceNode(), this.getTargetNode()].filter(function (item) {\n        return item != null;\n      });\n      return this.getCommonAncestor.apply(this, _toConsumableArray(cells));\n    }\n  }, {\n    key: \"isFragmentDescendantOf\",\n    value: function isFragmentDescendantOf(cell) {\n      var ancestor = this.getFragmentAncestor();\n      return !!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell));\n    }\n  }]);\n\n  return Edge;\n}(Cell, Symbol.toStringTag);\nEdge.defaults = {};\n\n(function (Edge) {\n  function equalTerminals(a, b) {\n    var a1 = a;\n    var b1 = b;\n\n    if (a1.cell === b1.cell) {\n      return a1.port === b1.port || a1.port == null && b1.port == null;\n    }\n\n    return false;\n  }\n\n  Edge.equalTerminals = equalTerminals;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.defaultLabel = {\n    markup: [{\n      tagName: 'rect',\n      selector: 'body'\n    }, {\n      tagName: 'text',\n      selector: 'label'\n    }],\n    attrs: {\n      text: {\n        fill: '#000',\n        fontSize: 14,\n        textAnchor: 'middle',\n        textVerticalAnchor: 'middle',\n        pointerEvents: 'none'\n      },\n      rect: {\n        ref: 'label',\n        fill: '#fff',\n        rx: 3,\n        ry: 3,\n        refWidth: 1,\n        refHeight: 1,\n        refX: 0,\n        refY: 0\n      }\n    },\n    position: {\n      distance: 0.5\n    }\n  };\n\n  function parseStringLabel(text) {\n    return {\n      attrs: {\n        label: {\n          text: text\n        }\n      }\n    };\n  }\n\n  Edge.parseStringLabel = parseStringLabel;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.toStringTag = \"X6.\".concat(Edge.name);\n\n  function isEdge(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Edge) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var edge = instance;\n\n    if ((tag == null || tag === Edge.toStringTag) && typeof edge.isNode === 'function' && typeof edge.isEdge === 'function' && typeof edge.prop === 'function' && typeof edge.attr === 'function' && typeof edge.disconnect === 'function' && typeof edge.getSource === 'function' && typeof edge.getTarget === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Edge.isEdge = isEdge;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  Edge.registry = Registry.create({\n    type: 'edge',\n    process: function process(shape, options) {\n      if (ShareRegistry.exist(shape, false)) {\n        throw new Error(\"Edge with name '\".concat(shape, \"' was registered by anthor Node\"));\n      }\n\n      if (typeof options === 'function') {\n        options.config({\n          shape: shape\n        });\n        return options;\n      }\n\n      var parent = Edge; // default inherit from 'dege'\n\n      var _options$inherit = options.inherit,\n          inherit = _options$inherit === void 0 ? 'edge' : _options$inherit,\n          others = __rest(options, [\"inherit\"]);\n\n      if (typeof inherit === 'string') {\n        var base = this.get(inherit || 'edge');\n\n        if (base == null && inherit) {\n          this.onNotFound(inherit, 'inherited');\n        } else {\n          parent = base;\n        }\n      } else {\n        parent = inherit;\n      }\n\n      if (others.constructorName == null) {\n        others.constructorName = shape;\n      }\n\n      var ctor = parent.define.call(parent, others);\n      ctor.config({\n        shape: shape\n      });\n      return ctor;\n    }\n  });\n  ShareRegistry.setEdgeRegistry(Edge.registry);\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  var counter = 0;\n\n  function getClassName(name) {\n    if (name) {\n      return StringExt.pascalCase(name);\n    }\n\n    counter += 1;\n    return \"CustomEdge\".concat(counter);\n  }\n\n  function define(config) {\n    var constructorName = config.constructorName,\n        overwrite = config.overwrite,\n        others = __rest(config, [\"constructorName\", \"overwrite\"]);\n\n    var ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n    ctor.config(others);\n\n    if (others.shape) {\n      Edge.registry.register(others.shape, ctor, overwrite);\n    }\n\n    return ctor;\n  }\n\n  Edge.define = define;\n\n  function create(options) {\n    var shape = options.shape || 'edge';\n    var Ctor = Edge.registry.get(shape);\n\n    if (Ctor) {\n      return new Ctor(options);\n    }\n\n    return Edge.registry.onNotFound(shape);\n  }\n\n  Edge.create = create;\n})(Edge || (Edge = {}));\n\n(function (Edge) {\n  var shape = 'basic.edge';\n  Edge.config({\n    shape: shape,\n    propHooks: function propHooks(metadata) {\n      var label = metadata.label,\n          vertices = metadata.vertices,\n          others = __rest(metadata, [\"label\", \"vertices\"]);\n\n      if (label) {\n        if (others.labels == null) {\n          others.labels = [];\n        }\n\n        var formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;\n        others.labels.push(formated);\n      }\n\n      if (vertices) {\n        if (Array.isArray(vertices)) {\n          others.vertices = vertices.map(function (item) {\n            return Point.create(item).toJSON();\n          });\n        }\n      }\n\n      return others;\n    }\n  });\n  Edge.registry.register(shape, Edge);\n})(Edge || (Edge = {}));","map":{"version":3,"sources":["../../src/model/edge.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ObjectExt, StringExt } from '../util';\nimport { Point, Polyline } from '../geometry';\nimport { Registry, } from '../registry';\nimport { Markup } from '../view/markup';\nimport { ShareRegistry } from './registry';\nimport { Cell } from './cell';\nexport class Edge extends Cell {\n    constructor(metadata = {}) {\n        super(metadata);\n    }\n    get [Symbol.toStringTag]() {\n        return Edge.toStringTag;\n    }\n    preprocess(metadata, ignoreIdCheck) {\n        const { source, sourceCell, sourcePort, sourcePoint, target, targetCell, targetPort, targetPoint } = metadata, others = __rest(metadata, [\"source\", \"sourceCell\", \"sourcePort\", \"sourcePoint\", \"target\", \"targetCell\", \"targetPort\", \"targetPoint\"]);\n        const data = others;\n        const isValidId = (val) => typeof val === 'string' || typeof val === 'number';\n        if (source != null) {\n            if (Cell.isCell(source)) {\n                data.source = { cell: source.id };\n            }\n            else if (isValidId(source)) {\n                data.source = { cell: source };\n            }\n            else if (Point.isPoint(source)) {\n                data.source = source.toJSON();\n            }\n            else if (Array.isArray(source)) {\n                data.source = { x: source[0], y: source[1] };\n            }\n            else {\n                const cell = source.cell;\n                if (Cell.isCell(cell)) {\n                    data.source = Object.assign(Object.assign({}, source), { cell: cell.id });\n                }\n                else {\n                    data.source = source;\n                }\n            }\n        }\n        if (sourceCell != null || sourcePort != null) {\n            let terminal = data.source;\n            if (sourceCell != null) {\n                const id = isValidId(sourceCell) ? sourceCell : sourceCell.id;\n                if (terminal) {\n                    terminal.cell = id;\n                }\n                else {\n                    terminal = data.source = { cell: id };\n                }\n            }\n            if (sourcePort != null && terminal) {\n                terminal.port = sourcePort;\n            }\n        }\n        else if (sourcePoint != null) {\n            data.source = Point.create(sourcePoint).toJSON();\n        }\n        if (target != null) {\n            if (Cell.isCell(target)) {\n                data.target = { cell: target.id };\n            }\n            else if (isValidId(target)) {\n                data.target = { cell: target };\n            }\n            else if (Point.isPoint(target)) {\n                data.target = target.toJSON();\n            }\n            else if (Array.isArray(target)) {\n                data.target = { x: target[0], y: target[1] };\n            }\n            else {\n                const cell = target.cell;\n                if (Cell.isCell(cell)) {\n                    data.target = Object.assign(Object.assign({}, target), { cell: cell.id });\n                }\n                else {\n                    data.target = target;\n                }\n            }\n        }\n        if (targetCell != null || targetPort != null) {\n            let terminal = data.target;\n            if (targetCell != null) {\n                const id = isValidId(targetCell) ? targetCell : targetCell.id;\n                if (terminal) {\n                    terminal.cell = id;\n                }\n                else {\n                    terminal = data.target = { cell: id };\n                }\n            }\n            if (targetPort != null && terminal) {\n                terminal.port = targetPort;\n            }\n        }\n        else if (targetPoint != null) {\n            data.target = Point.create(targetPoint).toJSON();\n        }\n        return super.preprocess(data, ignoreIdCheck);\n    }\n    setup() {\n        super.setup();\n        this.on('change:labels', (args) => this.onLabelsChanged(args));\n        this.on('change:vertices', (args) => this.onVertexsChanged(args));\n    }\n    isEdge() {\n        return true;\n    }\n    // #region terminal\n    disconnect(options = {}) {\n        this.store.set({\n            source: { x: 0, y: 0 },\n            target: { x: 0, y: 0 },\n        }, options);\n        return this;\n    }\n    get source() {\n        return this.getSource();\n    }\n    set source(data) {\n        this.setSource(data);\n    }\n    getSource() {\n        return this.getTerminal('source');\n    }\n    getSourceCellId() {\n        return this.source.cell;\n    }\n    getSourcePortId() {\n        return this.source.port;\n    }\n    setSource(source, args, options = {}) {\n        return this.setTerminal('source', source, args, options);\n    }\n    get target() {\n        return this.getTarget();\n    }\n    set target(data) {\n        this.setTarget(data);\n    }\n    getTarget() {\n        return this.getTerminal('target');\n    }\n    getTargetCellId() {\n        return this.target.cell;\n    }\n    getTargetPortId() {\n        return this.target.port;\n    }\n    setTarget(target, args, options = {}) {\n        return this.setTerminal('target', target, args, options);\n    }\n    getTerminal(type) {\n        return Object.assign({}, this.store.get(type));\n    }\n    setTerminal(type, terminal, args, options = {}) {\n        // `terminal` is a cell\n        if (Cell.isCell(terminal)) {\n            this.store.set(type, ObjectExt.merge({}, args, { cell: terminal.id }), options);\n            return this;\n        }\n        // `terminal` is a point-like object\n        const p = terminal;\n        if (Point.isPoint(terminal) || (p.x != null && p.y != null)) {\n            this.store.set(type, ObjectExt.merge({}, args, { x: p.x, y: p.y }), options);\n            return this;\n        }\n        // `terminal` is an object\n        this.store.set(type, ObjectExt.cloneDeep(terminal), options);\n        return this;\n    }\n    getSourcePoint() {\n        return this.getTerminalPoint('source');\n    }\n    getTargetPoint() {\n        return this.getTerminalPoint('target');\n    }\n    getTerminalPoint(type) {\n        const terminal = this[type];\n        if (Point.isPointLike(terminal)) {\n            return Point.create(terminal);\n        }\n        const cell = this.getTerminalCell(type);\n        if (cell) {\n            return cell.getConnectionPoint(this, type);\n        }\n        return new Point();\n    }\n    getSourceCell() {\n        return this.getTerminalCell('source');\n    }\n    getTargetCell() {\n        return this.getTerminalCell('target');\n    }\n    getTerminalCell(type) {\n        if (this.model) {\n            const cellId = type === 'source' ? this.getSourceCellId() : this.getTargetCellId();\n            if (cellId) {\n                return this.model.getCell(cellId);\n            }\n        }\n        return null;\n    }\n    getSourceNode() {\n        return this.getTerminalNode('source');\n    }\n    getTargetNode() {\n        return this.getTerminalNode('target');\n    }\n    getTerminalNode(type) {\n        let cell = this; // eslint-disable-line\n        const visited = {};\n        while (cell && cell.isEdge()) {\n            if (visited[cell.id]) {\n                return null;\n            }\n            visited[cell.id] = true;\n            cell = cell.getTerminalCell(type);\n        }\n        return cell && cell.isNode() ? cell : null;\n    }\n    // #endregion\n    // #region router\n    get router() {\n        return this.getRouter();\n    }\n    set router(data) {\n        if (data == null) {\n            this.removeRouter();\n        }\n        else {\n            this.setRouter(data);\n        }\n    }\n    getRouter() {\n        return this.store.get('router');\n    }\n    setRouter(name, args, options) {\n        if (typeof name === 'object') {\n            this.store.set('router', name, args);\n        }\n        else {\n            this.store.set('router', { name, args }, options);\n        }\n        return this;\n    }\n    removeRouter(options = {}) {\n        this.store.remove('router', options);\n        return this;\n    }\n    // #endregion\n    // #region connector\n    get connector() {\n        return this.getConnector();\n    }\n    set connector(data) {\n        if (data == null) {\n            this.removeConnector();\n        }\n        else {\n            this.setConnector(data);\n        }\n    }\n    getConnector() {\n        return this.store.get('connector');\n    }\n    setConnector(name, args, options) {\n        if (typeof name === 'object') {\n            this.store.set('connector', name, args);\n        }\n        else {\n            this.store.set('connector', { name, args }, options);\n        }\n        return this;\n    }\n    removeConnector(options = {}) {\n        return this.store.remove('connector', options);\n    }\n    // #endregion\n    // #region strategy\n    get strategy() {\n        return this.getStrategy();\n    }\n    set strategy(data) {\n        if (data == null) {\n            this.removeStrategy();\n        }\n        else {\n            this.setStrategy(data);\n        }\n    }\n    getStrategy() {\n        return this.store.get('strategy');\n    }\n    setStrategy(name, args, options) {\n        if (typeof name === 'object') {\n            this.store.set('strategy', name, args);\n        }\n        else {\n            this.store.set('strategy', { name, args }, options);\n        }\n        return this;\n    }\n    removeStrategy(options = {}) {\n        return this.store.remove('strategy', options);\n    }\n    // #endregion\n    // #region labels\n    getDefaultLabel() {\n        const ctor = this.constructor;\n        const defaults = this.store.get('defaultLabel') || ctor.defaultLabel || {};\n        return ObjectExt.cloneDeep(defaults);\n    }\n    get labels() {\n        return this.getLabels();\n    }\n    set labels(labels) {\n        this.setLabels(labels);\n    }\n    getLabels() {\n        return [...this.store.get('labels', [])].map((item) => this.parseLabel(item));\n    }\n    setLabels(labels, options = {}) {\n        this.store.set('labels', Array.isArray(labels) ? labels : [labels], options);\n        return this;\n    }\n    insertLabel(label, index, options = {}) {\n        const labels = this.getLabels();\n        const len = labels.length;\n        let idx = index != null && Number.isFinite(index) ? index : len;\n        if (idx < 0) {\n            idx = len + idx + 1;\n        }\n        labels.splice(idx, 0, this.parseLabel(label));\n        return this.setLabels(labels, options);\n    }\n    appendLabel(label, options = {}) {\n        return this.insertLabel(label, -1, options);\n    }\n    getLabelAt(index) {\n        const labels = this.getLabels();\n        if (index != null && Number.isFinite(index)) {\n            return this.parseLabel(labels[index]);\n        }\n        return null;\n    }\n    setLabelAt(index, label, options = {}) {\n        if (index != null && Number.isFinite(index)) {\n            const labels = this.getLabels();\n            labels[index] = this.parseLabel(label);\n            this.setLabels(labels, options);\n        }\n        return this;\n    }\n    removeLabelAt(index, options = {}) {\n        const labels = this.getLabels();\n        const idx = index != null && Number.isFinite(index) ? index : -1;\n        const removed = labels.splice(idx, 1);\n        this.setLabels(labels, options);\n        return removed.length ? removed[0] : null;\n    }\n    parseLabel(label) {\n        if (typeof label === 'string') {\n            const ctor = this.constructor;\n            return ctor.parseStringLabel(label);\n        }\n        return label;\n    }\n    onLabelsChanged({ previous, current, }) {\n        const added = previous && current\n            ? current.filter((label1) => {\n                if (!previous.find((label2) => label1 === label2 || ObjectExt.isEqual(label1, label2))) {\n                    return label1;\n                }\n                return null;\n            })\n            : current\n                ? [...current]\n                : [];\n        const removed = previous && current\n            ? previous.filter((label1) => {\n                if (!current.find((label2) => label1 === label2 || ObjectExt.isEqual(label1, label2))) {\n                    return label1;\n                }\n                return null;\n            })\n            : previous\n                ? [...previous]\n                : [];\n        if (added.length > 0) {\n            this.notify('labels:added', { added, cell: this, edge: this });\n        }\n        if (removed.length > 0) {\n            this.notify('labels:removed', { removed, cell: this, edge: this });\n        }\n    }\n    // #endregion\n    // #region vertices\n    get vertexMarkup() {\n        return this.getVertexMarkup();\n    }\n    set vertexMarkup(markup) {\n        this.setVertexMarkup(markup);\n    }\n    getDefaultVertexMarkup() {\n        return this.store.get('defaultVertexMarkup') || Markup.getEdgeVertexMarkup();\n    }\n    getVertexMarkup() {\n        return this.store.get('vertexMarkup') || this.getDefaultVertexMarkup();\n    }\n    setVertexMarkup(markup, options = {}) {\n        this.store.set('vertexMarkup', Markup.clone(markup), options);\n        return this;\n    }\n    get vertices() {\n        return this.getVertices();\n    }\n    set vertices(vertices) {\n        this.setVertices(vertices);\n    }\n    getVertices() {\n        return [...this.store.get('vertices', [])];\n    }\n    setVertices(vertices, options = {}) {\n        const points = Array.isArray(vertices) ? vertices : [vertices];\n        this.store.set('vertices', points.map((p) => Point.toJSON(p)), options);\n        return this;\n    }\n    insertVertex(vertice, index, options = {}) {\n        const vertices = this.getVertices();\n        const len = vertices.length;\n        let idx = index != null && Number.isFinite(index) ? index : len;\n        if (idx < 0) {\n            idx = len + idx + 1;\n        }\n        vertices.splice(idx, 0, Point.toJSON(vertice));\n        return this.setVertices(vertices, options);\n    }\n    appendVertex(vertex, options = {}) {\n        return this.insertVertex(vertex, -1, options);\n    }\n    getVertexAt(index) {\n        if (index != null && Number.isFinite(index)) {\n            const vertices = this.getVertices();\n            return vertices[index];\n        }\n        return null;\n    }\n    setVertexAt(index, vertice, options = {}) {\n        if (index != null && Number.isFinite(index)) {\n            const vertices = this.getVertices();\n            vertices[index] = vertice;\n            this.setVertices(vertices, options);\n        }\n        return this;\n    }\n    removeVertexAt(index, options = {}) {\n        const vertices = this.getVertices();\n        const idx = index != null && Number.isFinite(index) ? index : -1;\n        vertices.splice(idx, 1);\n        return this.setVertices(vertices, options);\n    }\n    onVertexsChanged({ previous, current, }) {\n        const added = previous && current\n            ? current.filter((p1) => {\n                if (!previous.find((p2) => Point.equals(p1, p2))) {\n                    return p1;\n                }\n                return null;\n            })\n            : current\n                ? [...current]\n                : [];\n        const removed = previous && current\n            ? previous.filter((p1) => {\n                if (!current.find((p2) => Point.equals(p1, p2))) {\n                    return p1;\n                }\n                return null;\n            })\n            : previous\n                ? [...previous]\n                : [];\n        if (added.length > 0) {\n            this.notify('vertexs:added', { added, cell: this, edge: this });\n        }\n        if (removed.length > 0) {\n            this.notify('vertexs:removed', { removed, cell: this, edge: this });\n        }\n    }\n    // #endregion\n    // #region markup\n    getDefaultMarkup() {\n        return this.store.get('defaultMarkup') || Markup.getEdgeMarkup();\n    }\n    getMarkup() {\n        return super.getMarkup() || this.getDefaultMarkup();\n    }\n    // #endregion\n    // #region toolMarkup\n    get toolMarkup() {\n        return this.getToolMarkup();\n    }\n    set toolMarkup(markup) {\n        this.setToolMarkup(markup);\n    }\n    getDefaultToolMarkup() {\n        return this.store.get('defaultToolMarkup') || Markup.getEdgeToolMarkup();\n    }\n    getToolMarkup() {\n        return this.store.get('toolMarkup') || this.getDefaultToolMarkup();\n    }\n    setToolMarkup(markup, options = {}) {\n        this.store.set('toolMarkup', markup, options);\n        return this;\n    }\n    get doubleToolMarkup() {\n        return this.getDoubleToolMarkup();\n    }\n    set doubleToolMarkup(markup) {\n        this.setDoubleToolMarkup(markup);\n    }\n    getDefaultDoubleToolMarkup() {\n        return this.store.get('defaultDoubleToolMarkup');\n    }\n    getDoubleToolMarkup() {\n        return (this.store.get('doubleToolMarkup') || this.getDefaultDoubleToolMarkup());\n    }\n    setDoubleToolMarkup(markup, options = {}) {\n        this.store.set('doubleToolMarkup', markup, options);\n        return this;\n    }\n    // #endregion\n    // #region arrowheadMarkup\n    get arrowheadMarkup() {\n        return this.getArrowheadMarkup();\n    }\n    set arrowheadMarkup(markup) {\n        this.setArrowheadMarkup(markup);\n    }\n    getDefaultArrowheadMarkup() {\n        return (this.store.get('defaultArrowheadMarkup') ||\n            Markup.getEdgeArrowheadMarkup());\n    }\n    getArrowheadMarkup() {\n        return this.store.get('arrowheadMarkup') || this.getDefaultArrowheadMarkup();\n    }\n    setArrowheadMarkup(markup, options = {}) {\n        this.store.set('arrowheadMarkup', markup, options);\n        return this;\n    }\n    // #endregion\n    // #region transform\n    /**\n     * Translate the edge vertices (and source and target if they are points)\n     * by `tx` pixels in the x-axis and `ty` pixels in the y-axis.\n     */\n    translate(tx, ty, options = {}) {\n        options.translateBy = options.translateBy || this.id;\n        options.tx = tx;\n        options.ty = ty;\n        return this.applyToPoints((p) => ({\n            x: (p.x || 0) + tx,\n            y: (p.y || 0) + ty,\n        }), options);\n    }\n    /**\n     * Scales the edge's points (vertices) relative to the given origin.\n     */\n    scale(sx, sy, origin, options = {}) {\n        return this.applyToPoints((p) => {\n            return Point.create(p).scale(sx, sy, origin).toJSON();\n        }, options);\n    }\n    applyToPoints(worker, options = {}) {\n        const attrs = {};\n        const source = this.getSource();\n        const target = this.getTarget();\n        if (Point.isPointLike(source)) {\n            attrs.source = worker(source);\n        }\n        if (Point.isPointLike(target)) {\n            attrs.target = worker(target);\n        }\n        const vertices = this.getVertices();\n        if (vertices.length > 0) {\n            attrs.vertices = vertices.map(worker);\n        }\n        this.store.set(attrs, options);\n        return this;\n    }\n    // #endregion\n    // #region common\n    getBBox() {\n        return this.getPolyline().bbox();\n    }\n    getConnectionPoint() {\n        return this.getPolyline().pointAt(0.5);\n    }\n    getPolyline() {\n        const points = [this.getSourcePoint(), this.getTargetPoint()];\n        const vertices = this.getVertices();\n        vertices.forEach((p) => points.push(Point.create(p)));\n        return new Polyline(points);\n    }\n    updateParent(options) {\n        let newParent = null;\n        const source = this.getSourceCell();\n        const target = this.getTargetCell();\n        const prevParent = this.getParent();\n        if (source && target) {\n            if (source === target || source.isDescendantOf(target)) {\n                newParent = target;\n            }\n            else if (target.isDescendantOf(source)) {\n                newParent = source;\n            }\n            else {\n                newParent = Cell.getCommonAncestor(source, target);\n            }\n        }\n        // Unembeds the edge if source and target has no common\n        // ancestor or common ancestor changed\n        if (prevParent && (!newParent || newParent.id !== prevParent.id)) {\n            prevParent.unembed(this, options);\n        }\n        if (newParent) {\n            newParent.embed(this, options);\n        }\n        return newParent;\n    }\n    hasLoop(options = {}) {\n        const source = this.getSource();\n        const target = this.getTarget();\n        const sourceId = source.cell;\n        const targetId = target.cell;\n        if (!sourceId || !targetId) {\n            return false;\n        }\n        let loop = sourceId === targetId;\n        // Note that there in the deep mode a edge can have a loop,\n        // even if it connects only a parent and its embed.\n        // A loop \"target equals source\" is valid in both shallow and deep mode.\n        // eslint-disable-next-line\n        if (!loop && options.deep && this._model) {\n            const sourceCell = this.getSourceCell();\n            const targetCell = this.getTargetCell();\n            if (sourceCell && targetCell) {\n                loop =\n                    sourceCell.isAncestorOf(targetCell, options) ||\n                        targetCell.isAncestorOf(sourceCell, options);\n            }\n        }\n        return loop;\n    }\n    getFragmentAncestor() {\n        const cells = [this, this.getSourceNode(), this.getTargetNode()].filter((item) => item != null);\n        return this.getCommonAncestor(...cells);\n    }\n    isFragmentDescendantOf(cell) {\n        const ancestor = this.getFragmentAncestor();\n        return (!!ancestor && (ancestor.id === cell.id || ancestor.isDescendantOf(cell)));\n    }\n}\nEdge.defaults = {};\n(function (Edge) {\n    function equalTerminals(a, b) {\n        const a1 = a;\n        const b1 = b;\n        if (a1.cell === b1.cell) {\n            return a1.port === b1.port || (a1.port == null && b1.port == null);\n        }\n        return false;\n    }\n    Edge.equalTerminals = equalTerminals;\n})(Edge || (Edge = {}));\n(function (Edge) {\n    Edge.defaultLabel = {\n        markup: [\n            {\n                tagName: 'rect',\n                selector: 'body',\n            },\n            {\n                tagName: 'text',\n                selector: 'label',\n            },\n        ],\n        attrs: {\n            text: {\n                fill: '#000',\n                fontSize: 14,\n                textAnchor: 'middle',\n                textVerticalAnchor: 'middle',\n                pointerEvents: 'none',\n            },\n            rect: {\n                ref: 'label',\n                fill: '#fff',\n                rx: 3,\n                ry: 3,\n                refWidth: 1,\n                refHeight: 1,\n                refX: 0,\n                refY: 0,\n            },\n        },\n        position: {\n            distance: 0.5,\n        },\n    };\n    function parseStringLabel(text) {\n        return {\n            attrs: { label: { text } },\n        };\n    }\n    Edge.parseStringLabel = parseStringLabel;\n})(Edge || (Edge = {}));\n(function (Edge) {\n    Edge.toStringTag = `X6.${Edge.name}`;\n    function isEdge(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Edge) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const edge = instance;\n        if ((tag == null || tag === Edge.toStringTag) &&\n            typeof edge.isNode === 'function' &&\n            typeof edge.isEdge === 'function' &&\n            typeof edge.prop === 'function' &&\n            typeof edge.attr === 'function' &&\n            typeof edge.disconnect === 'function' &&\n            typeof edge.getSource === 'function' &&\n            typeof edge.getTarget === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Edge.isEdge = isEdge;\n})(Edge || (Edge = {}));\n(function (Edge) {\n    Edge.registry = Registry.create({\n        type: 'edge',\n        process(shape, options) {\n            if (ShareRegistry.exist(shape, false)) {\n                throw new Error(`Edge with name '${shape}' was registered by anthor Node`);\n            }\n            if (typeof options === 'function') {\n                options.config({ shape });\n                return options;\n            }\n            let parent = Edge;\n            // default inherit from 'dege'\n            const { inherit = 'edge' } = options, others = __rest(options, [\"inherit\"]);\n            if (typeof inherit === 'string') {\n                const base = this.get(inherit || 'edge');\n                if (base == null && inherit) {\n                    this.onNotFound(inherit, 'inherited');\n                }\n                else {\n                    parent = base;\n                }\n            }\n            else {\n                parent = inherit;\n            }\n            if (others.constructorName == null) {\n                others.constructorName = shape;\n            }\n            const ctor = parent.define.call(parent, others);\n            ctor.config({ shape });\n            return ctor;\n        },\n    });\n    ShareRegistry.setEdgeRegistry(Edge.registry);\n})(Edge || (Edge = {}));\n(function (Edge) {\n    let counter = 0;\n    function getClassName(name) {\n        if (name) {\n            return StringExt.pascalCase(name);\n        }\n        counter += 1;\n        return `CustomEdge${counter}`;\n    }\n    function define(config) {\n        const { constructorName, overwrite } = config, others = __rest(config, [\"constructorName\", \"overwrite\"]);\n        const ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n        ctor.config(others);\n        if (others.shape) {\n            Edge.registry.register(others.shape, ctor, overwrite);\n        }\n        return ctor;\n    }\n    Edge.define = define;\n    function create(options) {\n        const shape = options.shape || 'edge';\n        const Ctor = Edge.registry.get(shape);\n        if (Ctor) {\n            return new Ctor(options);\n        }\n        return Edge.registry.onNotFound(shape);\n    }\n    Edge.create = create;\n})(Edge || (Edge = {}));\n(function (Edge) {\n    const shape = 'basic.edge';\n    Edge.config({\n        shape,\n        propHooks(metadata) {\n            const { label, vertices } = metadata, others = __rest(metadata, [\"label\", \"vertices\"]);\n            if (label) {\n                if (others.labels == null) {\n                    others.labels = [];\n                }\n                const formated = typeof label === 'string' ? Edge.parseStringLabel(label) : label;\n                others.labels.push(formated);\n            }\n            if (vertices) {\n                if (Array.isArray(vertices)) {\n                    others.vertices = vertices.map((item) => Point.create(item).toJSON());\n                }\n            }\n            return others;\n        },\n    });\n    Edge.registry.register(shape, Edge);\n})(Edge || (Edge = {}));\n//# sourceMappingURL=edge.js.map"]},"metadata":{},"sourceType":"module"}