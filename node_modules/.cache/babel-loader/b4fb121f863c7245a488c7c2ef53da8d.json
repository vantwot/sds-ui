{"ast":null,"code":"/**\n * An implementation of the Priority Queue abstract data type.\n *\n * @see: http://en.wikipedia.org/wiki/Priority_queue\n *\n * It is like a normal stack or queue, but where each item has assigned a\n * priority (a number). Items with higher priority are served before items\n * with lower priority. This implementation uses binary heap as an internal\n * representation of the queue. The time complexity of all the methods is as\n * follows:\n *\n * - create: `O(n)`\n * - insert: `O(log n)`\n * - remove: `O(log n)`\n * - peek: `O(1)`\n * - isEmpty: `O(1)`\n * - peekPriority: `O(1)`\n */\nexport class PriorityQueue {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.comparator = options.comparator || PriorityQueue.defaultComparator;\n    this.index = {};\n    this.data = options.data || [];\n    this.heapify();\n  }\n  /**\n   * Returns `true` if the priority queue is empty, `false` otherwise.\n   */\n\n\n  isEmpty() {\n    return this.data.length === 0;\n  }\n  /**\n   * Inserts a value with priority to the queue. Optionally pass a unique\n   * id of this item. Passing unique IDs for each item you insert allows\n   * you to use the `updatePriority()` operation.\n   * @param priority\n   * @param value\n   * @param id\n   */\n\n\n  insert(priority, value, id) {\n    const item = {\n      priority,\n      value\n    };\n    const index = this.data.length - 1;\n\n    if (id) {\n      item.id = id;\n      this.index[id] = index;\n    }\n\n    this.data.push(item);\n    this.bubbleUp(index);\n    return this;\n  }\n  /**\n   * Returns the value of an item with the highest priority.\n   */\n\n\n  peek() {\n    return this.data[0] ? this.data[0].value : null;\n  }\n  /**\n   * Returns the highest priority in the queue.\n   */\n\n\n  peekPriority() {\n    return this.data[0] ? this.data[0].priority : null;\n  }\n\n  updatePriority(id, priority) {\n    const index = this.index[id];\n\n    if (typeof index === 'undefined') {\n      throw new Error(`Node with id '${id}' was not found in the heap.`);\n    }\n\n    const data = this.data;\n    const oldPriority = data[index].priority;\n    const comp = this.comparator(priority, oldPriority);\n\n    if (comp < 0) {\n      data[index].priority = priority;\n      this.bubbleUp(index);\n    } else if (comp > 0) {\n      data[index].priority = priority;\n      this.bubbleDown(index);\n    }\n  }\n  /**\n   * Removes the item with the highest priority from the queue\n   *\n   * @returns The value of the removed item.\n   */\n\n\n  remove() {\n    const data = this.data;\n    const peek = data[0];\n    const last = data.pop();\n    delete this.index[data.length];\n\n    if (data.length > 0) {\n      data[0] = last;\n\n      if (last.id) {\n        this.index[last.id] = 0;\n      }\n\n      this.bubbleDown(0);\n    }\n\n    return peek ? peek.value : null;\n  }\n\n  heapify() {\n    for (let i = 0; i < this.data.length; i += 1) {\n      this.bubbleUp(i);\n    }\n  }\n\n  bubbleUp(index) {\n    const data = this.data;\n    let tmp;\n    let parent;\n    let current = index;\n\n    while (current > 0) {\n      parent = current - 1 >>> 1;\n\n      if (this.comparator(data[current].priority, data[parent].priority) < 0) {\n        tmp = data[parent];\n        data[parent] = data[current];\n        let id = data[current].id;\n\n        if (id != null) {\n          this.index[id] = parent;\n        }\n\n        data[current] = tmp;\n        id = data[current].id;\n\n        if (id != null) {\n          this.index[id] = current;\n        }\n\n        current = parent;\n      } else {\n        break;\n      }\n    }\n  }\n\n  bubbleDown(index) {\n    const data = this.data;\n    const last = data.length - 1;\n    let current = index; // eslint-disable-next-line\n\n    while (true) {\n      const left = (current << 1) + 1;\n      const right = left + 1;\n      let minIndex = current;\n\n      if (left <= last && this.comparator(data[left].priority, data[minIndex].priority) < 0) {\n        minIndex = left;\n      }\n\n      if (right <= last && this.comparator(data[right].priority, data[minIndex].priority) < 0) {\n        minIndex = right;\n      }\n\n      if (minIndex !== current) {\n        const tmp = data[minIndex];\n        data[minIndex] = data[current];\n        let id = data[current].id;\n\n        if (id != null) {\n          this.index[id] = minIndex;\n        }\n\n        data[current] = tmp;\n        id = data[current].id;\n\n        if (id != null) {\n          this.index[id] = current;\n        }\n\n        current = minIndex;\n      } else {\n        break;\n      }\n    }\n  }\n\n}\n\n(function (PriorityQueue) {\n  PriorityQueue.defaultComparator = (a, b) => a - b;\n})(PriorityQueue || (PriorityQueue = {}));","map":{"version":3,"sources":["../../../src/common/algorithm/priorityqueue.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * An implementation of the Priority Queue abstract data type.\n *\n * @see: http://en.wikipedia.org/wiki/Priority_queue\n *\n * It is like a normal stack or queue, but where each item has assigned a\n * priority (a number). Items with higher priority are served before items\n * with lower priority. This implementation uses binary heap as an internal\n * representation of the queue. The time complexity of all the methods is as\n * follows:\n *\n * - create: `O(n)`\n * - insert: `O(log n)`\n * - remove: `O(log n)`\n * - peek: `O(1)`\n * - isEmpty: `O(1)`\n * - peekPriority: `O(1)`\n */\nexport class PriorityQueue {\n    constructor(options = {}) {\n        this.comparator = options.comparator || PriorityQueue.defaultComparator;\n        this.index = {};\n        this.data = options.data || [];\n        this.heapify();\n    }\n    /**\n     * Returns `true` if the priority queue is empty, `false` otherwise.\n     */\n    isEmpty() {\n        return this.data.length === 0;\n    }\n    /**\n     * Inserts a value with priority to the queue. Optionally pass a unique\n     * id of this item. Passing unique IDs for each item you insert allows\n     * you to use the `updatePriority()` operation.\n     * @param priority\n     * @param value\n     * @param id\n     */\n    insert(priority, value, id) {\n        const item = { priority, value };\n        const index = this.data.length - 1;\n        if (id) {\n            item.id = id;\n            this.index[id] = index;\n        }\n        this.data.push(item);\n        this.bubbleUp(index);\n        return this;\n    }\n    /**\n     * Returns the value of an item with the highest priority.\n     */\n    peek() {\n        return this.data[0] ? this.data[0].value : null;\n    }\n    /**\n     * Returns the highest priority in the queue.\n     */\n    peekPriority() {\n        return this.data[0] ? this.data[0].priority : null;\n    }\n    updatePriority(id, priority) {\n        const index = this.index[id];\n        if (typeof index === 'undefined') {\n            throw new Error(`Node with id '${id}' was not found in the heap.`);\n        }\n        const data = this.data;\n        const oldPriority = data[index].priority;\n        const comp = this.comparator(priority, oldPriority);\n        if (comp < 0) {\n            data[index].priority = priority;\n            this.bubbleUp(index);\n        }\n        else if (comp > 0) {\n            data[index].priority = priority;\n            this.bubbleDown(index);\n        }\n    }\n    /**\n     * Removes the item with the highest priority from the queue\n     *\n     * @returns The value of the removed item.\n     */\n    remove() {\n        const data = this.data;\n        const peek = data[0];\n        const last = data.pop();\n        delete this.index[data.length];\n        if (data.length > 0) {\n            data[0] = last;\n            if (last.id) {\n                this.index[last.id] = 0;\n            }\n            this.bubbleDown(0);\n        }\n        return peek ? peek.value : null;\n    }\n    heapify() {\n        for (let i = 0; i < this.data.length; i += 1) {\n            this.bubbleUp(i);\n        }\n    }\n    bubbleUp(index) {\n        const data = this.data;\n        let tmp;\n        let parent;\n        let current = index;\n        while (current > 0) {\n            parent = (current - 1) >>> 1;\n            if (this.comparator(data[current].priority, data[parent].priority) < 0) {\n                tmp = data[parent];\n                data[parent] = data[current];\n                let id = data[current].id;\n                if (id != null) {\n                    this.index[id] = parent;\n                }\n                data[current] = tmp;\n                id = data[current].id;\n                if (id != null) {\n                    this.index[id] = current;\n                }\n                current = parent;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    bubbleDown(index) {\n        const data = this.data;\n        const last = data.length - 1;\n        let current = index;\n        // eslint-disable-next-line\n        while (true) {\n            const left = (current << 1) + 1;\n            const right = left + 1;\n            let minIndex = current;\n            if (left <= last &&\n                this.comparator(data[left].priority, data[minIndex].priority) < 0) {\n                minIndex = left;\n            }\n            if (right <= last &&\n                this.comparator(data[right].priority, data[minIndex].priority) < 0) {\n                minIndex = right;\n            }\n            if (minIndex !== current) {\n                const tmp = data[minIndex];\n                data[minIndex] = data[current];\n                let id = data[current].id;\n                if (id != null) {\n                    this.index[id] = minIndex;\n                }\n                data[current] = tmp;\n                id = data[current].id;\n                if (id != null) {\n                    this.index[id] = current;\n                }\n                current = minIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n}\n(function (PriorityQueue) {\n    PriorityQueue.defaultComparator = (a, b) => a - b;\n})(PriorityQueue || (PriorityQueue = {}));\n//# sourceMappingURL=priorityqueue.js.map"]},"metadata":{},"sourceType":"module"}