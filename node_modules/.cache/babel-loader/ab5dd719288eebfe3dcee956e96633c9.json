{"ast":null,"code":"import { mat3, vec3, ext, vec2 } from '@antv/matrix-util';\nimport { isArray, each } from '@antv/util';\nvar transform = ext.transform;\n/**\n * 对比对象，用于对象数组排序\n * @param   {string}       attributeName  排序依据的字段名称\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\n\nexport var compare = function compare(attributeName) {\n  return function (m, n) {\n    return m[attributeName] - n[attributeName];\n  };\n};\n/**\n * 是否在区间内\n * @param   {number}       value  值\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\n\nvar isBetween = function isBetween(value, min, max) {\n  return value >= min && value <= max;\n};\n/**\n * 获取两条线段的交点\n * @param  {Point}  p0 第一条线段起点\n * @param  {Point}  p1 第一条线段终点\n * @param  {Point}  p2 第二条线段起点\n * @param  {Point}  p3 第二条线段终点\n * @return {Point}  交点\n */\n\n\nexport var getLineIntersect = function getLineIntersect(p0, p1, p2, p3) {\n  var tolerance = 0.0001;\n  var E = {\n    x: p2.x - p0.x,\n    y: p2.y - p0.y\n  };\n  var D0 = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n  var D1 = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y\n  };\n  var kross = D0.x * D1.y - D0.y * D1.x;\n  var sqrKross = kross * kross;\n  var invertKross = 1 / kross;\n  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;\n  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;\n\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\n    var s = (E.x * D1.y - E.y * D1.x) * invertKross;\n    var t = (E.x * D0.y - E.y * D0.x) * invertKross;\n    if (!isBetween(s, 0, 1) || !isBetween(t, 0, 1)) return null;\n    return {\n      x: p0.x + s * D0.x,\n      y: p0.y + s * D0.y\n    };\n  }\n\n  return null;\n};\n/**\n * point and rectangular intersection point\n * @param  {IRect} rect  rect\n * @param  {Point} point point\n * @return {PointPoint} rst;\n */\n\nexport var getRectIntersectByPoint = function getRectIntersectByPoint(rect, point) {\n  var x = rect.x,\n      y = rect.y,\n      width = rect.width,\n      height = rect.height;\n  var cx = x + width / 2;\n  var cy = y + height / 2;\n  var points = [];\n  var center = {\n    x: cx,\n    y: cy\n  };\n  points.push({\n    x: x,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y\n  });\n  var rst = null;\n\n  for (var i = 1; i < points.length; i++) {\n    rst = getLineIntersect(points[i - 1], points[i], center, point);\n\n    if (rst) {\n      break;\n    }\n  }\n\n  return rst;\n};\n/**\n * get point and circle inIntersect\n * @param {ICircle} circle 圆点，x,y,r\n * @param {Point} point 点 x,y\n * @return {Point} applied point\n */\n\nexport var getCircleIntersectByPoint = function getCircleIntersectByPoint(circle, point) {\n  var cx = circle.x,\n      cy = circle.y,\n      r = circle.r;\n  var x = point.x,\n      y = point.y;\n  var dx = x - cx;\n  var dy = y - cy;\n\n  if (dx * dx + dy * dy < r * r) {\n    return null;\n  }\n\n  var angle = Math.atan(dy / dx);\n  return {\n    x: cx + Math.abs(r * Math.cos(angle)) * Math.sign(dx),\n    y: cy + Math.abs(r * Math.sin(angle)) * Math.sign(dy)\n  };\n};\n/**\n * get point and ellipse inIntersect\n * @param {Object} ellipse 椭圆 x,y,rx,ry\n * @param {Object} point 点 x,y\n * @return {object} applied point\n */\n\nexport var getEllipseIntersectByPoint = function getEllipseIntersectByPoint(ellipse, point) {\n  var a = ellipse.rx;\n  var b = ellipse.ry;\n  var cx = ellipse.x;\n  var cy = ellipse.y;\n  var dx = point.x - cx;\n  var dy = point.y - cy; // 直接通过 x,y 求夹角，求出来的范围是 -PI, PI\n\n  var angle = Math.atan2(dy / b, dx / a);\n\n  if (angle < 0) {\n    angle += 2 * Math.PI; // 转换到 0，2PI\n  }\n\n  return {\n    x: cx + a * Math.cos(angle),\n    y: cy + b * Math.sin(angle)\n  };\n};\n/**\n * coordinate matrix transformation\n * @param  {number} point   coordinate\n * @param  {Matrix} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {Point} transformed point\n */\n\nexport var applyMatrix = function applyMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  var vector = [point.x, point.y, tag];\n\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  vec3.transformMat3(vector, vector, matrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n * coordinate matrix invert transformation\n * @param  {number} point   coordinate\n * @param  {number} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {object} transformed point\n */\n\nexport var invertMatrix = function invertMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var inversedMatrix = mat3.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], matrix);\n\n  if (!inversedMatrix) {\n    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var vector = [point.x, point.y, tag];\n  vec3.transformMat3(vector, vector, inversedMatrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n *\n * @param p1 First coordinate\n * @param p2 second coordinate\n * @param p3 three coordinate\n */\n\nexport var getCircleCenterByPoints = function getCircleCenterByPoints(p1, p2, p3) {\n  var a = p1.x - p2.x;\n  var b = p1.y - p2.y;\n  var c = p1.x - p3.x;\n  var d = p1.y - p3.y;\n  var e = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;\n  var f = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;\n  var denominator = b * c - a * d;\n  return {\n    x: -(d * e - b * f) / denominator,\n    y: -(a * f - c * e) / denominator\n  };\n};\n/**\n * get distance by two points\n * @param p1 first point\n * @param p2 second point\n */\n\nexport var distance = function distance(p1, p2) {\n  var vx = p1.x - p2.x;\n  var vy = p1.y - p2.y;\n  return Math.sqrt(vx * vx + vy * vy);\n};\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\n\nexport var scaleMatrix = function scaleMatrix(matrix, ratio) {\n  var result = [];\n  matrix.forEach(function (row) {\n    var newRow = [];\n    row.forEach(function (v) {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\n * Floyd Warshall algorithm for shortest path distances matrix\n * @param  {array} adjMatrix   adjacency matrix\n * @return {array} distances   shortest path distances matrix\n */\n\nexport var floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (var k = 0; k < size; k += 1) {\n    for (var i = 0; i < size; i += 1) {\n      for (var j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\n/**\n * get adjacency matrix\n * @param data graph data\n * @param directed whether it's a directed graph\n */\n\nexport var getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n      edges = data.edges;\n  var matrix = []; // map node with index in data.nodes\n\n  var nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(function (e) {\n      var source = e.source,\n          target = e.target;\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};\n/**\n * 平移group\n * @param group Group 实例\n * @param vec 移动向量\n */\n\nexport var translate = function translate(group, vec) {\n  group.translate(vec.x, vec.y);\n};\n/**\n * 移动到指定坐标点\n * @param group Group 实例\n * @param point 移动到的坐标点\n */\n\nexport var move = function move(group, point, animate, animateCfg) {\n  if (animateCfg === void 0) {\n    animateCfg = {\n      duration: 500\n    };\n  }\n\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var bbox = group.getCanvasBBox();\n  var vx = point.x - bbox.minX;\n  var vy = point.y - bbox.minY;\n\n  if (animate) {\n    var dx_1 = vx * matrix[0];\n    var dy_1 = vy * matrix[4];\n    var lastX_1 = 0;\n    var lastY_1 = 0;\n    var newX_1 = 0;\n    var newY_1 = 0;\n    group.animate(function (ratio) {\n      newX_1 = dx_1 * ratio;\n      newY_1 = dy_1 * ratio;\n      matrix = transform(matrix, [['t', newX_1 - lastX_1, newY_1 - lastY_1]]);\n      lastX_1 = newX_1;\n      lastY_1 = newY_1;\n      return {\n        matrix: matrix\n      };\n    }, animateCfg);\n  } else {\n    var movedMatrix = transform(matrix, [['t', vx, vy]]);\n    group.setMatrix(movedMatrix);\n  }\n};\n/**\n * 缩放 group\n * @param group Group 实例\n * @param point 在x 和 y 方向上的缩放比例\n */\n\nexport var scale = function scale(group, ratio) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var scaleXY = ratio;\n\n  if (!isArray(ratio)) {\n    scaleXY = [ratio, ratio];\n  }\n\n  if (isArray(ratio) && ratio.length === 1) {\n    scaleXY = [ratio[0], ratio[0]];\n  }\n\n  matrix = transform(matrix, [['s', scaleXY[0], scaleXY[1]]]);\n  group.setMatrix(matrix);\n};\n/**\n *\n * @param group Group 实例\n * @param ratio 选择角度\n */\n\nexport var rotate = function rotate(group, angle) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  matrix = transform(matrix, [['r', angle]]);\n  group.setMatrix(matrix);\n};\nexport var getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n\n  for (var i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  edges.forEach(function (e) {\n    if (e.source) {\n      degrees[nodeIdxMap[e.source]] += 1;\n    }\n\n    if (e.target) {\n      degrees[nodeIdxMap[e.target]] += 1;\n    }\n  });\n  return degrees;\n}; // 判断点Q是否在p1和p2的线段上\n\nfunction onSegment(p1, p2, q) {\n  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * 判断点P在多边形内-射线法. Borrow from https://github.com/antvis/util/blob/master/packages/path-util/src/point-in-polygon.ts\n * @param points\n * @param x\n * @param y\n */\n\n\nexport var isPointInPolygon = function isPointInPolygon(points, x, y) {\n  var isHit = false;\n  var n = points.length; // 判断两个double在eps精度下的大小关系\n\n  var tolerance = 1e-6;\n\n  function dcmp(xValue) {\n    if (Math.abs(xValue) < tolerance) {\n      return 0;\n    }\n\n    return xValue < 0 ? -1 : 1;\n  }\n\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n\n  for (var i = 0; i < n; i++) {\n    var p1 = points[i];\n    var p2 = points[(i + 1) % n];\n\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    } // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n\n\n    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {\n      isHit = !isHit;\n    }\n  }\n\n  return isHit;\n}; // 判断两个BBox是否相交\n\nexport var intersectBBox = function intersectBBox(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n};\n\nvar lineIntersectPolygon = function lineIntersectPolygon(lines, line) {\n  var isIntersect = false;\n  each(lines, function (l) {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n/**\n * 判断两个polygon是否相交。\n * borrow from @antv/path-util\n * @param points1 polygon1的顶点数组\n * @param points2 polygon2的顶点数组\n */\n\n\nexport var isPolygonsIntersect = function isPolygonsIntersect(points1, points2) {\n  var getBBox = function getBBox(points) {\n    var xArr = points.map(function (p) {\n      return p[0];\n    });\n    var yArr = points.map(function (p) {\n      return p[1];\n    });\n    return {\n      minX: Math.min.apply(null, xArr),\n      maxX: Math.max.apply(null, xArr),\n      minY: Math.min.apply(null, yArr),\n      maxY: Math.max.apply(null, yArr)\n    };\n  };\n\n  var parseToLines = function parseToLines(points) {\n    var lines = [];\n    var count = points.length;\n\n    for (var i = 0; i < count - 1; i++) {\n      var point = points[i];\n      var next = points[i + 1];\n      lines.push({\n        from: {\n          x: point[0],\n          y: point[1]\n        },\n        to: {\n          x: next[0],\n          y: next[1]\n        }\n      });\n    }\n\n    if (lines.length > 1) {\n      var first = points[0];\n      var last = points[count - 1];\n      lines.push({\n        from: {\n          x: last[0],\n          y: last[1]\n        },\n        to: {\n          x: first[0],\n          y: first[1]\n        }\n      });\n    }\n\n    return lines;\n  }; // 空数组，或者一个点返回 false\n\n\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n\n  var bbox1 = getBBox(points1);\n  var bbox2 = getBBox(points2); // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n\n  var isIn = false; // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n\n  each(points2, function (point) {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  each(points1, function (point) {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  var lines1 = parseToLines(points1);\n  var lines2 = parseToLines(points2);\n  var isIntersect = false;\n  each(lines2, function (line) {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n\nvar Line =\n/** @class */\nfunction () {\n  function Line(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  Line.prototype.getBBox = function () {\n    var minX = Math.min(this.x1, this.x2);\n    var minY = Math.min(this.y1, this.y2);\n    var maxX = Math.max(this.x1, this.x2);\n    var maxY = Math.max(this.y1, this.y2);\n    var res = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return res;\n  };\n\n  return Line;\n}();\n\nexport { Line };\nexport var getBBoxBoundLine = function getBBoxBoundLine(bbox, direction) {\n  var bounds = {\n    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],\n    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],\n    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],\n    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]\n  };\n  return bounds[direction];\n};\n/**\n * 计算两条线段相交时，相交点对第一条线段上的分割比例\n */\n\nvar fractionAlongLineA = function fractionAlongLineA(la, lb) {\n  var uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  var ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  var uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n\n  if (uB) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return ua;\n    }\n  }\n\n  return Number.POSITIVE_INFINITY;\n};\n\nexport var itemIntersectByLine = function itemIntersectByLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var countIntersections = 0;\n  var intersections = [];\n\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    intersections[i] = getLineIntersect({\n      x: line.x1,\n      y: line.y1\n    }, {\n      x: line.x2,\n      y: line.y2\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x2,\n      y: y2\n    });\n\n    if (intersections[i]) {\n      countIntersections += 1;\n    }\n  }\n\n  return [intersections, countIntersections];\n};\nexport var fractionToLine = function fractionToLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var minDistance = Number.POSITIVE_INFINITY;\n  var countIntersections = 0;\n\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x2, y2));\n    testDistance = Math.abs(testDistance - 0.5);\n\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections += 1;\n      minDistance = testDistance < minDistance ? testDistance : minDistance;\n    }\n  }\n\n  if (countIntersections === 0) return -1;\n  return minDistance;\n};\nexport var getPointsCenter = function getPointsCenter(points) {\n  var centerX = 0;\n  var centerY = 0;\n\n  if (points.length > 0) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var point = points_1[_i];\n      centerX += point.x;\n      centerY += point.y;\n    }\n\n    centerX /= points.length;\n    centerY /= points.length;\n  }\n\n  return {\n    x: centerX,\n    y: centerY\n  };\n};\nexport var squareDist = function squareDist(a, b) {\n  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\n};\nexport var pointLineSquareDist = function pointLineSquareDist(point, line) {\n  var x1 = line.x1;\n  var y1 = line.y1;\n  var x2 = line.x2 - x1;\n  var y2 = line.y2 - y1;\n  var px = point.x - x1;\n  var py = point.y - y1;\n  var dotprod = px * x2 + py * y2;\n  var projlenSq;\n\n  if (dotprod <= 0) {\n    projlenSq = 0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n\n    if (dotprod <= 0) {\n      projlenSq = 0;\n    } else {\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n    }\n  }\n\n  var lenSq = px * px + py * py - projlenSq;\n\n  if (lenSq < 0) {\n    lenSq = 0;\n  }\n\n  return lenSq;\n};\nexport var isPointsOverlap = function isPointsOverlap(p1, p2, e) {\n  if (e === void 0) {\n    e = 1e-3;\n  }\n\n  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e, 2);\n};\n/**\n * 点到矩形的距离的平方：矩形内部点视作距离为0，外部的点若投影落在矩形边上则为点到矩形边的最近的垂直距离，否则为点到矩形顶点的距离，\n * @param point IPoint\n * @param rect IRect\n */\n\nexport var pointRectSquareDist = function pointRectSquareDist(point, rect) {\n  var isLeft = point.x < rect.x;\n  var isRight = point.x > rect.x + rect.width;\n  var isTop = point.y > rect.y + rect.height;\n  var isBottom = point.y < rect.y;\n  var isPointOutside = isLeft || isRight || isTop || isBottom;\n\n  if (!isPointOutside) {\n    return 0;\n  }\n\n  if (isTop && !isLeft && !isRight) {\n    return Math.pow(rect.y + rect.height - point.y, 2);\n  }\n\n  if (isBottom && !isLeft && !isRight) {\n    return Math.pow(point.y - rect.y, 2);\n  }\n\n  if (isLeft && !isTop && !isBottom) {\n    return Math.pow(rect.x - point.x, 2);\n  }\n\n  if (isRight && !isTop && !isBottom) {\n    return Math.pow(rect.x + rect.width - point.x, 2);\n  }\n\n  var dx = Math.min(Math.abs(rect.x - point.x), Math.abs(rect.x + rect.width - point.x));\n  var dy = Math.min(Math.abs(rect.y - point.y), Math.abs(rect.y + rect.height - point.y));\n  return dx * dx + dy * dy;\n};\n/**\n * point to line distance\n * @param  {array} line 线的四个顶点 [x1, y1, x2, y2]\n * @param  {object} point 坐标点 {x, y}\n * @return {Number|NaN} distance\n */\n\nexport var pointLineDistance = function pointLineDistance(line, point) {\n  var x1 = line[0],\n      y1 = line[1],\n      x2 = line[2],\n      y2 = line[3];\n  var x = point.x,\n      y = point.y;\n  var d = [x2 - x1, y2 - y1];\n\n  if (vec2.exactEquals(d, [0, 0])) {\n    return NaN;\n  }\n\n  var u = [-d[1], d[0]]; // @ts-ignore\n\n  vec2.normalize(u, u);\n  var a = [x - x1, y - y1]; // @ts-ignore\n\n  return Math.abs(vec2.dot(a, u));\n};\n/**\n * Linearly interpolate between start and end, where alpha is the percent distance along the line.\n * alpha = 0 will be start, and alpha = 1 will be end.\n * @param {Number} start\n * @param {Number} end\n * @param {Number} alpha interpolation factor, typically in the closed interval [0, 1]\n * @returns\n */\n\nexport var lerp = function lerp(start, end, alpha) {\n  return start + (end - start) * alpha;\n};","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/@antv/g6-core/es/util/math.js"],"names":["mat3","vec3","ext","vec2","isArray","each","transform","compare","attributeName","m","n","isBetween","value","min","max","getLineIntersect","p0","p1","p2","p3","tolerance","E","x","y","D0","D1","kross","sqrKross","invertKross","sqrLen0","sqrLen1","s","t","getRectIntersectByPoint","rect","point","width","height","cx","cy","points","center","push","rst","i","length","getCircleIntersectByPoint","circle","r","dx","dy","angle","Math","atan","abs","cos","sign","sin","getEllipseIntersectByPoint","ellipse","a","rx","b","ry","atan2","PI","applyMatrix","matrix","tag","vector","isNaN","transformMat3","invertMatrix","inversedMatrix","invert","getCircleCenterByPoints","c","d","e","f","denominator","distance","vx","vy","sqrt","scaleMatrix","ratio","result","forEach","row","newRow","v","floydWarshall","adjMatrix","dist","size","j","Infinity","k","getAdjMatrix","data","directed","nodes","edges","nodeMap","Error","node","id","source","target","sIndex","tIndex","translate","group","vec","move","animate","animateCfg","duration","getMatrix","bbox","getCanvasBBox","minX","minY","dx_1","dy_1","lastX_1","lastY_1","newX_1","newY_1","movedMatrix","setMatrix","scale","scaleXY","rotate","getDegree","nodeIdxMap","degrees","onSegment","q","isPointInPolygon","isHit","dcmp","xValue","intersectBBox","box1","box2","maxX","maxY","lineIntersectPolygon","lines","line","isIntersect","l","from","to","isPolygonsIntersect","points1","points2","getBBox","xArr","map","p","yArr","apply","parseToLines","count","next","first","last","bbox1","bbox2","isIn","lines1","lines2","Line","x1","y1","x2","y2","prototype","res","getBBoxBoundLine","direction","bounds","top","left","bottom","right","fractionAlongLineA","la","lb","uaT","ubT","uB","ua","ub","Number","POSITIVE_INFINITY","itemIntersectByLine","item","directions","countIntersections","intersections","_a","fractionToLine","minDistance","testDistance","getPointsCenter","centerX","centerY","_i","points_1","squareDist","pow","pointLineSquareDist","px","py","dotprod","projlenSq","lenSq","isPointsOverlap","pointRectSquareDist","isLeft","isRight","isTop","isBottom","isPointOutside","pointLineDistance","exactEquals","NaN","u","normalize","dot","lerp","start","end","alpha"],"mappings":"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","sourcesContent":["import { mat3, vec3, ext, vec2 } from '@antv/matrix-util';\nimport { isArray, each } from '@antv/util';\nvar transform = ext.transform;\n/**\n * 对比对象，用于对象数组排序\n * @param   {string}       attributeName  排序依据的字段名称\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\n\nexport var compare = function compare(attributeName) {\n  return function (m, n) {\n    return m[attributeName] - n[attributeName];\n  };\n};\n/**\n * 是否在区间内\n * @param   {number}       value  值\n * @param   {number}       min    最小值\n * @param   {number}       max    最大值\n * @return  {boolean}      bool   布尔\n */\n\nvar isBetween = function isBetween(value, min, max) {\n  return value >= min && value <= max;\n};\n/**\n * 获取两条线段的交点\n * @param  {Point}  p0 第一条线段起点\n * @param  {Point}  p1 第一条线段终点\n * @param  {Point}  p2 第二条线段起点\n * @param  {Point}  p3 第二条线段终点\n * @return {Point}  交点\n */\n\n\nexport var getLineIntersect = function getLineIntersect(p0, p1, p2, p3) {\n  var tolerance = 0.0001;\n  var E = {\n    x: p2.x - p0.x,\n    y: p2.y - p0.y\n  };\n  var D0 = {\n    x: p1.x - p0.x,\n    y: p1.y - p0.y\n  };\n  var D1 = {\n    x: p3.x - p2.x,\n    y: p3.y - p2.y\n  };\n  var kross = D0.x * D1.y - D0.y * D1.x;\n  var sqrKross = kross * kross;\n  var invertKross = 1 / kross;\n  var sqrLen0 = D0.x * D0.x + D0.y * D0.y;\n  var sqrLen1 = D1.x * D1.x + D1.y * D1.y;\n\n  if (sqrKross > tolerance * sqrLen0 * sqrLen1) {\n    var s = (E.x * D1.y - E.y * D1.x) * invertKross;\n    var t = (E.x * D0.y - E.y * D0.x) * invertKross;\n    if (!isBetween(s, 0, 1) || !isBetween(t, 0, 1)) return null;\n    return {\n      x: p0.x + s * D0.x,\n      y: p0.y + s * D0.y\n    };\n  }\n\n  return null;\n};\n/**\n * point and rectangular intersection point\n * @param  {IRect} rect  rect\n * @param  {Point} point point\n * @return {PointPoint} rst;\n */\n\nexport var getRectIntersectByPoint = function getRectIntersectByPoint(rect, point) {\n  var x = rect.x,\n      y = rect.y,\n      width = rect.width,\n      height = rect.height;\n  var cx = x + width / 2;\n  var cy = y + height / 2;\n  var points = [];\n  var center = {\n    x: cx,\n    y: cy\n  };\n  points.push({\n    x: x,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y\n  });\n  points.push({\n    x: x + width,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y + height\n  });\n  points.push({\n    x: x,\n    y: y\n  });\n  var rst = null;\n\n  for (var i = 1; i < points.length; i++) {\n    rst = getLineIntersect(points[i - 1], points[i], center, point);\n\n    if (rst) {\n      break;\n    }\n  }\n\n  return rst;\n};\n/**\n * get point and circle inIntersect\n * @param {ICircle} circle 圆点，x,y,r\n * @param {Point} point 点 x,y\n * @return {Point} applied point\n */\n\nexport var getCircleIntersectByPoint = function getCircleIntersectByPoint(circle, point) {\n  var cx = circle.x,\n      cy = circle.y,\n      r = circle.r;\n  var x = point.x,\n      y = point.y;\n  var dx = x - cx;\n  var dy = y - cy;\n\n  if (dx * dx + dy * dy < r * r) {\n    return null;\n  }\n\n  var angle = Math.atan(dy / dx);\n  return {\n    x: cx + Math.abs(r * Math.cos(angle)) * Math.sign(dx),\n    y: cy + Math.abs(r * Math.sin(angle)) * Math.sign(dy)\n  };\n};\n/**\n * get point and ellipse inIntersect\n * @param {Object} ellipse 椭圆 x,y,rx,ry\n * @param {Object} point 点 x,y\n * @return {object} applied point\n */\n\nexport var getEllipseIntersectByPoint = function getEllipseIntersectByPoint(ellipse, point) {\n  var a = ellipse.rx;\n  var b = ellipse.ry;\n  var cx = ellipse.x;\n  var cy = ellipse.y;\n  var dx = point.x - cx;\n  var dy = point.y - cy; // 直接通过 x,y 求夹角，求出来的范围是 -PI, PI\n\n  var angle = Math.atan2(dy / b, dx / a);\n\n  if (angle < 0) {\n    angle += 2 * Math.PI; // 转换到 0，2PI\n  }\n\n  return {\n    x: cx + a * Math.cos(angle),\n    y: cy + b * Math.sin(angle)\n  };\n};\n/**\n * coordinate matrix transformation\n * @param  {number} point   coordinate\n * @param  {Matrix} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {Point} transformed point\n */\n\nexport var applyMatrix = function applyMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  var vector = [point.x, point.y, tag];\n\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  vec3.transformMat3(vector, vector, matrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n * coordinate matrix invert transformation\n * @param  {number} point   coordinate\n * @param  {number} matrix  matrix\n * @param  {number} tag     could be 0 or 1\n * @return {object} transformed point\n */\n\nexport var invertMatrix = function invertMatrix(point, matrix, tag) {\n  if (tag === void 0) {\n    tag = 1;\n  }\n\n  if (!matrix || isNaN(matrix[0])) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var inversedMatrix = mat3.invert([1, 0, 0, 0, 1, 0, 0, 0, 1], matrix);\n\n  if (!inversedMatrix) {\n    inversedMatrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var vector = [point.x, point.y, tag];\n  vec3.transformMat3(vector, vector, inversedMatrix);\n  return {\n    x: vector[0],\n    y: vector[1]\n  };\n};\n/**\n *\n * @param p1 First coordinate\n * @param p2 second coordinate\n * @param p3 three coordinate\n */\n\nexport var getCircleCenterByPoints = function getCircleCenterByPoints(p1, p2, p3) {\n  var a = p1.x - p2.x;\n  var b = p1.y - p2.y;\n  var c = p1.x - p3.x;\n  var d = p1.y - p3.y;\n  var e = (p1.x * p1.x - p2.x * p2.x - p2.y * p2.y + p1.y * p1.y) / 2;\n  var f = (p1.x * p1.x - p3.x * p3.x - p3.y * p3.y + p1.y * p1.y) / 2;\n  var denominator = b * c - a * d;\n  return {\n    x: -(d * e - b * f) / denominator,\n    y: -(a * f - c * e) / denominator\n  };\n};\n/**\n * get distance by two points\n * @param p1 first point\n * @param p2 second point\n */\n\nexport var distance = function distance(p1, p2) {\n  var vx = p1.x - p2.x;\n  var vy = p1.y - p2.y;\n  return Math.sqrt(vx * vx + vy * vy);\n};\n/**\n * scale matrix\n * @param matrix [ [], [], [] ]\n * @param ratio\n */\n\nexport var scaleMatrix = function scaleMatrix(matrix, ratio) {\n  var result = [];\n  matrix.forEach(function (row) {\n    var newRow = [];\n    row.forEach(function (v) {\n      newRow.push(v * ratio);\n    });\n    result.push(newRow);\n  });\n  return result;\n};\n/**\n * Floyd Warshall algorithm for shortest path distances matrix\n * @param  {array} adjMatrix   adjacency matrix\n * @return {array} distances   shortest path distances matrix\n */\n\nexport var floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (var k = 0; k < size; k += 1) {\n    for (var i = 0; i < size; i += 1) {\n      for (var j = 0; j < size; j += 1) {\n        if (dist[i][j] > dist[i][k] + dist[k][j]) {\n          dist[i][j] = dist[i][k] + dist[k][j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\n/**\n * get adjacency matrix\n * @param data graph data\n * @param directed whether it's a directed graph\n */\n\nexport var getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n      edges = data.edges;\n  var matrix = []; // map node with index in data.nodes\n\n  var nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(function (e) {\n      var source = e.source,\n          target = e.target;\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};\n/**\n * 平移group\n * @param group Group 实例\n * @param vec 移动向量\n */\n\nexport var translate = function translate(group, vec) {\n  group.translate(vec.x, vec.y);\n};\n/**\n * 移动到指定坐标点\n * @param group Group 实例\n * @param point 移动到的坐标点\n */\n\nexport var move = function move(group, point, animate, animateCfg) {\n  if (animateCfg === void 0) {\n    animateCfg = {\n      duration: 500\n    };\n  }\n\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var bbox = group.getCanvasBBox();\n  var vx = point.x - bbox.minX;\n  var vy = point.y - bbox.minY;\n\n  if (animate) {\n    var dx_1 = vx * matrix[0];\n    var dy_1 = vy * matrix[4];\n    var lastX_1 = 0;\n    var lastY_1 = 0;\n    var newX_1 = 0;\n    var newY_1 = 0;\n    group.animate(function (ratio) {\n      newX_1 = dx_1 * ratio;\n      newY_1 = dy_1 * ratio;\n      matrix = transform(matrix, [['t', newX_1 - lastX_1, newY_1 - lastY_1]]);\n      lastX_1 = newX_1;\n      lastY_1 = newY_1;\n      return {\n        matrix: matrix\n      };\n    }, animateCfg);\n  } else {\n    var movedMatrix = transform(matrix, [['t', vx, vy]]);\n    group.setMatrix(movedMatrix);\n  }\n};\n/**\n * 缩放 group\n * @param group Group 实例\n * @param point 在x 和 y 方向上的缩放比例\n */\n\nexport var scale = function scale(group, ratio) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  var scaleXY = ratio;\n\n  if (!isArray(ratio)) {\n    scaleXY = [ratio, ratio];\n  }\n\n  if (isArray(ratio) && ratio.length === 1) {\n    scaleXY = [ratio[0], ratio[0]];\n  }\n\n  matrix = transform(matrix, [['s', scaleXY[0], scaleXY[1]]]);\n  group.setMatrix(matrix);\n};\n/**\n *\n * @param group Group 实例\n * @param ratio 选择角度\n */\n\nexport var rotate = function rotate(group, angle) {\n  var matrix = group.getMatrix();\n\n  if (!matrix) {\n    matrix = [1, 0, 0, 0, 1, 0, 0, 0, 1];\n  }\n\n  matrix = transform(matrix, [['r', angle]]);\n  group.setMatrix(matrix);\n};\nexport var getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n\n  for (var i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  edges.forEach(function (e) {\n    if (e.source) {\n      degrees[nodeIdxMap[e.source]] += 1;\n    }\n\n    if (e.target) {\n      degrees[nodeIdxMap[e.target]] += 1;\n    }\n  });\n  return degrees;\n}; // 判断点Q是否在p1和p2的线段上\n\nfunction onSegment(p1, p2, q) {\n  if ((q[0] - p1[0]) * (p2[1] - p1[1]) === (p2[0] - p1[0]) * (q[1] - p1[1]) && Math.min(p1[0], p2[0]) <= q[0] && q[0] <= Math.max(p1[0], p2[0]) && Math.min(p1[1], p2[1]) <= q[1] && q[1] <= Math.max(p1[1], p2[1])) {\n    return true;\n  }\n\n  return false;\n}\n/**\n * 判断点P在多边形内-射线法. Borrow from https://github.com/antvis/util/blob/master/packages/path-util/src/point-in-polygon.ts\n * @param points\n * @param x\n * @param y\n */\n\n\nexport var isPointInPolygon = function isPointInPolygon(points, x, y) {\n  var isHit = false;\n  var n = points.length; // 判断两个double在eps精度下的大小关系\n\n  var tolerance = 1e-6;\n\n  function dcmp(xValue) {\n    if (Math.abs(xValue) < tolerance) {\n      return 0;\n    }\n\n    return xValue < 0 ? -1 : 1;\n  }\n\n  if (n <= 2) {\n    // svg 中点小于 3 个时，不显示，也无法被拾取\n    return false;\n  }\n\n  for (var i = 0; i < n; i++) {\n    var p1 = points[i];\n    var p2 = points[(i + 1) % n];\n\n    if (onSegment(p1, p2, [x, y])) {\n      // 点在多边形一条边上\n      return true;\n    } // 前一个判断min(p1[1],p2[1])<P.y<=max(p1[1],p2[1])\n    // 后一个判断被测点 在 射线与边交点 的左边\n\n\n    if (dcmp(p1[1] - y) > 0 !== dcmp(p2[1] - y) > 0 && dcmp(x - (y - p1[1]) * (p1[0] - p2[0]) / (p1[1] - p2[1]) - p1[0]) < 0) {\n      isHit = !isHit;\n    }\n  }\n\n  return isHit;\n}; // 判断两个BBox是否相交\n\nexport var intersectBBox = function intersectBBox(box1, box2) {\n  return !(box2.minX > box1.maxX || box2.maxX < box1.minX || box2.minY > box1.maxY || box2.maxY < box1.minY);\n};\n\nvar lineIntersectPolygon = function lineIntersectPolygon(lines, line) {\n  var isIntersect = false;\n  each(lines, function (l) {\n    if (getLineIntersect(l.from, l.to, line.from, line.to)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n/**\n * 判断两个polygon是否相交。\n * borrow from @antv/path-util\n * @param points1 polygon1的顶点数组\n * @param points2 polygon2的顶点数组\n */\n\n\nexport var isPolygonsIntersect = function isPolygonsIntersect(points1, points2) {\n  var getBBox = function getBBox(points) {\n    var xArr = points.map(function (p) {\n      return p[0];\n    });\n    var yArr = points.map(function (p) {\n      return p[1];\n    });\n    return {\n      minX: Math.min.apply(null, xArr),\n      maxX: Math.max.apply(null, xArr),\n      minY: Math.min.apply(null, yArr),\n      maxY: Math.max.apply(null, yArr)\n    };\n  };\n\n  var parseToLines = function parseToLines(points) {\n    var lines = [];\n    var count = points.length;\n\n    for (var i = 0; i < count - 1; i++) {\n      var point = points[i];\n      var next = points[i + 1];\n      lines.push({\n        from: {\n          x: point[0],\n          y: point[1]\n        },\n        to: {\n          x: next[0],\n          y: next[1]\n        }\n      });\n    }\n\n    if (lines.length > 1) {\n      var first = points[0];\n      var last = points[count - 1];\n      lines.push({\n        from: {\n          x: last[0],\n          y: last[1]\n        },\n        to: {\n          x: first[0],\n          y: first[1]\n        }\n      });\n    }\n\n    return lines;\n  }; // 空数组，或者一个点返回 false\n\n\n  if (points1.length < 2 || points2.length < 2) {\n    return false;\n  }\n\n  var bbox1 = getBBox(points1);\n  var bbox2 = getBBox(points2); // 判定包围盒是否相交，比判定点是否在多边形内要快的多，可以筛选掉大多数情况\n\n  if (!intersectBBox(bbox1, bbox2)) {\n    return false;\n  }\n\n  var isIn = false; // 判定点是否在多边形内部，一旦有一个点在另一个多边形内，则返回\n\n  each(points2, function (point) {\n    if (isPointInPolygon(points1, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  each(points1, function (point) {\n    if (isPointInPolygon(points2, point[0], point[1])) {\n      isIn = true;\n      return false;\n    }\n  });\n\n  if (isIn) {\n    return true;\n  }\n\n  var lines1 = parseToLines(points1);\n  var lines2 = parseToLines(points2);\n  var isIntersect = false;\n  each(lines2, function (line) {\n    if (lineIntersectPolygon(lines1, line)) {\n      isIntersect = true;\n      return false;\n    }\n  });\n  return isIntersect;\n};\n\nvar Line =\n/** @class */\nfunction () {\n  function Line(x1, y1, x2, y2) {\n    this.x1 = x1;\n    this.y1 = y1;\n    this.x2 = x2;\n    this.y2 = y2;\n  }\n\n  Line.prototype.getBBox = function () {\n    var minX = Math.min(this.x1, this.x2);\n    var minY = Math.min(this.y1, this.y2);\n    var maxX = Math.max(this.x1, this.x2);\n    var maxY = Math.max(this.y1, this.y2);\n    var res = {\n      x: minX,\n      y: minY,\n      minX: minX,\n      minY: minY,\n      maxX: maxX,\n      maxY: maxY,\n      width: maxX - minX,\n      height: maxY - minY\n    };\n    return res;\n  };\n\n  return Line;\n}();\n\nexport { Line };\nexport var getBBoxBoundLine = function getBBoxBoundLine(bbox, direction) {\n  var bounds = {\n    top: [bbox.minX, bbox.minY, bbox.maxX, bbox.minY],\n    left: [bbox.minX, bbox.minY, bbox.minX, bbox.maxY],\n    bottom: [bbox.minX, bbox.maxY, bbox.maxX, bbox.maxY],\n    right: [bbox.maxX, bbox.minY, bbox.maxX, bbox.maxY]\n  };\n  return bounds[direction];\n};\n/**\n * 计算两条线段相交时，相交点对第一条线段上的分割比例\n */\n\nvar fractionAlongLineA = function fractionAlongLineA(la, lb) {\n  var uaT = (lb.x2 - lb.x1) * (la.y1 - lb.y1) - (lb.y2 - lb.y1) * (la.x1 - lb.x1);\n  var ubT = (la.x2 - la.x1) * (la.y1 - lb.y1) - (la.y2 - la.y1) * (la.x1 - lb.x1);\n  var uB = (lb.y2 - lb.y1) * (la.x2 - la.x1) - (lb.x2 - lb.x1) * (la.y2 - la.y1);\n\n  if (uB) {\n    var ua = uaT / uB;\n    var ub = ubT / uB;\n\n    if (ua >= 0 && ua <= 1 && ub >= 0 && ub <= 1) {\n      return ua;\n    }\n  }\n\n  return Number.POSITIVE_INFINITY;\n};\n\nexport var itemIntersectByLine = function itemIntersectByLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var countIntersections = 0;\n  var intersections = [];\n\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    intersections[i] = getLineIntersect({\n      x: line.x1,\n      y: line.y1\n    }, {\n      x: line.x2,\n      y: line.y2\n    }, {\n      x: x1,\n      y: y1\n    }, {\n      x: x2,\n      y: y2\n    });\n\n    if (intersections[i]) {\n      countIntersections += 1;\n    }\n  }\n\n  return [intersections, countIntersections];\n};\nexport var fractionToLine = function fractionToLine(item, line) {\n  var directions = ['top', 'left', 'bottom', 'right'];\n  var bbox = item.getBBox();\n  var minDistance = Number.POSITIVE_INFINITY;\n  var countIntersections = 0;\n\n  for (var i = 0; i < 4; i++) {\n    var _a = getBBoxBoundLine(bbox, directions[i]),\n        x1 = _a[0],\n        y1 = _a[1],\n        x2 = _a[2],\n        y2 = _a[3];\n\n    var testDistance = fractionAlongLineA(line, new Line(x1, y1, x2, y2));\n    testDistance = Math.abs(testDistance - 0.5);\n\n    if (testDistance >= 0 && testDistance <= 1) {\n      countIntersections += 1;\n      minDistance = testDistance < minDistance ? testDistance : minDistance;\n    }\n  }\n\n  if (countIntersections === 0) return -1;\n  return minDistance;\n};\nexport var getPointsCenter = function getPointsCenter(points) {\n  var centerX = 0;\n  var centerY = 0;\n\n  if (points.length > 0) {\n    for (var _i = 0, points_1 = points; _i < points_1.length; _i++) {\n      var point = points_1[_i];\n      centerX += point.x;\n      centerY += point.y;\n    }\n\n    centerX /= points.length;\n    centerY /= points.length;\n  }\n\n  return {\n    x: centerX,\n    y: centerY\n  };\n};\nexport var squareDist = function squareDist(a, b) {\n  return Math.pow(a.x - b.x, 2) + Math.pow(a.y - b.y, 2);\n};\nexport var pointLineSquareDist = function pointLineSquareDist(point, line) {\n  var x1 = line.x1;\n  var y1 = line.y1;\n  var x2 = line.x2 - x1;\n  var y2 = line.y2 - y1;\n  var px = point.x - x1;\n  var py = point.y - y1;\n  var dotprod = px * x2 + py * y2;\n  var projlenSq;\n\n  if (dotprod <= 0) {\n    projlenSq = 0;\n  } else {\n    px = x2 - px;\n    py = y2 - py;\n    dotprod = px * x2 + py * y2;\n\n    if (dotprod <= 0) {\n      projlenSq = 0;\n    } else {\n      projlenSq = dotprod * dotprod / (x2 * x2 + y2 * y2);\n    }\n  }\n\n  var lenSq = px * px + py * py - projlenSq;\n\n  if (lenSq < 0) {\n    lenSq = 0;\n  }\n\n  return lenSq;\n};\nexport var isPointsOverlap = function isPointsOverlap(p1, p2, e) {\n  if (e === void 0) {\n    e = 1e-3;\n  }\n\n  return Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2) < Math.pow(e, 2);\n};\n/**\n * 点到矩形的距离的平方：矩形内部点视作距离为0，外部的点若投影落在矩形边上则为点到矩形边的最近的垂直距离，否则为点到矩形顶点的距离，\n * @param point IPoint\n * @param rect IRect\n */\n\nexport var pointRectSquareDist = function pointRectSquareDist(point, rect) {\n  var isLeft = point.x < rect.x;\n  var isRight = point.x > rect.x + rect.width;\n  var isTop = point.y > rect.y + rect.height;\n  var isBottom = point.y < rect.y;\n  var isPointOutside = isLeft || isRight || isTop || isBottom;\n\n  if (!isPointOutside) {\n    return 0;\n  }\n\n  if (isTop && !isLeft && !isRight) {\n    return Math.pow(rect.y + rect.height - point.y, 2);\n  }\n\n  if (isBottom && !isLeft && !isRight) {\n    return Math.pow(point.y - rect.y, 2);\n  }\n\n  if (isLeft && !isTop && !isBottom) {\n    return Math.pow(rect.x - point.x, 2);\n  }\n\n  if (isRight && !isTop && !isBottom) {\n    return Math.pow(rect.x + rect.width - point.x, 2);\n  }\n\n  var dx = Math.min(Math.abs(rect.x - point.x), Math.abs(rect.x + rect.width - point.x));\n  var dy = Math.min(Math.abs(rect.y - point.y), Math.abs(rect.y + rect.height - point.y));\n  return dx * dx + dy * dy;\n};\n/**\n * point to line distance\n * @param  {array} line 线的四个顶点 [x1, y1, x2, y2]\n * @param  {object} point 坐标点 {x, y}\n * @return {Number|NaN} distance\n */\n\nexport var pointLineDistance = function pointLineDistance(line, point) {\n  var x1 = line[0],\n      y1 = line[1],\n      x2 = line[2],\n      y2 = line[3];\n  var x = point.x,\n      y = point.y;\n  var d = [x2 - x1, y2 - y1];\n\n  if (vec2.exactEquals(d, [0, 0])) {\n    return NaN;\n  }\n\n  var u = [-d[1], d[0]]; // @ts-ignore\n\n  vec2.normalize(u, u);\n  var a = [x - x1, y - y1]; // @ts-ignore\n\n  return Math.abs(vec2.dot(a, u));\n};\n/**\n * Linearly interpolate between start and end, where alpha is the percent distance along the line.\n * alpha = 0 will be start, and alpha = 1 will be end.\n * @param {Number} start\n * @param {Number} end\n * @param {Number} alpha interpolation factor, typically in the closed interval [0, 1]\n * @returns\n */\n\nexport var lerp = function lerp(start, end, alpha) {\n  return start + (end - start) * alpha;\n};"]},"metadata":{},"sourceType":"module"}