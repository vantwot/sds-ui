{"ast":null,"code":"import _slicedToArray from \"@babel/runtime/helpers/slicedToArray\";\nimport _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport { aProjectFlat } from '@antv/l7-utils';\nimport { vec2 } from 'gl-matrix';\nvar tmp = vec2.create();\nvar capEnd = vec2.create();\nvar lineA = vec2.create();\nvar lineB = vec2.create();\nvar tangent = vec2.create();\nexport function computeMiter(lineTangent, miter, start, end, halfThick) {\n  vec2.add(lineTangent, start, end);\n  vec2.normalize(lineTangent, lineTangent);\n  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);\n  var tmpvec = vec2.fromValues(-start[1], start[0]);\n  return [halfThick / vec2.dot(miter, tmpvec), miter];\n}\nexport function computeNormal(out, dir) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\nexport function direction(out, a, b) {\n  vec2.sub(out, a, b);\n  vec2.normalize(out, out);\n  return out;\n}\n\nfunction isPointEqual(a, b) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\nfunction getArrayUnique(matrix) {\n  var map = new Map();\n\n  for (var i = 0; i < matrix.length; i++) {\n    var key = matrix[0].toString() + '-' + matrix[1].toString();\n\n    if (map.get(key)) {\n      matrix.splice(i, 1);\n      i++;\n    } else {\n      map.set(key, key);\n    }\n  }\n\n  return matrix;\n}\n\nvar ExtrudePolyline = function () {\n  function ExtrudePolyline() {\n    var opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, ExtrudePolyline);\n\n    _defineProperty(this, \"complex\", void 0);\n\n    _defineProperty(this, \"join\", void 0);\n\n    _defineProperty(this, \"cap\", void 0);\n\n    _defineProperty(this, \"miterLimit\", void 0);\n\n    _defineProperty(this, \"thickness\", void 0);\n\n    _defineProperty(this, \"normal\", void 0);\n\n    _defineProperty(this, \"lastFlip\", -1);\n\n    _defineProperty(this, \"miter\", vec2.fromValues(0, 0));\n\n    _defineProperty(this, \"started\", false);\n\n    _defineProperty(this, \"dash\", false);\n\n    _defineProperty(this, \"totalDistance\", 0);\n\n    this.join = opts.join || 'miter';\n    this.cap = opts.cap || 'butt';\n    this.miterLimit = opts.miterLimit || 10;\n    this.thickness = opts.thickness || 1;\n    this.dash = opts.dash || false;\n    this.complex = {\n      positions: [],\n      indices: [],\n      normals: [],\n      startIndex: 0\n    };\n  }\n\n  _createClass(ExtrudePolyline, [{\n    key: \"extrude_gaode2\",\n    value: function extrude_gaode2(points, originPoints) {\n      var complex = this.complex;\n\n      if (points.length <= 1) {\n        return complex;\n      }\n\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      var total = points.length;\n      var count = complex.startIndex;\n\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var originLast = originPoints[i - 1];\n        var cur = points[i];\n        var originCur = originPoints[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var originNext = i < originPoints.length - 1 ? originPoints[i + 1] : null;\n        var amt = this.segment_gaode2(complex, count, last, cur, next, originLast, originCur, originNext);\n        count += amt;\n      }\n\n      if (this.dash) {\n        for (var _i = 0; _i < complex.positions.length / 6; _i++) {\n          complex.positions[_i * 6 + 5] = this.totalDistance;\n        }\n      }\n\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"extrude\",\n    value: function extrude(points) {\n      var complex = this.complex;\n\n      if (points.length <= 1) {\n        return complex;\n      }\n\n      this.lastFlip = -1;\n      this.started = false;\n      this.normal = null;\n      this.totalDistance = 0;\n      var total = points.length;\n      var count = complex.startIndex;\n\n      for (var i = 1; i < total; i++) {\n        var last = points[i - 1];\n        var cur = points[i];\n        var next = i < points.length - 1 ? points[i + 1] : null;\n        var amt = this.segment(complex, count, last, cur, next);\n        count += amt;\n      }\n\n      if (this.dash) {\n        for (var _i2 = 0; _i2 < complex.positions.length / 6; _i2++) {\n          complex.positions[_i2 * 6 + 5] = this.totalDistance;\n        }\n      }\n\n      complex.startIndex = complex.positions.length / 6;\n      return complex;\n    }\n  }, {\n    key: \"segment_gaode2\",\n    value: function segment_gaode2(complex, index, last, cur, next, originLast, originCur, originNext) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([originCur[0], originCur[1]]);\n      var flatLast = aProjectFlat([originLast[0], originLast[1]]);\n      direction(lineA, cur, last);\n      var segmentDistance = 0;\n\n      if (this.dash) {\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n\n      if (!this.started) {\n        this.started = true;\n\n        if (capSquare) {\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n\n      indices.push(index + 0, index + 1, index + 2);\n\n      if (!next) {\n        computeNormal(this.normal, lineA);\n\n        if (capSquare) {\n          var _out = vec2.create();\n\n          var _out2 = vec2.create();\n\n          vec2.sub(_out2, lineA, this.normal);\n          vec2.add(_out, lineA, this.normal);\n          normals.push(_out2[0], _out2[1], 0);\n          normals.push(_out[0], _out[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        if (isPointEqual(cur, next)) {\n          vec2.add(next, cur, vec2.normalize(next, vec2.subtract(next, cur, last)));\n        }\n\n        direction(lineB, next, cur);\n\n        var _computeMiter = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n            _computeMiter2 = _slicedToArray(_computeMiter, 2),\n            miterLen = _computeMiter2[0],\n            miter = _computeMiter2[1];\n\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp);\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n\n        this.lastFlip = flip;\n      }\n\n      return count;\n    }\n  }, {\n    key: \"segment\",\n    value: function segment(complex, index, last, cur, next) {\n      var count = 0;\n      var indices = complex.indices;\n      var positions = complex.positions;\n      var normals = complex.normals;\n      var capSquare = this.cap === 'square';\n      var joinBevel = this.join === 'bevel';\n      var flatCur = aProjectFlat([cur[0], cur[1]]);\n      var flatLast = aProjectFlat([last[0], last[1]]);\n      direction(lineA, flatCur, flatLast);\n      var segmentDistance = 0;\n\n      if (this.dash) {\n        segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n        this.totalDistance += segmentDistance;\n      }\n\n      if (!this.normal) {\n        this.normal = vec2.create();\n        computeNormal(this.normal, lineA);\n      }\n\n      if (!this.started) {\n        this.started = true;\n\n        if (capSquare) {\n          var out1 = vec2.create();\n          var out2 = vec2.create();\n          vec2.add(out1, this.normal, lineA);\n          vec2.add(out2, this.normal, lineA);\n          normals.push(out2[0], out2[1], 0);\n          normals.push(out1[0], out1[1], 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, -this.thickness, last[2] | 0);\n          positions.push(last[0], last[1], last[2] | 0, this.totalDistance - segmentDistance, this.thickness, last[2] | 0);\n        } else {\n          this.extrusions(positions, normals, last, this.normal, this.thickness, this.totalDistance - segmentDistance);\n        }\n      }\n\n      indices.push(index + 0, index + 1, index + 2);\n\n      if (!next) {\n        computeNormal(this.normal, lineA);\n\n        if (capSquare) {\n          var _out3 = vec2.create();\n\n          var _out4 = vec2.create();\n\n          vec2.sub(_out4, lineA, this.normal);\n          vec2.add(_out3, lineA, this.normal);\n          normals.push(_out4[0], _out4[1], 0);\n          normals.push(_out3[0], _out3[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness, cur[2] | 0);\n        } else {\n          this.extrusions(positions, normals, cur, this.normal, this.thickness, this.totalDistance);\n        }\n\n        indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n        count += 2;\n      } else {\n        var flatNext = aProjectFlat([next[0], next[1]]);\n\n        if (isPointEqual(flatCur, flatNext)) {\n          vec2.add(flatNext, flatCur, vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)));\n        }\n\n        direction(lineB, flatNext, flatCur);\n\n        var _computeMiter3 = computeMiter(tangent, vec2.create(), lineA, lineB, this.thickness),\n            _computeMiter4 = _slicedToArray(_computeMiter3, 2),\n            miterLen = _computeMiter4[0],\n            miter = _computeMiter4[1];\n\n        var flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n        var bevel = joinBevel;\n\n        if (!bevel && this.join === 'miter') {\n          var limit = miterLen;\n\n          if (limit > this.miterLimit) {\n            bevel = true;\n          }\n        }\n\n        if (bevel) {\n          normals.push(this.normal[0], this.normal[1], 0);\n          normals.push(miter[0], miter[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, this.thickness * flip, cur[2] | 0);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip !== -flip ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          indices.push(index + 2, index + 3, index + 4);\n          computeNormal(tmp, lineB);\n          vec2.copy(this.normal, tmp);\n          normals.push(this.normal[0], this.normal[1], 0);\n          positions.push(cur[0], cur[1], cur[2] | 0, this.totalDistance, -this.thickness * flip, cur[2] | 0);\n          count += 3;\n        } else {\n          this.extrusions(positions, normals, cur, miter, miterLen, this.totalDistance);\n          indices.push.apply(indices, _toConsumableArray(this.lastFlip === 1 ? [index, index + 2, index + 3] : [index + 2, index + 1, index + 3]));\n          flip = -1;\n          vec2.copy(this.normal, miter);\n          count += 2;\n        }\n\n        this.lastFlip = flip;\n      }\n\n      return count;\n    }\n  }, {\n    key: \"extrusions\",\n    value: function extrusions(positions, normals, point, normal, thickness, distanceRadio) {\n      normals.push(normal[0], normal[1], 0);\n      normals.push(normal[0], normal[1], 0);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, -thickness, point[2] | 0);\n      positions.push(point[0], point[1], point[2] | 0, distanceRadio, thickness, point[2] | 0);\n    }\n  }, {\n    key: \"lineSegmentDistance\",\n    value: function lineSegmentDistance(b1, a1) {\n      var dx = a1[0] - b1[0];\n      var dy = a1[1] - b1[1];\n      return Math.sqrt(dx * dx + dy * dy);\n    }\n  }]);\n\n  return ExtrudePolyline;\n}();\n\nexport { ExtrudePolyline as default };","map":{"version":3,"sources":["../../src/utils/extrude_polyline.ts"],"names":["tmp","vec2","capEnd","lineA","lineB","tangent","miter","lineTangent","tmpvec","start","halfThick","dir","a","b","map","i","matrix","key","ExtrudePolyline","opts","positions","indices","normals","startIndex","complex","points","total","count","last","originLast","originPoints","cur","originCur","next","originNext","amt","capSquare","joinBevel","flatCur","aProjectFlat","flatLast","direction","segmentDistance","computeNormal","out1","out2","index","isPointEqual","miterLen","computeMiter","flip","bevel","limit","flatNext","normal","point","dx","a1","b1","dy","Math"],"mappings":"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","sourcesContent":["import { aProjectFlat } from '@antv/l7-utils';\nimport { vec2, vec3 } from 'gl-matrix';\nconst tmp = vec2.create();\nconst capEnd = vec2.create();\nconst lineA = vec2.create();\nconst lineB = vec2.create();\nconst tangent = vec2.create();\n\nexport function computeMiter(\n  lineTangent: vec2,\n  miter: vec2,\n  start: vec2,\n  end: vec2,\n  halfThick: number,\n): [number, vec2] {\n  vec2.add(lineTangent, start, end);\n  vec2.normalize(lineTangent, lineTangent);\n  miter = vec2.fromValues(-lineTangent[1], lineTangent[0]);\n  const tmpvec = vec2.fromValues(-start[1], start[0]);\n  return [halfThick / vec2.dot(miter, tmpvec), miter];\n}\nexport function computeNormal(out: vec2, dir: vec2) {\n  return vec2.set(out, -dir[1], dir[0]);\n}\n\nexport function direction(out: vec2, a: vec2, b: vec2) {\n  vec2.sub(out, a, b);\n  vec2.normalize(out, out);\n  return out;\n}\n\nfunction isPointEqual(a: vec2, b: vec2) {\n  return a[0] === b[0] && a[1] === b[1];\n}\n\nfunction getArrayUnique(matrix: number[][]) {\n  const map = new Map();\n  for (let i = 0; i < matrix.length; i++) {\n    const key = matrix[0].toString() + '-' + matrix[1].toString();\n    if (map.get(key)) {\n      matrix.splice(i, 1);\n      i++;\n    } else {\n      map.set(key, key);\n    }\n  }\n  return matrix;\n}\n\nexport interface IExtrudeLineOption {\n  join: string;\n  cap: string;\n  dash: boolean;\n  closed: boolean;\n  indexOffset: number;\n  miterLimit: number;\n  thickness: number;\n}\nexport default class ExtrudePolyline {\n  public complex: {\n    positions: number[];\n    indices: number[];\n    normals: number[];\n    startIndex: number;\n  };\n  private join: string;\n  private cap: string;\n  private miterLimit: number;\n  private thickness: number;\n  private normal: vec2 | null;\n  private lastFlip: number = -1;\n  private miter: vec2 = vec2.fromValues(0, 0);\n  private started: boolean = false;\n  private dash: boolean = false;\n  private totalDistance: number = 0;\n\n  constructor(opts: Partial<IExtrudeLineOption> = {}) {\n    this.join = opts.join || 'miter';\n    this.cap = opts.cap || 'butt';\n    this.miterLimit = opts.miterLimit || 10;\n    this.thickness = opts.thickness || 1;\n    this.dash = opts.dash || false;\n    this.complex = {\n      positions: [],\n      indices: [],\n      normals: [],\n      startIndex: 0,\n    };\n  }\n\n  public extrude_gaode2(points: number[][], originPoints: number[][]) {\n    const complex = this.complex;\n    if (points.length <= 1) {\n      return complex;\n    }\n    this.lastFlip = -1;\n    this.started = false;\n    this.normal = null;\n    this.totalDistance = 0;\n    // 去除数组里重复的点\n    // points = getArrayUnique(points);\n    const total = points.length;\n    let count = complex.startIndex;\n    for (let i = 1; i < total; i++) {\n      const last = points[i - 1] as vec3;\n      const originLast = originPoints[i - 1] as vec2;\n\n      const cur = points[i] as vec3;\n      const originCur = originPoints[i] as vec2;\n\n      const next = i < points.length - 1 ? points[i + 1] : null;\n      const originNext =\n        i < originPoints.length - 1 ? originPoints[i + 1] : null;\n\n      const amt = this.segment_gaode2(\n        complex,\n        count,\n        last,\n        cur,\n        next as vec3,\n        originLast,\n        originCur,\n        originNext as vec2,\n      );\n      count += amt;\n    }\n    if (this.dash) {\n      for (let i = 0; i < complex.positions.length / 6; i++) {\n        complex.positions[i * 6 + 5] = this.totalDistance;\n      }\n    }\n    complex.startIndex = complex.positions.length / 6;\n    return complex;\n  }\n  public extrude(points: number[][]) {\n    const complex = this.complex;\n    if (points.length <= 1) {\n      return complex;\n    }\n    this.lastFlip = -1;\n    this.started = false;\n    this.normal = null;\n    this.totalDistance = 0;\n    // 去除数组里重复的点\n    // points = getArrayUnique(points);\n    const total = points.length;\n    let count = complex.startIndex;\n    for (let i = 1; i < total; i++) {\n      const last = points[i - 1] as vec3;\n      const cur = points[i] as vec3;\n      const next = i < points.length - 1 ? points[i + 1] : null;\n      const amt = this.segment(complex, count, last, cur, next as vec3);\n      count += amt;\n    }\n    if (this.dash) {\n      for (let i = 0; i < complex.positions.length / 6; i++) {\n        complex.positions[i * 6 + 5] = this.totalDistance;\n      }\n    }\n    complex.startIndex = complex.positions.length / 6;\n    return complex;\n  }\n  private segment_gaode2(\n    complex: any,\n    index: number,\n    last: vec3,\n    cur: vec3,\n    next: vec3,\n    originLast: vec2,\n    originCur: vec2,\n    originNext: vec2,\n  ) {\n    let count = 0;\n    const indices = complex.indices;\n    const positions = complex.positions;\n    const normals = complex.normals;\n    const capSquare = this.cap === 'square';\n    const joinBevel = this.join === 'bevel';\n    const flatCur = aProjectFlat([originCur[0], originCur[1]]) as [\n      number,\n      number,\n    ];\n    const flatLast = aProjectFlat([originLast[0], originLast[1]]) as [\n      number,\n      number,\n    ];\n    direction(lineA, cur as vec2, last as vec2);\n    let segmentDistance = 0;\n    if (this.dash) {\n      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n      this.totalDistance += segmentDistance;\n    }\n\n    if (!this.normal) {\n      this.normal = vec2.create();\n      computeNormal(this.normal, lineA);\n    }\n    if (!this.started) {\n      this.started = true;\n\n      // if the end cap is type square, we can just push the verts out a bit\n      if (capSquare) {\n        // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n        const out1 = vec2.create();\n        const out2 = vec2.create();\n        vec2.add(out1, this.normal, lineA);\n        vec2.add(out2, this.normal, lineA);\n        normals.push(out2[0], out2[1], 0);\n        normals.push(out1[0], out1[1], 0);\n        positions.push(\n          last[0],\n          last[1],\n          last[2] | 0,\n          this.totalDistance - segmentDistance,\n          -this.thickness,\n          last[2] | 0,\n        );\n        positions.push(\n          last[0],\n          last[1],\n          last[2] | 0,\n          this.totalDistance - segmentDistance,\n          this.thickness,\n          last[2] | 0,\n        );\n      } else {\n        this.extrusions(\n          positions,\n          normals,\n          last,\n          this.normal,\n          this.thickness,\n          this.totalDistance - segmentDistance,\n        );\n      }\n    }\n\n    indices.push(index + 0, index + 1, index + 2);\n\n    if (!next) {\n      computeNormal(this.normal, lineA);\n      if (capSquare) {\n        const out1 = vec2.create();\n        const out2 = vec2.create();\n        vec2.sub(out2, lineA, this.normal);\n        vec2.add(out1, lineA, this.normal);\n\n        normals.push(out2[0], out2[1], 0);\n        normals.push(out1[0], out1[1], 0);\n\n        positions.push(\n          cur[0],\n          cur[1],\n          cur[2] | 0,\n          this.totalDistance,\n          this.thickness,\n          cur[2] | 0,\n        );\n        positions.push(\n          cur[0],\n          cur[1],\n          cur[2] | 0,\n          this.totalDistance,\n          this.thickness,\n          cur[2] | 0,\n        );\n      } else {\n        this.extrusions(\n          positions,\n          normals,\n          cur,\n          this.normal,\n          this.thickness,\n          this.totalDistance,\n        );\n      }\n      indices.push(\n        ...(this.lastFlip === 1\n          ? [index, index + 2, index + 3]\n          : [index + 2, index + 1, index + 3]),\n      );\n      count += 2;\n    } else {\n      if (isPointEqual(cur as vec2, next as vec2)) {\n        vec2.add(\n          next as vec2,\n          cur as vec2,\n          vec2.normalize(\n            next as vec2,\n            vec2.subtract(next as vec2, cur as vec2, last as vec2),\n          ),\n        );\n      }\n      direction(lineB, next as vec2, cur as vec2);\n      // stores tangent & miter\n\n      const [miterLen, miter] = computeMiter(\n        tangent,\n        vec2.create(),\n        lineA,\n        lineB,\n        this.thickness,\n      );\n      // normal(tmp, lineA)\n\n      // get orientation\n      let flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n      let bevel = joinBevel;\n      if (!bevel && this.join === 'miter') {\n        const limit = miterLen;\n        if (limit > this.miterLimit) {\n          bevel = true;\n        }\n      }\n\n      if (bevel) {\n        normals.push(this.normal[0], this.normal[1], 0);\n        normals.push(miter[0], miter[1], 0);\n\n        positions.push(\n          cur[0],\n          cur[1],\n          cur[2] | 0,\n          this.totalDistance,\n          -this.thickness * flip,\n          cur[2] | 0,\n        );\n        positions.push(\n          cur[0],\n          cur[1],\n          cur[2] | 0,\n          this.totalDistance,\n          this.thickness * flip,\n          cur[2] | 0,\n        );\n        indices.push(\n          ...(this.lastFlip !== -flip\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3]),\n        );\n\n        // now add the bevel triangle\n        indices.push(index + 2, index + 3, index + 4);\n\n        computeNormal(tmp, lineB);\n        vec2.copy(this.normal, tmp); // store normal for next round\n        normals.push(this.normal[0], this.normal[1], 0);\n        positions.push(\n          cur[0],\n          cur[1],\n          cur[2] | 0,\n          this.totalDistance,\n          -this.thickness * flip,\n          cur[2] | 0,\n        );\n        count += 3;\n      } else {\n        this.extrusions(\n          positions,\n          normals,\n          cur,\n          miter,\n          miterLen,\n          this.totalDistance,\n        );\n        indices.push(\n          ...(this.lastFlip === 1\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3]),\n        );\n\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        vec2.copy(this.normal, miter);\n        count += 2;\n      }\n      this.lastFlip = flip;\n    }\n    return count;\n  }\n  private segment(\n    complex: any,\n    index: number,\n    last: vec3,\n    cur: vec3,\n    next: vec3,\n  ) {\n    let count = 0;\n    const indices = complex.indices;\n    const positions = complex.positions;\n    const normals = complex.normals;\n    const capSquare = this.cap === 'square';\n    const joinBevel = this.join === 'bevel';\n    const flatCur = aProjectFlat([cur[0], cur[1]]) as [number, number];\n    const flatLast = aProjectFlat([last[0], last[1]]) as [number, number];\n    direction(lineA, flatCur, flatLast);\n    let segmentDistance = 0;\n    if (this.dash) {\n      segmentDistance = this.lineSegmentDistance(flatCur, flatLast);\n      this.totalDistance += segmentDistance;\n    }\n\n    if (!this.normal) {\n      this.normal = vec2.create();\n      computeNormal(this.normal, lineA);\n    }\n    if (!this.started) {\n      this.started = true;\n\n      // if the end cap is type square, we can just push the verts out a bit\n      if (capSquare) {\n        // vec2.scaleAndAdd(capEnd, last, lineA, -this.thickness);\n        const out1 = vec2.create();\n        const out2 = vec2.create();\n        vec2.add(out1, this.normal, lineA);\n        vec2.add(out2, this.normal, lineA);\n        normals.push(out2[0], out2[1], 0);\n        normals.push(out1[0], out1[1], 0);\n        positions.push(\n          last[0],\n          last[1],\n          last[2] | 0,\n          this.totalDistance - segmentDistance,\n          -this.thickness,\n          last[2] | 0,\n        );\n        positions.push(\n          last[0],\n          last[1],\n          last[2] | 0,\n          this.totalDistance - segmentDistance,\n          this.thickness,\n          last[2] | 0,\n        );\n\n        // this.extrusions(positions, normals, last, out, this.thickness);\n        // last = capEnd;\n      } else {\n        this.extrusions(\n          positions,\n          normals,\n          last,\n          this.normal,\n          this.thickness,\n          this.totalDistance - segmentDistance,\n        );\n      }\n    }\n\n    indices.push(index + 0, index + 1, index + 2);\n\n    if (!next) {\n      computeNormal(this.normal, lineA);\n      if (capSquare) {\n        // vec2.scaleAndAdd(capEnd, cur, lineA, this.thickness);\n        // cur = capEnd;\n        const out1 = vec2.create();\n        const out2 = vec2.create();\n        vec2.sub(out2, lineA, this.normal);\n        vec2.add(out1, lineA, this.normal);\n        // this.extrusions(positions, normals, cur, out, this.thickness);\n        normals.push(out2[0], out2[1], 0);\n        normals.push(out1[0], out1[1], 0);\n        positions.push(\n          cur[0],\n          cur[1],\n          cur[2] | 0,\n          this.totalDistance,\n          this.thickness,\n          cur[2] | 0,\n        );\n        positions.push(\n          cur[0],\n          cur[1],\n          cur[2] | 0,\n          this.totalDistance,\n          this.thickness,\n          cur[2] | 0,\n        );\n      } else {\n        this.extrusions(\n          positions,\n          normals,\n          cur,\n          this.normal,\n          this.thickness,\n          this.totalDistance,\n        );\n      }\n\n      // this.extrusions(positions, normals, cur, this.normal, this.thickness);\n      indices.push(\n        ...(this.lastFlip === 1\n          ? [index, index + 2, index + 3]\n          : [index + 2, index + 1, index + 3]),\n      );\n      count += 2;\n    } else {\n      const flatNext = aProjectFlat([next[0], next[1]]) as [number, number];\n      if (isPointEqual(flatCur, flatNext)) {\n        vec2.add(\n          flatNext,\n          flatCur,\n          vec2.normalize(flatNext, vec2.subtract(flatNext, flatCur, flatLast)),\n        );\n      }\n      direction(lineB, flatNext, flatCur);\n\n      // stores tangent & miter\n\n      const [miterLen, miter] = computeMiter(\n        tangent,\n        vec2.create(),\n        lineA,\n        lineB,\n        this.thickness,\n      );\n      // normal(tmp, lineA)\n\n      // get orientation\n      let flip = vec2.dot(tangent, this.normal) < 0 ? -1 : 1;\n      let bevel = joinBevel;\n      if (!bevel && this.join === 'miter') {\n        const limit = miterLen;\n        if (limit > this.miterLimit) {\n          bevel = true;\n        }\n      }\n\n      if (bevel) {\n        normals.push(this.normal[0], this.normal[1], 0);\n        normals.push(miter[0], miter[1], 0);\n        positions.push(\n          cur[0],\n          cur[1],\n          cur[2] | 0,\n          this.totalDistance,\n          -this.thickness * flip,\n          cur[2] | 0,\n        );\n        positions.push(\n          cur[0],\n          cur[1],\n          cur[2] | 0,\n          this.totalDistance,\n          this.thickness * flip,\n          cur[2] | 0,\n        );\n        indices.push(\n          ...(this.lastFlip !== -flip\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3]),\n        );\n\n        // now add the bevel triangle\n        indices.push(index + 2, index + 3, index + 4);\n\n        computeNormal(tmp, lineB);\n        vec2.copy(this.normal, tmp); // store normal for next round\n        normals.push(this.normal[0], this.normal[1], 0);\n        positions.push(\n          cur[0],\n          cur[1],\n          cur[2] | 0,\n          this.totalDistance,\n          -this.thickness * flip,\n          cur[2] | 0,\n        );\n        count += 3;\n      } else {\n        this.extrusions(\n          positions,\n          normals,\n          cur,\n          miter,\n          miterLen,\n          this.totalDistance,\n        );\n        indices.push(\n          ...(this.lastFlip === 1\n            ? [index, index + 2, index + 3]\n            : [index + 2, index + 1, index + 3]),\n        );\n\n        flip = -1;\n\n        // the miter is now the normal for our next join\n        vec2.copy(this.normal, miter);\n        count += 2;\n      }\n      this.lastFlip = flip;\n    }\n    return count;\n  }\n  private extrusions(\n    positions: number[],\n    normals: number[],\n    point: vec3, // 顶点\n    normal: vec2, // 法向量\n    thickness: number, // 高度\n    distanceRadio: number,\n  ) {\n    normals.push(normal[0], normal[1], 0);\n    normals.push(normal[0], normal[1], 0);\n    positions.push(\n      point[0],\n      point[1],\n      point[2] | 0,\n      distanceRadio,\n      -thickness,\n      point[2] | 0,\n    );\n    positions.push(\n      point[0],\n      point[1],\n      point[2] | 0,\n      distanceRadio,\n      thickness,\n      point[2] | 0,\n    );\n  }\n  private lineSegmentDistance(b1: vec2, a1: vec2) {\n    const dx = a1[0] - b1[0];\n    const dy = a1[1] - b1[1];\n    return Math.sqrt(dx * dx + dy * dy);\n  }\n}\n"]},"metadata":{},"sourceType":"module"}