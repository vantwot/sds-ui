{"ast":null,"code":"import { resolve } from './util';\n\nvar middleSide = function middleSide(view, magnet, refPoint, options) {\n  var bbox;\n  var angle = 0;\n  var center;\n  var node = view.cell;\n\n  if (options.rotate) {\n    bbox = view.getUnrotatedBBoxOfElement(magnet);\n    center = node.getBBox().getCenter();\n    angle = node.getAngle();\n  } else {\n    bbox = view.getBBoxOfElement(magnet);\n  }\n\n  var padding = options.padding;\n\n  if (padding != null && Number.isFinite(padding)) {\n    bbox.inflate(padding);\n  }\n\n  if (options.rotate) {\n    refPoint.rotate(angle, center);\n  }\n\n  var side = bbox.getNearestSideToPoint(refPoint);\n  var result;\n\n  switch (side) {\n    case 'left':\n      result = bbox.getLeftMiddle();\n      break;\n\n    case 'right':\n      result = bbox.getRightMiddle();\n      break;\n\n    case 'top':\n      result = bbox.getTopCenter();\n      break;\n\n    case 'bottom':\n      result = bbox.getBottomCenter();\n      break;\n\n    default:\n      break;\n  }\n\n  var direction = options.direction;\n\n  if (direction === 'H') {\n    if (side === 'top' || side === 'bottom') {\n      if (refPoint.x <= bbox.x + bbox.width) {\n        result = bbox.getLeftMiddle();\n      } else {\n        result = bbox.getRightMiddle();\n      }\n    }\n  } else if (direction === 'V') {\n    if (refPoint.y <= bbox.y + bbox.height) {\n      result = bbox.getTopCenter();\n    } else {\n      result = bbox.getBottomCenter();\n    }\n  }\n\n  return options.rotate ? result.rotate(-angle, center) : result;\n};\n/**\n * Places the anchor of the edge in the middle of the side of view bbox\n * closest to the other endpoint.\n */\n\n\nexport var midSide = resolve(middleSide);","map":{"version":3,"sources":["../../../src/registry/node-anchor/middle-side.ts"],"names":[],"mappings":"AAAA,SAAyB,OAAzB,QAAwC,QAAxC;;AAUA,IAAM,UAAU,GACd,SADI,UACJ,CAAU,IAAV,EAAgB,MAAhB,EAAwB,QAAxB,EAAkC,OAAlC,EAAyC;AACvC,MAAI,IAAJ;AACA,MAAI,KAAK,GAAG,CAAZ;AACA,MAAI,MAAJ;AAEA,MAAM,IAAI,GAAG,IAAI,CAAC,IAAlB;;AACA,MAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,IAAA,IAAI,GAAG,IAAI,CAAC,yBAAL,CAA+B,MAA/B,CAAP;AACA,IAAA,MAAM,GAAG,IAAI,CAAC,OAAL,GAAe,SAAf,EAAT;AACA,IAAA,KAAK,GAAG,IAAI,CAAC,QAAL,EAAR;AACD,GAJD,MAIO;AACL,IAAA,IAAI,GAAG,IAAI,CAAC,gBAAL,CAAsB,MAAtB,CAAP;AACD;;AAED,MAAM,OAAO,GAAG,OAAO,CAAC,OAAxB;;AACA,MAAI,OAAO,IAAI,IAAX,IAAmB,MAAM,CAAC,QAAP,CAAgB,OAAhB,CAAvB,EAAiD;AAC/C,IAAA,IAAI,CAAC,OAAL,CAAa,OAAb;AACD;;AAED,MAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,IAAA,QAAQ,CAAC,MAAT,CAAgB,KAAhB,EAAuB,MAAvB;AACD;;AAED,MAAM,IAAI,GAAG,IAAI,CAAC,qBAAL,CAA2B,QAA3B,CAAb;AACA,MAAI,MAAJ;;AACA,UAAQ,IAAR;AACE,SAAK,MAAL;AACE,MAAA,MAAM,GAAG,IAAI,CAAC,aAAL,EAAT;AACA;;AACF,SAAK,OAAL;AACE,MAAA,MAAM,GAAG,IAAI,CAAC,cAAL,EAAT;AACA;;AACF,SAAK,KAAL;AACE,MAAA,MAAM,GAAG,IAAI,CAAC,YAAL,EAAT;AACA;;AACF,SAAK,QAAL;AACE,MAAA,MAAM,GAAG,IAAI,CAAC,eAAL,EAAT;AACA;;AACF;AACE;AAdJ;;AAiBA,MAAM,SAAS,GAAG,OAAO,CAAC,SAA1B;;AACA,MAAI,SAAS,KAAK,GAAlB,EAAuB;AACrB,QAAI,IAAI,KAAK,KAAT,IAAkB,IAAI,KAAK,QAA/B,EAAyC;AACvC,UAAI,QAAQ,CAAC,CAAT,IAAc,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,KAAhC,EAAuC;AACrC,QAAA,MAAM,GAAG,IAAI,CAAC,aAAL,EAAT;AACD,OAFD,MAEO;AACL,QAAA,MAAM,GAAG,IAAI,CAAC,cAAL,EAAT;AACD;AACF;AACF,GARD,MAQO,IAAI,SAAS,KAAK,GAAlB,EAAuB;AAC5B,QAAI,QAAQ,CAAC,CAAT,IAAc,IAAI,CAAC,CAAL,GAAS,IAAI,CAAC,MAAhC,EAAwC;AACtC,MAAA,MAAM,GAAG,IAAI,CAAC,YAAL,EAAT;AACD,KAFD,MAEO;AACL,MAAA,MAAM,GAAG,IAAI,CAAC,eAAL,EAAT;AACD;AACF;;AAED,SAAO,OAAO,CAAC,MAAR,GAAiB,MAAO,CAAC,MAAR,CAAe,CAAC,KAAhB,EAAuB,MAAvB,CAAjB,GAAkD,MAAzD;AACD,CA7DH;AA+DA;;;AAGG;;;AACH,OAAO,IAAM,OAAO,GAAG,OAAO,CAG5B,UAH4B,CAAvB","sourceRoot":"","sourcesContent":["import { resolve } from './util';\nconst middleSide = function (view, magnet, refPoint, options) {\n    let bbox;\n    let angle = 0;\n    let center;\n    const node = view.cell;\n    if (options.rotate) {\n        bbox = view.getUnrotatedBBoxOfElement(magnet);\n        center = node.getBBox().getCenter();\n        angle = node.getAngle();\n    }\n    else {\n        bbox = view.getBBoxOfElement(magnet);\n    }\n    const padding = options.padding;\n    if (padding != null && Number.isFinite(padding)) {\n        bbox.inflate(padding);\n    }\n    if (options.rotate) {\n        refPoint.rotate(angle, center);\n    }\n    const side = bbox.getNearestSideToPoint(refPoint);\n    let result;\n    switch (side) {\n        case 'left':\n            result = bbox.getLeftMiddle();\n            break;\n        case 'right':\n            result = bbox.getRightMiddle();\n            break;\n        case 'top':\n            result = bbox.getTopCenter();\n            break;\n        case 'bottom':\n            result = bbox.getBottomCenter();\n            break;\n        default:\n            break;\n    }\n    const direction = options.direction;\n    if (direction === 'H') {\n        if (side === 'top' || side === 'bottom') {\n            if (refPoint.x <= bbox.x + bbox.width) {\n                result = bbox.getLeftMiddle();\n            }\n            else {\n                result = bbox.getRightMiddle();\n            }\n        }\n    }\n    else if (direction === 'V') {\n        if (refPoint.y <= bbox.y + bbox.height) {\n            result = bbox.getTopCenter();\n        }\n        else {\n            result = bbox.getBottomCenter();\n        }\n    }\n    return options.rotate ? result.rotate(-angle, center) : result;\n};\n/**\n * Places the anchor of the edge in the middle of the side of view bbox\n * closest to the other endpoint.\n */\nexport const midSide = resolve(middleSide);\n//# sourceMappingURL=middle-side.js.map"]},"metadata":{},"sourceType":"module"}