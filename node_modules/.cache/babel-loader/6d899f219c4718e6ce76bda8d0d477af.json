{"ast":null,"code":"import _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { ArrayExt } from '../../util';\nimport { Point, Line, Angle } from '../../geometry';\nimport * as Util from './util';\n/**\n * Returns a route with orthogonal line segments.\n */\n\nexport var orth = function orth(vertices, options, edgeView) {\n  var sourceBBox = Util.getSourceBBox(edgeView, options);\n  var targetBBox = Util.getTargetBBox(edgeView, options);\n  var sourceAnchor = Util.getSourceAnchor(edgeView, options);\n  var targetAnchor = Util.getTargetAnchor(edgeView, options); // If anchor lies outside of bbox, the bbox expands to include it\n\n  sourceBBox = sourceBBox.union(Util.getPointBBox(sourceAnchor));\n  targetBBox = targetBBox.union(Util.getPointBBox(targetAnchor));\n  var points = vertices.map(function (p) {\n    return Point.create(p);\n  });\n  points.unshift(sourceAnchor);\n  points.push(targetAnchor); // bearing of previous route segment\n\n  var bearing = null;\n  var result = [];\n\n  for (var i = 0, len = points.length - 1; i < len; i += 1) {\n    var route = null;\n    var from = points[i];\n    var to = points[i + 1];\n    var isOrthogonal = Private.getBearing(from, to) != null;\n\n    if (i === 0) {\n      // source\n      if (i + 1 === len) {\n        // source -> target\n        // Expand one of the nodes by 1px to detect situations when the two\n        // nodes are positioned next to each other with no gap in between.\n        if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {\n          route = Private.insideNode(from, to, sourceBBox, targetBBox);\n        } else if (!isOrthogonal) {\n          route = Private.nodeToNode(from, to, sourceBBox, targetBBox);\n        }\n      } else {\n        // source -> vertex\n        if (sourceBBox.containsPoint(to)) {\n          route = Private.insideNode(from, to, sourceBBox, Util.getPointBBox(to).moveAndExpand(Util.getPaddingBox(options)));\n        } else if (!isOrthogonal) {\n          route = Private.nodeToVertex(from, to, sourceBBox);\n        }\n      }\n    } else if (i + 1 === len) {\n      // vertex -> target\n      // prevent overlaps with previous line segment\n      var isOrthogonalLoop = isOrthogonal && Private.getBearing(to, from) === bearing;\n\n      if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n        route = Private.insideNode(from, to, Util.getPointBBox(from).moveAndExpand(Util.getPaddingBox(options)), targetBBox, bearing);\n      } else if (!isOrthogonal) {\n        route = Private.vertexToNode(from, to, targetBBox, bearing);\n      }\n    } else if (!isOrthogonal) {\n      // vertex -> vertex\n      route = Private.vertexToVertex(from, to, bearing);\n    } // set bearing for next iteration\n\n\n    if (route) {\n      result.push.apply(result, _toConsumableArray(route.points));\n      bearing = route.direction;\n    } else {\n      // orthogonal route and not looped\n      bearing = Private.getBearing(from, to);\n    } // push `to` point to identified orthogonal vertices array\n\n\n    if (i + 1 < len) {\n      result.push(to);\n    }\n  }\n\n  return result;\n};\nvar Private;\n\n(function (Private) {\n  /**\n   * Bearing to opposite bearing map\n   */\n  var opposites = {\n    N: 'S',\n    S: 'N',\n    E: 'W',\n    W: 'E'\n  };\n  /**\n   * Bearing to radians map\n   */\n\n  var radians = {\n    N: -Math.PI / 2 * 3,\n    S: -Math.PI / 2,\n    E: 0,\n    W: Math.PI\n  };\n  /**\n   * Returns a point `p` where lines p,p1 and p,p2 are perpendicular\n   * and p is not contained in the given box\n   */\n\n  function freeJoin(p1, p2, bbox) {\n    var p = new Point(p1.x, p2.y);\n\n    if (bbox.containsPoint(p)) {\n      p = new Point(p2.x, p1.y);\n    } // kept for reference\n    // if (bbox.containsPoint(p)) {\n    //   return null\n    // }\n\n\n    return p;\n  }\n  /**\n   * Returns either width or height of a bbox based on the given bearing.\n   */\n\n\n  function getBBoxSize(bbox, bearing) {\n    return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];\n  }\n\n  Private.getBBoxSize = getBBoxSize;\n\n  function getBearing(from, to) {\n    if (from.x === to.x) {\n      return from.y > to.y ? 'N' : 'S';\n    }\n\n    if (from.y === to.y) {\n      return from.x > to.x ? 'W' : 'E';\n    }\n\n    return null;\n  }\n\n  Private.getBearing = getBearing;\n\n  function vertexToVertex(from, to, bearing) {\n    var p1 = new Point(from.x, to.y);\n    var p2 = new Point(to.x, from.y);\n    var d1 = getBearing(from, p1);\n    var d2 = getBearing(from, p2);\n    var opposite = bearing ? opposites[bearing] : null;\n    var p = d1 === bearing || d1 !== opposite && (d2 === opposite || d2 !== bearing) ? p1 : p2;\n    return {\n      points: [p],\n      direction: getBearing(p, to)\n    };\n  }\n\n  Private.vertexToVertex = vertexToVertex;\n\n  function nodeToVertex(from, to, fromBBox) {\n    var p = freeJoin(from, to, fromBBox);\n    return {\n      points: [p],\n      direction: getBearing(p, to)\n    };\n  }\n\n  Private.nodeToVertex = nodeToVertex;\n\n  function vertexToNode(from, to, toBBox, bearing) {\n    var points = [new Point(from.x, to.y), new Point(to.x, from.y)];\n    var freePoints = points.filter(function (p) {\n      return !toBBox.containsPoint(p);\n    });\n    var freeBearingPoints = freePoints.filter(function (p) {\n      return getBearing(p, from) !== bearing;\n    });\n    var p;\n\n    if (freeBearingPoints.length > 0) {\n      // Try to pick a point which bears the same direction as the previous segment.\n      p = freeBearingPoints.filter(function (p) {\n        return getBearing(from, p) === bearing;\n      }).pop();\n      p = p || freeBearingPoints[0];\n      return {\n        points: [p],\n        direction: getBearing(p, to)\n      };\n    }\n\n    {\n      // Here we found only points which are either contained in the element or they would create\n      // a link segment going in opposite direction from the previous one.\n      // We take the point inside element and move it outside the element in the direction the\n      // route is going. Now we can join this point with the current end (using freeJoin).\n      p = ArrayExt.difference(points, freePoints)[0];\n      var p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n      var p1 = freeJoin(p2, from, toBBox);\n      return {\n        points: [p1, p2],\n        direction: getBearing(p2, to)\n      };\n    }\n  }\n\n  Private.vertexToNode = vertexToNode;\n\n  function nodeToNode(from, to, fromBBox, toBBox) {\n    var route = nodeToVertex(to, from, toBBox);\n    var p1 = route.points[0];\n\n    if (fromBBox.containsPoint(p1)) {\n      route = nodeToVertex(from, to, fromBBox);\n      var p2 = route.points[0];\n\n      if (toBBox.containsPoint(p2)) {\n        var fromBorder = Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n        var toBorder = Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n        var mid = new Line(fromBorder, toBorder).getCenter();\n        var startRoute = nodeToVertex(from, mid, fromBBox);\n        var endRoute = vertexToVertex(mid, to, startRoute.direction);\n        route.points = [startRoute.points[0], endRoute.points[0]];\n        route.direction = endRoute.direction;\n      }\n    }\n\n    return route;\n  }\n\n  Private.nodeToNode = nodeToNode; // Finds route for situations where one node is inside the other.\n  // Typically the route is directed outside the outer node first and\n  // then back towards the inner node.\n\n  function insideNode(from, to, fromBBox, toBBox, bearing) {\n    var boundary = fromBBox.union(toBBox).inflate(1); // start from the point which is closer to the boundary\n\n    var center = boundary.getCenter();\n    var reversed = center.distance(to) > center.distance(from);\n    var start = reversed ? to : from;\n    var end = reversed ? from : to;\n    var p1;\n    var p2;\n    var p3;\n\n    if (bearing) {\n      // Points on circle with radius equals 'W + H` are always outside the rectangle\n      // with width W and height H if the center of that circle is the center of that rectangle.\n      p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n      p1 = boundary.getNearestPointToPoint(p1).move(p1, -1);\n    } else {\n      p1 = boundary.getNearestPointToPoint(start).move(start, 1);\n    }\n\n    p2 = freeJoin(p1, end, boundary);\n    var points;\n\n    if (p1.round().equals(p2.round())) {\n      p2 = Point.fromPolar(boundary.width + boundary.height, Angle.toRad(p1.theta(start)) + Math.PI / 2, end);\n      p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round();\n      p3 = freeJoin(p1, p2, boundary);\n      points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n    } else {\n      points = reversed ? [p2, p1] : [p1, p2];\n    }\n\n    var direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n    return {\n      points: points,\n      direction: direction\n    };\n  }\n\n  Private.insideNode = insideNode;\n})(Private || (Private = {}));","map":{"version":3,"sources":["../../../src/registry/router/orth.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ArrayExt } from '../../util';\nimport { Point, Line, Angle } from '../../geometry';\nimport * as Util from './util';\n/**\n * Returns a route with orthogonal line segments.\n */\nexport const orth = function (vertices, options, edgeView) {\n    let sourceBBox = Util.getSourceBBox(edgeView, options);\n    let targetBBox = Util.getTargetBBox(edgeView, options);\n    const sourceAnchor = Util.getSourceAnchor(edgeView, options);\n    const targetAnchor = Util.getTargetAnchor(edgeView, options);\n    // If anchor lies outside of bbox, the bbox expands to include it\n    sourceBBox = sourceBBox.union(Util.getPointBBox(sourceAnchor));\n    targetBBox = targetBBox.union(Util.getPointBBox(targetAnchor));\n    const points = vertices.map((p) => Point.create(p));\n    points.unshift(sourceAnchor);\n    points.push(targetAnchor);\n    // bearing of previous route segment\n    let bearing = null;\n    const result = [];\n    for (let i = 0, len = points.length - 1; i < len; i += 1) {\n        let route = null;\n        const from = points[i];\n        const to = points[i + 1];\n        const isOrthogonal = Private.getBearing(from, to) != null;\n        if (i === 0) {\n            // source\n            if (i + 1 === len) {\n                // source -> target\n                // Expand one of the nodes by 1px to detect situations when the two\n                // nodes are positioned next to each other with no gap in between.\n                if (sourceBBox.intersectsWithRect(targetBBox.clone().inflate(1))) {\n                    route = Private.insideNode(from, to, sourceBBox, targetBBox);\n                }\n                else if (!isOrthogonal) {\n                    route = Private.nodeToNode(from, to, sourceBBox, targetBBox);\n                }\n            }\n            else {\n                // source -> vertex\n                if (sourceBBox.containsPoint(to)) {\n                    route = Private.insideNode(from, to, sourceBBox, Util.getPointBBox(to).moveAndExpand(Util.getPaddingBox(options)));\n                }\n                else if (!isOrthogonal) {\n                    route = Private.nodeToVertex(from, to, sourceBBox);\n                }\n            }\n        }\n        else if (i + 1 === len) {\n            // vertex -> target\n            // prevent overlaps with previous line segment\n            const isOrthogonalLoop = isOrthogonal && Private.getBearing(to, from) === bearing;\n            if (targetBBox.containsPoint(from) || isOrthogonalLoop) {\n                route = Private.insideNode(from, to, Util.getPointBBox(from).moveAndExpand(Util.getPaddingBox(options)), targetBBox, bearing);\n            }\n            else if (!isOrthogonal) {\n                route = Private.vertexToNode(from, to, targetBBox, bearing);\n            }\n        }\n        else if (!isOrthogonal) {\n            // vertex -> vertex\n            route = Private.vertexToVertex(from, to, bearing);\n        }\n        // set bearing for next iteration\n        if (route) {\n            result.push(...route.points);\n            bearing = route.direction;\n        }\n        else {\n            // orthogonal route and not looped\n            bearing = Private.getBearing(from, to);\n        }\n        // push `to` point to identified orthogonal vertices array\n        if (i + 1 < len) {\n            result.push(to);\n        }\n    }\n    return result;\n};\nvar Private;\n(function (Private) {\n    /**\n     * Bearing to opposite bearing map\n     */\n    const opposites = {\n        N: 'S',\n        S: 'N',\n        E: 'W',\n        W: 'E',\n    };\n    /**\n     * Bearing to radians map\n     */\n    const radians = {\n        N: (-Math.PI / 2) * 3,\n        S: -Math.PI / 2,\n        E: 0,\n        W: Math.PI,\n    };\n    /**\n     * Returns a point `p` where lines p,p1 and p,p2 are perpendicular\n     * and p is not contained in the given box\n     */\n    function freeJoin(p1, p2, bbox) {\n        let p = new Point(p1.x, p2.y);\n        if (bbox.containsPoint(p)) {\n            p = new Point(p2.x, p1.y);\n        }\n        // kept for reference\n        // if (bbox.containsPoint(p)) {\n        //   return null\n        // }\n        return p;\n    }\n    /**\n     * Returns either width or height of a bbox based on the given bearing.\n     */\n    function getBBoxSize(bbox, bearing) {\n        return bbox[bearing === 'W' || bearing === 'E' ? 'width' : 'height'];\n    }\n    Private.getBBoxSize = getBBoxSize;\n    function getBearing(from, to) {\n        if (from.x === to.x) {\n            return from.y > to.y ? 'N' : 'S';\n        }\n        if (from.y === to.y) {\n            return from.x > to.x ? 'W' : 'E';\n        }\n        return null;\n    }\n    Private.getBearing = getBearing;\n    function vertexToVertex(from, to, bearing) {\n        const p1 = new Point(from.x, to.y);\n        const p2 = new Point(to.x, from.y);\n        const d1 = getBearing(from, p1);\n        const d2 = getBearing(from, p2);\n        const opposite = bearing ? opposites[bearing] : null;\n        const p = d1 === bearing || (d1 !== opposite && (d2 === opposite || d2 !== bearing))\n            ? p1\n            : p2;\n        return { points: [p], direction: getBearing(p, to) };\n    }\n    Private.vertexToVertex = vertexToVertex;\n    function nodeToVertex(from, to, fromBBox) {\n        const p = freeJoin(from, to, fromBBox);\n        return { points: [p], direction: getBearing(p, to) };\n    }\n    Private.nodeToVertex = nodeToVertex;\n    function vertexToNode(from, to, toBBox, bearing) {\n        const points = [new Point(from.x, to.y), new Point(to.x, from.y)];\n        const freePoints = points.filter((p) => !toBBox.containsPoint(p));\n        const freeBearingPoints = freePoints.filter((p) => getBearing(p, from) !== bearing);\n        let p;\n        if (freeBearingPoints.length > 0) {\n            // Try to pick a point which bears the same direction as the previous segment.\n            p = freeBearingPoints.filter((p) => getBearing(from, p) === bearing).pop();\n            p = p || freeBearingPoints[0];\n            return {\n                points: [p],\n                direction: getBearing(p, to),\n            };\n        }\n        {\n            // Here we found only points which are either contained in the element or they would create\n            // a link segment going in opposite direction from the previous one.\n            // We take the point inside element and move it outside the element in the direction the\n            // route is going. Now we can join this point with the current end (using freeJoin).\n            p = ArrayExt.difference(points, freePoints)[0];\n            const p2 = Point.create(to).move(p, -getBBoxSize(toBBox, bearing) / 2);\n            const p1 = freeJoin(p2, from, toBBox);\n            return {\n                points: [p1, p2],\n                direction: getBearing(p2, to),\n            };\n        }\n    }\n    Private.vertexToNode = vertexToNode;\n    function nodeToNode(from, to, fromBBox, toBBox) {\n        let route = nodeToVertex(to, from, toBBox);\n        const p1 = route.points[0];\n        if (fromBBox.containsPoint(p1)) {\n            route = nodeToVertex(from, to, fromBBox);\n            const p2 = route.points[0];\n            if (toBBox.containsPoint(p2)) {\n                const fromBorder = Point.create(from).move(p2, -getBBoxSize(fromBBox, getBearing(from, p2)) / 2);\n                const toBorder = Point.create(to).move(p1, -getBBoxSize(toBBox, getBearing(to, p1)) / 2);\n                const mid = new Line(fromBorder, toBorder).getCenter();\n                const startRoute = nodeToVertex(from, mid, fromBBox);\n                const endRoute = vertexToVertex(mid, to, startRoute.direction);\n                route.points = [startRoute.points[0], endRoute.points[0]];\n                route.direction = endRoute.direction;\n            }\n        }\n        return route;\n    }\n    Private.nodeToNode = nodeToNode;\n    // Finds route for situations where one node is inside the other.\n    // Typically the route is directed outside the outer node first and\n    // then back towards the inner node.\n    function insideNode(from, to, fromBBox, toBBox, bearing) {\n        const boundary = fromBBox.union(toBBox).inflate(1);\n        // start from the point which is closer to the boundary\n        const center = boundary.getCenter();\n        const reversed = center.distance(to) > center.distance(from);\n        const start = reversed ? to : from;\n        const end = reversed ? from : to;\n        let p1;\n        let p2;\n        let p3;\n        if (bearing) {\n            // Points on circle with radius equals 'W + H` are always outside the rectangle\n            // with width W and height H if the center of that circle is the center of that rectangle.\n            p1 = Point.fromPolar(boundary.width + boundary.height, radians[bearing], start);\n            p1 = boundary.getNearestPointToPoint(p1).move(p1, -1);\n        }\n        else {\n            p1 = boundary.getNearestPointToPoint(start).move(start, 1);\n        }\n        p2 = freeJoin(p1, end, boundary);\n        let points;\n        if (p1.round().equals(p2.round())) {\n            p2 = Point.fromPolar(boundary.width + boundary.height, Angle.toRad(p1.theta(start)) + Math.PI / 2, end);\n            p2 = boundary.getNearestPointToPoint(p2).move(end, 1).round();\n            p3 = freeJoin(p1, p2, boundary);\n            points = reversed ? [p2, p3, p1] : [p1, p3, p2];\n        }\n        else {\n            points = reversed ? [p2, p1] : [p1, p2];\n        }\n        const direction = reversed ? getBearing(p1, to) : getBearing(p2, to);\n        return {\n            points,\n            direction,\n        };\n    }\n    Private.insideNode = insideNode;\n})(Private || (Private = {}));\n//# sourceMappingURL=orth.js.map"]},"metadata":{},"sourceType":"module"}