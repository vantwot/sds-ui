{"ast":null,"code":"import _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport { Line } from '../../geometry';\nimport { resolve, getPointAtEdge } from '../node-anchor/util';\nimport { getClosestPoint } from './closest';\nimport { FunctionExt } from '../../util';\n\nvar orthogonal = function orthogonal(view, magnet, refPoint, options) {\n  var OFFSET = 1e6;\n  var path = view.getConnection();\n  var segmentSubdivisions = view.getConnectionSubdivisions();\n  var vLine = new Line(refPoint.clone().translate(0, OFFSET), refPoint.clone().translate(0, -OFFSET));\n  var hLine = new Line(refPoint.clone().translate(OFFSET, 0), refPoint.clone().translate(-OFFSET, 0));\n  var vIntersections = vLine.intersect(path, {\n    segmentSubdivisions: segmentSubdivisions\n  });\n  var hIntersections = hLine.intersect(path, {\n    segmentSubdivisions: segmentSubdivisions\n  });\n  var intersections = [];\n\n  if (vIntersections) {\n    intersections.push.apply(intersections, _toConsumableArray(vIntersections));\n  }\n\n  if (hIntersections) {\n    intersections.push.apply(intersections, _toConsumableArray(hIntersections));\n  }\n\n  if (intersections.length > 0) {\n    return refPoint.closest(intersections);\n  }\n\n  if (options.fallbackAt != null) {\n    return getPointAtEdge(view, options.fallbackAt);\n  }\n\n  return FunctionExt.call(getClosestPoint, this, view, magnet, refPoint, options);\n};\n\nexport var orth = resolve(orthogonal);","map":{"version":3,"sources":["../../../src/registry/edge-anchor/orth.ts"],"names":[],"mappings":";AAAA,SAAS,IAAT,QAA4B,gBAA5B;AACA,SAAyB,OAAzB,EAAkC,cAAlC,QAAwD,qBAAxD;AACA,SAAS,eAAT,QAAgC,WAAhC;AAEA,SAAS,WAAT,QAA4B,YAA5B;;AAMA,IAAM,UAAU,GACd,SADI,UACJ,CAAU,IAAV,EAAgB,MAAhB,EAAwB,QAAxB,EAAkC,OAAlC,EAAyC;AACvC,MAAM,MAAM,GAAG,GAAf;AACA,MAAM,IAAI,GAAG,IAAI,CAAC,aAAL,EAAb;AACA,MAAM,mBAAmB,GAAG,IAAI,CAAC,yBAAL,EAA5B;AACA,MAAM,KAAK,GAAG,IAAI,IAAJ,CACZ,QAAQ,CAAC,KAAT,GAAiB,SAAjB,CAA2B,CAA3B,EAA8B,MAA9B,CADY,EAEZ,QAAQ,CAAC,KAAT,GAAiB,SAAjB,CAA2B,CAA3B,EAA8B,CAAC,MAA/B,CAFY,CAAd;AAIA,MAAM,KAAK,GAAG,IAAI,IAAJ,CACZ,QAAQ,CAAC,KAAT,GAAiB,SAAjB,CAA2B,MAA3B,EAAmC,CAAnC,CADY,EAEZ,QAAQ,CAAC,KAAT,GAAiB,SAAjB,CAA2B,CAAC,MAA5B,EAAoC,CAApC,CAFY,CAAd;AAKA,MAAM,cAAc,GAAG,KAAK,CAAC,SAAN,CAAgB,IAAhB,EAAsB;AAC3C,IAAA,mBAAmB,EAAnB;AAD2C,GAAtB,CAAvB;AAIA,MAAM,cAAc,GAAG,KAAK,CAAC,SAAN,CAAgB,IAAhB,EAAsB;AAC3C,IAAA,mBAAmB,EAAnB;AAD2C,GAAtB,CAAvB;AAIA,MAAM,aAAa,GAAG,EAAtB;;AACA,MAAI,cAAJ,EAAoB;AAClB,IAAA,aAAa,CAAC,IAAd,OAAA,aAAa,qBAAS,cAAT,EAAb;AACD;;AACD,MAAI,cAAJ,EAAoB;AAClB,IAAA,aAAa,CAAC,IAAd,OAAA,aAAa,qBAAS,cAAT,EAAb;AACD;;AAED,MAAI,aAAa,CAAC,MAAd,GAAuB,CAA3B,EAA8B;AAC5B,WAAO,QAAQ,CAAC,OAAT,CAAiB,aAAjB,CAAP;AACD;;AAED,MAAI,OAAO,CAAC,UAAR,IAAsB,IAA1B,EAAgC;AAC9B,WAAO,cAAc,CAAC,IAAD,EAAO,OAAO,CAAC,UAAf,CAArB;AACD;;AAED,SAAO,WAAW,CAAC,IAAZ,CACL,eADK,EAEL,IAFK,EAGL,IAHK,EAIL,MAJK,EAKL,QALK,EAML,OANK,CAAP;AAQD,CA9CH;;AAgDA,OAAO,IAAM,IAAI,GAAG,OAAO,CAGzB,UAHyB,CAApB","sourceRoot":"","sourcesContent":["import { Line } from '../../geometry';\nimport { resolve, getPointAtEdge } from '../node-anchor/util';\nimport { getClosestPoint } from './closest';\nimport { FunctionExt } from '../../util';\nconst orthogonal = function (view, magnet, refPoint, options) {\n    const OFFSET = 1e6;\n    const path = view.getConnection();\n    const segmentSubdivisions = view.getConnectionSubdivisions();\n    const vLine = new Line(refPoint.clone().translate(0, OFFSET), refPoint.clone().translate(0, -OFFSET));\n    const hLine = new Line(refPoint.clone().translate(OFFSET, 0), refPoint.clone().translate(-OFFSET, 0));\n    const vIntersections = vLine.intersect(path, {\n        segmentSubdivisions,\n    });\n    const hIntersections = hLine.intersect(path, {\n        segmentSubdivisions,\n    });\n    const intersections = [];\n    if (vIntersections) {\n        intersections.push(...vIntersections);\n    }\n    if (hIntersections) {\n        intersections.push(...hIntersections);\n    }\n    if (intersections.length > 0) {\n        return refPoint.closest(intersections);\n    }\n    if (options.fallbackAt != null) {\n        return getPointAtEdge(view, options.fallbackAt);\n    }\n    return FunctionExt.call(getClosestPoint, this, view, magnet, refPoint, options);\n};\nexport const orth = resolve(orthogonal);\n//# sourceMappingURL=orth.js.map"]},"metadata":{},"sourceType":"module"}