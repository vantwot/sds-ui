{"ast":null,"code":"import { Ellipse } from '../../geometry';\nimport { toResult } from './util';\nexport var ellipse = function ellipse(portsPositionArgs, elemBBox, groupPositionArgs) {\n  var startAngle = groupPositionArgs.start || 0;\n  var stepAngle = groupPositionArgs.step || 20;\n  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, function (index, count) {\n    return (index + 0.5 - count / 2) * stepAngle;\n  });\n};\nexport var ellipseSpread = function ellipseSpread(portsPositionArgs, elemBBox, groupPositionArgs) {\n  var startAngle = groupPositionArgs.start || 0;\n  var stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;\n  return ellipseLayout(portsPositionArgs, elemBBox, startAngle, function (index) {\n    return index * stepAngle;\n  });\n};\n\nfunction ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {\n  var center = elemBBox.getCenter();\n  var start = elemBBox.getTopCenter();\n  var ratio = elemBBox.width / elemBBox.height;\n  var ellipse = Ellipse.fromRect(elemBBox);\n  var count = portsPositionArgs.length;\n  return portsPositionArgs.map(function (item, index) {\n    var angle = startAngle + stepFn(index, count);\n    var p = start.clone().rotate(-angle, center).scale(ratio, 1, center);\n    var theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0;\n\n    if (item.dx || item.dy) {\n      p.translate(item.dx || 0, item.dy || 0);\n    }\n\n    if (item.dr) {\n      p.move(center, item.dr);\n    }\n\n    return toResult(p.round(), theta, item);\n  });\n}","map":{"version":3,"sources":["../../../src/registry/port-layout/ellipse.ts"],"names":[],"mappings":"AAAA,SAAoB,OAApB,QAAmC,gBAAnC;AAEA,SAAS,QAAT,QAAyB,QAAzB;AAYA,OAAO,IAAM,OAAO,GAAuC,SAA9C,OAA8C,CACzD,iBADyD,EAEzD,QAFyD,EAGzD,iBAHyD,EAIvD;AACF,MAAM,UAAU,GAAG,iBAAiB,CAAC,KAAlB,IAA2B,CAA9C;AACA,MAAM,SAAS,GAAG,iBAAiB,CAAC,IAAlB,IAA0B,EAA5C;AAEA,SAAO,aAAa,CAClB,iBADkB,EAElB,QAFkB,EAGlB,UAHkB,EAIlB,UAAC,KAAD,EAAQ,KAAR;AAAA,WAAkB,CAAC,KAAK,GAAG,GAAR,GAAc,KAAK,GAAG,CAAvB,IAA4B,SAA9C;AAAA,GAJkB,CAApB;AAMD,CAdM;AAgBP,OAAO,IAAM,aAAa,GAAuC,SAApD,aAAoD,CAC/D,iBAD+D,EAE/D,QAF+D,EAG/D,iBAH+D,EAI7D;AACF,MAAM,UAAU,GAAG,iBAAiB,CAAC,KAAlB,IAA2B,CAA9C;AACA,MAAM,SAAS,GAAG,iBAAiB,CAAC,IAAlB,IAA0B,MAAM,iBAAiB,CAAC,MAApE;AAEA,SAAO,aAAa,CAAC,iBAAD,EAAoB,QAApB,EAA8B,UAA9B,EAA0C,UAAC,KAAD,EAAU;AACtE,WAAO,KAAK,GAAG,SAAf;AACD,GAFmB,CAApB;AAGD,CAXM;;AAaP,SAAS,aAAT,CACE,iBADF,EAEE,QAFF,EAGE,UAHF,EAIE,MAJF,EAIkD;AAEhD,MAAM,MAAM,GAAG,QAAQ,CAAC,SAAT,EAAf;AACA,MAAM,KAAK,GAAG,QAAQ,CAAC,YAAT,EAAd;AACA,MAAM,KAAK,GAAG,QAAQ,CAAC,KAAT,GAAiB,QAAQ,CAAC,MAAxC;AACA,MAAM,OAAO,GAAG,OAAO,CAAC,QAAR,CAAiB,QAAjB,CAAhB;AACA,MAAM,KAAK,GAAG,iBAAiB,CAAC,MAAhC;AAEA,SAAO,iBAAiB,CAAC,GAAlB,CAAsB,UAAC,IAAD,EAAO,KAAP,EAAgB;AAC3C,QAAM,KAAK,GAAG,UAAU,GAAG,MAAM,CAAC,KAAD,EAAQ,KAAR,CAAjC;AACA,QAAM,CAAC,GAAG,KAAK,CAAC,KAAN,GAAc,MAAd,CAAqB,CAAC,KAAtB,EAA6B,MAA7B,EAAqC,KAArC,CAA2C,KAA3C,EAAkD,CAAlD,EAAqD,MAArD,CAAV;AAEA,QAAM,KAAK,GAAG,IAAI,CAAC,gBAAL,GAAwB,CAAC,OAAO,CAAC,YAAR,CAAqB,CAArB,CAAzB,GAAmD,CAAjE;;AAEA,QAAI,IAAI,CAAC,EAAL,IAAW,IAAI,CAAC,EAApB,EAAwB;AACtB,MAAA,CAAC,CAAC,SAAF,CAAY,IAAI,CAAC,EAAL,IAAW,CAAvB,EAA0B,IAAI,CAAC,EAAL,IAAW,CAArC;AACD;;AAED,QAAI,IAAI,CAAC,EAAT,EAAa;AACX,MAAA,CAAC,CAAC,IAAF,CAAO,MAAP,EAAe,IAAI,CAAC,EAApB;AACD;;AAED,WAAO,QAAQ,CAAC,CAAC,CAAC,KAAF,EAAD,EAAY,KAAZ,EAAmB,IAAnB,CAAf;AACD,GAfM,CAAP;AAgBD","sourceRoot":"","sourcesContent":["import { Ellipse } from '../../geometry';\nimport { toResult } from './util';\nexport const ellipse = (portsPositionArgs, elemBBox, groupPositionArgs) => {\n    const startAngle = groupPositionArgs.start || 0;\n    const stepAngle = groupPositionArgs.step || 20;\n    return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index, count) => (index + 0.5 - count / 2) * stepAngle);\n};\nexport const ellipseSpread = (portsPositionArgs, elemBBox, groupPositionArgs) => {\n    const startAngle = groupPositionArgs.start || 0;\n    const stepAngle = groupPositionArgs.step || 360 / portsPositionArgs.length;\n    return ellipseLayout(portsPositionArgs, elemBBox, startAngle, (index) => {\n        return index * stepAngle;\n    });\n};\nfunction ellipseLayout(portsPositionArgs, elemBBox, startAngle, stepFn) {\n    const center = elemBBox.getCenter();\n    const start = elemBBox.getTopCenter();\n    const ratio = elemBBox.width / elemBBox.height;\n    const ellipse = Ellipse.fromRect(elemBBox);\n    const count = portsPositionArgs.length;\n    return portsPositionArgs.map((item, index) => {\n        const angle = startAngle + stepFn(index, count);\n        const p = start.clone().rotate(-angle, center).scale(ratio, 1, center);\n        const theta = item.compensateRotate ? -ellipse.tangentTheta(p) : 0;\n        if (item.dx || item.dy) {\n            p.translate(item.dx || 0, item.dy || 0);\n        }\n        if (item.dr) {\n            p.move(center, item.dr);\n        }\n        return toResult(p.round(), theta, item);\n    });\n}\n//# sourceMappingURL=ellipse.js.map"]},"metadata":{},"sourceType":"module"}