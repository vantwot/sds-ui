{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Platform, NumberExt, ObjectExt, Dom, FunctionExt } from '../../util';\nimport { Point, Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Renderer } from '../../graph/renderer';\nimport { GraphView } from '../../graph/view';\nimport { BackgroundManager } from '../../graph/background';\nexport class Scroller extends View {\n  constructor(options) {\n    super();\n    this.padding = {\n      left: 0,\n      top: 0,\n      right: 0,\n      bottom: 0\n    };\n    this.options = Util.getOptions(options);\n    const scale = this.graph.transform.getScale();\n    this.sx = scale.sx;\n    this.sy = scale.sy;\n    const width = this.options.width || this.graph.options.width;\n    const height = this.options.height || this.graph.options.height;\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container).addClass(this.prefixClassName(Util.containerClass)).css({\n      width,\n      height\n    });\n\n    if (this.options.pageVisible) {\n      this.$container.addClass(this.prefixClassName(Util.pagedClass));\n    }\n\n    if (this.options.className) {\n      this.$container.addClass(this.options.className);\n    }\n\n    const graphContainer = this.graph.container;\n\n    if (graphContainer.parentNode) {\n      this.$container.insertBefore(graphContainer);\n    } // copy style\n\n\n    const style = graphContainer.getAttribute('style');\n\n    if (style) {\n      const obj = {};\n      const styles = style.split(';');\n      styles.forEach(item => {\n        const section = item.trim();\n\n        if (section) {\n          const pair = section.split(':');\n\n          if (pair.length) {\n            obj[pair[0].trim()] = pair[1] ? pair[1].trim() : '';\n          }\n        }\n      });\n      Object.keys(obj).forEach(key => {\n        if (key === 'width' || key === 'height') {\n          return;\n        }\n\n        graphContainer.style[key] = '';\n        this.container.style[key] = obj[key];\n      });\n    }\n\n    this.content = document.createElement('div');\n    this.$content = this.$(this.content).addClass(this.prefixClassName(Util.contentClass)).css({\n      width: this.graph.options.width,\n      height: this.graph.options.height\n    }); // custom background\n\n    this.background = document.createElement('div');\n    this.$background = this.$(this.background).addClass(this.prefixClassName(Util.backgroundClass));\n    this.$content.append(this.background);\n\n    if (!this.options.pageVisible) {\n      this.$content.append(this.graph.view.grid);\n    }\n\n    this.$content.append(graphContainer);\n    this.$content.appendTo(this.container);\n    this.startListening();\n\n    if (!this.options.pageVisible) {\n      this.graph.grid.update();\n    }\n\n    this.backgroundManager = new Scroller.Background(this);\n\n    if (!this.options.autoResize) {\n      this.update();\n    }\n  }\n\n  get graph() {\n    return this.options.graph;\n  }\n\n  get model() {\n    return this.graph.model;\n  }\n\n  startListening() {\n    const graph = this.graph;\n    const model = this.model;\n    graph.on('scale', this.onScale, this);\n    graph.on('resize', this.onResize, this);\n    graph.on('before:print', this.storeScrollPosition, this);\n    graph.on('before:export', this.storeScrollPosition, this);\n    graph.on('after:print', this.restoreScrollPosition, this);\n    graph.on('after:export', this.restoreScrollPosition, this);\n    graph.on('render:done', this.onRenderDone, this);\n    graph.on('unfreeze', this.onUpdate, this);\n    model.on('reseted', this.onUpdate, this);\n    model.on('cell:added', this.onUpdate, this);\n    model.on('cell:removed', this.onUpdate, this);\n    model.on('cell:changed', this.onUpdate, this);\n    model.on('batch:stop', this.onBatchStop, this);\n    this.delegateBackgroundEvents();\n  }\n\n  stopListening() {\n    const graph = this.graph;\n    const model = this.model;\n    graph.off('scale', this.onScale, this);\n    graph.off('resize', this.onResize, this);\n    graph.off('beforeprint', this.storeScrollPosition, this);\n    graph.off('beforeexport', this.storeScrollPosition, this);\n    graph.off('afterprint', this.restoreScrollPosition, this);\n    graph.off('afterexport', this.restoreScrollPosition, this);\n    graph.off('render:done', this.onRenderDone, this);\n    graph.off('unfreeze', this.onUpdate, this);\n    model.off('reseted', this.onUpdate, this);\n    model.off('cell:added', this.onUpdate, this);\n    model.off('cell:removed', this.onUpdate, this);\n    model.off('cell:changed', this.onUpdate, this);\n    model.off('batch:stop', this.onBatchStop, this);\n    this.undelegateBackgroundEvents();\n  }\n\n  enableAutoResize() {\n    this.options.autoResize = true;\n  }\n\n  disableAutoResize() {\n    this.options.autoResize = false;\n  }\n\n  onUpdate() {\n    if (this.graph.isAsync() || !this.options.autoResize) {\n      return;\n    }\n\n    this.update();\n  }\n\n  onBatchStop(args) {\n    if (this.graph.isAsync() || !this.options.autoResize) {\n      return;\n    }\n\n    if (Renderer.UPDATE_DELAYING_BATCHES.includes(args.name)) {\n      this.update();\n    }\n  }\n\n  delegateBackgroundEvents(events) {\n    const evts = events || GraphView.events;\n    this.delegatedHandlers = Object.keys(evts).reduce((memo, name) => {\n      const handler = evts[name];\n\n      if (name.indexOf(' ') === -1) {\n        if (typeof handler === 'function') {\n          memo[name] = handler;\n        } else {\n          let method = this.graph.view[handler];\n\n          if (typeof method === 'function') {\n            method = method.bind(this.graph.view);\n            memo[name] = method;\n          }\n        }\n      }\n\n      return memo;\n    }, {});\n    this.onBackgroundEvent = this.onBackgroundEvent.bind(this);\n    Object.keys(this.delegatedHandlers).forEach(name => {\n      this.delegateEvent(name, {\n        guarded: false\n      }, this.onBackgroundEvent);\n    });\n  }\n\n  undelegateBackgroundEvents() {\n    Object.keys(this.delegatedHandlers).forEach(name => {\n      this.undelegateEvent(name, this.onBackgroundEvent);\n    });\n  }\n\n  onBackgroundEvent(e) {\n    let valid = false;\n    const target = e.target;\n\n    if (!this.options.pageVisible) {\n      const view = this.graph.view;\n      valid = view.background === target || view.grid === target;\n    } else if (this.options.background) {\n      valid = this.background === target;\n    } else {\n      valid = this.content === target;\n    }\n\n    if (valid) {\n      const handler = this.delegatedHandlers[e.type];\n\n      if (typeof handler === 'function') {\n        handler.apply(this.graph, arguments); // eslint-disable-line\n      }\n    }\n  }\n\n  onRenderDone(_ref) {\n    let {\n      stats\n    } = _ref;\n\n    if (this.options.autoResize && stats.priority < 2) {\n      this.update();\n    }\n  }\n\n  onResize() {\n    if (this.cachedCenterPoint) {\n      this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y);\n      this.updatePageBreak();\n    }\n  }\n\n  onScale(_ref2) {\n    let {\n      sx,\n      sy,\n      ox,\n      oy\n    } = _ref2;\n    this.updateScale(sx, sy);\n\n    if (ox || oy) {\n      this.centerPoint(ox, oy);\n      this.updatePageBreak();\n    }\n\n    const autoResizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n\n    if (typeof autoResizeOptions === 'function') {\n      this.update();\n    }\n  }\n\n  storeScrollPosition() {\n    this.cachedScrollLeft = this.container.scrollLeft;\n    this.cachedScrollTop = this.container.scrollTop;\n  }\n\n  restoreScrollPosition() {\n    this.container.scrollLeft = this.cachedScrollLeft;\n    this.container.scrollTop = this.cachedScrollTop;\n    this.cachedScrollLeft = null;\n    this.cachedScrollTop = null;\n  }\n\n  storeClientSize() {\n    this.cachedClientSize = {\n      width: this.container.clientWidth,\n      height: this.container.clientHeight\n    };\n  }\n\n  restoreClientSize() {\n    this.cachedClientSize = null;\n  }\n\n  beforeManipulation() {\n    if (Platform.IS_IE || Platform.IS_EDGE) {\n      this.$container.css('visibility', 'hidden');\n    }\n  }\n\n  afterManipulation() {\n    if (Platform.IS_IE || Platform.IS_EDGE) {\n      this.$container.css('visibility', 'visible');\n    }\n  }\n\n  updatePageSize(width, height) {\n    if (width != null) {\n      this.options.pageWidth = width;\n    }\n\n    if (height != null) {\n      this.options.pageHeight = height;\n    }\n\n    this.updatePageBreak();\n  }\n\n  updatePageBreak() {\n    if (this.pageBreak && this.pageBreak.parentNode) {\n      this.pageBreak.parentNode.removeChild(this.pageBreak);\n    }\n\n    this.pageBreak = null;\n\n    if (this.options.pageVisible && this.options.pageBreak) {\n      const graphWidth = this.graph.options.width;\n      const graphHeight = this.graph.options.height;\n      const pageWidth = this.options.pageWidth * this.sx;\n      const pageHeight = this.options.pageHeight * this.sy;\n\n      if (graphWidth > pageWidth || graphHeight > pageHeight) {\n        let hasPageBreak = false;\n        const container = document.createElement('div');\n\n        for (let i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {\n          this.$('<div/>').addClass(this.prefixClassName(`graph-pagebreak-vertical`)).css({\n            left: i * pageWidth\n          }).appendTo(container);\n          hasPageBreak = true;\n        }\n\n        for (let i = 1, l = Math.floor(graphHeight / pageHeight); i < l; i += 1) {\n          this.$('<div/>').addClass(this.prefixClassName(`graph-pagebreak-horizontal`)).css({\n            top: i * pageHeight\n          }).appendTo(container);\n          hasPageBreak = true;\n        }\n\n        if (hasPageBreak) {\n          Dom.addClass(container, this.prefixClassName('graph-pagebreak'));\n          this.$(this.graph.view.grid).after(container);\n          this.pageBreak = container;\n        }\n      }\n    }\n  }\n\n  update() {\n    const size = this.getClientSize();\n    this.cachedCenterPoint = this.clientToLocalPoint(size.width / 2, size.height / 2);\n    let resizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n\n    if (typeof resizeOptions === 'function') {\n      resizeOptions = FunctionExt.call(resizeOptions, this, this);\n    }\n\n    const options = Object.assign({\n      gridWidth: this.options.pageWidth,\n      gridHeight: this.options.pageHeight,\n      allowNewOrigin: 'negative'\n    }, resizeOptions);\n    this.graph.fitToContent(this.getFitToContentOptions(options));\n  }\n\n  getFitToContentOptions(options) {\n    const sx = this.sx;\n    const sy = this.sy;\n    options.gridWidth && (options.gridWidth *= sx);\n    options.gridHeight && (options.gridHeight *= sy);\n    options.minWidth && (options.minWidth *= sx);\n    options.minHeight && (options.minHeight *= sy);\n\n    if (typeof options.padding === 'object') {\n      options.padding = {\n        left: (options.padding.left || 0) * sx,\n        right: (options.padding.right || 0) * sx,\n        top: (options.padding.top || 0) * sy,\n        bottom: (options.padding.bottom || 0) * sy\n      };\n    } else if (typeof options.padding === 'number') {\n      options.padding *= sx;\n    }\n\n    if (!this.options.autoResize) {\n      options.contentArea = Rectangle.create();\n    }\n\n    return options;\n  }\n\n  updateScale(sx, sy) {\n    const options = this.graph.options;\n    const dx = sx / this.sx;\n    const dy = sy / this.sy;\n    this.sx = sx;\n    this.sy = sy;\n    this.graph.translate(options.x * dx, options.y * dy);\n    this.graph.resizeGraph(options.width * dx, options.height * dy);\n  }\n\n  scrollbarPosition(left, top, options) {\n    if (left == null && top == null) {\n      return {\n        left: this.container.scrollLeft,\n        top: this.container.scrollTop\n      };\n    }\n\n    const prop = {};\n\n    if (typeof left === 'number') {\n      prop.scrollLeft = left;\n    }\n\n    if (typeof top === 'number') {\n      prop.scrollTop = top;\n    }\n\n    if (options && options.animation) {\n      this.$container.animate(prop, options.animation);\n    } else {\n      this.$container.prop(prop);\n    }\n\n    return this;\n  }\n  /**\n   * Try to scroll to ensure that the position (x,y) on the graph (in local\n   * coordinates) is at the center of the viewport. If only one of the\n   * coordinates is specified, only scroll in the specified dimension and\n   * keep the other coordinate unchanged.\n   */\n\n\n  scrollToPoint(x, y, options) {\n    const size = this.getClientSize();\n    const ctm = this.graph.matrix();\n    const prop = {};\n\n    if (typeof x === 'number') {\n      prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0);\n    }\n\n    if (typeof y === 'number') {\n      prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0);\n    }\n\n    if (options && options.animation) {\n      this.$container.animate(prop, options.animation);\n    } else {\n      this.$container.prop(prop);\n    }\n\n    return this;\n  }\n  /**\n   * Try to scroll to ensure that the center of graph content is at the\n   * center of the viewport.\n   */\n\n\n  scrollToContent(options) {\n    const sx = this.sx;\n    const sy = this.sy;\n    const center = this.graph.getContentArea().getCenter();\n    return this.scrollToPoint(center.x * sx, center.y * sy, options);\n  }\n  /**\n   * Try to scroll to ensure that the center of cell is at the center of\n   * the viewport.\n   */\n\n\n  scrollToCell(cell, options) {\n    const sx = this.sx;\n    const sy = this.sy;\n    const center = cell.getBBox().getCenter();\n    return this.scrollToPoint(center.x * sx, center.y * sy, options);\n  }\n  /**\n   * The center methods are more aggressive than the scroll methods. These\n   * methods position the graph so that a specific point on the graph lies\n   * at the center of the viewport, adding paddings around the paper if\n   * necessary (e.g. if the requested point lies in a corner of the paper).\n   * This means that the requested point will always move into the center\n   * of the viewport. (Use the scroll functions to avoid adding paddings\n   * and only scroll the viewport as far as the graph boundary.)\n   */\n\n  /**\n   * Position the center of graph to the center of the viewport.\n   */\n\n\n  center(optons) {\n    return this.centerPoint(optons);\n  }\n\n  centerPoint(x, y, options) {\n    const ctm = this.graph.matrix();\n    const sx = ctm.a;\n    const sy = ctm.d;\n    const tx = -ctm.e;\n    const ty = -ctm.f;\n    const tWidth = tx + this.graph.options.width;\n    const tHeight = ty + this.graph.options.height;\n    let localOptions;\n    this.storeClientSize(); // avoid multilple reflow\n\n    if (typeof x === 'number' || typeof y === 'number') {\n      localOptions = options;\n      const visibleCenter = this.getVisibleArea().getCenter();\n\n      if (typeof x === 'number') {\n        x *= sx; // eslint-disable-line\n      } else {\n        x = visibleCenter.x; // eslint-disable-line\n      }\n\n      if (typeof y === 'number') {\n        y *= sy; // eslint-disable-line\n      } else {\n        y = visibleCenter.y; // eslint-disable-line\n      }\n    } else {\n      localOptions = x;\n      x = (tx + tWidth) / 2; // eslint-disable-line\n\n      y = (ty + tHeight) / 2; // eslint-disable-line\n    }\n\n    if (localOptions && localOptions.padding) {\n      return this.positionPoint({\n        x,\n        y\n      }, '50%', '50%', localOptions);\n    }\n\n    const padding = this.getPadding();\n    const clientSize = this.getClientSize();\n    const cx = clientSize.width / 2;\n    const cy = clientSize.height / 2;\n    const left = cx - padding.left - x + tx;\n    const right = cx - padding.right + x - tWidth;\n    const top = cy - padding.top - y + ty;\n    const bottom = cy - padding.bottom + y - tHeight;\n    this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));\n    const result = this.scrollToPoint(x, y, localOptions || undefined);\n    this.restoreClientSize();\n    return result;\n  }\n\n  centerContent(options) {\n    return this.positionContent('center', options);\n  }\n\n  centerCell(cell, options) {\n    return this.positionCell(cell, 'center', options);\n  }\n  /**\n   * The position methods are a more general version of the center methods.\n   * They position the graph so that a specific point on the graph lies at\n   * requested coordinates inside the viewport.\n   */\n\n  /**\n   *\n   */\n\n\n  positionContent(pos, options) {\n    const rect = this.graph.getContentArea(options);\n    return this.positionRect(rect, pos, options);\n  }\n\n  positionCell(cell, pos, options) {\n    const bbox = cell.getBBox();\n    return this.positionRect(bbox, pos, options);\n  }\n\n  positionRect(rect, pos, options) {\n    const bbox = Rectangle.create(rect);\n\n    switch (pos) {\n      case 'center':\n        return this.positionPoint(bbox.getCenter(), '50%', '50%', options);\n\n      case 'top':\n        return this.positionPoint(bbox.getTopCenter(), '50%', 0, options);\n\n      case 'top-right':\n        return this.positionPoint(bbox.getTopRight(), '100%', 0, options);\n\n      case 'right':\n        return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options);\n\n      case 'bottom-right':\n        return this.positionPoint(bbox.getBottomRight(), '100%', '100%', options);\n\n      case 'bottom':\n        return this.positionPoint(bbox.getBottomCenter(), '50%', '100%', options);\n\n      case 'bottom-left':\n        return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options);\n\n      case 'left':\n        return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options);\n\n      case 'top-left':\n        return this.positionPoint(bbox.getTopLeft(), 0, 0, options);\n\n      default:\n        return this;\n    }\n  }\n\n  positionPoint(point, x, y) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n\n    const {\n      padding: pad\n    } = options,\n          localOptions = __rest(options, [\"padding\"]);\n\n    const padding = NumberExt.normalizeSides(pad);\n    const clientRect = Rectangle.fromSize(this.getClientSize());\n    const targetRect = clientRect.clone().moveAndExpand({\n      x: padding.left,\n      y: padding.top,\n      width: -padding.right - padding.left,\n      height: -padding.top - padding.bottom\n    }); // eslint-disable-next-line\n\n    x = NumberExt.normalizePercentage(x, Math.max(0, targetRect.width));\n\n    if (x < 0) {\n      x = targetRect.width + x; // eslint-disable-line\n    } // eslint-disable-next-line\n\n\n    y = NumberExt.normalizePercentage(y, Math.max(0, targetRect.height));\n\n    if (y < 0) {\n      y = targetRect.height + y; // eslint-disable-line\n    }\n\n    const origin = targetRect.getTopLeft().translate(x, y);\n    const diff = clientRect.getCenter().diff(origin);\n    const scale = this.zoom();\n    const rawDiff = diff.scale(1 / scale, 1 / scale);\n    const result = Point.create(point).translate(rawDiff);\n    return this.centerPoint(result.x, result.y, localOptions);\n  }\n\n  zoom(factor, options) {\n    if (factor == null) {\n      return this.sx;\n    }\n\n    options = options || {}; // eslint-disable-line\n\n    let cx;\n    let cy;\n    const clientSize = this.getClientSize();\n    const center = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n    let sx = factor;\n    let sy = factor;\n\n    if (!options.absolute) {\n      sx += this.sx;\n      sy += this.sy;\n    }\n\n    if (options.scaleGrid) {\n      sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;\n      sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;\n    }\n\n    if (options.maxScale) {\n      sx = Math.min(options.maxScale, sx);\n      sy = Math.min(options.maxScale, sy);\n    }\n\n    if (options.minScale) {\n      sx = Math.max(options.minScale, sx);\n      sy = Math.max(options.minScale, sy);\n    }\n\n    sx = this.graph.transform.clampScale(sx);\n    sy = this.graph.transform.clampScale(sy);\n\n    if (options.center) {\n      const fx = sx / this.sx;\n      const fy = sy / this.sy;\n      cx = options.center.x - (options.center.x - center.x) / fx;\n      cy = options.center.y - (options.center.y - center.y) / fy;\n    } else {\n      cx = center.x;\n      cy = center.y;\n    }\n\n    this.beforeManipulation();\n    this.graph.transform.scale(sx, sy);\n    this.centerPoint(cx, cy);\n    this.afterManipulation();\n    return this;\n  }\n\n  zoomToRect(rect) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const area = Rectangle.create(rect);\n    const graph = this.graph;\n    options.contentArea = area;\n\n    if (options.viewportArea == null) {\n      options.viewportArea = {\n        x: graph.options.x,\n        y: graph.options.y,\n        width: this.$container.width(),\n        height: this.$container.height()\n      };\n    }\n\n    this.beforeManipulation();\n    graph.transform.scaleContentToFitImpl(options, false);\n    const center = area.getCenter();\n    this.centerPoint(center.x, center.y);\n    this.afterManipulation();\n    return this;\n  }\n\n  zoomToFit() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.zoomToRect(this.graph.getContentArea(options), options);\n  }\n\n  transitionToPoint(x, y, options) {\n    if (typeof x === 'object') {\n      options = y; // eslint-disable-line\n\n      y = x.y; // eslint-disable-line\n\n      x = x.x; // eslint-disable-line\n    } else {\n      y = y; // eslint-disable-line\n    }\n\n    if (options == null) {\n      options = {}; // eslint-disable-line\n    }\n\n    let transform;\n    let transformOrigin;\n    const scale = this.sx;\n    const targetScale = Math.max(options.scale || scale, 0.000001);\n    const clientSize = this.getClientSize();\n    const targetPoint = new Point(x, y);\n    const localPoint = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n\n    if (scale === targetScale) {\n      const translate = localPoint.diff(targetPoint).scale(scale, scale).round();\n      transform = `translate(${translate.x}px,${translate.y}px)`;\n    } else {\n      const delta = targetScale / (scale - targetScale) * targetPoint.distance(localPoint);\n      const range = localPoint.clone().move(targetPoint, delta);\n      const origin = this.localToBackgroundPoint(range).round();\n      transform = `scale(${targetScale / scale})`;\n      transformOrigin = `${origin.x}px ${origin.y}px`;\n    }\n\n    const onTransitionEnd = options.onTransitionEnd;\n    this.$container.addClass(Util.transitionClassName);\n    this.$content.off(Util.transitionEventName).on(Util.transitionEventName, e => {\n      this.syncTransition(targetScale, {\n        x: x,\n        y: y\n      });\n\n      if (typeof onTransitionEnd === 'function') {\n        FunctionExt.call(onTransitionEnd, this, e.originalEvent);\n      }\n    }).css({\n      transform,\n      transformOrigin,\n      transition: 'transform',\n      transitionDuration: options.duration || '1s',\n      transitionDelay: options.delay,\n      transitionTimingFunction: options.timing\n    });\n    return this;\n  }\n\n  syncTransition(scale, p) {\n    this.beforeManipulation();\n    this.graph.scale(scale);\n    this.removeTransition();\n    this.centerPoint(p.x, p.y);\n    this.afterManipulation();\n    return this;\n  }\n\n  removeTransition() {\n    this.$container.removeClass(Util.transitionClassName);\n    this.$content.off(Util.transitionEventName).css({\n      transform: '',\n      transformOrigin: '',\n      transition: '',\n      transitionDuration: '',\n      transitionDelay: '',\n      transitionTimingFunction: ''\n    });\n    return this;\n  }\n\n  transitionToRect(rectangle) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const rect = Rectangle.create(rectangle);\n    const maxScale = options.maxScale || Infinity;\n    const minScale = options.minScale || Number.MIN_VALUE;\n    const scaleGrid = options.scaleGrid || null;\n    const PIXEL_SIZE = options.visibility || 1;\n    const center = options.center ? Point.create(options.center) : rect.getCenter();\n    const clientSize = this.getClientSize();\n    const w = clientSize.width * PIXEL_SIZE;\n    const h = clientSize.height * PIXEL_SIZE;\n    let scale = new Rectangle(center.x - w / 2, center.y - h / 2, w, h).getMaxUniformScaleToFit(rect, center);\n    scale = Math.min(scale, maxScale);\n\n    if (scaleGrid) {\n      scale = Math.floor(scale / scaleGrid) * scaleGrid;\n    }\n\n    scale = Math.max(minScale, scale);\n    return this.transitionToPoint(center, Object.assign({\n      scale\n    }, options));\n  }\n\n  startPanning(evt) {\n    const e = this.normalizeEvent(evt);\n    this.clientX = e.clientX;\n    this.clientY = e.clientY;\n    this.trigger('pan:start', {\n      e\n    });\n    this.$(document.body).on({\n      'mousemove.panning touchmove.panning': this.pan.bind(this),\n      'mouseup.panning touchend.panning': this.stopPanning.bind(this)\n    });\n    this.$(window).on('mouseup.panning', this.stopPanning.bind(this));\n  }\n\n  pan(evt) {\n    const e = this.normalizeEvent(evt);\n    const dx = e.clientX - this.clientX;\n    const dy = e.clientY - this.clientY;\n    this.container.scrollTop -= dy;\n    this.container.scrollLeft -= dx;\n    this.clientX = e.clientX;\n    this.clientY = e.clientY;\n    this.trigger('panning', {\n      e\n    });\n  }\n\n  stopPanning(e) {\n    this.$(document.body).off('.panning');\n    this.$(window).off('.panning');\n    this.trigger('pan:stop', {\n      e\n    });\n  }\n\n  clientToLocalPoint(a, b) {\n    let x = typeof a === 'object' ? a.x : a;\n    let y = typeof a === 'object' ? a.y : b;\n    const ctm = this.graph.matrix();\n    x += this.container.scrollLeft - this.padding.left - ctm.e;\n    y += this.container.scrollTop - this.padding.top - ctm.f;\n    return new Point(x / ctm.a, y / ctm.d);\n  }\n\n  localToBackgroundPoint(x, y) {\n    const p = typeof x === 'object' ? Point.create(x) : new Point(x, y);\n    const ctm = this.graph.matrix();\n    const padding = this.padding;\n    return Dom.transformPoint(p, ctm).translate(padding.left, padding.top);\n  }\n\n  resize(width, height) {\n    let w = width != null ? width : this.container.clientWidth;\n    let h = height != null ? height : this.container.clientHeight;\n\n    if (typeof w === 'number') {\n      w = Math.round(w);\n    }\n\n    if (typeof h === 'number') {\n      h = Math.round(h);\n    }\n\n    this.options.width = w;\n    this.options.height = h;\n    this.$container.css({\n      width: w,\n      height: h\n    });\n    this.update();\n  }\n\n  getClientSize() {\n    if (this.cachedClientSize) {\n      return this.cachedClientSize;\n    }\n\n    return {\n      width: this.container.clientWidth,\n      height: this.container.clientHeight\n    };\n  }\n\n  autoScroll(clientX, clientY) {\n    const buffer = 10;\n    const container = this.container;\n    const rect = container.getBoundingClientRect();\n    let dx = 0;\n    let dy = 0;\n\n    if (clientX <= rect.left + buffer) {\n      dx = -buffer;\n    }\n\n    if (clientY <= rect.top + buffer) {\n      dy = -buffer;\n    }\n\n    if (clientX >= rect.right - buffer) {\n      dx = buffer;\n    }\n\n    if (clientY >= rect.bottom - buffer) {\n      dy = buffer;\n    }\n\n    if (dx !== 0) {\n      container.scrollLeft += dx;\n    }\n\n    if (dy !== 0) {\n      container.scrollTop += dy;\n    }\n\n    return {\n      scrollerX: dx,\n      scrollerY: dy\n    };\n  }\n\n  addPadding(left, right, top, bottom) {\n    let padding = this.getPadding();\n    this.padding = {\n      left: Math.round(padding.left + (left || 0)),\n      top: Math.round(padding.top + (top || 0)),\n      bottom: Math.round(padding.bottom + (bottom || 0)),\n      right: Math.round(padding.right + (right || 0))\n    };\n    padding = this.padding;\n    this.$content.css({\n      width: padding.left + this.graph.options.width + padding.right,\n      height: padding.top + this.graph.options.height + padding.bottom\n    });\n    const container = this.graph.container;\n    container.style.left = `${this.padding.left}px`;\n    container.style.top = `${this.padding.top}px`;\n    return this;\n  }\n\n  getPadding() {\n    const padding = this.options.padding;\n\n    if (typeof padding === 'function') {\n      return NumberExt.normalizeSides(FunctionExt.call(padding, this, this));\n    }\n\n    return NumberExt.normalizeSides(padding);\n  }\n  /**\n   * Returns the untransformed size and origin of the current viewport.\n   */\n\n\n  getVisibleArea() {\n    const ctm = this.graph.matrix();\n    const size = this.getClientSize();\n    const box = {\n      x: this.container.scrollLeft || 0,\n      y: this.container.scrollTop || 0,\n      width: size.width,\n      height: size.height\n    };\n    const area = Dom.transformRectangle(box, ctm.inverse());\n    area.x -= (this.padding.left || 0) / this.sx;\n    area.y -= (this.padding.top || 0) / this.sy;\n    return area;\n  }\n\n  isCellVisible(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const bbox = cell.getBBox();\n    const area = this.getVisibleArea();\n    return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n  }\n\n  isPointVisible(point) {\n    return this.getVisibleArea().containsPoint(point);\n  }\n  /**\n   * Lock the current viewport by disabling user scrolling.\n   */\n\n\n  lock() {\n    this.$container.css('overflow', 'hidden');\n    return this;\n  }\n  /**\n   * Enable user scrolling if previously locked.\n   */\n\n\n  unlock() {\n    this.$container.css('overflow', 'scroll');\n    return this;\n  }\n\n  onRemove() {\n    this.stopListening();\n  }\n\n  dispose() {\n    this.$(this.graph.container).insertBefore(this.$container);\n    this.remove();\n  }\n\n}\n\n__decorate([View.dispose()], Scroller.prototype, \"dispose\", null);\n\n(function (Scroller) {\n  class Background extends BackgroundManager {\n    constructor(scroller) {\n      super(scroller.graph);\n      this.scroller = scroller;\n\n      if (scroller.options.background) {\n        this.draw(scroller.options.background);\n      }\n    }\n\n    get elem() {\n      return this.scroller.background;\n    }\n\n    init() {\n      this.graph.on('scale', this.update, this);\n      this.graph.on('translate', this.update, this);\n    }\n\n    updateBackgroundOptions(options) {\n      this.scroller.options.background = options;\n    }\n\n  }\n\n  Scroller.Background = Background;\n})(Scroller || (Scroller = {}));\n\nvar Util;\n\n(function (Util) {\n  Util.containerClass = 'graph-scroller';\n  Util.panningClass = `${Util.containerClass}-panning`;\n  Util.pannableClass = `${Util.containerClass}-pannable`;\n  Util.pagedClass = `${Util.containerClass}-paged`;\n  Util.contentClass = `${Util.containerClass}-content`;\n  Util.backgroundClass = `${Util.containerClass}-background`;\n  Util.transitionClassName = 'transition-in-progress';\n  Util.transitionEventName = 'transitionend.graph-scroller-transition';\n  Util.defaultOptions = {\n    padding() {\n      const size = this.getClientSize();\n      const minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1;\n      const minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1;\n      const left = Math.max(size.width - minWidth, 0);\n      const top = Math.max(size.height - minHeight, 0);\n      return {\n        left,\n        top,\n        right: left,\n        bottom: top\n      };\n    },\n\n    minVisibleWidth: 50,\n    minVisibleHeight: 50,\n    pageVisible: false,\n    pageBreak: false,\n    autoResize: true\n  };\n\n  function getOptions(options) {\n    const result = ObjectExt.merge({}, Util.defaultOptions, options);\n\n    if (result.pageWidth == null) {\n      result.pageWidth = options.graph.options.width;\n    }\n\n    if (result.pageHeight == null) {\n      result.pageHeight = options.graph.options.height;\n    }\n\n    return result;\n  }\n\n  Util.getOptions = getOptions;\n})(Util || (Util = {}));","map":{"version":3,"sources":["../../../src/addon/scroller/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { Platform, NumberExt, ObjectExt, Dom, FunctionExt } from '../../util';\nimport { Point, Rectangle } from '../../geometry';\nimport { View } from '../../view/view';\nimport { Renderer } from '../../graph/renderer';\nimport { GraphView } from '../../graph/view';\nimport { BackgroundManager } from '../../graph/background';\nexport class Scroller extends View {\n    constructor(options) {\n        super();\n        this.padding = { left: 0, top: 0, right: 0, bottom: 0 };\n        this.options = Util.getOptions(options);\n        const scale = this.graph.transform.getScale();\n        this.sx = scale.sx;\n        this.sy = scale.sy;\n        const width = this.options.width || this.graph.options.width;\n        const height = this.options.height || this.graph.options.height;\n        this.container = document.createElement('div');\n        this.$container = this.$(this.container)\n            .addClass(this.prefixClassName(Util.containerClass))\n            .css({ width, height });\n        if (this.options.pageVisible) {\n            this.$container.addClass(this.prefixClassName(Util.pagedClass));\n        }\n        if (this.options.className) {\n            this.$container.addClass(this.options.className);\n        }\n        const graphContainer = this.graph.container;\n        if (graphContainer.parentNode) {\n            this.$container.insertBefore(graphContainer);\n        }\n        // copy style\n        const style = graphContainer.getAttribute('style');\n        if (style) {\n            const obj = {};\n            const styles = style.split(';');\n            styles.forEach((item) => {\n                const section = item.trim();\n                if (section) {\n                    const pair = section.split(':');\n                    if (pair.length) {\n                        obj[pair[0].trim()] = pair[1] ? pair[1].trim() : '';\n                    }\n                }\n            });\n            Object.keys(obj).forEach((key) => {\n                if (key === 'width' || key === 'height') {\n                    return;\n                }\n                graphContainer.style[key] = '';\n                this.container.style[key] = obj[key];\n            });\n        }\n        this.content = document.createElement('div');\n        this.$content = this.$(this.content)\n            .addClass(this.prefixClassName(Util.contentClass))\n            .css({\n            width: this.graph.options.width,\n            height: this.graph.options.height,\n        });\n        // custom background\n        this.background = document.createElement('div');\n        this.$background = this.$(this.background).addClass(this.prefixClassName(Util.backgroundClass));\n        this.$content.append(this.background);\n        if (!this.options.pageVisible) {\n            this.$content.append(this.graph.view.grid);\n        }\n        this.$content.append(graphContainer);\n        this.$content.appendTo(this.container);\n        this.startListening();\n        if (!this.options.pageVisible) {\n            this.graph.grid.update();\n        }\n        this.backgroundManager = new Scroller.Background(this);\n        if (!this.options.autoResize) {\n            this.update();\n        }\n    }\n    get graph() {\n        return this.options.graph;\n    }\n    get model() {\n        return this.graph.model;\n    }\n    startListening() {\n        const graph = this.graph;\n        const model = this.model;\n        graph.on('scale', this.onScale, this);\n        graph.on('resize', this.onResize, this);\n        graph.on('before:print', this.storeScrollPosition, this);\n        graph.on('before:export', this.storeScrollPosition, this);\n        graph.on('after:print', this.restoreScrollPosition, this);\n        graph.on('after:export', this.restoreScrollPosition, this);\n        graph.on('render:done', this.onRenderDone, this);\n        graph.on('unfreeze', this.onUpdate, this);\n        model.on('reseted', this.onUpdate, this);\n        model.on('cell:added', this.onUpdate, this);\n        model.on('cell:removed', this.onUpdate, this);\n        model.on('cell:changed', this.onUpdate, this);\n        model.on('batch:stop', this.onBatchStop, this);\n        this.delegateBackgroundEvents();\n    }\n    stopListening() {\n        const graph = this.graph;\n        const model = this.model;\n        graph.off('scale', this.onScale, this);\n        graph.off('resize', this.onResize, this);\n        graph.off('beforeprint', this.storeScrollPosition, this);\n        graph.off('beforeexport', this.storeScrollPosition, this);\n        graph.off('afterprint', this.restoreScrollPosition, this);\n        graph.off('afterexport', this.restoreScrollPosition, this);\n        graph.off('render:done', this.onRenderDone, this);\n        graph.off('unfreeze', this.onUpdate, this);\n        model.off('reseted', this.onUpdate, this);\n        model.off('cell:added', this.onUpdate, this);\n        model.off('cell:removed', this.onUpdate, this);\n        model.off('cell:changed', this.onUpdate, this);\n        model.off('batch:stop', this.onBatchStop, this);\n        this.undelegateBackgroundEvents();\n    }\n    enableAutoResize() {\n        this.options.autoResize = true;\n    }\n    disableAutoResize() {\n        this.options.autoResize = false;\n    }\n    onUpdate() {\n        if (this.graph.isAsync() || !this.options.autoResize) {\n            return;\n        }\n        this.update();\n    }\n    onBatchStop(args) {\n        if (this.graph.isAsync() || !this.options.autoResize) {\n            return;\n        }\n        if (Renderer.UPDATE_DELAYING_BATCHES.includes(args.name)) {\n            this.update();\n        }\n    }\n    delegateBackgroundEvents(events) {\n        const evts = events || GraphView.events;\n        this.delegatedHandlers = Object.keys(evts).reduce((memo, name) => {\n            const handler = evts[name];\n            if (name.indexOf(' ') === -1) {\n                if (typeof handler === 'function') {\n                    memo[name] = handler;\n                }\n                else {\n                    let method = this.graph.view[handler];\n                    if (typeof method === 'function') {\n                        method = method.bind(this.graph.view);\n                        memo[name] = method;\n                    }\n                }\n            }\n            return memo;\n        }, {});\n        this.onBackgroundEvent = this.onBackgroundEvent.bind(this);\n        Object.keys(this.delegatedHandlers).forEach((name) => {\n            this.delegateEvent(name, {\n                guarded: false,\n            }, this.onBackgroundEvent);\n        });\n    }\n    undelegateBackgroundEvents() {\n        Object.keys(this.delegatedHandlers).forEach((name) => {\n            this.undelegateEvent(name, this.onBackgroundEvent);\n        });\n    }\n    onBackgroundEvent(e) {\n        let valid = false;\n        const target = e.target;\n        if (!this.options.pageVisible) {\n            const view = this.graph.view;\n            valid = view.background === target || view.grid === target;\n        }\n        else if (this.options.background) {\n            valid = this.background === target;\n        }\n        else {\n            valid = this.content === target;\n        }\n        if (valid) {\n            const handler = this.delegatedHandlers[e.type];\n            if (typeof handler === 'function') {\n                handler.apply(this.graph, arguments); // eslint-disable-line\n            }\n        }\n    }\n    onRenderDone({ stats }) {\n        if (this.options.autoResize && stats.priority < 2) {\n            this.update();\n        }\n    }\n    onResize() {\n        if (this.cachedCenterPoint) {\n            this.centerPoint(this.cachedCenterPoint.x, this.cachedCenterPoint.y);\n            this.updatePageBreak();\n        }\n    }\n    onScale({ sx, sy, ox, oy }) {\n        this.updateScale(sx, sy);\n        if (ox || oy) {\n            this.centerPoint(ox, oy);\n            this.updatePageBreak();\n        }\n        const autoResizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n        if (typeof autoResizeOptions === 'function') {\n            this.update();\n        }\n    }\n    storeScrollPosition() {\n        this.cachedScrollLeft = this.container.scrollLeft;\n        this.cachedScrollTop = this.container.scrollTop;\n    }\n    restoreScrollPosition() {\n        this.container.scrollLeft = this.cachedScrollLeft;\n        this.container.scrollTop = this.cachedScrollTop;\n        this.cachedScrollLeft = null;\n        this.cachedScrollTop = null;\n    }\n    storeClientSize() {\n        this.cachedClientSize = {\n            width: this.container.clientWidth,\n            height: this.container.clientHeight,\n        };\n    }\n    restoreClientSize() {\n        this.cachedClientSize = null;\n    }\n    beforeManipulation() {\n        if (Platform.IS_IE || Platform.IS_EDGE) {\n            this.$container.css('visibility', 'hidden');\n        }\n    }\n    afterManipulation() {\n        if (Platform.IS_IE || Platform.IS_EDGE) {\n            this.$container.css('visibility', 'visible');\n        }\n    }\n    updatePageSize(width, height) {\n        if (width != null) {\n            this.options.pageWidth = width;\n        }\n        if (height != null) {\n            this.options.pageHeight = height;\n        }\n        this.updatePageBreak();\n    }\n    updatePageBreak() {\n        if (this.pageBreak && this.pageBreak.parentNode) {\n            this.pageBreak.parentNode.removeChild(this.pageBreak);\n        }\n        this.pageBreak = null;\n        if (this.options.pageVisible && this.options.pageBreak) {\n            const graphWidth = this.graph.options.width;\n            const graphHeight = this.graph.options.height;\n            const pageWidth = this.options.pageWidth * this.sx;\n            const pageHeight = this.options.pageHeight * this.sy;\n            if (graphWidth > pageWidth || graphHeight > pageHeight) {\n                let hasPageBreak = false;\n                const container = document.createElement('div');\n                for (let i = 1, l = Math.floor(graphWidth / pageWidth); i < l; i += 1) {\n                    this.$('<div/>')\n                        .addClass(this.prefixClassName(`graph-pagebreak-vertical`))\n                        .css({ left: i * pageWidth })\n                        .appendTo(container);\n                    hasPageBreak = true;\n                }\n                for (let i = 1, l = Math.floor(graphHeight / pageHeight); i < l; i += 1) {\n                    this.$('<div/>')\n                        .addClass(this.prefixClassName(`graph-pagebreak-horizontal`))\n                        .css({ top: i * pageHeight })\n                        .appendTo(container);\n                    hasPageBreak = true;\n                }\n                if (hasPageBreak) {\n                    Dom.addClass(container, this.prefixClassName('graph-pagebreak'));\n                    this.$(this.graph.view.grid).after(container);\n                    this.pageBreak = container;\n                }\n            }\n        }\n    }\n    update() {\n        const size = this.getClientSize();\n        this.cachedCenterPoint = this.clientToLocalPoint(size.width / 2, size.height / 2);\n        let resizeOptions = this.options.autoResizeOptions || this.options.fitTocontentOptions;\n        if (typeof resizeOptions === 'function') {\n            resizeOptions = FunctionExt.call(resizeOptions, this, this);\n        }\n        const options = Object.assign({ gridWidth: this.options.pageWidth, gridHeight: this.options.pageHeight, allowNewOrigin: 'negative' }, resizeOptions);\n        this.graph.fitToContent(this.getFitToContentOptions(options));\n    }\n    getFitToContentOptions(options) {\n        const sx = this.sx;\n        const sy = this.sy;\n        options.gridWidth && (options.gridWidth *= sx);\n        options.gridHeight && (options.gridHeight *= sy);\n        options.minWidth && (options.minWidth *= sx);\n        options.minHeight && (options.minHeight *= sy);\n        if (typeof options.padding === 'object') {\n            options.padding = {\n                left: (options.padding.left || 0) * sx,\n                right: (options.padding.right || 0) * sx,\n                top: (options.padding.top || 0) * sy,\n                bottom: (options.padding.bottom || 0) * sy,\n            };\n        }\n        else if (typeof options.padding === 'number') {\n            options.padding *= sx;\n        }\n        if (!this.options.autoResize) {\n            options.contentArea = Rectangle.create();\n        }\n        return options;\n    }\n    updateScale(sx, sy) {\n        const options = this.graph.options;\n        const dx = sx / this.sx;\n        const dy = sy / this.sy;\n        this.sx = sx;\n        this.sy = sy;\n        this.graph.translate(options.x * dx, options.y * dy);\n        this.graph.resizeGraph(options.width * dx, options.height * dy);\n    }\n    scrollbarPosition(left, top, options) {\n        if (left == null && top == null) {\n            return {\n                left: this.container.scrollLeft,\n                top: this.container.scrollTop,\n            };\n        }\n        const prop = {};\n        if (typeof left === 'number') {\n            prop.scrollLeft = left;\n        }\n        if (typeof top === 'number') {\n            prop.scrollTop = top;\n        }\n        if (options && options.animation) {\n            this.$container.animate(prop, options.animation);\n        }\n        else {\n            this.$container.prop(prop);\n        }\n        return this;\n    }\n    /**\n     * Try to scroll to ensure that the position (x,y) on the graph (in local\n     * coordinates) is at the center of the viewport. If only one of the\n     * coordinates is specified, only scroll in the specified dimension and\n     * keep the other coordinate unchanged.\n     */\n    scrollToPoint(x, y, options) {\n        const size = this.getClientSize();\n        const ctm = this.graph.matrix();\n        const prop = {};\n        if (typeof x === 'number') {\n            prop.scrollLeft = x - size.width / 2 + ctm.e + (this.padding.left || 0);\n        }\n        if (typeof y === 'number') {\n            prop.scrollTop = y - size.height / 2 + ctm.f + (this.padding.top || 0);\n        }\n        if (options && options.animation) {\n            this.$container.animate(prop, options.animation);\n        }\n        else {\n            this.$container.prop(prop);\n        }\n        return this;\n    }\n    /**\n     * Try to scroll to ensure that the center of graph content is at the\n     * center of the viewport.\n     */\n    scrollToContent(options) {\n        const sx = this.sx;\n        const sy = this.sy;\n        const center = this.graph.getContentArea().getCenter();\n        return this.scrollToPoint(center.x * sx, center.y * sy, options);\n    }\n    /**\n     * Try to scroll to ensure that the center of cell is at the center of\n     * the viewport.\n     */\n    scrollToCell(cell, options) {\n        const sx = this.sx;\n        const sy = this.sy;\n        const center = cell.getBBox().getCenter();\n        return this.scrollToPoint(center.x * sx, center.y * sy, options);\n    }\n    /**\n     * The center methods are more aggressive than the scroll methods. These\n     * methods position the graph so that a specific point on the graph lies\n     * at the center of the viewport, adding paddings around the paper if\n     * necessary (e.g. if the requested point lies in a corner of the paper).\n     * This means that the requested point will always move into the center\n     * of the viewport. (Use the scroll functions to avoid adding paddings\n     * and only scroll the viewport as far as the graph boundary.)\n     */\n    /**\n     * Position the center of graph to the center of the viewport.\n     */\n    center(optons) {\n        return this.centerPoint(optons);\n    }\n    centerPoint(x, y, options) {\n        const ctm = this.graph.matrix();\n        const sx = ctm.a;\n        const sy = ctm.d;\n        const tx = -ctm.e;\n        const ty = -ctm.f;\n        const tWidth = tx + this.graph.options.width;\n        const tHeight = ty + this.graph.options.height;\n        let localOptions;\n        this.storeClientSize(); // avoid multilple reflow\n        if (typeof x === 'number' || typeof y === 'number') {\n            localOptions = options;\n            const visibleCenter = this.getVisibleArea().getCenter();\n            if (typeof x === 'number') {\n                x *= sx; // eslint-disable-line\n            }\n            else {\n                x = visibleCenter.x; // eslint-disable-line\n            }\n            if (typeof y === 'number') {\n                y *= sy; // eslint-disable-line\n            }\n            else {\n                y = visibleCenter.y; // eslint-disable-line\n            }\n        }\n        else {\n            localOptions = x;\n            x = (tx + tWidth) / 2; // eslint-disable-line\n            y = (ty + tHeight) / 2; // eslint-disable-line\n        }\n        if (localOptions && localOptions.padding) {\n            return this.positionPoint({ x, y }, '50%', '50%', localOptions);\n        }\n        const padding = this.getPadding();\n        const clientSize = this.getClientSize();\n        const cx = clientSize.width / 2;\n        const cy = clientSize.height / 2;\n        const left = cx - padding.left - x + tx;\n        const right = cx - padding.right + x - tWidth;\n        const top = cy - padding.top - y + ty;\n        const bottom = cy - padding.bottom + y - tHeight;\n        this.addPadding(Math.max(left, 0), Math.max(right, 0), Math.max(top, 0), Math.max(bottom, 0));\n        const result = this.scrollToPoint(x, y, localOptions || undefined);\n        this.restoreClientSize();\n        return result;\n    }\n    centerContent(options) {\n        return this.positionContent('center', options);\n    }\n    centerCell(cell, options) {\n        return this.positionCell(cell, 'center', options);\n    }\n    /**\n     * The position methods are a more general version of the center methods.\n     * They position the graph so that a specific point on the graph lies at\n     * requested coordinates inside the viewport.\n     */\n    /**\n     *\n     */\n    positionContent(pos, options) {\n        const rect = this.graph.getContentArea(options);\n        return this.positionRect(rect, pos, options);\n    }\n    positionCell(cell, pos, options) {\n        const bbox = cell.getBBox();\n        return this.positionRect(bbox, pos, options);\n    }\n    positionRect(rect, pos, options) {\n        const bbox = Rectangle.create(rect);\n        switch (pos) {\n            case 'center':\n                return this.positionPoint(bbox.getCenter(), '50%', '50%', options);\n            case 'top':\n                return this.positionPoint(bbox.getTopCenter(), '50%', 0, options);\n            case 'top-right':\n                return this.positionPoint(bbox.getTopRight(), '100%', 0, options);\n            case 'right':\n                return this.positionPoint(bbox.getRightMiddle(), '100%', '50%', options);\n            case 'bottom-right':\n                return this.positionPoint(bbox.getBottomRight(), '100%', '100%', options);\n            case 'bottom':\n                return this.positionPoint(bbox.getBottomCenter(), '50%', '100%', options);\n            case 'bottom-left':\n                return this.positionPoint(bbox.getBottomLeft(), 0, '100%', options);\n            case 'left':\n                return this.positionPoint(bbox.getLeftMiddle(), 0, '50%', options);\n            case 'top-left':\n                return this.positionPoint(bbox.getTopLeft(), 0, 0, options);\n            default:\n                return this;\n        }\n    }\n    positionPoint(point, x, y, options = {}) {\n        const { padding: pad } = options, localOptions = __rest(options, [\"padding\"]);\n        const padding = NumberExt.normalizeSides(pad);\n        const clientRect = Rectangle.fromSize(this.getClientSize());\n        const targetRect = clientRect.clone().moveAndExpand({\n            x: padding.left,\n            y: padding.top,\n            width: -padding.right - padding.left,\n            height: -padding.top - padding.bottom,\n        });\n        // eslint-disable-next-line\n        x = NumberExt.normalizePercentage(x, Math.max(0, targetRect.width));\n        if (x < 0) {\n            x = targetRect.width + x; // eslint-disable-line\n        }\n        // eslint-disable-next-line\n        y = NumberExt.normalizePercentage(y, Math.max(0, targetRect.height));\n        if (y < 0) {\n            y = targetRect.height + y; // eslint-disable-line\n        }\n        const origin = targetRect.getTopLeft().translate(x, y);\n        const diff = clientRect.getCenter().diff(origin);\n        const scale = this.zoom();\n        const rawDiff = diff.scale(1 / scale, 1 / scale);\n        const result = Point.create(point).translate(rawDiff);\n        return this.centerPoint(result.x, result.y, localOptions);\n    }\n    zoom(factor, options) {\n        if (factor == null) {\n            return this.sx;\n        }\n        options = options || {}; // eslint-disable-line\n        let cx;\n        let cy;\n        const clientSize = this.getClientSize();\n        const center = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n        let sx = factor;\n        let sy = factor;\n        if (!options.absolute) {\n            sx += this.sx;\n            sy += this.sy;\n        }\n        if (options.scaleGrid) {\n            sx = Math.round(sx / options.scaleGrid) * options.scaleGrid;\n            sy = Math.round(sy / options.scaleGrid) * options.scaleGrid;\n        }\n        if (options.maxScale) {\n            sx = Math.min(options.maxScale, sx);\n            sy = Math.min(options.maxScale, sy);\n        }\n        if (options.minScale) {\n            sx = Math.max(options.minScale, sx);\n            sy = Math.max(options.minScale, sy);\n        }\n        sx = this.graph.transform.clampScale(sx);\n        sy = this.graph.transform.clampScale(sy);\n        if (options.center) {\n            const fx = sx / this.sx;\n            const fy = sy / this.sy;\n            cx = options.center.x - (options.center.x - center.x) / fx;\n            cy = options.center.y - (options.center.y - center.y) / fy;\n        }\n        else {\n            cx = center.x;\n            cy = center.y;\n        }\n        this.beforeManipulation();\n        this.graph.transform.scale(sx, sy);\n        this.centerPoint(cx, cy);\n        this.afterManipulation();\n        return this;\n    }\n    zoomToRect(rect, options = {}) {\n        const area = Rectangle.create(rect);\n        const graph = this.graph;\n        options.contentArea = area;\n        if (options.viewportArea == null) {\n            options.viewportArea = {\n                x: graph.options.x,\n                y: graph.options.y,\n                width: this.$container.width(),\n                height: this.$container.height(),\n            };\n        }\n        this.beforeManipulation();\n        graph.transform.scaleContentToFitImpl(options, false);\n        const center = area.getCenter();\n        this.centerPoint(center.x, center.y);\n        this.afterManipulation();\n        return this;\n    }\n    zoomToFit(options = {}) {\n        return this.zoomToRect(this.graph.getContentArea(options), options);\n    }\n    transitionToPoint(x, y, options) {\n        if (typeof x === 'object') {\n            options = y; // eslint-disable-line\n            y = x.y; // eslint-disable-line\n            x = x.x; // eslint-disable-line\n        }\n        else {\n            y = y; // eslint-disable-line\n        }\n        if (options == null) {\n            options = {}; // eslint-disable-line\n        }\n        let transform;\n        let transformOrigin;\n        const scale = this.sx;\n        const targetScale = Math.max(options.scale || scale, 0.000001);\n        const clientSize = this.getClientSize();\n        const targetPoint = new Point(x, y);\n        const localPoint = this.clientToLocalPoint(clientSize.width / 2, clientSize.height / 2);\n        if (scale === targetScale) {\n            const translate = localPoint.diff(targetPoint).scale(scale, scale).round();\n            transform = `translate(${translate.x}px,${translate.y}px)`;\n        }\n        else {\n            const delta = (targetScale / (scale - targetScale)) * targetPoint.distance(localPoint);\n            const range = localPoint.clone().move(targetPoint, delta);\n            const origin = this.localToBackgroundPoint(range).round();\n            transform = `scale(${targetScale / scale})`;\n            transformOrigin = `${origin.x}px ${origin.y}px`;\n        }\n        const onTransitionEnd = options.onTransitionEnd;\n        this.$container.addClass(Util.transitionClassName);\n        this.$content\n            .off(Util.transitionEventName)\n            .on(Util.transitionEventName, (e) => {\n            this.syncTransition(targetScale, { x: x, y: y });\n            if (typeof onTransitionEnd === 'function') {\n                FunctionExt.call(onTransitionEnd, this, e.originalEvent);\n            }\n        })\n            .css({\n            transform,\n            transformOrigin,\n            transition: 'transform',\n            transitionDuration: options.duration || '1s',\n            transitionDelay: options.delay,\n            transitionTimingFunction: options.timing,\n        });\n        return this;\n    }\n    syncTransition(scale, p) {\n        this.beforeManipulation();\n        this.graph.scale(scale);\n        this.removeTransition();\n        this.centerPoint(p.x, p.y);\n        this.afterManipulation();\n        return this;\n    }\n    removeTransition() {\n        this.$container.removeClass(Util.transitionClassName);\n        this.$content.off(Util.transitionEventName).css({\n            transform: '',\n            transformOrigin: '',\n            transition: '',\n            transitionDuration: '',\n            transitionDelay: '',\n            transitionTimingFunction: '',\n        });\n        return this;\n    }\n    transitionToRect(rectangle, options = {}) {\n        const rect = Rectangle.create(rectangle);\n        const maxScale = options.maxScale || Infinity;\n        const minScale = options.minScale || Number.MIN_VALUE;\n        const scaleGrid = options.scaleGrid || null;\n        const PIXEL_SIZE = options.visibility || 1;\n        const center = options.center\n            ? Point.create(options.center)\n            : rect.getCenter();\n        const clientSize = this.getClientSize();\n        const w = clientSize.width * PIXEL_SIZE;\n        const h = clientSize.height * PIXEL_SIZE;\n        let scale = new Rectangle(center.x - w / 2, center.y - h / 2, w, h).getMaxUniformScaleToFit(rect, center);\n        scale = Math.min(scale, maxScale);\n        if (scaleGrid) {\n            scale = Math.floor(scale / scaleGrid) * scaleGrid;\n        }\n        scale = Math.max(minScale, scale);\n        return this.transitionToPoint(center, Object.assign({ scale }, options));\n    }\n    startPanning(evt) {\n        const e = this.normalizeEvent(evt);\n        this.clientX = e.clientX;\n        this.clientY = e.clientY;\n        this.trigger('pan:start', { e });\n        this.$(document.body).on({\n            'mousemove.panning touchmove.panning': this.pan.bind(this),\n            'mouseup.panning touchend.panning': this.stopPanning.bind(this),\n        });\n        this.$(window).on('mouseup.panning', this.stopPanning.bind(this));\n    }\n    pan(evt) {\n        const e = this.normalizeEvent(evt);\n        const dx = e.clientX - this.clientX;\n        const dy = e.clientY - this.clientY;\n        this.container.scrollTop -= dy;\n        this.container.scrollLeft -= dx;\n        this.clientX = e.clientX;\n        this.clientY = e.clientY;\n        this.trigger('panning', { e });\n    }\n    stopPanning(e) {\n        this.$(document.body).off('.panning');\n        this.$(window).off('.panning');\n        this.trigger('pan:stop', { e });\n    }\n    clientToLocalPoint(a, b) {\n        let x = typeof a === 'object' ? a.x : a;\n        let y = typeof a === 'object' ? a.y : b;\n        const ctm = this.graph.matrix();\n        x += this.container.scrollLeft - this.padding.left - ctm.e;\n        y += this.container.scrollTop - this.padding.top - ctm.f;\n        return new Point(x / ctm.a, y / ctm.d);\n    }\n    localToBackgroundPoint(x, y) {\n        const p = typeof x === 'object' ? Point.create(x) : new Point(x, y);\n        const ctm = this.graph.matrix();\n        const padding = this.padding;\n        return Dom.transformPoint(p, ctm).translate(padding.left, padding.top);\n    }\n    resize(width, height) {\n        let w = width != null ? width : this.container.clientWidth;\n        let h = height != null ? height : this.container.clientHeight;\n        if (typeof w === 'number') {\n            w = Math.round(w);\n        }\n        if (typeof h === 'number') {\n            h = Math.round(h);\n        }\n        this.options.width = w;\n        this.options.height = h;\n        this.$container.css({ width: w, height: h });\n        this.update();\n    }\n    getClientSize() {\n        if (this.cachedClientSize) {\n            return this.cachedClientSize;\n        }\n        return {\n            width: this.container.clientWidth,\n            height: this.container.clientHeight,\n        };\n    }\n    autoScroll(clientX, clientY) {\n        const buffer = 10;\n        const container = this.container;\n        const rect = container.getBoundingClientRect();\n        let dx = 0;\n        let dy = 0;\n        if (clientX <= rect.left + buffer) {\n            dx = -buffer;\n        }\n        if (clientY <= rect.top + buffer) {\n            dy = -buffer;\n        }\n        if (clientX >= rect.right - buffer) {\n            dx = buffer;\n        }\n        if (clientY >= rect.bottom - buffer) {\n            dy = buffer;\n        }\n        if (dx !== 0) {\n            container.scrollLeft += dx;\n        }\n        if (dy !== 0) {\n            container.scrollTop += dy;\n        }\n        return {\n            scrollerX: dx,\n            scrollerY: dy,\n        };\n    }\n    addPadding(left, right, top, bottom) {\n        let padding = this.getPadding();\n        this.padding = {\n            left: Math.round(padding.left + (left || 0)),\n            top: Math.round(padding.top + (top || 0)),\n            bottom: Math.round(padding.bottom + (bottom || 0)),\n            right: Math.round(padding.right + (right || 0)),\n        };\n        padding = this.padding;\n        this.$content.css({\n            width: padding.left + this.graph.options.width + padding.right,\n            height: padding.top + this.graph.options.height + padding.bottom,\n        });\n        const container = this.graph.container;\n        container.style.left = `${this.padding.left}px`;\n        container.style.top = `${this.padding.top}px`;\n        return this;\n    }\n    getPadding() {\n        const padding = this.options.padding;\n        if (typeof padding === 'function') {\n            return NumberExt.normalizeSides(FunctionExt.call(padding, this, this));\n        }\n        return NumberExt.normalizeSides(padding);\n    }\n    /**\n     * Returns the untransformed size and origin of the current viewport.\n     */\n    getVisibleArea() {\n        const ctm = this.graph.matrix();\n        const size = this.getClientSize();\n        const box = {\n            x: this.container.scrollLeft || 0,\n            y: this.container.scrollTop || 0,\n            width: size.width,\n            height: size.height,\n        };\n        const area = Dom.transformRectangle(box, ctm.inverse());\n        area.x -= (this.padding.left || 0) / this.sx;\n        area.y -= (this.padding.top || 0) / this.sy;\n        return area;\n    }\n    isCellVisible(cell, options = {}) {\n        const bbox = cell.getBBox();\n        const area = this.getVisibleArea();\n        return options.strict\n            ? area.containsRect(bbox)\n            : area.isIntersectWithRect(bbox);\n    }\n    isPointVisible(point) {\n        return this.getVisibleArea().containsPoint(point);\n    }\n    /**\n     * Lock the current viewport by disabling user scrolling.\n     */\n    lock() {\n        this.$container.css('overflow', 'hidden');\n        return this;\n    }\n    /**\n     * Enable user scrolling if previously locked.\n     */\n    unlock() {\n        this.$container.css('overflow', 'scroll');\n        return this;\n    }\n    onRemove() {\n        this.stopListening();\n    }\n    dispose() {\n        this.$(this.graph.container).insertBefore(this.$container);\n        this.remove();\n    }\n}\n__decorate([\n    View.dispose()\n], Scroller.prototype, \"dispose\", null);\n(function (Scroller) {\n    class Background extends BackgroundManager {\n        constructor(scroller) {\n            super(scroller.graph);\n            this.scroller = scroller;\n            if (scroller.options.background) {\n                this.draw(scroller.options.background);\n            }\n        }\n        get elem() {\n            return this.scroller.background;\n        }\n        init() {\n            this.graph.on('scale', this.update, this);\n            this.graph.on('translate', this.update, this);\n        }\n        updateBackgroundOptions(options) {\n            this.scroller.options.background = options;\n        }\n    }\n    Scroller.Background = Background;\n})(Scroller || (Scroller = {}));\nvar Util;\n(function (Util) {\n    Util.containerClass = 'graph-scroller';\n    Util.panningClass = `${Util.containerClass}-panning`;\n    Util.pannableClass = `${Util.containerClass}-pannable`;\n    Util.pagedClass = `${Util.containerClass}-paged`;\n    Util.contentClass = `${Util.containerClass}-content`;\n    Util.backgroundClass = `${Util.containerClass}-background`;\n    Util.transitionClassName = 'transition-in-progress';\n    Util.transitionEventName = 'transitionend.graph-scroller-transition';\n    Util.defaultOptions = {\n        padding() {\n            const size = this.getClientSize();\n            const minWidth = Math.max(this.options.minVisibleWidth || 0, 1) || 1;\n            const minHeight = Math.max(this.options.minVisibleHeight || 0, 1) || 1;\n            const left = Math.max(size.width - minWidth, 0);\n            const top = Math.max(size.height - minHeight, 0);\n            return { left, top, right: left, bottom: top };\n        },\n        minVisibleWidth: 50,\n        minVisibleHeight: 50,\n        pageVisible: false,\n        pageBreak: false,\n        autoResize: true,\n    };\n    function getOptions(options) {\n        const result = ObjectExt.merge({}, Util.defaultOptions, options);\n        if (result.pageWidth == null) {\n            result.pageWidth = options.graph.options.width;\n        }\n        if (result.pageHeight == null) {\n            result.pageHeight = options.graph.options.height;\n        }\n        return result;\n    }\n    Util.getOptions = getOptions;\n})(Util || (Util = {}));\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}