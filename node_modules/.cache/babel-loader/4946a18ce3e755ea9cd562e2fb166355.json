{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getConnectedComponents;\nexports.detectStrongConnectComponents = exports.detectConnectedComponents = void 0;\n\nvar _util = require(\"./util\");\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\n\n\nvar detectConnectedComponents = function detectConnectedComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    var neighbors = (0, _util.getNeighbors)(node.id, edges);\n\n    var _loop_1 = function _loop_1(i) {\n      var neighbor = neighbors[i];\n\n      if (!visited[neighbor]) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === neighbor;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; ++i) {\n      _loop_1(i);\n    }\n  };\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n\n      allComponents.push(component);\n    }\n  }\n\n  return allComponents;\n};\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\n\n\nexports.detectConnectedComponents = detectConnectedComponents;\n\nvar detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true; // 考虑每个邻接点\n\n    var neighbors = (0, _util.getNeighbors)(node.id, edges, 'target').filter(function (n) {\n      return nodes.map(function (node) {\n        return node.id;\n      }).indexOf(n) > -1;\n    });\n\n    var _loop_2 = function _loop_2(i) {\n      var targetNodeID = neighbors[i];\n\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === targetNodeID;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        } // tree edge\n\n\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; i++) {\n      _loop_2(i);\n    } // If node is a root node, generate an SCC\n\n\n    if (lowLink[node.id] === indices[node.id]) {\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n};\n\nexports.detectStrongConnectComponents = detectStrongConnectComponents;\n\nfunction getConnectedComponents(graphData, directed) {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/@antv/algorithm/lib/connected-component.js"],"names":["Object","defineProperty","exports","value","default","getConnectedComponents","detectStrongConnectComponents","detectConnectedComponents","_util","require","graphData","_a","nodes","_b","edges","allComponents","visited","nodeStack","getComponent","node","push","id","neighbors","getNeighbors","_loop_1","i","neighbor","targetNode","filter","length","component","pop","inStack","indices","lowLink","index","n","map","indexOf","_loop_2","targetNodeID","Math","min","tmpNode","_i","nodes_1","directed"],"mappings":"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","sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = getConnectedComponents;\nexports.detectStrongConnectComponents = exports.detectConnectedComponents = void 0;\n\nvar _util = require(\"./util\");\n\n/**\n * Generate all connected components for an undirected graph\n * @param graph\n */\nvar detectConnectedComponents = function detectConnectedComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var allComponents = [];\n  var visited = {};\n  var nodeStack = [];\n\n  var getComponent = function getComponent(node) {\n    nodeStack.push(node);\n    visited[node.id] = true;\n    var neighbors = (0, _util.getNeighbors)(node.id, edges);\n\n    var _loop_1 = function _loop_1(i) {\n      var neighbor = neighbors[i];\n\n      if (!visited[neighbor]) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === neighbor;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        }\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; ++i) {\n      _loop_1(i);\n    }\n  };\n\n  for (var i = 0; i < nodes.length; i++) {\n    var node = nodes[i];\n\n    if (!visited[node.id]) {\n      // 对于无向图进行dfs遍历，每一次调用后都得到一个连通分量\n      getComponent(node);\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        component.push(nodeStack.pop());\n      }\n\n      allComponents.push(component);\n    }\n  }\n\n  return allComponents;\n};\n/**\n * Tarjan's Algorithm 复杂度  O(|V|+|E|)\n * For directed graph only\n * a directed graph is said to be strongly connected if \"every vertex is reachable from every other vertex\".\n * refer: http://en.wikipedia.org/wiki/Tarjan%27s_strongly_connected_components_algorithm\n * @param graph\n * @return a list of strongly connected components\n */\n\n\nexports.detectConnectedComponents = detectConnectedComponents;\n\nvar detectStrongConnectComponents = function detectStrongConnectComponents(graphData) {\n  var _a = graphData.nodes,\n      nodes = _a === void 0 ? [] : _a,\n      _b = graphData.edges,\n      edges = _b === void 0 ? [] : _b;\n  var nodeStack = [];\n  var inStack = {}; // 辅助判断是否已经在stack中，减少查找开销\n\n  var indices = {};\n  var lowLink = {};\n  var allComponents = [];\n  var index = 0;\n\n  var getComponent = function getComponent(node) {\n    // Set the depth index for v to the smallest unused index\n    indices[node.id] = index;\n    lowLink[node.id] = index;\n    index += 1;\n    nodeStack.push(node);\n    inStack[node.id] = true; // 考虑每个邻接点\n\n    var neighbors = (0, _util.getNeighbors)(node.id, edges, 'target').filter(function (n) {\n      return nodes.map(function (node) {\n        return node.id;\n      }).indexOf(n) > -1;\n    });\n\n    var _loop_2 = function _loop_2(i) {\n      var targetNodeID = neighbors[i];\n\n      if (!indices[targetNodeID] && indices[targetNodeID] !== 0) {\n        var targetNode = nodes.filter(function (node) {\n          return node.id === targetNodeID;\n        });\n\n        if (targetNode.length > 0) {\n          getComponent(targetNode[0]);\n        } // tree edge\n\n\n        lowLink[node.id] = Math.min(lowLink[node.id], lowLink[targetNodeID]);\n      } else if (inStack[targetNodeID]) {\n        // back edge, target node is in the current SCC\n        lowLink[node.id] = Math.min(lowLink[node.id], indices[targetNodeID]);\n      }\n    };\n\n    for (var i = 0; i < neighbors.length; i++) {\n      _loop_2(i);\n    } // If node is a root node, generate an SCC\n\n\n    if (lowLink[node.id] === indices[node.id]) {\n      var component = [];\n\n      while (nodeStack.length > 0) {\n        var tmpNode = nodeStack.pop();\n        inStack[tmpNode.id] = false;\n        component.push(tmpNode);\n        if (tmpNode === node) break;\n      }\n\n      if (component.length > 0) {\n        allComponents.push(component);\n      }\n    }\n  };\n\n  for (var _i = 0, nodes_1 = nodes; _i < nodes_1.length; _i++) {\n    var node = nodes_1[_i];\n\n    if (!indices[node.id] && indices[node.id] !== 0) {\n      getComponent(node);\n    }\n  }\n\n  return allComponents;\n};\n\nexports.detectStrongConnectComponents = detectStrongConnectComponents;\n\nfunction getConnectedComponents(graphData, directed) {\n  if (directed) return detectStrongConnectComponents(graphData);\n  return detectConnectedComponents(graphData);\n}"]},"metadata":{},"sourceType":"script"}