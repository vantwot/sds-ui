{"ast":null,"code":"import { __assign } from \"tslib\";\n/*\n * @Author: moyee\n * @LastEditors: moyee\n * @Description: 拖动 Combo\n */\n\nimport { each } from '@antv/util';\nimport Util from '../util';\nimport Global from '../global';\nvar calculationItemsBBox = Util.calculationItemsBBox;\n/**\n * 遍历拖动的 Combo 下的所有 Combo\n * @param data 拖动的 Combo\n * @param fn\n */\n\nvar traverseCombo = function traverseCombo(data, fn) {\n  if (fn(data) === false) {\n    return;\n  }\n\n  if (data) {\n    var combos = data.get('combos');\n\n    if (combos.length === 0) {\n      return false;\n    }\n\n    each(combos, function (child) {\n      traverseCombo(child, fn);\n    });\n  }\n};\n\nexport default {\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      enableDelegate: false,\n      delegateStyle: {},\n      // 拖动节点过程中是否只改变 Combo 的大小，而不改变其结构\n      onlyChangeComboSize: false,\n      // 拖动过程中目标 combo 状态样式\n      activeState: '',\n      selectedState: 'selected'\n    };\n  },\n  getEvents: function getEvents() {\n    return {\n      'combo:dragstart': 'onDragStart',\n      'combo:drag': 'onDrag',\n      'combo:dragend': 'onDragEnd',\n      'combo:drop': 'onDrop',\n      'node:drop': 'onNodeDrop',\n      'combo:dragenter': 'onDragEnter',\n      'combo:dragleave': 'onDragLeave'\n    };\n  },\n  validationCombo: function validationCombo(evt) {\n    var item = evt.item;\n\n    if (!item || item.destroyed) {\n      return false;\n    }\n\n    if (!this.shouldUpdate.call(this, evt)) {\n      return false;\n    }\n\n    var type = item.getType();\n\n    if (type !== 'combo') {\n      return false;\n    }\n\n    return true;\n  },\n  onDragStart: function onDragStart(evt) {\n    var _this = this;\n\n    var graph = this.graph;\n    var item = evt.item;\n    this.currentShouldEnd = true;\n    if (!this.validationCombo(evt)) return;\n    this.targets = []; // 获取所有选中的 Combo\n\n    var combos = graph.findAllByState('combo', this.selectedState);\n    var currentCombo = item.get('id');\n    var dragCombos = combos.filter(function (combo) {\n      var comboId = combo.get('id');\n      return currentCombo === comboId;\n    });\n\n    if (dragCombos.length === 0) {\n      this.targets.push(item);\n    } else {\n      this.targets = combos;\n    }\n\n    if (this.activeState) {\n      this.targets.map(function (combo) {\n        var model = combo.getModel();\n\n        if (model.parentId) {\n          var parentCombo = graph.findById(model.parentId);\n\n          if (parentCombo) {\n            graph.setItemState(parentCombo, _this.activeState, true);\n          }\n        }\n      });\n    }\n\n    this.point = {};\n    this.originPoint = {};\n    this.origin = {\n      x: evt.x,\n      y: evt.y\n    };\n    this.currentItemChildCombos = [];\n    traverseCombo(item, function (param) {\n      if (param.destroyed) {\n        return false;\n      }\n\n      var model = param.getModel();\n\n      _this.currentItemChildCombos.push(model.id);\n\n      return true;\n    });\n  },\n  onDrag: function onDrag(evt) {\n    var _this = this;\n\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.validationCombo(evt)) return;\n\n    if (this.enableDelegate) {\n      this.updateDelegate(evt);\n    } else {\n      if (this.activeState) {\n        var graph_1 = this.graph;\n        var item = evt.item;\n        var model_1 = item.getModel(); // 拖动过程中实时计算距离\n\n        var combos = graph_1.getCombos();\n        var sourceBBox = item.getBBox();\n        var centerX_1 = sourceBBox.centerX,\n            centerY_1 = sourceBBox.centerY,\n            width_1 = sourceBBox.width; // 参与计算的 Combo，需要排除掉：\n        // 1、拖动 combo 自己\n        // 2、拖动 combo 的 parent\n        // 3、拖动 Combo 的 children\n\n        var calcCombos = combos.filter(function (combo) {\n          var cmodel = combo.getModel(); // 被拖动的是最外层的 Combo，无 parent，排除自身和子元素\n\n          if (!model_1.parentId) {\n            return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);\n          }\n\n          return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);\n        });\n        calcCombos.map(function (combo) {\n          var _a = combo.getBBox(),\n              cx = _a.centerX,\n              cy = _a.centerY,\n              w = _a.width; // 拖动的 combo 和要进入的 combo 之间的距离\n\n\n          var disX = centerX_1 - cx;\n          var disY = centerY_1 - cy; // 圆心距离\n\n          var distance = 2 * Math.sqrt(disX * disX + disY * disY);\n\n          if (width_1 + w - distance > 0.8 * width_1) {\n            graph_1.setItemState(combo, _this.activeState, true);\n          } else {\n            graph_1.setItemState(combo, _this.activeState, false);\n          }\n        });\n      }\n\n      each(this.targets, function (item) {\n        _this.updateCombo(item, evt);\n      });\n    }\n  },\n  updatePositions: function updatePositions(evt, restore) {\n    var _this = this; // 当启用 delegate 时，拖动结束时需要更新 combo\n\n\n    if (this.enableDelegate || restore) {\n      each(this.targets, function (item) {\n        _this.updateCombo(item, evt, restore);\n      });\n    }\n  },\n  onDrop: function onDrop(evt) {\n    var _this = this; // 被放下的目标 combo\n\n\n    var item = evt.item;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, item);\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.currentShouldEnd || !item || !this.targets || item.destroyed) return;\n    var graph = this.graph;\n    var targetModel = item.getModel();\n    this.targets.map(function (combo) {\n      var model = combo.getModel();\n\n      if (model.parentId !== targetModel.id) {\n        if (_this.activeState) {\n          graph.setItemState(item, _this.activeState, false);\n        } // 将 Combo 放置到某个 Combo 上面时，只有当 onlyChangeComboSize 为 false 时候才更新 Combo 结构\n\n\n        if (!_this.onlyChangeComboSize) {\n          graph.updateComboTree(combo, targetModel.id);\n        } else {\n          graph.updateCombo(combo);\n        }\n      } else {\n        graph.updateCombo(item);\n      }\n    });\n    this.end(item, evt); // 如果已经拖放下了，则不需要再通过距离判断了\n\n    this.endComparison = true;\n  },\n  onNodeDrop: function onNodeDrop(evt) {\n    var _this = this;\n\n    if (!this.targets || this.targets.length === 0) return;\n    var graph = this.graph;\n    var item = evt.item;\n    var comboId = item.getModel().comboId;\n    var newParentCombo = comboId ? graph.findById(comboId) : undefined;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, newParentCombo);\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.currentShouldEnd) return;\n    var droppedCombo; // 如果被放置的的节点有 comboId，且这个 comboId 与正在被拖拽的 combo 的父 id 不相同，则更新父亲为 comboId\n\n    if (comboId) {\n      if (this.activeState) {\n        var combo = graph.findById(comboId);\n        graph.setItemState(combo, this.activeState, false);\n      }\n\n      this.targets.map(function (combo) {\n        if (!_this.onlyChangeComboSize) {\n          if (comboId !== combo.getID()) {\n            droppedCombo = graph.findById(comboId);\n            if (comboId !== combo.getModel().parentId) graph.updateComboTree(combo, comboId);\n          }\n        } else {\n          graph.updateCombo(combo);\n        }\n      });\n    } else {\n      // 如果被放置的节点没有 comboId，且正在被拖拽的 combo 有父 id，则更新父亲为 undefined\n      this.targets.map(function (combo) {\n        if (!_this.onlyChangeComboSize) {\n          var model = combo.getModel();\n\n          if (model.comboId) {\n            graph.updateComboTree(combo);\n          }\n        } else {\n          graph.updateCombo(combo);\n        }\n      });\n    } // 如果已经拖放下了，则不需要再通过距离判断了\n\n\n    this.endComparison = true;\n    this.end(droppedCombo, evt);\n  },\n  onDragEnter: function onDragEnter(evt) {\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.validationCombo(evt)) return;\n    var item = evt.item;\n    var graph = this.graph;\n\n    if (this.activeState) {\n      graph.setItemState(item, this.activeState, true);\n    }\n  },\n  onDragLeave: function onDragLeave(evt) {\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.validationCombo(evt)) return;\n    var item = evt.item;\n    var graph = this.graph;\n\n    if (this.activeState) {\n      graph.setItemState(item, this.activeState, false);\n    }\n  },\n  onDragEnd: function onDragEnd(evt) {\n    if (!this.targets || this.targets.length === 0) return;\n    var item = evt.item;\n\n    if (this.currentShouldEnd) {\n      this.updatePositions(evt);\n    }\n\n    var parentCombo = this.getParentCombo(item.getModel().parentId);\n    var graph = this.graph;\n\n    if (parentCombo && this.activeState) {\n      graph.setItemState(parentCombo, this.activeState, false);\n    }\n\n    this.end(undefined, evt);\n  },\n  end: function end(comboDropedOn, evt) {\n    var _this = this;\n\n    if (!this.origin) return;\n    var graph = this.graph; // 删除delegate shape\n\n    if (this.delegateShape) {\n      var delegateGroup = graph.get('delegateGroup');\n      delegateGroup.clear();\n      this.delegateShape = null;\n    }\n\n    if (comboDropedOn && this.activeState) {\n      graph.setItemState(comboDropedOn, this.activeState, false);\n    } // 若没有被放置的 combo，则是被放置在画布上\n\n\n    if (!comboDropedOn) {\n      this.targets.map(function (combo) {\n        // 将 Combo 放置到某个 Combo 上面时，只有当 onlyChangeComboSize 为 false 时候才更新 Combo 结构\n        if (!_this.onlyChangeComboSize) {\n          graph.updateComboTree(combo);\n        } else {\n          graph.updateCombo(combo);\n        }\n      });\n    }\n\n    this.point = [];\n    this.origin = null;\n    this.originPoint = null;\n    this.targets.length = 0;\n  },\n\n  /**\n   * 遍历 comboTree，分别更新 node 和 combo\n   * @param data\n   * @param fn\n   */\n  traverse: function traverse(data, fn) {\n    var _this = this;\n\n    if (fn(data) === false) {\n      return;\n    }\n\n    if (data) {\n      var combos = data.get('combos');\n      each(combos, function (child) {\n        _this.traverse(child, fn);\n      });\n      var nodes = data.get('nodes');\n      each(nodes, function (child) {\n        _this.traverse(child, fn);\n      });\n    }\n  },\n  updateCombo: function updateCombo(item, evt, restore) {\n    var _this = this;\n\n    this.traverse(item, function (param) {\n      if (param.destroyed) {\n        return false;\n      }\n\n      _this.updateSignleItem(param, evt, restore);\n\n      return true;\n    });\n  },\n\n  /**\n   *\n   * @param item 当前正在拖动的元素\n   * @param evt\n   */\n  updateSignleItem: function updateSignleItem(item, evt, restore) {\n    var origin = this.origin;\n    var graph = this.graph;\n    var model = item.getModel();\n    var itemId = item.get('id');\n\n    if (!this.point[itemId]) {\n      this.point[itemId] = {\n        x: model.x,\n        y: model.y\n      };\n    }\n\n    var x = evt.x - origin.x + this.point[itemId].x;\n    var y = evt.y - origin.y + this.point[itemId].y;\n\n    if (restore) {\n      x += origin.x - evt.x;\n      y += origin.y - evt.y;\n    }\n\n    graph.updateItem(item, {\n      x: x,\n      y: y\n    });\n  },\n\n  /**\n   * 根据 ID 获取父 Combo\n   * @param parentId 父 Combo ID\n   */\n  getParentCombo: function getParentCombo(parentId) {\n    var graph = this.graph;\n\n    if (!parentId) {\n      return undefined;\n    }\n\n    var parentCombo = graph.findById(parentId);\n\n    if (!parentCombo) {\n      return undefined;\n    }\n\n    return parentCombo;\n  },\n  updateDelegate: function updateDelegate(evt) {\n    var graph = this.graph; // 当没有 delegate shape 时创建\n\n    if (!this.delegateShape) {\n      var delegateGroup = graph.get('delegateGroup');\n      var bbox = null;\n\n      if (this.targets.length > 1) {\n        bbox = calculationItemsBBox(this.targets);\n      } else {\n        bbox = this.targets[0].getBBox();\n      }\n\n      var x = bbox.x,\n          y = bbox.y,\n          width = bbox.width,\n          height = bbox.height,\n          minX = bbox.minX,\n          minY = bbox.minY;\n      this.originPoint = {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        minX: minX,\n        minY: minY\n      };\n\n      var attrs = __assign(__assign({}, Global.delegateStyle), this.delegateStyle);\n\n      this.delegateShape = delegateGroup.addShape('rect', {\n        attrs: __assign({\n          width: bbox.width,\n          height: bbox.height,\n          x: bbox.x,\n          y: bbox.y\n        }, attrs),\n        name: 'combo-delegate-shape'\n      });\n      this.delegateShape.set('capture', false);\n      this.delegate = this.delegateShape;\n    } else {\n      var clientX = evt.x - this.origin.x + this.originPoint.minX;\n      var clientY = evt.y - this.origin.y + this.originPoint.minY;\n      this.delegateShape.attr({\n        x: clientX,\n        y: clientY\n      });\n    }\n  }\n};","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/@antv/g6-pc/es/behavior/drag-combo.js"],"names":["__assign","each","Util","Global","calculationItemsBBox","traverseCombo","data","fn","combos","get","length","child","getDefaultCfg","enableDelegate","delegateStyle","onlyChangeComboSize","activeState","selectedState","getEvents","validationCombo","evt","item","destroyed","shouldUpdate","call","type","getType","onDragStart","_this","graph","currentShouldEnd","targets","findAllByState","currentCombo","dragCombos","filter","combo","comboId","push","map","model","getModel","parentId","parentCombo","findById","setItemState","point","originPoint","origin","x","y","currentItemChildCombos","param","id","onDrag","updateDelegate","graph_1","model_1","getCombos","sourceBBox","getBBox","centerX_1","centerX","centerY_1","centerY","width_1","width","calcCombos","cmodel","includes","_a","cx","cy","w","disX","disY","distance","Math","sqrt","updateCombo","updatePositions","restore","onDrop","shouldEnd","targetModel","updateComboTree","end","endComparison","onNodeDrop","newParentCombo","undefined","droppedCombo","getID","onDragEnter","onDragLeave","onDragEnd","getParentCombo","comboDropedOn","delegateShape","delegateGroup","clear","traverse","nodes","updateSignleItem","itemId","updateItem","bbox","height","minX","minY","attrs","addShape","name","set","delegate","clientX","clientY","attr"],"mappings":"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","sourcesContent":["import { __assign } from \"tslib\";\n/*\n * @Author: moyee\n * @LastEditors: moyee\n * @Description: 拖动 Combo\n */\n\nimport { each } from '@antv/util';\nimport Util from '../util';\nimport Global from '../global';\nvar calculationItemsBBox = Util.calculationItemsBBox;\n/**\n * 遍历拖动的 Combo 下的所有 Combo\n * @param data 拖动的 Combo\n * @param fn\n */\n\nvar traverseCombo = function traverseCombo(data, fn) {\n  if (fn(data) === false) {\n    return;\n  }\n\n  if (data) {\n    var combos = data.get('combos');\n\n    if (combos.length === 0) {\n      return false;\n    }\n\n    each(combos, function (child) {\n      traverseCombo(child, fn);\n    });\n  }\n};\n\nexport default {\n  getDefaultCfg: function getDefaultCfg() {\n    return {\n      enableDelegate: false,\n      delegateStyle: {},\n      // 拖动节点过程中是否只改变 Combo 的大小，而不改变其结构\n      onlyChangeComboSize: false,\n      // 拖动过程中目标 combo 状态样式\n      activeState: '',\n      selectedState: 'selected'\n    };\n  },\n  getEvents: function getEvents() {\n    return {\n      'combo:dragstart': 'onDragStart',\n      'combo:drag': 'onDrag',\n      'combo:dragend': 'onDragEnd',\n      'combo:drop': 'onDrop',\n      'node:drop': 'onNodeDrop',\n      'combo:dragenter': 'onDragEnter',\n      'combo:dragleave': 'onDragLeave'\n    };\n  },\n  validationCombo: function validationCombo(evt) {\n    var item = evt.item;\n\n    if (!item || item.destroyed) {\n      return false;\n    }\n\n    if (!this.shouldUpdate.call(this, evt)) {\n      return false;\n    }\n\n    var type = item.getType();\n\n    if (type !== 'combo') {\n      return false;\n    }\n\n    return true;\n  },\n  onDragStart: function onDragStart(evt) {\n    var _this = this;\n\n    var graph = this.graph;\n    var item = evt.item;\n    this.currentShouldEnd = true;\n    if (!this.validationCombo(evt)) return;\n    this.targets = []; // 获取所有选中的 Combo\n\n    var combos = graph.findAllByState('combo', this.selectedState);\n    var currentCombo = item.get('id');\n    var dragCombos = combos.filter(function (combo) {\n      var comboId = combo.get('id');\n      return currentCombo === comboId;\n    });\n\n    if (dragCombos.length === 0) {\n      this.targets.push(item);\n    } else {\n      this.targets = combos;\n    }\n\n    if (this.activeState) {\n      this.targets.map(function (combo) {\n        var model = combo.getModel();\n\n        if (model.parentId) {\n          var parentCombo = graph.findById(model.parentId);\n\n          if (parentCombo) {\n            graph.setItemState(parentCombo, _this.activeState, true);\n          }\n        }\n      });\n    }\n\n    this.point = {};\n    this.originPoint = {};\n    this.origin = {\n      x: evt.x,\n      y: evt.y\n    };\n    this.currentItemChildCombos = [];\n    traverseCombo(item, function (param) {\n      if (param.destroyed) {\n        return false;\n      }\n\n      var model = param.getModel();\n\n      _this.currentItemChildCombos.push(model.id);\n\n      return true;\n    });\n  },\n  onDrag: function onDrag(evt) {\n    var _this = this;\n\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.validationCombo(evt)) return;\n\n    if (this.enableDelegate) {\n      this.updateDelegate(evt);\n    } else {\n      if (this.activeState) {\n        var graph_1 = this.graph;\n        var item = evt.item;\n        var model_1 = item.getModel(); // 拖动过程中实时计算距离\n\n        var combos = graph_1.getCombos();\n        var sourceBBox = item.getBBox();\n        var centerX_1 = sourceBBox.centerX,\n            centerY_1 = sourceBBox.centerY,\n            width_1 = sourceBBox.width; // 参与计算的 Combo，需要排除掉：\n        // 1、拖动 combo 自己\n        // 2、拖动 combo 的 parent\n        // 3、拖动 Combo 的 children\n\n        var calcCombos = combos.filter(function (combo) {\n          var cmodel = combo.getModel(); // 被拖动的是最外层的 Combo，无 parent，排除自身和子元素\n\n          if (!model_1.parentId) {\n            return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);\n          }\n\n          return cmodel.id !== model_1.id && !_this.currentItemChildCombos.includes(cmodel.id);\n        });\n        calcCombos.map(function (combo) {\n          var _a = combo.getBBox(),\n              cx = _a.centerX,\n              cy = _a.centerY,\n              w = _a.width; // 拖动的 combo 和要进入的 combo 之间的距离\n\n\n          var disX = centerX_1 - cx;\n          var disY = centerY_1 - cy; // 圆心距离\n\n          var distance = 2 * Math.sqrt(disX * disX + disY * disY);\n\n          if (width_1 + w - distance > 0.8 * width_1) {\n            graph_1.setItemState(combo, _this.activeState, true);\n          } else {\n            graph_1.setItemState(combo, _this.activeState, false);\n          }\n        });\n      }\n\n      each(this.targets, function (item) {\n        _this.updateCombo(item, evt);\n      });\n    }\n  },\n  updatePositions: function updatePositions(evt, restore) {\n    var _this = this; // 当启用 delegate 时，拖动结束时需要更新 combo\n\n\n    if (this.enableDelegate || restore) {\n      each(this.targets, function (item) {\n        _this.updateCombo(item, evt, restore);\n      });\n    }\n  },\n  onDrop: function onDrop(evt) {\n    var _this = this; // 被放下的目标 combo\n\n\n    var item = evt.item;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, item);\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.currentShouldEnd || !item || !this.targets || item.destroyed) return;\n    var graph = this.graph;\n    var targetModel = item.getModel();\n    this.targets.map(function (combo) {\n      var model = combo.getModel();\n\n      if (model.parentId !== targetModel.id) {\n        if (_this.activeState) {\n          graph.setItemState(item, _this.activeState, false);\n        } // 将 Combo 放置到某个 Combo 上面时，只有当 onlyChangeComboSize 为 false 时候才更新 Combo 结构\n\n\n        if (!_this.onlyChangeComboSize) {\n          graph.updateComboTree(combo, targetModel.id);\n        } else {\n          graph.updateCombo(combo);\n        }\n      } else {\n        graph.updateCombo(item);\n      }\n    });\n    this.end(item, evt); // 如果已经拖放下了，则不需要再通过距离判断了\n\n    this.endComparison = true;\n  },\n  onNodeDrop: function onNodeDrop(evt) {\n    var _this = this;\n\n    if (!this.targets || this.targets.length === 0) return;\n    var graph = this.graph;\n    var item = evt.item;\n    var comboId = item.getModel().comboId;\n    var newParentCombo = comboId ? graph.findById(comboId) : undefined;\n    this.currentShouldEnd = this.shouldEnd.call(this, evt, newParentCombo);\n    this.updatePositions(evt, !this.currentShouldEnd);\n    if (!this.currentShouldEnd) return;\n    var droppedCombo; // 如果被放置的的节点有 comboId，且这个 comboId 与正在被拖拽的 combo 的父 id 不相同，则更新父亲为 comboId\n\n    if (comboId) {\n      if (this.activeState) {\n        var combo = graph.findById(comboId);\n        graph.setItemState(combo, this.activeState, false);\n      }\n\n      this.targets.map(function (combo) {\n        if (!_this.onlyChangeComboSize) {\n          if (comboId !== combo.getID()) {\n            droppedCombo = graph.findById(comboId);\n            if (comboId !== combo.getModel().parentId) graph.updateComboTree(combo, comboId);\n          }\n        } else {\n          graph.updateCombo(combo);\n        }\n      });\n    } else {\n      // 如果被放置的节点没有 comboId，且正在被拖拽的 combo 有父 id，则更新父亲为 undefined\n      this.targets.map(function (combo) {\n        if (!_this.onlyChangeComboSize) {\n          var model = combo.getModel();\n\n          if (model.comboId) {\n            graph.updateComboTree(combo);\n          }\n        } else {\n          graph.updateCombo(combo);\n        }\n      });\n    } // 如果已经拖放下了，则不需要再通过距离判断了\n\n\n    this.endComparison = true;\n    this.end(droppedCombo, evt);\n  },\n  onDragEnter: function onDragEnter(evt) {\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.validationCombo(evt)) return;\n    var item = evt.item;\n    var graph = this.graph;\n\n    if (this.activeState) {\n      graph.setItemState(item, this.activeState, true);\n    }\n  },\n  onDragLeave: function onDragLeave(evt) {\n    if (!this.origin) {\n      return;\n    }\n\n    if (!this.validationCombo(evt)) return;\n    var item = evt.item;\n    var graph = this.graph;\n\n    if (this.activeState) {\n      graph.setItemState(item, this.activeState, false);\n    }\n  },\n  onDragEnd: function onDragEnd(evt) {\n    if (!this.targets || this.targets.length === 0) return;\n    var item = evt.item;\n\n    if (this.currentShouldEnd) {\n      this.updatePositions(evt);\n    }\n\n    var parentCombo = this.getParentCombo(item.getModel().parentId);\n    var graph = this.graph;\n\n    if (parentCombo && this.activeState) {\n      graph.setItemState(parentCombo, this.activeState, false);\n    }\n\n    this.end(undefined, evt);\n  },\n  end: function end(comboDropedOn, evt) {\n    var _this = this;\n\n    if (!this.origin) return;\n    var graph = this.graph; // 删除delegate shape\n\n    if (this.delegateShape) {\n      var delegateGroup = graph.get('delegateGroup');\n      delegateGroup.clear();\n      this.delegateShape = null;\n    }\n\n    if (comboDropedOn && this.activeState) {\n      graph.setItemState(comboDropedOn, this.activeState, false);\n    } // 若没有被放置的 combo，则是被放置在画布上\n\n\n    if (!comboDropedOn) {\n      this.targets.map(function (combo) {\n        // 将 Combo 放置到某个 Combo 上面时，只有当 onlyChangeComboSize 为 false 时候才更新 Combo 结构\n        if (!_this.onlyChangeComboSize) {\n          graph.updateComboTree(combo);\n        } else {\n          graph.updateCombo(combo);\n        }\n      });\n    }\n\n    this.point = [];\n    this.origin = null;\n    this.originPoint = null;\n    this.targets.length = 0;\n  },\n\n  /**\n   * 遍历 comboTree，分别更新 node 和 combo\n   * @param data\n   * @param fn\n   */\n  traverse: function traverse(data, fn) {\n    var _this = this;\n\n    if (fn(data) === false) {\n      return;\n    }\n\n    if (data) {\n      var combos = data.get('combos');\n      each(combos, function (child) {\n        _this.traverse(child, fn);\n      });\n      var nodes = data.get('nodes');\n      each(nodes, function (child) {\n        _this.traverse(child, fn);\n      });\n    }\n  },\n  updateCombo: function updateCombo(item, evt, restore) {\n    var _this = this;\n\n    this.traverse(item, function (param) {\n      if (param.destroyed) {\n        return false;\n      }\n\n      _this.updateSignleItem(param, evt, restore);\n\n      return true;\n    });\n  },\n\n  /**\n   *\n   * @param item 当前正在拖动的元素\n   * @param evt\n   */\n  updateSignleItem: function updateSignleItem(item, evt, restore) {\n    var origin = this.origin;\n    var graph = this.graph;\n    var model = item.getModel();\n    var itemId = item.get('id');\n\n    if (!this.point[itemId]) {\n      this.point[itemId] = {\n        x: model.x,\n        y: model.y\n      };\n    }\n\n    var x = evt.x - origin.x + this.point[itemId].x;\n    var y = evt.y - origin.y + this.point[itemId].y;\n\n    if (restore) {\n      x += origin.x - evt.x;\n      y += origin.y - evt.y;\n    }\n\n    graph.updateItem(item, {\n      x: x,\n      y: y\n    });\n  },\n\n  /**\n   * 根据 ID 获取父 Combo\n   * @param parentId 父 Combo ID\n   */\n  getParentCombo: function getParentCombo(parentId) {\n    var graph = this.graph;\n\n    if (!parentId) {\n      return undefined;\n    }\n\n    var parentCombo = graph.findById(parentId);\n\n    if (!parentCombo) {\n      return undefined;\n    }\n\n    return parentCombo;\n  },\n  updateDelegate: function updateDelegate(evt) {\n    var graph = this.graph; // 当没有 delegate shape 时创建\n\n    if (!this.delegateShape) {\n      var delegateGroup = graph.get('delegateGroup');\n      var bbox = null;\n\n      if (this.targets.length > 1) {\n        bbox = calculationItemsBBox(this.targets);\n      } else {\n        bbox = this.targets[0].getBBox();\n      }\n\n      var x = bbox.x,\n          y = bbox.y,\n          width = bbox.width,\n          height = bbox.height,\n          minX = bbox.minX,\n          minY = bbox.minY;\n      this.originPoint = {\n        x: x,\n        y: y,\n        width: width,\n        height: height,\n        minX: minX,\n        minY: minY\n      };\n\n      var attrs = __assign(__assign({}, Global.delegateStyle), this.delegateStyle);\n\n      this.delegateShape = delegateGroup.addShape('rect', {\n        attrs: __assign({\n          width: bbox.width,\n          height: bbox.height,\n          x: bbox.x,\n          y: bbox.y\n        }, attrs),\n        name: 'combo-delegate-shape'\n      });\n      this.delegateShape.set('capture', false);\n      this.delegate = this.delegateShape;\n    } else {\n      var clientX = evt.x - this.origin.x + this.originPoint.minX;\n      var clientY = evt.y - this.origin.y + this.originPoint.minY;\n      this.delegateShape.attr({\n        x: clientX,\n        y: clientY\n      });\n    }\n  }\n};"]},"metadata":{},"sourceType":"module"}