{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Point } from './point';\nimport { Line } from './line';\nimport { Rectangle } from './rectangle';\nimport { Polyline } from './polyline';\nimport { Geometry } from './geometry';\nexport var Curve = /*#__PURE__*/function (_Geometry, _Symbol$toStringTag) {\n  _inherits(Curve, _Geometry);\n\n  var _super = _createSuper(Curve);\n\n  function Curve(start, controlPoint1, controlPoint2, end) {\n    var _this;\n\n    _classCallCheck(this, Curve);\n\n    _this = _super.call(this);\n    _this.PRECISION = 3;\n    _this.start = Point.create(start);\n    _this.controlPoint1 = Point.create(controlPoint1);\n    _this.controlPoint2 = Point.create(controlPoint2);\n    _this.end = Point.create(end);\n    return _this;\n  }\n\n  _createClass(Curve, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Curve.toStringTag;\n    }\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      var start = this.start;\n      var controlPoint1 = this.controlPoint1;\n      var controlPoint2 = this.controlPoint2;\n      var end = this.end;\n      var x0 = start.x;\n      var y0 = start.y;\n      var x1 = controlPoint1.x;\n      var y1 = controlPoint1.y;\n      var x2 = controlPoint2.x;\n      var y2 = controlPoint2.y;\n      var x3 = end.x;\n      var y3 = end.y;\n      var points = []; // local extremes\n\n      var tvalues = []; // t values of local extremes\n\n      var bounds = [[], []];\n      var a;\n      var b;\n      var c;\n      var t;\n      var t1;\n      var t2;\n      var b2ac;\n      var sqrtb2ac;\n\n      for (var i = 0; i < 2; i += 1) {\n        if (i === 0) {\n          b = 6 * x0 - 12 * x1 + 6 * x2;\n          a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n          c = 3 * x1 - 3 * x0;\n        } else {\n          b = 6 * y0 - 12 * y1 + 6 * y2;\n          a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n          c = 3 * y1 - 3 * y0;\n        }\n\n        if (Math.abs(a) < 1e-12) {\n          if (Math.abs(b) < 1e-12) {\n            continue;\n          }\n\n          t = -c / b;\n          if (t > 0 && t < 1) tvalues.push(t);\n          continue;\n        }\n\n        b2ac = b * b - 4 * c * a;\n        sqrtb2ac = Math.sqrt(b2ac);\n        if (b2ac < 0) continue;\n        t1 = (-b + sqrtb2ac) / (2 * a);\n        if (t1 > 0 && t1 < 1) tvalues.push(t1);\n        t2 = (-b - sqrtb2ac) / (2 * a);\n        if (t2 > 0 && t2 < 1) tvalues.push(t2);\n      }\n\n      var x;\n      var y;\n      var mt;\n      var j = tvalues.length;\n      var jlen = j;\n\n      while (j) {\n        j -= 1;\n        t = tvalues[j];\n        mt = 1 - t;\n        x = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n        bounds[0][j] = x;\n        y = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n        bounds[1][j] = y;\n        points[j] = {\n          X: x,\n          Y: y\n        };\n      }\n\n      tvalues[jlen] = 0;\n      tvalues[jlen + 1] = 1;\n      points[jlen] = {\n        X: x0,\n        Y: y0\n      };\n      points[jlen + 1] = {\n        X: x3,\n        Y: y3\n      };\n      bounds[0][jlen] = x0;\n      bounds[1][jlen] = y0;\n      bounds[0][jlen + 1] = x3;\n      bounds[1][jlen + 1] = y3;\n      tvalues.length = jlen + 2;\n      bounds[0].length = jlen + 2;\n      bounds[1].length = jlen + 2;\n      points.length = jlen + 2;\n      var left = Math.min.apply(null, bounds[0]);\n      var top = Math.min.apply(null, bounds[1]);\n      var right = Math.max.apply(null, bounds[0]);\n      var bottom = Math.max.apply(null, bounds[1]);\n      return new Rectangle(left, top, right - left, bottom - top);\n    }\n  }, {\n    key: \"closestPoint\",\n    value: function closestPoint(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.pointAtT(this.closestPointT(p, options));\n    }\n  }, {\n    key: \"closestPointLength\",\n    value: function closestPointLength(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var opts = this.getOptions(options);\n      return this.lengthAtT(this.closestPointT(p, opts), opts);\n    }\n  }, {\n    key: \"closestPointNormalizedLength\",\n    value: function closestPointNormalizedLength(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var opts = this.getOptions(options);\n      var cpLength = this.closestPointLength(p, opts);\n\n      if (!cpLength) {\n        return 0;\n      }\n\n      var length = this.length(opts);\n\n      if (length === 0) {\n        return 0;\n      }\n\n      return cpLength / length;\n    }\n  }, {\n    key: \"closestPointT\",\n    value: function closestPointT(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var precision = this.getPrecision(options);\n      var subdivisions = this.getDivisions(options);\n      var precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n\n      var investigatedSubdivision = null;\n      var investigatedSubdivisionStartT = 0;\n      var investigatedSubdivisionEndT = 0;\n      var distFromStart = 0;\n      var distFromEnd = 0;\n      var chordLength = 0;\n      var minSumDist = null;\n      var count = subdivisions.length;\n      var piece = count > 0 ? 1 / count : 0;\n      subdivisions.forEach(function (division, i) {\n        var startDist = division.start.distance(p);\n        var endDist = division.end.distance(p);\n        var sumDist = startDist + endDist;\n\n        if (minSumDist == null || sumDist < minSumDist) {\n          investigatedSubdivision = division;\n          investigatedSubdivisionStartT = i * piece;\n          investigatedSubdivisionEndT = (i + 1) * piece;\n          distFromStart = startDist;\n          distFromEnd = endDist;\n          minSumDist = sumDist;\n          chordLength = division.endpointDistance();\n        }\n      }); // Recursively divide investigated subdivision, until distance between\n      // baselinePoint and closest path endpoint is within `10^(-precision)`,\n      // then return the closest endpoint of that final subdivision.\n      // eslint-disable-next-line\n\n      while (true) {\n        // check if we have reached at least one required observed precision\n        // - calculated as: the difference in distances from point to start and end divided by the distance\n        // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n        // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n        // - this criterion works well for points lying far away from the curve\n        var startPrecisionRatio = distFromStart ? Math.abs(distFromStart - distFromEnd) / distFromStart : 0;\n        var endPrecisionRatio = distFromEnd != null ? Math.abs(distFromStart - distFromEnd) / distFromEnd : 0;\n        var hasRequiredPrecision = startPrecisionRatio < precisionRatio || endPrecisionRatio < precisionRatio; // check if we have reached at least one required minimal distance\n        // - calculated as: the subdivision chord length multiplied by precisionRatio\n        // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n        // - this is a backup criterion that works well for points lying \"almost at\" the curve\n\n        var hasMiniStartDistance = distFromStart ? distFromStart < chordLength * precisionRatio : true;\n        var hasMiniEndDistance = distFromEnd ? distFromEnd < chordLength * precisionRatio : true;\n        var hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;\n\n        if (hasRequiredPrecision || hasMiniDistance) {\n          return distFromStart <= distFromEnd ? investigatedSubdivisionStartT : investigatedSubdivisionEndT;\n        } // otherwise, set up for next iteration\n\n\n        var divided = investigatedSubdivision.divide(0.5);\n        piece /= 2;\n        var startDist1 = divided[0].start.distance(p);\n        var endDist1 = divided[0].end.distance(p);\n        var sumDist1 = startDist1 + endDist1;\n        var startDist2 = divided[1].start.distance(p);\n        var endDist2 = divided[1].end.distance(p);\n        var sumDist2 = startDist2 + endDist2;\n\n        if (sumDist1 <= sumDist2) {\n          investigatedSubdivision = divided[0];\n          investigatedSubdivisionEndT -= piece;\n          distFromStart = startDist1;\n          distFromEnd = endDist1;\n        } else {\n          investigatedSubdivision = divided[1];\n          investigatedSubdivisionStartT += piece;\n          distFromStart = startDist2;\n          distFromEnd = endDist2;\n        }\n      }\n    }\n  }, {\n    key: \"closestPointTangent\",\n    value: function closestPointTangent(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.tangentAtT(this.closestPointT(p, options));\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(p) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var polyline = this.toPolyline(options);\n      return polyline.containsPoint(p);\n    }\n  }, {\n    key: \"divideAt\",\n    value: function divideAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (ratio <= 0) {\n        return this.divideAtT(0);\n      }\n\n      if (ratio >= 1) {\n        return this.divideAtT(1);\n      }\n\n      var t = this.tAt(ratio, options);\n      return this.divideAtT(t);\n    }\n  }, {\n    key: \"divideAtLength\",\n    value: function divideAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var t = this.tAtLength(length, options);\n      return this.divideAtT(t);\n    }\n  }, {\n    key: \"divide\",\n    value: function divide(t) {\n      return this.divideAtT(t);\n    }\n  }, {\n    key: \"divideAtT\",\n    value: function divideAtT(t) {\n      var start = this.start;\n      var controlPoint1 = this.controlPoint1;\n      var controlPoint2 = this.controlPoint2;\n      var end = this.end;\n\n      if (t <= 0) {\n        return [new Curve(start, start, start, start), new Curve(start, controlPoint1, controlPoint2, end)];\n      }\n\n      if (t >= 1) {\n        return [new Curve(start, controlPoint1, controlPoint2, end), new Curve(end, end, end, end)];\n      }\n\n      var dividerPoints = this.getSkeletonPoints(t);\n      var startControl1 = dividerPoints.startControlPoint1;\n      var startControl2 = dividerPoints.startControlPoint2;\n      var divider = dividerPoints.divider;\n      var dividerControl1 = dividerPoints.dividerControlPoint1;\n      var dividerControl2 = dividerPoints.dividerControlPoint2;\n      return [new Curve(start, startControl1, startControl2, divider), new Curve(divider, dividerControl1, dividerControl2, end)];\n    }\n  }, {\n    key: \"endpointDistance\",\n    value: function endpointDistance() {\n      return this.start.distance(this.end);\n    }\n  }, {\n    key: \"getSkeletonPoints\",\n    value: function getSkeletonPoints(t) {\n      var start = this.start;\n      var control1 = this.controlPoint1;\n      var control2 = this.controlPoint2;\n      var end = this.end; // shortcuts for `t` values that are out of range\n\n      if (t <= 0) {\n        return {\n          startControlPoint1: start.clone(),\n          startControlPoint2: start.clone(),\n          divider: start.clone(),\n          dividerControlPoint1: control1.clone(),\n          dividerControlPoint2: control2.clone()\n        };\n      }\n\n      if (t >= 1) {\n        return {\n          startControlPoint1: control1.clone(),\n          startControlPoint2: control2.clone(),\n          divider: end.clone(),\n          dividerControlPoint1: end.clone(),\n          dividerControlPoint2: end.clone()\n        };\n      }\n\n      var midpoint1 = new Line(start, control1).pointAt(t);\n      var midpoint2 = new Line(control1, control2).pointAt(t);\n      var midpoint3 = new Line(control2, end).pointAt(t);\n      var subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n      var subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n      var divideLine = new Line(subControl1, subControl2).pointAt(t);\n      return {\n        startControlPoint1: midpoint1,\n        startControlPoint2: subControl1,\n        divider: divideLine,\n        dividerControlPoint1: subControl2,\n        dividerControlPoint2: midpoint3\n      };\n    }\n  }, {\n    key: \"getSubdivisions\",\n    value: function getSubdivisions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var precision = this.getPrecision(options);\n      var subdivisions = [new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end)];\n\n      if (precision === 0) {\n        return subdivisions;\n      }\n\n      var previousLength = this.endpointDistance();\n      var precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n      // Recursively divide curve at `t = 0.5`, until the difference between\n      // observed length at subsequent iterations is lower than precision.\n\n      var iteration = 0; // eslint-disable-next-line\n\n      var _loop = function _loop() {\n        iteration += 1;\n        var divisions = [];\n        subdivisions.forEach(function (c) {\n          // dividing at t = 0.5 (not at middle length!)\n          var divided = c.divide(0.5);\n          divisions.push(divided[0], divided[1]);\n        }); // measure new length\n\n        var length = divisions.reduce(function (memo, c) {\n          return memo + c.endpointDistance();\n        }, 0); // check if we have reached required observed precision\n        // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n        // not a problem for further iterations because cubic curves cannot have more than two local extrema\n        // (i.e. cubic curves cannot intersect the baseline more than once)\n        // therefore two subsequent iterations cannot produce sampling with equal length\n\n        var ratio = length !== 0 ? (length - previousLength) / length : 0;\n\n        if (iteration > 1 && ratio < precisionRatio) {\n          return {\n            v: divisions\n          };\n        }\n\n        subdivisions = divisions;\n        previousLength = length;\n      };\n\n      while (true) {\n        var _ret = _loop();\n\n        if (typeof _ret === \"object\") return _ret.v;\n      }\n    }\n  }, {\n    key: \"length\",\n    value: function length() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var divisions = this.getDivisions(options);\n      return divisions.reduce(function (memo, c) {\n        return memo + c.endpointDistance();\n      }, 0);\n    }\n  }, {\n    key: \"lengthAtT\",\n    value: function lengthAtT(t) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (t <= 0) {\n        return 0;\n      }\n\n      var precision = options.precision === undefined ? this.PRECISION : options.precision;\n      var subCurve = this.divide(t)[0];\n      return subCurve.length({\n        precision: precision\n      });\n    }\n  }, {\n    key: \"pointAt\",\n    value: function pointAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (ratio <= 0) {\n        return this.start.clone();\n      }\n\n      if (ratio >= 1) {\n        return this.end.clone();\n      }\n\n      var t = this.tAt(ratio, options);\n      return this.pointAtT(t);\n    }\n  }, {\n    key: \"pointAtLength\",\n    value: function pointAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var t = this.tAtLength(length, options);\n      return this.pointAtT(t);\n    }\n  }, {\n    key: \"pointAtT\",\n    value: function pointAtT(t) {\n      if (t <= 0) {\n        return this.start.clone();\n      }\n\n      if (t >= 1) {\n        return this.end.clone();\n      }\n\n      return this.getSkeletonPoints(t).divider;\n    }\n  }, {\n    key: \"isDifferentiable\",\n    value: function isDifferentiable() {\n      var start = this.start;\n      var control1 = this.controlPoint1;\n      var control2 = this.controlPoint2;\n      var end = this.end;\n      return !(start.equals(control1) && control1.equals(control2) && control2.equals(end));\n    }\n  }, {\n    key: \"tangentAt\",\n    value: function tangentAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      if (!this.isDifferentiable()) return null;\n\n      if (ratio < 0) {\n        ratio = 0; // eslint-disable-line\n      } else if (ratio > 1) {\n        ratio = 1; // eslint-disable-line\n      }\n\n      var t = this.tAt(ratio, options);\n      return this.tangentAtT(t);\n    }\n  }, {\n    key: \"tangentAtLength\",\n    value: function tangentAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (!this.isDifferentiable()) {\n        return null;\n      }\n\n      var t = this.tAtLength(length, options);\n      return this.tangentAtT(t);\n    }\n  }, {\n    key: \"tangentAtT\",\n    value: function tangentAtT(t) {\n      if (!this.isDifferentiable()) {\n        return null;\n      }\n\n      if (t < 0) {\n        t = 0; // eslint-disable-line\n      }\n\n      if (t > 1) {\n        t = 1; // eslint-disable-line\n      }\n\n      var skeletonPoints = this.getSkeletonPoints(t);\n      var p1 = skeletonPoints.startControlPoint2;\n      var p2 = skeletonPoints.dividerControlPoint1;\n      var tangentStart = skeletonPoints.divider;\n      var tangentLine = new Line(p1, p2); // move so that tangent line starts at the point requested\n\n      tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);\n      return tangentLine;\n    }\n  }, {\n    key: \"getPrecision\",\n    value: function getPrecision() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return options.precision == null ? this.PRECISION : options.precision;\n    }\n  }, {\n    key: \"getDivisions\",\n    value: function getDivisions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.subdivisions != null) {\n        return options.subdivisions;\n      }\n\n      var precision = this.getPrecision(options);\n      return this.getSubdivisions({\n        precision: precision\n      });\n    }\n  }, {\n    key: \"getOptions\",\n    value: function getOptions() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var precision = this.getPrecision(options);\n      var subdivisions = this.getDivisions(options);\n      return {\n        precision: precision,\n        subdivisions: subdivisions\n      };\n    }\n  }, {\n    key: \"tAt\",\n    value: function tAt(ratio) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (ratio <= 0) {\n        return 0;\n      }\n\n      if (ratio >= 1) {\n        return 1;\n      }\n\n      var opts = this.getOptions(options);\n      var total = this.length(opts);\n      var length = total * ratio;\n      return this.tAtLength(length, opts);\n    }\n  }, {\n    key: \"tAtLength\",\n    value: function tAtLength(length) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var fromStart = true;\n\n      if (length < 0) {\n        fromStart = false;\n        length = -length; // eslint-disable-line\n      }\n\n      var precision = this.getPrecision(options);\n      var subdivisions = this.getDivisions(options);\n      var opts = {\n        precision: precision,\n        subdivisions: subdivisions\n      };\n      var investigatedSubdivision = null;\n      var investigatedSubdivisionStartT;\n      var investigatedSubdivisionEndT;\n      var baselinePointDistFromStart = 0;\n      var baselinePointDistFromEnd = 0;\n      var memo = 0;\n      var count = subdivisions.length;\n      var piece = count > 0 ? 1 / count : 0;\n\n      for (var i = 0; i < count; i += 1) {\n        var index = fromStart ? i : count - 1 - i;\n        var division = subdivisions[i];\n        var dist = division.endpointDistance();\n\n        if (length <= memo + dist) {\n          investigatedSubdivision = division;\n          investigatedSubdivisionStartT = index * piece;\n          investigatedSubdivisionEndT = (index + 1) * piece;\n          baselinePointDistFromStart = fromStart ? length - memo : dist + memo - length;\n          baselinePointDistFromEnd = fromStart ? dist + memo - length : length - memo;\n          break;\n        }\n\n        memo += dist;\n      }\n\n      if (investigatedSubdivision == null) {\n        return fromStart ? 1 : 0;\n      } // note that precision affects what length is recorded\n      // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n      // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n\n\n      var total = this.length(opts);\n      var precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n      // recursively divide investigated subdivision:\n      // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n      // then return the closest endpoint of that final subdivision\n      // eslint-disable-next-line\n\n      while (true) {\n        var ratio = void 0;\n        ratio = total !== 0 ? baselinePointDistFromStart / total : 0;\n\n        if (ratio < precisionRatio) {\n          return investigatedSubdivisionStartT;\n        }\n\n        ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;\n\n        if (ratio < precisionRatio) {\n          return investigatedSubdivisionEndT;\n        } // otherwise, set up for next iteration\n\n\n        var newBaselinePointDistFromStart = void 0;\n        var newBaselinePointDistFromEnd = void 0;\n        var divided = investigatedSubdivision.divide(0.5);\n        piece /= 2;\n        var baseline1Length = divided[0].endpointDistance();\n        var baseline2Length = divided[1].endpointDistance();\n\n        if (baselinePointDistFromStart <= baseline1Length) {\n          investigatedSubdivision = divided[0];\n          investigatedSubdivisionEndT -= piece;\n          newBaselinePointDistFromStart = baselinePointDistFromStart;\n          newBaselinePointDistFromEnd = baseline1Length - newBaselinePointDistFromStart;\n        } else {\n          investigatedSubdivision = divided[1];\n          investigatedSubdivisionStartT += piece;\n          newBaselinePointDistFromStart = baselinePointDistFromStart - baseline1Length;\n          newBaselinePointDistFromEnd = baseline2Length - newBaselinePointDistFromStart;\n        }\n\n        baselinePointDistFromStart = newBaselinePointDistFromStart;\n        baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n      }\n    }\n  }, {\n    key: \"toPoints\",\n    value: function toPoints() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var subdivisions = this.getDivisions(options);\n      var points = [subdivisions[0].start.clone()];\n      subdivisions.forEach(function (c) {\n        return points.push(c.end.clone());\n      });\n      return points;\n    }\n  }, {\n    key: \"toPolyline\",\n    value: function toPolyline() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return new Polyline(this.toPoints(options));\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      this.start.scale(sx, sy, origin);\n      this.controlPoint1.scale(sx, sy, origin);\n      this.controlPoint2.scale(sx, sy, origin);\n      this.end.scale(sx, sy, origin);\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      this.start.rotate(angle, origin);\n      this.controlPoint1.rotate(angle, origin);\n      this.controlPoint2.rotate(angle, origin);\n      this.end.rotate(angle, origin);\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(tx, ty) {\n      if (typeof tx === 'number') {\n        this.start.translate(tx, ty);\n        this.controlPoint1.translate(tx, ty);\n        this.controlPoint2.translate(tx, ty);\n        this.end.translate(tx, ty);\n      } else {\n        this.start.translate(tx);\n        this.controlPoint1.translate(tx);\n        this.controlPoint2.translate(tx);\n        this.end.translate(tx);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(c) {\n      return c != null && this.start.equals(c.start) && this.controlPoint1.equals(c.controlPoint1) && this.controlPoint2.equals(c.controlPoint2) && this.end.equals(c.end);\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        start: this.start.toJSON(),\n        controlPoint1: this.controlPoint1.toJSON(),\n        controlPoint2: this.controlPoint2.toJSON(),\n        end: this.end.toJSON()\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return [this.start.serialize(), this.controlPoint1.serialize(), this.controlPoint2.serialize(), this.end.serialize()].join(' ');\n    }\n  }]);\n\n  return Curve;\n}(Geometry, Symbol.toStringTag);\n\n(function (Curve) {\n  Curve.toStringTag = \"X6.Geometry.\".concat(Curve.name);\n\n  function isCurve(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Curve) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var curve = instance;\n\n    if ((tag == null || tag === Curve.toStringTag) && Point.isPoint(curve.start) && Point.isPoint(curve.controlPoint1) && Point.isPoint(curve.controlPoint2) && Point.isPoint(curve.end) && typeof curve.toPoints === 'function' && typeof curve.toPolyline === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Curve.isCurve = isCurve;\n})(Curve || (Curve = {}));\n\n(function (Curve) {\n  function getFirstControlPoints(rhs) {\n    var n = rhs.length;\n    var x = []; // `x` is a solution vector.\n\n    var tmp = [];\n    var b = 2.0;\n    x[0] = rhs[0] / b; // Decomposition and forward substitution.\n\n    for (var i = 1; i < n; i += 1) {\n      tmp[i] = 1 / b;\n      b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n      x[i] = (rhs[i] - x[i - 1]) / b;\n    }\n\n    for (var _i = 1; _i < n; _i += 1) {\n      // Backsubstitution.\n      x[n - _i - 1] -= tmp[n - _i] * x[n - _i];\n    }\n\n    return x;\n  }\n\n  function getCurveControlPoints(points) {\n    var knots = points.map(function (p) {\n      return Point.clone(p);\n    });\n    var firstControlPoints = [];\n    var secondControlPoints = [];\n    var n = knots.length - 1; // Special case: Bezier curve should be a straight line.\n\n    if (n === 1) {\n      // 3P1 = 2P0 + P3\n      firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3); // P2 = 2P1 â€“ P0\n\n      secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n      return [firstControlPoints, secondControlPoints];\n    } // Calculate first Bezier control points.\n    // Right hand side vector.\n\n\n    var rhs = []; // Set right hand side X values.\n\n    for (var i = 1; i < n - 1; i += 1) {\n      rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n    }\n\n    rhs[0] = knots[0].x + 2 * knots[1].x;\n    rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0; // Get first control points X-values.\n\n    var x = getFirstControlPoints(rhs); // Set right hand side Y values.\n\n    for (var _i2 = 1; _i2 < n - 1; _i2 += 1) {\n      rhs[_i2] = 4 * knots[_i2].y + 2 * knots[_i2 + 1].y;\n    }\n\n    rhs[0] = knots[0].y + 2 * knots[1].y;\n    rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0; // Get first control points Y-values.\n\n    var y = getFirstControlPoints(rhs); // Fill output arrays.\n\n    for (var _i3 = 0; _i3 < n; _i3 += 1) {\n      // First control point.\n      firstControlPoints.push(new Point(x[_i3], y[_i3])); // Second control point.\n\n      if (_i3 < n - 1) {\n        secondControlPoints.push(new Point(2 * knots[_i3 + 1].x - x[_i3 + 1], 2 * knots[_i3 + 1].y - y[_i3 + 1]));\n      } else {\n        secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n      }\n    }\n\n    return [firstControlPoints, secondControlPoints];\n  }\n\n  function throughPoints(points) {\n    if (points == null || Array.isArray(points) && points.length < 2) {\n      throw new Error('At least 2 points are required');\n    }\n\n    var controlPoints = getCurveControlPoints(points);\n    var curves = [];\n\n    for (var i = 0, ii = controlPoints[0].length; i < ii; i += 1) {\n      var controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n      var controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n      curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n    }\n\n    return curves;\n  }\n\n  Curve.throughPoints = throughPoints;\n})(Curve || (Curve = {}));","map":{"version":3,"sources":["../../src/geometry/curve.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Point } from './point';\nimport { Line } from './line';\nimport { Rectangle } from './rectangle';\nimport { Polyline } from './polyline';\nimport { Geometry } from './geometry';\nexport class Curve extends Geometry {\n    constructor(start, controlPoint1, controlPoint2, end) {\n        super();\n        this.PRECISION = 3;\n        this.start = Point.create(start);\n        this.controlPoint1 = Point.create(controlPoint1);\n        this.controlPoint2 = Point.create(controlPoint2);\n        this.end = Point.create(end);\n    }\n    get [Symbol.toStringTag]() {\n        return Curve.toStringTag;\n    }\n    bbox() {\n        const start = this.start;\n        const controlPoint1 = this.controlPoint1;\n        const controlPoint2 = this.controlPoint2;\n        const end = this.end;\n        const x0 = start.x;\n        const y0 = start.y;\n        const x1 = controlPoint1.x;\n        const y1 = controlPoint1.y;\n        const x2 = controlPoint2.x;\n        const y2 = controlPoint2.y;\n        const x3 = end.x;\n        const y3 = end.y;\n        const points = []; // local extremes\n        const tvalues = []; // t values of local extremes\n        const bounds = [[], []];\n        let a;\n        let b;\n        let c;\n        let t;\n        let t1;\n        let t2;\n        let b2ac;\n        let sqrtb2ac;\n        for (let i = 0; i < 2; i += 1) {\n            if (i === 0) {\n                b = 6 * x0 - 12 * x1 + 6 * x2;\n                a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n                c = 3 * x1 - 3 * x0;\n            }\n            else {\n                b = 6 * y0 - 12 * y1 + 6 * y2;\n                a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n                c = 3 * y1 - 3 * y0;\n            }\n            if (Math.abs(a) < 1e-12) {\n                if (Math.abs(b) < 1e-12) {\n                    continue;\n                }\n                t = -c / b;\n                if (t > 0 && t < 1)\n                    tvalues.push(t);\n                continue;\n            }\n            b2ac = b * b - 4 * c * a;\n            sqrtb2ac = Math.sqrt(b2ac);\n            if (b2ac < 0)\n                continue;\n            t1 = (-b + sqrtb2ac) / (2 * a);\n            if (t1 > 0 && t1 < 1)\n                tvalues.push(t1);\n            t2 = (-b - sqrtb2ac) / (2 * a);\n            if (t2 > 0 && t2 < 1)\n                tvalues.push(t2);\n        }\n        let x;\n        let y;\n        let mt;\n        let j = tvalues.length;\n        const jlen = j;\n        while (j) {\n            j -= 1;\n            t = tvalues[j];\n            mt = 1 - t;\n            x =\n                mt * mt * mt * x0 +\n                    3 * mt * mt * t * x1 +\n                    3 * mt * t * t * x2 +\n                    t * t * t * x3;\n            bounds[0][j] = x;\n            y =\n                mt * mt * mt * y0 +\n                    3 * mt * mt * t * y1 +\n                    3 * mt * t * t * y2 +\n                    t * t * t * y3;\n            bounds[1][j] = y;\n            points[j] = { X: x, Y: y };\n        }\n        tvalues[jlen] = 0;\n        tvalues[jlen + 1] = 1;\n        points[jlen] = { X: x0, Y: y0 };\n        points[jlen + 1] = { X: x3, Y: y3 };\n        bounds[0][jlen] = x0;\n        bounds[1][jlen] = y0;\n        bounds[0][jlen + 1] = x3;\n        bounds[1][jlen + 1] = y3;\n        tvalues.length = jlen + 2;\n        bounds[0].length = jlen + 2;\n        bounds[1].length = jlen + 2;\n        points.length = jlen + 2;\n        const left = Math.min.apply(null, bounds[0]);\n        const top = Math.min.apply(null, bounds[1]);\n        const right = Math.max.apply(null, bounds[0]);\n        const bottom = Math.max.apply(null, bounds[1]);\n        return new Rectangle(left, top, right - left, bottom - top);\n    }\n    closestPoint(p, options = {}) {\n        return this.pointAtT(this.closestPointT(p, options));\n    }\n    closestPointLength(p, options = {}) {\n        const opts = this.getOptions(options);\n        return this.lengthAtT(this.closestPointT(p, opts), opts);\n    }\n    closestPointNormalizedLength(p, options = {}) {\n        const opts = this.getOptions(options);\n        const cpLength = this.closestPointLength(p, opts);\n        if (!cpLength) {\n            return 0;\n        }\n        const length = this.length(opts);\n        if (length === 0) {\n            return 0;\n        }\n        return cpLength / length;\n    }\n    closestPointT(p, options = {}) {\n        const precision = this.getPrecision(options);\n        const subdivisions = this.getDivisions(options);\n        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n        let investigatedSubdivision = null;\n        let investigatedSubdivisionStartT = 0;\n        let investigatedSubdivisionEndT = 0;\n        let distFromStart = 0;\n        let distFromEnd = 0;\n        let chordLength = 0;\n        let minSumDist = null;\n        const count = subdivisions.length;\n        let piece = count > 0 ? 1 / count : 0;\n        subdivisions.forEach((division, i) => {\n            const startDist = division.start.distance(p);\n            const endDist = division.end.distance(p);\n            const sumDist = startDist + endDist;\n            if (minSumDist == null || sumDist < minSumDist) {\n                investigatedSubdivision = division;\n                investigatedSubdivisionStartT = i * piece;\n                investigatedSubdivisionEndT = (i + 1) * piece;\n                distFromStart = startDist;\n                distFromEnd = endDist;\n                minSumDist = sumDist;\n                chordLength = division.endpointDistance();\n            }\n        });\n        // Recursively divide investigated subdivision, until distance between\n        // baselinePoint and closest path endpoint is within `10^(-precision)`,\n        // then return the closest endpoint of that final subdivision.\n        // eslint-disable-next-line\n        while (true) {\n            // check if we have reached at least one required observed precision\n            // - calculated as: the difference in distances from point to start and end divided by the distance\n            // - note that this function is not monotonic = it doesn't converge stably but has \"teeth\"\n            // - the function decreases while one of the endpoints is fixed but \"jumps\" whenever we switch\n            // - this criterion works well for points lying far away from the curve\n            const startPrecisionRatio = distFromStart\n                ? Math.abs(distFromStart - distFromEnd) / distFromStart\n                : 0;\n            const endPrecisionRatio = distFromEnd != null\n                ? Math.abs(distFromStart - distFromEnd) / distFromEnd\n                : 0;\n            const hasRequiredPrecision = startPrecisionRatio < precisionRatio ||\n                endPrecisionRatio < precisionRatio;\n            // check if we have reached at least one required minimal distance\n            // - calculated as: the subdivision chord length multiplied by precisionRatio\n            // - calculation is relative so it will work for arbitrarily large/small curves and their subdivisions\n            // - this is a backup criterion that works well for points lying \"almost at\" the curve\n            const hasMiniStartDistance = distFromStart\n                ? distFromStart < chordLength * precisionRatio\n                : true;\n            const hasMiniEndDistance = distFromEnd\n                ? distFromEnd < chordLength * precisionRatio\n                : true;\n            const hasMiniDistance = hasMiniStartDistance || hasMiniEndDistance;\n            if (hasRequiredPrecision || hasMiniDistance) {\n                return distFromStart <= distFromEnd\n                    ? investigatedSubdivisionStartT\n                    : investigatedSubdivisionEndT;\n            }\n            // otherwise, set up for next iteration\n            const divided = investigatedSubdivision.divide(0.5);\n            piece /= 2;\n            const startDist1 = divided[0].start.distance(p);\n            const endDist1 = divided[0].end.distance(p);\n            const sumDist1 = startDist1 + endDist1;\n            const startDist2 = divided[1].start.distance(p);\n            const endDist2 = divided[1].end.distance(p);\n            const sumDist2 = startDist2 + endDist2;\n            if (sumDist1 <= sumDist2) {\n                investigatedSubdivision = divided[0];\n                investigatedSubdivisionEndT -= piece;\n                distFromStart = startDist1;\n                distFromEnd = endDist1;\n            }\n            else {\n                investigatedSubdivision = divided[1];\n                investigatedSubdivisionStartT += piece;\n                distFromStart = startDist2;\n                distFromEnd = endDist2;\n            }\n        }\n    }\n    closestPointTangent(p, options = {}) {\n        return this.tangentAtT(this.closestPointT(p, options));\n    }\n    containsPoint(p, options = {}) {\n        const polyline = this.toPolyline(options);\n        return polyline.containsPoint(p);\n    }\n    divideAt(ratio, options = {}) {\n        if (ratio <= 0) {\n            return this.divideAtT(0);\n        }\n        if (ratio >= 1) {\n            return this.divideAtT(1);\n        }\n        const t = this.tAt(ratio, options);\n        return this.divideAtT(t);\n    }\n    divideAtLength(length, options = {}) {\n        const t = this.tAtLength(length, options);\n        return this.divideAtT(t);\n    }\n    divide(t) {\n        return this.divideAtT(t);\n    }\n    divideAtT(t) {\n        const start = this.start;\n        const controlPoint1 = this.controlPoint1;\n        const controlPoint2 = this.controlPoint2;\n        const end = this.end;\n        if (t <= 0) {\n            return [\n                new Curve(start, start, start, start),\n                new Curve(start, controlPoint1, controlPoint2, end),\n            ];\n        }\n        if (t >= 1) {\n            return [\n                new Curve(start, controlPoint1, controlPoint2, end),\n                new Curve(end, end, end, end),\n            ];\n        }\n        const dividerPoints = this.getSkeletonPoints(t);\n        const startControl1 = dividerPoints.startControlPoint1;\n        const startControl2 = dividerPoints.startControlPoint2;\n        const divider = dividerPoints.divider;\n        const dividerControl1 = dividerPoints.dividerControlPoint1;\n        const dividerControl2 = dividerPoints.dividerControlPoint2;\n        return [\n            new Curve(start, startControl1, startControl2, divider),\n            new Curve(divider, dividerControl1, dividerControl2, end),\n        ];\n    }\n    endpointDistance() {\n        return this.start.distance(this.end);\n    }\n    getSkeletonPoints(t) {\n        const start = this.start;\n        const control1 = this.controlPoint1;\n        const control2 = this.controlPoint2;\n        const end = this.end;\n        // shortcuts for `t` values that are out of range\n        if (t <= 0) {\n            return {\n                startControlPoint1: start.clone(),\n                startControlPoint2: start.clone(),\n                divider: start.clone(),\n                dividerControlPoint1: control1.clone(),\n                dividerControlPoint2: control2.clone(),\n            };\n        }\n        if (t >= 1) {\n            return {\n                startControlPoint1: control1.clone(),\n                startControlPoint2: control2.clone(),\n                divider: end.clone(),\n                dividerControlPoint1: end.clone(),\n                dividerControlPoint2: end.clone(),\n            };\n        }\n        const midpoint1 = new Line(start, control1).pointAt(t);\n        const midpoint2 = new Line(control1, control2).pointAt(t);\n        const midpoint3 = new Line(control2, end).pointAt(t);\n        const subControl1 = new Line(midpoint1, midpoint2).pointAt(t);\n        const subControl2 = new Line(midpoint2, midpoint3).pointAt(t);\n        const divideLine = new Line(subControl1, subControl2).pointAt(t);\n        return {\n            startControlPoint1: midpoint1,\n            startControlPoint2: subControl1,\n            divider: divideLine,\n            dividerControlPoint1: subControl2,\n            dividerControlPoint2: midpoint3,\n        };\n    }\n    getSubdivisions(options = {}) {\n        const precision = this.getPrecision(options);\n        let subdivisions = [\n            new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end),\n        ];\n        if (precision === 0) {\n            return subdivisions;\n        }\n        let previousLength = this.endpointDistance();\n        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n        // Recursively divide curve at `t = 0.5`, until the difference between\n        // observed length at subsequent iterations is lower than precision.\n        let iteration = 0;\n        // eslint-disable-next-line\n        while (true) {\n            iteration += 1;\n            const divisions = [];\n            subdivisions.forEach((c) => {\n                // dividing at t = 0.5 (not at middle length!)\n                const divided = c.divide(0.5);\n                divisions.push(divided[0], divided[1]);\n            });\n            // measure new length\n            const length = divisions.reduce((memo, c) => memo + c.endpointDistance(), 0);\n            // check if we have reached required observed precision\n            // sine-like curves may have the same observed length in iteration 0 and 1 - skip iteration 1\n            // not a problem for further iterations because cubic curves cannot have more than two local extrema\n            // (i.e. cubic curves cannot intersect the baseline more than once)\n            // therefore two subsequent iterations cannot produce sampling with equal length\n            const ratio = length !== 0 ? (length - previousLength) / length : 0;\n            if (iteration > 1 && ratio < precisionRatio) {\n                return divisions;\n            }\n            subdivisions = divisions;\n            previousLength = length;\n        }\n    }\n    length(options = {}) {\n        const divisions = this.getDivisions(options);\n        return divisions.reduce((memo, c) => {\n            return memo + c.endpointDistance();\n        }, 0);\n    }\n    lengthAtT(t, options = {}) {\n        if (t <= 0) {\n            return 0;\n        }\n        const precision = options.precision === undefined ? this.PRECISION : options.precision;\n        const subCurve = this.divide(t)[0];\n        return subCurve.length({ precision });\n    }\n    pointAt(ratio, options = {}) {\n        if (ratio <= 0) {\n            return this.start.clone();\n        }\n        if (ratio >= 1) {\n            return this.end.clone();\n        }\n        const t = this.tAt(ratio, options);\n        return this.pointAtT(t);\n    }\n    pointAtLength(length, options = {}) {\n        const t = this.tAtLength(length, options);\n        return this.pointAtT(t);\n    }\n    pointAtT(t) {\n        if (t <= 0) {\n            return this.start.clone();\n        }\n        if (t >= 1) {\n            return this.end.clone();\n        }\n        return this.getSkeletonPoints(t).divider;\n    }\n    isDifferentiable() {\n        const start = this.start;\n        const control1 = this.controlPoint1;\n        const control2 = this.controlPoint2;\n        const end = this.end;\n        return !(start.equals(control1) &&\n            control1.equals(control2) &&\n            control2.equals(end));\n    }\n    tangentAt(ratio, options = {}) {\n        if (!this.isDifferentiable())\n            return null;\n        if (ratio < 0) {\n            ratio = 0; // eslint-disable-line\n        }\n        else if (ratio > 1) {\n            ratio = 1; // eslint-disable-line\n        }\n        const t = this.tAt(ratio, options);\n        return this.tangentAtT(t);\n    }\n    tangentAtLength(length, options = {}) {\n        if (!this.isDifferentiable()) {\n            return null;\n        }\n        const t = this.tAtLength(length, options);\n        return this.tangentAtT(t);\n    }\n    tangentAtT(t) {\n        if (!this.isDifferentiable()) {\n            return null;\n        }\n        if (t < 0) {\n            t = 0; // eslint-disable-line\n        }\n        if (t > 1) {\n            t = 1; // eslint-disable-line\n        }\n        const skeletonPoints = this.getSkeletonPoints(t);\n        const p1 = skeletonPoints.startControlPoint2;\n        const p2 = skeletonPoints.dividerControlPoint1;\n        const tangentStart = skeletonPoints.divider;\n        const tangentLine = new Line(p1, p2);\n        // move so that tangent line starts at the point requested\n        tangentLine.translate(tangentStart.x - p1.x, tangentStart.y - p1.y);\n        return tangentLine;\n    }\n    getPrecision(options = {}) {\n        return options.precision == null ? this.PRECISION : options.precision;\n    }\n    getDivisions(options = {}) {\n        if (options.subdivisions != null) {\n            return options.subdivisions;\n        }\n        const precision = this.getPrecision(options);\n        return this.getSubdivisions({ precision });\n    }\n    getOptions(options = {}) {\n        const precision = this.getPrecision(options);\n        const subdivisions = this.getDivisions(options);\n        return { precision, subdivisions };\n    }\n    tAt(ratio, options = {}) {\n        if (ratio <= 0) {\n            return 0;\n        }\n        if (ratio >= 1) {\n            return 1;\n        }\n        const opts = this.getOptions(options);\n        const total = this.length(opts);\n        const length = total * ratio;\n        return this.tAtLength(length, opts);\n    }\n    tAtLength(length, options = {}) {\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        const precision = this.getPrecision(options);\n        const subdivisions = this.getDivisions(options);\n        const opts = { precision, subdivisions };\n        let investigatedSubdivision = null;\n        let investigatedSubdivisionStartT;\n        let investigatedSubdivisionEndT;\n        let baselinePointDistFromStart = 0;\n        let baselinePointDistFromEnd = 0;\n        let memo = 0;\n        const count = subdivisions.length;\n        let piece = count > 0 ? 1 / count : 0;\n        for (let i = 0; i < count; i += 1) {\n            const index = fromStart ? i : count - 1 - i;\n            const division = subdivisions[i];\n            const dist = division.endpointDistance();\n            if (length <= memo + dist) {\n                investigatedSubdivision = division;\n                investigatedSubdivisionStartT = index * piece;\n                investigatedSubdivisionEndT = (index + 1) * piece;\n                baselinePointDistFromStart = fromStart\n                    ? length - memo\n                    : dist + memo - length;\n                baselinePointDistFromEnd = fromStart\n                    ? dist + memo - length\n                    : length - memo;\n                break;\n            }\n            memo += dist;\n        }\n        if (investigatedSubdivision == null) {\n            return fromStart ? 1 : 0;\n        }\n        // note that precision affects what length is recorded\n        // (imprecise measurements underestimate length by up to 10^(-precision) of the precise length)\n        // e.g. at precision 1, the length may be underestimated by up to 10% and cause this function to return 1\n        const total = this.length(opts);\n        const precisionRatio = Math.pow(10, -precision); // eslint-disable-line\n        // recursively divide investigated subdivision:\n        // until distance between baselinePoint and closest path endpoint is within 10^(-precision)\n        // then return the closest endpoint of that final subdivision\n        // eslint-disable-next-line\n        while (true) {\n            let ratio;\n            ratio = total !== 0 ? baselinePointDistFromStart / total : 0;\n            if (ratio < precisionRatio) {\n                return investigatedSubdivisionStartT;\n            }\n            ratio = total !== 0 ? baselinePointDistFromEnd / total : 0;\n            if (ratio < precisionRatio) {\n                return investigatedSubdivisionEndT;\n            }\n            // otherwise, set up for next iteration\n            let newBaselinePointDistFromStart;\n            let newBaselinePointDistFromEnd;\n            const divided = investigatedSubdivision.divide(0.5);\n            piece /= 2;\n            const baseline1Length = divided[0].endpointDistance();\n            const baseline2Length = divided[1].endpointDistance();\n            if (baselinePointDistFromStart <= baseline1Length) {\n                investigatedSubdivision = divided[0];\n                investigatedSubdivisionEndT -= piece;\n                newBaselinePointDistFromStart = baselinePointDistFromStart;\n                newBaselinePointDistFromEnd =\n                    baseline1Length - newBaselinePointDistFromStart;\n            }\n            else {\n                investigatedSubdivision = divided[1];\n                investigatedSubdivisionStartT += piece;\n                newBaselinePointDistFromStart =\n                    baselinePointDistFromStart - baseline1Length;\n                newBaselinePointDistFromEnd =\n                    baseline2Length - newBaselinePointDistFromStart;\n            }\n            baselinePointDistFromStart = newBaselinePointDistFromStart;\n            baselinePointDistFromEnd = newBaselinePointDistFromEnd;\n        }\n    }\n    toPoints(options = {}) {\n        const subdivisions = this.getDivisions(options);\n        const points = [subdivisions[0].start.clone()];\n        subdivisions.forEach((c) => points.push(c.end.clone()));\n        return points;\n    }\n    toPolyline(options = {}) {\n        return new Polyline(this.toPoints(options));\n    }\n    scale(sx, sy, origin) {\n        this.start.scale(sx, sy, origin);\n        this.controlPoint1.scale(sx, sy, origin);\n        this.controlPoint2.scale(sx, sy, origin);\n        this.end.scale(sx, sy, origin);\n        return this;\n    }\n    rotate(angle, origin) {\n        this.start.rotate(angle, origin);\n        this.controlPoint1.rotate(angle, origin);\n        this.controlPoint2.rotate(angle, origin);\n        this.end.rotate(angle, origin);\n        return this;\n    }\n    translate(tx, ty) {\n        if (typeof tx === 'number') {\n            this.start.translate(tx, ty);\n            this.controlPoint1.translate(tx, ty);\n            this.controlPoint2.translate(tx, ty);\n            this.end.translate(tx, ty);\n        }\n        else {\n            this.start.translate(tx);\n            this.controlPoint1.translate(tx);\n            this.controlPoint2.translate(tx);\n            this.end.translate(tx);\n        }\n        return this;\n    }\n    equals(c) {\n        return (c != null &&\n            this.start.equals(c.start) &&\n            this.controlPoint1.equals(c.controlPoint1) &&\n            this.controlPoint2.equals(c.controlPoint2) &&\n            this.end.equals(c.end));\n    }\n    clone() {\n        return new Curve(this.start, this.controlPoint1, this.controlPoint2, this.end);\n    }\n    toJSON() {\n        return {\n            start: this.start.toJSON(),\n            controlPoint1: this.controlPoint1.toJSON(),\n            controlPoint2: this.controlPoint2.toJSON(),\n            end: this.end.toJSON(),\n        };\n    }\n    serialize() {\n        return [\n            this.start.serialize(),\n            this.controlPoint1.serialize(),\n            this.controlPoint2.serialize(),\n            this.end.serialize(),\n        ].join(' ');\n    }\n}\n(function (Curve) {\n    Curve.toStringTag = `X6.Geometry.${Curve.name}`;\n    function isCurve(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Curve) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const curve = instance;\n        if ((tag == null || tag === Curve.toStringTag) &&\n            Point.isPoint(curve.start) &&\n            Point.isPoint(curve.controlPoint1) &&\n            Point.isPoint(curve.controlPoint2) &&\n            Point.isPoint(curve.end) &&\n            typeof curve.toPoints === 'function' &&\n            typeof curve.toPolyline === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Curve.isCurve = isCurve;\n})(Curve || (Curve = {}));\n(function (Curve) {\n    function getFirstControlPoints(rhs) {\n        const n = rhs.length;\n        const x = []; // `x` is a solution vector.\n        const tmp = [];\n        let b = 2.0;\n        x[0] = rhs[0] / b;\n        // Decomposition and forward substitution.\n        for (let i = 1; i < n; i += 1) {\n            tmp[i] = 1 / b;\n            b = (i < n - 1 ? 4.0 : 3.5) - tmp[i];\n            x[i] = (rhs[i] - x[i - 1]) / b;\n        }\n        for (let i = 1; i < n; i += 1) {\n            // Backsubstitution.\n            x[n - i - 1] -= tmp[n - i] * x[n - i];\n        }\n        return x;\n    }\n    function getCurveControlPoints(points) {\n        const knots = points.map((p) => Point.clone(p));\n        const firstControlPoints = [];\n        const secondControlPoints = [];\n        const n = knots.length - 1;\n        // Special case: Bezier curve should be a straight line.\n        if (n === 1) {\n            // 3P1 = 2P0 + P3\n            firstControlPoints[0] = new Point((2 * knots[0].x + knots[1].x) / 3, (2 * knots[0].y + knots[1].y) / 3);\n            // P2 = 2P1 â€“ P0\n            secondControlPoints[0] = new Point(2 * firstControlPoints[0].x - knots[0].x, 2 * firstControlPoints[0].y - knots[0].y);\n            return [firstControlPoints, secondControlPoints];\n        }\n        // Calculate first Bezier control points.\n        // Right hand side vector.\n        const rhs = [];\n        // Set right hand side X values.\n        for (let i = 1; i < n - 1; i += 1) {\n            rhs[i] = 4 * knots[i].x + 2 * knots[i + 1].x;\n        }\n        rhs[0] = knots[0].x + 2 * knots[1].x;\n        rhs[n - 1] = (8 * knots[n - 1].x + knots[n].x) / 2.0;\n        // Get first control points X-values.\n        const x = getFirstControlPoints(rhs);\n        // Set right hand side Y values.\n        for (let i = 1; i < n - 1; i += 1) {\n            rhs[i] = 4 * knots[i].y + 2 * knots[i + 1].y;\n        }\n        rhs[0] = knots[0].y + 2 * knots[1].y;\n        rhs[n - 1] = (8 * knots[n - 1].y + knots[n].y) / 2.0;\n        // Get first control points Y-values.\n        const y = getFirstControlPoints(rhs);\n        // Fill output arrays.\n        for (let i = 0; i < n; i += 1) {\n            // First control point.\n            firstControlPoints.push(new Point(x[i], y[i]));\n            // Second control point.\n            if (i < n - 1) {\n                secondControlPoints.push(new Point(2 * knots[i + 1].x - x[i + 1], 2 * knots[i + 1].y - y[i + 1]));\n            }\n            else {\n                secondControlPoints.push(new Point((knots[n].x + x[n - 1]) / 2, (knots[n].y + y[n - 1]) / 2));\n            }\n        }\n        return [firstControlPoints, secondControlPoints];\n    }\n    function throughPoints(points) {\n        if (points == null || (Array.isArray(points) && points.length < 2)) {\n            throw new Error('At least 2 points are required');\n        }\n        const controlPoints = getCurveControlPoints(points);\n        const curves = [];\n        for (let i = 0, ii = controlPoints[0].length; i < ii; i += 1) {\n            const controlPoint1 = new Point(controlPoints[0][i].x, controlPoints[0][i].y);\n            const controlPoint2 = new Point(controlPoints[1][i].x, controlPoints[1][i].y);\n            curves.push(new Curve(points[i], controlPoint1, controlPoint2, points[i + 1]));\n        }\n        return curves;\n    }\n    Curve.throughPoints = throughPoints;\n})(Curve || (Curve = {}));\n//# sourceMappingURL=curve.js.map"]},"metadata":{},"sourceType":"module"}