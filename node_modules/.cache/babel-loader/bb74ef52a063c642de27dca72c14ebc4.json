{"ast":null,"code":"import _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Dom, ObjectExt, FunctionExt } from '../../util';\nimport { Point, Line } from '../../geometry';\nimport { View } from '../../view/view';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\nexport var Segments = /*#__PURE__*/function (_ToolsView$ToolItem) {\n  _inherits(Segments, _ToolsView$ToolItem);\n\n  var _super = _createSuper(Segments);\n\n  function Segments() {\n    var _this;\n\n    _classCallCheck(this, Segments);\n\n    _this = _super.apply(this, arguments);\n    _this.handles = [];\n    return _this;\n  }\n\n  _createClass(Segments, [{\n    key: \"vertices\",\n    get: function get() {\n      return this.cellView.cell.getVertices();\n    }\n  }, {\n    key: \"update\",\n    value: function update() {\n      this.render();\n      return this;\n    }\n  }, {\n    key: \"onRender\",\n    value: function onRender() {\n      Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'));\n      this.resetHandles();\n      var edgeView = this.cellView;\n\n      var vertices = _toConsumableArray(this.vertices);\n\n      vertices.unshift(edgeView.sourcePoint);\n      vertices.push(edgeView.targetPoint);\n\n      for (var i = 0, l = vertices.length; i < l - 1; i += 1) {\n        var vertex = vertices[i];\n        var nextVertex = vertices[i + 1];\n        var handle = this.renderHandle(vertex, nextVertex, i);\n        this.stamp(handle.container);\n        this.handles.push(handle);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"renderHandle\",\n    value: function renderHandle(vertex, nextVertex, index) {\n      var _this2 = this;\n\n      var handle = this.options.createHandle({\n        index: index,\n        graph: this.graph,\n        guard: function guard(evt) {\n          return _this2.guard(evt);\n        },\n        attrs: this.options.attrs || {}\n      });\n\n      if (this.options.processHandle) {\n        this.options.processHandle(handle);\n      }\n\n      this.graph.hook.onToolItemCreated({\n        name: 'segments',\n        cell: this.cell,\n        view: this.cellView,\n        tool: handle\n      });\n      this.updateHandle(handle, vertex, nextVertex);\n      this.container.appendChild(handle.container);\n      this.startHandleListening(handle);\n      return handle;\n    }\n  }, {\n    key: \"startHandleListening\",\n    value: function startHandleListening(handle) {\n      handle.on('change', this.onHandleChange, this);\n      handle.on('changing', this.onHandleChanging, this);\n      handle.on('changed', this.onHandleChanged, this);\n    }\n  }, {\n    key: \"stopHandleListening\",\n    value: function stopHandleListening(handle) {\n      handle.off('change', this.onHandleChange, this);\n      handle.off('changing', this.onHandleChanging, this);\n      handle.off('changed', this.onHandleChanged, this);\n    }\n  }, {\n    key: \"resetHandles\",\n    value: function resetHandles() {\n      var _this3 = this;\n\n      var handles = this.handles;\n      this.handles = [];\n\n      if (handles) {\n        handles.forEach(function (handle) {\n          _this3.stopHandleListening(handle);\n\n          handle.remove();\n        });\n      }\n    }\n  }, {\n    key: \"shiftHandleIndexes\",\n    value: function shiftHandleIndexes(delta) {\n      var handles = this.handles;\n\n      for (var i = 0, n = handles.length; i < n; i += 1) {\n        handles[i].options.index += delta;\n      }\n    }\n  }, {\n    key: \"resetAnchor\",\n    value: function resetAnchor(type, anchor) {\n      var edge = this.cellView.cell;\n      var options = {\n        ui: true,\n        toolId: this.cid\n      };\n\n      if (anchor) {\n        edge.prop([type, 'anchor'], anchor, options);\n      } else {\n        edge.removeProp([type, 'anchor'], options);\n      }\n    }\n  }, {\n    key: \"snapHandle\",\n    value: function snapHandle(handle, position, data) {\n      var axis = handle.options.axis;\n      var index = handle.options.index;\n      var edgeView = this.cellView;\n      var edge = edgeView.cell;\n      var vertices = edge.getVertices();\n      var prev = vertices[index - 2] || data.sourceAnchor;\n      var next = vertices[index + 1] || data.targetAnchor;\n      var snapRadius = this.options.snapRadius;\n\n      if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n        position[axis] = prev[axis];\n      } else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n        position[axis] = next[axis];\n      }\n\n      return position;\n    }\n  }, {\n    key: \"onHandleChanging\",\n    value: function onHandleChanging(_ref) {\n      var handle = _ref.handle,\n          e = _ref.e;\n      var graph = this.graph;\n      var options = this.options;\n      var edgeView = this.cellView;\n      var anchorFn = options.anchor;\n      var axis = handle.options.axis;\n      var index = handle.options.index - 1;\n      var data = this.getEventData(e);\n      var evt = this.normalizeEvent(e);\n      var coords = graph.snapToGrid(evt.clientX, evt.clientY);\n      var position = this.snapHandle(handle, coords.clone(), data);\n      var vertices = ObjectExt.cloneDeep(this.vertices);\n      var vertex = vertices[index];\n      var nextVertex = vertices[index + 1]; // First Segment\n\n      var sourceView = edgeView.sourceView;\n      var sourceBBox = edgeView.sourceBBox;\n      var changeSourceAnchor = false;\n      var deleteSourceAnchor = false;\n\n      if (!vertex) {\n        vertex = edgeView.sourceAnchor.toJSON();\n        vertex[axis] = position[axis];\n\n        if (sourceBBox.containsPoint(vertex)) {\n          changeSourceAnchor = true;\n        } else {\n          vertices.unshift(vertex);\n          this.shiftHandleIndexes(1);\n          deleteSourceAnchor = true;\n        }\n      } else if (index === 0) {\n        if (sourceBBox.containsPoint(vertex)) {\n          vertices.shift();\n          this.shiftHandleIndexes(-1);\n          changeSourceAnchor = true;\n        } else {\n          vertex[axis] = position[axis];\n          deleteSourceAnchor = true;\n        }\n      } else {\n        vertex[axis] = position[axis];\n      }\n\n      if (typeof anchorFn === 'function' && sourceView) {\n        if (changeSourceAnchor) {\n          var sourceAnchorPosition = data.sourceAnchor.clone();\n          sourceAnchorPosition[axis] = position[axis];\n          var sourceAnchor = FunctionExt.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);\n          this.resetAnchor('source', sourceAnchor);\n        }\n\n        if (deleteSourceAnchor) {\n          this.resetAnchor('source', data.sourceAnchorDef);\n        }\n      } // Last segment\n\n\n      var targetView = edgeView.targetView;\n      var targetBBox = edgeView.targetBBox;\n      var changeTargetAnchor = false;\n      var deleteTargetAnchor = false;\n\n      if (!nextVertex) {\n        nextVertex = edgeView.targetAnchor.toJSON();\n        nextVertex[axis] = position[axis];\n\n        if (targetBBox.containsPoint(nextVertex)) {\n          changeTargetAnchor = true;\n        } else {\n          vertices.push(nextVertex);\n          deleteTargetAnchor = true;\n        }\n      } else if (index === vertices.length - 2) {\n        if (targetBBox.containsPoint(nextVertex)) {\n          vertices.pop();\n          changeTargetAnchor = true;\n        } else {\n          nextVertex[axis] = position[axis];\n          deleteTargetAnchor = true;\n        }\n      } else {\n        nextVertex[axis] = position[axis];\n      }\n\n      if (typeof anchorFn === 'function' && targetView) {\n        if (changeTargetAnchor) {\n          var targetAnchorPosition = data.targetAnchor.clone();\n          targetAnchorPosition[axis] = position[axis];\n          var targetAnchor = FunctionExt.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);\n          this.resetAnchor('target', targetAnchor);\n        }\n\n        if (deleteTargetAnchor) {\n          this.resetAnchor('target', data.targetAnchorDef);\n        }\n      }\n\n      if (!Point.equalPoints(vertices, this.vertices)) {\n        this.cellView.cell.setVertices(vertices, {\n          ui: true,\n          toolId: this.cid\n        });\n      }\n\n      this.updateHandle(handle, vertex, nextVertex, 0);\n\n      if (!options.stopPropagation) {\n        edgeView.notifyMouseMove(evt, coords.x, coords.y);\n      }\n    }\n  }, {\n    key: \"onHandleChange\",\n    value: function onHandleChange(_ref2) {\n      var handle = _ref2.handle,\n          e = _ref2.e;\n      var options = this.options;\n      var handles = this.handles;\n      var edgeView = this.cellView;\n      var index = handle.options.index;\n\n      if (!Array.isArray(handles)) {\n        return;\n      }\n\n      for (var i = 0, n = handles.length; i < n; i += 1) {\n        if (i !== index) {\n          handles[i].hide();\n        }\n      }\n\n      this.focus();\n      this.setEventData(e, {\n        sourceAnchor: edgeView.sourceAnchor.clone(),\n        targetAnchor: edgeView.targetAnchor.clone(),\n        sourceAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['source', 'anchor'])),\n        targetAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['target', 'anchor']))\n      });\n      this.cell.startBatch('move-segment', {\n        ui: true,\n        toolId: this.cid\n      });\n\n      if (!options.stopPropagation) {\n        var normalizedEvent = this.normalizeEvent(e);\n        var coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);\n      }\n    }\n  }, {\n    key: \"onHandleChanged\",\n    value: function onHandleChanged(_ref3) {\n      var e = _ref3.e;\n      var options = this.options;\n      var edgeView = this.cellView;\n\n      if (options.removeRedundancies) {\n        edgeView.removeRedundantLinearVertices({\n          ui: true,\n          toolId: this.cid\n        });\n      }\n\n      var normalizedEvent = this.normalizeEvent(e);\n      var coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n      this.render();\n      this.blur();\n      this.cell.stopBatch('move-segment', {\n        ui: true,\n        toolId: this.cid\n      });\n\n      if (!options.stopPropagation) {\n        edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);\n      }\n\n      edgeView.checkMouseleave(normalizedEvent);\n      options.onChanged && options.onChanged({\n        edge: edgeView.cell,\n        edgeView: edgeView\n      });\n    }\n  }, {\n    key: \"updateHandle\",\n    value: function updateHandle(handle, vertex, nextVertex) {\n      var offset = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var precision = this.options.precision || 0;\n      var vertical = Math.abs(vertex.x - nextVertex.x) < precision;\n      var horizontal = Math.abs(vertex.y - nextVertex.y) < precision;\n\n      if (vertical || horizontal) {\n        var segmentLine = new Line(vertex, nextVertex);\n        var length = segmentLine.length();\n\n        if (length < this.options.threshold) {\n          handle.hide();\n        } else {\n          var position = segmentLine.getCenter();\n          var axis = vertical ? 'x' : 'y';\n          position[axis] += offset || 0;\n          var angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n          handle.updatePosition(position.x, position.y, angle, this.cellView);\n          handle.show();\n          handle.options.axis = axis;\n        }\n      } else {\n        handle.hide();\n      }\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.resetHandles();\n    }\n  }]);\n\n  return Segments;\n}(ToolsView.ToolItem);\n\n(function (Segments) {\n  var Handle = /*#__PURE__*/function (_View) {\n    _inherits(Handle, _View);\n\n    var _super2 = _createSuper(Handle);\n\n    function Handle(options) {\n      var _this4;\n\n      _classCallCheck(this, Handle);\n\n      _this4 = _super2.call(this);\n      _this4.options = options;\n\n      _this4.render();\n\n      _this4.delegateEvents({\n        mousedown: 'onMouseDown',\n        touchstart: 'onMouseDown'\n      });\n\n      return _this4;\n    }\n\n    _createClass(Handle, [{\n      key: \"render\",\n      value: function render() {\n        this.container = View.createElement('rect', true);\n        var attrs = this.options.attrs;\n\n        if (typeof attrs === 'function') {\n          var defaults = Segments.getDefaults();\n          this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));\n        } else {\n          this.setAttrs(attrs);\n        }\n\n        this.addClass(this.prefixClassName('edge-tool-segment'));\n      }\n    }, {\n      key: \"updatePosition\",\n      value: function updatePosition(x, y, angle, view) {\n        var p = view.getClosestPoint(new Point(x, y)) || new Point(x, y);\n        var matrix = Dom.createSVGMatrix().translate(p.x, p.y);\n\n        if (!p.equals({\n          x: x,\n          y: y\n        })) {\n          var line = new Line(x, y, p.x, p.y);\n          var deg = line.vector().vectorAngle(new Point(1, 0));\n\n          if (deg !== 0) {\n            deg += 90;\n          }\n\n          matrix = matrix.rotate(deg);\n        } else {\n          matrix = matrix.rotate(angle);\n        }\n\n        this.setAttrs({\n          transform: Dom.matrixToTransformString(matrix),\n          cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize'\n        });\n      }\n    }, {\n      key: \"onMouseDown\",\n      value: function onMouseDown(evt) {\n        if (this.options.guard(evt)) {\n          return;\n        }\n\n        this.trigger('change', {\n          e: evt,\n          handle: this\n        });\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.options.graph.view.undelegateEvents();\n        this.delegateDocumentEvents({\n          mousemove: 'onMouseMove',\n          touchmove: 'onMouseMove',\n          mouseup: 'onMouseUp',\n          touchend: 'onMouseUp',\n          touchcancel: 'onMouseUp'\n        }, evt.data);\n      }\n    }, {\n      key: \"onMouseMove\",\n      value: function onMouseMove(evt) {\n        this.emit('changing', {\n          e: evt,\n          handle: this\n        });\n      }\n    }, {\n      key: \"onMouseUp\",\n      value: function onMouseUp(evt) {\n        this.emit('changed', {\n          e: evt,\n          handle: this\n        });\n        this.undelegateDocumentEvents();\n        this.options.graph.view.delegateEvents();\n      }\n    }, {\n      key: \"show\",\n      value: function show() {\n        this.container.style.display = '';\n      }\n    }, {\n      key: \"hide\",\n      value: function hide() {\n        this.container.style.display = 'none';\n      }\n    }]);\n\n    return Handle;\n  }(View);\n\n  Segments.Handle = Handle;\n})(Segments || (Segments = {}));\n\n(function (Segments) {\n  Segments.config({\n    name: 'segments',\n    precision: 0.5,\n    threshold: 40,\n    snapRadius: 10,\n    stopPropagation: true,\n    removeRedundancies: true,\n    attrs: {\n      width: 20,\n      height: 8,\n      x: -10,\n      y: -4,\n      rx: 4,\n      ry: 4,\n      fill: '#333',\n      stroke: '#fff',\n      'stroke-width': 2\n    },\n    createHandle: function createHandle(options) {\n      return new Segments.Handle(options);\n    },\n    anchor: Util.getAnchor\n  });\n})(Segments || (Segments = {}));","map":{"version":3,"sources":["../../../src/registry/tool/segments.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Dom, ObjectExt, FunctionExt } from '../../util';\nimport { Point, Line } from '../../geometry';\nimport { View } from '../../view/view';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\nexport class Segments extends ToolsView.ToolItem {\n    constructor() {\n        super(...arguments);\n        this.handles = [];\n    }\n    get vertices() {\n        return this.cellView.cell.getVertices();\n    }\n    update() {\n        this.render();\n        return this;\n    }\n    onRender() {\n        Dom.addClass(this.container, this.prefixClassName('edge-tool-segments'));\n        this.resetHandles();\n        const edgeView = this.cellView;\n        const vertices = [...this.vertices];\n        vertices.unshift(edgeView.sourcePoint);\n        vertices.push(edgeView.targetPoint);\n        for (let i = 0, l = vertices.length; i < l - 1; i += 1) {\n            const vertex = vertices[i];\n            const nextVertex = vertices[i + 1];\n            const handle = this.renderHandle(vertex, nextVertex, i);\n            this.stamp(handle.container);\n            this.handles.push(handle);\n        }\n        return this;\n    }\n    renderHandle(vertex, nextVertex, index) {\n        const handle = this.options.createHandle({\n            index,\n            graph: this.graph,\n            guard: (evt) => this.guard(evt),\n            attrs: this.options.attrs || {},\n        });\n        if (this.options.processHandle) {\n            this.options.processHandle(handle);\n        }\n        this.graph.hook.onToolItemCreated({\n            name: 'segments',\n            cell: this.cell,\n            view: this.cellView,\n            tool: handle,\n        });\n        this.updateHandle(handle, vertex, nextVertex);\n        this.container.appendChild(handle.container);\n        this.startHandleListening(handle);\n        return handle;\n    }\n    startHandleListening(handle) {\n        handle.on('change', this.onHandleChange, this);\n        handle.on('changing', this.onHandleChanging, this);\n        handle.on('changed', this.onHandleChanged, this);\n    }\n    stopHandleListening(handle) {\n        handle.off('change', this.onHandleChange, this);\n        handle.off('changing', this.onHandleChanging, this);\n        handle.off('changed', this.onHandleChanged, this);\n    }\n    resetHandles() {\n        const handles = this.handles;\n        this.handles = [];\n        if (handles) {\n            handles.forEach((handle) => {\n                this.stopHandleListening(handle);\n                handle.remove();\n            });\n        }\n    }\n    shiftHandleIndexes(delta) {\n        const handles = this.handles;\n        for (let i = 0, n = handles.length; i < n; i += 1) {\n            handles[i].options.index += delta;\n        }\n    }\n    resetAnchor(type, anchor) {\n        const edge = this.cellView.cell;\n        const options = {\n            ui: true,\n            toolId: this.cid,\n        };\n        if (anchor) {\n            edge.prop([type, 'anchor'], anchor, options);\n        }\n        else {\n            edge.removeProp([type, 'anchor'], options);\n        }\n    }\n    snapHandle(handle, position, data) {\n        const axis = handle.options.axis;\n        const index = handle.options.index;\n        const edgeView = this.cellView;\n        const edge = edgeView.cell;\n        const vertices = edge.getVertices();\n        const prev = vertices[index - 2] || data.sourceAnchor;\n        const next = vertices[index + 1] || data.targetAnchor;\n        const snapRadius = this.options.snapRadius;\n        if (Math.abs(position[axis] - prev[axis]) < snapRadius) {\n            position[axis] = prev[axis];\n        }\n        else if (Math.abs(position[axis] - next[axis]) < snapRadius) {\n            position[axis] = next[axis];\n        }\n        return position;\n    }\n    onHandleChanging({ handle, e, }) {\n        const graph = this.graph;\n        const options = this.options;\n        const edgeView = this.cellView;\n        const anchorFn = options.anchor;\n        const axis = handle.options.axis;\n        const index = handle.options.index - 1;\n        const data = this.getEventData(e);\n        const evt = this.normalizeEvent(e);\n        const coords = graph.snapToGrid(evt.clientX, evt.clientY);\n        const position = this.snapHandle(handle, coords.clone(), data);\n        const vertices = ObjectExt.cloneDeep(this.vertices);\n        let vertex = vertices[index];\n        let nextVertex = vertices[index + 1];\n        // First Segment\n        const sourceView = edgeView.sourceView;\n        const sourceBBox = edgeView.sourceBBox;\n        let changeSourceAnchor = false;\n        let deleteSourceAnchor = false;\n        if (!vertex) {\n            vertex = edgeView.sourceAnchor.toJSON();\n            vertex[axis] = position[axis];\n            if (sourceBBox.containsPoint(vertex)) {\n                changeSourceAnchor = true;\n            }\n            else {\n                vertices.unshift(vertex);\n                this.shiftHandleIndexes(1);\n                deleteSourceAnchor = true;\n            }\n        }\n        else if (index === 0) {\n            if (sourceBBox.containsPoint(vertex)) {\n                vertices.shift();\n                this.shiftHandleIndexes(-1);\n                changeSourceAnchor = true;\n            }\n            else {\n                vertex[axis] = position[axis];\n                deleteSourceAnchor = true;\n            }\n        }\n        else {\n            vertex[axis] = position[axis];\n        }\n        if (typeof anchorFn === 'function' && sourceView) {\n            if (changeSourceAnchor) {\n                const sourceAnchorPosition = data.sourceAnchor.clone();\n                sourceAnchorPosition[axis] = position[axis];\n                const sourceAnchor = FunctionExt.call(anchorFn, edgeView, sourceAnchorPosition, sourceView, edgeView.sourceMagnet || sourceView.container, 'source', edgeView, this);\n                this.resetAnchor('source', sourceAnchor);\n            }\n            if (deleteSourceAnchor) {\n                this.resetAnchor('source', data.sourceAnchorDef);\n            }\n        }\n        // Last segment\n        const targetView = edgeView.targetView;\n        const targetBBox = edgeView.targetBBox;\n        let changeTargetAnchor = false;\n        let deleteTargetAnchor = false;\n        if (!nextVertex) {\n            nextVertex = edgeView.targetAnchor.toJSON();\n            nextVertex[axis] = position[axis];\n            if (targetBBox.containsPoint(nextVertex)) {\n                changeTargetAnchor = true;\n            }\n            else {\n                vertices.push(nextVertex);\n                deleteTargetAnchor = true;\n            }\n        }\n        else if (index === vertices.length - 2) {\n            if (targetBBox.containsPoint(nextVertex)) {\n                vertices.pop();\n                changeTargetAnchor = true;\n            }\n            else {\n                nextVertex[axis] = position[axis];\n                deleteTargetAnchor = true;\n            }\n        }\n        else {\n            nextVertex[axis] = position[axis];\n        }\n        if (typeof anchorFn === 'function' && targetView) {\n            if (changeTargetAnchor) {\n                const targetAnchorPosition = data.targetAnchor.clone();\n                targetAnchorPosition[axis] = position[axis];\n                const targetAnchor = FunctionExt.call(anchorFn, edgeView, targetAnchorPosition, targetView, edgeView.targetMagnet || targetView.container, 'target', edgeView, this);\n                this.resetAnchor('target', targetAnchor);\n            }\n            if (deleteTargetAnchor) {\n                this.resetAnchor('target', data.targetAnchorDef);\n            }\n        }\n        if (!Point.equalPoints(vertices, this.vertices)) {\n            this.cellView.cell.setVertices(vertices, { ui: true, toolId: this.cid });\n        }\n        this.updateHandle(handle, vertex, nextVertex, 0);\n        if (!options.stopPropagation) {\n            edgeView.notifyMouseMove(evt, coords.x, coords.y);\n        }\n    }\n    onHandleChange({ handle, e }) {\n        const options = this.options;\n        const handles = this.handles;\n        const edgeView = this.cellView;\n        const index = handle.options.index;\n        if (!Array.isArray(handles)) {\n            return;\n        }\n        for (let i = 0, n = handles.length; i < n; i += 1) {\n            if (i !== index) {\n                handles[i].hide();\n            }\n        }\n        this.focus();\n        this.setEventData(e, {\n            sourceAnchor: edgeView.sourceAnchor.clone(),\n            targetAnchor: edgeView.targetAnchor.clone(),\n            sourceAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['source', 'anchor'])),\n            targetAnchorDef: ObjectExt.cloneDeep(this.cell.prop(['target', 'anchor'])),\n        });\n        this.cell.startBatch('move-segment', { ui: true, toolId: this.cid });\n        if (!options.stopPropagation) {\n            const normalizedEvent = this.normalizeEvent(e);\n            const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n            edgeView.notifyMouseDown(normalizedEvent, coords.x, coords.y);\n        }\n    }\n    onHandleChanged({ e }) {\n        const options = this.options;\n        const edgeView = this.cellView;\n        if (options.removeRedundancies) {\n            edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });\n        }\n        const normalizedEvent = this.normalizeEvent(e);\n        const coords = this.graph.snapToGrid(normalizedEvent.clientX, normalizedEvent.clientY);\n        this.render();\n        this.blur();\n        this.cell.stopBatch('move-segment', { ui: true, toolId: this.cid });\n        if (!options.stopPropagation) {\n            edgeView.notifyMouseUp(normalizedEvent, coords.x, coords.y);\n        }\n        edgeView.checkMouseleave(normalizedEvent);\n        options.onChanged && options.onChanged({ edge: edgeView.cell, edgeView });\n    }\n    updateHandle(handle, vertex, nextVertex, offset = 0) {\n        const precision = this.options.precision || 0;\n        const vertical = Math.abs(vertex.x - nextVertex.x) < precision;\n        const horizontal = Math.abs(vertex.y - nextVertex.y) < precision;\n        if (vertical || horizontal) {\n            const segmentLine = new Line(vertex, nextVertex);\n            const length = segmentLine.length();\n            if (length < this.options.threshold) {\n                handle.hide();\n            }\n            else {\n                const position = segmentLine.getCenter();\n                const axis = vertical ? 'x' : 'y';\n                position[axis] += offset || 0;\n                const angle = segmentLine.vector().vectorAngle(new Point(1, 0));\n                handle.updatePosition(position.x, position.y, angle, this.cellView);\n                handle.show();\n                handle.options.axis = axis;\n            }\n        }\n        else {\n            handle.hide();\n        }\n    }\n    onRemove() {\n        this.resetHandles();\n    }\n}\n(function (Segments) {\n    class Handle extends View {\n        constructor(options) {\n            super();\n            this.options = options;\n            this.render();\n            this.delegateEvents({\n                mousedown: 'onMouseDown',\n                touchstart: 'onMouseDown',\n            });\n        }\n        render() {\n            this.container = View.createElement('rect', true);\n            const attrs = this.options.attrs;\n            if (typeof attrs === 'function') {\n                const defaults = Segments.getDefaults();\n                this.setAttrs(Object.assign(Object.assign({}, defaults.attrs), attrs(this)));\n            }\n            else {\n                this.setAttrs(attrs);\n            }\n            this.addClass(this.prefixClassName('edge-tool-segment'));\n        }\n        updatePosition(x, y, angle, view) {\n            const p = view.getClosestPoint(new Point(x, y)) || new Point(x, y);\n            let matrix = Dom.createSVGMatrix().translate(p.x, p.y);\n            if (!p.equals({ x, y })) {\n                const line = new Line(x, y, p.x, p.y);\n                let deg = line.vector().vectorAngle(new Point(1, 0));\n                if (deg !== 0) {\n                    deg += 90;\n                }\n                matrix = matrix.rotate(deg);\n            }\n            else {\n                matrix = matrix.rotate(angle);\n            }\n            this.setAttrs({\n                transform: Dom.matrixToTransformString(matrix),\n                cursor: angle % 180 === 0 ? 'row-resize' : 'col-resize',\n            });\n        }\n        onMouseDown(evt) {\n            if (this.options.guard(evt)) {\n                return;\n            }\n            this.trigger('change', { e: evt, handle: this });\n            evt.stopPropagation();\n            evt.preventDefault();\n            this.options.graph.view.undelegateEvents();\n            this.delegateDocumentEvents({\n                mousemove: 'onMouseMove',\n                touchmove: 'onMouseMove',\n                mouseup: 'onMouseUp',\n                touchend: 'onMouseUp',\n                touchcancel: 'onMouseUp',\n            }, evt.data);\n        }\n        onMouseMove(evt) {\n            this.emit('changing', { e: evt, handle: this });\n        }\n        onMouseUp(evt) {\n            this.emit('changed', { e: evt, handle: this });\n            this.undelegateDocumentEvents();\n            this.options.graph.view.delegateEvents();\n        }\n        show() {\n            this.container.style.display = '';\n        }\n        hide() {\n            this.container.style.display = 'none';\n        }\n    }\n    Segments.Handle = Handle;\n})(Segments || (Segments = {}));\n(function (Segments) {\n    Segments.config({\n        name: 'segments',\n        precision: 0.5,\n        threshold: 40,\n        snapRadius: 10,\n        stopPropagation: true,\n        removeRedundancies: true,\n        attrs: {\n            width: 20,\n            height: 8,\n            x: -10,\n            y: -4,\n            rx: 4,\n            ry: 4,\n            fill: '#333',\n            stroke: '#fff',\n            'stroke-width': 2,\n        },\n        createHandle: (options) => new Segments.Handle(options),\n        anchor: Util.getAnchor,\n    });\n})(Segments || (Segments = {}));\n//# sourceMappingURL=segments.js.map"]},"metadata":{},"sourceType":"module"}