{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\nimport _isString from \"lodash/isString\";\nimport _isNumber from \"lodash/isNumber\";\nimport _isEqual from \"lodash/isEqual\";\nimport _isArray from \"lodash/isArray\";\n\nvar _dec, _dec2, _class, _descriptor, _descriptor2;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nimport { BlendType, gl, lazyInject, TYPES } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport { color } from 'd3-color';\nimport { BlendTypes } from '../utils/blend';\nvar BaseModel = (_dec = lazyInject(TYPES.IGlobalConfigService), _dec2 = lazyInject(TYPES.IShaderModuleService), (_class = function () {\n  function BaseModel(layer) {\n    _classCallCheck(this, BaseModel);\n\n    _defineProperty(this, \"triangulation\", void 0);\n\n    _defineProperty(this, \"createTexture2D\", void 0);\n\n    _defineProperty(this, \"layer\", void 0);\n\n    _defineProperty(this, \"dataTexture\", void 0);\n\n    _defineProperty(this, \"DATA_TEXTURE_WIDTH\", void 0);\n\n    _defineProperty(this, \"rowCount\", void 0);\n\n    _defineProperty(this, \"cacheStyleProperties\", void 0);\n\n    _defineProperty(this, \"cellLength\", void 0);\n\n    _defineProperty(this, \"cellProperties\", void 0);\n\n    _defineProperty(this, \"cellTypeLayout\", void 0);\n\n    _defineProperty(this, \"stylePropertyesExist\", void 0);\n\n    _defineProperty(this, \"dataTextureTest\", void 0);\n\n    _initializerDefineProperty(this, \"configService\", _descriptor, this);\n\n    _initializerDefineProperty(this, \"shaderModuleService\", _descriptor2, this);\n\n    _defineProperty(this, \"rendererService\", void 0);\n\n    _defineProperty(this, \"iconService\", void 0);\n\n    _defineProperty(this, \"fontService\", void 0);\n\n    _defineProperty(this, \"styleAttributeService\", void 0);\n\n    _defineProperty(this, \"mapService\", void 0);\n\n    _defineProperty(this, \"cameraService\", void 0);\n\n    _defineProperty(this, \"layerService\", void 0);\n\n    this.layer = layer;\n    this.rendererService = layer.getContainer().get(TYPES.IRendererService);\n    this.styleAttributeService = layer.getContainer().get(TYPES.IStyleAttributeService);\n    this.mapService = layer.getContainer().get(TYPES.IMapService);\n    this.iconService = layer.getContainer().get(TYPES.IIconService);\n    this.fontService = layer.getContainer().get(TYPES.IFontService);\n    this.cameraService = layer.getContainer().get(TYPES.ICameraService);\n    this.layerService = layer.getContainer().get(TYPES.ILayerService);\n    this.registerBuiltinAttributes();\n    this.startModelAnimate();\n    var createTexture2D = this.rendererService.createTexture2D;\n    this.createTexture2D = createTexture2D;\n    this.DATA_TEXTURE_WIDTH = 1024;\n    this.rowCount = 1;\n    this.cellLength = 0;\n    this.cellProperties = [];\n    this.cacheStyleProperties = {\n      opacity: undefined,\n      strokeOpacity: undefined,\n      strokeWidth: undefined,\n      stroke: undefined,\n      offsets: undefined\n    };\n    this.stylePropertyesExist = {\n      hasOpacity: 0,\n      hasStrokeOpacity: 0,\n      hasStrokeWidth: 0,\n      hasStroke: 0,\n      hasOffsets: 0\n    };\n    this.dataTextureTest = this.layerService.getOESTextureFloat();\n\n    if (!this.dataTextureTest) {\n      this.dataTexture = this.createTexture2D({\n        data: new Uint8ClampedArray(4),\n        mag: gl.NEAREST,\n        min: gl.NEAREST,\n        width: 1,\n        height: 1\n      });\n    }\n  }\n\n  _createClass(BaseModel, [{\n    key: \"clearLastCalRes\",\n    value: function clearLastCalRes() {\n      this.cellProperties = [];\n      this.cellLength = 0;\n      this.stylePropertyesExist = {\n        hasOpacity: 0,\n        hasStrokeOpacity: 0,\n        hasStrokeWidth: 0,\n        hasStroke: 0,\n        hasOffsets: 0\n      };\n    }\n  }, {\n    key: \"getCellTypeLayout\",\n    value: function getCellTypeLayout() {\n      if (this.dataTextureTest) {\n        return [this.rowCount, this.DATA_TEXTURE_WIDTH, 0.0, 0.0, this.stylePropertyesExist.hasOpacity, this.stylePropertyesExist.hasStrokeOpacity, this.stylePropertyesExist.hasStrokeWidth, this.stylePropertyesExist.hasStroke, this.stylePropertyesExist.hasOffsets, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 1.0];\n      } else {\n        return [1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0, -1.0];\n      }\n    }\n  }, {\n    key: \"dataTextureNeedUpdate\",\n    value: function dataTextureNeedUpdate(options) {\n      var isUpdate = false;\n\n      if (!_isEqual(options.opacity, this.cacheStyleProperties.opacity)) {\n        isUpdate = true;\n        this.cacheStyleProperties.opacity = options.opacity;\n      }\n\n      if (!_isEqual(options.strokeOpacity, this.cacheStyleProperties.strokeOpacity)) {\n        isUpdate = true;\n        this.cacheStyleProperties.strokeOpacity = options.strokeOpacity;\n      }\n\n      if (!_isEqual(options.strokeWidth, this.cacheStyleProperties.strokeWidth)) {\n        isUpdate = true;\n        this.cacheStyleProperties.strokeWidth = options.strokeWidth;\n      }\n\n      if (!_isEqual(options.stroke, this.cacheStyleProperties.stroke)) {\n        isUpdate = true;\n        this.cacheStyleProperties.stroke = options.stroke;\n      }\n\n      if (!_isEqual(options.offsets, this.cacheStyleProperties.offsets)) {\n        isUpdate = true;\n        this.cacheStyleProperties.offsets = options.offsets;\n      }\n\n      if (this.dataTexture === undefined) {\n        isUpdate = true;\n      }\n\n      return isUpdate;\n    }\n  }, {\n    key: \"judgeStyleAttributes\",\n    value: function judgeStyleAttributes(options) {\n      this.clearLastCalRes();\n\n      if (options.opacity !== undefined && !_isNumber(options.opacity)) {\n        this.cellProperties.push({\n          attr: 'opacity',\n          count: 1\n        });\n        this.stylePropertyesExist.hasOpacity = 1;\n        this.cellLength += 1;\n      }\n\n      if (options.strokeOpacity !== undefined && !_isNumber(options.strokeOpacity)) {\n        this.cellProperties.push({\n          attr: 'strokeOpacity',\n          count: 1\n        });\n        this.stylePropertyesExist.hasStrokeOpacity = 1;\n        this.cellLength += 1;\n      }\n\n      if (options.strokeWidth !== undefined && !_isNumber(options.strokeWidth)) {\n        this.cellProperties.push({\n          attr: 'strokeWidth',\n          count: 1\n        });\n        this.stylePropertyesExist.hasStrokeWidth = 1;\n        this.cellLength += 1;\n      }\n\n      if (options.stroke !== undefined && !this.isStaticColor(options.stroke)) {\n        this.cellProperties.push({\n          attr: 'stroke',\n          count: 4\n        });\n        this.stylePropertyesExist.hasStroke = 1;\n        this.cellLength += 4;\n      }\n\n      if (options.offsets !== undefined && !this.isOffsetStatic(options.offsets)) {\n        this.cellProperties.push({\n          attr: 'offsets',\n          count: 2\n        });\n        this.stylePropertyesExist.hasOffsets = 1;\n        this.cellLength += 2;\n      }\n    }\n  }, {\n    key: \"isStaticColor\",\n    value: function isStaticColor(stroke) {\n      if (_isString(stroke)) {\n        if (color(stroke)) {\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      return false;\n    }\n  }, {\n    key: \"getStrokeColor\",\n    value: function getStrokeColor(stroke) {\n      if (this.isStaticColor(stroke)) {\n        var strokeColor = rgb2arr(stroke);\n        strokeColor[0] = strokeColor[0] ? strokeColor[0] : 0;\n        strokeColor[1] = strokeColor[1] ? strokeColor[1] : 0;\n        strokeColor[2] = strokeColor[2] ? strokeColor[2] : 0;\n        strokeColor[3] = strokeColor[3] ? strokeColor[3] : 0;\n        return strokeColor;\n      } else {\n        return [0, 0, 0, 0];\n      }\n    }\n  }, {\n    key: \"isOffsetStatic\",\n    value: function isOffsetStatic(offsets) {\n      if (_isArray(offsets) && offsets.length === 2 && _isNumber(offsets[0]) && _isNumber(offsets[1])) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n  }, {\n    key: \"patchMod\",\n    value: function patchMod(d, count) {\n      for (var i = 0; i < count; i++) {\n        d.push(-1);\n      }\n    }\n  }, {\n    key: \"patchData\",\n    value: function patchData(d, cellData, cellPropertiesLayouts) {\n      var _iterator = _createForOfIteratorHelper(cellPropertiesLayouts),\n          _step;\n\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var layout = _step.value;\n          var attr = layout.attr,\n              count = layout.count;\n          var value = cellData[attr];\n\n          if (value) {\n            if (attr === 'stroke') {\n              d.push.apply(d, _toConsumableArray(rgb2arr(value)));\n            } else if (attr === 'offsets') {\n              if (this.isOffsetStatic(value)) {\n                d.push(-value[0], value[1]);\n              } else {\n                d.push(0, 0);\n              }\n            } else {\n              d.push(_isNumber(value) ? value : 1.0);\n            }\n          } else {\n            this.patchMod(d, count);\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  }, {\n    key: \"calDataFrame\",\n    value: function calDataFrame(cellLength, encodeData, cellPropertiesLayouts) {\n      var encodeDatalength = encodeData.length;\n      var rowCount = Math.ceil(encodeDatalength * cellLength / this.DATA_TEXTURE_WIDTH);\n      var totalLength = rowCount * this.DATA_TEXTURE_WIDTH;\n      var d = [];\n\n      for (var i = 0; i < encodeDatalength; i++) {\n        var cellData = encodeData[i];\n        this.patchData(d, cellData, cellPropertiesLayouts);\n      }\n\n      for (var _i = d.length; _i < totalLength; _i++) {\n        d.push(-1);\n      }\n\n      return {\n        data: d,\n        width: this.DATA_TEXTURE_WIDTH,\n        height: rowCount\n      };\n    }\n  }, {\n    key: \"getBlend\",\n    value: function getBlend() {\n      var _this$layer$getLayerC = this.layer.getLayerConfig(),\n          _this$layer$getLayerC2 = _this$layer$getLayerC.blend,\n          blend = _this$layer$getLayerC2 === void 0 ? 'normal' : _this$layer$getLayerC2;\n\n      return BlendTypes[BlendType[blend]];\n    }\n  }, {\n    key: \"getDefaultStyle\",\n    value: function getDefaultStyle() {\n      return {};\n    }\n  }, {\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      return {};\n    }\n  }, {\n    key: \"needUpdate\",\n    value: function needUpdate() {\n      return false;\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"clearModels\",\n    value: function clearModels() {\n      return;\n    }\n  }, {\n    key: \"getAttribute\",\n    value: function getAttribute() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"animateOption2Array\",\n    value: function animateOption2Array(option) {\n      return [option.enable ? 0 : 1.0, option.duration || 4.0, option.interval || 0.2, option.trailLength || 0.1];\n    }\n  }, {\n    key: \"startModelAnimate\",\n    value: function startModelAnimate() {\n      var _ref = this.layer.getLayerConfig(),\n          animateOption = _ref.animateOption;\n\n      if (animateOption.enable) {\n        this.layer.setAnimateStartTime();\n      }\n    }\n  }]);\n\n  return BaseModel;\n}(), (_descriptor = _applyDecoratedDescriptor(_class.prototype, \"configService\", [_dec], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _descriptor2 = _applyDecoratedDescriptor(_class.prototype, \"shaderModuleService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n})), _class));\nexport { BaseModel as default };","map":{"version":3,"sources":["../../src/core/BaseModel.ts"],"names":["BaseModel","lazyInject","TYPES","layer","createTexture2D","opacity","strokeOpacity","strokeWidth","stroke","offsets","undefined","hasOpacity","hasStrokeOpacity","hasStrokeWidth","hasStroke","hasOffsets","data","mag","gl","min","width","height","isUpdate","options","attr","count","color","strokeColor","rgb2arr","i","d","layout","value","cellData","encodeDatalength","encodeData","rowCount","Math","totalLength","blend","BlendTypes","BlendType","option","animateOption"],"mappings":"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","sourcesContent":["import {\n  BlendType,\n  gl,\n  IAnimateOption,\n  IAttribute,\n  IBlendOptions,\n  ICameraService,\n  IElements,\n  IEncodeFeature,\n  IFontService,\n  IGlobalConfigService,\n  IIconService,\n  ILayer,\n  ILayerConfig,\n  ILayerModel,\n  ILayerService,\n  IMapService,\n  IModel,\n  IModelUniform,\n  IRendererService,\n  IShaderModuleService,\n  IStyleAttributeService,\n  ITexture2D,\n  ITexture2DInitializationOptions,\n  lazyInject,\n  Triangulation,\n  TYPES,\n} from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport { color } from 'd3-color';\nimport { isArray, isEqual, isFunction, isNumber, isString } from 'lodash';\nimport { BlendTypes } from '../utils/blend';\n\nexport type styleSingle =\n  | number\n  | string\n  | [string, (single: any) => number]\n  | [string, [number, number]];\nexport type styleOffset =\n  | string\n  | [number, number]\n  | [string, (single: any) => number];\nexport type styleColor =\n  | string\n  | [string, (single: any) => string]\n  | [string, [string, string]];\nexport interface IDataTextureFrame {\n  data: number[];\n  width: number;\n  height: number;\n}\n\nexport interface ICellProperty {\n  attr: string;\n  count: number;\n}\n\nexport default class BaseModel<ChildLayerStyleOptions = {}>\n  implements ILayerModel {\n  public triangulation: Triangulation;\n\n  // style texture data mapping\n  public createTexture2D: (\n    options: ITexture2DInitializationOptions,\n  ) => ITexture2D;\n\n  protected layer: ILayer;\n  protected dataTexture: ITexture2D; // 用于数据传递的数据纹理\n  protected DATA_TEXTURE_WIDTH: number; // 默认有多少列（宽度）\n  protected rowCount: number; // 计算得到的当前数据纹理有多少行（高度）\n  protected cacheStyleProperties: {\n    // 记录存储上一次样式字段的值\n    opacity: styleSingle | undefined;\n    strokeOpacity: styleSingle | undefined;\n    strokeWidth: styleSingle | undefined;\n    stroke: styleColor | undefined;\n    offsets: styleOffset | undefined;\n  };\n  protected cellLength: number; // 单个 cell 的长度\n  protected cellProperties: ICellProperty[]; // 需要进行数据映射的属性集合\n  protected cellTypeLayout: number[];\n  protected stylePropertyesExist: {\n    // 记录 style 属性是否存在的中间变量\n    hasOpacity: number;\n    hasStrokeOpacity: number;\n    hasStrokeWidth: number;\n    hasStroke: number;\n    hasOffsets: number;\n  };\n  protected dataTextureTest: boolean;\n\n  @lazyInject(TYPES.IGlobalConfigService)\n  protected readonly configService: IGlobalConfigService;\n\n  // @lazyInject(TYPES.IIconService)\n  // protected readonly iconService: IIconService;\n\n  // @lazyInject(TYPES.IFontService)\n  // protected readonly fontService: IFontService;\n\n  @lazyInject(TYPES.IShaderModuleService)\n  protected readonly shaderModuleService: IShaderModuleService;\n\n  protected rendererService: IRendererService;\n  protected iconService: IIconService;\n  protected fontService: IFontService;\n  protected styleAttributeService: IStyleAttributeService;\n  protected mapService: IMapService;\n  protected cameraService: ICameraService;\n  protected layerService: ILayerService;\n\n  // style texture data mapping\n\n  constructor(layer: ILayer) {\n    this.layer = layer;\n    this.rendererService = layer\n      .getContainer()\n      .get<IRendererService>(TYPES.IRendererService);\n    this.styleAttributeService = layer\n      .getContainer()\n      .get<IStyleAttributeService>(TYPES.IStyleAttributeService);\n    this.mapService = layer.getContainer().get<IMapService>(TYPES.IMapService);\n    this.iconService = layer\n      .getContainer()\n      .get<IIconService>(TYPES.IIconService);\n    this.fontService = layer\n      .getContainer()\n      .get<IFontService>(TYPES.IFontService);\n    this.cameraService = layer\n      .getContainer()\n      .get<ICameraService>(TYPES.ICameraService);\n    this.layerService = layer\n      .getContainer()\n      .get<ILayerService>(TYPES.ILayerService);\n\n    // 注册 Attribute\n    this.registerBuiltinAttributes();\n    // 开启动画\n    this.startModelAnimate();\n\n    const { createTexture2D } = this.rendererService;\n    this.createTexture2D = createTexture2D;\n    this.DATA_TEXTURE_WIDTH = 1024; // 数据纹理固定宽度\n    this.rowCount = 1;\n    this.cellLength = 0;\n    this.cellProperties = [];\n    this.cacheStyleProperties = {\n      opacity: undefined,\n      strokeOpacity: undefined,\n      strokeWidth: undefined,\n      stroke: undefined,\n      offsets: undefined,\n    };\n    this.stylePropertyesExist = {\n      hasOpacity: 0,\n      hasStrokeOpacity: 0,\n      hasStrokeWidth: 0,\n      hasStroke: 0,\n      hasOffsets: 0,\n    };\n    this.dataTextureTest = this.layerService.getOESTextureFloat();\n    // 只有在不支持数据纹理的情况下进行赋值\n    if (!this.dataTextureTest) {\n      this.dataTexture = this.createTexture2D({\n        data: new Uint8ClampedArray(4),\n        mag: gl.NEAREST,\n        min: gl.NEAREST,\n        width: 1,\n        height: 1,\n      });\n    }\n  }\n\n  // style datatexture mapping\n\n  /**\n   * 清除上一次的计算结果 - 全量清除\n   */\n  public clearLastCalRes() {\n    this.cellProperties = []; // 清空上一次计算的需要进行数据映射的属性集合\n    this.cellLength = 0; // 清空上一次计算的 cell 的长度\n    this.stylePropertyesExist = {\n      // 全量清空上一次是否需要对 style 属性进行数据映射的判断\n      hasOpacity: 0,\n      hasStrokeOpacity: 0,\n      hasStrokeWidth: 0,\n      hasStroke: 0,\n      hasOffsets: 0,\n    };\n  }\n\n  public getCellTypeLayout() {\n    if (this.dataTextureTest) {\n      return [\n        this.rowCount, // 数据纹理有几行\n        this.DATA_TEXTURE_WIDTH, // 数据纹理有几列\n        0.0,\n        0.0,\n        this.stylePropertyesExist.hasOpacity, // cell 中是否存在 opacity\n        this.stylePropertyesExist.hasStrokeOpacity, // cell 中是否存在 strokeOpacity\n        this.stylePropertyesExist.hasStrokeWidth, // cell 中是否存在 strokeWidth\n        this.stylePropertyesExist.hasStroke, // cell 中是否存在 stroke\n        this.stylePropertyesExist.hasOffsets, // cell 中是否存在 offsets\n        0.0,\n        0.0,\n        0.0,\n        0.0,\n        0.0,\n        0.0,\n        1.0,\n      ];\n    } else {\n      return [\n        1.0, // 数据纹理有几行\n        1.0, // 数据纹理有几列\n        0.0,\n        0.0,\n        0.0, // cell 中是否存在 opacity\n        0.0, // cell 中是否存在 strokeOpacity\n        0.0, // cell 中是否存在 strokeWidth\n        0.0, // cell 中是否存在 stroke\n        0.0, // cell 中是否存在 offsets\n        0.0,\n        0.0,\n        0.0,\n        0.0,\n        0.0,\n        0.0,\n        -1.0,\n      ];\n    }\n  }\n\n  /**\n   * 判断数据纹理是否需要重新计算 - 根据传入的值进行判断\n   * @param options\n   * @returns\n   */\n  public dataTextureNeedUpdate(options: {\n    opacity?: styleSingle;\n    strokeOpacity?: styleSingle;\n    strokeWidth?: styleSingle;\n    stroke?: styleColor;\n    offsets?: styleOffset;\n    textOffset?: styleOffset;\n  }): boolean {\n    let isUpdate = false;\n    if (!isEqual(options.opacity, this.cacheStyleProperties.opacity)) {\n      isUpdate = true;\n      this.cacheStyleProperties.opacity = options.opacity;\n    }\n    if (\n      !isEqual(options.strokeOpacity, this.cacheStyleProperties.strokeOpacity)\n    ) {\n      isUpdate = true;\n      this.cacheStyleProperties.strokeOpacity = options.strokeOpacity;\n    }\n    if (!isEqual(options.strokeWidth, this.cacheStyleProperties.strokeWidth)) {\n      isUpdate = true;\n      this.cacheStyleProperties.strokeWidth = options.strokeWidth;\n    }\n    if (!isEqual(options.stroke, this.cacheStyleProperties.stroke)) {\n      isUpdate = true;\n      this.cacheStyleProperties.stroke = options.stroke;\n    }\n    if (!isEqual(options.offsets, this.cacheStyleProperties.offsets)) {\n      isUpdate = true;\n      this.cacheStyleProperties.offsets = options.offsets;\n    }\n    if (this.dataTexture === undefined) {\n      isUpdate = true;\n    }\n    return isUpdate;\n  }\n  /**\n   * 判断当前的样式中哪些是需要进行数据映射的，哪些是常量，同时计算用于构建数据纹理的一些中间变量\n   * @param options\n   */\n  public judgeStyleAttributes(options: {\n    opacity?: styleSingle;\n    strokeOpacity?: styleSingle;\n    strokeWidth?: styleSingle;\n    stroke?: styleColor;\n    offsets?: styleOffset;\n  }) {\n    this.clearLastCalRes(); // 清除上一次的计算结果 - 全量清除\n\n    if (options.opacity !== undefined && !isNumber(options.opacity)) {\n      // 数据映射\n      this.cellProperties.push({ attr: 'opacity', count: 1 });\n      this.stylePropertyesExist.hasOpacity = 1;\n      this.cellLength += 1;\n    }\n\n    if (\n      options.strokeOpacity !== undefined &&\n      !isNumber(options.strokeOpacity)\n    ) {\n      // 数据映射\n      this.cellProperties.push({ attr: 'strokeOpacity', count: 1 });\n      this.stylePropertyesExist.hasStrokeOpacity = 1;\n      this.cellLength += 1;\n    }\n\n    if (options.strokeWidth !== undefined && !isNumber(options.strokeWidth)) {\n      // 数据映射\n      this.cellProperties.push({ attr: 'strokeWidth', count: 1 });\n      this.stylePropertyesExist.hasStrokeWidth = 1;\n      this.cellLength += 1;\n    }\n\n    if (options.stroke !== undefined && !this.isStaticColor(options.stroke)) {\n      // 数据映射\n      this.cellProperties.push({ attr: 'stroke', count: 4 });\n      this.stylePropertyesExist.hasStroke = 1;\n      this.cellLength += 4;\n    }\n\n    if (\n      options.offsets !== undefined &&\n      !this.isOffsetStatic(options.offsets)\n    ) {\n      // 数据映射\n      this.cellProperties.push({ attr: 'offsets', count: 2 });\n      this.stylePropertyesExist.hasOffsets = 1;\n      this.cellLength += 2;\n    }\n    // console.log('this.cellLength', this.cellLength)\n  }\n\n  /**\n   * 判断变量 stroke 是否是常量值\n   * @param stroke\n   * @returns\n   */\n  public isStaticColor(stroke: styleColor): boolean {\n    if (isString(stroke)) {\n      if (color(stroke)) {\n        return true;\n      } else {\n        return false;\n      }\n    }\n    return false;\n  }\n  /**\n   * 获取 stroke 颜色并做兼容处理\n   * @param stroke\n   * @returns\n   */\n  public getStrokeColor(stroke: styleColor) {\n    if (this.isStaticColor(stroke)) {\n      const strokeColor = rgb2arr(stroke as string);\n      strokeColor[0] = strokeColor[0] ? strokeColor[0] : 0;\n      strokeColor[1] = strokeColor[1] ? strokeColor[1] : 0;\n      strokeColor[2] = strokeColor[2] ? strokeColor[2] : 0;\n      strokeColor[3] = strokeColor[3] ? strokeColor[3] : 0;\n      return strokeColor;\n    } else {\n      return [0, 0, 0, 0];\n    }\n  }\n\n  /**\n   * 判断 offsets 是否是常量\n   * @param offsets\n   * @returns\n   */\n  public isOffsetStatic(offsets: styleOffset) {\n    if (\n      isArray(offsets) &&\n      offsets.length === 2 &&\n      isNumber(offsets[0]) &&\n      isNumber(offsets[1])\n    ) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  /**\n   * 补空位\n   * @param d\n   * @param count\n   */\n  public patchMod(d: number[], count: number) {\n    for (let i = 0; i < count; i++) {\n      d.push(-1);\n    }\n  }\n\n  /**\n   * 根据映射的数据字段往推入数据\n   * @param d\n   * @param cellData\n   * @param cellPropertiesLayouts\n   */\n  public patchData(\n    d: number[],\n    cellData: IEncodeFeature,\n    cellPropertiesLayouts: ICellProperty[],\n  ) {\n    for (const layout of cellPropertiesLayouts) {\n      const { attr, count } = layout;\n\n      const value = cellData[attr];\n      if (value) {\n        // 数据中存在该属性\n        if (attr === 'stroke') {\n          d.push(...rgb2arr(value));\n        } else if (attr === 'offsets') {\n          if (this.isOffsetStatic(value)) {\n            d.push(-value[0], value[1]);\n          } else {\n            d.push(0, 0);\n          }\n        } else {\n          d.push(isNumber(value) ? value : 1.0);\n        }\n      } else {\n        // 若不存在时则补位\n        this.patchMod(d, count);\n      }\n    }\n  }\n\n  /**\n   * 计算推入数据纹理的数据\n   * @param cellLength\n   * @param encodeData\n   * @param cellPropertiesLayouts\n   * @returns\n   */\n  public calDataFrame(\n    cellLength: number,\n    encodeData: IEncodeFeature[],\n    cellPropertiesLayouts: ICellProperty[],\n  ): IDataTextureFrame {\n    const encodeDatalength = encodeData.length;\n    const rowCount = Math.ceil(\n      (encodeDatalength * cellLength) / this.DATA_TEXTURE_WIDTH,\n    ); // 有多少行\n\n    const totalLength = rowCount * this.DATA_TEXTURE_WIDTH;\n    const d: number[] = [];\n    for (let i = 0; i < encodeDatalength; i++) {\n      // 根据 encodeData 数据推入数据\n      const cellData = encodeData[i];\n      this.patchData(d, cellData, cellPropertiesLayouts);\n    }\n    for (let i = d.length; i < totalLength; i++) {\n      // 每行不足的部分用 -1 补足（数据纹理时 width * height 的矩形数据集合）\n      d.push(-1);\n    }\n    // console.log('data', d)\n    return { data: d, width: this.DATA_TEXTURE_WIDTH, height: rowCount };\n  }\n\n  // style datatexture mapping\n\n  public getBlend(): IBlendOptions {\n    const { blend = 'normal' } = this.layer.getLayerConfig();\n    return BlendTypes[BlendType[blend]] as IBlendOptions;\n  }\n  public getDefaultStyle(): unknown {\n    return {};\n  }\n  public getUninforms(): IModelUniform {\n    throw new Error('Method not implemented.');\n  }\n\n  public getAnimateUniforms(): IModelUniform {\n    return {};\n  }\n\n  public needUpdate(): boolean {\n    return false;\n  }\n  public buildModels(): IModel[] {\n    throw new Error('Method not implemented.');\n  }\n  public initModels(): IModel[] {\n    throw new Error('Method not implemented.');\n  }\n  public clearModels() {\n    return;\n  }\n  public getAttribute(): {\n    attributes: {\n      [attributeName: string]: IAttribute;\n    };\n    elements: IElements;\n  } {\n    throw new Error('Method not implemented.');\n  }\n  public render() {\n    throw new Error('Method not implemented.');\n  }\n  protected registerBuiltinAttributes() {\n    throw new Error('Method not implemented.');\n  }\n  protected animateOption2Array(option: IAnimateOption): number[] {\n    return [\n      option.enable ? 0 : 1.0,\n      option.duration || 4.0,\n      option.interval || 0.2,\n      option.trailLength || 0.1,\n    ];\n  }\n  protected startModelAnimate() {\n    const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;\n    if (animateOption.enable) {\n      this.layer.setAnimateStartTime();\n    }\n  }\n}\n"]},"metadata":{},"sourceType":"module"}