{"ast":null,"code":"import _toConsumableArray from \"@babel/runtime/helpers/toConsumableArray\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _dec, _class;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { generateColorRamp } from '@antv/l7-utils';\nimport { mat4 } from 'gl-matrix';\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\nimport BaseModel from '../../core/BaseModel';\nimport { HeatmapTriangulation } from '../../core/triangulation';\nvar heatmap3DFrag = \"uniform sampler2D u_texture;\\nuniform sampler2D u_colorTexture;\\nuniform float u_opacity;\\nvarying vec2 v_texCoord;\\nvarying float v_intensity;\\n\\nvoid main(){\\n   \\n     float intensity = texture2D(u_texture, v_texCoord).r;\\n    vec4 color = texture2D(u_colorTexture,vec2(intensity, 0));\\n    gl_FragColor = color;\\n    // gl_FragColor.a = color.a * smoothstep(0.1,0.2,intensity)* u_opacity;\\n     gl_FragColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\\n}\\n\";\nvar heatmap3DVert = \"precision highp float;\\nattribute vec3 a_Position;\\nattribute vec2 a_Uv;\\nuniform sampler2D u_texture;\\nvarying vec2 v_texCoord;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_InverseViewProjectionMatrix;\\nuniform mat4 u_ViewProjectionMatrixUncentered;\\nvarying float v_intensity;\\n\\n\\nvec2 toBezier(float t, vec2 P0, vec2 P1, vec2 P2, vec2 P3) {\\n    float t2 = t * t;\\n    float one_minus_t = 1.0 - t;\\n    float one_minus_t2 = one_minus_t * one_minus_t;\\n    return (P0 * one_minus_t2 * one_minus_t + P1 * 3.0 * t * one_minus_t2 + P2 * 3.0 * t2 * one_minus_t + P3 * t2 * t);\\n}\\nvec2 toBezier(float t, vec4 p){\\n    return toBezier(t, vec2(0.0, 0.0), vec2(p.x, p.y), vec2(p.z, p.w), vec2(1.0, 1.0));\\n}\\n#pragma include \\\"projection\\\"\\nvoid main() {\\n  v_texCoord = a_Uv;\\n\\n  vec2 pos = a_Uv * vec2(2.0) - vec2(1.0); // \\u5C06\\u539F\\u672C 0 -> 1 \\u7684 uv \\u8F6C\\u6362\\u4E3A -1 -> 1 \\u7684\\u6807\\u51C6\\u5750\\u6807\\u7A7A\\u95F4\\uFF08NDC\\uFF09\\n\\n  vec4 p1 = vec4(pos, 0.0, 1.0); // x/y \\u5E73\\u9762\\u4E0A\\u7684\\u70B9\\uFF08z == 0\\uFF09\\u53EF\\u4EE5\\u8BA4\\u4E3A\\u662F\\u4E09\\u7EF4\\u4E0A\\u7684\\u70B9\\u88AB\\u6295\\u5F71\\u5230\\u5E73\\u9762\\u540E\\u7684\\u70B9\\n\\tvec4 p2 = vec4(pos, 1.0, 1.0); // \\u5E73\\u884C\\u4E8Ex/y\\u5E73\\u9762\\u3001z==1 \\u7684\\u5E73\\u9762\\u4E0A\\u7684\\u70B9\\n\\n\\tvec4 inverseP1 = u_InverseViewProjectionMatrix * p1; // \\u6839\\u636E\\u89C6\\u56FE\\u6295\\u5F71\\u77E9\\u9635\\u7684\\u9006\\u77E9\\u9635\\u5E73\\u9762\\u4E0A\\u7684\\u53CD\\u7B97\\u51FA\\u4E09\\u7EF4\\u7A7A\\u95F4\\u4E2D\\u7684\\u70B9\\uFF08p1\\u5E73\\u9762\\u4E0A\\u7684\\u70B9\\uFF09\\n\\tvec4 inverseP2 = u_InverseViewProjectionMatrix * p2;\\n\\n  inverseP1 = inverseP1 / inverseP1.w; // \\u5F52\\u4E00\\u5316\\u64CD\\u4F5C\\uFF08\\u5F52\\u4E00\\u5316\\u540E\\u4E3A\\u4E16\\u754C\\u5750\\u6807\\uFF09\\n\\tinverseP2 = inverseP2 / inverseP2.w;\\n\\n\\tfloat zPos = (0.0 - inverseP1.z) / (inverseP2.z - inverseP1.z); // ??\\n\\tvec4 position = inverseP1 + zPos * (inverseP2 - inverseP1);\\n\\n  vec4 b= vec4(0.5000, 0.0, 1.0, 0.5000);\\n  float fh;\\n\\n  v_intensity = texture2D(u_texture, v_texCoord).r;\\n  fh = toBezier(v_intensity, b).y;\\n  gl_Position = u_ViewProjectionMatrixUncentered * vec4(position.xy, fh * project_pixel(50.), 1.0);\\n \\n}\\n\";\nvar heatmapColorFrag = \"uniform sampler2D u_texture;\\nuniform sampler2D u_colorTexture;\\nuniform float u_opacity;\\nvarying vec2 v_texCoord;\\nvarying float v_intensity;\\n\\nvoid main(){\\n     float intensity = texture2D(u_texture, v_texCoord).r;\\n    vec4 color = texture2D(u_colorTexture,vec2(intensity, 0));\\n    gl_FragColor =color;\\n    gl_FragColor.a = color.a * smoothstep(0.,0.1,intensity) * u_opacity;\\n\\n}\\n\";\nvar heatmapFrag = \"precision highp float;\\nuniform float u_intensity;\\nvarying float v_weight;\\nvarying vec2 v_extrude;\\n#define GAUSS_COEF  0.3989422804014327\\nvoid main(){\\n    float d = -0.5 * 3.0 * 3.0 * dot(v_extrude, v_extrude);\\n    float val = v_weight * u_intensity * GAUSS_COEF * exp(d);\\n    gl_FragColor = vec4(val, 1., 1., 1.);\\n}\\n\";\nvar heatmapVert = \"precision highp float;\\nattribute vec3 a_Position;\\nattribute float a_Size;\\nattribute vec2 a_Dir;\\nuniform float u_intensity;\\nuniform float u_radius;\\nvarying vec2 v_extrude;\\nvarying float v_weight;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_Mvp;\\n\\n#define GAUSS_COEF  0.3989422804014327\\n\\n#pragma include \\\"projection\\\"\\n\\nvoid main(){\\n    v_weight = a_Size;\\n    float ZERO = 1.0 / 255.0 / 16.0;\\n    float extrude_x = a_Dir.x * 2.0 -1.0;\\n    float extrude_y = a_Dir.y * 2.0 -1.0;\\n    vec2 extrude_dir = normalize(vec2(extrude_x,extrude_y));\\n    float S = sqrt(-2.0 * log(ZERO / a_Size / u_intensity / GAUSS_COEF)) / 3.0;\\n    v_extrude = extrude_dir * S;\\n\\n    vec2 offset = project_pixel(v_extrude * u_radius);\\n    vec4 project_pos = project_position(vec4(a_Position.xy, 0.0, 1.0));\\n\\n    // gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\\n\\n    if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\n        gl_Position = u_Mvp * (vec4(project_pos.xy + offset, 0.0, 1.0));\\n    } else {\\n        gl_Position = project_common_position_to_clipspace(vec4(project_pos.xy + offset, 0.0, 1.0));\\n    }\\n}\\n\";\nvar heatmapColorVert = \"precision highp float;\\nattribute vec3 a_Position;\\nattribute vec2 a_Uv;\\nuniform sampler2D u_texture;\\nvarying vec2 v_texCoord;\\nvarying float v_intensity;\\nvoid main() {\\n  v_texCoord = a_Uv;\\n  v_intensity = texture2D(u_texture, v_texCoord).r;\\n  gl_Position = vec4(a_Position.xy, 0, 1.);\\n}\\n\";\nimport { heatMap3DTriangulation } from '../triangulation';\nvar HeatMapModel = (_dec = injectable(), _dec(_class = function (_BaseModel) {\n  _inherits(HeatMapModel, _BaseModel);\n\n  var _super = _createSuper(HeatMapModel);\n\n  function HeatMapModel() {\n    var _this;\n\n    _classCallCheck(this, HeatMapModel);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _defineProperty(_assertThisInitialized(_this), \"texture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"colorTexture\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"heatmapFramerBuffer\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"intensityModel\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"colorModel\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"shapeType\", void 0);\n\n    return _this;\n  }\n\n  _createClass(HeatMapModel, [{\n    key: \"render\",\n    value: function render() {\n      var _this2 = this;\n\n      var _this$rendererService = this.rendererService,\n          clear = _this$rendererService.clear,\n          useFramebuffer = _this$rendererService.useFramebuffer;\n      useFramebuffer(this.heatmapFramerBuffer, function () {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: _this2.heatmapFramerBuffer\n        });\n\n        _this2.drawIntensityMode();\n      });\n\n      if (this.layer.styleNeedUpdate) {\n        this.updateColorTexture();\n      }\n\n      this.shapeType === 'heatmap' ? this.drawColorMode() : this.draw3DHeatMap();\n    }\n  }, {\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      throw new Error('Method not implemented.');\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      var _shapeAttr$scale;\n\n      var _this$rendererService2 = this.rendererService,\n          createFramebuffer = _this$rendererService2.createFramebuffer,\n          clear = _this$rendererService2.clear,\n          getViewportSize = _this$rendererService2.getViewportSize,\n          createTexture2D = _this$rendererService2.createTexture2D,\n          useFramebuffer = _this$rendererService2.useFramebuffer;\n      var shapeAttr = this.styleAttributeService.getLayerStyleAttribute('shape');\n      var shapeType = (shapeAttr === null || shapeAttr === void 0 ? void 0 : (_shapeAttr$scale = shapeAttr.scale) === null || _shapeAttr$scale === void 0 ? void 0 : _shapeAttr$scale.field) || 'heatmap';\n      this.shapeType = shapeType;\n      this.intensityModel = this.buildHeatMapIntensity();\n      this.colorModel = shapeType === 'heatmap' ? this.buildHeatmapColor() : this.build3dHeatMap();\n\n      var _getViewportSize = getViewportSize(),\n          width = _getViewportSize.width,\n          height = _getViewportSize.height;\n\n      this.heatmapFramerBuffer = createFramebuffer({\n        color: createTexture2D({\n          width: Math.floor(width / 4),\n          height: Math.floor(height / 4),\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE,\n          min: gl.LINEAR,\n          mag: gl.LINEAR\n        }),\n        depth: false\n      });\n      this.updateColorTexture();\n      return [this.intensityModel, this.colorModel];\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      return this.initModels();\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'dir',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Dir',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 2,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4]];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var _feature$size = feature.size,\n                size = _feature$size === void 0 ? 1 : _feature$size;\n            return [size];\n          }\n        }\n      });\n    }\n  }, {\n    key: \"buildHeatMapIntensity\",\n    value: function buildHeatMapIntensity() {\n      return this.layer.buildLayerModel({\n        moduleName: 'heatmapintensity',\n        vertexShader: heatmapVert,\n        fragmentShader: heatmapFrag,\n        triangulation: HeatmapTriangulation,\n        depth: {\n          enable: false\n        },\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.ONE,\n            srcAlpha: 1,\n            dstRGB: gl.ONE,\n            dstAlpha: 1\n          }\n        }\n      });\n    }\n  }, {\n    key: \"buildHeatmapColor\",\n    value: function buildHeatmapColor() {\n      this.shaderModuleService.registerModule('heatmapColor', {\n        vs: heatmapColorVert,\n        fs: heatmapColorFrag\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule('heatmapColor'),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          uniforms = _this$shaderModuleSer.uniforms;\n\n      var _this$rendererService3 = this.rendererService,\n          createAttribute = _this$rendererService3.createAttribute,\n          createElements = _this$rendererService3.createElements,\n          createBuffer = _this$rendererService3.createBuffer,\n          createModel = _this$rendererService3.createModel;\n      return createModel({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: [-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],\n              type: gl.FLOAT\n            }),\n            size: 3\n          }),\n          a_Uv: createAttribute({\n            buffer: createBuffer({\n              data: [0, 1, 1, 1, 0, 0, 1, 0],\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        uniforms: _objectSpread({}, uniforms),\n        depth: {\n          enable: false\n        },\n        blend: this.getBlend(),\n        count: 6,\n        elements: createElements({\n          data: [0, 2, 1, 2, 3, 1],\n          type: gl.UNSIGNED_INT,\n          count: 6\n        })\n      });\n    }\n  }, {\n    key: \"drawIntensityMode\",\n    value: function drawIntensityMode() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          _ref$intensity = _ref.intensity,\n          intensity = _ref$intensity === void 0 ? 10 : _ref$intensity,\n          _ref$radius = _ref.radius,\n          radius = _ref$radius === void 0 ? 5 : _ref$radius;\n\n      this.intensityModel.draw({\n        uniforms: {\n          u_opacity: opacity || 1.0,\n          u_radius: radius,\n          u_intensity: intensity\n        }\n      });\n    }\n  }, {\n    key: \"drawColorMode\",\n    value: function drawColorMode() {\n      var _ref2 = this.layer.getLayerConfig(),\n          opacity = _ref2.opacity;\n\n      this.colorModel.draw({\n        uniforms: {\n          u_opacity: opacity || 1.0,\n          u_colorTexture: this.colorTexture,\n          u_texture: this.heatmapFramerBuffer\n        }\n      });\n    }\n  }, {\n    key: \"draw3DHeatMap\",\n    value: function draw3DHeatMap() {\n      var _ref3 = this.layer.getLayerConfig(),\n          opacity = _ref3.opacity;\n\n      var invert = mat4.create();\n      mat4.invert(invert, this.cameraService.getViewProjectionMatrixUncentered());\n      this.colorModel.draw({\n        uniforms: {\n          u_opacity: opacity || 1.0,\n          u_colorTexture: this.colorTexture,\n          u_texture: this.heatmapFramerBuffer,\n          u_ViewProjectionMatrixUncentered: this.cameraService.getViewProjectionMatrixUncentered(),\n          u_InverseViewProjectionMatrix: _toConsumableArray(invert)\n        }\n      });\n    }\n  }, {\n    key: \"build3dHeatMap\",\n    value: function build3dHeatMap() {\n      var getViewportSize = this.rendererService.getViewportSize;\n\n      var _getViewportSize2 = getViewportSize(),\n          width = _getViewportSize2.width,\n          height = _getViewportSize2.height;\n\n      var triangulation = heatMap3DTriangulation(width / 4.0, height / 4.0);\n      this.shaderModuleService.registerModule('heatmap3dColor', {\n        vs: heatmap3DVert,\n        fs: heatmap3DFrag\n      });\n\n      var _this$shaderModuleSer2 = this.shaderModuleService.getModule('heatmap3dColor'),\n          vs = _this$shaderModuleSer2.vs,\n          fs = _this$shaderModuleSer2.fs,\n          uniforms = _this$shaderModuleSer2.uniforms;\n\n      var _this$rendererService4 = this.rendererService,\n          createAttribute = _this$rendererService4.createAttribute,\n          createElements = _this$rendererService4.createElements,\n          createBuffer = _this$rendererService4.createBuffer,\n          createModel = _this$rendererService4.createModel;\n      return createModel({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: triangulation.vertices,\n              type: gl.FLOAT\n            }),\n            size: 3\n          }),\n          a_Uv: createAttribute({\n            buffer: createBuffer({\n              data: triangulation.uvs,\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        primitive: gl.TRIANGLES,\n        uniforms: _objectSpread({}, uniforms),\n        depth: {\n          enable: true\n        },\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.SRC_ALPHA,\n            srcAlpha: 1,\n            dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n            dstAlpha: 1\n          }\n        },\n        elements: createElements({\n          data: triangulation.indices,\n          type: gl.UNSIGNED_INT,\n          count: triangulation.indices.length\n        })\n      });\n    }\n  }, {\n    key: \"updateStyle\",\n    value: function updateStyle() {\n      this.updateColorTexture();\n    }\n  }, {\n    key: \"updateColorTexture\",\n    value: function updateColorTexture() {\n      var createTexture2D = this.rendererService.createTexture2D;\n\n      if (this.texture) {\n        this.texture.destroy();\n      }\n\n      var _ref4 = this.layer.getLayerConfig(),\n          rampColors = _ref4.rampColors;\n\n      var imageData = generateColorRamp(rampColors);\n      this.colorTexture = createTexture2D({\n        data: new Uint8Array(imageData.data),\n        width: imageData.width,\n        height: imageData.height,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n        min: gl.NEAREST,\n        mag: gl.NEAREST,\n        flipY: false\n      });\n    }\n  }]);\n\n  return HeatMapModel;\n}(BaseModel)) || _class);\nexport { HeatMapModel as default };","map":{"version":3,"sources":["../../../src/heatmap/models/heatmap.ts"],"names":["injectable","HeatMapModel","BaseModel","clear","useFramebuffer","color","depth","stencil","framebuffer","heatmapFramerBuffer","createFramebuffer","getViewportSize","createTexture2D","shapeAttr","shapeType","width","height","Math","wrapS","gl","wrapT","min","mag","LINEAR","name","type","AttributeType","descriptor","buffer","usage","data","FLOAT","size","update","vertex","feature","moduleName","vertexShader","fragmentShader","triangulation","enable","blend","func","srcRGB","srcAlpha","dstRGB","dstAlpha","vs","fs","heatmapColorFrag","uniforms","createAttribute","createElements","createBuffer","createModel","attributes","a_Position","a_Uv","count","elements","opacity","intensity","radius","u_opacity","u_radius","u_intensity","u_colorTexture","u_texture","invert","mat4","u_ViewProjectionMatrixUncentered","u_InverseViewProjectionMatrix","heatMap3DTriangulation","heatmap3DFrag","primitive","length","rampColors","imageData","generateColorRamp","flipY"],"mappings":"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","sourcesContent":["import {\n  AttributeType,\n  gl,\n  IEncodeFeature,\n  IFramebuffer,\n  IModel,\n  IModelUniform,\n  ITexture2D,\n} from '@antv/l7-core';\nimport { generateColorRamp, IColorRamp } from '@antv/l7-utils';\nimport { mat4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\nimport BaseModel from '../../core/BaseModel';\nimport { HeatmapTriangulation } from '../../core/triangulation';\nimport heatmap3DFrag from '../shaders/heatmap_3d_frag.glsl';\nimport heatmap3DVert from '../shaders/heatmap_3d_vert.glsl';\nimport heatmapColorFrag from '../shaders/heatmap_frag.glsl';\nimport heatmapFrag from '../shaders/heatmap_framebuffer_frag.glsl';\nimport heatmapVert from '../shaders/heatmap_framebuffer_vert.glsl';\nimport heatmapColorVert from '../shaders/heatmap_vert.glsl';\nimport { heatMap3DTriangulation } from '../triangulation';\ninterface IHeatMapLayerStyleOptions {\n  opacity: number;\n  intensity: number;\n  radius: number;\n  angle: number;\n  rampColors: IColorRamp;\n}\n@injectable()\nexport default class HeatMapModel extends BaseModel {\n  protected texture: ITexture2D;\n  protected colorTexture: ITexture2D;\n  protected heatmapFramerBuffer: IFramebuffer;\n  private intensityModel: IModel;\n  private colorModel: IModel;\n  private shapeType: string;\n\n  public render() {\n    const { clear, useFramebuffer } = this.rendererService;\n    useFramebuffer(this.heatmapFramerBuffer, () => {\n      clear({\n        color: [0, 0, 0, 0],\n        depth: 1,\n        stencil: 0,\n        framebuffer: this.heatmapFramerBuffer,\n      });\n      this.drawIntensityMode();\n    });\n    if (this.layer.styleNeedUpdate) {\n      this.updateColorTexture();\n    }\n    this.shapeType === 'heatmap' ? this.drawColorMode() : this.draw3DHeatMap();\n  }\n\n  public getUninforms(): IModelUniform {\n    throw new Error('Method not implemented.');\n  }\n\n  public initModels(): IModel[] {\n    const {\n      createFramebuffer,\n      clear,\n      getViewportSize,\n      createTexture2D,\n      useFramebuffer,\n    } = this.rendererService;\n    const shapeAttr = this.styleAttributeService.getLayerStyleAttribute(\n      'shape',\n    );\n    const shapeType = shapeAttr?.scale?.field || 'heatmap';\n    this.shapeType = shapeType as string;\n    // 生成热力图密度图\n    this.intensityModel = this.buildHeatMapIntensity();\n    // 渲染到屏幕\n    this.colorModel =\n      shapeType === 'heatmap'\n        ? this.buildHeatmapColor() // 2D\n        : this.build3dHeatMap(); // 3D\n\n    const { width, height } = getViewportSize();\n\n    // 初始化密度图纹理\n    this.heatmapFramerBuffer = createFramebuffer({\n      color: createTexture2D({\n        width: Math.floor(width / 4),\n        height: Math.floor(height / 4),\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n        min: gl.LINEAR,\n        mag: gl.LINEAR,\n      }),\n      depth: false,\n    });\n\n    this.updateColorTexture();\n\n    return [this.intensityModel, this.colorModel];\n  }\n\n  public buildModels(): IModel[] {\n    return this.initModels();\n  }\n\n  protected registerBuiltinAttributes() {\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'dir',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Dir',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 2,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          return [vertex[3], vertex[4]];\n        },\n      },\n    });\n\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { size = 1 } = feature;\n          return [size as number];\n        },\n      },\n    });\n  }\n  private buildHeatMapIntensity(): IModel {\n    return this.layer.buildLayerModel({\n      moduleName: 'heatmapintensity',\n      vertexShader: heatmapVert,\n      fragmentShader: heatmapFrag,\n      triangulation: HeatmapTriangulation,\n      depth: {\n        enable: false,\n      },\n      blend: {\n        enable: true,\n        func: {\n          srcRGB: gl.ONE,\n          srcAlpha: 1,\n          dstRGB: gl.ONE,\n          dstAlpha: 1,\n        },\n      },\n    });\n  }\n\n  private buildHeatmapColor(): IModel {\n    this.shaderModuleService.registerModule('heatmapColor', {\n      vs: heatmapColorVert,\n      fs: heatmapColorFrag,\n    });\n\n    const { vs, fs, uniforms } = this.shaderModuleService.getModule(\n      'heatmapColor',\n    );\n    const {\n      createAttribute,\n      createElements,\n      createBuffer,\n      createModel,\n    } = this.rendererService;\n    return createModel({\n      vs,\n      fs,\n      attributes: {\n        a_Position: createAttribute({\n          buffer: createBuffer({\n            data: [-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0],\n            type: gl.FLOAT,\n          }),\n          size: 3,\n        }),\n        a_Uv: createAttribute({\n          buffer: createBuffer({\n            data: [0, 1, 1, 1, 0, 0, 1, 0],\n            type: gl.FLOAT,\n          }),\n          size: 2,\n        }),\n      },\n      uniforms: {\n        ...uniforms,\n      },\n      depth: {\n        enable: false,\n      },\n      blend: this.getBlend(),\n      count: 6,\n      elements: createElements({\n        data: [0, 2, 1, 2, 3, 1],\n        type: gl.UNSIGNED_INT,\n        count: 6,\n      }),\n    });\n  }\n\n  private drawIntensityMode() {\n    const {\n      opacity,\n      intensity = 10,\n      radius = 5,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n    this.intensityModel.draw({\n      uniforms: {\n        u_opacity: opacity || 1.0,\n        u_radius: radius,\n        u_intensity: intensity,\n      },\n    });\n  }\n\n  private drawColorMode() {\n    const {\n      opacity,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n    this.colorModel.draw({\n      uniforms: {\n        u_opacity: opacity || 1.0,\n        u_colorTexture: this.colorTexture,\n        u_texture: this.heatmapFramerBuffer,\n      },\n    });\n  }\n\n  private draw3DHeatMap() {\n    const {\n      opacity,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n\n    // const invert = mat4.invert(\n    //   mat4.create(),\n    //   mat4.fromValues(\n    //     // @ts-ignore\n    //     ...this.cameraService.getViewProjectionMatrixUncentered(),\n    //   ),\n    // ) as mat4;\n    const invert = mat4.create();\n    mat4.invert(\n      invert,\n      this.cameraService.getViewProjectionMatrixUncentered() as mat4,\n    );\n\n    this.colorModel.draw({\n      uniforms: {\n        u_opacity: opacity || 1.0,\n        u_colorTexture: this.colorTexture,\n        u_texture: this.heatmapFramerBuffer,\n        u_ViewProjectionMatrixUncentered: this.cameraService.getViewProjectionMatrixUncentered(),\n        u_InverseViewProjectionMatrix: [...invert],\n      },\n    });\n  }\n  private build3dHeatMap() {\n    const { getViewportSize } = this.rendererService;\n    const { width, height } = getViewportSize();\n    const triangulation = heatMap3DTriangulation(width / 4.0, height / 4.0);\n    this.shaderModuleService.registerModule('heatmap3dColor', {\n      vs: heatmap3DVert,\n      fs: heatmap3DFrag,\n    });\n\n    const { vs, fs, uniforms } = this.shaderModuleService.getModule(\n      'heatmap3dColor',\n    );\n    const {\n      createAttribute,\n      createElements,\n      createBuffer,\n      createModel,\n    } = this.rendererService;\n    return createModel({\n      vs,\n      fs,\n      attributes: {\n        a_Position: createAttribute({\n          buffer: createBuffer({\n            data: triangulation.vertices,\n            type: gl.FLOAT,\n          }),\n          size: 3,\n        }),\n        a_Uv: createAttribute({\n          buffer: createBuffer({\n            data: triangulation.uvs,\n            type: gl.FLOAT,\n          }),\n          size: 2,\n        }),\n      },\n      primitive: gl.TRIANGLES,\n      uniforms: {\n        ...uniforms,\n      },\n      depth: {\n        enable: true,\n      },\n      blend: {\n        enable: true,\n        func: {\n          srcRGB: gl.SRC_ALPHA,\n          srcAlpha: 1,\n          dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n          dstAlpha: 1,\n        },\n      },\n      elements: createElements({\n        data: triangulation.indices,\n        type: gl.UNSIGNED_INT,\n        count: triangulation.indices.length,\n      }),\n    });\n  }\n  private updateStyle() {\n    this.updateColorTexture();\n  }\n\n  private updateColorTexture() {\n    const { createTexture2D } = this.rendererService;\n    if (this.texture) {\n      this.texture.destroy();\n    }\n\n    const {\n      rampColors,\n    } = this.layer.getLayerConfig() as IHeatMapLayerStyleOptions;\n    const imageData = generateColorRamp(rampColors as IColorRamp);\n    this.colorTexture = createTexture2D({\n      data: new Uint8Array(imageData.data),\n      width: imageData.width,\n      height: imageData.height,\n      wrapS: gl.CLAMP_TO_EDGE,\n      wrapT: gl.CLAMP_TO_EDGE,\n      min: gl.NEAREST,\n      mag: gl.NEAREST,\n      flipY: false,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}