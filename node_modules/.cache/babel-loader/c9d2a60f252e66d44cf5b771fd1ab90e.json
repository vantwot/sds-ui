{"ast":null,"code":"import { clamp, squaredLength } from '../util';\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Curve } from '../curve';\nimport { Polyline } from '../polyline';\nimport { Rectangle } from '../rectangle';\nimport { Geometry } from '../geometry';\nimport { Close } from './close';\nimport { LineTo } from './lineto';\nimport { MoveTo } from './moveto';\nimport { CurveTo } from './curveto';\nimport { normalizePathData } from './normalize';\nimport * as Util from './util';\nexport class Path extends Geometry {\n  constructor(args) {\n    super();\n    this.PRECISION = 3;\n    this.segments = [];\n\n    if (Array.isArray(args)) {\n      if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n        let previousObj = null;\n        const arr = args;\n        arr.forEach((o, i) => {\n          if (i === 0) {\n            this.appendSegment(Path.createSegment('M', o.start));\n          }\n\n          if (previousObj != null && !previousObj.end.equals(o.start)) {\n            this.appendSegment(Path.createSegment('M', o.start));\n          }\n\n          if (Line.isLine(o)) {\n            this.appendSegment(Path.createSegment('L', o.end));\n          } else if (Curve.isCurve(o)) {\n            this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));\n          }\n\n          previousObj = o;\n        });\n      } else {\n        const arr = args;\n        arr.forEach(s => {\n          if (s.isSegment) {\n            this.appendSegment(s);\n          }\n        });\n      }\n    } else if (args != null) {\n      if (Line.isLine(args)) {\n        this.appendSegment(Path.createSegment('M', args.start));\n        this.appendSegment(Path.createSegment('L', args.end));\n      } else if (Curve.isCurve(args)) {\n        this.appendSegment(Path.createSegment('M', args.start));\n        this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));\n      } else if (Polyline.isPolyline(args)) {\n        if (args.points && args.points.length) {\n          args.points.forEach((point, index) => {\n            const segment = index === 0 ? Path.createSegment('M', point) : Path.createSegment('L', point);\n            this.appendSegment(segment);\n          });\n        }\n      } else if (args.isSegment) {\n        this.appendSegment(args);\n      }\n    }\n  }\n\n  get [Symbol.toStringTag]() {\n    return Path.toStringTag;\n  }\n\n  get start() {\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        return segment.start;\n      }\n    } // if no visible segment, return last segment end point\n\n\n    return segments[count - 1].end;\n  }\n\n  get end() {\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    for (let i = count - 1; i >= 0; i -= 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        return segment.end;\n      }\n    } // if no visible segment, return last segment end point\n\n\n    return segments[count - 1].end;\n  }\n\n  moveTo() {\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    return this.appendSegment(MoveTo.create.call(null, ...args));\n  }\n\n  lineTo() {\n    for (var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++) {\n      args[_key2] = arguments[_key2];\n    }\n\n    return this.appendSegment(LineTo.create.call(null, ...args));\n  }\n\n  curveTo() {\n    for (var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++) {\n      args[_key3] = arguments[_key3];\n    }\n\n    return this.appendSegment(CurveTo.create.call(null, ...args));\n  }\n\n  arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {\n    const start = this.end || new Point();\n    const points = typeof endX === 'number' ? Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) : Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);\n\n    if (points != null) {\n      for (let i = 0, ii = points.length; i < ii; i += 6) {\n        this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n      }\n    }\n\n    return this;\n  }\n\n  quadTo(x1, y1, x, y) {\n    const start = this.end || new Point();\n    const data = ['M', start.x, start.y];\n\n    if (typeof x1 === 'number') {\n      data.push('Q', x1, y1, x, y);\n    } else {\n      const p = y1;\n      data.push(`Q`, x1.x, x1.y, p.x, p.y);\n    }\n\n    const path = Path.parse(data.join(' '));\n    this.appendSegment(path.segments.slice(1));\n    return this;\n  }\n\n  close() {\n    return this.appendSegment(Close.create());\n  }\n\n  drawPoints(points) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const raw = Util.drawPoints(points, options);\n    const sub = Path.parse(raw);\n\n    if (sub && sub.segments) {\n      this.appendSegment(sub.segments);\n    }\n  }\n\n  bbox() {\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    let bbox;\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        const segmentBBox = segment.bbox();\n\n        if (segmentBBox != null) {\n          bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n        }\n      }\n    }\n\n    if (bbox != null) {\n      return bbox;\n    } // if the path has only invisible elements, return end point of last segment\n\n\n    const lastSegment = segments[count - 1];\n    return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);\n  }\n\n  appendSegment(seg) {\n    const count = this.segments.length;\n    let previousSegment = count !== 0 ? this.segments[count - 1] : null;\n    let currentSegment;\n    const nextSegment = null;\n\n    if (Array.isArray(seg)) {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.push(currentSegment);\n        previousSegment = currentSegment;\n      }\n    } else if (seg != null && seg.isSegment) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.push(currentSegment);\n    }\n\n    return this;\n  }\n\n  insertSegment(index, seg) {\n    const count = this.segments.length;\n\n    if (index < 0) {\n      index = count + index + 1; // eslint-disable-line\n    }\n\n    if (index > count || index < 0) {\n      throw new Error('Index out of range.');\n    }\n\n    let currentSegment;\n    let previousSegment = null;\n    let nextSegment = null;\n\n    if (count !== 0) {\n      if (index >= 1) {\n        previousSegment = this.segments[index - 1];\n        nextSegment = previousSegment.nextSegment;\n      } else {\n        previousSegment = null;\n        nextSegment = this.segments[0];\n      }\n    }\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.splice(index, 0, currentSegment);\n    } else {\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.splice(index + i, 0, currentSegment);\n        previousSegment = currentSegment;\n      }\n    }\n\n    return this;\n  }\n\n  removeSegment(index) {\n    const idx = this.fixIndex(index);\n    const removedSegment = this.segments.splice(idx, 1)[0];\n    const previousSegment = removedSegment.previousSegment;\n    const nextSegment = removedSegment.nextSegment; // link the previous and next segments together (if present)\n\n    if (previousSegment) {\n      previousSegment.nextSegment = nextSegment;\n    }\n\n    if (nextSegment) {\n      nextSegment.previousSegment = previousSegment;\n    }\n\n    if (removedSegment.isSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment);\n    }\n\n    return removedSegment;\n  }\n\n  replaceSegment(index, seg) {\n    const idx = this.fixIndex(index);\n    let currentSegment;\n    const replacedSegment = this.segments[idx];\n    let previousSegment = replacedSegment.previousSegment;\n    const nextSegment = replacedSegment.nextSegment;\n    let updateSubpathStart = replacedSegment.isSubpathStart;\n\n    if (!Array.isArray(seg)) {\n      currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n      this.segments.splice(idx, 1, currentSegment);\n\n      if (updateSubpathStart && currentSegment.isSubpathStart) {\n        // already updated by `prepareSegment`\n        updateSubpathStart = false;\n      }\n    } else {\n      this.segments.splice(index, 1);\n\n      for (let i = 0, ii = seg.length; i < ii; i += 1) {\n        const segment = seg[i];\n        currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n        this.segments.splice(index + i, 0, currentSegment);\n        previousSegment = currentSegment;\n\n        if (updateSubpathStart && currentSegment.isSubpathStart) {\n          updateSubpathStart = false;\n        }\n      }\n    }\n\n    if (updateSubpathStart && nextSegment) {\n      this.updateSubpathStartSegment(nextSegment);\n    }\n  }\n\n  getSegment(index) {\n    const idx = this.fixIndex(index);\n    return this.segments[idx];\n  }\n\n  fixIndex(index) {\n    const length = this.segments.length;\n\n    if (length === 0) {\n      throw new Error('Path has no segments.');\n    }\n\n    let i = index;\n\n    while (i < 0) {\n      i = length + i;\n    }\n\n    if (i >= length || i < 0) {\n      throw new Error('Index out of range.');\n    }\n\n    return i;\n  }\n\n  segmentAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.segmentIndexAt(ratio, options);\n\n    if (!index) {\n      return null;\n    }\n\n    return this.getSegment(index);\n  }\n\n  segmentAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const index = this.segmentIndexAtLength(length, options);\n    if (!index) return null;\n    return this.getSegment(index);\n  }\n\n  segmentIndexAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const rate = clamp(ratio, 0, 1);\n    const opt = this.getOptions(options);\n    const len = this.length(opt);\n    const length = len * rate;\n    return this.segmentIndexAtLength(length, opt);\n  }\n\n  segmentIndexAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const count = this.segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let memo = 0;\n    let lastVisibleIndex = null;\n\n    for (let i = 0; i < count; i += 1) {\n      const index = fromStart ? i : count - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const len = segment.length({\n        precision,\n        subdivisions\n      });\n\n      if (segment.isVisible) {\n        if (length <= memo + len) {\n          return index;\n        }\n\n        lastVisibleIndex = index;\n      }\n\n      memo += len;\n    } // If length requested is higher than the length of the path, return\n    // last visible segment index. If no visible segment, return null.\n\n\n    return lastVisibleIndex;\n  }\n\n  getSegmentSubdivisions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = [];\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segment.getSubdivisions({\n        precision\n      });\n      segmentSubdivisions.push(subdivisions);\n    }\n\n    return segmentSubdivisions;\n  }\n\n  updateSubpathStartSegment(segment) {\n    let previous = segment.previousSegment;\n    let current = segment;\n\n    while (current && !current.isSubpathStart) {\n      // assign previous segment's subpath start segment to this segment\n      if (previous != null) {\n        current.subpathStartSegment = previous.subpathStartSegment;\n      } else {\n        current.subpathStartSegment = null;\n      }\n\n      previous = current;\n      current = current.nextSegment;\n    }\n  }\n\n  prepareSegment(segment, previousSegment, nextSegment) {\n    segment.previousSegment = previousSegment;\n    segment.nextSegment = nextSegment;\n\n    if (previousSegment != null) {\n      previousSegment.nextSegment = segment;\n    }\n\n    if (nextSegment != null) {\n      nextSegment.previousSegment = segment;\n    }\n\n    let updateSubpathStart = segment;\n\n    if (segment.isSubpathStart) {\n      // move to\n      segment.subpathStartSegment = segment;\n      updateSubpathStart = nextSegment;\n    } // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n\n\n    if (updateSubpathStart != null) {\n      this.updateSubpathStartSegment(updateSubpathStart);\n    }\n\n    return segment;\n  }\n\n  closestPoint(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const t = this.closestPointT(p, options);\n\n    if (!t) {\n      return null;\n    }\n\n    return this.pointAtT(t);\n  }\n\n  closestPointLength(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const opts = this.getOptions(options);\n    const t = this.closestPointT(p, opts);\n\n    if (!t) {\n      return 0;\n    }\n\n    return this.lengthAtT(t, opts);\n  }\n\n  closestPointNormalizedLength(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const opts = this.getOptions(options);\n    const cpLength = this.closestPointLength(p, opts);\n\n    if (cpLength === 0) {\n      return 0;\n    }\n\n    const length = this.length(opts);\n\n    if (length === 0) {\n      return 0;\n    }\n\n    return cpLength / length;\n  }\n\n  closestPointT(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let closestPointT;\n    let minSquaredDistance = Infinity;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n\n      if (segment.isVisible) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions\n        });\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        const squaredDistance = squaredLength(segmentClosestPoint, p);\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointT = {\n            segmentIndex: i,\n            value: segmentClosestPointT\n          };\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n\n    if (closestPointT) {\n      return closestPointT;\n    }\n\n    return {\n      segmentIndex: this.segments.length - 1,\n      value: 1\n    };\n  }\n\n  closestPointTangent(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let closestPointTangent;\n    let minSquaredDistance = Infinity;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n\n      if (segment.isDifferentiable()) {\n        const segmentClosestPointT = segment.closestPointT(p, {\n          precision,\n          subdivisions\n        });\n        const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n        const squaredDistance = squaredLength(segmentClosestPoint, p);\n\n        if (squaredDistance < minSquaredDistance) {\n          closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n          minSquaredDistance = squaredDistance;\n        }\n      }\n    }\n\n    if (closestPointTangent) {\n      return closestPointTangent;\n    }\n\n    return null;\n  }\n\n  containsPoint(p) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const polylines = this.toPolylines(options);\n\n    if (!polylines) {\n      return false;\n    }\n\n    let numIntersections = 0;\n\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i];\n\n      if (polyline.containsPoint(p)) {\n        numIntersections += 1;\n      }\n    } // returns `true` for odd numbers of intersections (even-odd algorithm)\n\n\n    return numIntersections % 2 === 1;\n  }\n\n  pointAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    if (ratio <= 0) {\n      return this.start.clone();\n    }\n\n    if (ratio >= 1) {\n      return this.end.clone();\n    }\n\n    const opts = this.getOptions(options);\n    const pathLength = this.length(opts);\n    const length = pathLength * ratio;\n    return this.pointAtLength(length, opts);\n  }\n\n  pointAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    if (length === 0) {\n      return this.start.clone();\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let lastVisibleSegment;\n    let memo = 0;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const d = segment.length({\n        precision,\n        subdivisions\n      });\n\n      if (segment.isVisible) {\n        if (length <= memo + d) {\n          return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions\n          });\n        }\n\n        lastVisibleSegment = segment;\n      }\n\n      memo += d;\n    } // if length requested is higher than the length of the path,\n    // return last visible segment endpoint\n\n\n    if (lastVisibleSegment) {\n      return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n    } // if no visible segment, return last segment end point\n\n\n    const lastSegment = this.segments[this.segments.length - 1];\n    return lastSegment.end.clone();\n  }\n\n  pointAtT(t) {\n    const segments = this.segments;\n    const numSegments = segments.length;\n    if (numSegments === 0) return null; // if segments is an empty array\n\n    const segmentIndex = t.segmentIndex;\n    if (segmentIndex < 0) return segments[0].pointAtT(0);\n\n    if (segmentIndex >= numSegments) {\n      return segments[numSegments - 1].pointAtT(1);\n    }\n\n    const tValue = clamp(t.value, 0, 1);\n    return segments[segmentIndex].pointAtT(tValue);\n  }\n\n  divideAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const rate = clamp(ratio, 0, 1);\n    const opts = this.getOptions(options);\n    const len = this.length(opts);\n    const length = len * rate;\n    return this.divideAtLength(length, opts);\n  }\n\n  divideAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let memo = 0;\n    let divided;\n    let dividedSegmentIndex;\n    let lastValidSegment;\n    let lastValidSegmentIndex;\n    let t;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.getSegment(index);\n      const subdivisions = segmentSubdivisions[index];\n      const opts = {\n        precision,\n        subdivisions\n      };\n      const len = segment.length(opts);\n\n      if (segment.isDifferentiable()) {\n        lastValidSegment = segment;\n        lastValidSegmentIndex = index;\n\n        if (length <= memo + len) {\n          dividedSegmentIndex = index;\n          divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);\n          break;\n        }\n      }\n\n      memo += len;\n    }\n\n    if (!lastValidSegment) {\n      return null;\n    }\n\n    if (!divided) {\n      dividedSegmentIndex = lastValidSegmentIndex;\n      t = fromStart ? 1 : 0;\n      divided = lastValidSegment.divideAtT(t);\n    } // create a copy of this path and replace the identified segment with its two divided parts:\n\n\n    const pathCopy = this.clone();\n    const index = dividedSegmentIndex;\n    pathCopy.replaceSegment(index, divided);\n    const divisionStartIndex = index;\n    let divisionMidIndex = index + 1;\n    let divisionEndIndex = index + 2; // do not insert the part if it looks like a point\n\n    if (!divided[0].isDifferentiable()) {\n      pathCopy.removeSegment(divisionStartIndex);\n      divisionMidIndex -= 1;\n      divisionEndIndex -= 1;\n    } // insert a Moveto segment to ensure secondPath will be valid:\n\n\n    const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n    pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n    divisionEndIndex += 1; // do not insert the part if it looks like a point\n\n    if (!divided[1].isDifferentiable()) {\n      pathCopy.removeSegment(divisionEndIndex - 1);\n      divisionEndIndex -= 1;\n    } // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n\n\n    const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n\n    for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {\n      const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n      const segment = pathCopy.getSegment(i);\n\n      if (segment.type === 'Z' && !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n        // pathCopy segment's subpathStartSegment is different from original segment's one\n        // convert this Closepath segment to a Lineto and replace it in pathCopy\n        const convertedSegment = Path.createSegment('L', originalSegment.end);\n        pathCopy.replaceSegment(i, convertedSegment);\n      }\n    } // distribute pathCopy segments into two paths and return those:\n\n\n    const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n    const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n    return [firstPath, secondPath];\n  }\n\n  intersectsWithLine(line) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const polylines = this.toPolylines(options);\n\n    if (polylines == null) {\n      return null;\n    }\n\n    let intersections = null;\n\n    for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n      const polyline = polylines[i];\n      const intersection = line.intersect(polyline);\n\n      if (intersection) {\n        if (intersections == null) {\n          intersections = [];\n        }\n\n        if (Array.isArray(intersection)) {\n          intersections.push(...intersection);\n        } else {\n          intersections.push(intersection);\n        }\n      }\n    }\n\n    return intersections;\n  }\n\n  isDifferentiable() {\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n\n      if (segment.isDifferentiable()) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  isValid() {\n    const segments = this.segments;\n    const isValid = segments.length === 0 || segments[0].type === 'M';\n    return isValid;\n  }\n\n  length() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.segments.length === 0) {\n      return 0;\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let length = 0;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        subdivisions\n      });\n    }\n\n    return length;\n  }\n\n  lengthAtT(t) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const count = this.segments.length;\n\n    if (count === 0) {\n      return 0;\n    }\n\n    let segmentIndex = t.segmentIndex;\n\n    if (segmentIndex < 0) {\n      return 0;\n    }\n\n    let tValue = clamp(t.value, 0, 1);\n\n    if (segmentIndex >= count) {\n      segmentIndex = count - 1;\n      tValue = 1;\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let length = 0;\n\n    for (let i = 0; i < segmentIndex; i += 1) {\n      const segment = this.segments[i];\n      const subdivisions = segmentSubdivisions[i];\n      length += segment.length({\n        precision,\n        subdivisions\n      });\n    }\n\n    const segment = this.segments[segmentIndex];\n    const subdivisions = segmentSubdivisions[segmentIndex];\n    length += segment.lengthAtT(tValue, {\n      precision,\n      subdivisions\n    });\n    return length;\n  }\n\n  tangentAt(ratio) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    const rate = clamp(ratio, 0, 1);\n    const opts = this.getOptions(options);\n    const len = this.length(opts);\n    const length = len * rate;\n    return this.tangentAtLength(length, opts);\n  }\n\n  tangentAtLength(length) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (this.segments.length === 0) {\n      return null;\n    }\n\n    let fromStart = true;\n\n    if (length < 0) {\n      fromStart = false;\n      length = -length; // eslint-disable-line\n    }\n\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    let lastValidSegment;\n    let memo = 0;\n\n    for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n      const index = fromStart ? i : ii - 1 - i;\n      const segment = this.segments[index];\n      const subdivisions = segmentSubdivisions[index];\n      const len = segment.length({\n        precision,\n        subdivisions\n      });\n\n      if (segment.isDifferentiable()) {\n        if (length <= memo + len) {\n          return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {\n            precision,\n            subdivisions\n          });\n        }\n\n        lastValidSegment = segment;\n      }\n\n      memo += len;\n    } // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n\n\n    if (lastValidSegment) {\n      const t = fromStart ? 1 : 0;\n      return lastValidSegment.tangentAtT(t);\n    } // if no valid segment, return null\n\n\n    return null;\n  }\n\n  tangentAtT(t) {\n    const count = this.segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    const segmentIndex = t.segmentIndex;\n\n    if (segmentIndex < 0) {\n      return this.segments[0].tangentAtT(0);\n    }\n\n    if (segmentIndex >= count) {\n      return this.segments[count - 1].tangentAtT(1);\n    }\n\n    const tValue = clamp(t.value, 0, 1);\n    return this.segments[segmentIndex].tangentAtT(tValue);\n  }\n\n  getPrecision() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return options.precision == null ? this.PRECISION : options.precision;\n  }\n\n  getSubdivisions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (options.segmentSubdivisions == null) {\n      const precision = this.getPrecision(options);\n      return this.getSegmentSubdivisions({\n        precision\n      });\n    }\n\n    return options.segmentSubdivisions;\n  }\n\n  getOptions() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const precision = this.getPrecision(options);\n    const segmentSubdivisions = this.getSubdivisions(options);\n    return {\n      precision,\n      segmentSubdivisions\n    };\n  }\n\n  toPoints() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const segments = this.segments;\n    const count = segments.length;\n\n    if (count === 0) {\n      return null;\n    }\n\n    const segmentSubdivisions = this.getSubdivisions(options);\n    const points = [];\n    let partialPoints = [];\n\n    for (let i = 0; i < count; i += 1) {\n      const segment = segments[i];\n\n      if (segment.isVisible) {\n        const divisions = segmentSubdivisions[i];\n\n        if (divisions.length > 0) {\n          // eslint-disable-next-line no-loop-func\n          divisions.forEach(c => partialPoints.push(c.start));\n        } else {\n          partialPoints.push(segment.start);\n        }\n      } else if (partialPoints.length > 0) {\n        partialPoints.push(segments[i - 1].end);\n        points.push(partialPoints);\n        partialPoints = [];\n      }\n    }\n\n    if (partialPoints.length > 0) {\n      partialPoints.push(this.end);\n      points.push(partialPoints);\n    }\n\n    return points;\n  }\n\n  toPolylines() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const points = this.toPoints(options);\n\n    if (!points) {\n      return null;\n    }\n\n    return points.map(arr => new Polyline(arr));\n  }\n\n  scale(sx, sy, origin) {\n    this.segments.forEach(s => s.scale(sx, sy, origin));\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.segments.forEach(segment => segment.rotate(angle, origin));\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.segments.forEach(s => s.translate(tx, ty));\n    } else {\n      this.segments.forEach(s => s.translate(tx));\n    }\n\n    return this;\n  }\n\n  clone() {\n    const path = new Path();\n    this.segments.forEach(s => path.appendSegment(s.clone()));\n    return path;\n  }\n\n  equals(p) {\n    if (p == null) {\n      return false;\n    }\n\n    const segments = this.segments;\n    const otherSegments = p.segments;\n    const count = segments.length;\n\n    if (otherSegments.length !== count) {\n      return false;\n    }\n\n    for (let i = 0; i < count; i += 1) {\n      const a = segments[i];\n      const b = otherSegments[i];\n\n      if (a.type !== b.type || !a.equals(b)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  toJSON() {\n    return this.segments.map(s => s.toJSON());\n  }\n\n  serialize() {\n    if (!this.isValid()) {\n      throw new Error('Invalid path segments.');\n    }\n\n    return this.segments.map(s => s.serialize()).join(' ');\n  }\n\n  toString() {\n    return this.serialize();\n  }\n\n}\n\n(function (Path) {\n  Path.toStringTag = `X6.Geometry.${Path.name}`;\n\n  function isPath(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Path) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const path = instance;\n\n    if ((tag == null || tag === Path.toStringTag) && Array.isArray(path.segments) && typeof path.moveTo === 'function' && typeof path.lineTo === 'function' && typeof path.curveTo === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Path.isPath = isPath;\n})(Path || (Path = {}));\n\n(function (Path) {\n  function parse(pathData) {\n    if (!pathData) {\n      return new Path();\n    }\n\n    const path = new Path();\n    const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n    const commands = Path.normalize(pathData).match(commandRe);\n\n    if (commands != null) {\n      for (let i = 0, ii = commands.length; i < ii; i += 1) {\n        const command = commands[i];\n        const argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g; // args = [type, coordinate1, coordinate2...]\n\n        const args = command.match(argRe);\n\n        if (args != null) {\n          const type = args[0];\n          const coords = args.slice(1).map(a => +a);\n          const segment = createSegment.call(null, type, ...coords);\n          path.appendSegment(segment);\n        }\n      }\n    }\n\n    return path;\n  }\n\n  Path.parse = parse;\n\n  function createSegment(type) {\n    for (var _len4 = arguments.length, args = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {\n      args[_key4 - 1] = arguments[_key4];\n    }\n\n    if (type === 'M') {\n      return MoveTo.create.call(null, ...args);\n    }\n\n    if (type === 'L') {\n      return LineTo.create.call(null, ...args);\n    }\n\n    if (type === 'C') {\n      return CurveTo.create.call(null, ...args);\n    }\n\n    if (type === 'z' || type === 'Z') {\n      return Close.create();\n    }\n\n    throw new Error(`Invalid path segment type \"${type}\"`);\n  }\n\n  Path.createSegment = createSegment;\n})(Path || (Path = {}));\n\n(function (Path) {\n  Path.normalize = normalizePathData;\n  Path.isValid = Util.isValid;\n  Path.drawArc = Util.drawArc;\n  Path.drawPoints = Util.drawPoints;\n  Path.arcToCurves = Util.arcToCurves;\n})(Path || (Path = {}));","map":{"version":3,"sources":["../../../src/geometry/path/path.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { clamp, squaredLength } from '../util';\nimport { Line } from '../line';\nimport { Point } from '../point';\nimport { Curve } from '../curve';\nimport { Polyline } from '../polyline';\nimport { Rectangle } from '../rectangle';\nimport { Geometry } from '../geometry';\nimport { Close } from './close';\nimport { LineTo } from './lineto';\nimport { MoveTo } from './moveto';\nimport { CurveTo } from './curveto';\nimport { normalizePathData } from './normalize';\nimport * as Util from './util';\nexport class Path extends Geometry {\n    constructor(args) {\n        super();\n        this.PRECISION = 3;\n        this.segments = [];\n        if (Array.isArray(args)) {\n            if (Line.isLine(args[0]) || Curve.isCurve(args[0])) {\n                let previousObj = null;\n                const arr = args;\n                arr.forEach((o, i) => {\n                    if (i === 0) {\n                        this.appendSegment(Path.createSegment('M', o.start));\n                    }\n                    if (previousObj != null && !previousObj.end.equals(o.start)) {\n                        this.appendSegment(Path.createSegment('M', o.start));\n                    }\n                    if (Line.isLine(o)) {\n                        this.appendSegment(Path.createSegment('L', o.end));\n                    }\n                    else if (Curve.isCurve(o)) {\n                        this.appendSegment(Path.createSegment('C', o.controlPoint1, o.controlPoint2, o.end));\n                    }\n                    previousObj = o;\n                });\n            }\n            else {\n                const arr = args;\n                arr.forEach((s) => {\n                    if (s.isSegment) {\n                        this.appendSegment(s);\n                    }\n                });\n            }\n        }\n        else if (args != null) {\n            if (Line.isLine(args)) {\n                this.appendSegment(Path.createSegment('M', args.start));\n                this.appendSegment(Path.createSegment('L', args.end));\n            }\n            else if (Curve.isCurve(args)) {\n                this.appendSegment(Path.createSegment('M', args.start));\n                this.appendSegment(Path.createSegment('C', args.controlPoint1, args.controlPoint2, args.end));\n            }\n            else if (Polyline.isPolyline(args)) {\n                if (args.points && args.points.length) {\n                    args.points.forEach((point, index) => {\n                        const segment = index === 0\n                            ? Path.createSegment('M', point)\n                            : Path.createSegment('L', point);\n                        this.appendSegment(segment);\n                    });\n                }\n            }\n            else if (args.isSegment) {\n                this.appendSegment(args);\n            }\n        }\n    }\n    get [Symbol.toStringTag]() {\n        return Path.toStringTag;\n    }\n    get start() {\n        const segments = this.segments;\n        const count = segments.length;\n        if (count === 0) {\n            return null;\n        }\n        for (let i = 0; i < count; i += 1) {\n            const segment = segments[i];\n            if (segment.isVisible) {\n                return segment.start;\n            }\n        }\n        // if no visible segment, return last segment end point\n        return segments[count - 1].end;\n    }\n    get end() {\n        const segments = this.segments;\n        const count = segments.length;\n        if (count === 0) {\n            return null;\n        }\n        for (let i = count - 1; i >= 0; i -= 1) {\n            const segment = segments[i];\n            if (segment.isVisible) {\n                return segment.end;\n            }\n        }\n        // if no visible segment, return last segment end point\n        return segments[count - 1].end;\n    }\n    moveTo(...args) {\n        return this.appendSegment(MoveTo.create.call(null, ...args));\n    }\n    lineTo(...args) {\n        return this.appendSegment(LineTo.create.call(null, ...args));\n    }\n    curveTo(...args) {\n        return this.appendSegment(CurveTo.create.call(null, ...args));\n    }\n    arcTo(rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY) {\n        const start = this.end || new Point();\n        const points = typeof endX === 'number'\n            ? Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX, endY)\n            : Util.arcToCurves(start.x, start.y, rx, ry, xAxisRotation, largeArcFlag, sweepFlag, endX.x, endX.y);\n        if (points != null) {\n            for (let i = 0, ii = points.length; i < ii; i += 6) {\n                this.curveTo(points[i], points[i + 1], points[i + 2], points[i + 3], points[i + 4], points[i + 5]);\n            }\n        }\n        return this;\n    }\n    quadTo(x1, y1, x, y) {\n        const start = this.end || new Point();\n        const data = ['M', start.x, start.y];\n        if (typeof x1 === 'number') {\n            data.push('Q', x1, y1, x, y);\n        }\n        else {\n            const p = y1;\n            data.push(`Q`, x1.x, x1.y, p.x, p.y);\n        }\n        const path = Path.parse(data.join(' '));\n        this.appendSegment(path.segments.slice(1));\n        return this;\n    }\n    close() {\n        return this.appendSegment(Close.create());\n    }\n    drawPoints(points, options = {}) {\n        const raw = Util.drawPoints(points, options);\n        const sub = Path.parse(raw);\n        if (sub && sub.segments) {\n            this.appendSegment(sub.segments);\n        }\n    }\n    bbox() {\n        const segments = this.segments;\n        const count = segments.length;\n        if (count === 0) {\n            return null;\n        }\n        let bbox;\n        for (let i = 0; i < count; i += 1) {\n            const segment = segments[i];\n            if (segment.isVisible) {\n                const segmentBBox = segment.bbox();\n                if (segmentBBox != null) {\n                    bbox = bbox ? bbox.union(segmentBBox) : segmentBBox;\n                }\n            }\n        }\n        if (bbox != null) {\n            return bbox;\n        }\n        // if the path has only invisible elements, return end point of last segment\n        const lastSegment = segments[count - 1];\n        return new Rectangle(lastSegment.end.x, lastSegment.end.y, 0, 0);\n    }\n    appendSegment(seg) {\n        const count = this.segments.length;\n        let previousSegment = count !== 0 ? this.segments[count - 1] : null;\n        let currentSegment;\n        const nextSegment = null;\n        if (Array.isArray(seg)) {\n            for (let i = 0, ii = seg.length; i < ii; i += 1) {\n                const segment = seg[i];\n                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n                this.segments.push(currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n        else if (seg != null && seg.isSegment) {\n            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n            this.segments.push(currentSegment);\n        }\n        return this;\n    }\n    insertSegment(index, seg) {\n        const count = this.segments.length;\n        if (index < 0) {\n            index = count + index + 1; // eslint-disable-line\n        }\n        if (index > count || index < 0) {\n            throw new Error('Index out of range.');\n        }\n        let currentSegment;\n        let previousSegment = null;\n        let nextSegment = null;\n        if (count !== 0) {\n            if (index >= 1) {\n                previousSegment = this.segments[index - 1];\n                nextSegment = previousSegment.nextSegment;\n            }\n            else {\n                previousSegment = null;\n                nextSegment = this.segments[0];\n            }\n        }\n        if (!Array.isArray(seg)) {\n            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n            this.segments.splice(index, 0, currentSegment);\n        }\n        else {\n            for (let i = 0, ii = seg.length; i < ii; i += 1) {\n                const segment = seg[i];\n                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n                this.segments.splice(index + i, 0, currentSegment);\n                previousSegment = currentSegment;\n            }\n        }\n        return this;\n    }\n    removeSegment(index) {\n        const idx = this.fixIndex(index);\n        const removedSegment = this.segments.splice(idx, 1)[0];\n        const previousSegment = removedSegment.previousSegment;\n        const nextSegment = removedSegment.nextSegment;\n        // link the previous and next segments together (if present)\n        if (previousSegment) {\n            previousSegment.nextSegment = nextSegment;\n        }\n        if (nextSegment) {\n            nextSegment.previousSegment = previousSegment;\n        }\n        if (removedSegment.isSubpathStart && nextSegment) {\n            this.updateSubpathStartSegment(nextSegment);\n        }\n        return removedSegment;\n    }\n    replaceSegment(index, seg) {\n        const idx = this.fixIndex(index);\n        let currentSegment;\n        const replacedSegment = this.segments[idx];\n        let previousSegment = replacedSegment.previousSegment;\n        const nextSegment = replacedSegment.nextSegment;\n        let updateSubpathStart = replacedSegment.isSubpathStart;\n        if (!Array.isArray(seg)) {\n            currentSegment = this.prepareSegment(seg, previousSegment, nextSegment);\n            this.segments.splice(idx, 1, currentSegment);\n            if (updateSubpathStart && currentSegment.isSubpathStart) {\n                // already updated by `prepareSegment`\n                updateSubpathStart = false;\n            }\n        }\n        else {\n            this.segments.splice(index, 1);\n            for (let i = 0, ii = seg.length; i < ii; i += 1) {\n                const segment = seg[i];\n                currentSegment = this.prepareSegment(segment, previousSegment, nextSegment);\n                this.segments.splice(index + i, 0, currentSegment);\n                previousSegment = currentSegment;\n                if (updateSubpathStart && currentSegment.isSubpathStart) {\n                    updateSubpathStart = false;\n                }\n            }\n        }\n        if (updateSubpathStart && nextSegment) {\n            this.updateSubpathStartSegment(nextSegment);\n        }\n    }\n    getSegment(index) {\n        const idx = this.fixIndex(index);\n        return this.segments[idx];\n    }\n    fixIndex(index) {\n        const length = this.segments.length;\n        if (length === 0) {\n            throw new Error('Path has no segments.');\n        }\n        let i = index;\n        while (i < 0) {\n            i = length + i;\n        }\n        if (i >= length || i < 0) {\n            throw new Error('Index out of range.');\n        }\n        return i;\n    }\n    segmentAt(ratio, options = {}) {\n        const index = this.segmentIndexAt(ratio, options);\n        if (!index) {\n            return null;\n        }\n        return this.getSegment(index);\n    }\n    segmentAtLength(length, options = {}) {\n        const index = this.segmentIndexAtLength(length, options);\n        if (!index)\n            return null;\n        return this.getSegment(index);\n    }\n    segmentIndexAt(ratio, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        const rate = clamp(ratio, 0, 1);\n        const opt = this.getOptions(options);\n        const len = this.length(opt);\n        const length = len * rate;\n        return this.segmentIndexAtLength(length, opt);\n    }\n    segmentIndexAtLength(length, options = {}) {\n        const count = this.segments.length;\n        if (count === 0) {\n            return null;\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let memo = 0;\n        let lastVisibleIndex = null;\n        for (let i = 0; i < count; i += 1) {\n            const index = fromStart ? i : count - 1 - i;\n            const segment = this.segments[index];\n            const subdivisions = segmentSubdivisions[index];\n            const len = segment.length({ precision, subdivisions });\n            if (segment.isVisible) {\n                if (length <= memo + len) {\n                    return index;\n                }\n                lastVisibleIndex = index;\n            }\n            memo += len;\n        }\n        // If length requested is higher than the length of the path, return\n        // last visible segment index. If no visible segment, return null.\n        return lastVisibleIndex;\n    }\n    getSegmentSubdivisions(options = {}) {\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = [];\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const segment = this.segments[i];\n            const subdivisions = segment.getSubdivisions({ precision });\n            segmentSubdivisions.push(subdivisions);\n        }\n        return segmentSubdivisions;\n    }\n    updateSubpathStartSegment(segment) {\n        let previous = segment.previousSegment;\n        let current = segment;\n        while (current && !current.isSubpathStart) {\n            // assign previous segment's subpath start segment to this segment\n            if (previous != null) {\n                current.subpathStartSegment = previous.subpathStartSegment;\n            }\n            else {\n                current.subpathStartSegment = null;\n            }\n            previous = current;\n            current = current.nextSegment;\n        }\n    }\n    prepareSegment(segment, previousSegment, nextSegment) {\n        segment.previousSegment = previousSegment;\n        segment.nextSegment = nextSegment;\n        if (previousSegment != null) {\n            previousSegment.nextSegment = segment;\n        }\n        if (nextSegment != null) {\n            nextSegment.previousSegment = segment;\n        }\n        let updateSubpathStart = segment;\n        if (segment.isSubpathStart) {\n            // move to\n            segment.subpathStartSegment = segment;\n            updateSubpathStart = nextSegment;\n        }\n        // assign previous segment's subpath start (or self if it is a subpath start) to subsequent segments\n        if (updateSubpathStart != null) {\n            this.updateSubpathStartSegment(updateSubpathStart);\n        }\n        return segment;\n    }\n    closestPoint(p, options = {}) {\n        const t = this.closestPointT(p, options);\n        if (!t) {\n            return null;\n        }\n        return this.pointAtT(t);\n    }\n    closestPointLength(p, options = {}) {\n        const opts = this.getOptions(options);\n        const t = this.closestPointT(p, opts);\n        if (!t) {\n            return 0;\n        }\n        return this.lengthAtT(t, opts);\n    }\n    closestPointNormalizedLength(p, options = {}) {\n        const opts = this.getOptions(options);\n        const cpLength = this.closestPointLength(p, opts);\n        if (cpLength === 0) {\n            return 0;\n        }\n        const length = this.length(opts);\n        if (length === 0) {\n            return 0;\n        }\n        return cpLength / length;\n    }\n    closestPointT(p, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let closestPointT;\n        let minSquaredDistance = Infinity;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const segment = this.segments[i];\n            const subdivisions = segmentSubdivisions[i];\n            if (segment.isVisible) {\n                const segmentClosestPointT = segment.closestPointT(p, {\n                    precision,\n                    subdivisions,\n                });\n                const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                const squaredDistance = squaredLength(segmentClosestPoint, p);\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointT = { segmentIndex: i, value: segmentClosestPointT };\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n        if (closestPointT) {\n            return closestPointT;\n        }\n        return { segmentIndex: this.segments.length - 1, value: 1 };\n    }\n    closestPointTangent(p, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let closestPointTangent;\n        let minSquaredDistance = Infinity;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const segment = this.segments[i];\n            const subdivisions = segmentSubdivisions[i];\n            if (segment.isDifferentiable()) {\n                const segmentClosestPointT = segment.closestPointT(p, {\n                    precision,\n                    subdivisions,\n                });\n                const segmentClosestPoint = segment.pointAtT(segmentClosestPointT);\n                const squaredDistance = squaredLength(segmentClosestPoint, p);\n                if (squaredDistance < minSquaredDistance) {\n                    closestPointTangent = segment.tangentAtT(segmentClosestPointT);\n                    minSquaredDistance = squaredDistance;\n                }\n            }\n        }\n        if (closestPointTangent) {\n            return closestPointTangent;\n        }\n        return null;\n    }\n    containsPoint(p, options = {}) {\n        const polylines = this.toPolylines(options);\n        if (!polylines) {\n            return false;\n        }\n        let numIntersections = 0;\n        for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n            const polyline = polylines[i];\n            if (polyline.containsPoint(p)) {\n                numIntersections += 1;\n            }\n        }\n        // returns `true` for odd numbers of intersections (even-odd algorithm)\n        return numIntersections % 2 === 1;\n    }\n    pointAt(ratio, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        if (ratio <= 0) {\n            return this.start.clone();\n        }\n        if (ratio >= 1) {\n            return this.end.clone();\n        }\n        const opts = this.getOptions(options);\n        const pathLength = this.length(opts);\n        const length = pathLength * ratio;\n        return this.pointAtLength(length, opts);\n    }\n    pointAtLength(length, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        if (length === 0) {\n            return this.start.clone();\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let lastVisibleSegment;\n        let memo = 0;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const index = fromStart ? i : ii - 1 - i;\n            const segment = this.segments[index];\n            const subdivisions = segmentSubdivisions[index];\n            const d = segment.length({\n                precision,\n                subdivisions,\n            });\n            if (segment.isVisible) {\n                if (length <= memo + d) {\n                    return segment.pointAtLength((fromStart ? 1 : -1) * (length - memo), {\n                        precision,\n                        subdivisions,\n                    });\n                }\n                lastVisibleSegment = segment;\n            }\n            memo += d;\n        }\n        // if length requested is higher than the length of the path,\n        // return last visible segment endpoint\n        if (lastVisibleSegment) {\n            return fromStart ? lastVisibleSegment.end : lastVisibleSegment.start;\n        }\n        // if no visible segment, return last segment end point\n        const lastSegment = this.segments[this.segments.length - 1];\n        return lastSegment.end.clone();\n    }\n    pointAtT(t) {\n        const segments = this.segments;\n        const numSegments = segments.length;\n        if (numSegments === 0)\n            return null; // if segments is an empty array\n        const segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0)\n            return segments[0].pointAtT(0);\n        if (segmentIndex >= numSegments) {\n            return segments[numSegments - 1].pointAtT(1);\n        }\n        const tValue = clamp(t.value, 0, 1);\n        return segments[segmentIndex].pointAtT(tValue);\n    }\n    divideAt(ratio, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        const rate = clamp(ratio, 0, 1);\n        const opts = this.getOptions(options);\n        const len = this.length(opts);\n        const length = len * rate;\n        return this.divideAtLength(length, opts);\n    }\n    divideAtLength(length, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let memo = 0;\n        let divided;\n        let dividedSegmentIndex;\n        let lastValidSegment;\n        let lastValidSegmentIndex;\n        let t;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const index = fromStart ? i : ii - 1 - i;\n            const segment = this.getSegment(index);\n            const subdivisions = segmentSubdivisions[index];\n            const opts = { precision, subdivisions };\n            const len = segment.length(opts);\n            if (segment.isDifferentiable()) {\n                lastValidSegment = segment;\n                lastValidSegmentIndex = index;\n                if (length <= memo + len) {\n                    dividedSegmentIndex = index;\n                    divided = segment.divideAtLength((fromStart ? 1 : -1) * (length - memo), opts);\n                    break;\n                }\n            }\n            memo += len;\n        }\n        if (!lastValidSegment) {\n            return null;\n        }\n        if (!divided) {\n            dividedSegmentIndex = lastValidSegmentIndex;\n            t = fromStart ? 1 : 0;\n            divided = lastValidSegment.divideAtT(t);\n        }\n        // create a copy of this path and replace the identified segment with its two divided parts:\n        const pathCopy = this.clone();\n        const index = dividedSegmentIndex;\n        pathCopy.replaceSegment(index, divided);\n        const divisionStartIndex = index;\n        let divisionMidIndex = index + 1;\n        let divisionEndIndex = index + 2;\n        // do not insert the part if it looks like a point\n        if (!divided[0].isDifferentiable()) {\n            pathCopy.removeSegment(divisionStartIndex);\n            divisionMidIndex -= 1;\n            divisionEndIndex -= 1;\n        }\n        // insert a Moveto segment to ensure secondPath will be valid:\n        const movetoEnd = pathCopy.getSegment(divisionMidIndex).start;\n        pathCopy.insertSegment(divisionMidIndex, Path.createSegment('M', movetoEnd));\n        divisionEndIndex += 1;\n        // do not insert the part if it looks like a point\n        if (!divided[1].isDifferentiable()) {\n            pathCopy.removeSegment(divisionEndIndex - 1);\n            divisionEndIndex -= 1;\n        }\n        // ensure that Closepath segments in secondPath will be assigned correct subpathStartSegment:\n        const secondPathSegmentIndexConversion = divisionEndIndex - divisionStartIndex - 1;\n        for (let i = divisionEndIndex, ii = pathCopy.segments.length; i < ii; i += 1) {\n            const originalSegment = this.getSegment(i - secondPathSegmentIndexConversion);\n            const segment = pathCopy.getSegment(i);\n            if (segment.type === 'Z' &&\n                !originalSegment.subpathStartSegment.end.equals(segment.subpathStartSegment.end)) {\n                // pathCopy segment's subpathStartSegment is different from original segment's one\n                // convert this Closepath segment to a Lineto and replace it in pathCopy\n                const convertedSegment = Path.createSegment('L', originalSegment.end);\n                pathCopy.replaceSegment(i, convertedSegment);\n            }\n        }\n        // distribute pathCopy segments into two paths and return those:\n        const firstPath = new Path(pathCopy.segments.slice(0, divisionMidIndex));\n        const secondPath = new Path(pathCopy.segments.slice(divisionMidIndex));\n        return [firstPath, secondPath];\n    }\n    intersectsWithLine(line, options = {}) {\n        const polylines = this.toPolylines(options);\n        if (polylines == null) {\n            return null;\n        }\n        let intersections = null;\n        for (let i = 0, ii = polylines.length; i < ii; i += 1) {\n            const polyline = polylines[i];\n            const intersection = line.intersect(polyline);\n            if (intersection) {\n                if (intersections == null) {\n                    intersections = [];\n                }\n                if (Array.isArray(intersection)) {\n                    intersections.push(...intersection);\n                }\n                else {\n                    intersections.push(intersection);\n                }\n            }\n        }\n        return intersections;\n    }\n    isDifferentiable() {\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const segment = this.segments[i];\n            if (segment.isDifferentiable()) {\n                return true;\n            }\n        }\n        return false;\n    }\n    isValid() {\n        const segments = this.segments;\n        const isValid = segments.length === 0 || segments[0].type === 'M';\n        return isValid;\n    }\n    length(options = {}) {\n        if (this.segments.length === 0) {\n            return 0;\n        }\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let length = 0;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const segment = this.segments[i];\n            const subdivisions = segmentSubdivisions[i];\n            length += segment.length({ subdivisions });\n        }\n        return length;\n    }\n    lengthAtT(t, options = {}) {\n        const count = this.segments.length;\n        if (count === 0) {\n            return 0;\n        }\n        let segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) {\n            return 0;\n        }\n        let tValue = clamp(t.value, 0, 1);\n        if (segmentIndex >= count) {\n            segmentIndex = count - 1;\n            tValue = 1;\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let length = 0;\n        for (let i = 0; i < segmentIndex; i += 1) {\n            const segment = this.segments[i];\n            const subdivisions = segmentSubdivisions[i];\n            length += segment.length({ precision, subdivisions });\n        }\n        const segment = this.segments[segmentIndex];\n        const subdivisions = segmentSubdivisions[segmentIndex];\n        length += segment.lengthAtT(tValue, { precision, subdivisions });\n        return length;\n    }\n    tangentAt(ratio, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        const rate = clamp(ratio, 0, 1);\n        const opts = this.getOptions(options);\n        const len = this.length(opts);\n        const length = len * rate;\n        return this.tangentAtLength(length, opts);\n    }\n    tangentAtLength(length, options = {}) {\n        if (this.segments.length === 0) {\n            return null;\n        }\n        let fromStart = true;\n        if (length < 0) {\n            fromStart = false;\n            length = -length; // eslint-disable-line\n        }\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        let lastValidSegment;\n        let memo = 0;\n        for (let i = 0, ii = this.segments.length; i < ii; i += 1) {\n            const index = fromStart ? i : ii - 1 - i;\n            const segment = this.segments[index];\n            const subdivisions = segmentSubdivisions[index];\n            const len = segment.length({ precision, subdivisions });\n            if (segment.isDifferentiable()) {\n                if (length <= memo + len) {\n                    return segment.tangentAtLength((fromStart ? 1 : -1) * (length - memo), {\n                        precision,\n                        subdivisions,\n                    });\n                }\n                lastValidSegment = segment;\n            }\n            memo += len;\n        }\n        // if length requested is higher than the length of the path, return tangent of endpoint of last valid segment\n        if (lastValidSegment) {\n            const t = fromStart ? 1 : 0;\n            return lastValidSegment.tangentAtT(t);\n        }\n        // if no valid segment, return null\n        return null;\n    }\n    tangentAtT(t) {\n        const count = this.segments.length;\n        if (count === 0) {\n            return null;\n        }\n        const segmentIndex = t.segmentIndex;\n        if (segmentIndex < 0) {\n            return this.segments[0].tangentAtT(0);\n        }\n        if (segmentIndex >= count) {\n            return this.segments[count - 1].tangentAtT(1);\n        }\n        const tValue = clamp(t.value, 0, 1);\n        return this.segments[segmentIndex].tangentAtT(tValue);\n    }\n    getPrecision(options = {}) {\n        return options.precision == null ? this.PRECISION : options.precision;\n    }\n    getSubdivisions(options = {}) {\n        if (options.segmentSubdivisions == null) {\n            const precision = this.getPrecision(options);\n            return this.getSegmentSubdivisions({ precision });\n        }\n        return options.segmentSubdivisions;\n    }\n    getOptions(options = {}) {\n        const precision = this.getPrecision(options);\n        const segmentSubdivisions = this.getSubdivisions(options);\n        return { precision, segmentSubdivisions };\n    }\n    toPoints(options = {}) {\n        const segments = this.segments;\n        const count = segments.length;\n        if (count === 0) {\n            return null;\n        }\n        const segmentSubdivisions = this.getSubdivisions(options);\n        const points = [];\n        let partialPoints = [];\n        for (let i = 0; i < count; i += 1) {\n            const segment = segments[i];\n            if (segment.isVisible) {\n                const divisions = segmentSubdivisions[i];\n                if (divisions.length > 0) {\n                    // eslint-disable-next-line no-loop-func\n                    divisions.forEach((c) => partialPoints.push(c.start));\n                }\n                else {\n                    partialPoints.push(segment.start);\n                }\n            }\n            else if (partialPoints.length > 0) {\n                partialPoints.push(segments[i - 1].end);\n                points.push(partialPoints);\n                partialPoints = [];\n            }\n        }\n        if (partialPoints.length > 0) {\n            partialPoints.push(this.end);\n            points.push(partialPoints);\n        }\n        return points;\n    }\n    toPolylines(options = {}) {\n        const points = this.toPoints(options);\n        if (!points) {\n            return null;\n        }\n        return points.map((arr) => new Polyline(arr));\n    }\n    scale(sx, sy, origin) {\n        this.segments.forEach((s) => s.scale(sx, sy, origin));\n        return this;\n    }\n    rotate(angle, origin) {\n        this.segments.forEach((segment) => segment.rotate(angle, origin));\n        return this;\n    }\n    translate(tx, ty) {\n        if (typeof tx === 'number') {\n            this.segments.forEach((s) => s.translate(tx, ty));\n        }\n        else {\n            this.segments.forEach((s) => s.translate(tx));\n        }\n        return this;\n    }\n    clone() {\n        const path = new Path();\n        this.segments.forEach((s) => path.appendSegment(s.clone()));\n        return path;\n    }\n    equals(p) {\n        if (p == null) {\n            return false;\n        }\n        const segments = this.segments;\n        const otherSegments = p.segments;\n        const count = segments.length;\n        if (otherSegments.length !== count) {\n            return false;\n        }\n        for (let i = 0; i < count; i += 1) {\n            const a = segments[i];\n            const b = otherSegments[i];\n            if (a.type !== b.type || !a.equals(b)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    toJSON() {\n        return this.segments.map((s) => s.toJSON());\n    }\n    serialize() {\n        if (!this.isValid()) {\n            throw new Error('Invalid path segments.');\n        }\n        return this.segments.map((s) => s.serialize()).join(' ');\n    }\n    toString() {\n        return this.serialize();\n    }\n}\n(function (Path) {\n    Path.toStringTag = `X6.Geometry.${Path.name}`;\n    function isPath(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Path) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const path = instance;\n        if ((tag == null || tag === Path.toStringTag) &&\n            Array.isArray(path.segments) &&\n            typeof path.moveTo === 'function' &&\n            typeof path.lineTo === 'function' &&\n            typeof path.curveTo === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Path.isPath = isPath;\n})(Path || (Path = {}));\n(function (Path) {\n    function parse(pathData) {\n        if (!pathData) {\n            return new Path();\n        }\n        const path = new Path();\n        const commandRe = /(?:[a-zA-Z] *)(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)? *,? *)|(?:-?\\.\\d+ *,? *))+|(?:[a-zA-Z] *)(?! |\\d|-|\\.)/g;\n        const commands = Path.normalize(pathData).match(commandRe);\n        if (commands != null) {\n            for (let i = 0, ii = commands.length; i < ii; i += 1) {\n                const command = commands[i];\n                const argRe = /(?:[a-zA-Z])|(?:(?:-?\\d+(?:\\.\\d+)?(?:e[-+]?\\d+)?))|(?:(?:-?\\.\\d+))/g;\n                // args = [type, coordinate1, coordinate2...]\n                const args = command.match(argRe);\n                if (args != null) {\n                    const type = args[0];\n                    const coords = args.slice(1).map((a) => +a);\n                    const segment = createSegment.call(null, type, ...coords);\n                    path.appendSegment(segment);\n                }\n            }\n        }\n        return path;\n    }\n    Path.parse = parse;\n    function createSegment(type, ...args) {\n        if (type === 'M') {\n            return MoveTo.create.call(null, ...args);\n        }\n        if (type === 'L') {\n            return LineTo.create.call(null, ...args);\n        }\n        if (type === 'C') {\n            return CurveTo.create.call(null, ...args);\n        }\n        if (type === 'z' || type === 'Z') {\n            return Close.create();\n        }\n        throw new Error(`Invalid path segment type \"${type}\"`);\n    }\n    Path.createSegment = createSegment;\n})(Path || (Path = {}));\n(function (Path) {\n    Path.normalize = normalizePathData;\n    Path.isValid = Util.isValid;\n    Path.drawArc = Util.drawArc;\n    Path.drawPoints = Util.drawPoints;\n    Path.arcToCurves = Util.arcToCurves;\n})(Path || (Path = {}));\n//# sourceMappingURL=path.js.map"]},"metadata":{},"sourceType":"module"}