{"ast":null,"code":"import * as util from './util';\nimport { Angle } from './angle';\nimport { Line } from './line';\nimport { Point } from './point';\nimport { Geometry } from './geometry';\nexport class Rectangle extends Geometry {\n  constructor(x, y, width, height) {\n    super();\n    this.x = x == null ? 0 : x;\n    this.y = y == null ? 0 : y;\n    this.width = width == null ? 0 : width;\n    this.height = height == null ? 0 : height;\n  }\n\n  get [Symbol.toStringTag]() {\n    return Rectangle.toStringTag;\n  }\n\n  get left() {\n    return this.x;\n  }\n\n  get top() {\n    return this.y;\n  }\n\n  get right() {\n    return this.x + this.width;\n  }\n\n  get bottom() {\n    return this.y + this.height;\n  }\n\n  get origin() {\n    return new Point(this.x, this.y);\n  }\n\n  get topLeft() {\n    return new Point(this.x, this.y);\n  }\n\n  get topCenter() {\n    return new Point(this.x + this.width / 2, this.y);\n  }\n\n  get topRight() {\n    return new Point(this.x + this.width, this.y);\n  }\n\n  get center() {\n    return new Point(this.x + this.width / 2, this.y + this.height / 2);\n  }\n\n  get bottomLeft() {\n    return new Point(this.x, this.y + this.height);\n  }\n\n  get bottomCenter() {\n    return new Point(this.x + this.width / 2, this.y + this.height);\n  }\n\n  get bottomRight() {\n    return new Point(this.x + this.width, this.y + this.height);\n  }\n\n  get corner() {\n    return new Point(this.x + this.width, this.y + this.height);\n  }\n\n  get rightMiddle() {\n    return new Point(this.x + this.width, this.y + this.height / 2);\n  }\n\n  get leftMiddle() {\n    return new Point(this.x, this.y + this.height / 2);\n  }\n\n  get topLine() {\n    return new Line(this.topLeft, this.topRight);\n  }\n\n  get rightLine() {\n    return new Line(this.topRight, this.bottomRight);\n  }\n\n  get bottomLine() {\n    return new Line(this.bottomLeft, this.bottomRight);\n  }\n\n  get leftLine() {\n    return new Line(this.topLeft, this.bottomLeft);\n  }\n\n  getOrigin() {\n    return this.origin;\n  }\n\n  getTopLeft() {\n    return this.topLeft;\n  }\n\n  getTopCenter() {\n    return this.topCenter;\n  }\n\n  getTopRight() {\n    return this.topRight;\n  }\n\n  getCenter() {\n    return this.center;\n  }\n\n  getCenterX() {\n    return this.x + this.width / 2;\n  }\n\n  getCenterY() {\n    return this.y + this.height / 2;\n  }\n\n  getBottomLeft() {\n    return this.bottomLeft;\n  }\n\n  getBottomCenter() {\n    return this.bottomCenter;\n  }\n\n  getBottomRight() {\n    return this.bottomRight;\n  }\n\n  getCorner() {\n    return this.corner;\n  }\n\n  getRightMiddle() {\n    return this.rightMiddle;\n  }\n\n  getLeftMiddle() {\n    return this.leftMiddle;\n  }\n\n  getTopLine() {\n    return this.topLine;\n  }\n\n  getRightLine() {\n    return this.rightLine;\n  }\n\n  getBottomLine() {\n    return this.bottomLine;\n  }\n\n  getLeftLine() {\n    return this.leftLine;\n  }\n  /**\n   * Returns a rectangle that is the bounding box of the rectangle.\n   *\n   * If `angle` is specified, the bounding box calculation will take into\n   * account the rotation of the rectangle by angle degrees around its center.\n   */\n\n\n  bbox(angle) {\n    if (!angle) {\n      return this.clone();\n    }\n\n    const rad = Angle.toRad(angle);\n    const st = Math.abs(Math.sin(rad));\n    const ct = Math.abs(Math.cos(rad));\n    const w = this.width * ct + this.height * st;\n    const h = this.width * st + this.height * ct;\n    return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n  }\n\n  round() {\n    let precision = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.x = util.round(this.x, precision);\n    this.y = util.round(this.y, precision);\n    this.width = util.round(this.width, precision);\n    this.height = util.round(this.height, precision);\n    return this;\n  }\n\n  add(x, y, width, height) {\n    const rect = Rectangle.create(x, y, width, height);\n    const minX = Math.min(this.x, rect.x);\n    const minY = Math.min(this.y, rect.y);\n    const maxX = Math.max(this.x + this.width, rect.x + rect.width);\n    const maxY = Math.max(this.y + this.height, rect.y + rect.height);\n    this.x = minX;\n    this.y = minY;\n    this.width = maxX - minX;\n    this.height = maxY - minY;\n    return this;\n  }\n\n  update(x, y, width, height) {\n    const rect = Rectangle.create(x, y, width, height);\n    this.x = rect.x;\n    this.y = rect.y;\n    this.width = rect.width;\n    this.height = rect.height;\n    return this;\n  }\n\n  inflate(dx, dy) {\n    const w = dx;\n    const h = dy != null ? dy : dx;\n    this.x -= w;\n    this.y -= h;\n    this.width += 2 * w;\n    this.height += 2 * h;\n    return this;\n  }\n\n  snapToGrid(gx, gy) {\n    const origin = this.origin.snapToGrid(gx, gy);\n    const corner = this.corner.snapToGrid(gx, gy);\n    this.x = origin.x;\n    this.y = origin.y;\n    this.width = corner.x - origin.x;\n    this.height = corner.y - origin.y;\n    return this;\n  }\n\n  translate(tx, ty) {\n    const p = Point.create(tx, ty);\n    this.x += p.x;\n    this.y += p.y;\n    return this;\n  }\n\n  scale(sx, sy) {\n    let origin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : new Point();\n    const pos = this.origin.scale(sx, sy, origin);\n    this.x = pos.x;\n    this.y = pos.y;\n    this.width *= sx;\n    this.height *= sy;\n    return this;\n  }\n\n  rotate(degree) {\n    let center = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.getCenter();\n\n    if (degree !== 0) {\n      const rad = Angle.toRad(degree);\n      const cos = Math.cos(rad);\n      const sin = Math.sin(rad);\n      let p1 = this.getOrigin();\n      let p2 = this.getTopRight();\n      let p3 = this.getBottomRight();\n      let p4 = this.getBottomLeft();\n      p1 = Point.rotateEx(p1, cos, sin, center);\n      p2 = Point.rotateEx(p2, cos, sin, center);\n      p3 = Point.rotateEx(p3, cos, sin, center);\n      p4 = Point.rotateEx(p4, cos, sin, center);\n      const rect = new Rectangle(p1.x, p1.y, 0, 0);\n      rect.add(p2.x, p2.y, 0, 0);\n      rect.add(p3.x, p3.y, 0, 0);\n      rect.add(p4.x, p4.y, 0, 0);\n      this.update(rect);\n    }\n\n    return this;\n  }\n\n  rotate90() {\n    const t = (this.width - this.height) / 2;\n    this.x += t;\n    this.y -= t;\n    const tmp = this.width;\n    this.width = this.height;\n    this.height = tmp;\n    return this;\n  }\n  /**\n   * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n   * `rect.width` and `rect.height`.\n   */\n\n\n  moveAndExpand(rect) {\n    const ref = Rectangle.clone(rect);\n    this.x += ref.x || 0;\n    this.y += ref.y || 0;\n    this.width += ref.width || 0;\n    this.height += ref.height || 0;\n    return this;\n  }\n  /**\n   * Returns an object where `sx` and `sy` give the maximum scaling that can be\n   * applied to the rectangle so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n\n\n  getMaxScaleToFit(limit) {\n    let origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.center;\n    const rect = Rectangle.clone(limit);\n    const ox = origin.x;\n    const oy = origin.y; // Find the maximal possible scale for all corners, so when the scale\n    // is applied the point is still inside the rectangle.\n\n    let sx1 = Infinity;\n    let sx2 = Infinity;\n    let sx3 = Infinity;\n    let sx4 = Infinity;\n    let sy1 = Infinity;\n    let sy2 = Infinity;\n    let sy3 = Infinity;\n    let sy4 = Infinity; // Top Left\n\n    const p1 = rect.topLeft;\n\n    if (p1.x < ox) {\n      sx1 = (this.x - ox) / (p1.x - ox);\n    }\n\n    if (p1.y < oy) {\n      sy1 = (this.y - oy) / (p1.y - oy);\n    } // Bottom Right\n\n\n    const p2 = rect.bottomRight;\n\n    if (p2.x > ox) {\n      sx2 = (this.x + this.width - ox) / (p2.x - ox);\n    }\n\n    if (p2.y > oy) {\n      sy2 = (this.y + this.height - oy) / (p2.y - oy);\n    } // Top Right\n\n\n    const p3 = rect.topRight;\n\n    if (p3.x > ox) {\n      sx3 = (this.x + this.width - ox) / (p3.x - ox);\n    }\n\n    if (p3.y < oy) {\n      sy3 = (this.y - oy) / (p3.y - oy);\n    } // Bottom Left\n\n\n    const p4 = rect.bottomLeft;\n\n    if (p4.x < ox) {\n      sx4 = (this.x - ox) / (p4.x - ox);\n    }\n\n    if (p4.y > oy) {\n      sy4 = (this.y + this.height - oy) / (p4.y - oy);\n    }\n\n    return {\n      sx: Math.min(sx1, sx2, sx3, sx4),\n      sy: Math.min(sy1, sy2, sy3, sy4)\n    };\n  }\n  /**\n   * Returns a number that specifies the maximum scaling that can be applied to\n   * the rectangle along both axes so that it would still fit into `limit`. If\n   * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n   * scaled around its center.\n   */\n\n\n  getMaxUniformScaleToFit(limit) {\n    let origin = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.center;\n    const scale = this.getMaxScaleToFit(limit, origin);\n    return Math.min(scale.sx, scale.sy);\n  }\n\n  containsPoint(x, y) {\n    return util.containsPoint(this, Point.create(x, y));\n  }\n\n  containsRect(x, y, width, height) {\n    const b = Rectangle.create(x, y, width, height);\n    const x1 = this.x;\n    const y1 = this.y;\n    const w1 = this.width;\n    const h1 = this.height;\n    const x2 = b.x;\n    const y2 = b.y;\n    const w2 = b.width;\n    const h2 = b.height; // one of the dimensions is 0\n\n    if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n      return false;\n    }\n\n    return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;\n  }\n  /**\n   * Returns an array of the intersection points of the rectangle and the line.\n   * Return `null` if no intersection exists.\n   */\n\n\n  intersectsWithLine(line) {\n    const rectLines = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n    const points = [];\n    const dedupeArr = [];\n    rectLines.forEach(l => {\n      const p = line.intersectsWithLine(l);\n\n      if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n        points.push(p);\n        dedupeArr.push(p.toString());\n      }\n    });\n    return points.length > 0 ? points : null;\n  }\n  /**\n   * Returns the point on the boundary of the rectangle that is the intersection\n   * of the rectangle with a line starting in the center the rectangle ending in\n   * the point `p`.\n   *\n   * If `angle` is specified, the intersection will take into account the\n   * rotation of the rectangle by `angle` degrees around its center.\n   */\n\n\n  intersectsWithLineFromCenterToPoint(p, angle) {\n    const ref = Point.clone(p);\n    const center = this.center;\n    let result = null;\n\n    if (angle != null && angle !== 0) {\n      ref.rotate(angle, center);\n    }\n\n    const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n    const connector = new Line(center, ref);\n\n    for (let i = sides.length - 1; i >= 0; i -= 1) {\n      const intersection = sides[i].intersectsWithLine(connector);\n\n      if (intersection !== null) {\n        result = intersection;\n        break;\n      }\n    }\n\n    if (result && angle != null && angle !== 0) {\n      result.rotate(-angle, center);\n    }\n\n    return result;\n  }\n\n  intersectsWithRect(x, y, width, height) {\n    const ref = Rectangle.create(x, y, width, height); // no intersection\n\n    if (!this.isIntersectWithRect(ref)) {\n      return null;\n    }\n\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n    const xx = Math.max(myOrigin.x, rOrigin.x);\n    const yy = Math.max(myOrigin.y, rOrigin.y);\n    return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);\n  }\n\n  isIntersectWithRect(x, y, width, height) {\n    const ref = Rectangle.create(x, y, width, height);\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n\n    if (rCorner.x <= myOrigin.x || rCorner.y <= myOrigin.y || rOrigin.x >= myCorner.x || rOrigin.y >= myCorner.y) {\n      return false;\n    }\n\n    return true;\n  }\n  /**\n   * Normalize the rectangle, i.e. make it so that it has non-negative\n   * width and height. If width is less than `0`, the function swaps left and\n   * right corners and if height is less than `0`, the top and bottom corners\n   * are swapped.\n   */\n\n\n  normalize() {\n    let newx = this.x;\n    let newy = this.y;\n    let newwidth = this.width;\n    let newheight = this.height;\n\n    if (this.width < 0) {\n      newx = this.x + this.width;\n      newwidth = -this.width;\n    }\n\n    if (this.height < 0) {\n      newy = this.y + this.height;\n      newheight = -this.height;\n    }\n\n    this.x = newx;\n    this.y = newy;\n    this.width = newwidth;\n    this.height = newheight;\n    return this;\n  }\n  /**\n   * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n   */\n\n\n  union(rect) {\n    const ref = Rectangle.clone(rect);\n    const myOrigin = this.origin;\n    const myCorner = this.corner;\n    const rOrigin = ref.origin;\n    const rCorner = ref.corner;\n    const originX = Math.min(myOrigin.x, rOrigin.x);\n    const originY = Math.min(myOrigin.y, rOrigin.y);\n    const cornerX = Math.max(myCorner.x, rCorner.x);\n    const cornerY = Math.max(myCorner.y, rCorner.y);\n    return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);\n  }\n  /**\n   * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n   * the rectangle which is nearest to the point `p`.\n   */\n\n\n  getNearestSideToPoint(p) {\n    const ref = Point.clone(p);\n    const distLeft = ref.x - this.x;\n    const distRight = this.x + this.width - ref.x;\n    const distTop = ref.y - this.y;\n    const distBottom = this.y + this.height - ref.y;\n    let closest = distLeft;\n    let side = 'left';\n\n    if (distRight < closest) {\n      closest = distRight;\n      side = 'right';\n    }\n\n    if (distTop < closest) {\n      closest = distTop;\n      side = 'top';\n    }\n\n    if (distBottom < closest) {\n      side = 'bottom';\n    }\n\n    return side;\n  }\n  /**\n   * Returns a point on the boundary of the rectangle nearest to the point `p`.\n   */\n\n\n  getNearestPointToPoint(p) {\n    const ref = Point.clone(p);\n\n    if (this.containsPoint(ref)) {\n      const side = this.getNearestSideToPoint(ref);\n\n      switch (side) {\n        case 'right':\n          return new Point(this.x + this.width, ref.y);\n\n        case 'left':\n          return new Point(this.x, ref.y);\n\n        case 'bottom':\n          return new Point(ref.x, this.y + this.height);\n\n        case 'top':\n          return new Point(ref.x, this.y);\n\n        default:\n          break;\n      }\n    }\n\n    return ref.adhereToRect(this);\n  }\n\n  equals(rect) {\n    return rect != null && rect.x === this.x && rect.y === this.y && rect.width === this.width && rect.height === this.height;\n  }\n\n  clone() {\n    return new Rectangle(this.x, this.y, this.width, this.height);\n  }\n\n  toJSON() {\n    return {\n      x: this.x,\n      y: this.y,\n      width: this.width,\n      height: this.height\n    };\n  }\n\n  serialize() {\n    return `${this.x} ${this.y} ${this.width} ${this.height}`;\n  }\n\n}\n\n(function (Rectangle) {\n  Rectangle.toStringTag = `X6.Geometry.${Rectangle.name}`;\n\n  function isRectangle(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Rectangle) {\n      return true;\n    }\n\n    const tag = instance[Symbol.toStringTag];\n    const rect = instance;\n\n    if ((tag == null || tag === Rectangle.toStringTag) && typeof rect.x === 'number' && typeof rect.y === 'number' && typeof rect.width === 'number' && typeof rect.height === 'number' && typeof rect.inflate === 'function' && typeof rect.moveAndExpand === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Rectangle.isRectangle = isRectangle;\n})(Rectangle || (Rectangle = {}));\n\n(function (Rectangle) {\n  function isRectangleLike(o) {\n    return o != null && typeof o === 'object' && typeof o.x === 'number' && typeof o.y === 'number' && typeof o.width === 'number' && typeof o.height === 'number';\n  }\n\n  Rectangle.isRectangleLike = isRectangleLike;\n})(Rectangle || (Rectangle = {}));\n\n(function (Rectangle) {\n  function create(x, y, width, height) {\n    if (x == null || typeof x === 'number') {\n      return new Rectangle(x, y, width, height);\n    }\n\n    return clone(x);\n  }\n\n  Rectangle.create = create;\n\n  function clone(rect) {\n    if (Rectangle.isRectangle(rect)) {\n      return rect.clone();\n    }\n\n    if (Array.isArray(rect)) {\n      return new Rectangle(rect[0], rect[1], rect[2], rect[3]);\n    }\n\n    return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n  }\n\n  Rectangle.clone = clone;\n\n  function fromSize(size) {\n    return new Rectangle(0, 0, size.width, size.height);\n  }\n\n  Rectangle.fromSize = fromSize;\n\n  function fromPositionAndSize(pos, size) {\n    return new Rectangle(pos.x, pos.y, size.width, size.height);\n  }\n\n  Rectangle.fromPositionAndSize = fromPositionAndSize;\n  /**\n   * Returns a new rectangle from the given ellipse.\n   */\n\n  function fromEllipse(ellipse) {\n    return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);\n  }\n\n  Rectangle.fromEllipse = fromEllipse;\n})(Rectangle || (Rectangle = {}));","map":{"version":3,"sources":["../../src/geometry/rectangle.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import * as util from './util';\nimport { Angle } from './angle';\nimport { Line } from './line';\nimport { Point } from './point';\nimport { Geometry } from './geometry';\nexport class Rectangle extends Geometry {\n    constructor(x, y, width, height) {\n        super();\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n        this.width = width == null ? 0 : width;\n        this.height = height == null ? 0 : height;\n    }\n    get [Symbol.toStringTag]() {\n        return Rectangle.toStringTag;\n    }\n    get left() {\n        return this.x;\n    }\n    get top() {\n        return this.y;\n    }\n    get right() {\n        return this.x + this.width;\n    }\n    get bottom() {\n        return this.y + this.height;\n    }\n    get origin() {\n        return new Point(this.x, this.y);\n    }\n    get topLeft() {\n        return new Point(this.x, this.y);\n    }\n    get topCenter() {\n        return new Point(this.x + this.width / 2, this.y);\n    }\n    get topRight() {\n        return new Point(this.x + this.width, this.y);\n    }\n    get center() {\n        return new Point(this.x + this.width / 2, this.y + this.height / 2);\n    }\n    get bottomLeft() {\n        return new Point(this.x, this.y + this.height);\n    }\n    get bottomCenter() {\n        return new Point(this.x + this.width / 2, this.y + this.height);\n    }\n    get bottomRight() {\n        return new Point(this.x + this.width, this.y + this.height);\n    }\n    get corner() {\n        return new Point(this.x + this.width, this.y + this.height);\n    }\n    get rightMiddle() {\n        return new Point(this.x + this.width, this.y + this.height / 2);\n    }\n    get leftMiddle() {\n        return new Point(this.x, this.y + this.height / 2);\n    }\n    get topLine() {\n        return new Line(this.topLeft, this.topRight);\n    }\n    get rightLine() {\n        return new Line(this.topRight, this.bottomRight);\n    }\n    get bottomLine() {\n        return new Line(this.bottomLeft, this.bottomRight);\n    }\n    get leftLine() {\n        return new Line(this.topLeft, this.bottomLeft);\n    }\n    getOrigin() {\n        return this.origin;\n    }\n    getTopLeft() {\n        return this.topLeft;\n    }\n    getTopCenter() {\n        return this.topCenter;\n    }\n    getTopRight() {\n        return this.topRight;\n    }\n    getCenter() {\n        return this.center;\n    }\n    getCenterX() {\n        return this.x + this.width / 2;\n    }\n    getCenterY() {\n        return this.y + this.height / 2;\n    }\n    getBottomLeft() {\n        return this.bottomLeft;\n    }\n    getBottomCenter() {\n        return this.bottomCenter;\n    }\n    getBottomRight() {\n        return this.bottomRight;\n    }\n    getCorner() {\n        return this.corner;\n    }\n    getRightMiddle() {\n        return this.rightMiddle;\n    }\n    getLeftMiddle() {\n        return this.leftMiddle;\n    }\n    getTopLine() {\n        return this.topLine;\n    }\n    getRightLine() {\n        return this.rightLine;\n    }\n    getBottomLine() {\n        return this.bottomLine;\n    }\n    getLeftLine() {\n        return this.leftLine;\n    }\n    /**\n     * Returns a rectangle that is the bounding box of the rectangle.\n     *\n     * If `angle` is specified, the bounding box calculation will take into\n     * account the rotation of the rectangle by angle degrees around its center.\n     */\n    bbox(angle) {\n        if (!angle) {\n            return this.clone();\n        }\n        const rad = Angle.toRad(angle);\n        const st = Math.abs(Math.sin(rad));\n        const ct = Math.abs(Math.cos(rad));\n        const w = this.width * ct + this.height * st;\n        const h = this.width * st + this.height * ct;\n        return new Rectangle(this.x + (this.width - w) / 2, this.y + (this.height - h) / 2, w, h);\n    }\n    round(precision = 0) {\n        this.x = util.round(this.x, precision);\n        this.y = util.round(this.y, precision);\n        this.width = util.round(this.width, precision);\n        this.height = util.round(this.height, precision);\n        return this;\n    }\n    add(x, y, width, height) {\n        const rect = Rectangle.create(x, y, width, height);\n        const minX = Math.min(this.x, rect.x);\n        const minY = Math.min(this.y, rect.y);\n        const maxX = Math.max(this.x + this.width, rect.x + rect.width);\n        const maxY = Math.max(this.y + this.height, rect.y + rect.height);\n        this.x = minX;\n        this.y = minY;\n        this.width = maxX - minX;\n        this.height = maxY - minY;\n        return this;\n    }\n    update(x, y, width, height) {\n        const rect = Rectangle.create(x, y, width, height);\n        this.x = rect.x;\n        this.y = rect.y;\n        this.width = rect.width;\n        this.height = rect.height;\n        return this;\n    }\n    inflate(dx, dy) {\n        const w = dx;\n        const h = dy != null ? dy : dx;\n        this.x -= w;\n        this.y -= h;\n        this.width += 2 * w;\n        this.height += 2 * h;\n        return this;\n    }\n    snapToGrid(gx, gy) {\n        const origin = this.origin.snapToGrid(gx, gy);\n        const corner = this.corner.snapToGrid(gx, gy);\n        this.x = origin.x;\n        this.y = origin.y;\n        this.width = corner.x - origin.x;\n        this.height = corner.y - origin.y;\n        return this;\n    }\n    translate(tx, ty) {\n        const p = Point.create(tx, ty);\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    }\n    scale(sx, sy, origin = new Point()) {\n        const pos = this.origin.scale(sx, sy, origin);\n        this.x = pos.x;\n        this.y = pos.y;\n        this.width *= sx;\n        this.height *= sy;\n        return this;\n    }\n    rotate(degree, center = this.getCenter()) {\n        if (degree !== 0) {\n            const rad = Angle.toRad(degree);\n            const cos = Math.cos(rad);\n            const sin = Math.sin(rad);\n            let p1 = this.getOrigin();\n            let p2 = this.getTopRight();\n            let p3 = this.getBottomRight();\n            let p4 = this.getBottomLeft();\n            p1 = Point.rotateEx(p1, cos, sin, center);\n            p2 = Point.rotateEx(p2, cos, sin, center);\n            p3 = Point.rotateEx(p3, cos, sin, center);\n            p4 = Point.rotateEx(p4, cos, sin, center);\n            const rect = new Rectangle(p1.x, p1.y, 0, 0);\n            rect.add(p2.x, p2.y, 0, 0);\n            rect.add(p3.x, p3.y, 0, 0);\n            rect.add(p4.x, p4.y, 0, 0);\n            this.update(rect);\n        }\n        return this;\n    }\n    rotate90() {\n        const t = (this.width - this.height) / 2;\n        this.x += t;\n        this.y -= t;\n        const tmp = this.width;\n        this.width = this.height;\n        this.height = tmp;\n        return this;\n    }\n    /**\n     * Translates the rectangle by `rect.x` and `rect.y` and expand it by\n     * `rect.width` and `rect.height`.\n     */\n    moveAndExpand(rect) {\n        const ref = Rectangle.clone(rect);\n        this.x += ref.x || 0;\n        this.y += ref.y || 0;\n        this.width += ref.width || 0;\n        this.height += ref.height || 0;\n        return this;\n    }\n    /**\n     * Returns an object where `sx` and `sy` give the maximum scaling that can be\n     * applied to the rectangle so that it would still fit into `limit`. If\n     * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n     * scaled around its center.\n     */\n    getMaxScaleToFit(limit, origin = this.center) {\n        const rect = Rectangle.clone(limit);\n        const ox = origin.x;\n        const oy = origin.y;\n        // Find the maximal possible scale for all corners, so when the scale\n        // is applied the point is still inside the rectangle.\n        let sx1 = Infinity;\n        let sx2 = Infinity;\n        let sx3 = Infinity;\n        let sx4 = Infinity;\n        let sy1 = Infinity;\n        let sy2 = Infinity;\n        let sy3 = Infinity;\n        let sy4 = Infinity;\n        // Top Left\n        const p1 = rect.topLeft;\n        if (p1.x < ox) {\n            sx1 = (this.x - ox) / (p1.x - ox);\n        }\n        if (p1.y < oy) {\n            sy1 = (this.y - oy) / (p1.y - oy);\n        }\n        // Bottom Right\n        const p2 = rect.bottomRight;\n        if (p2.x > ox) {\n            sx2 = (this.x + this.width - ox) / (p2.x - ox);\n        }\n        if (p2.y > oy) {\n            sy2 = (this.y + this.height - oy) / (p2.y - oy);\n        }\n        // Top Right\n        const p3 = rect.topRight;\n        if (p3.x > ox) {\n            sx3 = (this.x + this.width - ox) / (p3.x - ox);\n        }\n        if (p3.y < oy) {\n            sy3 = (this.y - oy) / (p3.y - oy);\n        }\n        // Bottom Left\n        const p4 = rect.bottomLeft;\n        if (p4.x < ox) {\n            sx4 = (this.x - ox) / (p4.x - ox);\n        }\n        if (p4.y > oy) {\n            sy4 = (this.y + this.height - oy) / (p4.y - oy);\n        }\n        return {\n            sx: Math.min(sx1, sx2, sx3, sx4),\n            sy: Math.min(sy1, sy2, sy3, sy4),\n        };\n    }\n    /**\n     * Returns a number that specifies the maximum scaling that can be applied to\n     * the rectangle along both axes so that it would still fit into `limit`. If\n     * `origin` is specified, the rectangle is scaled around it; otherwise, it is\n     * scaled around its center.\n     */\n    getMaxUniformScaleToFit(limit, origin = this.center) {\n        const scale = this.getMaxScaleToFit(limit, origin);\n        return Math.min(scale.sx, scale.sy);\n    }\n    containsPoint(x, y) {\n        return util.containsPoint(this, Point.create(x, y));\n    }\n    containsRect(x, y, width, height) {\n        const b = Rectangle.create(x, y, width, height);\n        const x1 = this.x;\n        const y1 = this.y;\n        const w1 = this.width;\n        const h1 = this.height;\n        const x2 = b.x;\n        const y2 = b.y;\n        const w2 = b.width;\n        const h2 = b.height;\n        // one of the dimensions is 0\n        if (w1 === 0 || h1 === 0 || w2 === 0 || h2 === 0) {\n            return false;\n        }\n        return x2 >= x1 && y2 >= y1 && x2 + w2 <= x1 + w1 && y2 + h2 <= y1 + h1;\n    }\n    /**\n     * Returns an array of the intersection points of the rectangle and the line.\n     * Return `null` if no intersection exists.\n     */\n    intersectsWithLine(line) {\n        const rectLines = [\n            this.topLine,\n            this.rightLine,\n            this.bottomLine,\n            this.leftLine,\n        ];\n        const points = [];\n        const dedupeArr = [];\n        rectLines.forEach((l) => {\n            const p = line.intersectsWithLine(l);\n            if (p !== null && dedupeArr.indexOf(p.toString()) < 0) {\n                points.push(p);\n                dedupeArr.push(p.toString());\n            }\n        });\n        return points.length > 0 ? points : null;\n    }\n    /**\n     * Returns the point on the boundary of the rectangle that is the intersection\n     * of the rectangle with a line starting in the center the rectangle ending in\n     * the point `p`.\n     *\n     * If `angle` is specified, the intersection will take into account the\n     * rotation of the rectangle by `angle` degrees around its center.\n     */\n    intersectsWithLineFromCenterToPoint(p, angle) {\n        const ref = Point.clone(p);\n        const center = this.center;\n        let result = null;\n        if (angle != null && angle !== 0) {\n            ref.rotate(angle, center);\n        }\n        const sides = [this.topLine, this.rightLine, this.bottomLine, this.leftLine];\n        const connector = new Line(center, ref);\n        for (let i = sides.length - 1; i >= 0; i -= 1) {\n            const intersection = sides[i].intersectsWithLine(connector);\n            if (intersection !== null) {\n                result = intersection;\n                break;\n            }\n        }\n        if (result && angle != null && angle !== 0) {\n            result.rotate(-angle, center);\n        }\n        return result;\n    }\n    intersectsWithRect(x, y, width, height) {\n        const ref = Rectangle.create(x, y, width, height);\n        // no intersection\n        if (!this.isIntersectWithRect(ref)) {\n            return null;\n        }\n        const myOrigin = this.origin;\n        const myCorner = this.corner;\n        const rOrigin = ref.origin;\n        const rCorner = ref.corner;\n        const xx = Math.max(myOrigin.x, rOrigin.x);\n        const yy = Math.max(myOrigin.y, rOrigin.y);\n        return new Rectangle(xx, yy, Math.min(myCorner.x, rCorner.x) - xx, Math.min(myCorner.y, rCorner.y) - yy);\n    }\n    isIntersectWithRect(x, y, width, height) {\n        const ref = Rectangle.create(x, y, width, height);\n        const myOrigin = this.origin;\n        const myCorner = this.corner;\n        const rOrigin = ref.origin;\n        const rCorner = ref.corner;\n        if (rCorner.x <= myOrigin.x ||\n            rCorner.y <= myOrigin.y ||\n            rOrigin.x >= myCorner.x ||\n            rOrigin.y >= myCorner.y) {\n            return false;\n        }\n        return true;\n    }\n    /**\n     * Normalize the rectangle, i.e. make it so that it has non-negative\n     * width and height. If width is less than `0`, the function swaps left and\n     * right corners and if height is less than `0`, the top and bottom corners\n     * are swapped.\n     */\n    normalize() {\n        let newx = this.x;\n        let newy = this.y;\n        let newwidth = this.width;\n        let newheight = this.height;\n        if (this.width < 0) {\n            newx = this.x + this.width;\n            newwidth = -this.width;\n        }\n        if (this.height < 0) {\n            newy = this.y + this.height;\n            newheight = -this.height;\n        }\n        this.x = newx;\n        this.y = newy;\n        this.width = newwidth;\n        this.height = newheight;\n        return this;\n    }\n    /**\n     * Returns a rectangle that is a union of this rectangle and rectangle `rect`.\n     */\n    union(rect) {\n        const ref = Rectangle.clone(rect);\n        const myOrigin = this.origin;\n        const myCorner = this.corner;\n        const rOrigin = ref.origin;\n        const rCorner = ref.corner;\n        const originX = Math.min(myOrigin.x, rOrigin.x);\n        const originY = Math.min(myOrigin.y, rOrigin.y);\n        const cornerX = Math.max(myCorner.x, rCorner.x);\n        const cornerY = Math.max(myCorner.y, rCorner.y);\n        return new Rectangle(originX, originY, cornerX - originX, cornerY - originY);\n    }\n    /**\n     * Returns a string (\"top\", \"left\", \"right\" or \"bottom\") denoting the side of\n     * the rectangle which is nearest to the point `p`.\n     */\n    getNearestSideToPoint(p) {\n        const ref = Point.clone(p);\n        const distLeft = ref.x - this.x;\n        const distRight = this.x + this.width - ref.x;\n        const distTop = ref.y - this.y;\n        const distBottom = this.y + this.height - ref.y;\n        let closest = distLeft;\n        let side = 'left';\n        if (distRight < closest) {\n            closest = distRight;\n            side = 'right';\n        }\n        if (distTop < closest) {\n            closest = distTop;\n            side = 'top';\n        }\n        if (distBottom < closest) {\n            side = 'bottom';\n        }\n        return side;\n    }\n    /**\n     * Returns a point on the boundary of the rectangle nearest to the point `p`.\n     */\n    getNearestPointToPoint(p) {\n        const ref = Point.clone(p);\n        if (this.containsPoint(ref)) {\n            const side = this.getNearestSideToPoint(ref);\n            switch (side) {\n                case 'right':\n                    return new Point(this.x + this.width, ref.y);\n                case 'left':\n                    return new Point(this.x, ref.y);\n                case 'bottom':\n                    return new Point(ref.x, this.y + this.height);\n                case 'top':\n                    return new Point(ref.x, this.y);\n                default:\n                    break;\n            }\n        }\n        return ref.adhereToRect(this);\n    }\n    equals(rect) {\n        return (rect != null &&\n            rect.x === this.x &&\n            rect.y === this.y &&\n            rect.width === this.width &&\n            rect.height === this.height);\n    }\n    clone() {\n        return new Rectangle(this.x, this.y, this.width, this.height);\n    }\n    toJSON() {\n        return { x: this.x, y: this.y, width: this.width, height: this.height };\n    }\n    serialize() {\n        return `${this.x} ${this.y} ${this.width} ${this.height}`;\n    }\n}\n(function (Rectangle) {\n    Rectangle.toStringTag = `X6.Geometry.${Rectangle.name}`;\n    function isRectangle(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Rectangle) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const rect = instance;\n        if ((tag == null || tag === Rectangle.toStringTag) &&\n            typeof rect.x === 'number' &&\n            typeof rect.y === 'number' &&\n            typeof rect.width === 'number' &&\n            typeof rect.height === 'number' &&\n            typeof rect.inflate === 'function' &&\n            typeof rect.moveAndExpand === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Rectangle.isRectangle = isRectangle;\n})(Rectangle || (Rectangle = {}));\n(function (Rectangle) {\n    function isRectangleLike(o) {\n        return (o != null &&\n            typeof o === 'object' &&\n            typeof o.x === 'number' &&\n            typeof o.y === 'number' &&\n            typeof o.width === 'number' &&\n            typeof o.height === 'number');\n    }\n    Rectangle.isRectangleLike = isRectangleLike;\n})(Rectangle || (Rectangle = {}));\n(function (Rectangle) {\n    function create(x, y, width, height) {\n        if (x == null || typeof x === 'number') {\n            return new Rectangle(x, y, width, height);\n        }\n        return clone(x);\n    }\n    Rectangle.create = create;\n    function clone(rect) {\n        if (Rectangle.isRectangle(rect)) {\n            return rect.clone();\n        }\n        if (Array.isArray(rect)) {\n            return new Rectangle(rect[0], rect[1], rect[2], rect[3]);\n        }\n        return new Rectangle(rect.x, rect.y, rect.width, rect.height);\n    }\n    Rectangle.clone = clone;\n    function fromSize(size) {\n        return new Rectangle(0, 0, size.width, size.height);\n    }\n    Rectangle.fromSize = fromSize;\n    function fromPositionAndSize(pos, size) {\n        return new Rectangle(pos.x, pos.y, size.width, size.height);\n    }\n    Rectangle.fromPositionAndSize = fromPositionAndSize;\n    /**\n     * Returns a new rectangle from the given ellipse.\n     */\n    function fromEllipse(ellipse) {\n        return new Rectangle(ellipse.x - ellipse.a, ellipse.y - ellipse.b, 2 * ellipse.a, 2 * ellipse.b);\n    }\n    Rectangle.fromEllipse = fromEllipse;\n})(Rectangle || (Rectangle = {}));\n//# sourceMappingURL=rectangle.js.map"]},"metadata":{},"sourceType":"module"}