{"ast":null,"code":"export var Scheduler;\n\n(function (Scheduler) {\n  var queue = [];\n  var threshold = 1000 / 60;\n  var unit = [];\n  var deadline = 0;\n\n  var getTime = function getTime() {\n    return performance.now();\n  };\n\n  var peek = function peek(queue) {\n    return queue[0];\n  };\n\n  var schedule = function schedule(cb) {\n    return unit.push(cb) === 1 && postMessage();\n  };\n\n  var postMessage = function () {\n    var cb = function cb() {\n      return unit.splice(0, unit.length).forEach(function (c) {\n        return c();\n      });\n    };\n\n    if (typeof MessageChannel !== 'undefined') {\n      var _MessageChannel = new MessageChannel(),\n          port1 = _MessageChannel.port1,\n          port2 = _MessageChannel.port2;\n\n      port1.onmessage = cb;\n      return function () {\n        return port2.postMessage(null);\n      };\n    }\n\n    return function () {\n      return setTimeout(cb);\n    };\n  }();\n\n  var flushTask = function flushTask() {\n    deadline = getTime() + threshold;\n    var job = peek(queue);\n\n    while (job && !Scheduler.shouldYield()) {\n      var _job = job,\n          callback = _job.callback,\n          data = _job.data;\n      job.callback = null;\n      var next = callback && callback(data);\n\n      if (next) {\n        job.callback = next;\n      } else {\n        queue.shift();\n      }\n\n      job = peek(queue);\n    }\n\n    job && schedule(flushTask);\n  };\n\n  Scheduler.scheduleTask = function (callback, data) {\n    var task = {\n      callback: callback,\n      data: data\n    };\n    queue.push(task);\n    schedule(flushTask);\n  };\n\n  Scheduler.shouldYield = function () {\n    var _a, _b;\n\n    return ((_b = (_a = navigator) === null || _a === void 0 ? void 0 : _a.scheduling) === null || _b === void 0 ? void 0 : _b.isInputPending()) || getTime() >= deadline;\n  };\n})(Scheduler || (Scheduler = {}));","map":{"version":3,"sources":["../../../src/util/scheduler/index.ts"],"names":[],"mappings":"AAAA,OAAM,IAAW,SAAX;;AAAN,CAAA,UAAiB,SAAjB,EAA0B;AASxB,MAAM,KAAK,GAAY,EAAvB;AACA,MAAM,SAAS,GAAW,OAAO,EAAjC;AACA,MAAM,IAAI,GAAkB,EAA5B;AACA,MAAI,QAAQ,GAAG,CAAf;;AAEA,MAAM,OAAO,GAAG,SAAV,OAAU;AAAA,WAAM,WAAW,CAAC,GAAZ,EAAN;AAAA,GAAhB;;AACA,MAAM,IAAI,GAAG,SAAP,IAAO,CAAC,KAAD;AAAA,WAAoB,KAAK,CAAC,CAAD,CAAzB;AAAA,GAAb;;AACA,MAAM,QAAQ,GAAG,SAAX,QAAW,CAAC,EAAD;AAAA,WAAqB,IAAI,CAAC,IAAL,CAAU,EAAV,MAAkB,CAAlB,IAAuB,WAAW,EAAvD;AAAA,GAAjB;;AAEA,MAAM,WAAW,GAAI,YAAK;AACxB,QAAM,EAAE,GAAG,SAAL,EAAK;AAAA,aAAM,IAAI,CAAC,MAAL,CAAY,CAAZ,EAAe,IAAI,CAAC,MAApB,EAA4B,OAA5B,CAAoC,UAAC,CAAD;AAAA,eAAO,CAAC,EAAR;AAAA,OAApC,CAAN;AAAA,KAAX;;AACA,QAAI,OAAO,cAAP,KAA0B,WAA9B,EAA2C;AACzC,4BAAyB,IAAI,cAAJ,EAAzB;AAAA,UAAQ,KAAR,mBAAQ,KAAR;AAAA,UAAe,KAAf,mBAAe,KAAf;;AACA,MAAA,KAAK,CAAC,SAAN,GAAkB,EAAlB;AACA,aAAO;AAAA,eAAM,KAAK,CAAC,WAAN,CAAkB,IAAlB,CAAN;AAAA,OAAP;AACD;;AACD,WAAO;AAAA,aAAM,UAAU,CAAC,EAAD,CAAhB;AAAA,KAAP;AACD,GARmB,EAApB;;AAUA,MAAM,SAAS,GAAG,SAAZ,SAAY,GAAK;AACrB,IAAA,QAAQ,GAAG,OAAO,KAAK,SAAvB;AACA,QAAI,GAAG,GAAG,IAAI,CAAC,KAAD,CAAd;;AACA,WAAO,GAAG,IAAI,CAAC,SAAA,CAAA,WAAA,EAAf,EAA8B;AAC5B,iBAA2B,GAA3B;AAAA,UAAQ,QAAR,QAAQ,QAAR;AAAA,UAAkB,IAAlB,QAAkB,IAAlB;AACA,MAAA,GAAG,CAAC,QAAJ,GAAe,IAAf;AACA,UAAM,IAAI,GAAG,QAAQ,IAAI,QAAQ,CAAC,IAAD,CAAjC;;AACA,UAAI,IAAJ,EAAU;AACR,QAAA,GAAG,CAAC,QAAJ,GAAe,IAAf;AACD,OAFD,MAEO;AACL,QAAA,KAAK,CAAC,KAAN;AACD;;AACD,MAAA,GAAG,GAAG,IAAI,CAAC,KAAD,CAAV;AACD;;AACD,IAAA,GAAG,IAAI,QAAQ,CAAC,SAAD,CAAf;AACD,GAfD;;AAiBa,EAAA,SAAA,CAAA,YAAA,GAAe,UAAC,QAAD,EAA0B,IAA1B,EAAwC;AAClE,QAAM,IAAI,GAAG;AACX,MAAA,QAAQ,EAAR,QADW;AAEX,MAAA,IAAI,EAAJ;AAFW,KAAb;AAIA,IAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,IAAA,QAAQ,CAAC,SAAD,CAAR;AACD,GAPY;;AASA,EAAA,SAAA,CAAA,WAAA,GAAc,YAAc;;;AACvC,WACE,CAAA,CAAA,EAAA,GAAA,CAAA,EAAA,GAAC,SAAD,MAAkB,IAAlB,IAAkB,EAAA,KAAA,KAAA,CAAlB,GAAkB,KAAA,CAAlB,GAAkB,EAAA,CAAE,UAApB,MAA8B,IAA9B,IAA8B,EAAA,KAAA,KAAA,CAA9B,GAA8B,KAAA,CAA9B,GAA8B,EAAA,CAAE,cAAF,EAA9B,KAAoD,OAAO,MAAM,QADnE;AAGD,GAJY;AAKd,CA3DD,EAAiB,SAAS,KAAT,SAAS,GAAA,EAAA,CAA1B","sourceRoot":"","sourcesContent":["export var Scheduler;\n(function (Scheduler) {\n    const queue = [];\n    const threshold = 1000 / 60;\n    const unit = [];\n    let deadline = 0;\n    const getTime = () => performance.now();\n    const peek = (queue) => queue[0];\n    const schedule = (cb) => unit.push(cb) === 1 && postMessage();\n    const postMessage = (() => {\n        const cb = () => unit.splice(0, unit.length).forEach((c) => c());\n        if (typeof MessageChannel !== 'undefined') {\n            const { port1, port2 } = new MessageChannel();\n            port1.onmessage = cb;\n            return () => port2.postMessage(null);\n        }\n        return () => setTimeout(cb);\n    })();\n    const flushTask = () => {\n        deadline = getTime() + threshold;\n        let job = peek(queue);\n        while (job && !Scheduler.shouldYield()) {\n            const { callback, data } = job;\n            job.callback = null;\n            const next = callback && callback(data);\n            if (next) {\n                job.callback = next;\n            }\n            else {\n                queue.shift();\n            }\n            job = peek(queue);\n        }\n        job && schedule(flushTask);\n    };\n    Scheduler.scheduleTask = (callback, data) => {\n        const task = {\n            callback,\n            data,\n        };\n        queue.push(task);\n        schedule(flushTask);\n    };\n    Scheduler.shouldYield = () => {\n        var _a, _b;\n        return (((_b = (_a = navigator) === null || _a === void 0 ? void 0 : _a.scheduling) === null || _b === void 0 ? void 0 : _b.isInputPending()) || getTime() >= deadline);\n    };\n})(Scheduler || (Scheduler = {}));\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}