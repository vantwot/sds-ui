{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Geometry } from './geometry';\nexport var Ellipse = /*#__PURE__*/function (_Geometry, _Symbol$toStringTag) {\n  _inherits(Ellipse, _Geometry);\n\n  var _super = _createSuper(Ellipse);\n\n  function Ellipse(x, y, a, b) {\n    var _this;\n\n    _classCallCheck(this, Ellipse);\n\n    _this = _super.call(this);\n    _this.x = x == null ? 0 : x;\n    _this.y = y == null ? 0 : y;\n    _this.a = a == null ? 0 : a;\n    _this.b = b == null ? 0 : b;\n    return _this;\n  }\n\n  _createClass(Ellipse, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Ellipse.toStringTag;\n    }\n  }, {\n    key: \"center\",\n    get: function get() {\n      return new Point(this.x, this.y);\n    }\n    /**\n     * Returns a rectangle that is the bounding box of the ellipse.\n     */\n\n  }, {\n    key: \"bbox\",\n    value: function bbox() {\n      return Rectangle.fromEllipse(this);\n    }\n    /**\n     * Returns a point that is the center of the ellipse.\n     */\n\n  }, {\n    key: \"getCenter\",\n    value: function getCenter() {\n      return this.center;\n    }\n  }, {\n    key: \"inflate\",\n    value: function inflate(dx, dy) {\n      var w = dx;\n      var h = dy != null ? dy : dx;\n      this.a += 2 * w;\n      this.b += 2 * h;\n      return this;\n    }\n  }, {\n    key: \"normalizedDistance\",\n    value: function normalizedDistance(x, y) {\n      var ref = Point.create(x, y);\n      var dx = ref.x - this.x;\n      var dy = ref.y - this.y;\n      var a = this.a;\n      var b = this.b;\n      return dx * dx / (a * a) + dy * dy / (b * b);\n    }\n  }, {\n    key: \"containsPoint\",\n    value: function containsPoint(x, y) {\n      return this.normalizedDistance(x, y) <= 1;\n    }\n    /**\n     * Returns an array of the intersection points of the ellipse and the line.\n     * Returns `null` if no intersection exists.\n     */\n\n  }, {\n    key: \"intersectsWithLine\",\n    value: function intersectsWithLine(line) {\n      var intersections = [];\n      var rx = this.a;\n      var ry = this.b;\n      var a1 = line.start;\n      var a2 = line.end;\n      var dir = line.vector();\n      var diff = a1.diff(new Point(this.x, this.y));\n      var mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n      var mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n      var a = dir.dot(mDir);\n      var b = dir.dot(mDiff);\n      var c = diff.dot(mDiff) - 1.0;\n      var d = b * b - a * c;\n\n      if (d < 0) {\n        return null;\n      }\n\n      if (d > 0) {\n        var root = Math.sqrt(d);\n        var ta = (-b - root) / a;\n        var tb = (-b + root) / a;\n\n        if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n          // outside\n          return null;\n        }\n\n        if (ta >= 0 && ta <= 1) {\n          intersections.push(a1.lerp(a2, ta));\n        }\n\n        if (tb >= 0 && tb <= 1) {\n          intersections.push(a1.lerp(a2, tb));\n        }\n      } else {\n        var t = -b / a;\n\n        if (t >= 0 && t <= 1) {\n          intersections.push(a1.lerp(a2, t));\n        } else {\n          // outside\n          return null;\n        }\n      }\n\n      return intersections;\n    }\n    /**\n     * Returns the point on the boundary of the ellipse that is the\n     * intersection of the ellipse with a line starting in the center\n     * of the ellipse ending in the point `p`.\n     *\n     * If angle is specified, the intersection will take into account\n     * the rotation of the ellipse by angle degrees around its center.\n     */\n\n  }, {\n    key: \"intersectsWithLineFromCenterToPoint\",\n    value: function intersectsWithLineFromCenterToPoint(p) {\n      var angle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var ref = Point.clone(p);\n\n      if (angle) {\n        ref.rotate(angle, this.getCenter());\n      }\n\n      var dx = ref.x - this.x;\n      var dy = ref.y - this.y;\n      var result;\n\n      if (dx === 0) {\n        result = this.bbox().getNearestPointToPoint(ref);\n\n        if (angle) {\n          return result.rotate(-angle, this.getCenter());\n        }\n\n        return result;\n      }\n\n      var m = dy / dx;\n      var mSquared = m * m;\n      var aSquared = this.a * this.a;\n      var bSquared = this.b * this.b;\n      var x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));\n      x = dx < 0 ? -x : x;\n      var y = m * x;\n      result = new Point(this.x + x, this.y + y);\n\n      if (angle) {\n        return result.rotate(-angle, this.getCenter());\n      }\n\n      return result;\n    }\n    /**\n     * Returns the angle between the x-axis and the tangent from a point. It is\n     * valid for points lying on the ellipse boundary only.\n     */\n\n  }, {\n    key: \"tangentTheta\",\n    value: function tangentTheta(p) {\n      var ref = Point.clone(p);\n      var x0 = ref.x;\n      var y0 = ref.y;\n      var a = this.a;\n      var b = this.b;\n      var center = this.bbox().center;\n      var cx = center.x;\n      var cy = center.y;\n      var refPointDelta = 30;\n      var q1 = x0 > center.x + a / 2;\n      var q3 = x0 < center.x - a / 2;\n      var x;\n      var y;\n\n      if (q1 || q3) {\n        y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n        x = a * a / (x0 - cx) - a * a * (y0 - cy) * (y - cy) / (b * b * (x0 - cx)) + cx;\n      } else {\n        x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n        y = b * b / (y0 - cy) - b * b * (x0 - cx) * (x - cx) / (a * a * (y0 - cy)) + cy;\n      }\n\n      return new Point(x, y).theta(ref);\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy) {\n      this.a *= sx;\n      this.b *= sy;\n      return this;\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle, origin) {\n      var rect = Rectangle.fromEllipse(this);\n      rect.rotate(angle, origin);\n      var ellipse = Ellipse.fromRect(rect);\n      this.a = ellipse.a;\n      this.b = ellipse.b;\n      this.x = ellipse.x;\n      this.y = ellipse.y;\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate(dx, dy) {\n      var p = Point.create(dx, dy);\n      this.x += p.x;\n      this.y += p.y;\n      return this;\n    }\n  }, {\n    key: \"equals\",\n    value: function equals(ellipse) {\n      return ellipse != null && ellipse.x === this.x && ellipse.y === this.y && ellipse.a === this.a && ellipse.b === this.b;\n    }\n  }, {\n    key: \"clone\",\n    value: function clone() {\n      return new Ellipse(this.x, this.y, this.a, this.b);\n    }\n  }, {\n    key: \"toJSON\",\n    value: function toJSON() {\n      return {\n        x: this.x,\n        y: this.y,\n        a: this.a,\n        b: this.b\n      };\n    }\n  }, {\n    key: \"serialize\",\n    value: function serialize() {\n      return \"\".concat(this.x, \" \").concat(this.y, \" \").concat(this.a, \" \").concat(this.b);\n    }\n  }]);\n\n  return Ellipse;\n}(Geometry, Symbol.toStringTag);\n\n(function (Ellipse) {\n  Ellipse.toStringTag = \"X6.Geometry.\".concat(Ellipse.name);\n\n  function isEllipse(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Ellipse) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var ellipse = instance;\n\n    if ((tag == null || tag === Ellipse.toStringTag) && typeof ellipse.x === 'number' && typeof ellipse.y === 'number' && typeof ellipse.a === 'number' && typeof ellipse.b === 'number' && typeof ellipse.inflate === 'function' && typeof ellipse.normalizedDistance === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Ellipse.isEllipse = isEllipse;\n})(Ellipse || (Ellipse = {}));\n\n(function (Ellipse) {\n  function create(x, y, a, b) {\n    if (x == null || typeof x === 'number') {\n      return new Ellipse(x, y, a, b);\n    }\n\n    return parse(x);\n  }\n\n  Ellipse.create = create;\n\n  function parse(e) {\n    if (Ellipse.isEllipse(e)) {\n      return e.clone();\n    }\n\n    if (Array.isArray(e)) {\n      return new Ellipse(e[0], e[1], e[2], e[3]);\n    }\n\n    return new Ellipse(e.x, e.y, e.a, e.b);\n  }\n\n  Ellipse.parse = parse;\n\n  function fromRect(rect) {\n    var center = rect.center;\n    return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);\n  }\n\n  Ellipse.fromRect = fromRect;\n})(Ellipse || (Ellipse = {}));","map":{"version":3,"sources":["../../src/geometry/ellipse.ts"],"names":[],"mappings":";;;;AAAA,SAAS,KAAT,QAAsB,SAAtB;AAEA,SAAS,SAAT,QAA0B,aAA1B;AACA,SAAS,QAAT,QAAyB,YAAzB;AAEA,WAAa,OAAb;AAAA;;AAAA;;AAcE,mBAAY,CAAZ,EAAwB,CAAxB,EAAoC,CAApC,EAAgD,CAAhD,EAA0D;AAAA;;AAAA;;AACxD;AACA,UAAK,CAAL,GAAS,CAAC,IAAI,IAAL,GAAY,CAAZ,GAAgB,CAAzB;AACA,UAAK,CAAL,GAAS,CAAC,IAAI,IAAL,GAAY,CAAZ,GAAgB,CAAzB;AACA,UAAK,CAAL,GAAS,CAAC,IAAI,IAAL,GAAY,CAAZ,GAAgB,CAAzB;AACA,UAAK,CAAL,GAAS,CAAC,IAAI,IAAL,GAAY,CAAZ,GAAgB,CAAzB;AALwD;AAMzD;;AApBH;AAAA;AAAA,SAME,eAAkC;AAChC,aAAO,OAAO,CAAC,WAAf;AACD;AARH;AAAA;AAAA,SAUE,eAAU;AACR,aAAO,IAAI,KAAJ,CAAU,KAAK,CAAf,EAAkB,KAAK,CAAvB,CAAP;AACD;AAUD;;AAEG;;AAxBL;AAAA;AAAA,WAyBE,gBAAI;AACF,aAAO,SAAS,CAAC,WAAV,CAAsB,IAAtB,CAAP;AACD;AAED;;AAEG;;AA/BL;AAAA;AAAA,WAgCE,qBAAS;AACP,aAAO,KAAK,MAAZ;AACD;AAlCH;AAAA;AAAA,WA6CE,iBAAQ,EAAR,EAAoB,EAApB,EAA+B;AAC7B,UAAM,CAAC,GAAG,EAAV;AACA,UAAM,CAAC,GAAG,EAAE,IAAI,IAAN,GAAa,EAAb,GAAkB,EAA5B;AACA,WAAK,CAAL,IAAU,IAAI,CAAd;AACA,WAAK,CAAL,IAAU,IAAI,CAAd;AAEA,aAAO,IAAP;AACD;AApDH;AAAA;AAAA,WA6DE,4BACE,CADF,EAEE,CAFF,EAEY;AAEV,UAAM,GAAG,GAAG,KAAK,CAAC,MAAN,CAAa,CAAb,EAAgB,CAAhB,CAAZ;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAJ,GAAQ,KAAK,CAAxB;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAJ,GAAQ,KAAK,CAAxB;AACA,UAAM,CAAC,GAAG,KAAK,CAAf;AACA,UAAM,CAAC,GAAG,KAAK,CAAf;AAEA,aAAQ,EAAE,GAAG,EAAN,IAAa,CAAC,GAAG,CAAjB,IAAuB,EAAE,GAAG,EAAN,IAAa,CAAC,GAAG,CAAjB,CAA7B;AACD;AAxEH;AAAA;AAAA,WAgFE,uBAAc,CAAd,EAA6D,CAA7D,EAAuE;AACrE,aAAO,KAAK,kBAAL,CAAwB,CAAxB,EAAqC,CAArC,KAAqD,CAA5D;AACD;AAED;;;AAGG;;AAvFL;AAAA;AAAA,WAwFE,4BAAmB,IAAnB,EAA6B;AAC3B,UAAM,aAAa,GAAG,EAAtB;AACA,UAAM,EAAE,GAAG,KAAK,CAAhB;AACA,UAAM,EAAE,GAAG,KAAK,CAAhB;AACA,UAAM,EAAE,GAAG,IAAI,CAAC,KAAhB;AACA,UAAM,EAAE,GAAG,IAAI,CAAC,GAAhB;AACA,UAAM,GAAG,GAAG,IAAI,CAAC,MAAL,EAAZ;AACA,UAAM,IAAI,GAAG,EAAE,CAAC,IAAH,CAAQ,IAAI,KAAJ,CAAU,KAAK,CAAf,EAAkB,KAAK,CAAvB,CAAR,CAAb;AACA,UAAM,IAAI,GAAG,IAAI,KAAJ,CAAU,GAAG,CAAC,CAAJ,IAAS,EAAE,GAAG,EAAd,CAAV,EAA6B,GAAG,CAAC,CAAJ,IAAS,EAAE,GAAG,EAAd,CAA7B,CAAb;AACA,UAAM,KAAK,GAAG,IAAI,KAAJ,CAAU,IAAI,CAAC,CAAL,IAAU,EAAE,GAAG,EAAf,CAAV,EAA8B,IAAI,CAAC,CAAL,IAAU,EAAE,GAAG,EAAf,CAA9B,CAAd;AAEA,UAAM,CAAC,GAAG,GAAG,CAAC,GAAJ,CAAQ,IAAR,CAAV;AACA,UAAM,CAAC,GAAG,GAAG,CAAC,GAAJ,CAAQ,KAAR,CAAV;AACA,UAAM,CAAC,GAAG,IAAI,CAAC,GAAL,CAAS,KAAT,IAAkB,GAA5B;AACA,UAAM,CAAC,GAAG,CAAC,GAAG,CAAJ,GAAQ,CAAC,GAAG,CAAtB;;AAEA,UAAI,CAAC,GAAG,CAAR,EAAW;AACT,eAAO,IAAP;AACD;;AAED,UAAI,CAAC,GAAG,CAAR,EAAW;AACT,YAAM,IAAI,GAAG,IAAI,CAAC,IAAL,CAAU,CAAV,CAAb;AACA,YAAM,EAAE,GAAG,CAAC,CAAC,CAAD,GAAK,IAAN,IAAc,CAAzB;AACA,YAAM,EAAE,GAAG,CAAC,CAAC,CAAD,GAAK,IAAN,IAAc,CAAzB;;AAEA,YAAI,CAAC,EAAE,GAAG,CAAL,IAAU,EAAE,GAAG,CAAhB,MAAuB,EAAE,GAAG,CAAL,IAAU,EAAE,GAAG,CAAtC,CAAJ,EAA8C;AAC5C;AACA,iBAAO,IAAP;AACD;;AAED,YAAI,EAAE,IAAI,CAAN,IAAW,EAAE,IAAI,CAArB,EAAwB;AACtB,UAAA,aAAa,CAAC,IAAd,CAAmB,EAAE,CAAC,IAAH,CAAQ,EAAR,EAAY,EAAZ,CAAnB;AACD;;AAED,YAAI,EAAE,IAAI,CAAN,IAAW,EAAE,IAAI,CAArB,EAAwB;AACtB,UAAA,aAAa,CAAC,IAAd,CAAmB,EAAE,CAAC,IAAH,CAAQ,EAAR,EAAY,EAAZ,CAAnB;AACD;AACF,OAjBD,MAiBO;AACL,YAAM,CAAC,GAAG,CAAC,CAAD,GAAK,CAAf;;AACA,YAAI,CAAC,IAAI,CAAL,IAAU,CAAC,IAAI,CAAnB,EAAsB;AACpB,UAAA,aAAa,CAAC,IAAd,CAAmB,EAAE,CAAC,IAAH,CAAQ,EAAR,EAAY,CAAZ,CAAnB;AACD,SAFD,MAEO;AACL;AACA,iBAAO,IAAP;AACD;AACF;;AAED,aAAO,aAAP;AACD;AAED;;;;;;;AAOG;;AAjJL;AAAA;AAAA,WAkJE,6CACE,CADF,EAEW;AAAA,UAAT,KAAS,uEAAD,CAAC;AAET,UAAM,GAAG,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAZ;;AACA,UAAI,KAAJ,EAAW;AACT,QAAA,GAAG,CAAC,MAAJ,CAAW,KAAX,EAAkB,KAAK,SAAL,EAAlB;AACD;;AAED,UAAM,EAAE,GAAG,GAAG,CAAC,CAAJ,GAAQ,KAAK,CAAxB;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAJ,GAAQ,KAAK,CAAxB;AACA,UAAI,MAAJ;;AAEA,UAAI,EAAE,KAAK,CAAX,EAAc;AACZ,QAAA,MAAM,GAAG,KAAK,IAAL,GAAY,sBAAZ,CAAmC,GAAnC,CAAT;;AACA,YAAI,KAAJ,EAAW;AACT,iBAAO,MAAM,CAAC,MAAP,CAAc,CAAC,KAAf,EAAsB,KAAK,SAAL,EAAtB,CAAP;AACD;;AACD,eAAO,MAAP;AACD;;AAED,UAAM,CAAC,GAAG,EAAE,GAAG,EAAf;AACA,UAAM,QAAQ,GAAG,CAAC,GAAG,CAArB;AACA,UAAM,QAAQ,GAAG,KAAK,CAAL,GAAS,KAAK,CAA/B;AACA,UAAM,QAAQ,GAAG,KAAK,CAAL,GAAS,KAAK,CAA/B;AAEA,UAAI,CAAC,GAAG,IAAI,CAAC,IAAL,CAAU,KAAK,IAAI,QAAJ,GAAe,QAAQ,GAAG,QAA/B,CAAV,CAAR;AACA,MAAA,CAAC,GAAG,EAAE,GAAG,CAAL,GAAS,CAAC,CAAV,GAAc,CAAlB;AAEA,UAAM,CAAC,GAAG,CAAC,GAAG,CAAd;AACA,MAAA,MAAM,GAAG,IAAI,KAAJ,CAAU,KAAK,CAAL,GAAS,CAAnB,EAAsB,KAAK,CAAL,GAAS,CAA/B,CAAT;;AAEA,UAAI,KAAJ,EAAW;AACT,eAAO,MAAM,CAAC,MAAP,CAAc,CAAC,KAAf,EAAsB,KAAK,SAAL,EAAtB,CAAP;AACD;;AAED,aAAO,MAAP;AACD;AAED;;;AAGG;;AA5LL;AAAA;AAAA,WA6LE,sBAAa,CAAb,EAAiD;AAC/C,UAAM,GAAG,GAAG,KAAK,CAAC,KAAN,CAAY,CAAZ,CAAZ;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAf;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAf;AACA,UAAM,CAAC,GAAG,KAAK,CAAf;AACA,UAAM,CAAC,GAAG,KAAK,CAAf;AACA,UAAM,MAAM,GAAG,KAAK,IAAL,GAAY,MAA3B;AACA,UAAM,EAAE,GAAG,MAAM,CAAC,CAAlB;AACA,UAAM,EAAE,GAAG,MAAM,CAAC,CAAlB;AACA,UAAM,aAAa,GAAG,EAAtB;AAEA,UAAM,EAAE,GAAG,EAAE,GAAG,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,CAA/B;AACA,UAAM,EAAE,GAAG,EAAE,GAAG,MAAM,CAAC,CAAP,GAAW,CAAC,GAAG,CAA/B;AAEA,UAAI,CAAJ;AACA,UAAI,CAAJ;;AAEA,UAAI,EAAE,IAAI,EAAV,EAAc;AACZ,QAAA,CAAC,GAAG,EAAE,GAAG,MAAM,CAAC,CAAZ,GAAgB,EAAE,GAAG,aAArB,GAAqC,EAAE,GAAG,aAA9C;AACA,QAAA,CAAC,GACE,CAAC,GAAG,CAAL,IAAW,EAAE,GAAG,EAAhB,IACC,CAAC,GAAG,CAAJ,IAAS,EAAE,GAAG,EAAd,KAAqB,CAAC,GAAG,EAAzB,CAAD,IAAkC,CAAC,GAAG,CAAJ,IAAS,EAAE,GAAG,EAAd,CAAlC,CADA,GAEA,EAHF;AAID,OAND,MAMO;AACL,QAAA,CAAC,GAAG,EAAE,GAAG,MAAM,CAAC,CAAZ,GAAgB,EAAE,GAAG,aAArB,GAAqC,EAAE,GAAG,aAA9C;AACA,QAAA,CAAC,GACE,CAAC,GAAG,CAAL,IAAW,EAAE,GAAG,EAAhB,IACC,CAAC,GAAG,CAAJ,IAAS,EAAE,GAAG,EAAd,KAAqB,CAAC,GAAG,EAAzB,CAAD,IAAkC,CAAC,GAAG,CAAJ,IAAS,EAAE,GAAG,EAAd,CAAlC,CADA,GAEA,EAHF;AAID;;AAED,aAAO,IAAI,KAAJ,CAAU,CAAV,EAAa,CAAb,EAAgB,KAAhB,CAAsB,GAAtB,CAAP;AACD;AA7NH;AAAA;AAAA,WA+NE,eAAM,EAAN,EAAkB,EAAlB,EAA4B;AAC1B,WAAK,CAAL,IAAU,EAAV;AACA,WAAK,CAAL,IAAU,EAAV;AACA,aAAO,IAAP;AACD;AAnOH;AAAA;AAAA,WAqOE,gBAAO,KAAP,EAAsB,MAAtB,EAAgE;AAC9D,UAAM,IAAI,GAAG,SAAS,CAAC,WAAV,CAAsB,IAAtB,CAAb;AACA,MAAA,IAAI,CAAC,MAAL,CAAY,KAAZ,EAAmB,MAAnB;AACA,UAAM,OAAO,GAAG,OAAO,CAAC,QAAR,CAAiB,IAAjB,CAAhB;AACA,WAAK,CAAL,GAAS,OAAO,CAAC,CAAjB;AACA,WAAK,CAAL,GAAS,OAAO,CAAC,CAAjB;AACA,WAAK,CAAL,GAAS,OAAO,CAAC,CAAjB;AACA,WAAK,CAAL,GAAS,OAAO,CAAC,CAAjB;AACA,aAAO,IAAP;AACD;AA9OH;AAAA;AAAA,WAkPE,mBAAU,EAAV,EAA0D,EAA1D,EAAqE;AACnE,UAAM,CAAC,GAAG,KAAK,CAAC,MAAN,CAAa,EAAb,EAAiB,EAAjB,CAAV;AACA,WAAK,CAAL,IAAU,CAAC,CAAC,CAAZ;AACA,WAAK,CAAL,IAAU,CAAC,CAAC,CAAZ;AACA,aAAO,IAAP;AACD;AAvPH;AAAA;AAAA,WAyPE,gBAAO,OAAP,EAAuB;AACrB,aACE,OAAO,IAAI,IAAX,IACA,OAAO,CAAC,CAAR,KAAc,KAAK,CADnB,IAEA,OAAO,CAAC,CAAR,KAAc,KAAK,CAFnB,IAGA,OAAO,CAAC,CAAR,KAAc,KAAK,CAHnB,IAIA,OAAO,CAAC,CAAR,KAAc,KAAK,CALrB;AAOD;AAjQH;AAAA;AAAA,WAmQE,iBAAK;AACH,aAAO,IAAI,OAAJ,CAAY,KAAK,CAAjB,EAAoB,KAAK,CAAzB,EAA4B,KAAK,CAAjC,EAAoC,KAAK,CAAzC,CAAP;AACD;AArQH;AAAA;AAAA,WAuQE,kBAAM;AACJ,aAAO;AAAE,QAAA,CAAC,EAAE,KAAK,CAAV;AAAa,QAAA,CAAC,EAAE,KAAK,CAArB;AAAwB,QAAA,CAAC,EAAE,KAAK,CAAhC;AAAmC,QAAA,CAAC,EAAE,KAAK;AAA3C,OAAP;AACD;AAzQH;AAAA;AAAA,WA2QE,qBAAS;AACP,uBAAU,KAAK,CAAf,cAAoB,KAAK,CAAzB,cAA8B,KAAK,CAAnC,cAAwC,KAAK,CAA7C;AACD;AA7QH;;AAAA;AAAA,EAA6B,QAA7B,EAMiB,MAAM,CAAC,WANxB;;AAgRA,CAAA,UAAiB,OAAjB,EAAwB;AACT,EAAA,OAAA,CAAA,WAAA,yBAA6B,OAAO,CAAC,IAArC;;AAEb,WAAgB,SAAhB,CAA0B,QAA1B,EAAuC;AACrC,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAO,KAAP;AACD;;AAED,QAAI,QAAQ,YAAY,OAAxB,EAAiC;AAC/B,aAAO,IAAP;AACD;;AAED,QAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,WAAR,CAApB;AACA,QAAM,OAAO,GAAG,QAAhB;;AAEA,QACE,CAAC,GAAG,IAAI,IAAP,IAAe,GAAG,KAAK,OAAA,CAAA,WAAxB,KACA,OAAO,OAAO,CAAC,CAAf,KAAqB,QADrB,IAEA,OAAO,OAAO,CAAC,CAAf,KAAqB,QAFrB,IAGA,OAAO,OAAO,CAAC,CAAf,KAAqB,QAHrB,IAIA,OAAO,OAAO,CAAC,CAAf,KAAqB,QAJrB,IAKA,OAAO,OAAO,CAAC,OAAf,KAA2B,UAL3B,IAMA,OAAO,OAAO,CAAC,kBAAf,KAAsC,UAPxC,EAQE;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD;;AAzBe,EAAA,OAAA,CAAA,SAAA,GAAS,SAAT;AA0BjB,CA7BD,EAAiB,OAAO,KAAP,OAAO,GAAA,EAAA,CAAxB;;AA0CA,CAAA,UAAiB,OAAjB,EAAwB;AACtB,WAAgB,MAAhB,CACE,CADF,EAEE,CAFF,EAGE,CAHF,EAIE,CAJF,EAIY;AAEV,QAAI,CAAC,IAAI,IAAL,IAAa,OAAO,CAAP,KAAa,QAA9B,EAAwC;AACtC,aAAO,IAAI,OAAJ,CAAY,CAAZ,EAAe,CAAf,EAAkB,CAAlB,EAAqB,CAArB,CAAP;AACD;;AAED,WAAO,KAAK,CAAC,CAAD,CAAZ;AACD;;AAXe,EAAA,OAAA,CAAA,MAAA,GAAM,MAAN;;AAahB,WAAgB,KAAhB,CAAsB,CAAtB,EAA4D;AAC1D,QAAI,OAAO,CAAC,SAAR,CAAkB,CAAlB,CAAJ,EAA0B;AACxB,aAAO,CAAC,CAAC,KAAF,EAAP;AACD;;AAED,QAAI,KAAK,CAAC,OAAN,CAAc,CAAd,CAAJ,EAAsB;AACpB,aAAO,IAAI,OAAJ,CAAY,CAAC,CAAC,CAAD,CAAb,EAAkB,CAAC,CAAC,CAAD,CAAnB,EAAwB,CAAC,CAAC,CAAD,CAAzB,EAA8B,CAAC,CAAC,CAAD,CAA/B,CAAP;AACD;;AAED,WAAO,IAAI,OAAJ,CAAY,CAAC,CAAC,CAAd,EAAiB,CAAC,CAAC,CAAnB,EAAsB,CAAC,CAAC,CAAxB,EAA2B,CAAC,CAAC,CAA7B,CAAP;AACD;;AAVe,EAAA,OAAA,CAAA,KAAA,GAAK,KAAL;;AAYhB,WAAgB,QAAhB,CAAyB,IAAzB,EAAwC;AACtC,QAAM,MAAM,GAAG,IAAI,CAAC,MAApB;AACA,WAAO,IAAI,OAAJ,CAAY,MAAM,CAAC,CAAnB,EAAsB,MAAM,CAAC,CAA7B,EAAgC,IAAI,CAAC,KAAL,GAAa,CAA7C,EAAgD,IAAI,CAAC,MAAL,GAAc,CAA9D,CAAP;AACD;;AAHe,EAAA,OAAA,CAAA,QAAA,GAAQ,QAAR;AAIjB,CA9BD,EAAiB,OAAO,KAAP,OAAO,GAAA,EAAA,CAAxB","sourceRoot":"","sourcesContent":["import { Point } from './point';\nimport { Rectangle } from './rectangle';\nimport { Geometry } from './geometry';\nexport class Ellipse extends Geometry {\n    constructor(x, y, a, b) {\n        super();\n        this.x = x == null ? 0 : x;\n        this.y = y == null ? 0 : y;\n        this.a = a == null ? 0 : a;\n        this.b = b == null ? 0 : b;\n    }\n    get [Symbol.toStringTag]() {\n        return Ellipse.toStringTag;\n    }\n    get center() {\n        return new Point(this.x, this.y);\n    }\n    /**\n     * Returns a rectangle that is the bounding box of the ellipse.\n     */\n    bbox() {\n        return Rectangle.fromEllipse(this);\n    }\n    /**\n     * Returns a point that is the center of the ellipse.\n     */\n    getCenter() {\n        return this.center;\n    }\n    inflate(dx, dy) {\n        const w = dx;\n        const h = dy != null ? dy : dx;\n        this.a += 2 * w;\n        this.b += 2 * h;\n        return this;\n    }\n    normalizedDistance(x, y) {\n        const ref = Point.create(x, y);\n        const dx = ref.x - this.x;\n        const dy = ref.y - this.y;\n        const a = this.a;\n        const b = this.b;\n        return (dx * dx) / (a * a) + (dy * dy) / (b * b);\n    }\n    containsPoint(x, y) {\n        return this.normalizedDistance(x, y) <= 1;\n    }\n    /**\n     * Returns an array of the intersection points of the ellipse and the line.\n     * Returns `null` if no intersection exists.\n     */\n    intersectsWithLine(line) {\n        const intersections = [];\n        const rx = this.a;\n        const ry = this.b;\n        const a1 = line.start;\n        const a2 = line.end;\n        const dir = line.vector();\n        const diff = a1.diff(new Point(this.x, this.y));\n        const mDir = new Point(dir.x / (rx * rx), dir.y / (ry * ry));\n        const mDiff = new Point(diff.x / (rx * rx), diff.y / (ry * ry));\n        const a = dir.dot(mDir);\n        const b = dir.dot(mDiff);\n        const c = diff.dot(mDiff) - 1.0;\n        const d = b * b - a * c;\n        if (d < 0) {\n            return null;\n        }\n        if (d > 0) {\n            const root = Math.sqrt(d);\n            const ta = (-b - root) / a;\n            const tb = (-b + root) / a;\n            if ((ta < 0 || ta > 1) && (tb < 0 || tb > 1)) {\n                // outside\n                return null;\n            }\n            if (ta >= 0 && ta <= 1) {\n                intersections.push(a1.lerp(a2, ta));\n            }\n            if (tb >= 0 && tb <= 1) {\n                intersections.push(a1.lerp(a2, tb));\n            }\n        }\n        else {\n            const t = -b / a;\n            if (t >= 0 && t <= 1) {\n                intersections.push(a1.lerp(a2, t));\n            }\n            else {\n                // outside\n                return null;\n            }\n        }\n        return intersections;\n    }\n    /**\n     * Returns the point on the boundary of the ellipse that is the\n     * intersection of the ellipse with a line starting in the center\n     * of the ellipse ending in the point `p`.\n     *\n     * If angle is specified, the intersection will take into account\n     * the rotation of the ellipse by angle degrees around its center.\n     */\n    intersectsWithLineFromCenterToPoint(p, angle = 0) {\n        const ref = Point.clone(p);\n        if (angle) {\n            ref.rotate(angle, this.getCenter());\n        }\n        const dx = ref.x - this.x;\n        const dy = ref.y - this.y;\n        let result;\n        if (dx === 0) {\n            result = this.bbox().getNearestPointToPoint(ref);\n            if (angle) {\n                return result.rotate(-angle, this.getCenter());\n            }\n            return result;\n        }\n        const m = dy / dx;\n        const mSquared = m * m;\n        const aSquared = this.a * this.a;\n        const bSquared = this.b * this.b;\n        let x = Math.sqrt(1 / (1 / aSquared + mSquared / bSquared));\n        x = dx < 0 ? -x : x;\n        const y = m * x;\n        result = new Point(this.x + x, this.y + y);\n        if (angle) {\n            return result.rotate(-angle, this.getCenter());\n        }\n        return result;\n    }\n    /**\n     * Returns the angle between the x-axis and the tangent from a point. It is\n     * valid for points lying on the ellipse boundary only.\n     */\n    tangentTheta(p) {\n        const ref = Point.clone(p);\n        const x0 = ref.x;\n        const y0 = ref.y;\n        const a = this.a;\n        const b = this.b;\n        const center = this.bbox().center;\n        const cx = center.x;\n        const cy = center.y;\n        const refPointDelta = 30;\n        const q1 = x0 > center.x + a / 2;\n        const q3 = x0 < center.x - a / 2;\n        let x;\n        let y;\n        if (q1 || q3) {\n            y = x0 > center.x ? y0 - refPointDelta : y0 + refPointDelta;\n            x =\n                (a * a) / (x0 - cx) -\n                    (a * a * (y0 - cy) * (y - cy)) / (b * b * (x0 - cx)) +\n                    cx;\n        }\n        else {\n            x = y0 > center.y ? x0 + refPointDelta : x0 - refPointDelta;\n            y =\n                (b * b) / (y0 - cy) -\n                    (b * b * (x0 - cx) * (x - cx)) / (a * a * (y0 - cy)) +\n                    cy;\n        }\n        return new Point(x, y).theta(ref);\n    }\n    scale(sx, sy) {\n        this.a *= sx;\n        this.b *= sy;\n        return this;\n    }\n    rotate(angle, origin) {\n        const rect = Rectangle.fromEllipse(this);\n        rect.rotate(angle, origin);\n        const ellipse = Ellipse.fromRect(rect);\n        this.a = ellipse.a;\n        this.b = ellipse.b;\n        this.x = ellipse.x;\n        this.y = ellipse.y;\n        return this;\n    }\n    translate(dx, dy) {\n        const p = Point.create(dx, dy);\n        this.x += p.x;\n        this.y += p.y;\n        return this;\n    }\n    equals(ellipse) {\n        return (ellipse != null &&\n            ellipse.x === this.x &&\n            ellipse.y === this.y &&\n            ellipse.a === this.a &&\n            ellipse.b === this.b);\n    }\n    clone() {\n        return new Ellipse(this.x, this.y, this.a, this.b);\n    }\n    toJSON() {\n        return { x: this.x, y: this.y, a: this.a, b: this.b };\n    }\n    serialize() {\n        return `${this.x} ${this.y} ${this.a} ${this.b}`;\n    }\n}\n(function (Ellipse) {\n    Ellipse.toStringTag = `X6.Geometry.${Ellipse.name}`;\n    function isEllipse(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Ellipse) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const ellipse = instance;\n        if ((tag == null || tag === Ellipse.toStringTag) &&\n            typeof ellipse.x === 'number' &&\n            typeof ellipse.y === 'number' &&\n            typeof ellipse.a === 'number' &&\n            typeof ellipse.b === 'number' &&\n            typeof ellipse.inflate === 'function' &&\n            typeof ellipse.normalizedDistance === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Ellipse.isEllipse = isEllipse;\n})(Ellipse || (Ellipse = {}));\n(function (Ellipse) {\n    function create(x, y, a, b) {\n        if (x == null || typeof x === 'number') {\n            return new Ellipse(x, y, a, b);\n        }\n        return parse(x);\n    }\n    Ellipse.create = create;\n    function parse(e) {\n        if (Ellipse.isEllipse(e)) {\n            return e.clone();\n        }\n        if (Array.isArray(e)) {\n            return new Ellipse(e[0], e[1], e[2], e[3]);\n        }\n        return new Ellipse(e.x, e.y, e.a, e.b);\n    }\n    Ellipse.parse = parse;\n    function fromRect(rect) {\n        const center = rect.center;\n        return new Ellipse(center.x, center.y, rect.width / 2, rect.height / 2);\n    }\n    Ellipse.fromRect = fromRect;\n})(Ellipse || (Ellipse = {}));\n//# sourceMappingURL=ellipse.js.map"]},"metadata":{},"sourceType":"module"}