{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _objectWithoutProperties from \"@babel/runtime/helpers/objectWithoutProperties\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _dec, _class;\n\nvar _excluded = [\"type\"];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { injectable } from 'inversify';\nimport 'reflect-metadata';\nvar lightTypeUniformMap = {\n  directional: {\n    lights: 'u_DirectionalLights',\n    num: 'u_NumOfDirectionalLights'\n  },\n  spot: {\n    lights: 'u_SpotLights',\n    num: 'u_NumOfSpotLights'\n  }\n};\nvar DEFAULT_LIGHT = {\n  type: 'directional',\n  direction: [1, 10.5, 12],\n  ambient: [0.2, 0.2, 0.2],\n  diffuse: [0.6, 0.6, 0.6],\n  specular: [0.1, 0.1, 0.1]\n};\nvar DEFAULT_DIRECTIONAL_LIGHT = {\n  direction: [0, 0, 0],\n  ambient: [0, 0, 0],\n  diffuse: [0, 0, 0],\n  specular: [0, 0, 0]\n};\nvar DEFAULT_SPOT_LIGHT = {\n  position: [0, 0, 0],\n  direction: [0, 0, 0],\n  ambient: [0, 0, 0],\n  diffuse: [0, 0, 0],\n  specular: [0, 0, 0],\n  constant: 1,\n  linear: 0,\n  quadratic: 0,\n  angle: 14,\n  exponent: 40,\n  blur: 5\n};\nvar COLOR_ATTRIBUTES = ['ambient', 'diffuse', 'specular'];\nexport function generateLightingUniforms(lights) {\n  var lightsMap = {\n    u_DirectionalLights: new Array(3).fill(_objectSpread({}, DEFAULT_DIRECTIONAL_LIGHT)),\n    u_NumOfDirectionalLights: 0,\n    u_SpotLights: new Array(3).fill(_objectSpread({}, DEFAULT_SPOT_LIGHT)),\n    u_NumOfSpotLights: 0\n  };\n\n  if (!lights || !lights.length) {\n    lights = [DEFAULT_LIGHT];\n  }\n\n  lights.forEach(function (_ref, i) {\n    var _ref$type = _ref.type,\n        type = _ref$type === void 0 ? 'directional' : _ref$type,\n        rest = _objectWithoutProperties(_ref, _excluded);\n\n    var lightsUniformName = lightTypeUniformMap[type].lights;\n    var lightsNumUniformName = lightTypeUniformMap[type].num;\n    var num = lightsMap[lightsNumUniformName];\n    lightsMap[lightsUniformName][num] = _objectSpread(_objectSpread({}, lightsMap[lightsUniformName][num]), rest);\n    lightsMap[lightsNumUniformName]++;\n  });\n  return lightsMap;\n}\nvar LightingPlugin = (_dec = injectable(), _dec(_class = function () {\n  function LightingPlugin() {\n    _classCallCheck(this, LightingPlugin);\n  }\n\n  _createClass(LightingPlugin, [{\n    key: \"apply\",\n    value: function apply(layer) {\n      layer.hooks.beforeRender.tap('LightingPlugin', function () {\n        var _layer$getLayerConfig = layer.getLayerConfig(),\n            enableLighting = _layer$getLayerConfig.enableLighting;\n\n        if (enableLighting) {\n          layer.models.forEach(function (model) {\n            return model.addUniforms(_objectSpread({}, generateLightingUniforms()));\n          });\n        }\n      });\n    }\n  }]);\n\n  return LightingPlugin;\n}()) || _class);\nexport { LightingPlugin as default };","map":{"version":3,"sources":["../../src/plugins/LightingPlugin.ts"],"names":["lightTypeUniformMap","directional","lights","num","spot","DEFAULT_LIGHT","type","direction","ambient","diffuse","specular","DEFAULT_DIRECTIONAL_LIGHT","DEFAULT_SPOT_LIGHT","position","constant","linear","quadratic","angle","exponent","blur","COLOR_ATTRIBUTES","lightsMap","u_DirectionalLights","u_NumOfDirectionalLights","u_SpotLights","u_NumOfSpotLights","rest","lightsUniformName","lightsNumUniformName","injectable","LightingPlugin","layer","enableLighting","model","generateLightingUniforms"],"mappings":"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","sourcesContent":["import {\n  CameraUniform,\n  CoordinateUniform,\n  ICameraService,\n  ICoordinateSystemService,\n  ILayer,\n  ILayerPlugin,\n  IRendererService,\n  TYPES,\n} from '@antv/l7-core';\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\n\nconst lightTypeUniformMap = {\n  directional: {\n    lights: 'u_DirectionalLights',\n    num: 'u_NumOfDirectionalLights',\n  },\n  spot: {\n    lights: 'u_SpotLights',\n    num: 'u_NumOfSpotLights',\n  },\n};\n\ninterface IDirectionalLight {\n  type: 'directional';\n  direction: [number, number, number];\n  ambient: [number, number, number];\n  diffuse: [number, number, number];\n  specular: [number, number, number];\n}\n\ninterface ISpotLight {\n  type: 'spot';\n  position: [number, number, number];\n  direction: [number, number, number];\n  ambient: [number, number, number];\n  diffuse: [number, number, number];\n  specular: [number, number, number];\n  constant: number;\n  linear: number;\n  quadratic: number;\n  angle: number;\n  exponent: number;\n  blur: number;\n}\n\nconst DEFAULT_LIGHT: IDirectionalLight = {\n  type: 'directional',\n  direction: [1, 10.5, 12],\n  ambient: [0.2, 0.2, 0.2],\n  diffuse: [0.6, 0.6, 0.6],\n  specular: [0.1, 0.1, 0.1],\n};\n\nconst DEFAULT_DIRECTIONAL_LIGHT = {\n  direction: [0, 0, 0],\n  ambient: [0, 0, 0],\n  diffuse: [0, 0, 0],\n  specular: [0, 0, 0],\n};\n\nconst DEFAULT_SPOT_LIGHT = {\n  position: [0, 0, 0],\n  direction: [0, 0, 0],\n  ambient: [0, 0, 0],\n  diffuse: [0, 0, 0],\n  specular: [0, 0, 0],\n  constant: 1,\n  linear: 0,\n  quadratic: 0,\n  angle: 14,\n  exponent: 40,\n  blur: 5,\n};\n\nconst COLOR_ATTRIBUTES = ['ambient', 'diffuse', 'specular'];\n\nexport function generateLightingUniforms(\n  lights?: Array<Partial<IDirectionalLight | ISpotLight>>,\n) {\n  const lightsMap: {\n    u_DirectionalLights: Array<Omit<IDirectionalLight, 'type'>>;\n    u_NumOfDirectionalLights: number;\n    u_SpotLights: Array<Omit<ISpotLight, 'type'>>;\n    u_NumOfSpotLights: number;\n  } = {\n    u_DirectionalLights: new Array(3).fill({ ...DEFAULT_DIRECTIONAL_LIGHT }),\n    u_NumOfDirectionalLights: 0,\n    u_SpotLights: new Array(3).fill({ ...DEFAULT_SPOT_LIGHT }),\n    u_NumOfSpotLights: 0,\n  };\n  if (!lights || !lights.length) {\n    lights = [DEFAULT_LIGHT];\n  }\n  lights.forEach(({ type = 'directional', ...rest }, i) => {\n    const lightsUniformName = lightTypeUniformMap[type].lights;\n    const lightsNumUniformName = lightTypeUniformMap[type].num;\n\n    // Object.keys(rest).forEach(key => {\n    //   if (Util.isString(rest[key]) && COLOR_ATTRIBUTES.indexOf(key) > -1) {\n    //     rest[key] = ColorUtil.color2RGBA(rest[key]).slice(0, 3);\n    //   }\n    // });\n\n    // @ts-ignore\n    const num = lightsMap[lightsNumUniformName];\n    // @ts-ignore\n    lightsMap[lightsUniformName][num] = {\n      // @ts-ignore\n      ...lightsMap[lightsUniformName][num],\n      ...rest,\n    };\n    // @ts-ignore\n    lightsMap[lightsNumUniformName]++;\n  });\n  return lightsMap;\n}\n\n/**\n * 光照 & Shadow\n */\n@injectable()\nexport default class LightingPlugin implements ILayerPlugin {\n  public apply(layer: ILayer) {\n    layer.hooks.beforeRender.tap('LightingPlugin', () => {\n      const { enableLighting } = layer.getLayerConfig();\n      if (enableLighting) {\n        layer.models.forEach((model) =>\n          // @ts-ignore\n          model.addUniforms({\n            ...generateLightingUniforms(),\n          }),\n        );\n      }\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}