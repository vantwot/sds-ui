{"ast":null,"code":"import { Curve, Path } from '../../geometry';\nexport const smooth = function (sourcePoint, targetPoint, routePoints) {\n  let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  let path;\n  let direction = options.direction;\n\n  if (routePoints && routePoints.length !== 0) {\n    const points = [sourcePoint, ...routePoints, targetPoint];\n    const curves = Curve.throughPoints(points);\n    path = new Path(curves);\n  } else {\n    // If we have no route, use a default cubic bezier curve, cubic bezier\n    // requires two control points, the control points have `x` midway\n    // between source and target. This produces an S-like curve.\n    path = new Path();\n    path.appendSegment(Path.createSegment('M', sourcePoint));\n\n    if (!direction) {\n      direction = Math.abs(sourcePoint.x - targetPoint.x) >= Math.abs(sourcePoint.y - targetPoint.y) ? 'H' : 'V';\n    }\n\n    if (direction === 'H') {\n      const controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n      path.appendSegment(Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));\n    } else {\n      const controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n      path.appendSegment(Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));\n    }\n  }\n\n  return options.raw ? path : path.serialize();\n};","map":{"version":3,"sources":["../../../src/registry/connector/smooth.ts"],"names":[],"mappings":"AAAA,SAAS,KAAT,EAAgB,IAAhB,QAA4B,gBAA5B;AAOA,OAAO,MAAM,MAAM,GAAiD,UAClE,WADkE,EAElE,WAFkE,EAGlE,WAHkE,EAItD;AAAA,MAAZ,OAAY,uEAAF,EAAE;AAEZ,MAAI,IAAJ;AACA,MAAI,SAAS,GAAG,OAAO,CAAC,SAAxB;;AAEA,MAAI,WAAW,IAAI,WAAW,CAAC,MAAZ,KAAuB,CAA1C,EAA6C;AAC3C,UAAM,MAAM,GAAG,CAAC,WAAD,EAAc,GAAG,WAAjB,EAA8B,WAA9B,CAAf;AACA,UAAM,MAAM,GAAG,KAAK,CAAC,aAAN,CAAoB,MAApB,CAAf;AACA,IAAA,IAAI,GAAG,IAAI,IAAJ,CAAS,MAAT,CAAP;AACD,GAJD,MAIO;AACL;AACA;AACA;AAEA,IAAA,IAAI,GAAG,IAAI,IAAJ,EAAP;AACA,IAAA,IAAI,CAAC,aAAL,CAAmB,IAAI,CAAC,aAAL,CAAmB,GAAnB,EAAwB,WAAxB,CAAnB;;AAEA,QAAI,CAAC,SAAL,EAAgB;AACd,MAAA,SAAS,GACP,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,CAAZ,GAAgB,WAAW,CAAC,CAArC,KACA,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,CAAZ,GAAgB,WAAW,CAAC,CAArC,CADA,GAEI,GAFJ,GAGI,GAJN;AAKD;;AAED,QAAI,SAAS,KAAK,GAAlB,EAAuB;AACrB,YAAM,aAAa,GAAG,CAAC,WAAW,CAAC,CAAZ,GAAgB,WAAW,CAAC,CAA7B,IAAkC,CAAxD;AACA,MAAA,IAAI,CAAC,aAAL,CACE,IAAI,CAAC,aAAL,CACE,GADF,EAEE,aAFF,EAGE,WAAW,CAAC,CAHd,EAIE,aAJF,EAKE,WAAW,CAAC,CALd,EAME,WAAW,CAAC,CANd,EAOE,WAAW,CAAC,CAPd,CADF;AAWD,KAbD,MAaO;AACL,YAAM,aAAa,GAAG,CAAC,WAAW,CAAC,CAAZ,GAAgB,WAAW,CAAC,CAA7B,IAAkC,CAAxD;AACA,MAAA,IAAI,CAAC,aAAL,CACE,IAAI,CAAC,aAAL,CACE,GADF,EAEE,WAAW,CAAC,CAFd,EAGE,aAHF,EAIE,WAAW,CAAC,CAJd,EAKE,aALF,EAME,WAAW,CAAC,CANd,EAOE,WAAW,CAAC,CAPd,CADF;AAWD;AACF;;AAED,SAAO,OAAO,CAAC,GAAR,GAAc,IAAd,GAAqB,IAAI,CAAC,SAAL,EAA5B;AACD,CA3DM","sourceRoot":"","sourcesContent":["import { Curve, Path } from '../../geometry';\nexport const smooth = function (sourcePoint, targetPoint, routePoints, options = {}) {\n    let path;\n    let direction = options.direction;\n    if (routePoints && routePoints.length !== 0) {\n        const points = [sourcePoint, ...routePoints, targetPoint];\n        const curves = Curve.throughPoints(points);\n        path = new Path(curves);\n    }\n    else {\n        // If we have no route, use a default cubic bezier curve, cubic bezier\n        // requires two control points, the control points have `x` midway\n        // between source and target. This produces an S-like curve.\n        path = new Path();\n        path.appendSegment(Path.createSegment('M', sourcePoint));\n        if (!direction) {\n            direction =\n                Math.abs(sourcePoint.x - targetPoint.x) >=\n                    Math.abs(sourcePoint.y - targetPoint.y)\n                    ? 'H'\n                    : 'V';\n        }\n        if (direction === 'H') {\n            const controlPointX = (sourcePoint.x + targetPoint.x) / 2;\n            path.appendSegment(Path.createSegment('C', controlPointX, sourcePoint.y, controlPointX, targetPoint.y, targetPoint.x, targetPoint.y));\n        }\n        else {\n            const controlPointY = (sourcePoint.y + targetPoint.y) / 2;\n            path.appendSegment(Path.createSegment('C', sourcePoint.x, controlPointY, targetPoint.x, controlPointY, targetPoint.x, targetPoint.y));\n        }\n    }\n    return options.raw ? path : path.serialize();\n};\n//# sourceMappingURL=smooth.js.map"]},"metadata":{},"sourceType":"module"}