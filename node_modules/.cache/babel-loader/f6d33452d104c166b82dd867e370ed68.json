{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nvar _dec, _class;\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nimport { $window, LRUCache } from '@antv/l7-utils';\nimport { injectable } from 'inversify';\nimport TinySDF from 'l7-tiny-sdf';\nimport 'reflect-metadata';\nimport { buildMapping } from '../../utils/font_util';\nexport var DEFAULT_CHAR_SET = getDefaultCharacterSet();\nexport var DEFAULT_FONT_FAMILY = 'sans-serif';\nexport var DEFAULT_FONT_WEIGHT = 'normal';\nexport var DEFAULT_FONT_SIZE = 24;\nexport var DEFAULT_BUFFER = 3;\nexport var DEFAULT_CUTOFF = 0.25;\nexport var DEFAULT_RADIUS = 8;\nvar MAX_CANVAS_WIDTH = 1024;\nvar BASELINE_SCALE = 1.0;\nvar HEIGHT_SCALE = 1.0;\nvar CACHE_LIMIT = 3;\nvar VALID_PROPS = ['fontFamily', 'fontWeight', 'characterSet', 'fontSize', 'sdf', 'buffer', 'cutoff', 'radius'];\n\nfunction getDefaultCharacterSet() {\n  var charSet = [];\n\n  for (var i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n\n  return charSet;\n}\n\nfunction setTextStyle(ctx, fontFamily, fontSize, fontWeight) {\n  ctx.font = \"\".concat(fontWeight, \" \").concat(fontSize, \"px \").concat(fontFamily);\n  ctx.fillStyle = 'black';\n  ctx.textBaseline = 'middle';\n}\n\nfunction populateAlphaChannel(alphaChannel, imageData) {\n  for (var i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\nvar FontService = (_dec = injectable(), _dec(_class = function () {\n  function FontService() {\n    _classCallCheck(this, FontService);\n\n    _defineProperty(this, \"fontAtlas\", void 0);\n\n    _defineProperty(this, \"iconFontMap\", void 0);\n\n    _defineProperty(this, \"iconFontGlyphs\", {});\n\n    _defineProperty(this, \"fontOptions\", void 0);\n\n    _defineProperty(this, \"key\", void 0);\n\n    _defineProperty(this, \"cache\", new LRUCache(CACHE_LIMIT));\n  }\n\n  _createClass(FontService, [{\n    key: \"scale\",\n    get: function get() {\n      return HEIGHT_SCALE;\n    }\n  }, {\n    key: \"canvas\",\n    get: function get() {\n      var data = this.cache.get(this.key);\n      return data && data.data;\n    }\n  }, {\n    key: \"mapping\",\n    get: function get() {\n      var data = this.cache.get(this.key);\n      return data && data.mapping;\n    }\n  }, {\n    key: \"init\",\n    value: function init() {\n      this.cache.clear();\n      this.fontOptions = {\n        fontFamily: DEFAULT_FONT_FAMILY,\n        fontWeight: DEFAULT_FONT_WEIGHT,\n        characterSet: DEFAULT_CHAR_SET,\n        fontSize: DEFAULT_FONT_SIZE,\n        buffer: DEFAULT_BUFFER,\n        sdf: true,\n        cutoff: DEFAULT_CUTOFF,\n        radius: DEFAULT_RADIUS,\n        iconfont: false\n      };\n      this.key = '';\n      this.iconFontMap = new Map();\n    }\n  }, {\n    key: \"addIconGlyphs\",\n    value: function addIconGlyphs(glyphs) {\n      var _this = this;\n\n      glyphs.forEach(function (glyph) {\n        _this.iconFontGlyphs[glyph.name] = glyph.unicode;\n      });\n    }\n  }, {\n    key: \"addIconFont\",\n    value: function addIconFont(name, fontUnicode) {\n      this.iconFontMap.set(name, fontUnicode);\n    }\n  }, {\n    key: \"getIconFontKey\",\n    value: function getIconFontKey(name) {\n      return this.iconFontMap.get(name) || name;\n    }\n  }, {\n    key: \"getGlyph\",\n    value: function getGlyph(name) {\n      if (this.iconFontGlyphs[name]) {\n        return String.fromCharCode(parseInt(this.iconFontGlyphs[name], 16));\n      }\n\n      return '';\n    }\n  }, {\n    key: \"setFontOptions\",\n    value: function setFontOptions(option) {\n      this.fontOptions = _objectSpread(_objectSpread({}, this.fontOptions), option);\n      this.key = this.getKey();\n      var charSet = this.getNewChars(this.key, this.fontOptions.characterSet);\n      var cachedFontAtlas = this.cache.get(this.key);\n\n      if (cachedFontAtlas && charSet.length === 0) {\n        return;\n      }\n\n      var fontAtlas = this.generateFontAtlas(this.key, charSet, cachedFontAtlas);\n      this.fontAtlas = fontAtlas;\n      this.cache.set(this.key, fontAtlas);\n    }\n  }, {\n    key: \"destroy\",\n    value: function destroy() {\n      this.cache.clear();\n      this.iconFontMap.clear();\n    }\n  }, {\n    key: \"generateFontAtlas\",\n    value: function generateFontAtlas(key, characterSet, cachedFontAtlas) {\n      var _this$fontOptions = this.fontOptions,\n          fontFamily = _this$fontOptions.fontFamily,\n          fontWeight = _this$fontOptions.fontWeight,\n          fontSize = _this$fontOptions.fontSize,\n          buffer = _this$fontOptions.buffer,\n          sdf = _this$fontOptions.sdf,\n          radius = _this$fontOptions.radius,\n          cutoff = _this$fontOptions.cutoff,\n          iconfont = _this$fontOptions.iconfont;\n      var canvas = cachedFontAtlas && cachedFontAtlas.data;\n\n      if (!canvas) {\n        canvas = $window.document.createElement('canvas');\n        canvas.width = MAX_CANVAS_WIDTH;\n      }\n\n      var ctx = canvas.getContext('2d');\n      setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n      var _buildMapping = buildMapping(_objectSpread({\n        getFontWidth: function getFontWidth(char) {\n          return ctx.measureText(char).width;\n        },\n        fontHeight: fontSize * HEIGHT_SCALE,\n        buffer: buffer,\n        characterSet: characterSet,\n        maxCanvasWidth: MAX_CANVAS_WIDTH\n      }, cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset\n      })),\n          mapping = _buildMapping.mapping,\n          canvasHeight = _buildMapping.canvasHeight,\n          xOffset = _buildMapping.xOffset,\n          yOffset = _buildMapping.yOffset;\n\n      var copyImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n      canvas.height = canvasHeight;\n      ctx.putImageData(copyImageData, 0, 0);\n      setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n      if (sdf) {\n        var tinySDF = new TinySDF(fontSize, buffer, radius, cutoff, fontFamily, fontWeight);\n        var imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n\n        var _iterator = _createForOfIteratorHelper(characterSet),\n            _step;\n\n        try {\n          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n            var char = _step.value;\n\n            if (iconfont) {\n              var icon = String.fromCharCode(parseInt(char.replace('&#x', '').replace(';', ''), 16));\n              var iconData = tinySDF.draw(icon);\n              populateAlphaChannel(iconData, imageData);\n            } else {\n              populateAlphaChannel(tinySDF.draw(char), imageData);\n            }\n\n            ctx.putImageData(imageData, mapping[char].x, mapping[char].y);\n          }\n        } catch (err) {\n          _iterator.e(err);\n        } finally {\n          _iterator.f();\n        }\n      } else {\n        var _iterator2 = _createForOfIteratorHelper(characterSet),\n            _step2;\n\n        try {\n          for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n            var _char = _step2.value;\n            ctx.fillText(_char, mapping[_char].x, mapping[_char].y + fontSize * BASELINE_SCALE);\n          }\n        } catch (err) {\n          _iterator2.e(err);\n        } finally {\n          _iterator2.f();\n        }\n      }\n\n      return {\n        xOffset: xOffset,\n        yOffset: yOffset,\n        mapping: mapping,\n        data: canvas,\n        width: canvas.width,\n        height: canvas.height\n      };\n    }\n  }, {\n    key: \"getKey\",\n    value: function getKey() {\n      return 'key';\n      var _this$fontOptions2 = this.fontOptions,\n          fontFamily = _this$fontOptions2.fontFamily,\n          fontWeight = _this$fontOptions2.fontWeight,\n          fontSize = _this$fontOptions2.fontSize,\n          buffer = _this$fontOptions2.buffer,\n          sdf = _this$fontOptions2.sdf,\n          radius = _this$fontOptions2.radius,\n          cutoff = _this$fontOptions2.cutoff;\n\n      if (sdf) {\n        return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer, \" \").concat(radius, \" \").concat(cutoff, \" \");\n      }\n\n      return \"\".concat(fontFamily, \" \").concat(fontWeight, \" \").concat(fontSize, \" \").concat(buffer);\n    }\n  }, {\n    key: \"getNewChars\",\n    value: function getNewChars(key, characterSet) {\n      var cachedFontAtlas = this.cache.get(key);\n\n      if (!cachedFontAtlas) {\n        return characterSet;\n      }\n\n      var newChars = [];\n      var cachedMapping = cachedFontAtlas.mapping;\n      var cachedCharSet = new Set(Object.keys(cachedMapping));\n      var charSet = new Set(characterSet);\n      charSet.forEach(function (char) {\n        if (!cachedCharSet.has(char)) {\n          newChars.push(char);\n        }\n      });\n      return newChars;\n    }\n  }]);\n\n  return FontService;\n}()) || _class);\nexport { FontService as default };","map":{"version":3,"sources":["../../../src/services/asset/FontService.ts"],"names":["DEFAULT_CHAR_SET","getDefaultCharacterSet","DEFAULT_FONT_FAMILY","DEFAULT_FONT_WEIGHT","DEFAULT_FONT_SIZE","DEFAULT_BUFFER","DEFAULT_CUTOFF","DEFAULT_RADIUS","MAX_CANVAS_WIDTH","BASELINE_SCALE","HEIGHT_SCALE","CACHE_LIMIT","VALID_PROPS","charSet","i","String","ctx","alphaChannel","imageData","injectable","FontService","data","fontFamily","fontWeight","characterSet","fontSize","buffer","sdf","cutoff","radius","iconfont","glyphs","glyph","parseInt","cachedFontAtlas","fontAtlas","canvas","$window","setTextStyle","mapping","canvasHeight","xOffset","yOffset","buildMapping","getFontWidth","fontHeight","maxCanvasWidth","copyImageData","tinySDF","char","icon","iconData","populateAlphaChannel","width","height","newChars","cachedMapping","cachedCharSet","Object"],"mappings":"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","sourcesContent":["import { $window, LRUCache } from '@antv/l7-utils';\nimport { inject, injectable } from 'inversify';\nimport TinySDF from 'l7-tiny-sdf';\nimport 'reflect-metadata';\nimport { buildMapping } from '../../utils/font_util';\nimport {\n  IFontAtlas,\n  IFontMapping,\n  IFontMappingItem,\n  IFontOptions,\n  IFontService,\n  IIconFontGlyph,\n} from './IFontService';\nexport const DEFAULT_CHAR_SET = getDefaultCharacterSet();\nexport const DEFAULT_FONT_FAMILY = 'sans-serif';\nexport const DEFAULT_FONT_WEIGHT = 'normal';\nexport const DEFAULT_FONT_SIZE = 24;\nexport const DEFAULT_BUFFER = 3;\nexport const DEFAULT_CUTOFF = 0.25;\nexport const DEFAULT_RADIUS = 8;\nconst MAX_CANVAS_WIDTH = 1024;\nconst BASELINE_SCALE = 1.0;\nconst HEIGHT_SCALE = 1.0;\nconst CACHE_LIMIT = 3;\nconst VALID_PROPS = [\n  'fontFamily',\n  'fontWeight',\n  'characterSet',\n  'fontSize',\n  'sdf',\n  'buffer',\n  'cutoff',\n  'radius',\n];\n\nfunction getDefaultCharacterSet() {\n  const charSet = [];\n  for (let i = 32; i < 128; i++) {\n    charSet.push(String.fromCharCode(i));\n  }\n  return charSet;\n}\n\nfunction setTextStyle(\n  ctx: CanvasRenderingContext2D,\n  fontFamily: string,\n  fontSize: number,\n  fontWeight: string,\n) {\n  ctx.font = `${fontWeight} ${fontSize}px ${fontFamily}`;\n  ctx.fillStyle = 'black';\n  ctx.textBaseline = 'middle';\n  // ctx.textAlign = 'left';\n}\n\nfunction populateAlphaChannel(alphaChannel: number[], imageData: ImageData) {\n  // populate distance value from tinySDF to image alpha channel\n  for (let i = 0; i < alphaChannel.length; i++) {\n    imageData.data[4 * i + 3] = alphaChannel[i];\n  }\n}\n\n@injectable()\nexport default class FontService implements IFontService {\n  public get scale() {\n    return HEIGHT_SCALE;\n  }\n\n  public get canvas(): HTMLCanvasElement {\n    const data = this.cache.get(this.key);\n    return data && data.data;\n  }\n\n  public get mapping(): IFontMapping {\n    const data = this.cache.get(this.key);\n    return data && data.mapping;\n  }\n  public fontAtlas: IFontAtlas;\n\n  // iconFontMap 记录用户设置的 iconfont unicode 和名称的键值关系\n  public iconFontMap: Map<string, string>;\n  private iconFontGlyphs: {\n    [key: string]: string;\n  } = {};\n  private fontOptions: IFontOptions;\n  private key: string;\n  private cache: LRUCache = new LRUCache(CACHE_LIMIT);\n\n  public init() {\n    this.cache.clear();\n    this.fontOptions = {\n      fontFamily: DEFAULT_FONT_FAMILY,\n      fontWeight: DEFAULT_FONT_WEIGHT,\n      characterSet: DEFAULT_CHAR_SET,\n      fontSize: DEFAULT_FONT_SIZE,\n      buffer: DEFAULT_BUFFER,\n      sdf: true,\n      cutoff: DEFAULT_CUTOFF,\n      radius: DEFAULT_RADIUS,\n      iconfont: false,\n    };\n    this.key = '';\n    this.iconFontMap = new Map();\n  }\n  public addIconGlyphs(glyphs: IIconFontGlyph[]): void {\n    glyphs.forEach((glyph) => {\n      this.iconFontGlyphs[glyph.name] = glyph.unicode;\n    });\n  }\n\n  /**\n   * 添加对 iconfont unicode 的映射\n   * @param fontUnicode\n   * @param name\n   */\n  public addIconFont(name: string, fontUnicode: string): void {\n    this.iconFontMap.set(name, fontUnicode);\n  }\n\n  /**\n   * 获取自定义 iconfont 别称对应的 unicode 编码，若是当前的 map 中没有对应的键值对，那么就返回原值\n   * @param name\n   * @returns\n   */\n  public getIconFontKey(name: string): string {\n    return this.iconFontMap.get(name) || name;\n  }\n\n  public getGlyph(name: string): string {\n    if (this.iconFontGlyphs[name]) {\n      return String.fromCharCode(parseInt(this.iconFontGlyphs[name], 16));\n    }\n    return '';\n  }\n\n  public setFontOptions(option: Partial<IFontOptions>) {\n    this.fontOptions = {\n      ...this.fontOptions,\n      ...option,\n    };\n    // const oldKey = this.key;\n    this.key = this.getKey();\n\n    const charSet = this.getNewChars(this.key, this.fontOptions.characterSet);\n    const cachedFontAtlas = this.cache.get(this.key);\n    if (cachedFontAtlas && charSet.length === 0) {\n      // update texture with cached fontAtlas\n      return;\n    }\n    // update fontAtlas with new settings\n    const fontAtlas = this.generateFontAtlas(\n      this.key,\n      charSet,\n      cachedFontAtlas,\n    );\n    this.fontAtlas = fontAtlas;\n\n    // update cache\n    this.cache.set(this.key, fontAtlas);\n  }\n\n  public destroy(): void {\n    this.cache.clear();\n    this.iconFontMap.clear();\n  }\n\n  private generateFontAtlas(\n    key: string,\n    characterSet: string[],\n    cachedFontAtlas: IFontAtlas,\n  ): IFontAtlas {\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff,\n      iconfont,\n    } = this.fontOptions;\n    let canvas = cachedFontAtlas && cachedFontAtlas.data;\n    if (!canvas) {\n      canvas = $window.document.createElement('canvas');\n      canvas.width = MAX_CANVAS_WIDTH;\n    }\n    const ctx = canvas.getContext('2d') as CanvasRenderingContext2D;\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 1. build mapping\n    const { mapping, canvasHeight, xOffset, yOffset } = buildMapping({\n      getFontWidth: (char) => ctx.measureText(char).width,\n      fontHeight: fontSize * HEIGHT_SCALE,\n      buffer,\n      characterSet,\n      maxCanvasWidth: MAX_CANVAS_WIDTH,\n      ...(cachedFontAtlas && {\n        mapping: cachedFontAtlas.mapping,\n        xOffset: cachedFontAtlas.xOffset,\n        yOffset: cachedFontAtlas.yOffset,\n      }),\n    });\n\n    // 2. update canvas\n    // copy old canvas data to new canvas only when height changed\n    // TODO safari 不能正常更新\n    const copyImageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n    canvas.height = canvasHeight;\n    ctx.putImageData(copyImageData, 0, 0);\n    setTextStyle(ctx, fontFamily, fontSize, fontWeight);\n\n    // 3. layout characters\n    if (sdf) {\n      const tinySDF = new TinySDF(\n        fontSize,\n        buffer,\n        radius,\n        cutoff,\n        fontFamily,\n        fontWeight,\n      );\n      // used to store distance values from tinySDF\n      // tinySDF.size equals `fontSize + buffer * 2`\n      const imageData = ctx.getImageData(0, 0, tinySDF.size, tinySDF.size);\n      for (const char of characterSet) {\n        if (iconfont) {\n          // @ts-ignore\n          // const icon = eval(\n          //   '(\"' + char.replace('&#x', '\\\\u').replace(';', '') + '\")',\n          // );\n\n          const icon = String.fromCharCode(\n            parseInt(char.replace('&#x', '').replace(';', ''), 16),\n          );\n          const iconData = tinySDF.draw(icon);\n          populateAlphaChannel(iconData, imageData);\n        } else {\n          populateAlphaChannel(tinySDF.draw(char), imageData);\n        }\n        // populateAlphaChannel(tinySDF.draw(char), imageData);\n\n        // 考虑到描边，需要保留 sdf 的 buffer，不能像 deck.gl 一样直接减去\n        ctx.putImageData(imageData, mapping[char].x, mapping[char].y);\n      }\n    } else {\n      for (const char of characterSet) {\n        ctx.fillText(\n          char,\n          mapping[char].x,\n          mapping[char].y + fontSize * BASELINE_SCALE,\n        );\n      }\n    }\n    return {\n      xOffset,\n      yOffset,\n      mapping,\n      data: canvas,\n      width: canvas.width,\n      height: canvas.height,\n    };\n  }\n\n  private getKey() {\n    return 'key';\n    const {\n      fontFamily,\n      fontWeight,\n      fontSize,\n      buffer,\n      sdf,\n      radius,\n      cutoff,\n    } = this.fontOptions;\n    if (sdf) {\n      return `${fontFamily} ${fontWeight} ${fontSize} ${buffer} ${radius} ${cutoff} `;\n    }\n    return `${fontFamily} ${fontWeight} ${fontSize} ${buffer}`;\n  }\n\n  /**\n   *\n   * @param key\n   * @param characterSet\n   * @returns\n   * 若是相同的 key，那么将字符存储到同同一个字符列表中\n   */\n  private getNewChars(key: string, characterSet: string[]): string[] {\n    const cachedFontAtlas = this.cache.get(key);\n    if (!cachedFontAtlas) {\n      return characterSet;\n    }\n\n    const newChars: string[] = [];\n    const cachedMapping = cachedFontAtlas.mapping;\n    const cachedCharSet = new Set(Object.keys(cachedMapping));\n    const charSet = new Set(characterSet);\n    charSet.forEach((char: string) => {\n      if (!cachedCharSet.has(char)) {\n        newChars.push(char);\n      }\n    });\n\n    return newChars;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}