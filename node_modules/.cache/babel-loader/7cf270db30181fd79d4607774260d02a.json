{"ast":null,"code":"import toposort from 'toposort';\nexport var ErrorUtils;\n\n(function (ErrorUtils) {\n  let ErrorEnum;\n\n  (function (ErrorEnum) {\n    ErrorEnum[\"INVALID_HOOK_BEFORE\"] = \"INVALID_HOOK_BEFORE\";\n    ErrorEnum[\"INVALID_HOOK_AFTER\"] = \"INVALID_HOOK_AFTER\";\n    ErrorEnum[\"INVALID_HOOK_ARGS_LENGTH\"] = \"INVALID_HOOK_ARGS_LENGTH\";\n  })(ErrorEnum = ErrorUtils.ErrorEnum || (ErrorUtils.ErrorEnum = {}));\n\n  class HookError extends Error {\n    constructor(code, message) {\n      if (Array.isArray(message)) {\n        message = message.filter(function (line) {\n          return !!line;\n        }).join(' ');\n      }\n\n      super(`${code}: ${message}`);\n\n      if (Error.captureStackTrace) {\n        ;\n        Error.captureStackTrace(this, HookError);\n      }\n\n      this.code = code;\n      this.contexts = {};\n\n      for (var _len = arguments.length, contexts = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        contexts[_key - 2] = arguments[_key];\n      }\n\n      contexts.forEach(context => {\n        if (typeof context === 'object') {\n          Object.entries(context).forEach(pair => {\n            const [key, value] = pair;\n\n            if (key !== 'key' && value) {\n              this.contexts[key] = JSON.parse(JSON.stringify(value));\n            }\n          });\n        }\n      });\n    }\n\n    toString() {\n      return `${this.code}: ${this.message}`;\n    }\n\n  }\n\n  ErrorUtils.HookError = HookError;\n\n  const createError = function (code, message) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    return new HookError(code, message, ...args);\n  };\n\n  ErrorUtils.HookBeforeError = () => {\n    return createError(ErrorEnum.INVALID_HOOK_BEFORE, ['hook require a before dependency but not exist in hookmap']);\n  };\n\n  ErrorUtils.HookAfterError = () => {\n    return createError(ErrorEnum.INVALID_HOOK_AFTER, ['hook require a after dependency but not exist in hookmap']);\n  };\n\n  ErrorUtils.InvalidHookArguments = hook => {\n    return createError(ErrorEnum.INVALID_HOOK_ARGS_LENGTH, ['hook handlers must have 0 to 2 arguments', `but got ${hook.handler.length}`]);\n  };\n})(ErrorUtils || (ErrorUtils = {}));\n\nexport var HookUtils;\n\n(function (HookUtils) {\n  /** 处理 runtime hooks */\n  HookUtils.normalize = function () {\n    let hookConfig = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let hookMap = arguments.length > 1 ? arguments[1] : undefined;\n    const runtimeHook = Array.isArray(hookConfig) ? hookConfig : [hookConfig];\n    const innerHooks = [];\n    hookMap.forEach(val => {\n      innerHooks.push(val);\n    });\n    return [...innerHooks, ...runtimeHook].filter(item => item && !!item.handler);\n  };\n  /** 排序 hooks */\n\n\n  HookUtils.sort = function () {\n    let hooks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let hookMap = arguments.length > 1 ? arguments[1] : undefined;\n    const edges = [];\n    hooks.forEach(hook => {\n      if (hook.before) {\n        if (!hookMap.has(hook.before)) {\n          throw ErrorUtils.HookBeforeError();\n        }\n\n        const edge = [hookMap.get(hook.before), hook];\n        edges.push(edge);\n      }\n\n      if (hook.after) {\n        if (!hookMap.has(hook.after)) {\n          throw ErrorUtils.HookBeforeError();\n        }\n\n        const edge = [hook, hookMap.get(hook.after)];\n        edges.push(edge);\n      }\n    });\n    const sortedHooks = toposort(edges);\n    sortedHooks.reverse();\n    return sortedHooks;\n  };\n})(HookUtils || (HookUtils = {}));\n\nexport class Deferred {\n  constructor() {\n    this.isResolved = false;\n    this.isRejected = false;\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = args => {\n        this.isResolved = true;\n        resolve(args);\n      };\n\n      this.reject = args => {\n        this.isRejected = true;\n        reject(args);\n      };\n    });\n  }\n\n}","map":{"version":3,"sources":["../src/utils.ts"],"names":[],"mappings":"AACA,OAAO,QAAP,MAAqB,UAArB;AAEA,OAAM,IAAW,UAAX;;AAAN,CAAA,UAAiB,UAAjB,EAA2B;AACzB,MAAY,SAAZ;;AAAA,GAAA,UAAY,SAAZ,EAAqB;AACnB,IAAA,SAAA,CAAA,qBAAA,CAAA,GAAA,qBAAA;AACA,IAAA,SAAA,CAAA,oBAAA,CAAA,GAAA,oBAAA;AACA,IAAA,SAAA,CAAA,0BAAA,CAAA,GAAA,0BAAA;AACD,GAJD,EAAY,SAAS,GAAT,UAAA,CAAA,SAAA,KAAA,UAAA,CAAA,SAAA,GAAS,EAAT,CAAZ;;AAMA,QAAa,SAAb,SAA+B,KAA/B,CAAoC;AAGlC,IAAA,WAAA,CAAY,IAAZ,EAA0B,OAA1B,EAAwE;AACtE,UAAI,KAAK,CAAC,OAAN,CAAc,OAAd,CAAJ,EAA4B;AAC1B,QAAA,OAAO,GAAG,OAAO,CACd,MADO,CACA,UAAU,IAAV,EAAc;AACpB,iBAAO,CAAC,CAAC,IAAT;AACD,SAHO,EAIP,IAJO,CAIF,GAJE,CAAV;AAKD;;AACD,YAAM,GAAG,IAAI,KAAK,OAAO,EAAzB;;AACA,UAAK,KAAa,CAAC,iBAAnB,EAAsC;AACpC;AAAE,QAAA,KAAa,CAAC,iBAAd,CAAgC,IAAhC,EAAsC,SAAtC;AACH;;AACD,WAAK,IAAL,GAAY,IAAZ;AACA,WAAK,QAAL,GAAgB,EAAhB;;AAbsE,wCAAf,QAAe;AAAf,QAAA,QAAe;AAAA;;AActE,MAAA,QAAQ,CAAC,OAAT,CAAiB,OAAO,IAAG;AACzB,YAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,UAAA,MAAM,CAAC,OAAP,CAAe,OAAf,EAAwB,OAAxB,CAAgC,IAAI,IAAG;AACrC,kBAAM,CAAC,GAAD,EAAM,KAAN,IAAe,IAArB;;AACA,gBAAI,GAAG,KAAK,KAAR,IAAiB,KAArB,EAA4B;AAC1B,mBAAK,QAAL,CAAc,GAAd,IAAqB,IAAI,CAAC,KAAL,CAAW,IAAI,CAAC,SAAL,CAAe,KAAf,CAAX,CAArB;AACD;AACF,WALD;AAMD;AACF,OATD;AAUD;;AACD,IAAA,QAAQ,GAAA;AACN,aAAO,GAAG,KAAK,IAAI,KAAK,KAAK,OAAO,EAApC;AACD;;AA9BiC;;AAAvB,EAAA,UAAA,CAAA,SAAA,GAAS,SAAT;;AAgCb,QAAM,WAAW,GAAG,UAAC,IAAD,EAAe,OAAf,EAAoD;AAAA,uCAAf,IAAe;AAAf,MAAA,IAAe;AAAA;;AACtE,WAAO,IAAI,SAAJ,CAAc,IAAd,EAAoB,OAApB,EAA6B,GAAG,IAAhC,CAAP;AACD,GAFD;;AAGa,EAAA,UAAA,CAAA,eAAA,GAAkB,MAAK;AAClC,WAAO,WAAW,CAAC,SAAS,CAAC,mBAAX,EAAgC,CAChD,2DADgD,CAAhC,CAAlB;AAGD,GAJY;;AAKA,EAAA,UAAA,CAAA,cAAA,GAAiB,MAAK;AACjC,WAAO,WAAW,CAAC,SAAS,CAAC,kBAAX,EAA+B,CAC/C,0DAD+C,CAA/B,CAAlB;AAGD,GAJY;;AAKA,EAAA,UAAA,CAAA,oBAAA,GAAwB,IAAD,IAAgB;AAClD,WAAO,WAAW,CAAC,SAAS,CAAC,wBAAX,EAAqC,CACrD,0CADqD,EAErD,WAAW,IAAI,CAAC,OAAL,CAAa,MAAM,EAFuB,CAArC,CAAlB;AAID,GALY;AAMd,CA1DD,EAAiB,UAAU,KAAV,UAAU,GAAA,EAAA,CAA3B;;AA4DA,OAAM,IAAW,SAAX;;AAAN,CAAA,UAAiB,SAAjB,EAA0B;AACxB;AACa,EAAA,SAAA,CAAA,SAAA,GAAY,YAGZ;AAAA,QAFX,UAEW,uEAFmB,EAEnB;AAAA,QADX,OACW;AACX,UAAM,WAAW,GAAG,KAAK,CAAC,OAAN,CAAc,UAAd,IAA4B,UAA5B,GAAyC,CAAC,UAAD,CAA7D;AACA,UAAM,UAAU,GAAY,EAA5B;AACA,IAAA,OAAO,CAAC,OAAR,CAAgB,GAAG,IAAG;AACpB,MAAA,UAAU,CAAC,IAAX,CAAgB,GAAhB;AACD,KAFD;AAIA,WAAO,CAAC,GAAG,UAAJ,EAAgB,GAAG,WAAnB,EAAgC,MAAhC,CAAuC,IAAI,IAAI,IAAI,IAAI,CAAC,CAAC,IAAI,CAAC,OAA9D,CAAP;AACD,GAXY;AAYb;;;AACa,EAAA,SAAA,CAAA,IAAA,GAAO,YAA8D;AAAA,QAA7D,KAA6D,uEAA5C,EAA4C;AAAA,QAAxC,OAAwC;AAChF,UAAM,KAAK,GAAqB,EAAhC;AACA,IAAA,KAAK,CAAC,OAAN,CAAc,IAAI,IAAG;AACnB,UAAI,IAAI,CAAC,MAAT,EAAiB;AACf,YAAI,CAAC,OAAO,CAAC,GAAR,CAAY,IAAI,CAAC,MAAjB,CAAL,EAA+B;AAC7B,gBAAM,UAAU,CAAC,eAAX,EAAN;AACD;;AACD,cAAM,IAAI,GAAG,CAAC,OAAO,CAAC,GAAR,CAAY,IAAI,CAAC,MAAjB,CAAD,EAA2B,IAA3B,CAAb;AACA,QAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACD;;AACD,UAAI,IAAI,CAAC,KAAT,EAAgB;AACd,YAAI,CAAC,OAAO,CAAC,GAAR,CAAY,IAAI,CAAC,KAAjB,CAAL,EAA8B;AAC5B,gBAAM,UAAU,CAAC,eAAX,EAAN;AACD;;AACD,cAAM,IAAI,GAAG,CAAC,IAAD,EAAO,OAAO,CAAC,GAAR,CAAY,IAAI,CAAC,KAAjB,CAAP,CAAb;AACA,QAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACD;AACF,KAfD;AAiBA,UAAM,WAAW,GAAG,QAAQ,CAAC,KAAD,CAA5B;AACA,IAAA,WAAW,CAAC,OAAZ;AACA,WAAO,WAAP;AACD,GAtBY;AAuBd,CAtCD,EAAiB,SAAS,KAAT,SAAS,GAAA,EAAA,CAA1B;;AAwCA,OAAM,MAAO,QAAP,CAAe;AAWnB,EAAA,WAAA,GAAA;AAVA,SAAA,UAAA,GAAsB,KAAtB;AAEA,SAAA,UAAA,GAAsB,KAAtB;AASE,SAAK,OAAL,GAAe,IAAI,OAAJ,CAAe,CAAC,OAAD,EAAU,MAAV,KAAoB;AAChD,WAAK,OAAL,GAAe,IAAI,IAAG;AACpB,aAAK,UAAL,GAAkB,IAAlB;AACA,QAAA,OAAO,CAAC,IAAD,CAAP;AACD,OAHD;;AAIA,WAAK,MAAL,GAAc,IAAI,IAAG;AACnB,aAAK,UAAL,GAAkB,IAAlB;AACA,QAAA,MAAM,CAAC,IAAD,CAAN;AACD,OAHD;AAID,KATc,CAAf;AAUD;;AAtBkB","sourceRoot":"","sourcesContent":["import toposort from 'toposort';\nexport var ErrorUtils;\n(function (ErrorUtils) {\n    let ErrorEnum;\n    (function (ErrorEnum) {\n        ErrorEnum[\"INVALID_HOOK_BEFORE\"] = \"INVALID_HOOK_BEFORE\";\n        ErrorEnum[\"INVALID_HOOK_AFTER\"] = \"INVALID_HOOK_AFTER\";\n        ErrorEnum[\"INVALID_HOOK_ARGS_LENGTH\"] = \"INVALID_HOOK_ARGS_LENGTH\";\n    })(ErrorEnum = ErrorUtils.ErrorEnum || (ErrorUtils.ErrorEnum = {}));\n    class HookError extends Error {\n        constructor(code, message, ...contexts) {\n            if (Array.isArray(message)) {\n                message = message\n                    .filter(function (line) {\n                    return !!line;\n                })\n                    .join(' ');\n            }\n            super(`${code}: ${message}`);\n            if (Error.captureStackTrace) {\n                ;\n                Error.captureStackTrace(this, HookError);\n            }\n            this.code = code;\n            this.contexts = {};\n            contexts.forEach(context => {\n                if (typeof context === 'object') {\n                    Object.entries(context).forEach(pair => {\n                        const [key, value] = pair;\n                        if (key !== 'key' && value) {\n                            this.contexts[key] = JSON.parse(JSON.stringify(value));\n                        }\n                    });\n                }\n            });\n        }\n        toString() {\n            return `${this.code}: ${this.message}`;\n        }\n    }\n    ErrorUtils.HookError = HookError;\n    const createError = (code, message, ...args) => {\n        return new HookError(code, message, ...args);\n    };\n    ErrorUtils.HookBeforeError = () => {\n        return createError(ErrorEnum.INVALID_HOOK_BEFORE, [\n            'hook require a before dependency but not exist in hookmap',\n        ]);\n    };\n    ErrorUtils.HookAfterError = () => {\n        return createError(ErrorEnum.INVALID_HOOK_AFTER, [\n            'hook require a after dependency but not exist in hookmap',\n        ]);\n    };\n    ErrorUtils.InvalidHookArguments = (hook) => {\n        return createError(ErrorEnum.INVALID_HOOK_ARGS_LENGTH, [\n            'hook handlers must have 0 to 2 arguments',\n            `but got ${hook.handler.length}`,\n        ]);\n    };\n})(ErrorUtils || (ErrorUtils = {}));\nexport var HookUtils;\n(function (HookUtils) {\n    /** 处理 runtime hooks */\n    HookUtils.normalize = (hookConfig = [], hookMap) => {\n        const runtimeHook = Array.isArray(hookConfig) ? hookConfig : [hookConfig];\n        const innerHooks = [];\n        hookMap.forEach(val => {\n            innerHooks.push(val);\n        });\n        return [...innerHooks, ...runtimeHook].filter(item => item && !!item.handler);\n    };\n    /** 排序 hooks */\n    HookUtils.sort = (hooks = [], hookMap) => {\n        const edges = [];\n        hooks.forEach(hook => {\n            if (hook.before) {\n                if (!hookMap.has(hook.before)) {\n                    throw ErrorUtils.HookBeforeError();\n                }\n                const edge = [hookMap.get(hook.before), hook];\n                edges.push(edge);\n            }\n            if (hook.after) {\n                if (!hookMap.has(hook.after)) {\n                    throw ErrorUtils.HookBeforeError();\n                }\n                const edge = [hook, hookMap.get(hook.after)];\n                edges.push(edge);\n            }\n        });\n        const sortedHooks = toposort(edges);\n        sortedHooks.reverse();\n        return sortedHooks;\n    };\n})(HookUtils || (HookUtils = {}));\nexport class Deferred {\n    constructor() {\n        this.isResolved = false;\n        this.isRejected = false;\n        this.promise = new Promise((resolve, reject) => {\n            this.resolve = args => {\n                this.isResolved = true;\n                resolve(args);\n            };\n            this.reject = args => {\n                this.isRejected = true;\n                reject(args);\n            };\n        });\n    }\n}\n//# sourceMappingURL=utils.js.map"]},"metadata":{},"sourceType":"module"}