{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * An implementation of the Priority Queue abstract data type.\n *\n * @see: http://en.wikipedia.org/wiki/Priority_queue\n *\n * It is like a normal stack or queue, but where each item has assigned a\n * priority (a number). Items with higher priority are served before items\n * with lower priority. This implementation uses binary heap as an internal\n * representation of the queue. The time complexity of all the methods is as\n * follows:\n *\n * - create: `O(n)`\n * - insert: `O(log n)`\n * - remove: `O(log n)`\n * - peek: `O(1)`\n * - isEmpty: `O(1)`\n * - peekPriority: `O(1)`\n */\nexport var PriorityQueue = /*#__PURE__*/function () {\n  function PriorityQueue() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, PriorityQueue);\n\n    this.comparator = options.comparator || PriorityQueue.defaultComparator;\n    this.index = {};\n    this.data = options.data || [];\n    this.heapify();\n  }\n  /**\n   * Returns `true` if the priority queue is empty, `false` otherwise.\n   */\n\n\n  _createClass(PriorityQueue, [{\n    key: \"isEmpty\",\n    value: function isEmpty() {\n      return this.data.length === 0;\n    }\n    /**\n     * Inserts a value with priority to the queue. Optionally pass a unique\n     * id of this item. Passing unique IDs for each item you insert allows\n     * you to use the `updatePriority()` operation.\n     * @param priority\n     * @param value\n     * @param id\n     */\n\n  }, {\n    key: \"insert\",\n    value: function insert(priority, value, id) {\n      var item = {\n        priority: priority,\n        value: value\n      };\n      var index = this.data.length - 1;\n\n      if (id) {\n        item.id = id;\n        this.index[id] = index;\n      }\n\n      this.data.push(item);\n      this.bubbleUp(index);\n      return this;\n    }\n    /**\n     * Returns the value of an item with the highest priority.\n     */\n\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this.data[0] ? this.data[0].value : null;\n    }\n    /**\n     * Returns the highest priority in the queue.\n     */\n\n  }, {\n    key: \"peekPriority\",\n    value: function peekPriority() {\n      return this.data[0] ? this.data[0].priority : null;\n    }\n  }, {\n    key: \"updatePriority\",\n    value: function updatePriority(id, priority) {\n      var index = this.index[id];\n\n      if (typeof index === 'undefined') {\n        throw new Error(\"Node with id '\".concat(id, \"' was not found in the heap.\"));\n      }\n\n      var data = this.data;\n      var oldPriority = data[index].priority;\n      var comp = this.comparator(priority, oldPriority);\n\n      if (comp < 0) {\n        data[index].priority = priority;\n        this.bubbleUp(index);\n      } else if (comp > 0) {\n        data[index].priority = priority;\n        this.bubbleDown(index);\n      }\n    }\n    /**\n     * Removes the item with the highest priority from the queue\n     *\n     * @returns The value of the removed item.\n     */\n\n  }, {\n    key: \"remove\",\n    value: function remove() {\n      var data = this.data;\n      var peek = data[0];\n      var last = data.pop();\n      delete this.index[data.length];\n\n      if (data.length > 0) {\n        data[0] = last;\n\n        if (last.id) {\n          this.index[last.id] = 0;\n        }\n\n        this.bubbleDown(0);\n      }\n\n      return peek ? peek.value : null;\n    }\n  }, {\n    key: \"heapify\",\n    value: function heapify() {\n      for (var i = 0; i < this.data.length; i += 1) {\n        this.bubbleUp(i);\n      }\n    }\n  }, {\n    key: \"bubbleUp\",\n    value: function bubbleUp(index) {\n      var data = this.data;\n      var tmp;\n      var parent;\n      var current = index;\n\n      while (current > 0) {\n        parent = current - 1 >>> 1;\n\n        if (this.comparator(data[current].priority, data[parent].priority) < 0) {\n          tmp = data[parent];\n          data[parent] = data[current];\n          var id = data[current].id;\n\n          if (id != null) {\n            this.index[id] = parent;\n          }\n\n          data[current] = tmp;\n          id = data[current].id;\n\n          if (id != null) {\n            this.index[id] = current;\n          }\n\n          current = parent;\n        } else {\n          break;\n        }\n      }\n    }\n  }, {\n    key: \"bubbleDown\",\n    value: function bubbleDown(index) {\n      var data = this.data;\n      var last = data.length - 1;\n      var current = index; // eslint-disable-next-line\n\n      while (true) {\n        var left = (current << 1) + 1;\n        var right = left + 1;\n        var minIndex = current;\n\n        if (left <= last && this.comparator(data[left].priority, data[minIndex].priority) < 0) {\n          minIndex = left;\n        }\n\n        if (right <= last && this.comparator(data[right].priority, data[minIndex].priority) < 0) {\n          minIndex = right;\n        }\n\n        if (minIndex !== current) {\n          var tmp = data[minIndex];\n          data[minIndex] = data[current];\n          var id = data[current].id;\n\n          if (id != null) {\n            this.index[id] = minIndex;\n          }\n\n          data[current] = tmp;\n          id = data[current].id;\n\n          if (id != null) {\n            this.index[id] = current;\n          }\n\n          current = minIndex;\n        } else {\n          break;\n        }\n      }\n    }\n  }]);\n\n  return PriorityQueue;\n}();\n\n(function (PriorityQueue) {\n  PriorityQueue.defaultComparator = function (a, b) {\n    return a - b;\n  };\n})(PriorityQueue || (PriorityQueue = {}));","map":{"version":3,"sources":["../../../src/common/algorithm/priorityqueue.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * An implementation of the Priority Queue abstract data type.\n *\n * @see: http://en.wikipedia.org/wiki/Priority_queue\n *\n * It is like a normal stack or queue, but where each item has assigned a\n * priority (a number). Items with higher priority are served before items\n * with lower priority. This implementation uses binary heap as an internal\n * representation of the queue. The time complexity of all the methods is as\n * follows:\n *\n * - create: `O(n)`\n * - insert: `O(log n)`\n * - remove: `O(log n)`\n * - peek: `O(1)`\n * - isEmpty: `O(1)`\n * - peekPriority: `O(1)`\n */\nexport class PriorityQueue {\n    constructor(options = {}) {\n        this.comparator = options.comparator || PriorityQueue.defaultComparator;\n        this.index = {};\n        this.data = options.data || [];\n        this.heapify();\n    }\n    /**\n     * Returns `true` if the priority queue is empty, `false` otherwise.\n     */\n    isEmpty() {\n        return this.data.length === 0;\n    }\n    /**\n     * Inserts a value with priority to the queue. Optionally pass a unique\n     * id of this item. Passing unique IDs for each item you insert allows\n     * you to use the `updatePriority()` operation.\n     * @param priority\n     * @param value\n     * @param id\n     */\n    insert(priority, value, id) {\n        const item = { priority, value };\n        const index = this.data.length - 1;\n        if (id) {\n            item.id = id;\n            this.index[id] = index;\n        }\n        this.data.push(item);\n        this.bubbleUp(index);\n        return this;\n    }\n    /**\n     * Returns the value of an item with the highest priority.\n     */\n    peek() {\n        return this.data[0] ? this.data[0].value : null;\n    }\n    /**\n     * Returns the highest priority in the queue.\n     */\n    peekPriority() {\n        return this.data[0] ? this.data[0].priority : null;\n    }\n    updatePriority(id, priority) {\n        const index = this.index[id];\n        if (typeof index === 'undefined') {\n            throw new Error(`Node with id '${id}' was not found in the heap.`);\n        }\n        const data = this.data;\n        const oldPriority = data[index].priority;\n        const comp = this.comparator(priority, oldPriority);\n        if (comp < 0) {\n            data[index].priority = priority;\n            this.bubbleUp(index);\n        }\n        else if (comp > 0) {\n            data[index].priority = priority;\n            this.bubbleDown(index);\n        }\n    }\n    /**\n     * Removes the item with the highest priority from the queue\n     *\n     * @returns The value of the removed item.\n     */\n    remove() {\n        const data = this.data;\n        const peek = data[0];\n        const last = data.pop();\n        delete this.index[data.length];\n        if (data.length > 0) {\n            data[0] = last;\n            if (last.id) {\n                this.index[last.id] = 0;\n            }\n            this.bubbleDown(0);\n        }\n        return peek ? peek.value : null;\n    }\n    heapify() {\n        for (let i = 0; i < this.data.length; i += 1) {\n            this.bubbleUp(i);\n        }\n    }\n    bubbleUp(index) {\n        const data = this.data;\n        let tmp;\n        let parent;\n        let current = index;\n        while (current > 0) {\n            parent = (current - 1) >>> 1;\n            if (this.comparator(data[current].priority, data[parent].priority) < 0) {\n                tmp = data[parent];\n                data[parent] = data[current];\n                let id = data[current].id;\n                if (id != null) {\n                    this.index[id] = parent;\n                }\n                data[current] = tmp;\n                id = data[current].id;\n                if (id != null) {\n                    this.index[id] = current;\n                }\n                current = parent;\n            }\n            else {\n                break;\n            }\n        }\n    }\n    bubbleDown(index) {\n        const data = this.data;\n        const last = data.length - 1;\n        let current = index;\n        // eslint-disable-next-line\n        while (true) {\n            const left = (current << 1) + 1;\n            const right = left + 1;\n            let minIndex = current;\n            if (left <= last &&\n                this.comparator(data[left].priority, data[minIndex].priority) < 0) {\n                minIndex = left;\n            }\n            if (right <= last &&\n                this.comparator(data[right].priority, data[minIndex].priority) < 0) {\n                minIndex = right;\n            }\n            if (minIndex !== current) {\n                const tmp = data[minIndex];\n                data[minIndex] = data[current];\n                let id = data[current].id;\n                if (id != null) {\n                    this.index[id] = minIndex;\n                }\n                data[current] = tmp;\n                id = data[current].id;\n                if (id != null) {\n                    this.index[id] = current;\n                }\n                current = minIndex;\n            }\n            else {\n                break;\n            }\n        }\n    }\n}\n(function (PriorityQueue) {\n    PriorityQueue.defaultComparator = (a, b) => a - b;\n})(PriorityQueue || (PriorityQueue = {}));\n//# sourceMappingURL=priorityqueue.js.map"]},"metadata":{},"sourceType":"module"}