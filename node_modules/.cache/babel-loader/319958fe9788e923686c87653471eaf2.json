{"ast":null,"code":"import { Util } from '../../global';\nimport { StringExt, FunctionExt } from '../../util';\nimport { Point, Rectangle, Angle } from '../../geometry';\nimport { Cell } from '../../model/cell';\nimport { notify } from '../transform/util';\nexport class NodePreset {\n  constructor(halo) {\n    this.halo = halo;\n  }\n\n  get options() {\n    return this.halo.options;\n  }\n\n  get graph() {\n    return this.halo.graph;\n  }\n\n  get model() {\n    return this.halo.model;\n  }\n\n  get view() {\n    return this.halo.view;\n  }\n\n  get cell() {\n    return this.halo.cell;\n  }\n\n  get node() {\n    return this.cell;\n  }\n\n  getPresets() {\n    return {\n      className: 'type-node',\n      handles: [{\n        name: 'remove',\n        position: 'nw',\n        events: {\n          mousedown: this.removeCell.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'resize',\n        position: 'se',\n        events: {\n          mousedown: this.startResize.bind(this),\n          mousemove: this.doResize.bind(this),\n          mouseup: this.stopResize.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'clone',\n        position: 'n',\n        events: {\n          mousedown: this.startClone.bind(this),\n          mousemove: this.doClone.bind(this),\n          mouseup: this.stopClone.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'link',\n        position: 'e',\n        events: {\n          mousedown: this.startLink.bind(this),\n          mousemove: this.doLink.bind(this),\n          mouseup: this.stopLink.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'fork',\n        position: 'ne',\n        events: {\n          mousedown: this.startFork.bind(this),\n          mousemove: this.doFork.bind(this),\n          mouseup: this.stopFork.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'unlink',\n        position: 'w',\n        events: {\n          mousedown: this.unlink.bind(this)\n        },\n        icon: null\n      }, {\n        name: 'rotate',\n        position: 'sw',\n        events: {\n          mousedown: this.startRotate.bind(this),\n          mousemove: this.doRotate.bind(this),\n          mouseup: this.stopRotate.bind(this)\n        },\n        icon: null\n      }],\n\n      bbox(view) {\n        if (this.options.useCellGeometry) {\n          const node = view.cell;\n          return node.getBBox();\n        }\n\n        return view.getBBox();\n      },\n\n      content(view) {\n        const template = StringExt.template('x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>');\n        const cell = view.cell;\n        const bbox = cell.getBBox();\n        return template({\n          x: Math.floor(bbox.x),\n          y: Math.floor(bbox.y),\n          width: Math.floor(bbox.width),\n          height: Math.floor(bbox.height),\n          angle: Math.floor(cell.getAngle())\n        });\n      },\n\n      magnet(view) {\n        return view.container;\n      },\n\n      tinyThreshold: 40,\n      smallThreshold: 80,\n      loopEdgePreferredSide: 'top',\n      loopEdgeWidth: 40,\n      rotateGrid: 15,\n      rotateEmbeds: false\n    };\n  }\n\n  removeCell() {\n    this.model.removeConnectedEdges(this.cell);\n    this.cell.remove();\n  } // #region create edge\n\n\n  startLink(_ref) {\n    let {\n      x,\n      y\n    } = _ref;\n    this.halo.startBatch();\n    const graph = this.graph;\n    const edge = this.createEdgeConnectedToSource();\n    edge.setTarget({\n      x,\n      y\n    });\n    this.model.addEdge(edge, {\n      validation: false,\n      halo: this.halo.cid,\n      async: false\n    });\n    graph.view.undelegateEvents();\n    this.edgeView = graph.renderer.findViewByCell(edge);\n    this.edgeView.prepareArrowheadDragging('target', {\n      x,\n      y,\n      fallbackAction: 'remove'\n    });\n  }\n\n  createEdgeConnectedToSource() {\n    const magnet = this.getMagnet(this.view, 'source');\n    const terminal = this.getEdgeTerminal(this.view, magnet);\n    const edge = this.graph.hook.getDefaultEdge(this.view, magnet);\n    edge.setSource(terminal);\n    return edge;\n  }\n\n  getMagnet(view, terminal) {\n    const magnet = this.options.magnet;\n\n    if (typeof magnet === 'function') {\n      const val = FunctionExt.call(magnet, this.halo, view, terminal);\n\n      if (val instanceof SVGElement) {\n        return val;\n      }\n    }\n\n    throw new Error('`magnet()` has to return an SVGElement');\n  }\n\n  getEdgeTerminal(view, magnet) {\n    const terminal = {\n      cell: view.cell.id\n    };\n\n    if (magnet !== view.container) {\n      const port = magnet.getAttribute('port');\n\n      if (port) {\n        terminal.port = port;\n      } else {\n        terminal.selector = view.getSelector(magnet);\n      }\n    }\n\n    return terminal;\n  }\n\n  doLink(_ref2) {\n    let {\n      e,\n      x,\n      y\n    } = _ref2;\n\n    if (this.edgeView) {\n      this.edgeView.onMouseMove(e, x, y);\n    }\n  }\n\n  stopLink(_ref3) {\n    let {\n      e,\n      x,\n      y\n    } = _ref3;\n    const edgeView = this.edgeView;\n\n    if (edgeView) {\n      edgeView.onMouseUp(e, x, y);\n      const edge = edgeView.cell;\n\n      if (edge.hasLoop()) {\n        this.makeLoopEdge(edge);\n      }\n\n      this.halo.stopBatch();\n      this.halo.trigger('action:edge:addde', {\n        edge\n      });\n      this.edgeView = null;\n    }\n\n    this.graph.view.delegateEvents();\n  }\n\n  makeLoopEdge(edge) {\n    let vertex1 = null;\n    let vertex2 = null;\n    const loopEdgeWidth = this.options.loopEdgeWidth;\n    const graphOptions = this.graph.options;\n    const graphRect = new Rectangle(0, 0, graphOptions.width, graphOptions.height);\n    const bbox = this.graph.graphToLocal(this.view.getBBox());\n    const found = [this.options.loopEdgePreferredSide, 'top', 'bottom', 'left', 'right'].some(position => {\n      let point = null;\n      let dx = 0;\n      let dy = 0;\n\n      switch (position) {\n        case 'top':\n          point = new Point(bbox.x + bbox.width / 2, bbox.y - loopEdgeWidth);\n          dx = loopEdgeWidth / 2;\n          break;\n\n        case 'bottom':\n          point = new Point(bbox.x + bbox.width / 2, bbox.y + bbox.height + loopEdgeWidth);\n          dx = loopEdgeWidth / 2;\n          break;\n\n        case 'left':\n          point = new Point(bbox.x - loopEdgeWidth, bbox.y + bbox.height / 2);\n          dy = loopEdgeWidth / 2;\n          break;\n\n        case 'right':\n          point = new Point(bbox.x + bbox.width + loopEdgeWidth, bbox.y + bbox.height / 2);\n          dy = loopEdgeWidth / 2;\n          break;\n\n        default:\n          break;\n      }\n\n      if (point) {\n        vertex1 = point.translate(-dx, -dy);\n        vertex2 = point.translate(dx, dy);\n        return graphRect.containsPoint(vertex1) && graphRect.containsPoint(vertex2);\n      }\n\n      return false;\n    });\n\n    if (found && vertex1 && vertex2) {\n      edge.setVertices([vertex1, vertex2]);\n    }\n  } // #endregion\n  // #region resize\n\n\n  startResize(_ref4) {\n    let {\n      e\n    } = _ref4;\n    this.halo.startBatch();\n    this.flip = [1, 0, 0, 1, 1, 0, 0, 1][Math.floor(Angle.normalize(this.node.getAngle()) / 45)];\n    this.view.addClass('node-resizing');\n    notify('node:resize', e, this.view);\n  }\n\n  doResize(_ref5) {\n    let {\n      e,\n      dx,\n      dy\n    } = _ref5;\n    const size = this.node.getSize();\n    const width = Math.max(size.width + (this.flip ? dx : dy), 1);\n    const height = Math.max(size.height + (this.flip ? dy : dx), 1);\n    this.node.resize(width, height, {\n      absolute: true\n    });\n    notify('node:resizing', e, this.view);\n  }\n\n  stopResize(_ref6) {\n    let {\n      e\n    } = _ref6;\n    this.view.removeClass('node-resizing');\n    notify('node:resized', e, this.view);\n    this.halo.stopBatch();\n  } // #endregion\n  // #region clone\n\n\n  startClone(_ref7) {\n    let {\n      e,\n      x,\n      y\n    } = _ref7;\n    this.halo.startBatch();\n    const options = this.options;\n    const cloned = options.clone(this.cell, {\n      clone: true\n    });\n\n    if (!Cell.isCell(cloned)) {\n      throw new Error(\"option 'clone()' has to return a cell\");\n    }\n\n    this.centerNodeAtCursor(cloned, x, y);\n    this.model.addCell(cloned, {\n      halo: this.halo.cid,\n      async: false\n    });\n    const cloneView = this.graph.renderer.findViewByCell(cloned);\n    cloneView.onMouseDown(e, x, y);\n    this.halo.setEventData(e, {\n      cloneView\n    });\n  }\n\n  centerNodeAtCursor(cell, x, y) {\n    const center = cell.getBBox().getCenter();\n    const dx = x - center.x;\n    const dy = y - center.y;\n    cell.translate(dx, dy);\n  }\n\n  doClone(_ref8) {\n    let {\n      e,\n      x,\n      y\n    } = _ref8;\n    const view = this.halo.getEventData(e).cloneView;\n\n    if (view) {\n      view.onMouseMove(e, x, y);\n    }\n  }\n\n  stopClone(_ref9) {\n    let {\n      e,\n      x,\n      y\n    } = _ref9;\n    const nodeView = this.halo.getEventData(e).cloneView;\n\n    if (nodeView) {\n      nodeView.onMouseUp(e, x, y);\n    }\n\n    this.halo.stopBatch();\n  } // #endregion\n  // #region fork\n\n\n  startFork(_ref10) {\n    let {\n      e,\n      x,\n      y\n    } = _ref10;\n    this.halo.startBatch();\n    const cloned = this.options.clone(this.cell, {\n      fork: true\n    });\n\n    if (!Cell.isCell(cloned)) {\n      throw new Error(\"option 'clone()' has to return a cell\");\n    }\n\n    this.centerNodeAtCursor(cloned, x, y);\n    this.model.addCell(cloned, {\n      halo: this.halo.cid,\n      async: false\n    });\n    const edge = this.createEdgeConnectedToSource();\n    const cloneView = this.graph.renderer.findViewByCell(cloned);\n    const magnet = this.getMagnet(cloneView, 'target');\n    const terminal = this.getEdgeTerminal(cloneView, magnet);\n    edge.setTarget(terminal);\n    this.model.addEdge(edge, {\n      halo: this.halo.cid,\n      async: false\n    });\n    cloneView.onMouseDown(e, x, y);\n    this.halo.setEventData(e, {\n      cloneView\n    });\n  }\n\n  doFork(_ref11) {\n    let {\n      e,\n      x,\n      y\n    } = _ref11;\n    const view = this.halo.getEventData(e).cloneView;\n\n    if (view) {\n      view.onMouseMove(e, x, y);\n    }\n  }\n\n  stopFork(_ref12) {\n    let {\n      e,\n      x,\n      y\n    } = _ref12;\n    const view = this.halo.getEventData(e).cloneView;\n\n    if (view) {\n      view.onMouseUp(e, x, y);\n    }\n\n    this.halo.stopBatch();\n  } // #endregion\n  // #region rotate\n\n\n  startRotate(_ref13) {\n    let {\n      e,\n      x,\n      y\n    } = _ref13;\n    this.halo.startBatch();\n    const center = this.node.getBBox().getCenter();\n    const nodes = [this.node];\n\n    if (this.options.rotateEmbeds) {\n      this.node.getDescendants({\n        deep: true\n      }).reduce((memo, cell) => {\n        if (cell.isNode()) {\n          memo.push(cell);\n        }\n\n        return memo;\n      }, nodes);\n    }\n\n    this.halo.setEventData(e, {\n      center,\n      nodes,\n      rotateStartAngles: nodes.map(node => node.getAngle()),\n      clientStartAngle: new Point(x, y).theta(center)\n    });\n    nodes.forEach(node => {\n      const view = this.graph.findViewByCell(node);\n\n      if (view) {\n        view.addClass('node-rotating');\n        notify('node:rotate', e, view);\n      }\n    });\n  }\n\n  doRotate(_ref14) {\n    let {\n      e,\n      x,\n      y\n    } = _ref14;\n    const data = this.halo.getEventData(e);\n    const delta = data.clientStartAngle - new Point(x, y).theta(data.center);\n    data.nodes.forEach((node, index) => {\n      const startAngle = data.rotateStartAngles[index];\n      const targetAngle = Util.snapToGrid(startAngle + delta, this.options.rotateGrid);\n      node.rotate(targetAngle, {\n        absolute: true,\n        center: data.center,\n        halo: this.halo.cid\n      });\n      notify('node:rotating', e, this.graph.findViewByCell(node));\n    });\n  }\n\n  stopRotate(_ref15) {\n    let {\n      e\n    } = _ref15;\n    const data = this.halo.getEventData(e);\n    data.nodes.forEach(node => {\n      const view = this.graph.findViewByCell(node);\n      view.removeClass('node-rotating');\n      notify('node:rotated', e, view);\n    });\n    this.halo.stopBatch();\n  } // #endregion\n  // #region unlink\n\n\n  unlink() {\n    this.halo.startBatch();\n    this.model.removeConnectedEdges(this.cell);\n    this.halo.stopBatch();\n  }\n\n}","map":{"version":3,"sources":["../../../src/addon/halo/node-preset.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Util } from '../../global';\nimport { StringExt, FunctionExt } from '../../util';\nimport { Point, Rectangle, Angle } from '../../geometry';\nimport { Cell } from '../../model/cell';\nimport { notify } from '../transform/util';\nexport class NodePreset {\n    constructor(halo) {\n        this.halo = halo;\n    }\n    get options() {\n        return this.halo.options;\n    }\n    get graph() {\n        return this.halo.graph;\n    }\n    get model() {\n        return this.halo.model;\n    }\n    get view() {\n        return this.halo.view;\n    }\n    get cell() {\n        return this.halo.cell;\n    }\n    get node() {\n        return this.cell;\n    }\n    getPresets() {\n        return {\n            className: 'type-node',\n            handles: [\n                {\n                    name: 'remove',\n                    position: 'nw',\n                    events: {\n                        mousedown: this.removeCell.bind(this),\n                    },\n                    icon: null,\n                },\n                {\n                    name: 'resize',\n                    position: 'se',\n                    events: {\n                        mousedown: this.startResize.bind(this),\n                        mousemove: this.doResize.bind(this),\n                        mouseup: this.stopResize.bind(this),\n                    },\n                    icon: null,\n                },\n                {\n                    name: 'clone',\n                    position: 'n',\n                    events: {\n                        mousedown: this.startClone.bind(this),\n                        mousemove: this.doClone.bind(this),\n                        mouseup: this.stopClone.bind(this),\n                    },\n                    icon: null,\n                },\n                {\n                    name: 'link',\n                    position: 'e',\n                    events: {\n                        mousedown: this.startLink.bind(this),\n                        mousemove: this.doLink.bind(this),\n                        mouseup: this.stopLink.bind(this),\n                    },\n                    icon: null,\n                },\n                {\n                    name: 'fork',\n                    position: 'ne',\n                    events: {\n                        mousedown: this.startFork.bind(this),\n                        mousemove: this.doFork.bind(this),\n                        mouseup: this.stopFork.bind(this),\n                    },\n                    icon: null,\n                },\n                {\n                    name: 'unlink',\n                    position: 'w',\n                    events: {\n                        mousedown: this.unlink.bind(this),\n                    },\n                    icon: null,\n                },\n                {\n                    name: 'rotate',\n                    position: 'sw',\n                    events: {\n                        mousedown: this.startRotate.bind(this),\n                        mousemove: this.doRotate.bind(this),\n                        mouseup: this.stopRotate.bind(this),\n                    },\n                    icon: null,\n                },\n            ],\n            bbox(view) {\n                if (this.options.useCellGeometry) {\n                    const node = view.cell;\n                    return node.getBBox();\n                }\n                return view.getBBox();\n            },\n            content(view) {\n                const template = StringExt.template('x: <%= x %>, y: <%= y %>, width: <%= width %>, height: <%= height %>, angle: <%= angle %>');\n                const cell = view.cell;\n                const bbox = cell.getBBox();\n                return template({\n                    x: Math.floor(bbox.x),\n                    y: Math.floor(bbox.y),\n                    width: Math.floor(bbox.width),\n                    height: Math.floor(bbox.height),\n                    angle: Math.floor(cell.getAngle()),\n                });\n            },\n            magnet(view) {\n                return view.container;\n            },\n            tinyThreshold: 40,\n            smallThreshold: 80,\n            loopEdgePreferredSide: 'top',\n            loopEdgeWidth: 40,\n            rotateGrid: 15,\n            rotateEmbeds: false,\n        };\n    }\n    removeCell() {\n        this.model.removeConnectedEdges(this.cell);\n        this.cell.remove();\n    }\n    // #region create edge\n    startLink({ x, y }) {\n        this.halo.startBatch();\n        const graph = this.graph;\n        const edge = this.createEdgeConnectedToSource();\n        edge.setTarget({ x, y });\n        this.model.addEdge(edge, {\n            validation: false,\n            halo: this.halo.cid,\n            async: false,\n        });\n        graph.view.undelegateEvents();\n        this.edgeView = graph.renderer.findViewByCell(edge);\n        this.edgeView.prepareArrowheadDragging('target', {\n            x,\n            y,\n            fallbackAction: 'remove',\n        });\n    }\n    createEdgeConnectedToSource() {\n        const magnet = this.getMagnet(this.view, 'source');\n        const terminal = this.getEdgeTerminal(this.view, magnet);\n        const edge = this.graph.hook.getDefaultEdge(this.view, magnet);\n        edge.setSource(terminal);\n        return edge;\n    }\n    getMagnet(view, terminal) {\n        const magnet = this.options.magnet;\n        if (typeof magnet === 'function') {\n            const val = FunctionExt.call(magnet, this.halo, view, terminal);\n            if (val instanceof SVGElement) {\n                return val;\n            }\n        }\n        throw new Error('`magnet()` has to return an SVGElement');\n    }\n    getEdgeTerminal(view, magnet) {\n        const terminal = {\n            cell: view.cell.id,\n        };\n        if (magnet !== view.container) {\n            const port = magnet.getAttribute('port');\n            if (port) {\n                terminal.port = port;\n            }\n            else {\n                terminal.selector = view.getSelector(magnet);\n            }\n        }\n        return terminal;\n    }\n    doLink({ e, x, y }) {\n        if (this.edgeView) {\n            this.edgeView.onMouseMove(e, x, y);\n        }\n    }\n    stopLink({ e, x, y }) {\n        const edgeView = this.edgeView;\n        if (edgeView) {\n            edgeView.onMouseUp(e, x, y);\n            const edge = edgeView.cell;\n            if (edge.hasLoop()) {\n                this.makeLoopEdge(edge);\n            }\n            this.halo.stopBatch();\n            this.halo.trigger('action:edge:addde', { edge });\n            this.edgeView = null;\n        }\n        this.graph.view.delegateEvents();\n    }\n    makeLoopEdge(edge) {\n        let vertex1 = null;\n        let vertex2 = null;\n        const loopEdgeWidth = this.options.loopEdgeWidth;\n        const graphOptions = this.graph.options;\n        const graphRect = new Rectangle(0, 0, graphOptions.width, graphOptions.height);\n        const bbox = this.graph.graphToLocal(this.view.getBBox());\n        const found = [\n            this.options.loopEdgePreferredSide,\n            'top',\n            'bottom',\n            'left',\n            'right',\n        ].some((position) => {\n            let point = null;\n            let dx = 0;\n            let dy = 0;\n            switch (position) {\n                case 'top':\n                    point = new Point(bbox.x + bbox.width / 2, bbox.y - loopEdgeWidth);\n                    dx = loopEdgeWidth / 2;\n                    break;\n                case 'bottom':\n                    point = new Point(bbox.x + bbox.width / 2, bbox.y + bbox.height + loopEdgeWidth);\n                    dx = loopEdgeWidth / 2;\n                    break;\n                case 'left':\n                    point = new Point(bbox.x - loopEdgeWidth, bbox.y + bbox.height / 2);\n                    dy = loopEdgeWidth / 2;\n                    break;\n                case 'right':\n                    point = new Point(bbox.x + bbox.width + loopEdgeWidth, bbox.y + bbox.height / 2);\n                    dy = loopEdgeWidth / 2;\n                    break;\n                default:\n                    break;\n            }\n            if (point) {\n                vertex1 = point.translate(-dx, -dy);\n                vertex2 = point.translate(dx, dy);\n                return (graphRect.containsPoint(vertex1) && graphRect.containsPoint(vertex2));\n            }\n            return false;\n        });\n        if (found && vertex1 && vertex2) {\n            edge.setVertices([vertex1, vertex2]);\n        }\n    }\n    // #endregion\n    // #region resize\n    startResize({ e }) {\n        this.halo.startBatch();\n        this.flip = [1, 0, 0, 1, 1, 0, 0, 1][Math.floor(Angle.normalize(this.node.getAngle()) / 45)];\n        this.view.addClass('node-resizing');\n        notify('node:resize', e, this.view);\n    }\n    doResize({ e, dx, dy }) {\n        const size = this.node.getSize();\n        const width = Math.max(size.width + (this.flip ? dx : dy), 1);\n        const height = Math.max(size.height + (this.flip ? dy : dx), 1);\n        this.node.resize(width, height, {\n            absolute: true,\n        });\n        notify('node:resizing', e, this.view);\n    }\n    stopResize({ e }) {\n        this.view.removeClass('node-resizing');\n        notify('node:resized', e, this.view);\n        this.halo.stopBatch();\n    }\n    // #endregion\n    // #region clone\n    startClone({ e, x, y }) {\n        this.halo.startBatch();\n        const options = this.options;\n        const cloned = options.clone(this.cell, {\n            clone: true,\n        });\n        if (!Cell.isCell(cloned)) {\n            throw new Error(\"option 'clone()' has to return a cell\");\n        }\n        this.centerNodeAtCursor(cloned, x, y);\n        this.model.addCell(cloned, {\n            halo: this.halo.cid,\n            async: false,\n        });\n        const cloneView = this.graph.renderer.findViewByCell(cloned);\n        cloneView.onMouseDown(e, x, y);\n        this.halo.setEventData(e, { cloneView });\n    }\n    centerNodeAtCursor(cell, x, y) {\n        const center = cell.getBBox().getCenter();\n        const dx = x - center.x;\n        const dy = y - center.y;\n        cell.translate(dx, dy);\n    }\n    doClone({ e, x, y }) {\n        const view = this.halo.getEventData(e).cloneView;\n        if (view) {\n            view.onMouseMove(e, x, y);\n        }\n    }\n    stopClone({ e, x, y }) {\n        const nodeView = this.halo.getEventData(e).cloneView;\n        if (nodeView) {\n            nodeView.onMouseUp(e, x, y);\n        }\n        this.halo.stopBatch();\n    }\n    // #endregion\n    // #region fork\n    startFork({ e, x, y }) {\n        this.halo.startBatch();\n        const cloned = this.options.clone(this.cell, {\n            fork: true,\n        });\n        if (!Cell.isCell(cloned)) {\n            throw new Error(\"option 'clone()' has to return a cell\");\n        }\n        this.centerNodeAtCursor(cloned, x, y);\n        this.model.addCell(cloned, {\n            halo: this.halo.cid,\n            async: false,\n        });\n        const edge = this.createEdgeConnectedToSource();\n        const cloneView = this.graph.renderer.findViewByCell(cloned);\n        const magnet = this.getMagnet(cloneView, 'target');\n        const terminal = this.getEdgeTerminal(cloneView, magnet);\n        edge.setTarget(terminal);\n        this.model.addEdge(edge, {\n            halo: this.halo.cid,\n            async: false,\n        });\n        cloneView.onMouseDown(e, x, y);\n        this.halo.setEventData(e, { cloneView });\n    }\n    doFork({ e, x, y }) {\n        const view = this.halo.getEventData(e).cloneView;\n        if (view) {\n            view.onMouseMove(e, x, y);\n        }\n    }\n    stopFork({ e, x, y }) {\n        const view = this.halo.getEventData(e).cloneView;\n        if (view) {\n            view.onMouseUp(e, x, y);\n        }\n        this.halo.stopBatch();\n    }\n    // #endregion\n    // #region rotate\n    startRotate({ e, x, y }) {\n        this.halo.startBatch();\n        const center = this.node.getBBox().getCenter();\n        const nodes = [this.node];\n        if (this.options.rotateEmbeds) {\n            this.node\n                .getDescendants({\n                deep: true,\n            })\n                .reduce((memo, cell) => {\n                if (cell.isNode()) {\n                    memo.push(cell);\n                }\n                return memo;\n            }, nodes);\n        }\n        this.halo.setEventData(e, {\n            center,\n            nodes,\n            rotateStartAngles: nodes.map((node) => node.getAngle()),\n            clientStartAngle: new Point(x, y).theta(center),\n        });\n        nodes.forEach((node) => {\n            const view = this.graph.findViewByCell(node);\n            if (view) {\n                view.addClass('node-rotating');\n                notify('node:rotate', e, view);\n            }\n        });\n    }\n    doRotate({ e, x, y }) {\n        const data = this.halo.getEventData(e);\n        const delta = data.clientStartAngle - new Point(x, y).theta(data.center);\n        data.nodes.forEach((node, index) => {\n            const startAngle = data.rotateStartAngles[index];\n            const targetAngle = Util.snapToGrid(startAngle + delta, this.options.rotateGrid);\n            node.rotate(targetAngle, {\n                absolute: true,\n                center: data.center,\n                halo: this.halo.cid,\n            });\n            notify('node:rotating', e, this.graph.findViewByCell(node));\n        });\n    }\n    stopRotate({ e }) {\n        const data = this.halo.getEventData(e);\n        data.nodes.forEach((node) => {\n            const view = this.graph.findViewByCell(node);\n            view.removeClass('node-rotating');\n            notify('node:rotated', e, view);\n        });\n        this.halo.stopBatch();\n    }\n    // #endregion\n    // #region unlink\n    unlink() {\n        this.halo.startBatch();\n        this.model.removeConnectedEdges(this.cell);\n        this.halo.stopBatch();\n    }\n}\n//# sourceMappingURL=node-preset.js.map"]},"metadata":{},"sourceType":"module"}