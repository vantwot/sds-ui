{"ast":null,"code":"\"use strict\";\n\nvar _ = require(\"./lodash\");\n\nvar acyclic = require(\"./acyclic\");\n\nvar normalize = require(\"./normalize\");\n\nvar rank = require(\"./rank\");\n\nvar normalizeRanks = require(\"./util\").normalizeRanks;\n\nvar parentDummyChains = require(\"./parent-dummy-chains\");\n\nvar removeEmptyRanks = require(\"./util\").removeEmptyRanks;\n\nvar nestingGraph = require(\"./nesting-graph\");\n\nvar addBorderSegments = require(\"./add-border-segments\");\n\nvar coordinateSystem = require(\"./coordinate-system\");\n\nvar order = require(\"./order\");\n\nvar position = require(\"./position\");\n\nvar util = require(\"./util\");\n\nvar Graph = require(\"./graphlib\").Graph;\n\nvar initDataOrder = require(\"./order/init-data-order\");\n\nmodule.exports = layout;\n\nfunction layout(g, opts) {\n  var time = opts && opts.debugTiming ? util.time : util.notime;\n  time(\"layout\", function () {\n    // 如果在原图基础上修改，继承原图的order结果\n    if (opts && !opts.keepNodeOrder && opts.prevGraph) {\n      time(\"  inheritOrder\", function () {\n        inheritOrder(g, opts.prevGraph);\n      });\n    }\n\n    var layoutGraph = time(\"  buildLayoutGraph\", function () {\n      return buildLayoutGraph(g);\n    }); // 控制是否为边的label留位置（这会影响是否在边中间添加dummy node）\n\n    if (!(opts && opts.edgeLabelSpace === false)) {\n      time(\"  makeSpaceForEdgeLabels\", function () {\n        makeSpaceForEdgeLabels(layoutGraph);\n      });\n    } // TODO: 暂时处理层级设置不正确时的异常报错，提示设置正确的层级\n\n\n    try {\n      time(\"  runLayout\", function () {\n        runLayout(layoutGraph, time, opts);\n      });\n    } catch (e) {\n      if (e.message === \"Not possible to find intersection inside of the rectangle\") {\n        console.error('The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph\\'s structure:\\n', e);\n        return;\n      } else {\n        throw e;\n      }\n    }\n\n    time(\"  updateInputGraph\", function () {\n      updateInputGraph(g, layoutGraph);\n    });\n  });\n}\n\nfunction runLayout(g, time, opts) {\n  time(\"    removeSelfEdges\", function () {\n    removeSelfEdges(g);\n  });\n  time(\"    acyclic\", function () {\n    acyclic.run(g);\n  });\n  time(\"    nestingGraph.run\", function () {\n    nestingGraph.run(g);\n  });\n  time(\"    rank\", function () {\n    rank(util.asNonCompoundGraph(g));\n  });\n  time(\"    injectEdgeLabelProxies\", function () {\n    injectEdgeLabelProxies(g);\n  });\n  time(\"    removeEmptyRanks\", function () {\n    removeEmptyRanks(g);\n  });\n  time(\"    nestingGraph.cleanup\", function () {\n    nestingGraph.cleanup(g);\n  });\n  time(\"    normalizeRanks\", function () {\n    normalizeRanks(g);\n  });\n  time(\"    assignRankMinMax\", function () {\n    assignRankMinMax(g);\n  });\n  time(\"    removeEdgeLabelProxies\", function () {\n    removeEdgeLabelProxies(g);\n  });\n  time(\"    normalize.run\", function () {\n    normalize.run(g);\n  });\n  time(\"    parentDummyChains\", function () {\n    parentDummyChains(g);\n  });\n  time(\"    addBorderSegments\", function () {\n    addBorderSegments(g);\n  });\n\n  if (opts && opts.keepNodeOrder) {\n    time(\"    initDataOrder\", function () {\n      initDataOrder(g, opts.nodeOrder);\n    });\n  }\n\n  time(\"    order\", function () {\n    order(g);\n  });\n  time(\"    insertSelfEdges\", function () {\n    insertSelfEdges(g);\n  });\n  time(\"    adjustCoordinateSystem\", function () {\n    coordinateSystem.adjust(g);\n  });\n  time(\"    position\", function () {\n    position(g);\n  });\n  time(\"    positionSelfEdges\", function () {\n    positionSelfEdges(g);\n  });\n  time(\"    removeBorderNodes\", function () {\n    removeBorderNodes(g);\n  });\n  time(\"    normalize.undo\", function () {\n    normalize.undo(g);\n  });\n  time(\"    fixupEdgeLabelCoords\", function () {\n    fixupEdgeLabelCoords(g);\n  });\n  time(\"    undoCoordinateSystem\", function () {\n    coordinateSystem.undo(g);\n  });\n  time(\"    translateGraph\", function () {\n    translateGraph(g);\n  });\n  time(\"    assignNodeIntersects\", function () {\n    assignNodeIntersects(g);\n  });\n  time(\"    reversePoints\", function () {\n    reversePointsForReversedEdges(g);\n  });\n  time(\"    acyclic.undo\", function () {\n    acyclic.undo(g);\n  });\n}\n/**\n * 继承上一个布局中的order，防止翻转\n * TODO: 暂时没有考虑涉及层级变动的布局，只保证原来布局层级和相对顺序不变\n */\n\n\nfunction inheritOrder(currG, prevG) {\n  var prevNodeMap = prevG._nodes;\n\n  _.forEach(currG.nodes(), function (n) {\n    var node = currG.node(n);\n\n    if (prevNodeMap[n] !== undefined) {\n      node.fixorder = prevNodeMap[n]._order;\n      delete prevNodeMap[n]._order;\n    } else {\n      delete node.fixorder;\n    }\n  });\n}\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\n\n\nfunction updateInputGraph(inputGraph, layoutGraph) {\n  _.forEach(inputGraph.nodes(), function (v) {\n    var inputLabel = inputGraph.node(v);\n    var layoutLabel = layoutGraph.node(v);\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n      inputLabel._order = layoutLabel.order;\n      inputLabel._rank = layoutLabel.rank;\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n\n  _.forEach(inputGraph.edges(), function (e) {\n    var inputLabel = inputGraph.edge(e);\n    var layoutLabel = layoutGraph.edge(e);\n    inputLabel.points = layoutLabel.points;\n\n    if (_.has(layoutLabel, \"x\")) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n}\n\nvar graphNumAttrs = [\"nodesep\", \"edgesep\", \"ranksep\", \"marginx\", \"marginy\"];\nvar graphDefaults = {\n  ranksep: 50,\n  edgesep: 20,\n  nodesep: 50,\n  rankdir: \"tb\"\n};\nvar graphAttrs = [\"acyclicer\", \"ranker\", \"rankdir\", \"align\"];\nvar nodeNumAttrs = [\"width\", \"height\", \"layer\", \"fixorder\"]; // 需要传入layer, fixOrder作为参数参考\n\nvar nodeDefaults = {\n  width: 0,\n  height: 0\n};\nvar edgeNumAttrs = [\"minlen\", \"weight\", \"width\", \"height\", \"labeloffset\"];\nvar edgeDefaults = {\n  minlen: 1,\n  weight: 1,\n  width: 0,\n  height: 0,\n  labeloffset: 10,\n  labelpos: \"r\"\n};\nvar edgeAttrs = [\"labelpos\"];\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\n\nfunction buildLayoutGraph(inputGraph) {\n  var g = new Graph({\n    multigraph: true,\n    compound: true\n  });\n  var graph = canonicalize(inputGraph.graph());\n  g.setGraph(_.merge({}, graphDefaults, selectNumberAttrs(graph, graphNumAttrs), _.pick(graph, graphAttrs)));\n\n  _.forEach(inputGraph.nodes(), function (v) {\n    var node = canonicalize(inputGraph.node(v));\n    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));\n    g.setParent(v, inputGraph.parent(v));\n  });\n\n  _.forEach(inputGraph.edges(), function (e) {\n    var edge = canonicalize(inputGraph.edge(e));\n    g.setEdge(e, _.merge({}, edgeDefaults, selectNumberAttrs(edge, edgeNumAttrs), _.pick(edge, edgeAttrs)));\n  });\n\n  return g;\n}\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\n\n\nfunction makeSpaceForEdgeLabels(g) {\n  var graph = g.graph();\n  graph.ranksep /= 2;\n\n  _.forEach(g.nodes(), function (n) {\n    var node = g.node(n);\n\n    if (!isNaN(node.layer)) {\n      node.layer *= 2; // TODO: 因为默认的rank变为两倍，设定的layer也*2\n    }\n  });\n\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    edge.minlen *= 2;\n\n    if (edge.labelpos.toLowerCase() !== \"c\") {\n      if (graph.rankdir === \"TB\" || graph.rankdir === \"BT\") {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n}\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\n\n\nfunction injectEdgeLabelProxies(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n\n    if (edge.width && edge.height) {\n      var v = g.node(e.v);\n      var w = g.node(e.w);\n      var label = {\n        rank: (w.rank - v.rank) / 2 + v.rank,\n        e: e\n      };\n      util.addDummyNode(g, \"edge-proxy\", label, \"_ep\");\n    }\n  });\n}\n\nfunction assignRankMinMax(g) {\n  var maxRank = 0;\n\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank;\n      node.maxRank = g.node(node.borderBottom).rank;\n      maxRank = _.max(maxRank, node.maxRank);\n    }\n  });\n\n  g.graph().maxRank = maxRank;\n}\n\nfunction removeEdgeLabelProxies(g) {\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n\n    if (node.dummy === \"edge-proxy\") {\n      g.edge(node.e).labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction translateGraph(g) {\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = 0;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = 0;\n  var graphLabel = g.graph();\n  var marginX = graphLabel.marginx || 0;\n  var marginY = graphLabel.marginy || 0;\n\n  function getExtremes(attrs) {\n    var x = attrs.x;\n    var y = attrs.y;\n    var w = attrs.width;\n    var h = attrs.height;\n    minX = Math.min(minX, x - w / 2);\n    maxX = Math.max(maxX, x + w / 2);\n    minY = Math.min(minY, y - h / 2);\n    maxY = Math.max(maxY, y + h / 2);\n  }\n\n  _.forEach(g.nodes(), function (v) {\n    getExtremes(g.node(v));\n  });\n\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n\n    if (_.has(edge, \"x\")) {\n      getExtremes(edge);\n    }\n  });\n\n  minX -= marginX;\n  minY -= marginY;\n\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n    node.x -= minX;\n    node.y -= minY;\n  });\n\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n\n    _.forEach(edge.points, function (p) {\n      p.x -= minX;\n      p.y -= minY;\n    });\n\n    if (_.has(edge, \"x\")) {\n      edge.x -= minX;\n    }\n\n    if (_.has(edge, \"y\")) {\n      edge.y -= minY;\n    }\n  });\n\n  graphLabel.width = maxX - minX + marginX;\n  graphLabel.height = maxY - minY + marginY;\n}\n\nfunction assignNodeIntersects(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n    var nodeV = g.node(e.v);\n    var nodeW = g.node(e.w);\n    var p1, p2;\n\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n\n    edge.points.unshift(util.intersectRect(nodeV, p1));\n    edge.points.push(util.intersectRect(nodeW, p2));\n  });\n}\n\nfunction fixupEdgeLabelCoords(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n\n    if (_.has(edge, \"x\")) {\n      if (edge.labelpos === \"l\" || edge.labelpos === \"r\") {\n        edge.width -= edge.labeloffset;\n      }\n\n      switch (edge.labelpos) {\n        case \"l\":\n          edge.x -= edge.width / 2 + edge.labeloffset;\n          break;\n\n        case \"r\":\n          edge.x += edge.width / 2 + edge.labeloffset;\n          break;\n      }\n    }\n  });\n}\n\nfunction reversePointsForReversedEdges(g) {\n  _.forEach(g.edges(), function (e) {\n    var edge = g.edge(e);\n\n    if (edge.reversed) {\n      edge.points.reverse();\n    }\n  });\n}\n\nfunction removeBorderNodes(g) {\n  _.forEach(g.nodes(), function (v) {\n    if (g.children(v).length) {\n      var node = g.node(v);\n      var t = g.node(node.borderTop);\n      var b = g.node(node.borderBottom);\n      var l = g.node(_.last(node.borderLeft));\n      var r = g.node(_.last(node.borderRight));\n      node.width = Math.abs(r.x - l.x);\n      node.height = Math.abs(b.y - t.y);\n      node.x = l.x + node.width / 2;\n      node.y = t.y + node.height / 2;\n    }\n  });\n\n  _.forEach(g.nodes(), function (v) {\n    if (g.node(v).dummy === \"border\") {\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction removeSelfEdges(g) {\n  _.forEach(g.edges(), function (e) {\n    if (e.v === e.w) {\n      var node = g.node(e.v);\n\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n\n      node.selfEdges.push({\n        e: e,\n        label: g.edge(e)\n      });\n      g.removeEdge(e);\n    }\n  });\n}\n\nfunction insertSelfEdges(g) {\n  var layers = util.buildLayerMatrix(g);\n\n  _.forEach(layers, function (layer) {\n    var orderShift = 0;\n\n    _.forEach(layer, function (v, i) {\n      var node = g.node(v);\n      node.order = i + orderShift;\n\n      _.forEach(node.selfEdges, function (selfEdge) {\n        util.addDummyNode(g, \"selfedge\", {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + ++orderShift,\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, \"_se\");\n      });\n\n      delete node.selfEdges;\n    });\n  });\n}\n\nfunction positionSelfEdges(g) {\n  _.forEach(g.nodes(), function (v) {\n    var node = g.node(v);\n\n    if (node.dummy === \"selfedge\") {\n      var selfNode = g.node(node.e.v);\n      var x = selfNode.x + selfNode.width / 2;\n      var y = selfNode.y;\n      var dx = node.x - x;\n      var dy = selfNode.height / 2;\n      g.setEdge(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [{\n        x: x + 2 * dx / 3,\n        y: y - dy\n      }, {\n        x: x + 5 * dx / 6,\n        y: y - dy\n      }, {\n        x: x + dx,\n        y: y\n      }, {\n        x: x + 5 * dx / 6,\n        y: y + dy\n      }, {\n        x: x + 2 * dx / 3,\n        y: y + dy\n      }];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n}\n\nfunction selectNumberAttrs(obj, attrs) {\n  return _.mapValues(_.pick(obj, attrs), Number);\n}\n\nfunction canonicalize(attrs) {\n  var newAttrs = {};\n\n  _.forEach(attrs, function (v, k) {\n    newAttrs[k.toLowerCase()] = v;\n  });\n\n  return newAttrs;\n}","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/dagrejs/lib/layout.js"],"names":["_","require","acyclic","normalize","rank","normalizeRanks","parentDummyChains","removeEmptyRanks","nestingGraph","addBorderSegments","coordinateSystem","order","position","util","Graph","initDataOrder","module","exports","layout","g","opts","time","debugTiming","notime","keepNodeOrder","prevGraph","inheritOrder","layoutGraph","buildLayoutGraph","edgeLabelSpace","makeSpaceForEdgeLabels","runLayout","e","message","console","error","updateInputGraph","removeSelfEdges","run","asNonCompoundGraph","injectEdgeLabelProxies","cleanup","assignRankMinMax","removeEdgeLabelProxies","nodeOrder","insertSelfEdges","adjust","positionSelfEdges","removeBorderNodes","undo","fixupEdgeLabelCoords","translateGraph","assignNodeIntersects","reversePointsForReversedEdges","currG","prevG","prevNodeMap","_nodes","forEach","nodes","n","node","undefined","fixorder","_order","inputGraph","v","inputLabel","layoutLabel","x","y","_rank","children","length","width","height","edges","edge","points","has","graph","graphNumAttrs","graphDefaults","ranksep","edgesep","nodesep","rankdir","graphAttrs","nodeNumAttrs","nodeDefaults","edgeNumAttrs","edgeDefaults","minlen","weight","labeloffset","labelpos","edgeAttrs","multigraph","compound","canonicalize","setGraph","merge","selectNumberAttrs","pick","setNode","defaults","setParent","parent","setEdge","isNaN","layer","toLowerCase","w","label","addDummyNode","maxRank","borderTop","minRank","borderBottom","max","dummy","labelRank","removeNode","minX","Number","POSITIVE_INFINITY","maxX","minY","maxY","graphLabel","marginX","marginx","marginY","marginy","getExtremes","attrs","h","Math","min","p","nodeV","nodeW","p1","p2","unshift","intersectRect","push","reversed","reverse","t","b","l","last","borderLeft","r","borderRight","abs","selfEdges","removeEdge","layers","buildLayerMatrix","orderShift","i","selfEdge","selfNode","dx","dy","obj","mapValues","newAttrs","k"],"mappings":"AAAA;;AAEA,IAAIA,CAAC,GAAGC,OAAO,CAAC,UAAD,CAAf;;AACA,IAAIC,OAAO,GAAGD,OAAO,CAAC,WAAD,CAArB;;AACA,IAAIE,SAAS,GAAGF,OAAO,CAAC,aAAD,CAAvB;;AACA,IAAIG,IAAI,GAAGH,OAAO,CAAC,QAAD,CAAlB;;AACA,IAAII,cAAc,GAAGJ,OAAO,CAAC,QAAD,CAAP,CAAkBI,cAAvC;;AACA,IAAIC,iBAAiB,GAAGL,OAAO,CAAC,uBAAD,CAA/B;;AACA,IAAIM,gBAAgB,GAAGN,OAAO,CAAC,QAAD,CAAP,CAAkBM,gBAAzC;;AACA,IAAIC,YAAY,GAAGP,OAAO,CAAC,iBAAD,CAA1B;;AACA,IAAIQ,iBAAiB,GAAGR,OAAO,CAAC,uBAAD,CAA/B;;AACA,IAAIS,gBAAgB,GAAGT,OAAO,CAAC,qBAAD,CAA9B;;AACA,IAAIU,KAAK,GAAGV,OAAO,CAAC,SAAD,CAAnB;;AACA,IAAIW,QAAQ,GAAGX,OAAO,CAAC,YAAD,CAAtB;;AACA,IAAIY,IAAI,GAAGZ,OAAO,CAAC,QAAD,CAAlB;;AACA,IAAIa,KAAK,GAAGb,OAAO,CAAC,YAAD,CAAP,CAAsBa,KAAlC;;AACA,IAAIC,aAAa,GAAGd,OAAO,CAAC,yBAAD,CAA3B;;AAEAe,MAAM,CAACC,OAAP,GAAiBC,MAAjB;;AAEA,SAASA,MAAT,CAAgBC,CAAhB,EAAmBC,IAAnB,EAAyB;AACvB,MAAIC,IAAI,GAAGD,IAAI,IAAIA,IAAI,CAACE,WAAb,GAA2BT,IAAI,CAACQ,IAAhC,GAAuCR,IAAI,CAACU,MAAvD;AACAF,EAAAA,IAAI,CAAC,QAAD,EAAW,YAAW;AACxB;AACA,QAAID,IAAI,IAAI,CAACA,IAAI,CAACI,aAAd,IAA+BJ,IAAI,CAACK,SAAxC,EAAmD;AACjDJ,MAAAA,IAAI,CAAC,gBAAD,EAAmB,YAAW;AAAEK,QAAAA,YAAY,CAACP,CAAD,EAAIC,IAAI,CAACK,SAAT,CAAZ;AAAkC,OAAlE,CAAJ;AACD;;AACD,QAAIE,WAAW,GACbN,IAAI,CAAC,oBAAD,EAAuB,YAAW;AAAE,aAAOO,gBAAgB,CAACT,CAAD,CAAvB;AAA6B,KAAjE,CADN,CALwB,CAOxB;;AACA,QAAI,EAAEC,IAAI,IAAKA,IAAI,CAACS,cAAL,KAAwB,KAAnC,CAAJ,EAAgD;AAC9CR,MAAAA,IAAI,CAAC,0BAAD,EAA6B,YAAW;AAAES,QAAAA,sBAAsB,CAACH,WAAD,CAAtB;AAAsC,OAAhF,CAAJ;AACD,KAVuB,CAWxB;;;AACA,QAAI;AACFN,MAAAA,IAAI,CAAC,aAAD,EAAuB,YAAW;AAAEU,QAAAA,SAAS,CAACJ,WAAD,EAAcN,IAAd,EAAoBD,IAApB,CAAT;AAAqC,OAAzE,CAAJ;AACD,KAFD,CAEE,OAAMY,CAAN,EAAS;AACT,UAAIA,CAAC,CAACC,OAAF,KAAc,2DAAlB,EAA+E;AAC7EC,QAAAA,OAAO,CAACC,KAAR,CAAc,oJAAd,EAAoKH,CAApK;AACA;AACD,OAHD,MAGO;AACL,cAAMA,CAAN;AACD;AACF;;AACDX,IAAAA,IAAI,CAAC,oBAAD,EAAuB,YAAW;AAAEe,MAAAA,gBAAgB,CAACjB,CAAD,EAAIQ,WAAJ,CAAhB;AAAmC,KAAvE,CAAJ;AACD,GAvBG,CAAJ;AAwBD;;AAED,SAASI,SAAT,CAAmBZ,CAAnB,EAAsBE,IAAtB,EAA4BD,IAA5B,EAAkC;AAChCC,EAAAA,IAAI,CAAC,qBAAD,EAA+B,YAAW;AAAEgB,IAAAA,eAAe,CAAClB,CAAD,CAAf;AAAqB,GAAjE,CAAJ;AACAE,EAAAA,IAAI,CAAC,aAAD,EAA+B,YAAW;AAAEnB,IAAAA,OAAO,CAACoC,GAAR,CAAYnB,CAAZ;AAAiB,GAA7D,CAAJ;AACAE,EAAAA,IAAI,CAAC,sBAAD,EAA+B,YAAW;AAAEb,IAAAA,YAAY,CAAC8B,GAAb,CAAiBnB,CAAjB;AAAsB,GAAlE,CAAJ;AACAE,EAAAA,IAAI,CAAC,UAAD,EAA+B,YAAW;AAAEjB,IAAAA,IAAI,CAACS,IAAI,CAAC0B,kBAAL,CAAwBpB,CAAxB,CAAD,CAAJ;AAAmC,GAA/E,CAAJ;AACAE,EAAAA,IAAI,CAAC,4BAAD,EAA+B,YAAW;AAAEmB,IAAAA,sBAAsB,CAACrB,CAAD,CAAtB;AAA4B,GAAxE,CAAJ;AACAE,EAAAA,IAAI,CAAC,sBAAD,EAA+B,YAAW;AAAEd,IAAAA,gBAAgB,CAACY,CAAD,CAAhB;AAAsB,GAAlE,CAAJ;AACAE,EAAAA,IAAI,CAAC,0BAAD,EAA+B,YAAW;AAAEb,IAAAA,YAAY,CAACiC,OAAb,CAAqBtB,CAArB;AAA0B,GAAtE,CAAJ;AACAE,EAAAA,IAAI,CAAC,oBAAD,EAA+B,YAAW;AAAEhB,IAAAA,cAAc,CAACc,CAAD,CAAd;AAAoB,GAAhE,CAAJ;AACAE,EAAAA,IAAI,CAAC,sBAAD,EAA+B,YAAW;AAAEqB,IAAAA,gBAAgB,CAACvB,CAAD,CAAhB;AAAsB,GAAlE,CAAJ;AACAE,EAAAA,IAAI,CAAC,4BAAD,EAA+B,YAAW;AAAEsB,IAAAA,sBAAsB,CAACxB,CAAD,CAAtB;AAA4B,GAAxE,CAAJ;AACAE,EAAAA,IAAI,CAAC,mBAAD,EAA+B,YAAW;AAAElB,IAAAA,SAAS,CAACmC,GAAV,CAAcnB,CAAd;AAAmB,GAA/D,CAAJ;AACAE,EAAAA,IAAI,CAAC,uBAAD,EAA+B,YAAW;AAAEf,IAAAA,iBAAiB,CAACa,CAAD,CAAjB;AAAuB,GAAnE,CAAJ;AACAE,EAAAA,IAAI,CAAC,uBAAD,EAA+B,YAAW;AAAEZ,IAAAA,iBAAiB,CAACU,CAAD,CAAjB;AAAuB,GAAnE,CAAJ;;AACA,MAAIC,IAAI,IAAIA,IAAI,CAACI,aAAjB,EAAgC;AAC9BH,IAAAA,IAAI,CAAC,mBAAD,EAAsB,YAAW;AAAEN,MAAAA,aAAa,CAACI,CAAD,EAAIC,IAAI,CAACwB,SAAT,CAAb;AAAmC,KAAtE,CAAJ;AACD;;AACDvB,EAAAA,IAAI,CAAC,WAAD,EAA+B,YAAW;AAAEV,IAAAA,KAAK,CAACQ,CAAD,CAAL;AAAW,GAAvD,CAAJ;AACAE,EAAAA,IAAI,CAAC,qBAAD,EAA+B,YAAW;AAAEwB,IAAAA,eAAe,CAAC1B,CAAD,CAAf;AAAqB,GAAjE,CAAJ;AACAE,EAAAA,IAAI,CAAC,4BAAD,EAA+B,YAAW;AAAEX,IAAAA,gBAAgB,CAACoC,MAAjB,CAAwB3B,CAAxB;AAA6B,GAAzE,CAAJ;AACAE,EAAAA,IAAI,CAAC,cAAD,EAA+B,YAAW;AAAET,IAAAA,QAAQ,CAACO,CAAD,CAAR;AAAc,GAA1D,CAAJ;AACAE,EAAAA,IAAI,CAAC,uBAAD,EAA+B,YAAW;AAAE0B,IAAAA,iBAAiB,CAAC5B,CAAD,CAAjB;AAAuB,GAAnE,CAAJ;AACAE,EAAAA,IAAI,CAAC,uBAAD,EAA+B,YAAW;AAAE2B,IAAAA,iBAAiB,CAAC7B,CAAD,CAAjB;AAAuB,GAAnE,CAAJ;AACAE,EAAAA,IAAI,CAAC,oBAAD,EAA+B,YAAW;AAAElB,IAAAA,SAAS,CAAC8C,IAAV,CAAe9B,CAAf;AAAoB,GAAhE,CAAJ;AACAE,EAAAA,IAAI,CAAC,0BAAD,EAA+B,YAAW;AAAE6B,IAAAA,oBAAoB,CAAC/B,CAAD,CAApB;AAA0B,GAAtE,CAAJ;AACAE,EAAAA,IAAI,CAAC,0BAAD,EAA+B,YAAW;AAAEX,IAAAA,gBAAgB,CAACuC,IAAjB,CAAsB9B,CAAtB;AAA2B,GAAvE,CAAJ;AACAE,EAAAA,IAAI,CAAC,oBAAD,EAA+B,YAAW;AAAE8B,IAAAA,cAAc,CAAChC,CAAD,CAAd;AAAoB,GAAhE,CAAJ;AACAE,EAAAA,IAAI,CAAC,0BAAD,EAA+B,YAAW;AAAE+B,IAAAA,oBAAoB,CAACjC,CAAD,CAApB;AAA0B,GAAtE,CAAJ;AACAE,EAAAA,IAAI,CAAC,mBAAD,EAA+B,YAAW;AAAEgC,IAAAA,6BAA6B,CAAClC,CAAD,CAA7B;AAAmC,GAA/E,CAAJ;AACAE,EAAAA,IAAI,CAAC,kBAAD,EAA+B,YAAW;AAAEnB,IAAAA,OAAO,CAAC+C,IAAR,CAAa9B,CAAb;AAAkB,GAA9D,CAAJ;AACD;AAED;AACA;AACA;AACA;;;AACA,SAASO,YAAT,CAAsB4B,KAAtB,EAA6BC,KAA7B,EAAoC;AAClC,MAAIC,WAAW,GAAGD,KAAK,CAACE,MAAxB;;AACAzD,EAAAA,CAAC,CAAC0D,OAAF,CAAUJ,KAAK,CAACK,KAAN,EAAV,EAAyB,UAAUC,CAAV,EAAa;AACpC,QAAIC,IAAI,GAAGP,KAAK,CAACO,IAAN,CAAWD,CAAX,CAAX;;AACA,QAAIJ,WAAW,CAACI,CAAD,CAAX,KAAmBE,SAAvB,EAAkC;AAChCD,MAAAA,IAAI,CAACE,QAAL,GAAgBP,WAAW,CAACI,CAAD,CAAX,CAAeI,MAA/B;AACA,aAAOR,WAAW,CAACI,CAAD,CAAX,CAAeI,MAAtB;AACD,KAHD,MAGO;AACL,aAAOH,IAAI,CAACE,QAAZ;AACD;AACF,GARD;AASD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAS3B,gBAAT,CAA0B6B,UAA1B,EAAsCtC,WAAtC,EAAmD;AACjD3B,EAAAA,CAAC,CAAC0D,OAAF,CAAUO,UAAU,CAACN,KAAX,EAAV,EAA8B,UAASO,CAAT,EAAY;AACxC,QAAIC,UAAU,GAAGF,UAAU,CAACJ,IAAX,CAAgBK,CAAhB,CAAjB;AACA,QAAIE,WAAW,GAAGzC,WAAW,CAACkC,IAAZ,CAAiBK,CAAjB,CAAlB;;AAEA,QAAIC,UAAJ,EAAgB;AACdA,MAAAA,UAAU,CAACE,CAAX,GAAeD,WAAW,CAACC,CAA3B;AACAF,MAAAA,UAAU,CAACG,CAAX,GAAeF,WAAW,CAACE,CAA3B;AACAH,MAAAA,UAAU,CAACH,MAAX,GAAoBI,WAAW,CAACzD,KAAhC;AACAwD,MAAAA,UAAU,CAACI,KAAX,GAAmBH,WAAW,CAAChE,IAA/B;;AAEA,UAAIuB,WAAW,CAAC6C,QAAZ,CAAqBN,CAArB,EAAwBO,MAA5B,EAAoC;AAClCN,QAAAA,UAAU,CAACO,KAAX,GAAmBN,WAAW,CAACM,KAA/B;AACAP,QAAAA,UAAU,CAACQ,MAAX,GAAoBP,WAAW,CAACO,MAAhC;AACD;AACF;AACF,GAfD;;AAiBA3E,EAAAA,CAAC,CAAC0D,OAAF,CAAUO,UAAU,CAACW,KAAX,EAAV,EAA8B,UAAS5C,CAAT,EAAY;AACxC,QAAImC,UAAU,GAAGF,UAAU,CAACY,IAAX,CAAgB7C,CAAhB,CAAjB;AACA,QAAIoC,WAAW,GAAGzC,WAAW,CAACkD,IAAZ,CAAiB7C,CAAjB,CAAlB;AAEAmC,IAAAA,UAAU,CAACW,MAAX,GAAoBV,WAAW,CAACU,MAAhC;;AACA,QAAI9E,CAAC,CAAC+E,GAAF,CAAMX,WAAN,EAAmB,GAAnB,CAAJ,EAA6B;AAC3BD,MAAAA,UAAU,CAACE,CAAX,GAAeD,WAAW,CAACC,CAA3B;AACAF,MAAAA,UAAU,CAACG,CAAX,GAAeF,WAAW,CAACE,CAA3B;AACD;AACF,GATD;;AAWAL,EAAAA,UAAU,CAACe,KAAX,GAAmBN,KAAnB,GAA2B/C,WAAW,CAACqD,KAAZ,GAAoBN,KAA/C;AACAT,EAAAA,UAAU,CAACe,KAAX,GAAmBL,MAAnB,GAA4BhD,WAAW,CAACqD,KAAZ,GAAoBL,MAAhD;AACD;;AAED,IAAIM,aAAa,GAAG,CAAC,SAAD,EAAY,SAAZ,EAAuB,SAAvB,EAAkC,SAAlC,EAA6C,SAA7C,CAApB;AACA,IAAIC,aAAa,GAAG;AAAEC,EAAAA,OAAO,EAAE,EAAX;AAAeC,EAAAA,OAAO,EAAE,EAAxB;AAA4BC,EAAAA,OAAO,EAAE,EAArC;AAAyCC,EAAAA,OAAO,EAAE;AAAlD,CAApB;AACA,IAAIC,UAAU,GAAG,CAAC,WAAD,EAAc,QAAd,EAAwB,SAAxB,EAAmC,OAAnC,CAAjB;AACA,IAAIC,YAAY,GAAG,CAAC,OAAD,EAAU,QAAV,EAAoB,OAApB,EAA6B,UAA7B,CAAnB,C,CAA6D;;AAC7D,IAAIC,YAAY,GAAG;AAAEf,EAAAA,KAAK,EAAE,CAAT;AAAYC,EAAAA,MAAM,EAAE;AAApB,CAAnB;AACA,IAAIe,YAAY,GAAG,CAAC,QAAD,EAAW,QAAX,EAAqB,OAArB,EAA8B,QAA9B,EAAwC,aAAxC,CAAnB;AACA,IAAIC,YAAY,GAAG;AACjBC,EAAAA,MAAM,EAAE,CADS;AACNC,EAAAA,MAAM,EAAE,CADF;AACKnB,EAAAA,KAAK,EAAE,CADZ;AACeC,EAAAA,MAAM,EAAE,CADvB;AAEjBmB,EAAAA,WAAW,EAAE,EAFI;AAEAC,EAAAA,QAAQ,EAAE;AAFV,CAAnB;AAIA,IAAIC,SAAS,GAAG,CAAC,UAAD,CAAhB;AAEA;AACA;AACA;AACA;AACA;AACA;;AACA,SAASpE,gBAAT,CAA0BqC,UAA1B,EAAsC;AACpC,MAAI9C,CAAC,GAAG,IAAIL,KAAJ,CAAU;AAAEmF,IAAAA,UAAU,EAAE,IAAd;AAAoBC,IAAAA,QAAQ,EAAE;AAA9B,GAAV,CAAR;AACA,MAAIlB,KAAK,GAAGmB,YAAY,CAAClC,UAAU,CAACe,KAAX,EAAD,CAAxB;AAEA7D,EAAAA,CAAC,CAACiF,QAAF,CAAWpG,CAAC,CAACqG,KAAF,CAAQ,EAAR,EACTnB,aADS,EAEToB,iBAAiB,CAACtB,KAAD,EAAQC,aAAR,CAFR,EAGTjF,CAAC,CAACuG,IAAF,CAAOvB,KAAP,EAAcO,UAAd,CAHS,CAAX;;AAKAvF,EAAAA,CAAC,CAAC0D,OAAF,CAAUO,UAAU,CAACN,KAAX,EAAV,EAA8B,UAASO,CAAT,EAAY;AACxC,QAAIL,IAAI,GAAGsC,YAAY,CAAClC,UAAU,CAACJ,IAAX,CAAgBK,CAAhB,CAAD,CAAvB;AACA/C,IAAAA,CAAC,CAACqF,OAAF,CAAUtC,CAAV,EAAalE,CAAC,CAACyG,QAAF,CAAWH,iBAAiB,CAACzC,IAAD,EAAO2B,YAAP,CAA5B,EAAkDC,YAAlD,CAAb;AACAtE,IAAAA,CAAC,CAACuF,SAAF,CAAYxC,CAAZ,EAAeD,UAAU,CAAC0C,MAAX,CAAkBzC,CAAlB,CAAf;AACD,GAJD;;AAMAlE,EAAAA,CAAC,CAAC0D,OAAF,CAAUO,UAAU,CAACW,KAAX,EAAV,EAA8B,UAAS5C,CAAT,EAAY;AACxC,QAAI6C,IAAI,GAAGsB,YAAY,CAAClC,UAAU,CAACY,IAAX,CAAgB7C,CAAhB,CAAD,CAAvB;AACAb,IAAAA,CAAC,CAACyF,OAAF,CAAU5E,CAAV,EAAahC,CAAC,CAACqG,KAAF,CAAQ,EAAR,EACXV,YADW,EAEXW,iBAAiB,CAACzB,IAAD,EAAOa,YAAP,CAFN,EAGX1F,CAAC,CAACuG,IAAF,CAAO1B,IAAP,EAAamB,SAAb,CAHW,CAAb;AAID,GAND;;AAQA,SAAO7E,CAAP;AACD;AAED;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACA,SAASW,sBAAT,CAAgCX,CAAhC,EAAmC;AACjC,MAAI6D,KAAK,GAAG7D,CAAC,CAAC6D,KAAF,EAAZ;AACAA,EAAAA,KAAK,CAACG,OAAN,IAAiB,CAAjB;;AACAnF,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACwC,KAAF,EAAV,EAAqB,UAASC,CAAT,EAAY;AAC/B,QAAIC,IAAI,GAAG1C,CAAC,CAAC0C,IAAF,CAAOD,CAAP,CAAX;;AACA,QAAI,CAACiD,KAAK,CAAChD,IAAI,CAACiD,KAAN,CAAV,EAAwB;AACtBjD,MAAAA,IAAI,CAACiD,KAAL,IAAc,CAAd,CADsB,CACL;AAClB;AACF,GALD;;AAMA9G,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACyD,KAAF,EAAV,EAAqB,UAAS5C,CAAT,EAAY;AAC/B,QAAI6C,IAAI,GAAG1D,CAAC,CAAC0D,IAAF,CAAO7C,CAAP,CAAX;AACA6C,IAAAA,IAAI,CAACe,MAAL,IAAe,CAAf;;AACA,QAAIf,IAAI,CAACkB,QAAL,CAAcgB,WAAd,OAAgC,GAApC,EAAyC;AACvC,UAAI/B,KAAK,CAACM,OAAN,KAAkB,IAAlB,IAA0BN,KAAK,CAACM,OAAN,KAAkB,IAAhD,EAAsD;AACpDT,QAAAA,IAAI,CAACH,KAAL,IAAcG,IAAI,CAACiB,WAAnB;AACD,OAFD,MAEO;AACLjB,QAAAA,IAAI,CAACF,MAAL,IAAeE,IAAI,CAACiB,WAApB;AACD;AACF;AACF,GAVD;AAWD;AAED;AACA;AACA;AACA;AACA;AACA;;;AACA,SAAStD,sBAAT,CAAgCrB,CAAhC,EAAmC;AACjCnB,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACyD,KAAF,EAAV,EAAqB,UAAS5C,CAAT,EAAY;AAC/B,QAAI6C,IAAI,GAAG1D,CAAC,CAAC0D,IAAF,CAAO7C,CAAP,CAAX;;AACA,QAAI6C,IAAI,CAACH,KAAL,IAAcG,IAAI,CAACF,MAAvB,EAA+B;AAC7B,UAAIT,CAAC,GAAG/C,CAAC,CAAC0C,IAAF,CAAO7B,CAAC,CAACkC,CAAT,CAAR;AACA,UAAI8C,CAAC,GAAG7F,CAAC,CAAC0C,IAAF,CAAO7B,CAAC,CAACgF,CAAT,CAAR;AACA,UAAIC,KAAK,GAAG;AAAE7G,QAAAA,IAAI,EAAE,CAAC4G,CAAC,CAAC5G,IAAF,GAAS8D,CAAC,CAAC9D,IAAZ,IAAoB,CAApB,GAAwB8D,CAAC,CAAC9D,IAAlC;AAAwC4B,QAAAA,CAAC,EAAEA;AAA3C,OAAZ;AACAnB,MAAAA,IAAI,CAACqG,YAAL,CAAkB/F,CAAlB,EAAqB,YAArB,EAAmC8F,KAAnC,EAA0C,KAA1C;AACD;AACF,GARD;AASD;;AAED,SAASvE,gBAAT,CAA0BvB,CAA1B,EAA6B;AAC3B,MAAIgG,OAAO,GAAG,CAAd;;AACAnH,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACwC,KAAF,EAAV,EAAqB,UAASO,CAAT,EAAY;AAC/B,QAAIL,IAAI,GAAG1C,CAAC,CAAC0C,IAAF,CAAOK,CAAP,CAAX;;AACA,QAAIL,IAAI,CAACuD,SAAT,EAAoB;AAClBvD,MAAAA,IAAI,CAACwD,OAAL,GAAelG,CAAC,CAAC0C,IAAF,CAAOA,IAAI,CAACuD,SAAZ,EAAuBhH,IAAtC;AACAyD,MAAAA,IAAI,CAACsD,OAAL,GAAehG,CAAC,CAAC0C,IAAF,CAAOA,IAAI,CAACyD,YAAZ,EAA0BlH,IAAzC;AACA+G,MAAAA,OAAO,GAAGnH,CAAC,CAACuH,GAAF,CAAMJ,OAAN,EAAetD,IAAI,CAACsD,OAApB,CAAV;AACD;AACF,GAPD;;AAQAhG,EAAAA,CAAC,CAAC6D,KAAF,GAAUmC,OAAV,GAAoBA,OAApB;AACD;;AAED,SAASxE,sBAAT,CAAgCxB,CAAhC,EAAmC;AACjCnB,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACwC,KAAF,EAAV,EAAqB,UAASO,CAAT,EAAY;AAC/B,QAAIL,IAAI,GAAG1C,CAAC,CAAC0C,IAAF,CAAOK,CAAP,CAAX;;AACA,QAAIL,IAAI,CAAC2D,KAAL,KAAe,YAAnB,EAAiC;AAC/BrG,MAAAA,CAAC,CAAC0D,IAAF,CAAOhB,IAAI,CAAC7B,CAAZ,EAAeyF,SAAf,GAA2B5D,IAAI,CAACzD,IAAhC;AACAe,MAAAA,CAAC,CAACuG,UAAF,CAAaxD,CAAb;AACD;AACF,GAND;AAOD;;AAED,SAASf,cAAT,CAAwBhC,CAAxB,EAA2B;AACzB,MAAIwG,IAAI,GAAGC,MAAM,CAACC,iBAAlB;AACA,MAAIC,IAAI,GAAG,CAAX;AACA,MAAIC,IAAI,GAAGH,MAAM,CAACC,iBAAlB;AACA,MAAIG,IAAI,GAAG,CAAX;AACA,MAAIC,UAAU,GAAG9G,CAAC,CAAC6D,KAAF,EAAjB;AACA,MAAIkD,OAAO,GAAGD,UAAU,CAACE,OAAX,IAAsB,CAApC;AACA,MAAIC,OAAO,GAAGH,UAAU,CAACI,OAAX,IAAsB,CAApC;;AAEA,WAASC,WAAT,CAAqBC,KAArB,EAA4B;AAC1B,QAAIlE,CAAC,GAAGkE,KAAK,CAAClE,CAAd;AACA,QAAIC,CAAC,GAAGiE,KAAK,CAACjE,CAAd;AACA,QAAI0C,CAAC,GAAGuB,KAAK,CAAC7D,KAAd;AACA,QAAI8D,CAAC,GAAGD,KAAK,CAAC5D,MAAd;AACAgD,IAAAA,IAAI,GAAGc,IAAI,CAACC,GAAL,CAASf,IAAT,EAAetD,CAAC,GAAG2C,CAAC,GAAG,CAAvB,CAAP;AACAc,IAAAA,IAAI,GAAGW,IAAI,CAAClB,GAAL,CAASO,IAAT,EAAezD,CAAC,GAAG2C,CAAC,GAAG,CAAvB,CAAP;AACAe,IAAAA,IAAI,GAAGU,IAAI,CAACC,GAAL,CAASX,IAAT,EAAezD,CAAC,GAAGkE,CAAC,GAAG,CAAvB,CAAP;AACAR,IAAAA,IAAI,GAAGS,IAAI,CAAClB,GAAL,CAASS,IAAT,EAAe1D,CAAC,GAAGkE,CAAC,GAAG,CAAvB,CAAP;AACD;;AAEDxI,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACwC,KAAF,EAAV,EAAqB,UAASO,CAAT,EAAY;AAAEoE,IAAAA,WAAW,CAACnH,CAAC,CAAC0C,IAAF,CAAOK,CAAP,CAAD,CAAX;AAAyB,GAA5D;;AACAlE,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACyD,KAAF,EAAV,EAAqB,UAAS5C,CAAT,EAAY;AAC/B,QAAI6C,IAAI,GAAG1D,CAAC,CAAC0D,IAAF,CAAO7C,CAAP,CAAX;;AACA,QAAIhC,CAAC,CAAC+E,GAAF,CAAMF,IAAN,EAAY,GAAZ,CAAJ,EAAsB;AACpByD,MAAAA,WAAW,CAACzD,IAAD,CAAX;AACD;AACF,GALD;;AAOA8C,EAAAA,IAAI,IAAIO,OAAR;AACAH,EAAAA,IAAI,IAAIK,OAAR;;AAEApI,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACwC,KAAF,EAAV,EAAqB,UAASO,CAAT,EAAY;AAC/B,QAAIL,IAAI,GAAG1C,CAAC,CAAC0C,IAAF,CAAOK,CAAP,CAAX;AACAL,IAAAA,IAAI,CAACQ,CAAL,IAAUsD,IAAV;AACA9D,IAAAA,IAAI,CAACS,CAAL,IAAUyD,IAAV;AACD,GAJD;;AAMA/H,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACyD,KAAF,EAAV,EAAqB,UAAS5C,CAAT,EAAY;AAC/B,QAAI6C,IAAI,GAAG1D,CAAC,CAAC0D,IAAF,CAAO7C,CAAP,CAAX;;AACAhC,IAAAA,CAAC,CAAC0D,OAAF,CAAUmB,IAAI,CAACC,MAAf,EAAuB,UAAS6D,CAAT,EAAY;AACjCA,MAAAA,CAAC,CAACtE,CAAF,IAAOsD,IAAP;AACAgB,MAAAA,CAAC,CAACrE,CAAF,IAAOyD,IAAP;AACD,KAHD;;AAIA,QAAI/H,CAAC,CAAC+E,GAAF,CAAMF,IAAN,EAAY,GAAZ,CAAJ,EAAsB;AAAEA,MAAAA,IAAI,CAACR,CAAL,IAAUsD,IAAV;AAAiB;;AACzC,QAAI3H,CAAC,CAAC+E,GAAF,CAAMF,IAAN,EAAY,GAAZ,CAAJ,EAAsB;AAAEA,MAAAA,IAAI,CAACP,CAAL,IAAUyD,IAAV;AAAiB;AAC1C,GARD;;AAUAE,EAAAA,UAAU,CAACvD,KAAX,GAAmBoD,IAAI,GAAGH,IAAP,GAAcO,OAAjC;AACAD,EAAAA,UAAU,CAACtD,MAAX,GAAoBqD,IAAI,GAAGD,IAAP,GAAcK,OAAlC;AACD;;AAED,SAAShF,oBAAT,CAA8BjC,CAA9B,EAAiC;AAC/BnB,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACyD,KAAF,EAAV,EAAqB,UAAS5C,CAAT,EAAY;AAC/B,QAAI6C,IAAI,GAAG1D,CAAC,CAAC0D,IAAF,CAAO7C,CAAP,CAAX;AACA,QAAI4G,KAAK,GAAGzH,CAAC,CAAC0C,IAAF,CAAO7B,CAAC,CAACkC,CAAT,CAAZ;AACA,QAAI2E,KAAK,GAAG1H,CAAC,CAAC0C,IAAF,CAAO7B,CAAC,CAACgF,CAAT,CAAZ;AACA,QAAI8B,EAAJ,EAAQC,EAAR;;AACA,QAAI,CAAClE,IAAI,CAACC,MAAV,EAAkB;AAChBD,MAAAA,IAAI,CAACC,MAAL,GAAc,EAAd;AACAgE,MAAAA,EAAE,GAAGD,KAAL;AACAE,MAAAA,EAAE,GAAGH,KAAL;AACD,KAJD,MAIO;AACLE,MAAAA,EAAE,GAAGjE,IAAI,CAACC,MAAL,CAAY,CAAZ,CAAL;AACAiE,MAAAA,EAAE,GAAGlE,IAAI,CAACC,MAAL,CAAYD,IAAI,CAACC,MAAL,CAAYL,MAAZ,GAAqB,CAAjC,CAAL;AACD;;AACDI,IAAAA,IAAI,CAACC,MAAL,CAAYkE,OAAZ,CAAoBnI,IAAI,CAACoI,aAAL,CAAmBL,KAAnB,EAA0BE,EAA1B,CAApB;AACAjE,IAAAA,IAAI,CAACC,MAAL,CAAYoE,IAAZ,CAAiBrI,IAAI,CAACoI,aAAL,CAAmBJ,KAAnB,EAA0BE,EAA1B,CAAjB;AACD,GAfD;AAgBD;;AAED,SAAS7F,oBAAT,CAA8B/B,CAA9B,EAAiC;AAC/BnB,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACyD,KAAF,EAAV,EAAqB,UAAS5C,CAAT,EAAY;AAC/B,QAAI6C,IAAI,GAAG1D,CAAC,CAAC0D,IAAF,CAAO7C,CAAP,CAAX;;AACA,QAAIhC,CAAC,CAAC+E,GAAF,CAAMF,IAAN,EAAY,GAAZ,CAAJ,EAAsB;AACpB,UAAIA,IAAI,CAACkB,QAAL,KAAkB,GAAlB,IAAyBlB,IAAI,CAACkB,QAAL,KAAkB,GAA/C,EAAoD;AAClDlB,QAAAA,IAAI,CAACH,KAAL,IAAcG,IAAI,CAACiB,WAAnB;AACD;;AACD,cAAQjB,IAAI,CAACkB,QAAb;AACA,aAAK,GAAL;AAAUlB,UAAAA,IAAI,CAACR,CAAL,IAAUQ,IAAI,CAACH,KAAL,GAAa,CAAb,GAAiBG,IAAI,CAACiB,WAAhC;AAA6C;;AACvD,aAAK,GAAL;AAAUjB,UAAAA,IAAI,CAACR,CAAL,IAAUQ,IAAI,CAACH,KAAL,GAAa,CAAb,GAAiBG,IAAI,CAACiB,WAAhC;AAA6C;AAFvD;AAID;AACF,GAXD;AAYD;;AAED,SAASzC,6BAAT,CAAuClC,CAAvC,EAA0C;AACxCnB,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACyD,KAAF,EAAV,EAAqB,UAAS5C,CAAT,EAAY;AAC/B,QAAI6C,IAAI,GAAG1D,CAAC,CAAC0D,IAAF,CAAO7C,CAAP,CAAX;;AACA,QAAI6C,IAAI,CAACsE,QAAT,EAAmB;AACjBtE,MAAAA,IAAI,CAACC,MAAL,CAAYsE,OAAZ;AACD;AACF,GALD;AAMD;;AAED,SAASpG,iBAAT,CAA2B7B,CAA3B,EAA8B;AAC5BnB,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACwC,KAAF,EAAV,EAAqB,UAASO,CAAT,EAAY;AAC/B,QAAI/C,CAAC,CAACqD,QAAF,CAAWN,CAAX,EAAcO,MAAlB,EAA0B;AACxB,UAAIZ,IAAI,GAAG1C,CAAC,CAAC0C,IAAF,CAAOK,CAAP,CAAX;AACA,UAAImF,CAAC,GAAGlI,CAAC,CAAC0C,IAAF,CAAOA,IAAI,CAACuD,SAAZ,CAAR;AACA,UAAIkC,CAAC,GAAGnI,CAAC,CAAC0C,IAAF,CAAOA,IAAI,CAACyD,YAAZ,CAAR;AACA,UAAIiC,CAAC,GAAGpI,CAAC,CAAC0C,IAAF,CAAO7D,CAAC,CAACwJ,IAAF,CAAO3F,IAAI,CAAC4F,UAAZ,CAAP,CAAR;AACA,UAAIC,CAAC,GAAGvI,CAAC,CAAC0C,IAAF,CAAO7D,CAAC,CAACwJ,IAAF,CAAO3F,IAAI,CAAC8F,WAAZ,CAAP,CAAR;AAEA9F,MAAAA,IAAI,CAACa,KAAL,GAAa+D,IAAI,CAACmB,GAAL,CAASF,CAAC,CAACrF,CAAF,GAAMkF,CAAC,CAAClF,CAAjB,CAAb;AACAR,MAAAA,IAAI,CAACc,MAAL,GAAc8D,IAAI,CAACmB,GAAL,CAASN,CAAC,CAAChF,CAAF,GAAM+E,CAAC,CAAC/E,CAAjB,CAAd;AACAT,MAAAA,IAAI,CAACQ,CAAL,GAASkF,CAAC,CAAClF,CAAF,GAAMR,IAAI,CAACa,KAAL,GAAa,CAA5B;AACAb,MAAAA,IAAI,CAACS,CAAL,GAAS+E,CAAC,CAAC/E,CAAF,GAAMT,IAAI,CAACc,MAAL,GAAc,CAA7B;AACD;AACF,GAbD;;AAeA3E,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACwC,KAAF,EAAV,EAAqB,UAASO,CAAT,EAAY;AAC/B,QAAI/C,CAAC,CAAC0C,IAAF,CAAOK,CAAP,EAAUsD,KAAV,KAAoB,QAAxB,EAAkC;AAChCrG,MAAAA,CAAC,CAACuG,UAAF,CAAaxD,CAAb;AACD;AACF,GAJD;AAKD;;AAED,SAAS7B,eAAT,CAAyBlB,CAAzB,EAA4B;AAC1BnB,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACyD,KAAF,EAAV,EAAqB,UAAS5C,CAAT,EAAY;AAC/B,QAAIA,CAAC,CAACkC,CAAF,KAAQlC,CAAC,CAACgF,CAAd,EAAiB;AACf,UAAInD,IAAI,GAAG1C,CAAC,CAAC0C,IAAF,CAAO7B,CAAC,CAACkC,CAAT,CAAX;;AACA,UAAI,CAACL,IAAI,CAACgG,SAAV,EAAqB;AACnBhG,QAAAA,IAAI,CAACgG,SAAL,GAAiB,EAAjB;AACD;;AACDhG,MAAAA,IAAI,CAACgG,SAAL,CAAeX,IAAf,CAAoB;AAAElH,QAAAA,CAAC,EAAEA,CAAL;AAAQiF,QAAAA,KAAK,EAAE9F,CAAC,CAAC0D,IAAF,CAAO7C,CAAP;AAAf,OAApB;AACAb,MAAAA,CAAC,CAAC2I,UAAF,CAAa9H,CAAb;AACD;AACF,GATD;AAUD;;AAED,SAASa,eAAT,CAAyB1B,CAAzB,EAA4B;AAC1B,MAAI4I,MAAM,GAAGlJ,IAAI,CAACmJ,gBAAL,CAAsB7I,CAAtB,CAAb;;AACAnB,EAAAA,CAAC,CAAC0D,OAAF,CAAUqG,MAAV,EAAkB,UAASjD,KAAT,EAAgB;AAChC,QAAImD,UAAU,GAAG,CAAjB;;AACAjK,IAAAA,CAAC,CAAC0D,OAAF,CAAUoD,KAAV,EAAiB,UAAS5C,CAAT,EAAYgG,CAAZ,EAAe;AAC9B,UAAIrG,IAAI,GAAG1C,CAAC,CAAC0C,IAAF,CAAOK,CAAP,CAAX;AACAL,MAAAA,IAAI,CAAClD,KAAL,GAAauJ,CAAC,GAAGD,UAAjB;;AACAjK,MAAAA,CAAC,CAAC0D,OAAF,CAAUG,IAAI,CAACgG,SAAf,EAA0B,UAASM,QAAT,EAAmB;AAC3CtJ,QAAAA,IAAI,CAACqG,YAAL,CAAkB/F,CAAlB,EAAqB,UAArB,EAAiC;AAC/BuD,UAAAA,KAAK,EAAEyF,QAAQ,CAAClD,KAAT,CAAevC,KADS;AAE/BC,UAAAA,MAAM,EAAEwF,QAAQ,CAAClD,KAAT,CAAetC,MAFQ;AAG/BvE,UAAAA,IAAI,EAAEyD,IAAI,CAACzD,IAHoB;AAI/BO,UAAAA,KAAK,EAAEuJ,CAAC,GAAI,EAAED,UAJiB;AAK/BjI,UAAAA,CAAC,EAAEmI,QAAQ,CAACnI,CALmB;AAM/BiF,UAAAA,KAAK,EAAEkD,QAAQ,CAAClD;AANe,SAAjC,EAOG,KAPH;AAQD,OATD;;AAUA,aAAOpD,IAAI,CAACgG,SAAZ;AACD,KAdD;AAeD,GAjBD;AAkBD;;AAED,SAAS9G,iBAAT,CAA2B5B,CAA3B,EAA8B;AAC5BnB,EAAAA,CAAC,CAAC0D,OAAF,CAAUvC,CAAC,CAACwC,KAAF,EAAV,EAAqB,UAASO,CAAT,EAAY;AAC/B,QAAIL,IAAI,GAAG1C,CAAC,CAAC0C,IAAF,CAAOK,CAAP,CAAX;;AACA,QAAIL,IAAI,CAAC2D,KAAL,KAAe,UAAnB,EAA+B;AAC7B,UAAI4C,QAAQ,GAAGjJ,CAAC,CAAC0C,IAAF,CAAOA,IAAI,CAAC7B,CAAL,CAAOkC,CAAd,CAAf;AACA,UAAIG,CAAC,GAAG+F,QAAQ,CAAC/F,CAAT,GAAa+F,QAAQ,CAAC1F,KAAT,GAAiB,CAAtC;AACA,UAAIJ,CAAC,GAAG8F,QAAQ,CAAC9F,CAAjB;AACA,UAAI+F,EAAE,GAAGxG,IAAI,CAACQ,CAAL,GAASA,CAAlB;AACA,UAAIiG,EAAE,GAAGF,QAAQ,CAACzF,MAAT,GAAkB,CAA3B;AACAxD,MAAAA,CAAC,CAACyF,OAAF,CAAU/C,IAAI,CAAC7B,CAAf,EAAkB6B,IAAI,CAACoD,KAAvB;AACA9F,MAAAA,CAAC,CAACuG,UAAF,CAAaxD,CAAb;AACAL,MAAAA,IAAI,CAACoD,KAAL,CAAWnC,MAAX,GAAoB,CAClB;AAAET,QAAAA,CAAC,EAAEA,CAAC,GAAG,IAAIgG,EAAJ,GAAS,CAAlB;AAAqB/F,QAAAA,CAAC,EAAEA,CAAC,GAAGgG;AAA5B,OADkB,EAElB;AAAEjG,QAAAA,CAAC,EAAEA,CAAC,GAAG,IAAIgG,EAAJ,GAAS,CAAlB;AAAqB/F,QAAAA,CAAC,EAAEA,CAAC,GAAGgG;AAA5B,OAFkB,EAGlB;AAAEjG,QAAAA,CAAC,EAAEA,CAAC,GAAOgG,EAAb;AAAqB/F,QAAAA,CAAC,EAAEA;AAAxB,OAHkB,EAIlB;AAAED,QAAAA,CAAC,EAAEA,CAAC,GAAG,IAAIgG,EAAJ,GAAS,CAAlB;AAAqB/F,QAAAA,CAAC,EAAEA,CAAC,GAAGgG;AAA5B,OAJkB,EAKlB;AAAEjG,QAAAA,CAAC,EAAEA,CAAC,GAAG,IAAIgG,EAAJ,GAAS,CAAlB;AAAqB/F,QAAAA,CAAC,EAAEA,CAAC,GAAGgG;AAA5B,OALkB,CAApB;AAOAzG,MAAAA,IAAI,CAACoD,KAAL,CAAW5C,CAAX,GAAeR,IAAI,CAACQ,CAApB;AACAR,MAAAA,IAAI,CAACoD,KAAL,CAAW3C,CAAX,GAAeT,IAAI,CAACS,CAApB;AACD;AACF,GApBD;AAqBD;;AAED,SAASgC,iBAAT,CAA2BiE,GAA3B,EAAgChC,KAAhC,EAAuC;AACrC,SAAOvI,CAAC,CAACwK,SAAF,CAAYxK,CAAC,CAACuG,IAAF,CAAOgE,GAAP,EAAYhC,KAAZ,CAAZ,EAAgCX,MAAhC,CAAP;AACD;;AAED,SAASzB,YAAT,CAAsBoC,KAAtB,EAA6B;AAC3B,MAAIkC,QAAQ,GAAG,EAAf;;AACAzK,EAAAA,CAAC,CAAC0D,OAAF,CAAU6E,KAAV,EAAiB,UAASrE,CAAT,EAAYwG,CAAZ,EAAe;AAC9BD,IAAAA,QAAQ,CAACC,CAAC,CAAC3D,WAAF,EAAD,CAAR,GAA4B7C,CAA5B;AACD,GAFD;;AAGA,SAAOuG,QAAP;AACD","sourcesContent":["\"use strict\";\n\nvar _ = require(\"./lodash\");\nvar acyclic = require(\"./acyclic\");\nvar normalize = require(\"./normalize\");\nvar rank = require(\"./rank\");\nvar normalizeRanks = require(\"./util\").normalizeRanks;\nvar parentDummyChains = require(\"./parent-dummy-chains\");\nvar removeEmptyRanks = require(\"./util\").removeEmptyRanks;\nvar nestingGraph = require(\"./nesting-graph\");\nvar addBorderSegments = require(\"./add-border-segments\");\nvar coordinateSystem = require(\"./coordinate-system\");\nvar order = require(\"./order\");\nvar position = require(\"./position\");\nvar util = require(\"./util\");\nvar Graph = require(\"./graphlib\").Graph;\nvar initDataOrder = require(\"./order/init-data-order\");\n\nmodule.exports = layout;\n\nfunction layout(g, opts) {\n  var time = opts && opts.debugTiming ? util.time : util.notime;\n  time(\"layout\", function() {\n    // 如果在原图基础上修改，继承原图的order结果\n    if (opts && !opts.keepNodeOrder && opts.prevGraph) {\n      time(\"  inheritOrder\", function() { inheritOrder(g, opts.prevGraph); });\n    }\n    var layoutGraph = \n      time(\"  buildLayoutGraph\", function() { return buildLayoutGraph(g); });\n    // 控制是否为边的label留位置（这会影响是否在边中间添加dummy node）\n    if (!(opts && (opts.edgeLabelSpace === false))) {\n      time(\"  makeSpaceForEdgeLabels\", function() { makeSpaceForEdgeLabels(layoutGraph); });\n    }\n    // TODO: 暂时处理层级设置不正确时的异常报错，提示设置正确的层级\n    try {\n      time(\"  runLayout\",        function() { runLayout(layoutGraph, time, opts); });\n    } catch(e) {\n      if (e.message === \"Not possible to find intersection inside of the rectangle\") {\n        console.error('The following error may be caused by improper layer setting, please make sure your manual layer setting does not violate the graph\\'s structure:\\n', e);\n        return;\n      } else {\n        throw(e);\n      }\n    }\n    time(\"  updateInputGraph\", function() { updateInputGraph(g, layoutGraph); });\n  });\n}\n\nfunction runLayout(g, time, opts) {\n  time(\"    removeSelfEdges\",        function() { removeSelfEdges(g); });\n  time(\"    acyclic\",                function() { acyclic.run(g); });\n  time(\"    nestingGraph.run\",       function() { nestingGraph.run(g); });\n  time(\"    rank\",                   function() { rank(util.asNonCompoundGraph(g)); });\n  time(\"    injectEdgeLabelProxies\", function() { injectEdgeLabelProxies(g); });\n  time(\"    removeEmptyRanks\",       function() { removeEmptyRanks(g); });\n  time(\"    nestingGraph.cleanup\",   function() { nestingGraph.cleanup(g); });\n  time(\"    normalizeRanks\",         function() { normalizeRanks(g); });\n  time(\"    assignRankMinMax\",       function() { assignRankMinMax(g); });\n  time(\"    removeEdgeLabelProxies\", function() { removeEdgeLabelProxies(g); });\n  time(\"    normalize.run\",          function() { normalize.run(g); });\n  time(\"    parentDummyChains\",      function() { parentDummyChains(g); });\n  time(\"    addBorderSegments\",      function() { addBorderSegments(g); });\n  if (opts && opts.keepNodeOrder) {\n    time(\"    initDataOrder\", function() { initDataOrder(g, opts.nodeOrder); });\n  }\n  time(\"    order\",                  function() { order(g); });\n  time(\"    insertSelfEdges\",        function() { insertSelfEdges(g); });\n  time(\"    adjustCoordinateSystem\", function() { coordinateSystem.adjust(g); });\n  time(\"    position\",               function() { position(g); });\n  time(\"    positionSelfEdges\",      function() { positionSelfEdges(g); });\n  time(\"    removeBorderNodes\",      function() { removeBorderNodes(g); });\n  time(\"    normalize.undo\",         function() { normalize.undo(g); });\n  time(\"    fixupEdgeLabelCoords\",   function() { fixupEdgeLabelCoords(g); });\n  time(\"    undoCoordinateSystem\",   function() { coordinateSystem.undo(g); });\n  time(\"    translateGraph\",         function() { translateGraph(g); });\n  time(\"    assignNodeIntersects\",   function() { assignNodeIntersects(g); });\n  time(\"    reversePoints\",          function() { reversePointsForReversedEdges(g); });\n  time(\"    acyclic.undo\",           function() { acyclic.undo(g); });\n}\n\n/**\n * 继承上一个布局中的order，防止翻转\n * TODO: 暂时没有考虑涉及层级变动的布局，只保证原来布局层级和相对顺序不变\n */\nfunction inheritOrder(currG, prevG) {\n  var prevNodeMap = prevG._nodes;\n  _.forEach(currG.nodes(), function (n) {\n    var node = currG.node(n);\n    if (prevNodeMap[n] !== undefined) {\n      node.fixorder = prevNodeMap[n]._order;\n      delete prevNodeMap[n]._order;\n    } else {\n      delete node.fixorder;\n    }\n  });\n}\n\n/*\n * Copies final layout information from the layout graph back to the input\n * graph. This process only copies whitelisted attributes from the layout graph\n * to the input graph, so it serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction updateInputGraph(inputGraph, layoutGraph) {\n  _.forEach(inputGraph.nodes(), function(v) {\n    var inputLabel = inputGraph.node(v);\n    var layoutLabel = layoutGraph.node(v);\n\n    if (inputLabel) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n      inputLabel._order = layoutLabel.order;\n      inputLabel._rank = layoutLabel.rank;\n\n      if (layoutGraph.children(v).length) {\n        inputLabel.width = layoutLabel.width;\n        inputLabel.height = layoutLabel.height;\n      }\n    }\n  });\n\n  _.forEach(inputGraph.edges(), function(e) {\n    var inputLabel = inputGraph.edge(e);\n    var layoutLabel = layoutGraph.edge(e);\n\n    inputLabel.points = layoutLabel.points;\n    if (_.has(layoutLabel, \"x\")) {\n      inputLabel.x = layoutLabel.x;\n      inputLabel.y = layoutLabel.y;\n    }\n  });\n\n  inputGraph.graph().width = layoutGraph.graph().width;\n  inputGraph.graph().height = layoutGraph.graph().height;\n}\n\nvar graphNumAttrs = [\"nodesep\", \"edgesep\", \"ranksep\", \"marginx\", \"marginy\"];\nvar graphDefaults = { ranksep: 50, edgesep: 20, nodesep: 50, rankdir: \"tb\" };\nvar graphAttrs = [\"acyclicer\", \"ranker\", \"rankdir\", \"align\"];\nvar nodeNumAttrs = [\"width\", \"height\", \"layer\", \"fixorder\"]; // 需要传入layer, fixOrder作为参数参考\nvar nodeDefaults = { width: 0, height: 0 };\nvar edgeNumAttrs = [\"minlen\", \"weight\", \"width\", \"height\", \"labeloffset\"];\nvar edgeDefaults = {\n  minlen: 1, weight: 1, width: 0, height: 0,\n  labeloffset: 10, labelpos: \"r\"\n};\nvar edgeAttrs = [\"labelpos\"];\n\n/*\n * Constructs a new graph from the input graph, which can be used for layout.\n * This process copies only whitelisted attributes from the input graph to the\n * layout graph. Thus this function serves as a good place to determine what\n * attributes can influence layout.\n */\nfunction buildLayoutGraph(inputGraph) {\n  var g = new Graph({ multigraph: true, compound: true });\n  var graph = canonicalize(inputGraph.graph());\n\n  g.setGraph(_.merge({},\n    graphDefaults,\n    selectNumberAttrs(graph, graphNumAttrs),\n    _.pick(graph, graphAttrs)));\n\n  _.forEach(inputGraph.nodes(), function(v) {\n    var node = canonicalize(inputGraph.node(v));\n    g.setNode(v, _.defaults(selectNumberAttrs(node, nodeNumAttrs), nodeDefaults));\n    g.setParent(v, inputGraph.parent(v));\n  });\n\n  _.forEach(inputGraph.edges(), function(e) {\n    var edge = canonicalize(inputGraph.edge(e));\n    g.setEdge(e, _.merge({},\n      edgeDefaults,\n      selectNumberAttrs(edge, edgeNumAttrs),\n      _.pick(edge, edgeAttrs)));\n  });\n\n  return g;\n}\n\n/*\n * This idea comes from the Gansner paper: to account for edge labels in our\n * layout we split each rank in half by doubling minlen and halving ranksep.\n * Then we can place labels at these mid-points between nodes.\n *\n * We also add some minimal padding to the width to push the label for the edge\n * away from the edge itself a bit.\n */\nfunction makeSpaceForEdgeLabels(g) {\n  var graph = g.graph();\n  graph.ranksep /= 2;\n  _.forEach(g.nodes(), function(n) {\n    var node = g.node(n);\n    if (!isNaN(node.layer)) {\n      node.layer *= 2; // TODO: 因为默认的rank变为两倍，设定的layer也*2\n    }\n  });\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    edge.minlen *= 2;\n    if (edge.labelpos.toLowerCase() !== \"c\") {\n      if (graph.rankdir === \"TB\" || graph.rankdir === \"BT\") {\n        edge.width += edge.labeloffset;\n      } else {\n        edge.height += edge.labeloffset;\n      }\n    }\n  });\n}\n\n/*\n * Creates temporary dummy nodes that capture the rank in which each edge's\n * label is going to, if it has one of non-zero width and height. We do this\n * so that we can safely remove empty ranks while preserving balance for the\n * label's position.\n */\nfunction injectEdgeLabelProxies(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (edge.width && edge.height) {\n      var v = g.node(e.v);\n      var w = g.node(e.w);\n      var label = { rank: (w.rank - v.rank) / 2 + v.rank, e: e };\n      util.addDummyNode(g, \"edge-proxy\", label, \"_ep\");\n    }\n  });\n}\n\nfunction assignRankMinMax(g) {\n  var maxRank = 0;\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (node.borderTop) {\n      node.minRank = g.node(node.borderTop).rank;\n      node.maxRank = g.node(node.borderBottom).rank;\n      maxRank = _.max(maxRank, node.maxRank);\n    }\n  });\n  g.graph().maxRank = maxRank;\n}\n\nfunction removeEdgeLabelProxies(g) {\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (node.dummy === \"edge-proxy\") {\n      g.edge(node.e).labelRank = node.rank;\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction translateGraph(g) {\n  var minX = Number.POSITIVE_INFINITY;\n  var maxX = 0;\n  var minY = Number.POSITIVE_INFINITY;\n  var maxY = 0;\n  var graphLabel = g.graph();\n  var marginX = graphLabel.marginx || 0;\n  var marginY = graphLabel.marginy || 0;\n\n  function getExtremes(attrs) {\n    var x = attrs.x;\n    var y = attrs.y;\n    var w = attrs.width;\n    var h = attrs.height;\n    minX = Math.min(minX, x - w / 2);\n    maxX = Math.max(maxX, x + w / 2);\n    minY = Math.min(minY, y - h / 2);\n    maxY = Math.max(maxY, y + h / 2);\n  }\n\n  _.forEach(g.nodes(), function(v) { getExtremes(g.node(v)); });\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (_.has(edge, \"x\")) {\n      getExtremes(edge);\n    }\n  });\n\n  minX -= marginX;\n  minY -= marginY;\n\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    node.x -= minX;\n    node.y -= minY;\n  });\n\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    _.forEach(edge.points, function(p) {\n      p.x -= minX;\n      p.y -= minY;\n    });\n    if (_.has(edge, \"x\")) { edge.x -= minX; }\n    if (_.has(edge, \"y\")) { edge.y -= minY; }\n  });\n\n  graphLabel.width = maxX - minX + marginX;\n  graphLabel.height = maxY - minY + marginY;\n}\n\nfunction assignNodeIntersects(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    var nodeV = g.node(e.v);\n    var nodeW = g.node(e.w);\n    var p1, p2;\n    if (!edge.points) {\n      edge.points = [];\n      p1 = nodeW;\n      p2 = nodeV;\n    } else {\n      p1 = edge.points[0];\n      p2 = edge.points[edge.points.length - 1];\n    }\n    edge.points.unshift(util.intersectRect(nodeV, p1));\n    edge.points.push(util.intersectRect(nodeW, p2));\n  });\n}\n\nfunction fixupEdgeLabelCoords(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (_.has(edge, \"x\")) {\n      if (edge.labelpos === \"l\" || edge.labelpos === \"r\") {\n        edge.width -= edge.labeloffset;\n      }\n      switch (edge.labelpos) {\n      case \"l\": edge.x -= edge.width / 2 + edge.labeloffset; break;\n      case \"r\": edge.x += edge.width / 2 + edge.labeloffset; break;\n      }\n    }\n  });\n}\n\nfunction reversePointsForReversedEdges(g) {\n  _.forEach(g.edges(), function(e) {\n    var edge = g.edge(e);\n    if (edge.reversed) {\n      edge.points.reverse();\n    }\n  });\n}\n\nfunction removeBorderNodes(g) {\n  _.forEach(g.nodes(), function(v) {\n    if (g.children(v).length) {\n      var node = g.node(v);\n      var t = g.node(node.borderTop);\n      var b = g.node(node.borderBottom);\n      var l = g.node(_.last(node.borderLeft));\n      var r = g.node(_.last(node.borderRight));\n\n      node.width = Math.abs(r.x - l.x);\n      node.height = Math.abs(b.y - t.y);\n      node.x = l.x + node.width / 2;\n      node.y = t.y + node.height / 2;\n    }\n  });\n\n  _.forEach(g.nodes(), function(v) {\n    if (g.node(v).dummy === \"border\") {\n      g.removeNode(v);\n    }\n  });\n}\n\nfunction removeSelfEdges(g) {\n  _.forEach(g.edges(), function(e) {\n    if (e.v === e.w) {\n      var node = g.node(e.v);\n      if (!node.selfEdges) {\n        node.selfEdges = [];\n      }\n      node.selfEdges.push({ e: e, label: g.edge(e) });\n      g.removeEdge(e);\n    }\n  });\n}\n\nfunction insertSelfEdges(g) {\n  var layers = util.buildLayerMatrix(g);\n  _.forEach(layers, function(layer) {\n    var orderShift = 0;\n    _.forEach(layer, function(v, i) {\n      var node = g.node(v);\n      node.order = i + orderShift;\n      _.forEach(node.selfEdges, function(selfEdge) {\n        util.addDummyNode(g, \"selfedge\", {\n          width: selfEdge.label.width,\n          height: selfEdge.label.height,\n          rank: node.rank,\n          order: i + (++orderShift),\n          e: selfEdge.e,\n          label: selfEdge.label\n        }, \"_se\");\n      });\n      delete node.selfEdges;\n    });\n  });\n}\n\nfunction positionSelfEdges(g) {\n  _.forEach(g.nodes(), function(v) {\n    var node = g.node(v);\n    if (node.dummy === \"selfedge\") {\n      var selfNode = g.node(node.e.v);\n      var x = selfNode.x + selfNode.width / 2;\n      var y = selfNode.y;\n      var dx = node.x - x;\n      var dy = selfNode.height / 2;\n      g.setEdge(node.e, node.label);\n      g.removeNode(v);\n      node.label.points = [\n        { x: x + 2 * dx / 3, y: y - dy },\n        { x: x + 5 * dx / 6, y: y - dy },\n        { x: x +     dx    , y: y },\n        { x: x + 5 * dx / 6, y: y + dy },\n        { x: x + 2 * dx / 3, y: y + dy }\n      ];\n      node.label.x = node.x;\n      node.label.y = node.y;\n    }\n  });\n}\n\nfunction selectNumberAttrs(obj, attrs) {\n  return _.mapValues(_.pick(obj, attrs), Number);\n}\n\nfunction canonicalize(attrs) {\n  var newAttrs = {};\n  _.forEach(attrs, function(v, k) {\n    newAttrs[k.toLowerCase()] = v;\n  });\n  return newAttrs;\n}\n"]},"metadata":{},"sourceType":"script"}