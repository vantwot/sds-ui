{"ast":null,"code":"import { Point } from '../../geometry';\nimport { attr } from './attr';\nimport { getBBox, getTransformToElement } from './geom';\nimport { createSVGTransform, parseTransformString, transformStringToMatrix, matrixToTransformString } from './matrix';\nexport function transform(elem, matrix) {\n  var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n  if (matrix == null) {\n    return transformStringToMatrix(attr(elem, 'transform'));\n  }\n\n  if (options.absolute) {\n    elem.setAttribute('transform', matrixToTransformString(matrix));\n    return;\n  }\n\n  var transformList = elem.transform;\n  var svgTransform = createSVGTransform(matrix);\n  transformList.baseVal.appendItem(svgTransform);\n}\nexport function translate(elem, tx) {\n  var ty = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n  var transformAttr = attr(elem, 'transform');\n  var transform = parseTransformString(transformAttr);\n\n  if (tx == null) {\n    return transform.translation;\n  }\n\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n  var newTx = options.absolute ? tx : transform.translation.tx + tx;\n  var newTy = options.absolute ? ty : transform.translation.ty + ty;\n  var newTranslate = \"translate(\".concat(newTx, \",\").concat(newTy, \")\"); // Note that `translate()` is always the first transformation. This is\n  // usually the desired case.\n\n  elem.setAttribute('transform', \"\".concat(newTranslate, \" \").concat(transformAttr).trim());\n}\nexport function rotate(elem, angle, cx, cy) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n  var transformAttr = attr(elem, 'transform');\n  var transform = parseTransformString(transformAttr);\n\n  if (angle == null) {\n    return transform.rotation;\n  }\n\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n  angle %= 360; // eslint-disable-line\n\n  var newAngle = options.absolute ? angle : transform.rotation.angle + angle;\n  var newOrigin = cx != null && cy != null ? \",\".concat(cx, \",\").concat(cy) : '';\n  var newRotate = \"rotate(\".concat(newAngle).concat(newOrigin, \")\");\n  elem.setAttribute('transform', \"\".concat(transformAttr, \" \").concat(newRotate).trim());\n}\nexport function scale(elem, sx, sy) {\n  var transformAttr = attr(elem, 'transform');\n  var transform = parseTransformString(transformAttr);\n\n  if (sx == null) {\n    return transform.scale;\n  }\n\n  sy = sy == null ? sx : sy; // eslint-disable-line\n\n  transformAttr = transform.raw;\n  transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n  var newScale = \"scale(\".concat(sx, \",\").concat(sy, \")\");\n  elem.setAttribute('transform', \"\".concat(transformAttr, \" \").concat(newScale).trim());\n}\nexport function translateAndAutoOrient(elem, position, reference, target) {\n  var pos = Point.create(position);\n  var ref = Point.create(reference);\n\n  if (!target) {\n    var svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n    target = svg; // eslint-disable-line\n  } // Clean-up previously set transformations except the scale.\n  // If we didn't clean up the previous transformations then they'd\n  // add up with the old ones. Scale is an exception as it doesn't\n  // add up, consider: `this.scale(2).scale(2).scale(2)`. The result\n  // is that the element is scaled by the factor 2, not 8.\n\n\n  var s = scale(elem);\n  elem.setAttribute('transform', '');\n  var bbox = getBBox(elem, {\n    target: target\n  }).scale(s.sx, s.sy); // 1. Translate to origin.\n\n  var translateToOrigin = createSVGTransform();\n  translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2); // 2. Rotate around origin.\n\n  var rotateAroundOrigin = createSVGTransform();\n  var angle = pos.angleBetween(ref, pos.clone().translate(1, 0));\n  if (angle) rotateAroundOrigin.setRotate(angle, 0, 0); // 3. Translate to the `position` + the offset (half my width)\n  //    towards the `reference` point.\n\n  var translateFromOrigin = createSVGTransform();\n  var finalPosition = pos.clone().move(ref, bbox.width / 2);\n  translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y); // 4. Get the current transformation matrix of this node\n\n  var ctm = getTransformToElement(elem, target); // 5. Apply transformations and the scale\n\n  var transform = createSVGTransform();\n  transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));\n  elem.setAttribute('transform', matrixToTransformString(transform.matrix));\n}","map":{"version":3,"sources":["../../../src/util/dom/transform.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Point } from '../../geometry';\nimport { attr } from './attr';\nimport { getBBox, getTransformToElement } from './geom';\nimport { createSVGTransform, parseTransformString, transformStringToMatrix, matrixToTransformString, } from './matrix';\nexport function transform(elem, matrix, options = {}) {\n    if (matrix == null) {\n        return transformStringToMatrix(attr(elem, 'transform'));\n    }\n    if (options.absolute) {\n        elem.setAttribute('transform', matrixToTransformString(matrix));\n        return;\n    }\n    const transformList = elem.transform;\n    const svgTransform = createSVGTransform(matrix);\n    transformList.baseVal.appendItem(svgTransform);\n}\nexport function translate(elem, tx, ty = 0, options = {}) {\n    let transformAttr = attr(elem, 'transform');\n    const transform = parseTransformString(transformAttr);\n    if (tx == null) {\n        return transform.translation;\n    }\n    transformAttr = transform.raw;\n    transformAttr = transformAttr.replace(/translate\\([^)]*\\)/g, '').trim();\n    const newTx = options.absolute ? tx : transform.translation.tx + tx;\n    const newTy = options.absolute ? ty : transform.translation.ty + ty;\n    const newTranslate = `translate(${newTx},${newTy})`;\n    // Note that `translate()` is always the first transformation. This is\n    // usually the desired case.\n    elem.setAttribute('transform', `${newTranslate} ${transformAttr}`.trim());\n}\nexport function rotate(elem, angle, cx, cy, options = {}) {\n    let transformAttr = attr(elem, 'transform');\n    const transform = parseTransformString(transformAttr);\n    if (angle == null) {\n        return transform.rotation;\n    }\n    transformAttr = transform.raw;\n    transformAttr = transformAttr.replace(/rotate\\([^)]*\\)/g, '').trim();\n    angle %= 360; // eslint-disable-line\n    const newAngle = options.absolute ? angle : transform.rotation.angle + angle;\n    const newOrigin = cx != null && cy != null ? `,${cx},${cy}` : '';\n    const newRotate = `rotate(${newAngle}${newOrigin})`;\n    elem.setAttribute('transform', `${transformAttr} ${newRotate}`.trim());\n}\nexport function scale(elem, sx, sy) {\n    let transformAttr = attr(elem, 'transform');\n    const transform = parseTransformString(transformAttr);\n    if (sx == null) {\n        return transform.scale;\n    }\n    sy = sy == null ? sx : sy; // eslint-disable-line\n    transformAttr = transform.raw;\n    transformAttr = transformAttr.replace(/scale\\([^)]*\\)/g, '').trim();\n    const newScale = `scale(${sx},${sy})`;\n    elem.setAttribute('transform', `${transformAttr} ${newScale}`.trim());\n}\nexport function translateAndAutoOrient(elem, position, reference, target) {\n    const pos = Point.create(position);\n    const ref = Point.create(reference);\n    if (!target) {\n        const svg = elem instanceof SVGSVGElement ? elem : elem.ownerSVGElement;\n        target = svg; // eslint-disable-line\n    }\n    // Clean-up previously set transformations except the scale.\n    // If we didn't clean up the previous transformations then they'd\n    // add up with the old ones. Scale is an exception as it doesn't\n    // add up, consider: `this.scale(2).scale(2).scale(2)`. The result\n    // is that the element is scaled by the factor 2, not 8.\n    const s = scale(elem);\n    elem.setAttribute('transform', '');\n    const bbox = getBBox(elem, { target }).scale(s.sx, s.sy);\n    // 1. Translate to origin.\n    const translateToOrigin = createSVGTransform();\n    translateToOrigin.setTranslate(-bbox.x - bbox.width / 2, -bbox.y - bbox.height / 2);\n    // 2. Rotate around origin.\n    const rotateAroundOrigin = createSVGTransform();\n    const angle = pos.angleBetween(ref, pos.clone().translate(1, 0));\n    if (angle)\n        rotateAroundOrigin.setRotate(angle, 0, 0);\n    // 3. Translate to the `position` + the offset (half my width)\n    //    towards the `reference` point.\n    const translateFromOrigin = createSVGTransform();\n    const finalPosition = pos.clone().move(ref, bbox.width / 2);\n    translateFromOrigin.setTranslate(2 * pos.x - finalPosition.x, 2 * pos.y - finalPosition.y);\n    // 4. Get the current transformation matrix of this node\n    const ctm = getTransformToElement(elem, target);\n    // 5. Apply transformations and the scale\n    const transform = createSVGTransform();\n    transform.setMatrix(translateFromOrigin.matrix.multiply(rotateAroundOrigin.matrix.multiply(translateToOrigin.matrix.multiply(ctm.scale(s.sx, s.sy)))));\n    elem.setAttribute('transform', matrixToTransformString(transform.matrix));\n}\n//# sourceMappingURL=transform.js.map"]},"metadata":{},"sourceType":"module"}