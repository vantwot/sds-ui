{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Util } from '../../global';\nimport { Rectangle, Angle } from '../../geometry';\nimport { ObjectExt, StringExt, FunctionExt } from '../../util';\nimport { Cell } from '../../model/cell';\nimport { Collection } from '../../model/collection';\nimport { View } from '../../view/view';\nimport { notify } from '../transform/util';\nimport { Handle } from '../common';\nexport class Selection extends View {\n  constructor(options) {\n    super();\n    this.options = ObjectExt.merge({}, Private.defaultOptions, options);\n\n    if (this.options.model) {\n      this.options.collection = this.options.model.collection;\n    }\n\n    if (this.options.collection) {\n      this.collection = this.options.collection;\n    } else {\n      this.collection = new Collection([], {\n        comparator: Private.depthComparator\n      });\n      this.options.collection = this.collection;\n    }\n\n    this.boxCount = 0;\n    this.createContainer();\n    this.initHandles();\n    this.startListening();\n  }\n\n  get graph() {\n    return this.options.graph;\n  }\n\n  get boxClassName() {\n    return this.prefixClassName(Private.classNames.box);\n  }\n\n  get $boxes() {\n    return this.$container.children(`.${this.boxClassName}`);\n  }\n\n  get handleOptions() {\n    return this.options;\n  }\n\n  startListening() {\n    const graph = this.graph;\n    const collection = this.collection;\n    this.delegateEvents({\n      [`mousedown .${this.boxClassName}`]: 'onSelectionBoxMouseDown',\n      [`touchstart .${this.boxClassName}`]: 'onSelectionBoxMouseDown'\n    }, true);\n    graph.on('scale', this.onGraphTransformed, this);\n    graph.on('translate', this.onGraphTransformed, this);\n    graph.model.on('updated', this.onModelUpdated, this);\n    collection.on('added', this.onCellAdded, this);\n    collection.on('removed', this.onCellRemoved, this);\n    collection.on('reseted', this.onReseted, this);\n    collection.on('updated', this.onCollectionUpdated, this);\n    collection.on('node:change:position', this.onNodePositionChanged, this);\n    collection.on('cell:changed', this.onCellChanged, this);\n  }\n\n  stopListening() {\n    const graph = this.graph;\n    const collection = this.collection;\n    this.undelegateEvents();\n    graph.off('scale', this.onGraphTransformed, this);\n    graph.off('translate', this.onGraphTransformed, this);\n    graph.model.off('updated', this.onModelUpdated, this);\n    collection.off('added', this.onCellAdded, this);\n    collection.off('removed', this.onCellRemoved, this);\n    collection.off('reseted', this.onReseted, this);\n    collection.off('updated', this.onCollectionUpdated, this);\n    collection.off('node:change:position', this.onNodePositionChanged, this);\n    collection.off('cell:changed', this.onCellChanged, this);\n  }\n\n  onRemove() {\n    this.stopListening();\n  }\n\n  onGraphTransformed() {\n    this.updateSelectionBoxes({\n      async: false\n    });\n  }\n\n  onCellChanged() {\n    this.updateSelectionBoxes();\n  }\n\n  onNodePositionChanged(_ref) {\n    let {\n      node,\n      options\n    } = _ref;\n    const {\n      showNodeSelectionBox,\n      pointerEvents\n    } = this.options;\n    const {\n      ui,\n      selection\n    } = options;\n    let allowTranslating = !this.translating;\n    /* Scenarios where this method is not called:\n     * 1. ShowNodeSelection is true or ponterEvents is none\n     * 2. Avoid circular calls with the selection tag\n     */\n\n    allowTranslating = allowTranslating && (showNodeSelectionBox !== true || pointerEvents === 'none');\n    allowTranslating = allowTranslating && ui && !selection;\n\n    if (allowTranslating) {\n      this.translating = true;\n      const current = node.position();\n      const previous = node.previous('position');\n      const dx = current.x - previous.x;\n      const dy = current.y - previous.y;\n\n      if (dx !== 0 || dy !== 0) {\n        this.translateSelectedNodes(dx, dy, node, options);\n      }\n\n      this.translating = false;\n    }\n  }\n\n  onModelUpdated(_ref2) {\n    let {\n      removed\n    } = _ref2;\n\n    if (removed && removed.length) {\n      this.unselect(removed);\n    }\n  }\n\n  isEmpty() {\n    return this.length <= 0;\n  }\n\n  isSelected(cell) {\n    return this.collection.has(cell);\n  }\n\n  get length() {\n    return this.collection.length;\n  }\n\n  get cells() {\n    return this.collection.toArray();\n  }\n\n  select(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    options.dryrun = true;\n    const items = this.filter(Array.isArray(cells) ? cells : [cells]);\n    this.collection.add(items, options);\n    return this;\n  }\n\n  unselect(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    // dryrun to prevent cell be removed from graph\n    options.dryrun = true;\n    this.collection.remove(Array.isArray(cells) ? cells : [cells], options);\n    return this;\n  }\n\n  reset(cells) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (cells) {\n      if (options.batch) {\n        const filterCells = this.filter(Array.isArray(cells) ? cells : [cells]);\n        this.collection.reset(filterCells, Object.assign(Object.assign({}, options), {\n          ui: true\n        }));\n        return this;\n      }\n\n      const prev = this.cells;\n      const next = this.filter(Array.isArray(cells) ? cells : [cells]);\n      const prevMap = {};\n      const nextMap = {};\n      prev.forEach(cell => prevMap[cell.id] = cell);\n      next.forEach(cell => nextMap[cell.id] = cell);\n      const added = [];\n      const removed = [];\n      next.forEach(cell => {\n        if (!prevMap[cell.id]) {\n          added.push(cell);\n        }\n      });\n      prev.forEach(cell => {\n        if (!nextMap[cell.id]) {\n          removed.push(cell);\n        }\n      });\n\n      if (removed.length) {\n        this.unselect(removed, Object.assign(Object.assign({}, options), {\n          ui: true\n        }));\n      }\n\n      if (added.length) {\n        this.select(added, Object.assign(Object.assign({}, options), {\n          ui: true\n        }));\n      }\n\n      if (removed.length === 0 && added.length === 0) {\n        this.updateContainer();\n      }\n\n      return this;\n    }\n\n    return this.clean(options);\n  }\n\n  clean() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.length) {\n      if (options.batch === false) {\n        this.unselect(this.cells, options);\n      } else {\n        this.collection.reset([], Object.assign(Object.assign({}, options), {\n          ui: true\n        }));\n      }\n    }\n\n    return this;\n  }\n\n  setFilter(filter) {\n    this.options.filter = filter;\n  }\n\n  setContent(content) {\n    this.options.content = content;\n  }\n\n  startSelecting(evt) {\n    // Flow: startSelecting => adjustSelection => stopSelecting\n    evt = this.normalizeEvent(evt); // eslint-disable-line\n\n    this.clean();\n    let x;\n    let y;\n    const graphContainer = this.graph.container;\n\n    if (evt.offsetX != null && evt.offsetY != null && graphContainer.contains(evt.target)) {\n      x = evt.offsetX;\n      y = evt.offsetY;\n    } else {\n      const offset = this.$(graphContainer).offset();\n      const scrollLeft = graphContainer.scrollLeft;\n      const scrollTop = graphContainer.scrollTop;\n      x = evt.clientX - offset.left + window.pageXOffset + scrollLeft;\n      y = evt.clientY - offset.top + window.pageYOffset + scrollTop;\n    }\n\n    this.$container.css({\n      top: y,\n      left: x,\n      width: 1,\n      height: 1\n    });\n    this.setEventData(evt, {\n      action: 'selecting',\n      clientX: evt.clientX,\n      clientY: evt.clientY,\n      offsetX: x,\n      offsetY: y,\n      scrollerX: 0,\n      scrollerY: 0\n    });\n    this.delegateDocumentEvents(Private.documentEvents, evt.data);\n  }\n\n  filter(cells) {\n    const filter = this.options.filter;\n\n    if (Array.isArray(filter)) {\n      return cells.filter(cell => !filter.includes(cell) && !filter.includes(cell.shape));\n    }\n\n    if (typeof filter === 'function') {\n      return cells.filter(cell => FunctionExt.call(filter, this.graph, cell));\n    }\n\n    return cells;\n  }\n\n  stopSelecting(evt) {\n    const graph = this.graph;\n    const eventData = this.getEventData(evt);\n    const action = eventData.action;\n\n    switch (action) {\n      case 'selecting':\n        {\n          let width = this.$container.width();\n          let height = this.$container.height();\n          const offset = this.$container.offset();\n          const origin = graph.pageToLocal(offset.left, offset.top);\n          const scale = graph.transform.getScale();\n          width /= scale.sx;\n          height /= scale.sy;\n          const rect = new Rectangle(origin.x, origin.y, width, height);\n          const cells = this.getCellViewsInArea(rect).map(view => view.cell);\n          this.reset(cells, {\n            batch: true\n          });\n          this.hideRubberband();\n          break;\n        }\n\n      case 'translating':\n        {\n          const client = graph.snapToGrid(evt.clientX, evt.clientY);\n\n          if (!this.options.following) {\n            const data = eventData;\n            this.updateSelectedNodesPosition({\n              dx: data.clientX - data.originX,\n              dy: data.clientY - data.originY\n            });\n          }\n\n          this.graph.model.stopBatch('move-selection');\n          this.notifyBoxEvent('box:mouseup', evt, client.x, client.y);\n          break;\n        }\n\n      default:\n        {\n          this.clean();\n          break;\n        }\n    }\n  }\n\n  onMouseUp(evt) {\n    const action = this.getEventData(evt).action;\n\n    if (action) {\n      this.stopSelecting(evt);\n      this.undelegateDocumentEvents();\n    }\n  }\n\n  onSelectionBoxMouseDown(evt) {\n    if (!this.options.following) {\n      evt.stopPropagation();\n    }\n\n    const e = this.normalizeEvent(evt);\n\n    if (this.options.movable) {\n      this.startTranslating(e);\n    }\n\n    const activeView = this.getCellViewFromElem(e.target);\n    this.setEventData(e, {\n      activeView\n    });\n    const client = this.graph.snapToGrid(e.clientX, e.clientY);\n    this.notifyBoxEvent('box:mousedown', e, client.x, client.y);\n    this.delegateDocumentEvents(Private.documentEvents, e.data);\n  }\n\n  startTranslating(evt) {\n    this.graph.model.startBatch('move-selection');\n    const client = this.graph.snapToGrid(evt.clientX, evt.clientY);\n    this.setEventData(evt, {\n      action: 'translating',\n      clientX: client.x,\n      clientY: client.y,\n      originX: client.x,\n      originY: client.y\n    });\n  }\n\n  getSelectionOffset(client, data) {\n    let dx = client.x - data.clientX;\n    let dy = client.y - data.clientY;\n    const restrict = this.graph.hook.getRestrictArea();\n\n    if (restrict) {\n      const cells = this.collection.toArray();\n      const totalBBox = Cell.getCellsBBox(cells, {\n        deep: true\n      }) || Rectangle.create();\n      const minDx = restrict.x - totalBBox.x;\n      const minDy = restrict.y - totalBBox.y;\n      const maxDx = restrict.x + restrict.width - (totalBBox.x + totalBBox.width);\n      const maxDy = restrict.y + restrict.height - (totalBBox.y + totalBBox.height);\n\n      if (dx < minDx) {\n        dx = minDx;\n      }\n\n      if (dy < minDy) {\n        dy = minDy;\n      }\n\n      if (maxDx < dx) {\n        dx = maxDx;\n      }\n\n      if (maxDy < dy) {\n        dy = maxDy;\n      }\n\n      if (!this.options.following) {\n        const offsetX = client.x - data.originX;\n        const offsetY = client.y - data.originY;\n        dx = offsetX <= minDx || offsetX >= maxDx ? 0 : dx;\n        dy = offsetY <= minDy || offsetY >= maxDy ? 0 : dy;\n      }\n    }\n\n    return {\n      dx,\n      dy\n    };\n  }\n\n  updateSelectedNodesPosition(offset) {\n    const {\n      dx,\n      dy\n    } = offset;\n\n    if (dx || dy) {\n      if (this.translateSelectedNodes(dx, dy), this.boxesUpdated) {\n        if (this.collection.length > 1) {\n          this.updateSelectionBoxes();\n        }\n      } else {\n        const scale = this.graph.transform.getScale();\n        this.$boxes.add(this.$selectionContainer).css({\n          left: `+=${dx * scale.sx}`,\n          top: `+=${dy * scale.sy}`\n        });\n      }\n    }\n  }\n\n  autoScrollGraph(x, y) {\n    const scroller = this.graph.scroller.widget;\n\n    if (scroller) {\n      return scroller.autoScroll(x, y);\n    }\n\n    return {\n      scrollerX: 0,\n      scrollerY: 0\n    };\n  }\n\n  adjustSelection(evt) {\n    const e = this.normalizeEvent(evt);\n    const eventData = this.getEventData(e);\n    const action = eventData.action;\n\n    switch (action) {\n      case 'selecting':\n        {\n          const data = eventData;\n\n          if (data.moving !== true) {\n            this.$container.appendTo(this.graph.container);\n            this.showRubberband();\n            data.moving = true;\n          }\n\n          const {\n            scrollerX,\n            scrollerY\n          } = this.autoScrollGraph(e.clientX, e.clientY);\n          data.scrollerX += scrollerX;\n          data.scrollerY += scrollerY;\n          const dx = e.clientX - data.clientX + data.scrollerX;\n          const dy = e.clientY - data.clientY + data.scrollerY;\n          const left = parseInt(this.$container.css('left'), 10);\n          const top = parseInt(this.$container.css('top'), 10);\n          this.$container.css({\n            left: dx < 0 ? data.offsetX + dx : left,\n            top: dy < 0 ? data.offsetY + dy : top,\n            width: Math.abs(dx),\n            height: Math.abs(dy)\n          });\n          break;\n        }\n\n      case 'translating':\n        {\n          const client = this.graph.snapToGrid(e.clientX, e.clientY);\n          const data = eventData;\n          const offset = this.getSelectionOffset(client, data);\n\n          if (this.options.following) {\n            this.updateSelectedNodesPosition(offset);\n          } else {\n            this.updateContainerPosition(offset);\n          }\n\n          if (offset.dx) {\n            data.clientX = client.x;\n          }\n\n          if (offset.dy) {\n            data.clientY = client.y;\n          }\n\n          this.notifyBoxEvent('box:mousemove', evt, client.x, client.y);\n          break;\n        }\n\n      default:\n        break;\n    }\n\n    this.boxesUpdated = false;\n  }\n\n  translateSelectedNodes(dx, dy, exclude, otherOptions) {\n    const map = {};\n    const excluded = [];\n\n    if (exclude) {\n      map[exclude.id] = true;\n    }\n\n    this.collection.toArray().forEach(cell => {\n      cell.getDescendants({\n        deep: true\n      }).forEach(child => {\n        map[child.id] = true;\n      });\n    });\n\n    if (otherOptions && otherOptions.translateBy) {\n      const currentCell = this.graph.getCellById(otherOptions.translateBy);\n\n      if (currentCell) {\n        map[currentCell.id] = true;\n        currentCell.getDescendants({\n          deep: true\n        }).forEach(child => {\n          map[child.id] = true;\n        });\n        excluded.push(currentCell);\n      }\n    }\n\n    this.collection.toArray().forEach(cell => {\n      if (!map[cell.id]) {\n        const options = Object.assign(Object.assign({}, otherOptions), {\n          selection: this.cid,\n          exclude: excluded\n        });\n        cell.translate(dx, dy, options);\n        this.graph.model.getConnectedEdges(cell).forEach(edge => {\n          if (!map[edge.id]) {\n            edge.translate(dx, dy, options);\n            map[edge.id] = true;\n          }\n        });\n      }\n    });\n  }\n\n  getCellViewsInArea(rect) {\n    const graph = this.graph;\n    const options = {\n      strict: this.options.strict\n    };\n    let views = [];\n\n    if (this.options.rubberNode) {\n      if (this.options.useCellGeometry) {\n        views = views.concat(graph.model.getNodesInArea(rect, options).map(node => graph.renderer.findViewByCell(node)).filter(view => view != null));\n      } else {\n        views = views.concat(graph.renderer.findViewsInArea(rect, options));\n      }\n    }\n\n    if (this.options.rubberEdge) {\n      if (this.options.useCellGeometry) {\n        views = views.concat(graph.model.getEdgesInArea(rect, options).map(edge => graph.renderer.findViewByCell(edge)).filter(view => view != null));\n      } else {\n        views = views.concat(graph.renderer.findEdgeViewsInArea(rect, options));\n      }\n    }\n\n    return views;\n  }\n\n  notifyBoxEvent(name, e, x, y) {\n    const data = this.getEventData(e);\n    const view = data.activeView;\n    this.trigger(name, {\n      e,\n      view,\n      x,\n      y,\n      cell: view.cell\n    });\n  }\n\n  getSelectedClassName(cell) {\n    return this.prefixClassName(`${cell.isNode() ? 'node' : 'edge'}-selected`);\n  }\n\n  addCellSelectedClassName(cell) {\n    const view = this.graph.renderer.findViewByCell(cell);\n\n    if (view) {\n      view.addClass(this.getSelectedClassName(cell));\n    }\n  }\n\n  removeCellUnSelectedClassName(cell) {\n    const view = this.graph.renderer.findViewByCell(cell);\n\n    if (view) {\n      view.removeClass(this.getSelectedClassName(cell));\n    }\n  }\n\n  destroySelectionBox(cell) {\n    this.removeCellUnSelectedClassName(cell);\n\n    if (this.canShowSelectionBox(cell)) {\n      this.$container.find(`[data-cell-id=\"${cell.id}\"]`).remove();\n\n      if (this.$boxes.length === 0) {\n        this.hide();\n      }\n\n      this.boxCount = Math.max(0, this.boxCount - 1);\n    }\n  }\n\n  destroyAllSelectionBoxes(cells) {\n    cells.forEach(cell => this.removeCellUnSelectedClassName(cell));\n    this.hide();\n    this.$boxes.remove();\n    this.boxCount = 0;\n  }\n\n  hide() {\n    this.$container.removeClass(this.prefixClassName(Private.classNames.rubberband)).removeClass(this.prefixClassName(Private.classNames.selected));\n  }\n\n  showRubberband() {\n    this.$container.addClass(this.prefixClassName(Private.classNames.rubberband));\n  }\n\n  hideRubberband() {\n    this.$container.removeClass(this.prefixClassName(Private.classNames.rubberband));\n  }\n\n  showSelected() {\n    this.$container.removeAttr('style').addClass(this.prefixClassName(Private.classNames.selected));\n  }\n\n  createContainer() {\n    this.container = document.createElement('div');\n    this.$container = this.$(this.container);\n    this.$container.addClass(this.prefixClassName(Private.classNames.root));\n\n    if (this.options.className) {\n      this.$container.addClass(this.options.className);\n    }\n\n    this.$selectionContainer = this.$('<div/>').addClass(this.prefixClassName(Private.classNames.inner));\n    this.$selectionContent = this.$('<div/>').addClass(this.prefixClassName(Private.classNames.content));\n    this.$selectionContainer.append(this.$selectionContent);\n    this.$selectionContainer.attr('data-selection-length', this.collection.length);\n    this.$container.prepend(this.$selectionContainer);\n    this.$handleContainer = this.$selectionContainer;\n  }\n\n  updateContainerPosition(offset) {\n    if (offset.dx || offset.dy) {\n      this.$selectionContainer.css({\n        left: `+=${offset.dx}`,\n        top: `+=${offset.dy}`\n      });\n    }\n  }\n\n  updateContainer() {\n    const origin = {\n      x: Infinity,\n      y: Infinity\n    };\n    const corner = {\n      x: 0,\n      y: 0\n    };\n    const cells = this.collection.toArray().filter(cell => this.canShowSelectionBox(cell));\n    cells.forEach(cell => {\n      const view = this.graph.renderer.findViewByCell(cell);\n\n      if (view) {\n        const bbox = view.getBBox({\n          useCellGeometry: this.options.useCellGeometry\n        });\n        origin.x = Math.min(origin.x, bbox.x);\n        origin.y = Math.min(origin.y, bbox.y);\n        corner.x = Math.max(corner.x, bbox.x + bbox.width);\n        corner.y = Math.max(corner.y, bbox.y + bbox.height);\n      }\n    });\n    this.$selectionContainer.css({\n      position: 'absolute',\n      pointerEvents: 'none',\n      left: origin.x,\n      top: origin.y,\n      width: corner.x - origin.x,\n      height: corner.y - origin.y\n    }).attr('data-selection-length', this.collection.length);\n    const boxContent = this.options.content;\n\n    if (boxContent) {\n      if (typeof boxContent === 'function') {\n        const content = FunctionExt.call(boxContent, this.graph, this, this.$selectionContent[0]);\n\n        if (content) {\n          this.$selectionContent.html(content);\n        }\n      } else {\n        this.$selectionContent.html(boxContent);\n      }\n    }\n\n    if (this.collection.length > 0 && !this.container.parentNode) {\n      this.$container.appendTo(this.graph.container);\n    } else if (this.collection.length <= 0 && this.container.parentNode) {\n      this.container.parentNode.removeChild(this.container);\n    }\n  }\n\n  canShowSelectionBox(cell) {\n    return cell.isNode() && this.options.showNodeSelectionBox === true || cell.isEdge() && this.options.showEdgeSelectionBox === true;\n  }\n\n  createSelectionBox(cell) {\n    this.addCellSelectedClassName(cell);\n\n    if (this.canShowSelectionBox(cell)) {\n      const view = this.graph.renderer.findViewByCell(cell);\n\n      if (view) {\n        const bbox = view.getBBox({\n          useCellGeometry: this.options.useCellGeometry\n        });\n        const className = this.boxClassName;\n        this.$('<div/>').addClass(className).addClass(`${className}-${cell.isNode() ? 'node' : 'edge'}`).attr('data-cell-id', cell.id).css({\n          position: 'absolute',\n          left: bbox.x,\n          top: bbox.y,\n          width: bbox.width,\n          height: bbox.height,\n          pointerEvents: this.options.pointerEvents || 'auto'\n        }).appendTo(this.container);\n        this.showSelected();\n        this.boxCount += 1;\n      }\n    }\n  }\n\n  updateSelectionBoxes() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    if (this.collection.length > 0) {\n      this.boxesUpdated = true;\n      this.graph.renderer.requestViewUpdate(this, 1, 2, options);\n    }\n  }\n\n  confirmUpdate() {\n    if (this.boxCount) {\n      this.hide();\n      this.$boxes.each((_, elem) => {\n        const cellId = this.$(elem).remove().attr('data-cell-id');\n        const cell = this.collection.get(cellId);\n\n        if (cell) {\n          this.createSelectionBox(cell);\n        }\n      });\n      this.updateContainer();\n    }\n\n    return 0;\n  }\n\n  getCellViewFromElem(elem) {\n    const id = elem.getAttribute('data-cell-id');\n\n    if (id) {\n      const cell = this.collection.get(id);\n\n      if (cell) {\n        return this.graph.renderer.findViewByCell(cell);\n      }\n    }\n\n    return null;\n  }\n\n  onCellRemoved(_ref3) {\n    let {\n      cell\n    } = _ref3;\n    this.destroySelectionBox(cell);\n    this.updateContainer();\n  }\n\n  onReseted(_ref4) {\n    let {\n      previous,\n      current\n    } = _ref4;\n    this.destroyAllSelectionBoxes(previous);\n    current.forEach(cell => {\n      this.listenCellRemoveEvent(cell);\n      this.createSelectionBox(cell);\n    });\n    this.updateContainer();\n  }\n\n  onCellAdded(_ref5) {\n    let {\n      cell\n    } = _ref5;\n    // The collection do not known the cell was removed when cell was\n    // removed by interaction(such as, by \"delete\" shortcut), so we should\n    // manually listen to cell's remove evnet.\n    this.listenCellRemoveEvent(cell);\n    this.createSelectionBox(cell);\n    this.updateContainer();\n  }\n\n  listenCellRemoveEvent(cell) {\n    cell.off('removed', this.onCellRemoved, this);\n    cell.on('removed', this.onCellRemoved, this);\n  }\n\n  onCollectionUpdated(_ref6) {\n    let {\n      added,\n      removed,\n      options\n    } = _ref6;\n    added.forEach(cell => {\n      this.trigger('cell:selected', {\n        cell,\n        options\n      });\n      this.graph.trigger('cell:selected', {\n        cell,\n        options\n      });\n\n      if (cell.isNode()) {\n        this.trigger('node:selected', {\n          cell,\n          options,\n          node: cell\n        });\n        this.graph.trigger('node:selected', {\n          cell,\n          options,\n          node: cell\n        });\n      } else if (cell.isEdge()) {\n        this.trigger('edge:selected', {\n          cell,\n          options,\n          edge: cell\n        });\n        this.graph.trigger('edge:selected', {\n          cell,\n          options,\n          edge: cell\n        });\n      }\n    });\n    removed.forEach(cell => {\n      this.trigger('cell:unselected', {\n        cell,\n        options\n      });\n      this.graph.trigger('cell:unselected', {\n        cell,\n        options\n      });\n\n      if (cell.isNode()) {\n        this.trigger('node:unselected', {\n          cell,\n          options,\n          node: cell\n        });\n        this.graph.trigger('node:unselected', {\n          cell,\n          options,\n          node: cell\n        });\n      } else if (cell.isEdge()) {\n        this.trigger('edge:unselected', {\n          cell,\n          options,\n          edge: cell\n        });\n        this.graph.trigger('edge:unselected', {\n          cell,\n          options,\n          edge: cell\n        });\n      }\n    });\n    const args = {\n      added,\n      removed,\n      options,\n      selected: this.cells\n    };\n    this.trigger('selection:changed', args);\n    this.graph.trigger('selection:changed', args);\n  } // #region handle\n\n\n  deleteSelectedCells() {\n    const cells = this.collection.toArray();\n    this.clean();\n    this.graph.model.removeCells(cells, {\n      selection: this.cid\n    });\n  }\n\n  startRotate(_ref7) {\n    let {\n      e\n    } = _ref7;\n    const cells = this.collection.toArray();\n    const center = Cell.getCellsBBox(cells).getCenter();\n    const client = this.graph.snapToGrid(e.clientX, e.clientY);\n    const angles = cells.reduce((memo, cell) => {\n      memo[cell.id] = Angle.normalize(cell.getAngle());\n      return memo;\n    }, {});\n    this.setEventData(e, {\n      center,\n      angles,\n      start: client.theta(center)\n    });\n  }\n\n  doRotate(_ref8) {\n    let {\n      e\n    } = _ref8;\n    const data = this.getEventData(e);\n    const grid = this.graph.options.rotating.grid;\n    const gridSize = typeof grid === 'function' ? FunctionExt.call(grid, this.graph, null) : grid;\n    const client = this.graph.snapToGrid(e.clientX, e.clientY);\n    const delta = data.start - client.theta(data.center);\n\n    if (!data.rotated) {\n      data.rotated = true;\n    }\n\n    if (Math.abs(delta) > 0.001) {\n      this.collection.toArray().forEach(node => {\n        const angle = Util.snapToGrid(data.angles[node.id] + delta, gridSize || 15);\n        node.rotate(angle, {\n          absolute: true,\n          center: data.center,\n          selection: this.cid\n        });\n      });\n      this.updateSelectionBoxes();\n    }\n  }\n\n  stopRotate(_ref9) {\n    let {\n      e\n    } = _ref9;\n    const data = this.getEventData(e);\n\n    if (data.rotated) {\n      data.rotated = false;\n      this.collection.toArray().forEach(node => {\n        notify('node:rotated', e, this.graph.findViewByCell(node));\n      });\n    }\n  }\n\n  startResize(_ref10) {\n    let {\n      e\n    } = _ref10;\n    const gridSize = this.graph.getGridSize();\n    const cells = this.collection.toArray();\n    const bbox = Cell.getCellsBBox(cells);\n    const bboxes = cells.map(cell => cell.getBBox());\n    const maxWidth = bboxes.reduce((maxWidth, bbox) => {\n      return bbox.width < maxWidth ? bbox.width : maxWidth;\n    }, Infinity);\n    const maxHeight = bboxes.reduce((maxHeight, bbox) => {\n      return bbox.height < maxHeight ? bbox.height : maxHeight;\n    }, Infinity);\n    this.setEventData(e, {\n      bbox,\n      cells: this.graph.model.getSubGraph(cells),\n      minWidth: gridSize * bbox.width / maxWidth,\n      minHeight: gridSize * bbox.height / maxHeight\n    });\n  }\n\n  doResize(_ref11) {\n    let {\n      e,\n      dx,\n      dy\n    } = _ref11;\n    const data = this.eventData(e);\n    const bbox = data.bbox;\n    const width = bbox.width;\n    const height = bbox.height;\n    const newWidth = Math.max(width + dx, data.minWidth);\n    const newHeight = Math.max(height + dy, data.minHeight);\n\n    if (!data.resized) {\n      data.resized = true;\n    }\n\n    if (Math.abs(width - newWidth) > 0.001 || Math.abs(height - newHeight) > 0.001) {\n      this.graph.model.resizeCells(newWidth, newHeight, data.cells, {\n        selection: this.cid\n      });\n      bbox.width = newWidth;\n      bbox.height = newHeight;\n      this.updateSelectionBoxes();\n    }\n  }\n\n  stopResize(_ref12) {\n    let {\n      e\n    } = _ref12;\n    const data = this.eventData(e);\n\n    if (data.resized) {\n      data.resized = false;\n      this.collection.toArray().forEach(node => {\n        notify('node:resized', e, this.graph.findViewByCell(node));\n      });\n    }\n  } // #endregion\n\n\n  dispose() {\n    this.clean();\n    this.remove();\n  }\n\n}\n\n__decorate([View.dispose()], Selection.prototype, \"dispose\", null);\n\nObjectExt.applyMixins(Selection, Handle); // private\n// -------\n\nvar Private;\n\n(function (Private) {\n  const base = 'widget-selection';\n  Private.classNames = {\n    root: base,\n    inner: `${base}-inner`,\n    box: `${base}-box`,\n    content: `${base}-content`,\n    rubberband: `${base}-rubberband`,\n    selected: `${base}-selected`\n  };\n  Private.documentEvents = {\n    mousemove: 'adjustSelection',\n    touchmove: 'adjustSelection',\n    mouseup: 'onMouseUp',\n    touchend: 'onMouseUp',\n    touchcancel: 'onMouseUp'\n  };\n  Private.defaultOptions = {\n    movable: true,\n    following: true,\n    strict: false,\n    useCellGeometry: false,\n\n    content(selection) {\n      return StringExt.template('<%= length %> node<%= length > 1 ? \"s\":\"\" %> selected.')({\n        length: selection.length\n      });\n    },\n\n    handles: [{\n      name: 'remove',\n      position: 'nw',\n      events: {\n        mousedown: 'deleteSelectedCells'\n      }\n    }, {\n      name: 'rotate',\n      position: 'sw',\n      events: {\n        mousedown: 'startRotate',\n        mousemove: 'doRotate',\n        mouseup: 'stopRotate'\n      }\n    }, {\n      name: 'resize',\n      position: 'se',\n      events: {\n        mousedown: 'startResize',\n        mousemove: 'doResize',\n        mouseup: 'stopResize'\n      }\n    }]\n  };\n\n  function depthComparator(cell) {\n    return cell.getAncestors().length;\n  }\n\n  Private.depthComparator = depthComparator;\n})(Private || (Private = {}));","map":{"version":3,"sources":["../../../src/addon/selection/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Util } from '../../global';\nimport { Rectangle, Angle } from '../../geometry';\nimport { ObjectExt, StringExt, FunctionExt } from '../../util';\nimport { Cell } from '../../model/cell';\nimport { Collection } from '../../model/collection';\nimport { View } from '../../view/view';\nimport { notify } from '../transform/util';\nimport { Handle } from '../common';\nexport class Selection extends View {\n    constructor(options) {\n        super();\n        this.options = ObjectExt.merge({}, Private.defaultOptions, options);\n        if (this.options.model) {\n            this.options.collection = this.options.model.collection;\n        }\n        if (this.options.collection) {\n            this.collection = this.options.collection;\n        }\n        else {\n            this.collection = new Collection([], {\n                comparator: Private.depthComparator,\n            });\n            this.options.collection = this.collection;\n        }\n        this.boxCount = 0;\n        this.createContainer();\n        this.initHandles();\n        this.startListening();\n    }\n    get graph() {\n        return this.options.graph;\n    }\n    get boxClassName() {\n        return this.prefixClassName(Private.classNames.box);\n    }\n    get $boxes() {\n        return this.$container.children(`.${this.boxClassName}`);\n    }\n    get handleOptions() {\n        return this.options;\n    }\n    startListening() {\n        const graph = this.graph;\n        const collection = this.collection;\n        this.delegateEvents({\n            [`mousedown .${this.boxClassName}`]: 'onSelectionBoxMouseDown',\n            [`touchstart .${this.boxClassName}`]: 'onSelectionBoxMouseDown',\n        }, true);\n        graph.on('scale', this.onGraphTransformed, this);\n        graph.on('translate', this.onGraphTransformed, this);\n        graph.model.on('updated', this.onModelUpdated, this);\n        collection.on('added', this.onCellAdded, this);\n        collection.on('removed', this.onCellRemoved, this);\n        collection.on('reseted', this.onReseted, this);\n        collection.on('updated', this.onCollectionUpdated, this);\n        collection.on('node:change:position', this.onNodePositionChanged, this);\n        collection.on('cell:changed', this.onCellChanged, this);\n    }\n    stopListening() {\n        const graph = this.graph;\n        const collection = this.collection;\n        this.undelegateEvents();\n        graph.off('scale', this.onGraphTransformed, this);\n        graph.off('translate', this.onGraphTransformed, this);\n        graph.model.off('updated', this.onModelUpdated, this);\n        collection.off('added', this.onCellAdded, this);\n        collection.off('removed', this.onCellRemoved, this);\n        collection.off('reseted', this.onReseted, this);\n        collection.off('updated', this.onCollectionUpdated, this);\n        collection.off('node:change:position', this.onNodePositionChanged, this);\n        collection.off('cell:changed', this.onCellChanged, this);\n    }\n    onRemove() {\n        this.stopListening();\n    }\n    onGraphTransformed() {\n        this.updateSelectionBoxes({ async: false });\n    }\n    onCellChanged() {\n        this.updateSelectionBoxes();\n    }\n    onNodePositionChanged({ node, options, }) {\n        const { showNodeSelectionBox, pointerEvents } = this.options;\n        const { ui, selection } = options;\n        let allowTranslating = !this.translating;\n        /* Scenarios where this method is not called:\n         * 1. ShowNodeSelection is true or ponterEvents is none\n         * 2. Avoid circular calls with the selection tag\n         */\n        allowTranslating =\n            allowTranslating &&\n                (showNodeSelectionBox !== true || pointerEvents === 'none');\n        allowTranslating = allowTranslating && ui && !selection;\n        if (allowTranslating) {\n            this.translating = true;\n            const current = node.position();\n            const previous = node.previous('position');\n            const dx = current.x - previous.x;\n            const dy = current.y - previous.y;\n            if (dx !== 0 || dy !== 0) {\n                this.translateSelectedNodes(dx, dy, node, options);\n            }\n            this.translating = false;\n        }\n    }\n    onModelUpdated({ removed }) {\n        if (removed && removed.length) {\n            this.unselect(removed);\n        }\n    }\n    isEmpty() {\n        return this.length <= 0;\n    }\n    isSelected(cell) {\n        return this.collection.has(cell);\n    }\n    get length() {\n        return this.collection.length;\n    }\n    get cells() {\n        return this.collection.toArray();\n    }\n    select(cells, options = {}) {\n        options.dryrun = true;\n        const items = this.filter(Array.isArray(cells) ? cells : [cells]);\n        this.collection.add(items, options);\n        return this;\n    }\n    unselect(cells, options = {}) {\n        // dryrun to prevent cell be removed from graph\n        options.dryrun = true;\n        this.collection.remove(Array.isArray(cells) ? cells : [cells], options);\n        return this;\n    }\n    reset(cells, options = {}) {\n        if (cells) {\n            if (options.batch) {\n                const filterCells = this.filter(Array.isArray(cells) ? cells : [cells]);\n                this.collection.reset(filterCells, Object.assign(Object.assign({}, options), { ui: true }));\n                return this;\n            }\n            const prev = this.cells;\n            const next = this.filter(Array.isArray(cells) ? cells : [cells]);\n            const prevMap = {};\n            const nextMap = {};\n            prev.forEach((cell) => (prevMap[cell.id] = cell));\n            next.forEach((cell) => (nextMap[cell.id] = cell));\n            const added = [];\n            const removed = [];\n            next.forEach((cell) => {\n                if (!prevMap[cell.id]) {\n                    added.push(cell);\n                }\n            });\n            prev.forEach((cell) => {\n                if (!nextMap[cell.id]) {\n                    removed.push(cell);\n                }\n            });\n            if (removed.length) {\n                this.unselect(removed, Object.assign(Object.assign({}, options), { ui: true }));\n            }\n            if (added.length) {\n                this.select(added, Object.assign(Object.assign({}, options), { ui: true }));\n            }\n            if (removed.length === 0 && added.length === 0) {\n                this.updateContainer();\n            }\n            return this;\n        }\n        return this.clean(options);\n    }\n    clean(options = {}) {\n        if (this.length) {\n            if (options.batch === false) {\n                this.unselect(this.cells, options);\n            }\n            else {\n                this.collection.reset([], Object.assign(Object.assign({}, options), { ui: true }));\n            }\n        }\n        return this;\n    }\n    setFilter(filter) {\n        this.options.filter = filter;\n    }\n    setContent(content) {\n        this.options.content = content;\n    }\n    startSelecting(evt) {\n        // Flow: startSelecting => adjustSelection => stopSelecting\n        evt = this.normalizeEvent(evt); // eslint-disable-line\n        this.clean();\n        let x;\n        let y;\n        const graphContainer = this.graph.container;\n        if (evt.offsetX != null &&\n            evt.offsetY != null &&\n            graphContainer.contains(evt.target)) {\n            x = evt.offsetX;\n            y = evt.offsetY;\n        }\n        else {\n            const offset = this.$(graphContainer).offset();\n            const scrollLeft = graphContainer.scrollLeft;\n            const scrollTop = graphContainer.scrollTop;\n            x = evt.clientX - offset.left + window.pageXOffset + scrollLeft;\n            y = evt.clientY - offset.top + window.pageYOffset + scrollTop;\n        }\n        this.$container.css({\n            top: y,\n            left: x,\n            width: 1,\n            height: 1,\n        });\n        this.setEventData(evt, {\n            action: 'selecting',\n            clientX: evt.clientX,\n            clientY: evt.clientY,\n            offsetX: x,\n            offsetY: y,\n            scrollerX: 0,\n            scrollerY: 0,\n        });\n        this.delegateDocumentEvents(Private.documentEvents, evt.data);\n    }\n    filter(cells) {\n        const filter = this.options.filter;\n        if (Array.isArray(filter)) {\n            return cells.filter((cell) => !filter.includes(cell) && !filter.includes(cell.shape));\n        }\n        if (typeof filter === 'function') {\n            return cells.filter((cell) => FunctionExt.call(filter, this.graph, cell));\n        }\n        return cells;\n    }\n    stopSelecting(evt) {\n        const graph = this.graph;\n        const eventData = this.getEventData(evt);\n        const action = eventData.action;\n        switch (action) {\n            case 'selecting': {\n                let width = this.$container.width();\n                let height = this.$container.height();\n                const offset = this.$container.offset();\n                const origin = graph.pageToLocal(offset.left, offset.top);\n                const scale = graph.transform.getScale();\n                width /= scale.sx;\n                height /= scale.sy;\n                const rect = new Rectangle(origin.x, origin.y, width, height);\n                const cells = this.getCellViewsInArea(rect).map((view) => view.cell);\n                this.reset(cells, { batch: true });\n                this.hideRubberband();\n                break;\n            }\n            case 'translating': {\n                const client = graph.snapToGrid(evt.clientX, evt.clientY);\n                if (!this.options.following) {\n                    const data = eventData;\n                    this.updateSelectedNodesPosition({\n                        dx: data.clientX - data.originX,\n                        dy: data.clientY - data.originY,\n                    });\n                }\n                this.graph.model.stopBatch('move-selection');\n                this.notifyBoxEvent('box:mouseup', evt, client.x, client.y);\n                break;\n            }\n            default: {\n                this.clean();\n                break;\n            }\n        }\n    }\n    onMouseUp(evt) {\n        const action = this.getEventData(evt).action;\n        if (action) {\n            this.stopSelecting(evt);\n            this.undelegateDocumentEvents();\n        }\n    }\n    onSelectionBoxMouseDown(evt) {\n        if (!this.options.following) {\n            evt.stopPropagation();\n        }\n        const e = this.normalizeEvent(evt);\n        if (this.options.movable) {\n            this.startTranslating(e);\n        }\n        const activeView = this.getCellViewFromElem(e.target);\n        this.setEventData(e, { activeView });\n        const client = this.graph.snapToGrid(e.clientX, e.clientY);\n        this.notifyBoxEvent('box:mousedown', e, client.x, client.y);\n        this.delegateDocumentEvents(Private.documentEvents, e.data);\n    }\n    startTranslating(evt) {\n        this.graph.model.startBatch('move-selection');\n        const client = this.graph.snapToGrid(evt.clientX, evt.clientY);\n        this.setEventData(evt, {\n            action: 'translating',\n            clientX: client.x,\n            clientY: client.y,\n            originX: client.x,\n            originY: client.y,\n        });\n    }\n    getSelectionOffset(client, data) {\n        let dx = client.x - data.clientX;\n        let dy = client.y - data.clientY;\n        const restrict = this.graph.hook.getRestrictArea();\n        if (restrict) {\n            const cells = this.collection.toArray();\n            const totalBBox = Cell.getCellsBBox(cells, { deep: true }) || Rectangle.create();\n            const minDx = restrict.x - totalBBox.x;\n            const minDy = restrict.y - totalBBox.y;\n            const maxDx = restrict.x + restrict.width - (totalBBox.x + totalBBox.width);\n            const maxDy = restrict.y + restrict.height - (totalBBox.y + totalBBox.height);\n            if (dx < minDx) {\n                dx = minDx;\n            }\n            if (dy < minDy) {\n                dy = minDy;\n            }\n            if (maxDx < dx) {\n                dx = maxDx;\n            }\n            if (maxDy < dy) {\n                dy = maxDy;\n            }\n            if (!this.options.following) {\n                const offsetX = client.x - data.originX;\n                const offsetY = client.y - data.originY;\n                dx = offsetX <= minDx || offsetX >= maxDx ? 0 : dx;\n                dy = offsetY <= minDy || offsetY >= maxDy ? 0 : dy;\n            }\n        }\n        return {\n            dx,\n            dy,\n        };\n    }\n    updateSelectedNodesPosition(offset) {\n        const { dx, dy } = offset;\n        if (dx || dy) {\n            if ((this.translateSelectedNodes(dx, dy), this.boxesUpdated)) {\n                if (this.collection.length > 1) {\n                    this.updateSelectionBoxes();\n                }\n            }\n            else {\n                const scale = this.graph.transform.getScale();\n                this.$boxes.add(this.$selectionContainer).css({\n                    left: `+=${dx * scale.sx}`,\n                    top: `+=${dy * scale.sy}`,\n                });\n            }\n        }\n    }\n    autoScrollGraph(x, y) {\n        const scroller = this.graph.scroller.widget;\n        if (scroller) {\n            return scroller.autoScroll(x, y);\n        }\n        return { scrollerX: 0, scrollerY: 0 };\n    }\n    adjustSelection(evt) {\n        const e = this.normalizeEvent(evt);\n        const eventData = this.getEventData(e);\n        const action = eventData.action;\n        switch (action) {\n            case 'selecting': {\n                const data = eventData;\n                if (data.moving !== true) {\n                    this.$container.appendTo(this.graph.container);\n                    this.showRubberband();\n                    data.moving = true;\n                }\n                const { scrollerX, scrollerY } = this.autoScrollGraph(e.clientX, e.clientY);\n                data.scrollerX += scrollerX;\n                data.scrollerY += scrollerY;\n                const dx = e.clientX - data.clientX + data.scrollerX;\n                const dy = e.clientY - data.clientY + data.scrollerY;\n                const left = parseInt(this.$container.css('left'), 10);\n                const top = parseInt(this.$container.css('top'), 10);\n                this.$container.css({\n                    left: dx < 0 ? data.offsetX + dx : left,\n                    top: dy < 0 ? data.offsetY + dy : top,\n                    width: Math.abs(dx),\n                    height: Math.abs(dy),\n                });\n                break;\n            }\n            case 'translating': {\n                const client = this.graph.snapToGrid(e.clientX, e.clientY);\n                const data = eventData;\n                const offset = this.getSelectionOffset(client, data);\n                if (this.options.following) {\n                    this.updateSelectedNodesPosition(offset);\n                }\n                else {\n                    this.updateContainerPosition(offset);\n                }\n                if (offset.dx) {\n                    data.clientX = client.x;\n                }\n                if (offset.dy) {\n                    data.clientY = client.y;\n                }\n                this.notifyBoxEvent('box:mousemove', evt, client.x, client.y);\n                break;\n            }\n            default:\n                break;\n        }\n        this.boxesUpdated = false;\n    }\n    translateSelectedNodes(dx, dy, exclude, otherOptions) {\n        const map = {};\n        const excluded = [];\n        if (exclude) {\n            map[exclude.id] = true;\n        }\n        this.collection.toArray().forEach((cell) => {\n            cell.getDescendants({ deep: true }).forEach((child) => {\n                map[child.id] = true;\n            });\n        });\n        if (otherOptions && otherOptions.translateBy) {\n            const currentCell = this.graph.getCellById(otherOptions.translateBy);\n            if (currentCell) {\n                map[currentCell.id] = true;\n                currentCell.getDescendants({ deep: true }).forEach((child) => {\n                    map[child.id] = true;\n                });\n                excluded.push(currentCell);\n            }\n        }\n        this.collection.toArray().forEach((cell) => {\n            if (!map[cell.id]) {\n                const options = Object.assign(Object.assign({}, otherOptions), { selection: this.cid, exclude: excluded });\n                cell.translate(dx, dy, options);\n                this.graph.model.getConnectedEdges(cell).forEach((edge) => {\n                    if (!map[edge.id]) {\n                        edge.translate(dx, dy, options);\n                        map[edge.id] = true;\n                    }\n                });\n            }\n        });\n    }\n    getCellViewsInArea(rect) {\n        const graph = this.graph;\n        const options = {\n            strict: this.options.strict,\n        };\n        let views = [];\n        if (this.options.rubberNode) {\n            if (this.options.useCellGeometry) {\n                views = views.concat(graph.model\n                    .getNodesInArea(rect, options)\n                    .map((node) => graph.renderer.findViewByCell(node))\n                    .filter((view) => view != null));\n            }\n            else {\n                views = views.concat(graph.renderer.findViewsInArea(rect, options));\n            }\n        }\n        if (this.options.rubberEdge) {\n            if (this.options.useCellGeometry) {\n                views = views.concat(graph.model\n                    .getEdgesInArea(rect, options)\n                    .map((edge) => graph.renderer.findViewByCell(edge))\n                    .filter((view) => view != null));\n            }\n            else {\n                views = views.concat(graph.renderer.findEdgeViewsInArea(rect, options));\n            }\n        }\n        return views;\n    }\n    notifyBoxEvent(name, e, x, y) {\n        const data = this.getEventData(e);\n        const view = data.activeView;\n        this.trigger(name, { e, view, x, y, cell: view.cell });\n    }\n    getSelectedClassName(cell) {\n        return this.prefixClassName(`${cell.isNode() ? 'node' : 'edge'}-selected`);\n    }\n    addCellSelectedClassName(cell) {\n        const view = this.graph.renderer.findViewByCell(cell);\n        if (view) {\n            view.addClass(this.getSelectedClassName(cell));\n        }\n    }\n    removeCellUnSelectedClassName(cell) {\n        const view = this.graph.renderer.findViewByCell(cell);\n        if (view) {\n            view.removeClass(this.getSelectedClassName(cell));\n        }\n    }\n    destroySelectionBox(cell) {\n        this.removeCellUnSelectedClassName(cell);\n        if (this.canShowSelectionBox(cell)) {\n            this.$container.find(`[data-cell-id=\"${cell.id}\"]`).remove();\n            if (this.$boxes.length === 0) {\n                this.hide();\n            }\n            this.boxCount = Math.max(0, this.boxCount - 1);\n        }\n    }\n    destroyAllSelectionBoxes(cells) {\n        cells.forEach((cell) => this.removeCellUnSelectedClassName(cell));\n        this.hide();\n        this.$boxes.remove();\n        this.boxCount = 0;\n    }\n    hide() {\n        this.$container\n            .removeClass(this.prefixClassName(Private.classNames.rubberband))\n            .removeClass(this.prefixClassName(Private.classNames.selected));\n    }\n    showRubberband() {\n        this.$container.addClass(this.prefixClassName(Private.classNames.rubberband));\n    }\n    hideRubberband() {\n        this.$container.removeClass(this.prefixClassName(Private.classNames.rubberband));\n    }\n    showSelected() {\n        this.$container\n            .removeAttr('style')\n            .addClass(this.prefixClassName(Private.classNames.selected));\n    }\n    createContainer() {\n        this.container = document.createElement('div');\n        this.$container = this.$(this.container);\n        this.$container.addClass(this.prefixClassName(Private.classNames.root));\n        if (this.options.className) {\n            this.$container.addClass(this.options.className);\n        }\n        this.$selectionContainer = this.$('<div/>').addClass(this.prefixClassName(Private.classNames.inner));\n        this.$selectionContent = this.$('<div/>').addClass(this.prefixClassName(Private.classNames.content));\n        this.$selectionContainer.append(this.$selectionContent);\n        this.$selectionContainer.attr('data-selection-length', this.collection.length);\n        this.$container.prepend(this.$selectionContainer);\n        this.$handleContainer = this.$selectionContainer;\n    }\n    updateContainerPosition(offset) {\n        if (offset.dx || offset.dy) {\n            this.$selectionContainer.css({\n                left: `+=${offset.dx}`,\n                top: `+=${offset.dy}`,\n            });\n        }\n    }\n    updateContainer() {\n        const origin = { x: Infinity, y: Infinity };\n        const corner = { x: 0, y: 0 };\n        const cells = this.collection\n            .toArray()\n            .filter((cell) => this.canShowSelectionBox(cell));\n        cells.forEach((cell) => {\n            const view = this.graph.renderer.findViewByCell(cell);\n            if (view) {\n                const bbox = view.getBBox({\n                    useCellGeometry: this.options.useCellGeometry,\n                });\n                origin.x = Math.min(origin.x, bbox.x);\n                origin.y = Math.min(origin.y, bbox.y);\n                corner.x = Math.max(corner.x, bbox.x + bbox.width);\n                corner.y = Math.max(corner.y, bbox.y + bbox.height);\n            }\n        });\n        this.$selectionContainer\n            .css({\n            position: 'absolute',\n            pointerEvents: 'none',\n            left: origin.x,\n            top: origin.y,\n            width: corner.x - origin.x,\n            height: corner.y - origin.y,\n        })\n            .attr('data-selection-length', this.collection.length);\n        const boxContent = this.options.content;\n        if (boxContent) {\n            if (typeof boxContent === 'function') {\n                const content = FunctionExt.call(boxContent, this.graph, this, this.$selectionContent[0]);\n                if (content) {\n                    this.$selectionContent.html(content);\n                }\n            }\n            else {\n                this.$selectionContent.html(boxContent);\n            }\n        }\n        if (this.collection.length > 0 && !this.container.parentNode) {\n            this.$container.appendTo(this.graph.container);\n        }\n        else if (this.collection.length <= 0 && this.container.parentNode) {\n            this.container.parentNode.removeChild(this.container);\n        }\n    }\n    canShowSelectionBox(cell) {\n        return ((cell.isNode() && this.options.showNodeSelectionBox === true) ||\n            (cell.isEdge() && this.options.showEdgeSelectionBox === true));\n    }\n    createSelectionBox(cell) {\n        this.addCellSelectedClassName(cell);\n        if (this.canShowSelectionBox(cell)) {\n            const view = this.graph.renderer.findViewByCell(cell);\n            if (view) {\n                const bbox = view.getBBox({\n                    useCellGeometry: this.options.useCellGeometry,\n                });\n                const className = this.boxClassName;\n                this.$('<div/>')\n                    .addClass(className)\n                    .addClass(`${className}-${cell.isNode() ? 'node' : 'edge'}`)\n                    .attr('data-cell-id', cell.id)\n                    .css({\n                    position: 'absolute',\n                    left: bbox.x,\n                    top: bbox.y,\n                    width: bbox.width,\n                    height: bbox.height,\n                    pointerEvents: this.options.pointerEvents || 'auto',\n                })\n                    .appendTo(this.container);\n                this.showSelected();\n                this.boxCount += 1;\n            }\n        }\n    }\n    updateSelectionBoxes(options = {}) {\n        if (this.collection.length > 0) {\n            this.boxesUpdated = true;\n            this.graph.renderer.requestViewUpdate(this, 1, 2, options);\n        }\n    }\n    confirmUpdate() {\n        if (this.boxCount) {\n            this.hide();\n            this.$boxes.each((_, elem) => {\n                const cellId = this.$(elem).remove().attr('data-cell-id');\n                const cell = this.collection.get(cellId);\n                if (cell) {\n                    this.createSelectionBox(cell);\n                }\n            });\n            this.updateContainer();\n        }\n        return 0;\n    }\n    getCellViewFromElem(elem) {\n        const id = elem.getAttribute('data-cell-id');\n        if (id) {\n            const cell = this.collection.get(id);\n            if (cell) {\n                return this.graph.renderer.findViewByCell(cell);\n            }\n        }\n        return null;\n    }\n    onCellRemoved({ cell }) {\n        this.destroySelectionBox(cell);\n        this.updateContainer();\n    }\n    onReseted({ previous, current }) {\n        this.destroyAllSelectionBoxes(previous);\n        current.forEach((cell) => {\n            this.listenCellRemoveEvent(cell);\n            this.createSelectionBox(cell);\n        });\n        this.updateContainer();\n    }\n    onCellAdded({ cell }) {\n        // The collection do not known the cell was removed when cell was\n        // removed by interaction(such as, by \"delete\" shortcut), so we should\n        // manually listen to cell's remove evnet.\n        this.listenCellRemoveEvent(cell);\n        this.createSelectionBox(cell);\n        this.updateContainer();\n    }\n    listenCellRemoveEvent(cell) {\n        cell.off('removed', this.onCellRemoved, this);\n        cell.on('removed', this.onCellRemoved, this);\n    }\n    onCollectionUpdated({ added, removed, options, }) {\n        added.forEach((cell) => {\n            this.trigger('cell:selected', { cell, options });\n            this.graph.trigger('cell:selected', { cell, options });\n            if (cell.isNode()) {\n                this.trigger('node:selected', { cell, options, node: cell });\n                this.graph.trigger('node:selected', { cell, options, node: cell });\n            }\n            else if (cell.isEdge()) {\n                this.trigger('edge:selected', { cell, options, edge: cell });\n                this.graph.trigger('edge:selected', { cell, options, edge: cell });\n            }\n        });\n        removed.forEach((cell) => {\n            this.trigger('cell:unselected', { cell, options });\n            this.graph.trigger('cell:unselected', { cell, options });\n            if (cell.isNode()) {\n                this.trigger('node:unselected', { cell, options, node: cell });\n                this.graph.trigger('node:unselected', { cell, options, node: cell });\n            }\n            else if (cell.isEdge()) {\n                this.trigger('edge:unselected', { cell, options, edge: cell });\n                this.graph.trigger('edge:unselected', { cell, options, edge: cell });\n            }\n        });\n        const args = {\n            added,\n            removed,\n            options,\n            selected: this.cells,\n        };\n        this.trigger('selection:changed', args);\n        this.graph.trigger('selection:changed', args);\n    }\n    // #region handle\n    deleteSelectedCells() {\n        const cells = this.collection.toArray();\n        this.clean();\n        this.graph.model.removeCells(cells, { selection: this.cid });\n    }\n    startRotate({ e }) {\n        const cells = this.collection.toArray();\n        const center = Cell.getCellsBBox(cells).getCenter();\n        const client = this.graph.snapToGrid(e.clientX, e.clientY);\n        const angles = cells.reduce((memo, cell) => {\n            memo[cell.id] = Angle.normalize(cell.getAngle());\n            return memo;\n        }, {});\n        this.setEventData(e, {\n            center,\n            angles,\n            start: client.theta(center),\n        });\n    }\n    doRotate({ e }) {\n        const data = this.getEventData(e);\n        const grid = this.graph.options.rotating.grid;\n        const gridSize = typeof grid === 'function'\n            ? FunctionExt.call(grid, this.graph, null)\n            : grid;\n        const client = this.graph.snapToGrid(e.clientX, e.clientY);\n        const delta = data.start - client.theta(data.center);\n        if (!data.rotated) {\n            data.rotated = true;\n        }\n        if (Math.abs(delta) > 0.001) {\n            this.collection.toArray().forEach((node) => {\n                const angle = Util.snapToGrid(data.angles[node.id] + delta, gridSize || 15);\n                node.rotate(angle, {\n                    absolute: true,\n                    center: data.center,\n                    selection: this.cid,\n                });\n            });\n            this.updateSelectionBoxes();\n        }\n    }\n    stopRotate({ e }) {\n        const data = this.getEventData(e);\n        if (data.rotated) {\n            data.rotated = false;\n            this.collection.toArray().forEach((node) => {\n                notify('node:rotated', e, this.graph.findViewByCell(node));\n            });\n        }\n    }\n    startResize({ e }) {\n        const gridSize = this.graph.getGridSize();\n        const cells = this.collection.toArray();\n        const bbox = Cell.getCellsBBox(cells);\n        const bboxes = cells.map((cell) => cell.getBBox());\n        const maxWidth = bboxes.reduce((maxWidth, bbox) => {\n            return bbox.width < maxWidth ? bbox.width : maxWidth;\n        }, Infinity);\n        const maxHeight = bboxes.reduce((maxHeight, bbox) => {\n            return bbox.height < maxHeight ? bbox.height : maxHeight;\n        }, Infinity);\n        this.setEventData(e, {\n            bbox,\n            cells: this.graph.model.getSubGraph(cells),\n            minWidth: (gridSize * bbox.width) / maxWidth,\n            minHeight: (gridSize * bbox.height) / maxHeight,\n        });\n    }\n    doResize({ e, dx, dy }) {\n        const data = this.eventData(e);\n        const bbox = data.bbox;\n        const width = bbox.width;\n        const height = bbox.height;\n        const newWidth = Math.max(width + dx, data.minWidth);\n        const newHeight = Math.max(height + dy, data.minHeight);\n        if (!data.resized) {\n            data.resized = true;\n        }\n        if (Math.abs(width - newWidth) > 0.001 ||\n            Math.abs(height - newHeight) > 0.001) {\n            this.graph.model.resizeCells(newWidth, newHeight, data.cells, {\n                selection: this.cid,\n            });\n            bbox.width = newWidth;\n            bbox.height = newHeight;\n            this.updateSelectionBoxes();\n        }\n    }\n    stopResize({ e }) {\n        const data = this.eventData(e);\n        if (data.resized) {\n            data.resized = false;\n            this.collection.toArray().forEach((node) => {\n                notify('node:resized', e, this.graph.findViewByCell(node));\n            });\n        }\n    }\n    // #endregion\n    dispose() {\n        this.clean();\n        this.remove();\n    }\n}\n__decorate([\n    View.dispose()\n], Selection.prototype, \"dispose\", null);\nObjectExt.applyMixins(Selection, Handle);\n// private\n// -------\nvar Private;\n(function (Private) {\n    const base = 'widget-selection';\n    Private.classNames = {\n        root: base,\n        inner: `${base}-inner`,\n        box: `${base}-box`,\n        content: `${base}-content`,\n        rubberband: `${base}-rubberband`,\n        selected: `${base}-selected`,\n    };\n    Private.documentEvents = {\n        mousemove: 'adjustSelection',\n        touchmove: 'adjustSelection',\n        mouseup: 'onMouseUp',\n        touchend: 'onMouseUp',\n        touchcancel: 'onMouseUp',\n    };\n    Private.defaultOptions = {\n        movable: true,\n        following: true,\n        strict: false,\n        useCellGeometry: false,\n        content(selection) {\n            return StringExt.template('<%= length %> node<%= length > 1 ? \"s\":\"\" %> selected.')({ length: selection.length });\n        },\n        handles: [\n            {\n                name: 'remove',\n                position: 'nw',\n                events: {\n                    mousedown: 'deleteSelectedCells',\n                },\n            },\n            {\n                name: 'rotate',\n                position: 'sw',\n                events: {\n                    mousedown: 'startRotate',\n                    mousemove: 'doRotate',\n                    mouseup: 'stopRotate',\n                },\n            },\n            {\n                name: 'resize',\n                position: 'se',\n                events: {\n                    mousedown: 'startResize',\n                    mousemove: 'doResize',\n                    mouseup: 'stopResize',\n                },\n            },\n        ],\n    };\n    function depthComparator(cell) {\n        return cell.getAncestors().length;\n    }\n    Private.depthComparator = depthComparator;\n})(Private || (Private = {}));\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}