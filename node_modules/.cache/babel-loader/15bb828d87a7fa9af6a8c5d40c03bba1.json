{"ast":null,"code":"import { Graph, Path, Registry, Shape } from '@antv/x6';\nimport { EDGE_PATH_TYPE, XFLOW_SHAPE } from '../constants';\n\nif (!Registry.Connector.registry.exist(EDGE_PATH_TYPE.VERTICAL_NODE)) {\n  Graph.registerConnector(EDGE_PATH_TYPE.VERTICAL_NODE, function (s, e) {\n    var offset = 16;\n    var deltaY = Math.abs(e.y - s.y);\n    var control = Math.floor(deltaY / 3 * 2);\n    var v1 = {\n      x: s.x,\n      y: s.y + offset + control\n    };\n    var v2 = {\n      x: e.x,\n      y: e.y - offset - control\n    };\n    return Path.normalize(\"M \".concat(s.x, \" \").concat(s.y, \"\\n         L \").concat(s.x, \" \").concat(s.y + offset, \"\\n         C \").concat(v1.x, \" \").concat(v1.y, \" \").concat(v2.x, \" \").concat(v2.y, \" \").concat(e.x, \" \").concat(e.y - offset, \"\\n         L \").concat(e.x, \" \").concat(e.y, \"\\n        \"));\n  }, true);\n}\n\nif (!Registry.Connector.registry.exist(EDGE_PATH_TYPE.VERTICAL_GROUP)) {\n  Graph.registerConnector(EDGE_PATH_TYPE.VERTICAL_GROUP, function (s, t) {\n    var offset = 4;\n    var control = Math.abs(t.y - s.y);\n    var v1 = {\n      x: s.x,\n      y: s.y + offset + control\n    };\n    var v2 = {\n      x: t.x,\n      y: t.y - offset - control\n    };\n    return Path.normalize(\"M \".concat(s.x, \" \").concat(s.y, \"\\n       L \").concat(s.x, \" \").concat(s.y + offset, \"\\n       C \").concat(v1.x, \" \").concat(v1.y, \" \").concat(v2.x, \" \").concat(v2.y, \" \").concat(t.x, \" \").concat(t.y - offset, \"\\n       L \").concat(t.x, \" \").concat(t.y, \"\\n      \"));\n  }, true);\n} // TODO: fix this vertical function\n\n\nif (!Registry.Connector.registry.exist(EDGE_PATH_TYPE.HORIRONTAL_NODE)) {\n  Graph.registerConnector(EDGE_PATH_TYPE.HORIRONTAL_NODE, function (s, e) {\n    var offset = 4; // const control = 80;\n\n    var deltaY = Math.abs(e.y - s.y);\n    var control = Math.floor(deltaY / 3 * 2);\n    var v1 = {\n      x: s.x,\n      y: s.y + offset + control\n    };\n    var v2 = {\n      x: e.x,\n      y: e.y - offset - control\n    };\n    return Path.normalize(\"M \".concat(s.x, \" \").concat(s.y, \"\\n         L \").concat(s.x, \" \").concat(s.y + offset, \"\\n         C \").concat(v1.x, \" \").concat(v1.y, \" \").concat(v2.x, \" \").concat(v2.y, \" \").concat(e.x, \" \").concat(e.y - offset, \"\\n         L \").concat(e.x, \" \").concat(e.y, \"\\n        \"));\n  }, true);\n}\n\nvar XFlowEdge = Shape.Edge.registry.get(XFLOW_SHAPE.EDGE);\n\nif (!Shape.Edge.registry.exist(XFLOW_SHAPE.EDGE)) {\n  XFlowEdge = Shape.Edge.registry.register(XFLOW_SHAPE.EDGE, Shape.Edge.define({\n    zIndex: 1,\n    highlight: false,\n    connector: {\n      name: EDGE_PATH_TYPE.VERTICAL_NODE\n    },\n    shape: XFLOW_SHAPE.EDGE // https://x6.antv.vision/zh/docs/api/registry/node-anchor\n    // source: {\n    //   anchor: {\n    //     name: 'bottom',\n    //   },\n    // },\n    // target: {\n    //   anchor: {\n    //     name: 'center',\n    //   },\n    // },\n\n  }), true);\n}\n\nexport { EDGE_PATH_TYPE, XFlowEdge };","map":{"version":3,"sources":["../../../src/canvas-dag-extension/x6-extension/edge.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Graph, Path, Registry, Shape } from '@antv/x6';\nimport { EDGE_PATH_TYPE, XFLOW_SHAPE } from '../constants';\nif (!Registry.Connector.registry.exist(EDGE_PATH_TYPE.VERTICAL_NODE)) {\n    Graph.registerConnector(EDGE_PATH_TYPE.VERTICAL_NODE, (s, e) => {\n        const offset = 16;\n        const deltaY = Math.abs(e.y - s.y);\n        const control = Math.floor((deltaY / 3) * 2);\n        const v1 = { x: s.x, y: s.y + offset + control };\n        const v2 = { x: e.x, y: e.y - offset - control };\n        return Path.normalize(`M ${s.x} ${s.y}\n         L ${s.x} ${s.y + offset}\n         C ${v1.x} ${v1.y} ${v2.x} ${v2.y} ${e.x} ${e.y - offset}\n         L ${e.x} ${e.y}\n        `);\n    }, true);\n}\nif (!Registry.Connector.registry.exist(EDGE_PATH_TYPE.VERTICAL_GROUP)) {\n    Graph.registerConnector(EDGE_PATH_TYPE.VERTICAL_GROUP, (s, t) => {\n        const offset = 4;\n        const control = Math.abs(t.y - s.y);\n        const v1 = { x: s.x, y: s.y + offset + control };\n        const v2 = { x: t.x, y: t.y - offset - control };\n        return Path.normalize(`M ${s.x} ${s.y}\n       L ${s.x} ${s.y + offset}\n       C ${v1.x} ${v1.y} ${v2.x} ${v2.y} ${t.x} ${t.y - offset}\n       L ${t.x} ${t.y}\n      `);\n    }, true);\n}\n// TODO: fix this vertical function\nif (!Registry.Connector.registry.exist(EDGE_PATH_TYPE.HORIRONTAL_NODE)) {\n    Graph.registerConnector(EDGE_PATH_TYPE.HORIRONTAL_NODE, (s, e) => {\n        const offset = 4;\n        // const control = 80;\n        const deltaY = Math.abs(e.y - s.y);\n        const control = Math.floor((deltaY / 3) * 2);\n        const v1 = { x: s.x, y: s.y + offset + control };\n        const v2 = { x: e.x, y: e.y - offset - control };\n        return Path.normalize(`M ${s.x} ${s.y}\n         L ${s.x} ${s.y + offset}\n         C ${v1.x} ${v1.y} ${v2.x} ${v2.y} ${e.x} ${e.y - offset}\n         L ${e.x} ${e.y}\n        `);\n    }, true);\n}\nlet XFlowEdge = Shape.Edge.registry.get(XFLOW_SHAPE.EDGE);\nif (!Shape.Edge.registry.exist(XFLOW_SHAPE.EDGE)) {\n    XFlowEdge = Shape.Edge.registry.register(XFLOW_SHAPE.EDGE, Shape.Edge.define({\n        zIndex: 1,\n        highlight: false,\n        connector: { name: EDGE_PATH_TYPE.VERTICAL_NODE },\n        shape: XFLOW_SHAPE.EDGE,\n        // https://x6.antv.vision/zh/docs/api/registry/node-anchor\n        // source: {\n        //   anchor: {\n        //     name: 'bottom',\n        //   },\n        // },\n        // target: {\n        //   anchor: {\n        //     name: 'center',\n        //   },\n        // },\n    }), true);\n}\nexport { EDGE_PATH_TYPE, XFlowEdge };\n//# sourceMappingURL=edge.js.map"]},"metadata":{},"sourceType":"module"}