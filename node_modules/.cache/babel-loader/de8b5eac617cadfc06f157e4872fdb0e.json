{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\n  var it = typeof Symbol !== \"undefined\" && o[Symbol.iterator] || o[\"@@iterator\"];\n\n  if (!it) {\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \"number\") {\n      if (it) o = it;\n      var i = 0;\n\n      var F = function F() {};\n\n      return {\n        s: F,\n        n: function n() {\n          if (i >= o.length) return {\n            done: true\n          };\n          return {\n            done: false,\n            value: o[i++]\n          };\n        },\n        e: function e(_e) {\n          throw _e;\n        },\n        f: F\n      };\n    }\n\n    throw new TypeError(\"Invalid attempt to iterate non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n  }\n\n  var normalCompletion = true,\n      didErr = false,\n      err;\n  return {\n    s: function s() {\n      it = it.call(o);\n    },\n    n: function n() {\n      var step = it.next();\n      normalCompletion = step.done;\n      return step;\n    },\n    e: function e(_e2) {\n      didErr = true;\n      err = _e2;\n    },\n    f: function f() {\n      try {\n        if (!normalCompletion && it.return != null) it.return();\n      } finally {\n        if (didErr) throw err;\n      }\n    }\n  };\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nvar glyphSizeInSDF = 30;\nexport function buildMapping(_ref) {\n  var characterSet = _ref.characterSet,\n      getFontWidth = _ref.getFontWidth,\n      fontHeight = _ref.fontHeight,\n      buffer = _ref.buffer,\n      maxCanvasWidth = _ref.maxCanvasWidth,\n      _ref$mapping = _ref.mapping,\n      mapping = _ref$mapping === void 0 ? {} : _ref$mapping,\n      _ref$xOffset = _ref.xOffset,\n      xOffset = _ref$xOffset === void 0 ? 0 : _ref$xOffset,\n      _ref$yOffset = _ref.yOffset,\n      yOffset = _ref$yOffset === void 0 ? 0 : _ref$yOffset;\n  var row = 0;\n  var x = xOffset;\n  Array.from(characterSet).forEach(function (char, i) {\n    if (!mapping[char]) {\n      var width = getFontWidth(char, i);\n\n      if (x + glyphSizeInSDF > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n\n      mapping[char] = {\n        x: x,\n        y: yOffset + row * glyphSizeInSDF,\n        width: glyphSizeInSDF,\n        height: glyphSizeInSDF,\n        advance: width\n      };\n      x += glyphSizeInSDF;\n    }\n  });\n  var rowHeight = fontHeight + buffer * 2;\n  return {\n    mapping: mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight)\n  };\n}\nexport function buildIconMaping(icons, buffer, maxCanvasWidth) {\n  var xOffset = 0;\n  var yOffset = 0;\n  var rowHeight = 0;\n  var columns = [];\n  var mapping = {};\n\n  var _iterator = _createForOfIteratorHelper(icons),\n      _step;\n\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var icon = _step.value;\n\n      if (!mapping[icon.id]) {\n        var size = icon.size;\n\n        if (xOffset + size + buffer > maxCanvasWidth) {\n          buildRowMapping(mapping, columns, yOffset);\n          xOffset = 0;\n          yOffset = rowHeight + yOffset + buffer;\n          rowHeight = 0;\n          columns = [];\n        }\n\n        columns.push({\n          icon: icon,\n          xOffset: xOffset\n        });\n        xOffset = xOffset + size + buffer;\n        rowHeight = Math.max(rowHeight, size);\n      }\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  var canvasHeight = nextPowOfTwo(rowHeight + yOffset + buffer);\n  return {\n    mapping: mapping,\n    canvasHeight: canvasHeight\n  };\n}\n\nfunction buildRowMapping(mapping, columns, yOffset) {\n  var _iterator2 = _createForOfIteratorHelper(columns),\n      _step2;\n\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var column = _step2.value;\n      var icon = column.icon,\n          xOffset = column.xOffset;\n      mapping[icon.id] = _objectSpread(_objectSpread({}, icon), {}, {\n        x: xOffset,\n        y: yOffset,\n        image: icon.image,\n        width: icon.width,\n        height: icon.height\n      });\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n}\n\nexport function nextPowOfTwo(num) {\n  return Math.pow(2, Math.ceil(Math.log2(num)));\n}","map":{"version":3,"sources":["../../src/utils/font_util.ts"],"names":["glyphSizeInSDF","characterSet","getFontWidth","fontHeight","buffer","maxCanvasWidth","mapping","xOffset","yOffset","row","x","Array","width","y","height","advance","rowHeight","canvasHeight","nextPowOfTwo","columns","icon","size","buildRowMapping","Math","column","image"],"mappings":"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","sourcesContent":["import { IFontMappingOption } from '../services/asset/IFontService';\nimport { IIcon, IICONMap } from '../services/asset/IIconService';\n/**\n * tiny-sdf 中每个 glyph 的宽度（加上 buffer 24 + 3 + 3 = 30）\n */\nconst glyphSizeInSDF = 30;\nexport function buildMapping({\n  characterSet,\n  getFontWidth,\n  fontHeight,\n  buffer,\n  maxCanvasWidth,\n  mapping = {},\n  xOffset = 0,\n  yOffset = 0,\n}: IFontMappingOption) {\n  let row = 0;\n  let x = xOffset;\n  Array.from(characterSet).forEach((char: string, i: number) => {\n    if (!mapping[char]) {\n      const width = getFontWidth(char, i);\n      if (x + glyphSizeInSDF > maxCanvasWidth) {\n        x = 0;\n        row++;\n      }\n      mapping[char] = {\n        x,\n        y: yOffset + row * glyphSizeInSDF,\n        width: glyphSizeInSDF,\n        height: glyphSizeInSDF,\n        advance: width,\n      };\n      x += glyphSizeInSDF;\n    }\n  });\n\n  const rowHeight = fontHeight + buffer * 2;\n  return {\n    mapping,\n    xOffset: x,\n    yOffset: yOffset + row * rowHeight,\n    canvasHeight: nextPowOfTwo(yOffset + (row + 1) * rowHeight),\n  };\n}\n\nexport function buildIconMaping(\n  icons: IIcon[],\n  buffer: number,\n  maxCanvasWidth: number,\n) {\n  let xOffset = 0;\n  let yOffset = 0;\n  let rowHeight = 0;\n  let columns = [];\n  const mapping: IICONMap = {};\n  for (const icon of icons) {\n    if (!mapping[icon.id]) {\n      const { size } = icon;\n\n      // fill one row\n      if (xOffset + size + buffer > maxCanvasWidth) {\n        buildRowMapping(mapping, columns, yOffset);\n\n        xOffset = 0;\n        yOffset = rowHeight + yOffset + buffer;\n        rowHeight = 0;\n        columns = [];\n      }\n\n      columns.push({\n        icon,\n        xOffset,\n      });\n\n      xOffset = xOffset + size + buffer;\n      rowHeight = Math.max(rowHeight, size);\n    }\n  }\n\n  if (columns.length > 0) {\n    buildRowMapping(mapping, columns, yOffset);\n  }\n\n  const canvasHeight = nextPowOfTwo(rowHeight + yOffset + buffer);\n\n  return {\n    mapping,\n    canvasHeight,\n  };\n}\nfunction buildRowMapping(\n  mapping: IICONMap,\n  columns: Array<{\n    icon: IIcon;\n    xOffset: number;\n  }>,\n  yOffset: number,\n) {\n  for (const column of columns) {\n    const { icon, xOffset } = column;\n    mapping[icon.id] = {\n      ...icon,\n      x: xOffset,\n      y: yOffset,\n      image: icon.image,\n      width: icon.width,\n      height: icon.height,\n    };\n  }\n}\nexport function nextPowOfTwo(num: number) {\n  return Math.pow(2, Math.ceil(Math.log2(num)));\n}\n"]},"metadata":{},"sourceType":"module"}