{"ast":null,"code":"import _defineProperty from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _regeneratorRuntime from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";\n\nvar __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport React, { useCallback } from 'react';\nimport { XFlowGraphCommands, MODELS, XFlowNodeCommands, XFlowEdgeCommands } from '@antv/xflow-core';\nimport { onConfigChange } from '../flowchart-canvas/utils';\nimport { FormItemWrapper } from '../canvas-json-schema-form';\nimport { usePanelContext } from '../base-panel/context';\nimport useAsync from './useAsync';\nexport var FlowchartFormWrapper = function FlowchartFormWrapper(props) {\n  var controlSchema = props.controlSchema,\n      children = props.children,\n      _props$type = props.type,\n      formType = _props$type === void 0 ? 'node' : _props$type;\n\n  var _usePanelContext = usePanelContext(),\n      commandService = _usePanelContext.commandService,\n      modelService = _usePanelContext.modelService;\n\n  var getSelectNode = useCallback(function () {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee() {\n      var _yield$MODELS$SELECTE, data;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return MODELS.SELECTED_NODE.useValue(modelService);\n\n            case 2:\n              _yield$MODELS$SELECTE = _context.sent;\n              data = _yield$MODELS$SELECTE.data;\n              return _context.abrupt(\"return\", data);\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n  }, [modelService]);\n  var getSelectEdge = useCallback(function () {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee2() {\n      var cell, data;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return MODELS.SELECTED_CELL.useValue(modelService);\n\n            case 2:\n              cell = _context2.sent;\n              data = cell.getData();\n              return _context2.abrupt(\"return\", Object.assign({\n                id: cell.id\n              }, data));\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n  }, [modelService]);\n\n  var _useAsync = useAsync(formType === 'edge' ? getSelectEdge : getSelectNode),\n      data = _useAsync.data,\n      loading = _useAsync.loading;\n\n  React.useEffect(function () {\n    commandService.executeCommand(XFlowGraphCommands.SAVE_GRAPH_DATA.id, {\n      saveGraphDataService: function saveGraphDataService(meta, graph) {\n        return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee3() {\n          return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n            while (1) {\n              switch (_context3.prev = _context3.next) {\n                case 0:\n                  return _context3.abrupt(\"return\", {\n                    err: null,\n                    data: graph,\n                    meta: meta\n                  });\n\n                case 1:\n                case \"end\":\n                  return _context3.stop();\n              }\n            }\n          }, _callee3);\n        }));\n      }\n    });\n  }, [commandService, props]);\n\n  var updateNode = function updateNode(value) {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee4() {\n      var currentNodeData, nodeConfig;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return getSelectNode();\n\n            case 2:\n              currentNodeData = _context4.sent;\n              nodeConfig = Object.assign(Object.assign({}, currentNodeData), value);\n              _context4.next = 6;\n              return commandService.executeCommand(XFlowNodeCommands.UPDATE_NODE.id, {\n                nodeConfig: nodeConfig\n              });\n\n            case 6:\n              onConfigChange({\n                type: 'update:node',\n                config: nodeConfig\n              });\n\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4);\n    }));\n  };\n\n  var updateEdge = function updateEdge(value) {\n    var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'line';\n    var key = arguments.length > 2 ? arguments[2] : undefined;\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee5() {\n      var _a, currentEdgeData, edgeConfig;\n\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              _context5.next = 2;\n              return getSelectEdge();\n\n            case 2:\n              currentEdgeData = _context5.sent;\n              // 更新线、文本样式\n              edgeConfig = Object.assign(Object.assign(Object.assign({}, currentEdgeData), key ? value[key] : value), {\n                attrs: Object.assign(Object.assign({}, currentEdgeData.attrs), _defineProperty({}, type, Object.assign(Object.assign({}, (_a = currentEdgeData.attrs) === null || _a === void 0 ? void 0 : _a[type]), key ? value[key] : value)))\n              });\n              _context5.next = 6;\n              return commandService.executeCommand(XFlowEdgeCommands.UPDATE_EDGE.id, {\n                edgeConfig: edgeConfig\n              });\n\n            case 6:\n              onConfigChange({\n                type: 'update:edge',\n                config: edgeConfig\n              });\n\n            case 7:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5);\n    }));\n  };\n\n  var updateGroup = function updateGroup(value) {\n    return __awaiter(void 0, void 0, void 0, /*#__PURE__*/_regeneratorRuntime.mark(function _callee6() {\n      var currentGroupData, nodeConfig;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return getSelectNode();\n\n            case 2:\n              currentGroupData = _context6.sent;\n              nodeConfig = Object.assign(Object.assign({}, currentGroupData), value);\n              _context6.next = 6;\n              return commandService.executeCommand(XFlowNodeCommands.UPDATE_NODE.id, {\n                nodeConfig: nodeConfig\n              });\n\n            case 6:\n              onConfigChange({\n                type: 'update:group',\n                config: nodeConfig\n              });\n\n            case 7:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6);\n    }));\n  };\n\n  if (loading) {\n    return null;\n  }\n\n  return React.createElement(FormItemWrapper, {\n    schema: controlSchema\n  }, function () {\n    return children(Object.assign({}, data), {\n      updateNode: updateNode,\n      updateEdge: updateEdge,\n      updateGroup: updateGroup\n    });\n  });\n};","map":{"version":3,"sources":["../../src/flowchart-editor-panel/form-wrapper.tsx"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport React, { useCallback } from 'react';\nimport { XFlowGraphCommands, MODELS, XFlowNodeCommands, XFlowEdgeCommands } from '@antv/xflow-core';\nimport { onConfigChange } from '../flowchart-canvas/utils';\nimport { FormItemWrapper } from '../canvas-json-schema-form';\nimport { usePanelContext } from '../base-panel/context';\nimport useAsync from './useAsync';\nexport const FlowchartFormWrapper = props => {\n    const { controlSchema, children, type: formType = 'node' } = props;\n    const { commandService, modelService } = usePanelContext();\n    const getSelectNode = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        const { data } = yield MODELS.SELECTED_NODE.useValue(modelService);\n        return data;\n    }), [modelService]);\n    const getSelectEdge = useCallback(() => __awaiter(void 0, void 0, void 0, function* () {\n        const cell = yield MODELS.SELECTED_CELL.useValue(modelService);\n        const data = cell.getData();\n        return Object.assign({ id: cell.id }, data);\n    }), [modelService]);\n    const { data, loading } = useAsync(formType === 'edge' ? getSelectEdge : getSelectNode);\n    React.useEffect(() => {\n        commandService.executeCommand(XFlowGraphCommands.SAVE_GRAPH_DATA.id, {\n            saveGraphDataService: (meta, graph) => __awaiter(void 0, void 0, void 0, function* () {\n                return { err: null, data: graph, meta };\n            }),\n        });\n    }, [commandService, props]);\n    const updateNode = (value) => __awaiter(void 0, void 0, void 0, function* () {\n        const currentNodeData = yield getSelectNode();\n        const nodeConfig = Object.assign(Object.assign({}, currentNodeData), value);\n        yield commandService.executeCommand(XFlowNodeCommands.UPDATE_NODE.id, {\n            nodeConfig,\n        });\n        onConfigChange({ type: 'update:node', config: nodeConfig });\n    });\n    const updateEdge = (value, type = 'line', key) => __awaiter(void 0, void 0, void 0, function* () {\n        var _a;\n        const currentEdgeData = yield getSelectEdge();\n        // 更新线、文本样式\n        const edgeConfig = Object.assign(Object.assign(Object.assign({}, currentEdgeData), (key ? value[key] : value)), { attrs: Object.assign(Object.assign({}, currentEdgeData.attrs), { [type]: Object.assign(Object.assign({}, (_a = currentEdgeData.attrs) === null || _a === void 0 ? void 0 : _a[type]), (key ? value[key] : value)) }) });\n        yield commandService.executeCommand(XFlowEdgeCommands.UPDATE_EDGE.id, { edgeConfig });\n        onConfigChange({ type: 'update:edge', config: edgeConfig });\n    });\n    const updateGroup = (value) => __awaiter(void 0, void 0, void 0, function* () {\n        const currentGroupData = yield getSelectNode();\n        const nodeConfig = Object.assign(Object.assign({}, currentGroupData), value);\n        yield commandService.executeCommand(XFlowNodeCommands.UPDATE_NODE.id, {\n            nodeConfig,\n        });\n        onConfigChange({ type: 'update:group', config: nodeConfig });\n    });\n    if (loading) {\n        return null;\n    }\n    return (React.createElement(FormItemWrapper, { schema: controlSchema }, () => {\n        return children(Object.assign({}, data), { updateNode, updateEdge, updateGroup });\n    }));\n};\n//# sourceMappingURL=form-wrapper.js.map"]},"metadata":{},"sourceType":"module"}