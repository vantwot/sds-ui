{"ast":null,"code":"export var getDegree = function getDegree(n, nodeIdxMap, edges) {\n  var degrees = [];\n\n  for (var i = 0; i < n; i++) {\n    degrees[i] = 0;\n  }\n\n  edges.forEach(function (e) {\n    if (e.source) {\n      degrees[nodeIdxMap[e.source]] += 1;\n    }\n\n    if (e.target) {\n      degrees[nodeIdxMap[e.target]] += 1;\n    }\n  });\n  return degrees;\n};\nexport var floydWarshall = function floydWarshall(adjMatrix) {\n  // initialize\n  var dist = [];\n  var size = adjMatrix.length;\n\n  for (var i = 0; i < size; i += 1) {\n    dist[i] = [];\n\n    for (var j = 0; j < size; j += 1) {\n      if (i === j) {\n        dist[i][j] = 0;\n      } else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n        dist[i][j] = Infinity;\n      } else {\n        dist[i][j] = adjMatrix[i][j];\n      }\n    }\n  } // floyd\n\n\n  for (var k = 0; k < size; k += 1) {\n    for (var _i = 0; _i < size; _i += 1) {\n      for (var _j = 0; _j < size; _j += 1) {\n        if (dist[_i][_j] > dist[_i][k] + dist[k][_j]) {\n          dist[_i][_j] = dist[_i][k] + dist[k][_j];\n        }\n      }\n    }\n  }\n\n  return dist;\n};\nexport var getAdjMatrix = function getAdjMatrix(data, directed) {\n  var nodes = data.nodes,\n      edges = data.edges;\n  var matrix = []; // map node with index in data.nodes\n\n  var nodeMap = {};\n\n  if (!nodes) {\n    throw new Error('invalid nodes data!');\n  }\n\n  if (nodes) {\n    nodes.forEach(function (node, i) {\n      nodeMap[node.id] = i;\n      var row = [];\n      matrix.push(row);\n    });\n  }\n\n  if (edges) {\n    edges.forEach(function (e) {\n      var source = e.source,\n          target = e.target;\n      var sIndex = nodeMap[source];\n      var tIndex = nodeMap[target];\n      matrix[sIndex][tIndex] = 1;\n\n      if (!directed) {\n        matrix[tIndex][sIndex] = 1;\n      }\n    });\n  }\n\n  return matrix;\n};","map":{"version":3,"sources":["../../src/util/math.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["export const getDegree = (n, nodeIdxMap, edges) => {\n    const degrees = [];\n    for (let i = 0; i < n; i++) {\n        degrees[i] = 0;\n    }\n    edges.forEach((e) => {\n        if (e.source) {\n            degrees[nodeIdxMap[e.source]] += 1;\n        }\n        if (e.target) {\n            degrees[nodeIdxMap[e.target]] += 1;\n        }\n    });\n    return degrees;\n};\nexport const floydWarshall = (adjMatrix) => {\n    // initialize\n    const dist = [];\n    const size = adjMatrix.length;\n    for (let i = 0; i < size; i += 1) {\n        dist[i] = [];\n        for (let j = 0; j < size; j += 1) {\n            if (i === j) {\n                dist[i][j] = 0;\n            }\n            else if (adjMatrix[i][j] === 0 || !adjMatrix[i][j]) {\n                dist[i][j] = Infinity;\n            }\n            else {\n                dist[i][j] = adjMatrix[i][j];\n            }\n        }\n    }\n    // floyd\n    for (let k = 0; k < size; k += 1) {\n        for (let i = 0; i < size; i += 1) {\n            for (let j = 0; j < size; j += 1) {\n                if (dist[i][j] > dist[i][k] + dist[k][j]) {\n                    dist[i][j] = dist[i][k] + dist[k][j];\n                }\n            }\n        }\n    }\n    return dist;\n};\nexport const getAdjMatrix = (data, directed) => {\n    const { nodes, edges } = data;\n    const matrix = [];\n    // map node with index in data.nodes\n    const nodeMap = {};\n    if (!nodes) {\n        throw new Error('invalid nodes data!');\n    }\n    if (nodes) {\n        nodes.forEach((node, i) => {\n            nodeMap[node.id] = i;\n            const row = [];\n            matrix.push(row);\n        });\n    }\n    if (edges) {\n        edges.forEach((e) => {\n            const { source, target } = e;\n            const sIndex = nodeMap[source];\n            const tIndex = nodeMap[target];\n            matrix[sIndex][tIndex] = 1;\n            if (!directed) {\n                matrix[tIndex][sIndex] = 1;\n            }\n        });\n    }\n    return matrix;\n};\n//# sourceMappingURL=math.js.map"]},"metadata":{},"sourceType":"module"}