{"ast":null,"code":"import _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _isNumber from \"lodash/isNumber\";\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { AttributeType, gl } from '@antv/l7-core';\nimport { rgb2arr } from '@antv/l7-utils';\nimport BaseModel from '../../core/BaseModel';\nimport { LineArcTriangulation } from '../../core/triangulation';\nvar line_arcmini_frag = \"#define LineTypeSolid 0.0\\n#define Animate 0.0\\n\\nuniform float u_opacity;\\nuniform float u_blur : 0.9;\\n// varying vec2 v_normal;\\nvarying vec4 v_color;\\n\\nuniform float u_time;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\n\\nuniform float segmentNumber;\\nvarying float v_distance_ratio;\\n\\nuniform float u_linearColor: 0;\\nuniform vec4 u_sourceColor;\\nuniform vec4 u_targetColor;\\n\\n#pragma include \\\"picking\\\"\\n\\nvoid main() {\\n\\n  // \\u8BBE\\u7F6E\\u5F27\\u7EBF\\u7684\\u5E95\\u8272\\n  if(u_linearColor == 1.0) { // \\u4F7F\\u7528\\u6E10\\u53D8\\u989C\\u8272\\n    gl_FragColor = mix(u_sourceColor, u_targetColor, v_distance_ratio);\\n  } else { // \\u4F7F\\u7528 color \\u65B9\\u6CD5\\u4F20\\u5165\\u7684\\u989C\\u8272\\n     gl_FragColor = v_color;\\n  }\\n  \\n \\n  gl_FragColor.a *= u_opacity;\\n\\n  if(u_aimate.x == Animate) {\\n      float animateSpeed = u_time / u_aimate.y; // \\u8FD0\\u52A8\\u901F\\u5EA6\\n      float alpha =1.0 - fract( mod(1.0- v_distance_ratio, u_aimate.z)* (1.0/ u_aimate.z) + u_time / u_aimate.y);\\n      alpha = (alpha + u_aimate.w -1.0) / u_aimate.w;\\n      // alpha = smoothstep(0., 1., alpha);\\n      alpha = clamp(alpha, 0.0, 1.0);\\n      gl_FragColor.a *= alpha;\\n  }\\n  gl_FragColor = filterColor(gl_FragColor);\\n}\";\nvar line_arcmini_vert = \"#define LineTypeSolid 0.0\\n#define LineTypeDash 1.0\\n#define Animate 0.0\\n\\nattribute vec4 a_Color;\\nattribute vec3 a_Position;\\nattribute vec4 a_Instance;\\nattribute float a_Size;\\nuniform mat4 u_ModelMatrix;\\nuniform mat4 u_Mvp;\\nuniform float segmentNumber;\\nuniform vec4 u_aimate: [ 0, 2., 1.0, 0.2 ];\\nvarying vec4 v_color;\\n// varying vec2 v_normal;\\n\\nuniform float u_lineDir: 1.0;\\n\\n// \\u504F\\u79FB\\u91CF\\nuniform float u_thetaOffset: 0.314;\\n\\nuniform float u_opacity: 1.0;\\nvarying float v_distance_ratio;\\n\\n#pragma include \\\"projection\\\"\\n#pragma include \\\"project\\\"\\n#pragma include \\\"picking\\\"\\n\\nfloat bezier3(vec3 arr, float t) {\\n  float ut = 1. - t;\\n  return (arr.x * ut + arr.y * t) * ut + (arr.y * ut + arr.z * t) * t;\\n}\\nvec2 midPoint(vec2 source, vec2 target) {\\n  vec2 center = target - source;\\n  float r = length(center);\\n  float theta = atan(center.y, center.x);\\n  float thetaOffset = u_thetaOffset;\\n  float r2 = r / 2.0 / cos(thetaOffset);\\n  float theta2 = theta + thetaOffset;\\n  vec2 mid = vec2(r2*cos(theta2) + source.x, r2*sin(theta2) + source.y);\\n  if(u_lineDir == 1.0) { // \\u6B63\\u5411\\n    return mid;\\n  } else { // \\u9006\\u5411\\n    // (mid + vmin)/2 = (s + t)/2\\n    vec2 vmid = source + target - mid;\\n    return vmid;\\n  }\\n  // return mid;\\n}\\nfloat getSegmentRatio(float index) {\\n    return smoothstep(0.0, 1.0, index / (segmentNumber - 1.));\\n}\\nvec2 interpolate (vec2 source, vec2 target, float t) {\\n  // if the angularDist is PI, linear interpolation is applied. otherwise, use spherical interpolation\\n  vec2 mid = midPoint(source, target);\\n  vec3 x = vec3(source.x, mid.x, target.x);\\n  vec3 y = vec3(source.y, mid.y, target.y);\\n  return vec2(bezier3(x ,t), bezier3(y,t));\\n}\\nvec2 getExtrusionOffset(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace);\\n  // rotate by 90 degrees\\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n  vec2 offset = dir_screenspace * offset_direction * setPickingSize(a_Size) / 2.0;\\n  return offset;\\n}\\nvec2 getNormal(vec2 line_clipspace, float offset_direction) {\\n  // normalized direction of the line\\n  vec2 dir_screenspace = normalize(line_clipspace);\\n  // rotate by 90 degrees\\n   dir_screenspace = vec2(-dir_screenspace.y, dir_screenspace.x);\\n   return reverse_offset_normal(vec3(dir_screenspace,1.0)).xy * sign(offset_direction);\\n}\\n\\nvoid main() {\\n  v_color = a_Color;\\n  \\n  vec2 source = a_Instance.rg;  // \\u8D77\\u59CB\\u70B9\\n  vec2 target =  a_Instance.ba; // \\u7EC8\\u70B9\\n  float segmentIndex = a_Position.x;\\n  float segmentRatio = getSegmentRatio(segmentIndex);\\n\\n  float indexDir = mix(-1.0, 1.0, step(segmentIndex, 0.0));\\n  float nextSegmentRatio = getSegmentRatio(segmentIndex + indexDir);\\n\\n  v_distance_ratio = segmentIndex / segmentNumber;\\n  \\n  if(u_aimate.x == Animate && u_lineDir != 1.0) {\\n      v_distance_ratio = 1.0 - v_distance_ratio;\\n  }\\n\\n  vec4 curr = project_position(vec4(interpolate(source, target, segmentRatio), 0.0, 1.0));\\n  vec4 next = project_position(vec4(interpolate(source, target, nextSegmentRatio), 0.0, 1.0));\\n  // v_normal = getNormal((next.xy - curr.xy) * indexDir, a_Position.y);\\n  //unProjCustomCoord\\n  \\n  vec2 offset = project_pixel(getExtrusionOffset((next.xy - curr.xy) * indexDir, a_Position.y));\\n\\n  if(u_CoordinateSystem == COORDINATE_SYSTEM_P20_2) { // gaode2.x\\n    gl_Position = u_Mvp * (vec4(curr.xy + offset, 0, 1.0));\\n  } else {\\n    gl_Position = project_common_position_to_clipspace(vec4(curr.xy + offset, 0, 1.0));\\n  }\\n  setPickingColor(a_PickingColor);\\n}\\n\";\n\nvar ArcMiniModel = function (_BaseModel) {\n  _inherits(ArcMiniModel, _BaseModel);\n\n  var _super = _createSuper(ArcMiniModel);\n\n  function ArcMiniModel() {\n    _classCallCheck(this, ArcMiniModel);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(ArcMiniModel, [{\n    key: \"getUninforms\",\n    value: function getUninforms() {\n      var _ref = this.layer.getLayerConfig(),\n          opacity = _ref.opacity,\n          sourceColor = _ref.sourceColor,\n          targetColor = _ref.targetColor,\n          _ref$forward = _ref.forward,\n          forward = _ref$forward === void 0 ? true : _ref$forward,\n          _ref$segmentNumber = _ref.segmentNumber,\n          segmentNumber = _ref$segmentNumber === void 0 ? 30 : _ref$segmentNumber,\n          _ref$thetaOffset = _ref.thetaOffset,\n          thetaOffset = _ref$thetaOffset === void 0 ? 0.314 : _ref$thetaOffset;\n\n      var useLinearColor = 0;\n      var sourceColorArr = [0, 0, 0, 0];\n      var targetColorArr = [0, 0, 0, 0];\n\n      if (sourceColor && targetColor) {\n        sourceColorArr = rgb2arr(sourceColor);\n        targetColorArr = rgb2arr(targetColor);\n        useLinearColor = 1;\n      }\n\n      return {\n        u_thetaOffset: thetaOffset,\n        u_opacity: _isNumber(opacity) ? opacity : 1.0,\n        segmentNumber: segmentNumber,\n        u_blur: 0.9,\n        u_lineDir: forward ? 1 : -1,\n        u_linearColor: useLinearColor,\n        u_sourceColor: sourceColorArr,\n        u_targetColor: targetColorArr\n      };\n    }\n  }, {\n    key: \"getAnimateUniforms\",\n    value: function getAnimateUniforms() {\n      var _ref2 = this.layer.getLayerConfig(),\n          animateOption = _ref2.animateOption;\n\n      return {\n        u_aimate: this.animateOption2Array(animateOption),\n        u_time: this.layer.getLayerAnimateTime()\n      };\n    }\n  }, {\n    key: \"initModels\",\n    value: function initModels() {\n      return this.buildModels();\n    }\n  }, {\n    key: \"buildModels\",\n    value: function buildModels() {\n      var _ref3 = this.layer.getLayerConfig(),\n          _ref3$segmentNumber = _ref3.segmentNumber,\n          segmentNumber = _ref3$segmentNumber === void 0 ? 30 : _ref3$segmentNumber;\n\n      return [this.layer.buildLayerModel({\n        moduleName: 'arc2dminiline',\n        vertexShader: line_arcmini_vert,\n        fragmentShader: line_arcmini_frag,\n        triangulation: LineArcTriangulation,\n        depth: {\n          enable: false\n        },\n        blend: this.getBlend(),\n        segmentNumber: segmentNumber\n      })];\n    }\n  }, {\n    key: \"registerBuiltinAttributes\",\n    value: function registerBuiltinAttributes() {\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'size',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Size',\n          buffer: {\n            usage: gl.DYNAMIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 1,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            var _feature$size = feature.size,\n                size = _feature$size === void 0 ? 1 : _feature$size;\n            return Array.isArray(size) ? [size[0]] : [size];\n          }\n        }\n      });\n      this.styleAttributeService.registerStyleAttribute({\n        name: 'instance',\n        type: AttributeType.Attribute,\n        descriptor: {\n          name: 'a_Instance',\n          buffer: {\n            usage: gl.STATIC_DRAW,\n            data: [],\n            type: gl.FLOAT\n          },\n          size: 4,\n          update: function update(feature, featureIdx, vertex, attributeIdx) {\n            return [vertex[3], vertex[4], vertex[5], vertex[6]];\n          }\n        }\n      });\n    }\n  }]);\n\n  return ArcMiniModel;\n}(BaseModel);\n\nexport { ArcMiniModel as default };","map":{"version":3,"sources":["../../../src/line/models/arcmini.ts"],"names":["ArcMiniModel","BaseModel","opacity","sourceColor","targetColor","forward","segmentNumber","thetaOffset","useLinearColor","sourceColorArr","targetColorArr","rgb2arr","u_thetaOffset","u_opacity","u_blur","u_lineDir","u_linearColor","u_sourceColor","u_targetColor","animateOption","u_aimate","u_time","moduleName","vertexShader","fragmentShader","triangulation","depth","enable","blend","name","type","AttributeType","descriptor","buffer","usage","gl","data","FLOAT","size","update","feature","Array","vertex"],"mappings":"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","sourcesContent":["import {\n  AttributeType,\n  gl,\n  IAnimateOption,\n  IEncodeFeature,\n  ILayerConfig,\n  IModel,\n  IModelUniform,\n} from '@antv/l7-core';\n\nimport { rgb2arr } from '@antv/l7-utils';\nimport { isNumber } from 'lodash';\nimport BaseModel from '../../core/BaseModel';\nimport { ILineLayerStyleOptions } from '../../core/interface';\nimport { LineArcTriangulation } from '../../core/triangulation';\nimport line_arcmini_frag from '../shaders/line_arcmini_frag.glsl';\nimport line_arcmini_vert from '../shaders/line_arcmini_vert.glsl';\n\nexport default class ArcMiniModel extends BaseModel {\n  public getUninforms(): IModelUniform {\n    const {\n      opacity,\n      sourceColor,\n      targetColor,\n      forward = true,\n      segmentNumber = 30,\n      thetaOffset = 0.314,\n    } = this.layer.getLayerConfig() as ILineLayerStyleOptions;\n\n    // 转化渐变色\n    let useLinearColor = 0; // 默认不生效\n    let sourceColorArr = [0, 0, 0, 0];\n    let targetColorArr = [0, 0, 0, 0];\n    if (sourceColor && targetColor) {\n      sourceColorArr = rgb2arr(sourceColor);\n      targetColorArr = rgb2arr(targetColor);\n      useLinearColor = 1;\n    }\n\n    return {\n      u_thetaOffset: thetaOffset,\n\n      u_opacity: isNumber(opacity) ? opacity : 1.0,\n\n      segmentNumber,\n      u_blur: 0.9,\n      u_lineDir: forward ? 1 : -1,\n\n      // 渐变色支持参数\n      u_linearColor: useLinearColor,\n      u_sourceColor: sourceColorArr,\n      u_targetColor: targetColorArr,\n    };\n  }\n\n  public getAnimateUniforms(): IModelUniform {\n    const { animateOption } = this.layer.getLayerConfig() as ILayerConfig;\n    return {\n      u_aimate: this.animateOption2Array(animateOption as IAnimateOption),\n      u_time: this.layer.getLayerAnimateTime(),\n    };\n  }\n\n  public initModels(): IModel[] {\n    return this.buildModels();\n  }\n\n  public buildModels(): IModel[] {\n    const {\n      segmentNumber = 30,\n    } = this.layer.getLayerConfig() as ILineLayerStyleOptions;\n\n    return [\n      this.layer.buildLayerModel({\n        moduleName: 'arc2dminiline',\n        vertexShader: line_arcmini_vert,\n        fragmentShader: line_arcmini_frag,\n        triangulation: LineArcTriangulation,\n        depth: { enable: false },\n        blend: this.getBlend(),\n        segmentNumber,\n      }),\n    ];\n  }\n\n  protected registerBuiltinAttributes() {\n    // point layer size;\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'size',\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Size',\n        buffer: {\n          // give the WebGL driver a hint that this buffer may change\n          usage: gl.DYNAMIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 1,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          const { size = 1 } = feature;\n          return Array.isArray(size) ? [size[0]] : [size as number];\n        },\n      },\n    });\n\n    this.styleAttributeService.registerStyleAttribute({\n      name: 'instance', // 弧线起始点信息\n      type: AttributeType.Attribute,\n      descriptor: {\n        name: 'a_Instance',\n        buffer: {\n          usage: gl.STATIC_DRAW,\n          data: [],\n          type: gl.FLOAT,\n        },\n        size: 4,\n        update: (\n          feature: IEncodeFeature,\n          featureIdx: number,\n          vertex: number[],\n          attributeIdx: number,\n        ) => {\n          return [vertex[3], vertex[4], vertex[5], vertex[6]];\n        },\n      },\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}