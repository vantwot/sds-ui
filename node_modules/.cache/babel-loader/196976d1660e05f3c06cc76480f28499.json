{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _class, _class2, _descriptor;\n\nimport { mat4, vec4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { TYPES } from '../../types';\nimport { getDistanceScales } from '../../utils/project';\nimport { CoordinateSystem } from './ICoordinateSystemService';\nvar VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\nvar CoordinateSystemService = (_dec = injectable(), _dec2 = inject(TYPES.ICameraService), _dec(_class = (_class2 = function () {\n  function CoordinateSystemService() {\n    _classCallCheck(this, CoordinateSystemService);\n\n    _defineProperty(this, \"needRefresh\", true);\n\n    _initializerDefineProperty(this, \"cameraService\", _descriptor, this);\n\n    _defineProperty(this, \"coordinateSystem\", void 0);\n\n    _defineProperty(this, \"viewportCenter\", void 0);\n\n    _defineProperty(this, \"viewportCenterProjection\", void 0);\n\n    _defineProperty(this, \"pixelsPerDegree\", void 0);\n\n    _defineProperty(this, \"pixelsPerDegree2\", void 0);\n\n    _defineProperty(this, \"pixelsPerMeter\", void 0);\n  }\n\n  _createClass(CoordinateSystemService, [{\n    key: \"refresh\",\n    value: function refresh() {\n      var zoom = this.cameraService.getZoom();\n      var zoomScale = this.cameraService.getZoomScale();\n      var center = this.cameraService.getCenter();\n\n      var _getDistanceScales = getDistanceScales({\n        latitude: center[1],\n        zoom: zoom\n      }),\n          pixelsPerMeter = _getDistanceScales.pixelsPerMeter,\n          pixelsPerDegree = _getDistanceScales.pixelsPerDegree;\n\n      this.viewportCenter = center;\n      this.viewportCenterProjection = [0, 0, 0, 0];\n      this.pixelsPerMeter = pixelsPerMeter;\n      this.pixelsPerDegree = pixelsPerDegree;\n      this.pixelsPerDegree2 = [0, 0, 0];\n\n      if (this.coordinateSystem === CoordinateSystem.LNGLAT || this.coordinateSystem === CoordinateSystem.P20) {\n        this.cameraService.setViewProjectionMatrix(undefined);\n      } else if (this.coordinateSystem === CoordinateSystem.LNGLAT_OFFSET) {\n        this.calculateLnglatOffset(center, zoom);\n      } else if (this.coordinateSystem === CoordinateSystem.P20_OFFSET) {\n        this.calculateLnglatOffset(center, zoom, zoomScale, true);\n      }\n\n      this.needRefresh = false;\n    }\n  }, {\n    key: \"getCoordinateSystem\",\n    value: function getCoordinateSystem() {\n      return this.coordinateSystem;\n    }\n  }, {\n    key: \"setCoordinateSystem\",\n    value: function setCoordinateSystem(coordinateSystem) {\n      this.coordinateSystem = coordinateSystem;\n    }\n  }, {\n    key: \"getViewportCenter\",\n    value: function getViewportCenter() {\n      return this.viewportCenter;\n    }\n  }, {\n    key: \"getViewportCenterProjection\",\n    value: function getViewportCenterProjection() {\n      return this.viewportCenterProjection;\n    }\n  }, {\n    key: \"getPixelsPerDegree\",\n    value: function getPixelsPerDegree() {\n      return this.pixelsPerDegree;\n    }\n  }, {\n    key: \"getPixelsPerDegree2\",\n    value: function getPixelsPerDegree2() {\n      return this.pixelsPerDegree2;\n    }\n  }, {\n    key: \"getPixelsPerMeter\",\n    value: function getPixelsPerMeter() {\n      return this.pixelsPerMeter;\n    }\n  }, {\n    key: \"calculateLnglatOffset\",\n    value: function calculateLnglatOffset(center, zoom, scale, flipY) {\n      var _getDistanceScales2 = getDistanceScales({\n        latitude: center[1],\n        zoom: zoom,\n        scale: scale,\n        flipY: flipY,\n        highPrecision: true\n      }),\n          ppm = _getDistanceScales2.pixelsPerMeter,\n          ppd = _getDistanceScales2.pixelsPerDegree,\n          pixelsPerDegree2 = _getDistanceScales2.pixelsPerDegree2;\n\n      var viewMatrix = this.cameraService.getViewMatrix();\n      var projectionMatrix = this.cameraService.getProjectionMatrix();\n      var viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n      var positionPixels = this.cameraService.projectFlat([Math.fround(center[0]), Math.fround(center[1])], Math.pow(2, zoom));\n      this.viewportCenterProjection = vec4.transformMat4([], [positionPixels[0], positionPixels[1], 0.0, 1.0], viewProjectionMatrix);\n      viewMatrix = this.cameraService.getViewMatrixUncentered() || viewMatrix;\n      viewProjectionMatrix = mat4.multiply([], projectionMatrix, viewMatrix);\n      viewProjectionMatrix = mat4.multiply([], viewProjectionMatrix, VECTOR_TO_POINT_MATRIX);\n      this.cameraService.setViewProjectionMatrix(viewProjectionMatrix);\n      this.pixelsPerMeter = ppm;\n      this.pixelsPerDegree = ppd;\n      this.pixelsPerDegree2 = pixelsPerDegree2;\n    }\n  }]);\n\n  return CoordinateSystemService;\n}(), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"cameraService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);\nexport { CoordinateSystemService as default };","map":{"version":3,"sources":["../../../src/services/coordinate/CoordinateSystemService.ts"],"names":["VECTOR_TO_POINT_MATRIX","injectable","CoordinateSystemService","inject","TYPES","zoom","zoomScale","center","pixelsPerMeter","pixelsPerDegree","getDistanceScales","latitude","CoordinateSystem","ppm","ppd","pixelsPerDegree2","scale","flipY","highPrecision","viewMatrix","projectionMatrix","viewProjectionMatrix","mat4","positionPixels","Math","vec4"],"mappings":"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","sourcesContent":["import { mat4, vec4 } from 'gl-matrix';\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\nimport { TYPES } from '../../types';\nimport { getDistanceScales } from '../../utils/project';\nimport { ICameraService } from '../camera/ICameraService';\n// import { IMapService } from '../map/IMapService'\nimport {\n  CoordinateSystem,\n  ICoordinateSystemService,\n} from './ICoordinateSystemService';\n\nconst VECTOR_TO_POINT_MATRIX = [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0];\n\n@injectable()\nexport default class CoordinateSystemService\n  implements ICoordinateSystemService {\n  public needRefresh: boolean = true;\n  @inject(TYPES.ICameraService)\n  private readonly cameraService: ICameraService;\n\n  // map.getCenter\n  // @inject(TYPES.IMapService)\n  // private readonly mapService: IMapService\n\n  /**\n   * 1. Web 墨卡托坐标系\n   * 2. 偏移经纬度，用于解决高精度抖动问题\n   * 3. 瓦片坐标，用于数据瓦片\n   * 4. 常规世界坐标系，用于常规 2D/3D 可视化场景\n   * 5. P20 坐标系，高德地图使用\n   * @see https://yuque.antfin-inc.com/yuqi.pyq/fgetpa/doml91\n   */\n  private coordinateSystem: CoordinateSystem;\n\n  /**\n   * 屏幕中心点 [lng, lat]\n   */\n  private viewportCenter: [number, number];\n\n  /**\n   * 屏幕中心点的最终投影结果，在 CPU 侧计算后传入 Shader\n   * @see https://zhuanlan.zhihu.com/p/57469121\n   */\n  private viewportCenterProjection: [number, number, number, number];\n\n  /**\n   * 像素单位 -> 经纬度 [x, y, z]\n   */\n  private pixelsPerDegree: [number, number, number];\n\n  /**\n   * 像素单位 -> 经纬度 [lng, lat] 使用泰勒级数展开\n   * 通过墨卡托坐标系下的差值估计世界坐标系下的差值\n   * @see https://zhuanlan.zhihu.com/p/57469121\n   */\n  private pixelsPerDegree2: [number, number, number];\n\n  /**\n   * 像素单位 -> 米\n   */\n  private pixelsPerMeter: [number, number, number];\n\n  /**\n   * 重新计算当前坐标系参数\n   * TODO: 使用 memoize 缓存参数以及计算结果\n   */\n  public refresh(): void {\n    // if (!this.needRefresh) {\n    //   return;\n    // }\n    const zoom = this.cameraService.getZoom();\n    const zoomScale = this.cameraService.getZoomScale();\n    const center = this.cameraService.getCenter();\n\n    // 计算像素到米以及经纬度之间的转换\n    const { pixelsPerMeter, pixelsPerDegree } = getDistanceScales({\n      // longitude: center[0],\n      latitude: center[1],\n      zoom,\n    });\n    this.viewportCenter = center;\n    this.viewportCenterProjection = [0, 0, 0, 0];\n    this.pixelsPerMeter = pixelsPerMeter;\n    this.pixelsPerDegree = pixelsPerDegree;\n    this.pixelsPerDegree2 = [0, 0, 0];\n\n    if (\n      this.coordinateSystem === CoordinateSystem.LNGLAT ||\n      this.coordinateSystem === CoordinateSystem.P20\n    ) {\n      // 继续使用相机服务计算的 VP 矩阵\n      this.cameraService.setViewProjectionMatrix(undefined);\n    } else if (this.coordinateSystem === CoordinateSystem.LNGLAT_OFFSET) {\n      this.calculateLnglatOffset(center, zoom);\n    } else if (this.coordinateSystem === CoordinateSystem.P20_OFFSET) {\n      this.calculateLnglatOffset(center, zoom, zoomScale, true);\n    }\n    this.needRefresh = false;\n\n    // TODO: 判断是否应用瓦片 & 常规坐标系\n  }\n\n  public getCoordinateSystem(): CoordinateSystem {\n    return this.coordinateSystem;\n  }\n\n  public setCoordinateSystem(coordinateSystem: CoordinateSystem) {\n    this.coordinateSystem = coordinateSystem;\n  }\n\n  public getViewportCenter(): [number, number] {\n    return this.viewportCenter;\n  }\n\n  public getViewportCenterProjection(): [number, number, number, number] {\n    return this.viewportCenterProjection;\n  }\n\n  public getPixelsPerDegree(): [number, number, number] {\n    return this.pixelsPerDegree;\n  }\n\n  public getPixelsPerDegree2(): [number, number, number] {\n    return this.pixelsPerDegree2;\n  }\n\n  public getPixelsPerMeter(): [number, number, number] {\n    return this.pixelsPerMeter;\n  }\n\n  private calculateLnglatOffset(\n    center: [number, number],\n    zoom: number,\n    scale?: number,\n    flipY?: boolean,\n  ) {\n    // http://uber-common.github.io/viewport-mercator-project/docs/api-reference/web-mercator-utils#code-classlanguage-textgetdistancescalesviewportcode\n    const {\n      pixelsPerMeter: ppm,\n      pixelsPerDegree: ppd,\n      pixelsPerDegree2,\n    } = getDistanceScales({\n      // longitude: center[0],\n      latitude: center[1],\n      zoom,\n      scale,\n      flipY,\n      highPrecision: true,\n    });\n\n    let viewMatrix = this.cameraService.getViewMatrix();\n    const projectionMatrix = this.cameraService.getProjectionMatrix();\n    let viewProjectionMatrix = mat4.multiply(\n      ([] as unknown) as mat4,\n      (projectionMatrix as unknown) as mat4,\n      (viewMatrix as unknown) as mat4,\n    );\n\n    // 经纬度投影到 Web 墨卡托坐标系\n    const positionPixels = this.cameraService.projectFlat(\n      [Math.fround(center[0]), Math.fround(center[1])],\n      Math.pow(2, zoom),\n    );\n\n    // Web 墨卡托坐标系通过 VP 矩阵变换到世界坐标系\n    this.viewportCenterProjection = (vec4.transformMat4(\n      ([] as unknown) as vec4,\n      [positionPixels[0], positionPixels[1], 0.0, 1.0],\n      (viewProjectionMatrix as unknown) as mat4,\n    ) as unknown) as [number, number, number, number];\n\n    // Always apply uncentered projection matrix if available (shader adds center)\n    viewMatrix = this.cameraService.getViewMatrixUncentered() || viewMatrix;\n\n    // Zero out 4th coordinate (\"after\" model matrix) - avoids further translations\n    viewProjectionMatrix = mat4.multiply(\n      ([] as unknown) as mat4,\n      (projectionMatrix as unknown) as mat4,\n      (viewMatrix as unknown) as mat4,\n    );\n    viewProjectionMatrix = mat4.multiply(\n      ([] as unknown) as mat4,\n      viewProjectionMatrix,\n      (VECTOR_TO_POINT_MATRIX as unknown) as mat4,\n    );\n\n    // 重新计算相机 VP 矩阵\n    this.cameraService.setViewProjectionMatrix(\n      (viewProjectionMatrix as unknown) as number[],\n    );\n\n    this.pixelsPerMeter = ppm;\n    this.pixelsPerDegree = ppd;\n    this.pixelsPerDegree2 = pixelsPerDegree2;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}