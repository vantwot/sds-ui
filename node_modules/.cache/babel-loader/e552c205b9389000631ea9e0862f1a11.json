{"ast":null,"code":"import { NumberExt } from '../../../util';\nimport { Point, Angle } from '../../../geometry';\nimport { orth } from '../orth';\nexport var defaults = {\n  step: 10,\n  maxLoopCount: 2000,\n  precision: 1,\n  maxDirectionChange: 90,\n  perpendicular: true,\n  excludeTerminals: [],\n  excludeShapes: [],\n  excludeHiddenNodes: false,\n  startDirections: ['top', 'right', 'bottom', 'left'],\n  endDirections: ['top', 'right', 'bottom', 'left'],\n  directionMap: {\n    top: {\n      x: 0,\n      y: -1\n    },\n    right: {\n      x: 1,\n      y: 0\n    },\n    bottom: {\n      x: 0,\n      y: 1\n    },\n    left: {\n      x: -1,\n      y: 0\n    }\n  },\n  cost: function cost() {\n    var step = resolve(this.step, this);\n    return step;\n  },\n  directions: function directions() {\n    var step = resolve(this.step, this);\n    var cost = resolve(this.cost, this);\n    return [{\n      cost: cost,\n      offsetX: step,\n      offsetY: 0\n    }, {\n      cost: cost,\n      offsetX: 0,\n      offsetY: step\n    }, {\n      cost: cost,\n      offsetX: -step,\n      offsetY: 0\n    }, {\n      cost: cost,\n      offsetX: 0,\n      offsetY: -step\n    }];\n  },\n  penalties: function penalties() {\n    var step = resolve(this.step, this);\n    return {\n      0: 0,\n      45: step / 2,\n      90: step / 2\n    };\n  },\n  paddingBox: function paddingBox() {\n    var step = resolve(this.step, this);\n    return {\n      x: -step,\n      y: -step,\n      width: 2 * step,\n      height: 2 * step\n    };\n  },\n  fallbackRouter: orth,\n  draggingRouter: null\n};\nexport function resolve(input, options) {\n  if (typeof input === 'function') {\n    return input.call(options);\n  }\n\n  return input;\n}\nexport function resolveOptions(options) {\n  var result = Object.keys(options).reduce(function (memo, key) {\n    var ret = memo;\n\n    if (key === 'fallbackRouter' || key === 'draggingRouter' || key === 'fallbackRoute') {\n      ret[key] = options[key];\n    } else {\n      ret[key] = resolve(options[key], options);\n    }\n\n    return memo;\n  }, {});\n\n  if (result.padding) {\n    var sides = NumberExt.normalizeSides(result.padding);\n    options.paddingBox = {\n      x: -sides.left,\n      y: -sides.top,\n      width: sides.left + sides.right,\n      height: sides.top + sides.bottom\n    };\n  }\n\n  result.directions.forEach(function (direction) {\n    var point1 = new Point(0, 0);\n    var point2 = new Point(direction.offsetX, direction.offsetY);\n    direction.angle = Angle.normalize(point1.theta(point2));\n  });\n  return result;\n}","map":{"version":3,"sources":["../../../../src/registry/router/manhattan/options.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { NumberExt } from '../../../util';\nimport { Point, Angle } from '../../../geometry';\nimport { orth } from '../orth';\nexport const defaults = {\n    step: 10,\n    maxLoopCount: 2000,\n    precision: 1,\n    maxDirectionChange: 90,\n    perpendicular: true,\n    excludeTerminals: [],\n    excludeShapes: [],\n    excludeHiddenNodes: false,\n    startDirections: ['top', 'right', 'bottom', 'left'],\n    endDirections: ['top', 'right', 'bottom', 'left'],\n    directionMap: {\n        top: { x: 0, y: -1 },\n        right: { x: 1, y: 0 },\n        bottom: { x: 0, y: 1 },\n        left: { x: -1, y: 0 },\n    },\n    cost() {\n        const step = resolve(this.step, this);\n        return step;\n    },\n    directions() {\n        const step = resolve(this.step, this);\n        const cost = resolve(this.cost, this);\n        return [\n            { cost, offsetX: step, offsetY: 0 },\n            { cost, offsetX: 0, offsetY: step },\n            { cost, offsetX: -step, offsetY: 0 },\n            { cost, offsetX: 0, offsetY: -step },\n        ];\n    },\n    penalties() {\n        const step = resolve(this.step, this);\n        return {\n            0: 0,\n            45: step / 2,\n            90: step / 2,\n        };\n    },\n    paddingBox() {\n        const step = resolve(this.step, this);\n        return {\n            x: -step,\n            y: -step,\n            width: 2 * step,\n            height: 2 * step,\n        };\n    },\n    fallbackRouter: orth,\n    draggingRouter: null,\n};\nexport function resolve(input, options) {\n    if (typeof input === 'function') {\n        return input.call(options);\n    }\n    return input;\n}\nexport function resolveOptions(options) {\n    const result = Object.keys(options).reduce((memo, key) => {\n        const ret = memo;\n        if (key === 'fallbackRouter' ||\n            key === 'draggingRouter' ||\n            key === 'fallbackRoute') {\n            ret[key] = options[key];\n        }\n        else {\n            ret[key] = resolve(options[key], options);\n        }\n        return memo;\n    }, {});\n    if (result.padding) {\n        const sides = NumberExt.normalizeSides(result.padding);\n        options.paddingBox = {\n            x: -sides.left,\n            y: -sides.top,\n            width: sides.left + sides.right,\n            height: sides.top + sides.bottom,\n        };\n    }\n    result.directions.forEach((direction) => {\n        const point1 = new Point(0, 0);\n        const point2 = new Point(direction.offsetX, direction.offsetY);\n        direction.angle = Angle.normalize(point1.theta(point2));\n    });\n    return result;\n}\n//# sourceMappingURL=options.js.map"]},"metadata":{},"sourceType":"module"}