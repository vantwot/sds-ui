{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { ArrayExt } from '../../../util';\nimport { Point } from '../../../geometry';\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\n\nexport var ObstacleMap = /*#__PURE__*/function () {\n  function ObstacleMap(options) {\n    _classCallCheck(this, ObstacleMap);\n\n    this.options = options;\n    this.mapGridSize = 100;\n    this.map = {};\n  }\n  /**\n   * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n   * contained in any obstacle?\n   *\n   * A simplified grid search.\n   */\n\n\n  _createClass(ObstacleMap, [{\n    key: \"build\",\n    value: function build(model, edge) {\n      var options = this.options; // source or target node could be excluded from set of obstacles\n\n      var excludedTerminals = options.excludeTerminals.reduce(function (memo, type) {\n        var terminal = edge[type];\n\n        if (terminal) {\n          var cell = model.getCell(terminal.cell);\n\n          if (cell) {\n            memo.push(cell);\n          }\n        }\n\n        return memo;\n      }, []);\n      var excludedAncestors = [];\n      var source = model.getCell(edge.getSourceCellId());\n\n      if (source) {\n        excludedAncestors = ArrayExt.union(excludedAncestors, source.getAncestors().map(function (cell) {\n          return cell.id;\n        }));\n      }\n\n      var target = model.getCell(edge.getTargetCellId());\n\n      if (target) {\n        excludedAncestors = ArrayExt.union(excludedAncestors, target.getAncestors().map(function (cell) {\n          return cell.id;\n        }));\n      } // The graph is divided into smaller cells, where each holds information\n      // about which node belong to it. When we query whether a point lies\n      // inside an obstacle we don't need to go through all obstacles, we check\n      // only those in a particular cell.\n\n\n      var mapGridSize = this.mapGridSize;\n      model.getNodes().reduce(function (map, node) {\n        var shape = node.shape;\n        var excludeShapes = options.excludeShapes;\n        var excType = shape ? excludeShapes.includes(shape) : false;\n        var excTerminal = excludedTerminals.some(function (cell) {\n          return cell.id === node.id;\n        });\n        var excAncestor = excludedAncestors.includes(node.id);\n        var excHidden = options.excludeHiddenNodes && !node.isVisible();\n        var excluded = excType || excTerminal || excAncestor || excHidden;\n\n        if (!excluded) {\n          var bbox = node.getBBox().moveAndExpand(options.paddingBox);\n          var origin = bbox.getOrigin().snapToGrid(mapGridSize);\n          var corner = bbox.getCorner().snapToGrid(mapGridSize);\n\n          for (var x = origin.x; x <= corner.x; x += mapGridSize) {\n            for (var y = origin.y; y <= corner.y; y += mapGridSize) {\n              var key = new Point(x, y).toString();\n\n              if (map[key] == null) {\n                map[key] = [];\n              }\n\n              map[key].push(bbox);\n            }\n          }\n        }\n\n        return map;\n      }, this.map);\n      return this;\n    }\n  }, {\n    key: \"isAccessible\",\n    value: function isAccessible(point) {\n      var key = point.clone().snapToGrid(this.mapGridSize).toString();\n      var rects = this.map[key];\n      return rects ? rects.every(function (rect) {\n        return !rect.containsPoint(point);\n      }) : true;\n    }\n  }]);\n\n  return ObstacleMap;\n}();","map":{"version":3,"sources":["../../../../src/registry/router/manhattan/obstacle-map.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ArrayExt } from '../../../util';\nimport { Point } from '../../../geometry';\n/**\n * Helper structure to identify whether a point lies inside an obstacle.\n */\nexport class ObstacleMap {\n    constructor(options) {\n        this.options = options;\n        this.mapGridSize = 100;\n        this.map = {};\n    }\n    /**\n     * Builds a map of all nodes for quicker obstacle queries i.e. is a point\n     * contained in any obstacle?\n     *\n     * A simplified grid search.\n     */\n    build(model, edge) {\n        const options = this.options;\n        // source or target node could be excluded from set of obstacles\n        const excludedTerminals = options.excludeTerminals.reduce((memo, type) => {\n            const terminal = edge[type];\n            if (terminal) {\n                const cell = model.getCell(terminal.cell);\n                if (cell) {\n                    memo.push(cell);\n                }\n            }\n            return memo;\n        }, []);\n        let excludedAncestors = [];\n        const source = model.getCell(edge.getSourceCellId());\n        if (source) {\n            excludedAncestors = ArrayExt.union(excludedAncestors, source.getAncestors().map((cell) => cell.id));\n        }\n        const target = model.getCell(edge.getTargetCellId());\n        if (target) {\n            excludedAncestors = ArrayExt.union(excludedAncestors, target.getAncestors().map((cell) => cell.id));\n        }\n        // The graph is divided into smaller cells, where each holds information\n        // about which node belong to it. When we query whether a point lies\n        // inside an obstacle we don't need to go through all obstacles, we check\n        // only those in a particular cell.\n        const mapGridSize = this.mapGridSize;\n        model.getNodes().reduce((map, node) => {\n            const shape = node.shape;\n            const excludeShapes = options.excludeShapes;\n            const excType = shape ? excludeShapes.includes(shape) : false;\n            const excTerminal = excludedTerminals.some((cell) => cell.id === node.id);\n            const excAncestor = excludedAncestors.includes(node.id);\n            const excHidden = options.excludeHiddenNodes && !node.isVisible();\n            const excluded = excType || excTerminal || excAncestor || excHidden;\n            if (!excluded) {\n                const bbox = node.getBBox().moveAndExpand(options.paddingBox);\n                const origin = bbox.getOrigin().snapToGrid(mapGridSize);\n                const corner = bbox.getCorner().snapToGrid(mapGridSize);\n                for (let x = origin.x; x <= corner.x; x += mapGridSize) {\n                    for (let y = origin.y; y <= corner.y; y += mapGridSize) {\n                        const key = new Point(x, y).toString();\n                        if (map[key] == null) {\n                            map[key] = [];\n                        }\n                        map[key].push(bbox);\n                    }\n                }\n            }\n            return map;\n        }, this.map);\n        return this;\n    }\n    isAccessible(point) {\n        const key = point.clone().snapToGrid(this.mapGridSize).toString();\n        const rects = this.map[key];\n        return rects ? rects.every((rect) => !rect.containsPoint(point)) : true;\n    }\n}\n//# sourceMappingURL=obstacle-map.js.map"]},"metadata":{},"sourceType":"module"}