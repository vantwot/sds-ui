{"ast":null,"code":"var __awaiter = this && this.__awaiter || function (thisArg, _arguments, P, generator) {\n  function adopt(value) {\n    return value instanceof P ? value : new P(function (resolve) {\n      resolve(value);\n    });\n  }\n\n  return new (P || (P = Promise))(function (resolve, reject) {\n    function fulfilled(value) {\n      try {\n        step(generator.next(value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function rejected(value) {\n      try {\n        step(generator[\"throw\"](value));\n      } catch (e) {\n        reject(e);\n      }\n    }\n\n    function step(result) {\n      result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected);\n    }\n\n    step((generator = generator.apply(thisArg, _arguments || [])).next());\n  });\n};\n\nimport { ScheduleTypeEnum } from './interface';\nimport { ErrorUtils, HookUtils, Deferred } from './utils';\nexport { ScheduleTypeEnum } from './interface';\nexport class HookHub {\n  constructor(options) {\n    var _this = this;\n\n    /** scheduleType */\n    this.scheduleType = ScheduleTypeEnum.ASYNC_SRRIES;\n    /** hasRegistered */\n\n    this.hasHook = hookName => {\n      return this.hookMap.has(hookName);\n    };\n    /** getHooks */\n\n\n    this.getHooks = function () {\n      let runtimeHooks = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      let sort = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n      const hooks = HookUtils.normalize(runtimeHooks, _this.hookMap);\n\n      if (!sort) {\n        return hooks;\n      }\n\n      HookUtils.sort(hooks, _this.hookMap);\n      return hooks;\n    };\n    /** registerHook */\n\n\n    this.registerHook = hookMeta => {\n      if (this.hookMap.has(hookMeta.name)) {\n        console.error(`${hookMeta.name} is duplicated in hookmap`);\n      }\n\n      this.hookMap.set(hookMeta.name, hookMeta);\n      return {\n        dispose: () => {\n          this.hookMap.delete(hookMeta.name);\n        }\n      };\n    };\n    /** registerHook */\n\n\n    this.call = function (args) {\n      let main = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : mainArgs => __awaiter(_this, void 0, void 0, function* () {\n        return mainArgs;\n      });\n      let runtimeHook = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n      return __awaiter(_this, void 0, void 0, function* () {\n        // TODO: 这里加cache\n        const hooks = this.getHooks(runtimeHook);\n        const scheduler = this.schedulers[this.scheduleType];\n        return scheduler(args, main, hooks);\n      });\n    };\n    /** 执行hook的scheduler */\n\n\n    this.schedulers = {\n      /** pipeline执行 */\n      [ScheduleTypeEnum.ASYNC_SRRIES]: function (args, main) {\n        let hooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        return __awaiter(_this, void 0, void 0, function* () {\n          let callback = main;\n          /** 用 hook 加工 args  */\n\n          for (const hook of hooks) {\n            if ([0, 1].includes(hook.handler.length)) {\n              yield hook.handler.call(this, args);\n              continue;\n            }\n\n            if ([2].includes(hook.handler.length) && callback !== null) {\n              // eslint-disable-next-line @typescript-eslint/no-shadow\n              const result = yield hook.handler.call(this, args, callback);\n              /** 如果返回为null，则直接中断执行 */\n\n              if (result === null) {\n                callback = null;\n                break;\n              } else if (typeof result === 'function') {\n                callback = result;\n                continue;\n              }\n            }\n\n            const err = ErrorUtils.InvalidHookArguments(hook);\n            throw err;\n          }\n          /** 检查是否被替换为null */\n\n\n          if (callback) {\n            return yield callback.call(this, args);\n          }\n        });\n      },\n      [ScheduleTypeEnum.ASYNC_PARALLEL]: function (args, main) {\n        let hooks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n        return __awaiter(_this, void 0, void 0, function* () {\n          /** 同时触发 hook */\n          const promises = hooks.map(hook => {\n            if ([0, 1].includes(hook.handler.length)) {\n              return hook.handler.call(this, args);\n            }\n\n            if ([2].includes(hook.handler.length)) {\n              return hook.handler.call(this, args, main);\n            }\n\n            throw ErrorUtils.InvalidHookArguments(hook);\n          });\n          const defer = new Deferred();\n          Promise.all(promises).then(res => defer.resolve(res));\n          /** 检查是否被替换 */\n\n          if (main) {\n            return yield main.call(this, defer);\n          }\n        });\n      }\n    };\n    this.hookMap = new Map();\n\n    if (options && options.type) {\n      this.scheduleType = options.type;\n    }\n  }\n\n}","map":{"version":3,"sources":["../src/index.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { ScheduleTypeEnum } from './interface';\nimport { ErrorUtils, HookUtils, Deferred } from './utils';\nexport { ScheduleTypeEnum } from './interface';\nexport class HookHub {\n    constructor(options) {\n        /** scheduleType */\n        this.scheduleType = ScheduleTypeEnum.ASYNC_SRRIES;\n        /** hasRegistered */\n        this.hasHook = (hookName) => {\n            return this.hookMap.has(hookName);\n        };\n        /** getHooks */\n        this.getHooks = (runtimeHooks = [], sort = true) => {\n            const hooks = HookUtils.normalize(runtimeHooks, this.hookMap);\n            if (!sort) {\n                return hooks;\n            }\n            HookUtils.sort(hooks, this.hookMap);\n            return hooks;\n        };\n        /** registerHook */\n        this.registerHook = (hookMeta) => {\n            if (this.hookMap.has(hookMeta.name)) {\n                console.error(`${hookMeta.name} is duplicated in hookmap`);\n            }\n            this.hookMap.set(hookMeta.name, hookMeta);\n            return {\n                dispose: () => {\n                    this.hookMap.delete(hookMeta.name);\n                },\n            };\n        };\n        /** registerHook */\n        this.call = (args, main = (mainArgs) => __awaiter(this, void 0, void 0, function* () { return mainArgs; }), runtimeHook = []) => __awaiter(this, void 0, void 0, function* () {\n            // TODO: 这里加cache\n            const hooks = this.getHooks(runtimeHook);\n            const scheduler = this.schedulers[this.scheduleType];\n            return scheduler(args, main, hooks);\n        });\n        /** 执行hook的scheduler */\n        this.schedulers = {\n            /** pipeline执行 */\n            [ScheduleTypeEnum.ASYNC_SRRIES]: (args, main, hooks = []) => __awaiter(this, void 0, void 0, function* () {\n                let callback = main;\n                /** 用 hook 加工 args  */\n                for (const hook of hooks) {\n                    if ([0, 1].includes(hook.handler.length)) {\n                        yield hook.handler.call(this, args);\n                        continue;\n                    }\n                    if ([2].includes(hook.handler.length) && callback !== null) {\n                        // eslint-disable-next-line @typescript-eslint/no-shadow\n                        const result = yield hook.handler.call(this, args, callback);\n                        /** 如果返回为null，则直接中断执行 */\n                        if (result === null) {\n                            callback = null;\n                            break;\n                        }\n                        else if (typeof result === 'function') {\n                            callback = result;\n                            continue;\n                        }\n                    }\n                    const err = ErrorUtils.InvalidHookArguments(hook);\n                    throw err;\n                }\n                /** 检查是否被替换为null */\n                if (callback) {\n                    return yield callback.call(this, args);\n                }\n            }),\n            [ScheduleTypeEnum.ASYNC_PARALLEL]: (args, main, hooks = []) => __awaiter(this, void 0, void 0, function* () {\n                /** 同时触发 hook */\n                const promises = hooks.map(hook => {\n                    if ([0, 1].includes(hook.handler.length)) {\n                        return hook.handler.call(this, args);\n                    }\n                    if ([2].includes(hook.handler.length)) {\n                        return hook.handler.call(this, args, main);\n                    }\n                    throw ErrorUtils.InvalidHookArguments(hook);\n                });\n                const defer = new Deferred();\n                Promise.all(promises).then(res => defer.resolve(res));\n                /** 检查是否被替换 */\n                if (main) {\n                    return yield main.call(this, defer);\n                }\n            }),\n        };\n        this.hookMap = new Map();\n        if (options && options.type) {\n            this.scheduleType = options.type;\n        }\n    }\n}\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}