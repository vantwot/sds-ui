{"ast":null,"code":"import { ObjectExt, Dom } from '../../util';\nimport { Path, Rectangle, Ellipse } from '../../geometry';\nimport { offset, getStrokeWidth, findShapeNode } from './util';\n/**\n * Places the connection point at the intersection between the\n * edge path end segment and the actual shape of the target magnet.\n */\n\nexport var boundary = function boundary(line, view, magnet, options) {\n  var node;\n  var intersection;\n  var anchor = line.end;\n  var selector = options.selector;\n\n  if (typeof selector === 'string') {\n    node = view.findOne(selector);\n  } else if (Array.isArray(selector)) {\n    node = ObjectExt.getByPath(magnet, selector);\n  } else {\n    node = findShapeNode(magnet);\n  }\n\n  if (!Dom.isSVGGraphicsElement(node)) {\n    if (node === magnet || !Dom.isSVGGraphicsElement(magnet)) {\n      return anchor;\n    }\n\n    node = magnet;\n  }\n\n  var localShape = view.getShapeOfElement(node);\n  var magnetMatrix = view.getMatrixOfElement(node);\n  var translateMatrix = view.getRootTranslatedMatrix();\n  var rotateMatrix = view.getRootRotatedMatrix();\n  var targetMatrix = translateMatrix.multiply(rotateMatrix).multiply(magnetMatrix);\n  var localMatrix = targetMatrix.inverse();\n  var localLine = Dom.transformLine(line, localMatrix);\n  var localRef = localLine.start.clone();\n  var data = view.getDataOfElement(node);\n\n  if (options.insideout === false) {\n    if (data.shapeBBox == null) {\n      data.shapeBBox = localShape.bbox();\n    }\n\n    var localBBox = data.shapeBBox;\n\n    if (localBBox != null && localBBox.containsPoint(localRef)) {\n      return anchor;\n    }\n  }\n\n  if (options.extrapolate === true) {\n    localLine.setLength(1e6);\n  } // Caching segment subdivisions for paths\n\n\n  var pathOptions;\n\n  if (Path.isPath(localShape)) {\n    var precision = options.precision || 2;\n\n    if (data.segmentSubdivisions == null) {\n      data.segmentSubdivisions = localShape.getSegmentSubdivisions({\n        precision: precision\n      });\n    }\n\n    pathOptions = {\n      precision: precision,\n      segmentSubdivisions: data.segmentSubdivisions\n    };\n    intersection = localLine.intersect(localShape, pathOptions);\n  } else {\n    intersection = localLine.intersect(localShape);\n  }\n\n  if (intersection) {\n    if (Array.isArray(intersection)) {\n      intersection = localRef.closest(intersection);\n    }\n  } else if (options.sticky === true) {\n    // No intersection, find the closest point instead\n    if (Rectangle.isRectangle(localShape)) {\n      intersection = localShape.getNearestPointToPoint(localRef);\n    } else if (Ellipse.isEllipse(localShape)) {\n      intersection = localShape.intersectsWithLineFromCenterToPoint(localRef);\n    } else {\n      intersection = localShape.closestPoint(localRef, pathOptions);\n    }\n  }\n\n  var cp = intersection ? Dom.transformPoint(intersection, targetMatrix) : anchor;\n  var cpOffset = options.offset || 0;\n\n  if (options.stroked !== false) {\n    if (typeof cpOffset === 'object') {\n      cpOffset = Object.assign({}, cpOffset);\n\n      if (cpOffset.x == null) {\n        cpOffset.x = 0;\n      }\n\n      cpOffset.x += getStrokeWidth(node) / 2;\n    } else {\n      cpOffset += getStrokeWidth(node) / 2;\n    }\n  }\n\n  return offset(cp, line.start, cpOffset);\n};","map":{"version":3,"sources":["../../../src/registry/connection-point/boundary.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ObjectExt, Dom } from '../../util';\nimport { Path, Rectangle, Ellipse } from '../../geometry';\nimport { offset, getStrokeWidth, findShapeNode } from './util';\n/**\n * Places the connection point at the intersection between the\n * edge path end segment and the actual shape of the target magnet.\n */\nexport const boundary = function (line, view, magnet, options) {\n    let node;\n    let intersection;\n    const anchor = line.end;\n    const selector = options.selector;\n    if (typeof selector === 'string') {\n        node = view.findOne(selector);\n    }\n    else if (Array.isArray(selector)) {\n        node = ObjectExt.getByPath(magnet, selector);\n    }\n    else {\n        node = findShapeNode(magnet);\n    }\n    if (!Dom.isSVGGraphicsElement(node)) {\n        if (node === magnet || !Dom.isSVGGraphicsElement(magnet)) {\n            return anchor;\n        }\n        node = magnet;\n    }\n    const localShape = view.getShapeOfElement(node);\n    const magnetMatrix = view.getMatrixOfElement(node);\n    const translateMatrix = view.getRootTranslatedMatrix();\n    const rotateMatrix = view.getRootRotatedMatrix();\n    const targetMatrix = translateMatrix\n        .multiply(rotateMatrix)\n        .multiply(magnetMatrix);\n    const localMatrix = targetMatrix.inverse();\n    const localLine = Dom.transformLine(line, localMatrix);\n    const localRef = localLine.start.clone();\n    const data = view.getDataOfElement(node);\n    if (options.insideout === false) {\n        if (data.shapeBBox == null) {\n            data.shapeBBox = localShape.bbox();\n        }\n        const localBBox = data.shapeBBox;\n        if (localBBox != null && localBBox.containsPoint(localRef)) {\n            return anchor;\n        }\n    }\n    if (options.extrapolate === true) {\n        localLine.setLength(1e6);\n    }\n    // Caching segment subdivisions for paths\n    let pathOptions;\n    if (Path.isPath(localShape)) {\n        const precision = options.precision || 2;\n        if (data.segmentSubdivisions == null) {\n            data.segmentSubdivisions = localShape.getSegmentSubdivisions({\n                precision,\n            });\n        }\n        pathOptions = {\n            precision,\n            segmentSubdivisions: data.segmentSubdivisions,\n        };\n        intersection = localLine.intersect(localShape, pathOptions);\n    }\n    else {\n        intersection = localLine.intersect(localShape);\n    }\n    if (intersection) {\n        if (Array.isArray(intersection)) {\n            intersection = localRef.closest(intersection);\n        }\n    }\n    else if (options.sticky === true) {\n        // No intersection, find the closest point instead\n        if (Rectangle.isRectangle(localShape)) {\n            intersection = localShape.getNearestPointToPoint(localRef);\n        }\n        else if (Ellipse.isEllipse(localShape)) {\n            intersection = localShape.intersectsWithLineFromCenterToPoint(localRef);\n        }\n        else {\n            intersection = localShape.closestPoint(localRef, pathOptions);\n        }\n    }\n    const cp = intersection\n        ? Dom.transformPoint(intersection, targetMatrix)\n        : anchor;\n    let cpOffset = options.offset || 0;\n    if (options.stroked !== false) {\n        if (typeof cpOffset === 'object') {\n            cpOffset = Object.assign({}, cpOffset);\n            if (cpOffset.x == null) {\n                cpOffset.x = 0;\n            }\n            cpOffset.x += getStrokeWidth(node) / 2;\n        }\n        else {\n            cpOffset += getStrokeWidth(node) / 2;\n        }\n    }\n    return offset(cp, line.start, cpOffset);\n};\n//# sourceMappingURL=boundary.js.map"]},"metadata":{},"sourceType":"module"}