{"ast":null,"code":"/**\n * @fileOverview 自定义边\n * @description 自定义边中有大量逻辑同自定义节点重复，虽然可以提取成为 mixin ，但是考虑到代码的可读性，还是单独实现。\n */\nimport { __assign } from \"tslib\";\nimport { deepMix, mix, each, isNil, isNumber, isArray } from '@antv/util';\nimport { getLabelPosition, getLoopCfgs } from '../util/graphic';\nimport { distance, getCircleCenterByPoints } from '../util/math';\nimport { getControlPoint, getSpline } from '../util/path';\nimport Global from '../global';\nimport Shape from './shape';\nimport { shapeBase, CLS_LABEL_BG_SUFFIX } from './shapeBase';\nvar CLS_SHAPE = 'edge-shape'; // start,end 倒置，center 不变\n\nfunction revertAlign(labelPosition) {\n  var textAlign = labelPosition;\n\n  if (labelPosition === 'start') {\n    textAlign = 'end';\n  } else if (labelPosition === 'end') {\n    textAlign = 'start';\n  }\n\n  return textAlign;\n}\n\nvar singleEdge = {\n  itemType: 'edge',\n\n  /**\n   * 文本的位置\n   * @type {String}\n   */\n  labelPosition: 'center',\n\n  /**\n   * 文本的 x 偏移\n   * @type {Number}\n   */\n  refX: 0,\n\n  /**\n   * 文本的 y 偏移\n   * @type {Number}\n   */\n  refY: 0,\n\n  /**\n   * 文本是否跟着线自动旋转，默认 false\n   * @type {Boolean}\n   */\n  labelAutoRotate: false,\n  // 自定义边时的配置\n  options: {\n    size: Global.defaultEdge.size,\n    style: {\n      x: 0,\n      y: 0,\n      stroke: Global.defaultEdge.style.stroke,\n      lineAppendWidth: Global.defaultEdge.style.lineAppendWidth\n    },\n    labelCfg: {\n      style: {\n        fill: Global.edgeLabel.style.fill,\n        fontSize: Global.edgeLabel.style.fontSize,\n        fontFamily: Global.windowFontFamily\n      }\n    },\n    stateStyles: __assign({}, Global.edgeStateStyles)\n  },\n\n  /**\n   * 获取边的 path\n   * @internal 供扩展的边覆盖\n   * @param  {Array} points 构成边的点的集合\n   * @return {Array} 构成 path 的数组\n   */\n  getPath: function getPath(points) {\n    var path = [];\n    each(points, function (point, index) {\n      if (index === 0) {\n        path.push(['M', point.x, point.y]);\n      } else {\n        path.push(['L', point.x, point.y]);\n      }\n    });\n    return path;\n  },\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.options.style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = mix({}, defaultStyle, strokeStyle, cfg.style);\n    var size = cfg.size || Global.defaultEdge.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg);\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var path = this.getPath(points);\n    var styles = mix({}, Global.defaultEdge.style, {\n      stroke: Global.defaultEdge.color,\n      lineWidth: size,\n      path: path\n    }, style);\n    return styles;\n  },\n  updateShapeStyle: function updateShapeStyle(cfg, item, updateType) {\n    var _a;\n\n    var group = item.getContainer(); // const strokeStyle: ShapeStyle = {\n    //   stroke: cfg.color,\n    // };\n\n    var shape = ((_a = item.getKeyShape) === null || _a === void 0 ? void 0 : _a.call(item)) || group['shapeMap']['edge-shape']; // group.find((element) => element.get('className') === 'edge-shape');\n\n    var size = cfg.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;\n\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var currentAttr = shape.attr(); // const previousStyle = mix({}, strokeStyle, currentAttr, cfg.style);\n\n    var previousStyle = cfg.style || {};\n\n    if (previousStyle.stroke === undefined) {\n      previousStyle.stroke = cfg.color;\n    }\n\n    var source = cfg.sourceNode;\n    var target = cfg.targetNode;\n    var routeCfg = {\n      radius: previousStyle.radius\n    };\n\n    if (!controlPoints) {\n      routeCfg = {\n        source: source,\n        target: target,\n        offset: previousStyle.offset,\n        radius: previousStyle.radius\n      };\n    }\n\n    var path = this.getPath(points, routeCfg);\n    var style = {};\n\n    if (updateType === 'move') {\n      style = {\n        path: path\n      };\n    } else {\n      if (currentAttr.endArrow && previousStyle.endArrow === false) {\n        cfg.style.endArrow = {\n          path: ''\n        };\n      }\n\n      if (currentAttr.startArrow && previousStyle.startArrow === false) {\n        cfg.style.startArrow = {\n          path: ''\n        };\n      }\n\n      style = __assign({}, cfg.style);\n      if (style.lineWidth === undefined) style.lineWdith = (isNumber(size) ? size : size === null || size === void 0 ? void 0 : size[0]) || currentAttr.lineWidth;\n      if (style.path === undefined) style.path = path;\n      if (style.stroke === undefined) style.stroke = currentAttr.stroke || cfg.color;\n    }\n\n    if (shape) {\n      shape.attr(style);\n    }\n  },\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {\n    var labelPosition = labelCfg.position || this.labelPosition; // 文本的位置用户可以传入\n\n    var style = {};\n    var pathShape = group === null || group === void 0 ? void 0 : group['shapeMap'][CLS_SHAPE]; // group?.find((element) => element.get('className') === CLS_SHAPE);\n    // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      style.text = cfg.label;\n      return style;\n    }\n\n    var autoRotate;\n    if (isNil(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;else autoRotate = labelCfg.autoRotate;\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX, offsetY, autoRotate);\n    style.x = offsetStyle.x;\n    style.y = offsetStyle.y;\n    style.rotate = offsetStyle.rotate;\n    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);\n    style.text = cfg.label;\n    return style;\n  },\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\n    if (!label) {\n      return {};\n    }\n\n    var bbox = label.getBBox();\n    var backgroundStyle = labelCfg.style && labelCfg.style.background;\n\n    if (!backgroundStyle) {\n      return {};\n    }\n\n    var padding = backgroundStyle.padding;\n    var backgroundWidth = bbox.width + padding[1] + padding[3];\n    var backgroundHeight = bbox.height + padding[0] + padding[2];\n    var labelPosition = labelCfg.position || this.labelPosition;\n\n    var style = __assign(__assign({}, backgroundStyle), {\n      width: backgroundWidth,\n      height: backgroundHeight,\n      x: bbox.minX - padding[2],\n      y: bbox.minY - padding[0],\n      rotate: 0\n    });\n\n    var autoRotate;\n    if (isNil(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;else autoRotate = labelCfg.autoRotate;\n    var pathShape = group === null || group === void 0 ? void 0 : group['shapeMap'][CLS_SHAPE]; // group?.find((element) => element.get('className') === CLS_SHAPE);\n    // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX - backgroundWidth / 2;\n      style.y = cfg.startPoint.y + offsetY - backgroundHeight / 2;\n      return style;\n    }\n\n    var bgOffsetX = offsetX - backgroundWidth / 2;\n\n    if (labelCfg.position === 'start') {\n      bgOffsetX = offsetX - padding[2];\n    } else if (labelCfg.position === 'end') {\n      bgOffsetX = offsetX - backgroundWidth;\n    }\n\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, bgOffsetX, offsetY + backgroundHeight / 2, autoRotate);\n\n    if (autoRotate) {\n      style.x = offsetStyle.x;\n      style.y = offsetStyle.y;\n    }\n\n    style.rotate = offsetStyle.rotate;\n    return style;\n  },\n  // 获取文本对齐方式\n  _getTextAlign: function _getTextAlign(labelPosition, angle) {\n    var textAlign = 'center';\n\n    if (!angle) {\n      return labelPosition;\n    }\n\n    angle = angle % (Math.PI * 2); // 取模\n\n    if (labelPosition !== 'center') {\n      if (angle >= 0 && angle <= Math.PI / 2 || angle >= 3 / 2 * Math.PI && angle < 2 * Math.PI) {\n        textAlign = labelPosition;\n      } else {\n        textAlign = revertAlign(labelPosition);\n      }\n    }\n\n    return textAlign;\n  },\n\n  /**\n   * @internal 获取边的控制点\n   * @param  {Object} cfg 边的配置项\n   * @return {Array} 控制点的数组\n   */\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n\n  /**\n   * @internal 处理需要重计算点和边的情况\n   * @param {Object} cfg 边的配置项\n   * @return {Object} 边的配置项\n   */\n  getPathPoints: function getPathPoints(cfg) {\n    return cfg;\n  },\n\n  /**\n   * 绘制边\n   * @override\n   * @param  {Object} cfg   边的配置项\n   * @param  {G.Group} group 边的容器\n   * @return {IShape} 图形\n   */\n  drawShape: function drawShape(cfg, group) {\n    var shapeStyle = this.getShapeStyle(cfg);\n    var shape = group.addShape('path', {\n      className: CLS_SHAPE,\n      name: CLS_SHAPE,\n      attrs: shapeStyle\n    });\n    group['shapeMap'][CLS_SHAPE] = shape;\n    return shape;\n  },\n  drawLabel: function drawLabel(cfg, group) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({}, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    delete labelStyle.rotate;\n    var label = group.addShape('text', {\n      attrs: labelStyle,\n      name: 'text-shape'\n    });\n    group['shapeMap']['text-shape'] = label;\n\n    if (!isNaN(rotate) && rotate !== '') {\n      label.rotateAtStart(rotate);\n    }\n\n    if (labelStyle.background) {\n      var rect = this.drawLabelBg(cfg, group, label, labelStyle, rotate);\n      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;\n      rect.set('classname', labelBgClassname);\n      group['shapeMap'][labelBgClassname] = rect;\n      label.toFront();\n    }\n\n    return label;\n  },\n  drawLabelBg: function drawLabelBg(cfg, group, label, labelStyle, rotate) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({}, defaultLabelCfg, cfg.labelCfg);\n    var style = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\n    delete style.rotate;\n    var rect = group.addShape('rect', {\n      name: 'text-bg-shape',\n      attrs: style\n    });\n    group['shapeMap']['text-bg-shape'] = rect;\n    if (!isNaN(rotate)) rect.rotateAtStart(rotate);\n    return rect;\n  }\n};\n\nvar singleEdgeDef = __assign(__assign({}, shapeBase), singleEdge);\n\nShape.registerEdge('single-edge', singleEdgeDef); // 直线, 不支持控制点\n\nShape.registerEdge('line', {\n  // 控制点不生效\n  getControlPoints: function getControlPoints() {\n    return undefined;\n  }\n}, 'single-edge'); // 直线\n\nShape.registerEdge('spline', {\n  getPath: function getPath(points) {\n    var path = getSpline(points);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('arc', {\n  curveOffset: 20,\n  clockwise: 1,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var midPoint = {\n      x: (startPoint.x + endPoint.x) / 2,\n      y: (startPoint.y + endPoint.y) / 2\n    };\n    var center;\n    var arcPoint; // 根据给定点计算圆弧\n\n    if (cfg.controlPoints !== undefined) {\n      arcPoint = cfg.controlPoints[0];\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint); // 根据控制点和直线关系决定 clockwise值\n\n      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 0 : 1;\n      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 1 : 0;\n      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {\n        this.clockwise = center.y < arcPoint.y ? 0 : 1;\n      } else {\n        this.clockwise = center.y < arcPoint.y ? 1 : 0;\n      } // 若给定点和两端点共线，无法生成圆弧，绘制直线\n\n\n      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {\n        return [];\n      }\n    } else {\n      // 根据直线连线中点的的偏移计算圆弧\n      // 若用户给定偏移量则根据其计算，否则按照默认偏移值计算\n      if (cfg.curveOffset === undefined) {\n        cfg.curveOffset = this.curveOffset;\n      }\n\n      if (isArray(cfg.curveOffset)) {\n        cfg.curveOffset = cfg.curveOffset[0];\n      }\n\n      if (cfg.curveOffset < 0) {\n        this.clockwise = 0;\n      } else {\n        this.clockwise = 1;\n      }\n\n      var vec = {\n        x: endPoint.x - startPoint.x,\n        y: endPoint.y - startPoint.y\n      };\n      var edgeAngle = Math.atan2(vec.y, vec.x);\n      arcPoint = {\n        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint.x,\n        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint.y\n      };\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);\n    }\n\n    var radius = distance(startPoint, center);\n    var controlPoints = [{\n      x: radius,\n      y: radius\n    }];\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]); // 控制点与端点共线\n\n    if (points.length === 2) {\n      path.push(['L', points[1].x, points[1].y]);\n    } else {\n      path.push(['A', points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);\n    }\n\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('quadratic', {\n  curvePosition: 0.5,\n  curveOffset: -20,\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (!controlPoints || !controlPoints.length) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n      if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n      if (isArray(this.curveOffset)) cfg.curveOffset = cfg.curveOffset[0];\n      if (isArray(this.curvePosition)) cfg.curvePosition = cfg.curveOffset[0];\n      var innerPoint = getControlPoint(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);\n      controlPoints = [innerPoint];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['Q', points[1].x, points[1].y, points[2].x, points[2].y]);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('cubic', {\n  curvePosition: [1 / 2, 1 / 2],\n  curveOffset: [-20, 20],\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定 controlPoints\n\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (isNumber(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if (isNumber(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n\n    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      var innerPoint1 = getControlPoint(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);\n      var innerPoint2 = getControlPoint(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);\n      controlPoints = [innerPoint1, innerPoint2];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);\n    return path;\n  }\n}, 'single-edge'); // 垂直方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-vertical', {\n  curvePosition: [1 / 2, 1 / 2],\n  minCurveOffset: [0, 0],\n  curveOffset: undefined,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.minCurveOffset === undefined) cfg.minCurveOffset = this.minCurveOffset;\n    if (isNumber(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if (isNumber(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];\n    if (isNumber(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n    var yDist = endPoint.y - startPoint.y;\n    var curveOffset = [0, 0];\n\n    if (cfg.curveOffset) {\n      curveOffset = cfg.curveOffset;\n    } else if (Math.abs(yDist) < Math.abs(cfg.minCurveOffset[0])) {\n      curveOffset = cfg.minCurveOffset;\n    }\n\n    var innerPoint1 = {\n      x: startPoint.x,\n      y: startPoint.y + yDist * this.curvePosition[0] + curveOffset[0]\n    };\n    var innerPoint2 = {\n      x: endPoint.x,\n      y: endPoint.y - yDist * this.curvePosition[1] + curveOffset[1]\n    };\n    return [innerPoint1, innerPoint2];\n  }\n}, 'cubic'); // 水平方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-horizontal', {\n  curvePosition: [1 / 2, 1 / 2],\n  minCurveOffset: [0, 0],\n  curveOffset: undefined,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.minCurveOffset === undefined) cfg.minCurveOffset = this.minCurveOffset;\n    if (isNumber(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if (isNumber(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];\n    if (isNumber(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n    var xDist = endPoint.x - startPoint.x;\n    var curveOffset = [0, 0];\n\n    if (cfg.curveOffset) {\n      curveOffset = cfg.curveOffset;\n    } else if (Math.abs(xDist) < Math.abs(cfg.minCurveOffset[0])) {\n      curveOffset = cfg.minCurveOffset;\n    }\n\n    var innerPoint1 = {\n      x: startPoint.x + xDist * this.curvePosition[0] + curveOffset[0],\n      y: startPoint.y\n    };\n    var innerPoint2 = {\n      x: endPoint.x - xDist * this.curvePosition[1] + curveOffset[1],\n      y: endPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic');\nShape.registerEdge('loop', {\n  getPathPoints: function getPathPoints(cfg) {\n    return getLoopCfgs(cfg);\n  },\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n  afterDraw: function afterDraw(cfg) {\n    cfg.controlPoints = undefined;\n  },\n  afterUpdate: function afterUpdate(cfg) {\n    cfg.controlPoints = undefined;\n  }\n}, 'cubic');","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/@antv/g6-core/es/element/edge.js"],"names":["__assign","deepMix","mix","each","isNil","isNumber","isArray","getLabelPosition","getLoopCfgs","distance","getCircleCenterByPoints","getControlPoint","getSpline","Global","Shape","shapeBase","CLS_LABEL_BG_SUFFIX","CLS_SHAPE","revertAlign","labelPosition","textAlign","singleEdge","itemType","refX","refY","labelAutoRotate","options","size","defaultEdge","style","x","y","stroke","lineAppendWidth","labelCfg","fill","edgeLabel","fontSize","fontFamily","windowFontFamily","stateStyles","edgeStateStyles","getPath","points","path","point","index","push","getShapeStyle","cfg","defaultStyle","strokeStyle","color","getPathPoints","startPoint","endPoint","controlPoints","getControlPoints","concat","styles","lineWidth","updateShapeStyle","item","updateType","_a","group","getContainer","shape","getKeyShape","call","currentAttr","attr","previousStyle","undefined","source","sourceNode","target","targetNode","routeCfg","radius","offset","endArrow","startArrow","lineWdith","getLabelStyleByPosition","position","pathShape","pointPercent","offsetX","offsetY","text","label","autoRotate","offsetStyle","rotate","_getTextAlign","angle","getLabelBgStyleByPosition","bbox","getBBox","backgroundStyle","background","padding","backgroundWidth","width","backgroundHeight","height","minX","minY","bgOffsetX","Math","PI","drawShape","shapeStyle","addShape","className","name","attrs","drawLabel","defaultLabelCfg","labelStyle","getLabelStyle","isNaN","rotateAtStart","rect","drawLabelBg","labelBgClassname","set","toFront","singleEdgeDef","registerEdge","curveOffset","clockwise","midPoint","center","arcPoint","vec","edgeAngle","atan2","cos","sin","length","curvePosition","innerPoint","innerPoint1","innerPoint2","minCurveOffset","yDist","abs","xDist","afterDraw","afterUpdate"],"mappings":"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","sourcesContent":["/**\n * @fileOverview 自定义边\n * @description 自定义边中有大量逻辑同自定义节点重复，虽然可以提取成为 mixin ，但是考虑到代码的可读性，还是单独实现。\n */\nimport { __assign } from \"tslib\";\nimport { deepMix, mix, each, isNil, isNumber, isArray } from '@antv/util';\nimport { getLabelPosition, getLoopCfgs } from '../util/graphic';\nimport { distance, getCircleCenterByPoints } from '../util/math';\nimport { getControlPoint, getSpline } from '../util/path';\nimport Global from '../global';\nimport Shape from './shape';\nimport { shapeBase, CLS_LABEL_BG_SUFFIX } from './shapeBase';\nvar CLS_SHAPE = 'edge-shape'; // start,end 倒置，center 不变\n\nfunction revertAlign(labelPosition) {\n  var textAlign = labelPosition;\n\n  if (labelPosition === 'start') {\n    textAlign = 'end';\n  } else if (labelPosition === 'end') {\n    textAlign = 'start';\n  }\n\n  return textAlign;\n}\n\nvar singleEdge = {\n  itemType: 'edge',\n\n  /**\n   * 文本的位置\n   * @type {String}\n   */\n  labelPosition: 'center',\n\n  /**\n   * 文本的 x 偏移\n   * @type {Number}\n   */\n  refX: 0,\n\n  /**\n   * 文本的 y 偏移\n   * @type {Number}\n   */\n  refY: 0,\n\n  /**\n   * 文本是否跟着线自动旋转，默认 false\n   * @type {Boolean}\n   */\n  labelAutoRotate: false,\n  // 自定义边时的配置\n  options: {\n    size: Global.defaultEdge.size,\n    style: {\n      x: 0,\n      y: 0,\n      stroke: Global.defaultEdge.style.stroke,\n      lineAppendWidth: Global.defaultEdge.style.lineAppendWidth\n    },\n    labelCfg: {\n      style: {\n        fill: Global.edgeLabel.style.fill,\n        fontSize: Global.edgeLabel.style.fontSize,\n        fontFamily: Global.windowFontFamily\n      }\n    },\n    stateStyles: __assign({}, Global.edgeStateStyles)\n  },\n\n  /**\n   * 获取边的 path\n   * @internal 供扩展的边覆盖\n   * @param  {Array} points 构成边的点的集合\n   * @return {Array} 构成 path 的数组\n   */\n  getPath: function getPath(points) {\n    var path = [];\n    each(points, function (point, index) {\n      if (index === 0) {\n        path.push(['M', point.x, point.y]);\n      } else {\n        path.push(['L', point.x, point.y]);\n      }\n    });\n    return path;\n  },\n  getShapeStyle: function getShapeStyle(cfg) {\n    var defaultStyle = this.options.style;\n    var strokeStyle = {\n      stroke: cfg.color\n    }; // 如果设置了color，则覆盖默认的stroke属性\n\n    var style = mix({}, defaultStyle, strokeStyle, cfg.style);\n    var size = cfg.size || Global.defaultEdge.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg);\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var path = this.getPath(points);\n    var styles = mix({}, Global.defaultEdge.style, {\n      stroke: Global.defaultEdge.color,\n      lineWidth: size,\n      path: path\n    }, style);\n    return styles;\n  },\n  updateShapeStyle: function updateShapeStyle(cfg, item, updateType) {\n    var _a;\n\n    var group = item.getContainer(); // const strokeStyle: ShapeStyle = {\n    //   stroke: cfg.color,\n    // };\n\n    var shape = ((_a = item.getKeyShape) === null || _a === void 0 ? void 0 : _a.call(item)) || group['shapeMap']['edge-shape']; // group.find((element) => element.get('className') === 'edge-shape');\n\n    var size = cfg.size;\n    cfg = this.getPathPoints(cfg);\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var controlPoints = this.getControlPoints(cfg); // || cfg.controlPoints;\n\n    var points = [startPoint]; // 添加起始点\n    // 添加控制点\n\n    if (controlPoints) {\n      points = points.concat(controlPoints);\n    } // 添加结束点\n\n\n    points.push(endPoint);\n    var currentAttr = shape.attr(); // const previousStyle = mix({}, strokeStyle, currentAttr, cfg.style);\n\n    var previousStyle = cfg.style || {};\n\n    if (previousStyle.stroke === undefined) {\n      previousStyle.stroke = cfg.color;\n    }\n\n    var source = cfg.sourceNode;\n    var target = cfg.targetNode;\n    var routeCfg = {\n      radius: previousStyle.radius\n    };\n\n    if (!controlPoints) {\n      routeCfg = {\n        source: source,\n        target: target,\n        offset: previousStyle.offset,\n        radius: previousStyle.radius\n      };\n    }\n\n    var path = this.getPath(points, routeCfg);\n    var style = {};\n\n    if (updateType === 'move') {\n      style = {\n        path: path\n      };\n    } else {\n      if (currentAttr.endArrow && previousStyle.endArrow === false) {\n        cfg.style.endArrow = {\n          path: ''\n        };\n      }\n\n      if (currentAttr.startArrow && previousStyle.startArrow === false) {\n        cfg.style.startArrow = {\n          path: ''\n        };\n      }\n\n      style = __assign({}, cfg.style);\n      if (style.lineWidth === undefined) style.lineWdith = (isNumber(size) ? size : size === null || size === void 0 ? void 0 : size[0]) || currentAttr.lineWidth;\n      if (style.path === undefined) style.path = path;\n      if (style.stroke === undefined) style.stroke = currentAttr.stroke || cfg.color;\n    }\n\n    if (shape) {\n      shape.attr(style);\n    }\n  },\n  getLabelStyleByPosition: function getLabelStyleByPosition(cfg, labelCfg, group) {\n    var labelPosition = labelCfg.position || this.labelPosition; // 文本的位置用户可以传入\n\n    var style = {};\n    var pathShape = group === null || group === void 0 ? void 0 : group['shapeMap'][CLS_SHAPE]; // group?.find((element) => element.get('className') === CLS_SHAPE);\n    // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX;\n      style.y = cfg.startPoint.y + offsetY;\n      style.text = cfg.label;\n      return style;\n    }\n\n    var autoRotate;\n    if (isNil(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;else autoRotate = labelCfg.autoRotate;\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, offsetX, offsetY, autoRotate);\n    style.x = offsetStyle.x;\n    style.y = offsetStyle.y;\n    style.rotate = offsetStyle.rotate;\n    style.textAlign = this._getTextAlign(labelPosition, offsetStyle.angle);\n    style.text = cfg.label;\n    return style;\n  },\n  getLabelBgStyleByPosition: function getLabelBgStyleByPosition(label, cfg, labelCfg, group) {\n    if (!label) {\n      return {};\n    }\n\n    var bbox = label.getBBox();\n    var backgroundStyle = labelCfg.style && labelCfg.style.background;\n\n    if (!backgroundStyle) {\n      return {};\n    }\n\n    var padding = backgroundStyle.padding;\n    var backgroundWidth = bbox.width + padding[1] + padding[3];\n    var backgroundHeight = bbox.height + padding[0] + padding[2];\n    var labelPosition = labelCfg.position || this.labelPosition;\n\n    var style = __assign(__assign({}, backgroundStyle), {\n      width: backgroundWidth,\n      height: backgroundHeight,\n      x: bbox.minX - padding[2],\n      y: bbox.minY - padding[0],\n      rotate: 0\n    });\n\n    var autoRotate;\n    if (isNil(labelCfg.autoRotate)) autoRotate = this.labelAutoRotate;else autoRotate = labelCfg.autoRotate;\n    var pathShape = group === null || group === void 0 ? void 0 : group['shapeMap'][CLS_SHAPE]; // group?.find((element) => element.get('className') === CLS_SHAPE);\n    // 不对 pathShape 进行判空，如果线不存在，说明有问题了\n\n    var pointPercent;\n\n    if (labelPosition === 'start') {\n      pointPercent = 0;\n    } else if (labelPosition === 'end') {\n      pointPercent = 1;\n    } else {\n      pointPercent = 0.5;\n    } // 偏移量\n\n\n    var offsetX = labelCfg.refX || this.refX;\n    var offsetY = labelCfg.refY || this.refY; // // 如果两个节点重叠，线就变成了一个点，这时候label的位置，就是这个点 + 绝对偏移\n\n    if (cfg.startPoint.x === cfg.endPoint.x && cfg.startPoint.y === cfg.endPoint.y) {\n      style.x = cfg.startPoint.x + offsetX - backgroundWidth / 2;\n      style.y = cfg.startPoint.y + offsetY - backgroundHeight / 2;\n      return style;\n    }\n\n    var bgOffsetX = offsetX - backgroundWidth / 2;\n\n    if (labelCfg.position === 'start') {\n      bgOffsetX = offsetX - padding[2];\n    } else if (labelCfg.position === 'end') {\n      bgOffsetX = offsetX - backgroundWidth;\n    }\n\n    var offsetStyle = getLabelPosition(pathShape, pointPercent, bgOffsetX, offsetY + backgroundHeight / 2, autoRotate);\n\n    if (autoRotate) {\n      style.x = offsetStyle.x;\n      style.y = offsetStyle.y;\n    }\n\n    style.rotate = offsetStyle.rotate;\n    return style;\n  },\n  // 获取文本对齐方式\n  _getTextAlign: function _getTextAlign(labelPosition, angle) {\n    var textAlign = 'center';\n\n    if (!angle) {\n      return labelPosition;\n    }\n\n    angle = angle % (Math.PI * 2); // 取模\n\n    if (labelPosition !== 'center') {\n      if (angle >= 0 && angle <= Math.PI / 2 || angle >= 3 / 2 * Math.PI && angle < 2 * Math.PI) {\n        textAlign = labelPosition;\n      } else {\n        textAlign = revertAlign(labelPosition);\n      }\n    }\n\n    return textAlign;\n  },\n\n  /**\n   * @internal 获取边的控制点\n   * @param  {Object} cfg 边的配置项\n   * @return {Array} 控制点的数组\n   */\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n\n  /**\n   * @internal 处理需要重计算点和边的情况\n   * @param {Object} cfg 边的配置项\n   * @return {Object} 边的配置项\n   */\n  getPathPoints: function getPathPoints(cfg) {\n    return cfg;\n  },\n\n  /**\n   * 绘制边\n   * @override\n   * @param  {Object} cfg   边的配置项\n   * @param  {G.Group} group 边的容器\n   * @return {IShape} 图形\n   */\n  drawShape: function drawShape(cfg, group) {\n    var shapeStyle = this.getShapeStyle(cfg);\n    var shape = group.addShape('path', {\n      className: CLS_SHAPE,\n      name: CLS_SHAPE,\n      attrs: shapeStyle\n    });\n    group['shapeMap'][CLS_SHAPE] = shape;\n    return shape;\n  },\n  drawLabel: function drawLabel(cfg, group) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({}, defaultLabelCfg, cfg.labelCfg);\n    var labelStyle = this.getLabelStyle(cfg, labelCfg, group);\n    var rotate = labelStyle.rotate;\n    delete labelStyle.rotate;\n    var label = group.addShape('text', {\n      attrs: labelStyle,\n      name: 'text-shape'\n    });\n    group['shapeMap']['text-shape'] = label;\n\n    if (!isNaN(rotate) && rotate !== '') {\n      label.rotateAtStart(rotate);\n    }\n\n    if (labelStyle.background) {\n      var rect = this.drawLabelBg(cfg, group, label, labelStyle, rotate);\n      var labelBgClassname = this.itemType + CLS_LABEL_BG_SUFFIX;\n      rect.set('classname', labelBgClassname);\n      group['shapeMap'][labelBgClassname] = rect;\n      label.toFront();\n    }\n\n    return label;\n  },\n  drawLabelBg: function drawLabelBg(cfg, group, label, labelStyle, rotate) {\n    var defaultLabelCfg = this.options.labelCfg;\n    var labelCfg = deepMix({}, defaultLabelCfg, cfg.labelCfg);\n    var style = this.getLabelBgStyleByPosition(label, cfg, labelCfg, group);\n    delete style.rotate;\n    var rect = group.addShape('rect', {\n      name: 'text-bg-shape',\n      attrs: style\n    });\n    group['shapeMap']['text-bg-shape'] = rect;\n    if (!isNaN(rotate)) rect.rotateAtStart(rotate);\n    return rect;\n  }\n};\n\nvar singleEdgeDef = __assign(__assign({}, shapeBase), singleEdge);\n\nShape.registerEdge('single-edge', singleEdgeDef); // 直线, 不支持控制点\n\nShape.registerEdge('line', {\n  // 控制点不生效\n  getControlPoints: function getControlPoints() {\n    return undefined;\n  }\n}, 'single-edge'); // 直线\n\nShape.registerEdge('spline', {\n  getPath: function getPath(points) {\n    var path = getSpline(points);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('arc', {\n  curveOffset: 20,\n  clockwise: 1,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    var midPoint = {\n      x: (startPoint.x + endPoint.x) / 2,\n      y: (startPoint.y + endPoint.y) / 2\n    };\n    var center;\n    var arcPoint; // 根据给定点计算圆弧\n\n    if (cfg.controlPoints !== undefined) {\n      arcPoint = cfg.controlPoints[0];\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint); // 根据控制点和直线关系决定 clockwise值\n\n      if (startPoint.x <= endPoint.x && startPoint.y > endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 0 : 1;\n      } else if (startPoint.x <= endPoint.x && startPoint.y < endPoint.y) {\n        this.clockwise = center.x > arcPoint.x ? 1 : 0;\n      } else if (startPoint.x > endPoint.x && startPoint.y <= endPoint.y) {\n        this.clockwise = center.y < arcPoint.y ? 0 : 1;\n      } else {\n        this.clockwise = center.y < arcPoint.y ? 1 : 0;\n      } // 若给定点和两端点共线，无法生成圆弧，绘制直线\n\n\n      if ((arcPoint.x - startPoint.x) / (arcPoint.y - startPoint.y) === (endPoint.x - startPoint.x) / (endPoint.y - startPoint.y)) {\n        return [];\n      }\n    } else {\n      // 根据直线连线中点的的偏移计算圆弧\n      // 若用户给定偏移量则根据其计算，否则按照默认偏移值计算\n      if (cfg.curveOffset === undefined) {\n        cfg.curveOffset = this.curveOffset;\n      }\n\n      if (isArray(cfg.curveOffset)) {\n        cfg.curveOffset = cfg.curveOffset[0];\n      }\n\n      if (cfg.curveOffset < 0) {\n        this.clockwise = 0;\n      } else {\n        this.clockwise = 1;\n      }\n\n      var vec = {\n        x: endPoint.x - startPoint.x,\n        y: endPoint.y - startPoint.y\n      };\n      var edgeAngle = Math.atan2(vec.y, vec.x);\n      arcPoint = {\n        x: cfg.curveOffset * Math.cos(-Math.PI / 2 + edgeAngle) + midPoint.x,\n        y: cfg.curveOffset * Math.sin(-Math.PI / 2 + edgeAngle) + midPoint.y\n      };\n      center = getCircleCenterByPoints(startPoint, arcPoint, endPoint);\n    }\n\n    var radius = distance(startPoint, center);\n    var controlPoints = [{\n      x: radius,\n      y: radius\n    }];\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]); // 控制点与端点共线\n\n    if (points.length === 2) {\n      path.push(['L', points[1].x, points[1].y]);\n    } else {\n      path.push(['A', points[1].x, points[1].y, 0, 0, this.clockwise, points[2].x, points[2].y]);\n    }\n\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('quadratic', {\n  curvePosition: 0.5,\n  curveOffset: -20,\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定controlPoints\n\n    if (!controlPoints || !controlPoints.length) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n      if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n      if (isArray(this.curveOffset)) cfg.curveOffset = cfg.curveOffset[0];\n      if (isArray(this.curvePosition)) cfg.curvePosition = cfg.curveOffset[0];\n      var innerPoint = getControlPoint(startPoint, endPoint, cfg.curvePosition, cfg.curveOffset);\n      controlPoints = [innerPoint];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['Q', points[1].x, points[1].y, points[2].x, points[2].y]);\n    return path;\n  }\n}, 'single-edge');\nShape.registerEdge('cubic', {\n  curvePosition: [1 / 2, 1 / 2],\n  curveOffset: [-20, 20],\n  getControlPoints: function getControlPoints(cfg) {\n    var controlPoints = cfg.controlPoints; // 指定 controlPoints\n\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (isNumber(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if (isNumber(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n\n    if (!controlPoints || !controlPoints.length || controlPoints.length < 2) {\n      var startPoint = cfg.startPoint,\n          endPoint = cfg.endPoint;\n      var innerPoint1 = getControlPoint(startPoint, endPoint, cfg.curvePosition[0], cfg.curveOffset[0]);\n      var innerPoint2 = getControlPoint(startPoint, endPoint, cfg.curvePosition[1], cfg.curveOffset[1]);\n      controlPoints = [innerPoint1, innerPoint2];\n    }\n\n    return controlPoints;\n  },\n  getPath: function getPath(points) {\n    var path = [];\n    path.push(['M', points[0].x, points[0].y]);\n    path.push(['C', points[1].x, points[1].y, points[2].x, points[2].y, points[3].x, points[3].y]);\n    return path;\n  }\n}, 'single-edge'); // 垂直方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-vertical', {\n  curvePosition: [1 / 2, 1 / 2],\n  minCurveOffset: [0, 0],\n  curveOffset: undefined,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.minCurveOffset === undefined) cfg.minCurveOffset = this.minCurveOffset;\n    if (isNumber(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if (isNumber(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];\n    if (isNumber(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n    var yDist = endPoint.y - startPoint.y;\n    var curveOffset = [0, 0];\n\n    if (cfg.curveOffset) {\n      curveOffset = cfg.curveOffset;\n    } else if (Math.abs(yDist) < Math.abs(cfg.minCurveOffset[0])) {\n      curveOffset = cfg.minCurveOffset;\n    }\n\n    var innerPoint1 = {\n      x: startPoint.x,\n      y: startPoint.y + yDist * this.curvePosition[0] + curveOffset[0]\n    };\n    var innerPoint2 = {\n      x: endPoint.x,\n      y: endPoint.y - yDist * this.curvePosition[1] + curveOffset[1]\n    };\n    return [innerPoint1, innerPoint2];\n  }\n}, 'cubic'); // 水平方向的三阶贝塞尔曲线，不再考虑用户外部传入的控制点\n\nShape.registerEdge('cubic-horizontal', {\n  curvePosition: [1 / 2, 1 / 2],\n  minCurveOffset: [0, 0],\n  curveOffset: undefined,\n  getControlPoints: function getControlPoints(cfg) {\n    var startPoint = cfg.startPoint,\n        endPoint = cfg.endPoint;\n    if (cfg.curvePosition === undefined) cfg.curvePosition = this.curvePosition;\n    if (cfg.curveOffset === undefined) cfg.curveOffset = this.curveOffset;\n    if (cfg.minCurveOffset === undefined) cfg.minCurveOffset = this.minCurveOffset;\n    if (isNumber(cfg.curveOffset)) cfg.curveOffset = [cfg.curveOffset, -cfg.curveOffset];\n    if (isNumber(cfg.minCurveOffset)) cfg.minCurveOffset = [cfg.minCurveOffset, -cfg.minCurveOffset];\n    if (isNumber(cfg.curvePosition)) cfg.curvePosition = [cfg.curvePosition, 1 - cfg.curvePosition];\n    var xDist = endPoint.x - startPoint.x;\n    var curveOffset = [0, 0];\n\n    if (cfg.curveOffset) {\n      curveOffset = cfg.curveOffset;\n    } else if (Math.abs(xDist) < Math.abs(cfg.minCurveOffset[0])) {\n      curveOffset = cfg.minCurveOffset;\n    }\n\n    var innerPoint1 = {\n      x: startPoint.x + xDist * this.curvePosition[0] + curveOffset[0],\n      y: startPoint.y\n    };\n    var innerPoint2 = {\n      x: endPoint.x - xDist * this.curvePosition[1] + curveOffset[1],\n      y: endPoint.y\n    };\n    var controlPoints = [innerPoint1, innerPoint2];\n    return controlPoints;\n  }\n}, 'cubic');\nShape.registerEdge('loop', {\n  getPathPoints: function getPathPoints(cfg) {\n    return getLoopCfgs(cfg);\n  },\n  getControlPoints: function getControlPoints(cfg) {\n    return cfg.controlPoints;\n  },\n  afterDraw: function afterDraw(cfg) {\n    cfg.controlPoints = undefined;\n  },\n  afterUpdate: function afterUpdate(cfg) {\n    cfg.controlPoints = undefined;\n  }\n}, 'cubic');"]},"metadata":{},"sourceType":"module"}