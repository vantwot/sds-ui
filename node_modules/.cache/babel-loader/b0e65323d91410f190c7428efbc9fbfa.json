{"ast":null,"code":"import { Dom, FunctionExt } from '../../util';\nimport { Point } from '../../geometry';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\n\nclass Anchor extends ToolsView.ToolItem {\n  get type() {\n    return this.options.type;\n  }\n\n  onRender() {\n    Dom.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`));\n    this.toggleArea(false);\n    this.update();\n  }\n\n  update() {\n    const type = this.type;\n    const edgeView = this.cellView;\n    const terminalView = edgeView.getTerminalView(type);\n\n    if (terminalView) {\n      this.updateAnchor();\n      this.updateArea();\n      this.container.style.display = '';\n    } else {\n      this.container.style.display = 'none';\n    }\n\n    return this;\n  }\n\n  updateAnchor() {\n    const childNodes = this.childNodes;\n\n    if (!childNodes) {\n      return;\n    }\n\n    const anchorNode = childNodes.anchor;\n\n    if (!anchorNode) {\n      return;\n    }\n\n    const type = this.type;\n    const edgeView = this.cellView;\n    const options = this.options;\n    const position = edgeView.getTerminalAnchor(type);\n    const customAnchor = edgeView.cell.prop([type, 'anchor']);\n    anchorNode.setAttribute('transform', `translate(${position.x}, ${position.y})`);\n    const anchorAttrs = customAnchor ? options.customAnchorAttrs : options.defaultAnchorAttrs;\n\n    if (anchorAttrs) {\n      Object.keys(anchorAttrs).forEach(attrName => {\n        anchorNode.setAttribute(attrName, anchorAttrs[attrName]);\n      });\n    }\n  }\n\n  updateArea() {\n    const childNodes = this.childNodes;\n\n    if (!childNodes) {\n      return;\n    }\n\n    const areaNode = childNodes.area;\n\n    if (!areaNode) {\n      return;\n    }\n\n    const type = this.type;\n    const edgeView = this.cellView;\n    const terminalView = edgeView.getTerminalView(type);\n\n    if (terminalView) {\n      const terminalCell = terminalView.cell;\n      const magnet = edgeView.getTerminalMagnet(type);\n      let padding = this.options.areaPadding || 0;\n\n      if (!Number.isFinite(padding)) {\n        padding = 0;\n      }\n\n      let bbox;\n      let angle;\n      let center;\n\n      if (terminalView.isEdgeElement(magnet)) {\n        bbox = terminalView.getBBox();\n        angle = 0;\n        center = bbox.getCenter();\n      } else {\n        bbox = terminalView.getUnrotatedBBoxOfElement(magnet);\n        angle = terminalCell.getAngle();\n        center = bbox.getCenter();\n\n        if (angle) {\n          center.rotate(-angle, terminalCell.getBBox().getCenter());\n        }\n      }\n\n      bbox.inflate(padding);\n      Dom.attr(areaNode, {\n        x: -bbox.width / 2,\n        y: -bbox.height / 2,\n        width: bbox.width,\n        height: bbox.height,\n        transform: `translate(${center.x}, ${center.y}) rotate(${angle})`\n      });\n    }\n  }\n\n  toggleArea(visible) {\n    if (this.childNodes) {\n      const elem = this.childNodes.area;\n\n      if (elem) {\n        elem.style.display = visible ? '' : 'none';\n      }\n    }\n  }\n\n  onMouseDown(evt) {\n    if (this.guard(evt)) {\n      return;\n    }\n\n    evt.stopPropagation();\n    evt.preventDefault();\n    this.graph.view.undelegateEvents();\n\n    if (this.options.documentEvents) {\n      this.delegateDocumentEvents(this.options.documentEvents);\n    }\n\n    this.focus();\n    this.toggleArea(this.options.restrictArea);\n    this.cell.startBatch('move-anchor', {\n      ui: true,\n      toolId: this.cid\n    });\n  }\n\n  resetAnchor(anchor) {\n    const type = this.type;\n    const cell = this.cell;\n\n    if (anchor) {\n      cell.prop([type, 'anchor'], anchor, {\n        rewrite: true,\n        ui: true,\n        toolId: this.cid\n      });\n    } else {\n      cell.removeProp([type, 'anchor'], {\n        ui: true,\n        toolId: this.cid\n      });\n    }\n  }\n\n  onMouseMove(evt) {\n    const terminalType = this.type;\n    const edgeView = this.cellView;\n    const terminalView = edgeView.getTerminalView(terminalType);\n\n    if (terminalView == null) {\n      return;\n    }\n\n    const e = this.normalizeEvent(evt);\n    const terminalCell = terminalView.cell;\n    const terminalMagnet = edgeView.getTerminalMagnet(terminalType);\n    let coords = this.graph.clientToLocal(e.clientX, e.clientY);\n    const snapFn = this.options.snap;\n\n    if (typeof snapFn === 'function') {\n      const tmp = FunctionExt.call(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);\n      coords = Point.create(tmp);\n    }\n\n    if (this.options.restrictArea) {\n      if (terminalView.isEdgeElement(terminalMagnet)) {\n        const pointAtConnection = terminalView.getClosestPoint(coords);\n\n        if (pointAtConnection) {\n          coords = pointAtConnection;\n        }\n      } else {\n        const bbox = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);\n        const angle = terminalCell.getAngle();\n        const origin = terminalCell.getBBox().getCenter();\n        const rotatedCoords = coords.clone().rotate(angle, origin);\n\n        if (!bbox.containsPoint(rotatedCoords)) {\n          coords = bbox.getNearestPointToPoint(rotatedCoords).rotate(-angle, origin);\n        }\n      }\n    }\n\n    let anchor;\n    const anchorFn = this.options.anchor;\n\n    if (typeof anchorFn === 'function') {\n      anchor = FunctionExt.call(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);\n    }\n\n    this.resetAnchor(anchor);\n    this.update();\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  onMouseUp(evt) {\n    this.graph.view.delegateEvents();\n    this.undelegateDocumentEvents();\n    this.blur();\n    this.toggleArea(false);\n    const edgeView = this.cellView;\n\n    if (this.options.removeRedundancies) {\n      edgeView.removeRedundantLinearVertices({\n        ui: true,\n        toolId: this.cid\n      });\n    }\n\n    this.cell.stopBatch('move-anchor', {\n      ui: true,\n      toolId: this.cid\n    });\n  }\n\n  onDblClick() {\n    const anchor = this.options.resetAnchor;\n\n    if (anchor) {\n      this.resetAnchor(anchor === true ? undefined : anchor);\n    }\n\n    this.update();\n  }\n\n}\n\n(function (Anchor) {\n  Anchor.config({\n    tagName: 'g',\n    markup: [{\n      tagName: 'circle',\n      selector: 'anchor',\n      attrs: {\n        cursor: 'pointer'\n      }\n    }, {\n      tagName: 'rect',\n      selector: 'area',\n      attrs: {\n        'pointer-events': 'none',\n        fill: 'none',\n        stroke: '#33334F',\n        'stroke-dasharray': '2,4',\n        rx: 5,\n        ry: 5\n      }\n    }],\n    events: {\n      mousedown: 'onMouseDown',\n      touchstart: 'onMouseDown',\n      dblclick: 'onDblClick'\n    },\n    documentEvents: {\n      mousemove: 'onMouseMove',\n      touchmove: 'onMouseMove',\n      mouseup: 'onMouseUp',\n      touchend: 'onMouseUp',\n      touchcancel: 'onMouseUp'\n    },\n    customAnchorAttrs: {\n      'stroke-width': 4,\n      stroke: '#33334F',\n      fill: '#FFFFFF',\n      r: 5\n    },\n    defaultAnchorAttrs: {\n      'stroke-width': 2,\n      stroke: '#FFFFFF',\n      fill: '#33334F',\n      r: 6\n    },\n    areaPadding: 6,\n    snapRadius: 10,\n    resetAnchor: true,\n    restrictArea: true,\n    removeRedundancies: true,\n    anchor: Util.getAnchor,\n\n    snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {\n      const snapRadius = toolView.options.snapRadius || 0;\n      const isSource = terminalType === 'source';\n      const refIndex = isSource ? 0 : -1;\n      const ref = this.cell.getVertexAt(refIndex) || this.getTerminalAnchor(isSource ? 'target' : 'source');\n\n      if (ref) {\n        if (Math.abs(ref.x - pos.x) < snapRadius) pos.x = ref.x;\n        if (Math.abs(ref.y - pos.y) < snapRadius) pos.y = ref.y;\n      }\n\n      return pos;\n    }\n\n  });\n})(Anchor || (Anchor = {}));\n\nexport const SourceAnchor = Anchor.define({\n  name: 'source-anchor',\n  type: 'source'\n});\nexport const TargetAnchor = Anchor.define({\n  name: 'target-anchor',\n  type: 'target'\n});","map":{"version":3,"sources":["../../../src/registry/tool/anchor.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Dom, FunctionExt } from '../../util';\nimport { Point } from '../../geometry';\nimport { ToolsView } from '../../view/tool';\nimport * as Util from './util';\nclass Anchor extends ToolsView.ToolItem {\n    get type() {\n        return this.options.type;\n    }\n    onRender() {\n        Dom.addClass(this.container, this.prefixClassName(`edge-tool-${this.type}-anchor`));\n        this.toggleArea(false);\n        this.update();\n    }\n    update() {\n        const type = this.type;\n        const edgeView = this.cellView;\n        const terminalView = edgeView.getTerminalView(type);\n        if (terminalView) {\n            this.updateAnchor();\n            this.updateArea();\n            this.container.style.display = '';\n        }\n        else {\n            this.container.style.display = 'none';\n        }\n        return this;\n    }\n    updateAnchor() {\n        const childNodes = this.childNodes;\n        if (!childNodes) {\n            return;\n        }\n        const anchorNode = childNodes.anchor;\n        if (!anchorNode) {\n            return;\n        }\n        const type = this.type;\n        const edgeView = this.cellView;\n        const options = this.options;\n        const position = edgeView.getTerminalAnchor(type);\n        const customAnchor = edgeView.cell.prop([type, 'anchor']);\n        anchorNode.setAttribute('transform', `translate(${position.x}, ${position.y})`);\n        const anchorAttrs = customAnchor\n            ? options.customAnchorAttrs\n            : options.defaultAnchorAttrs;\n        if (anchorAttrs) {\n            Object.keys(anchorAttrs).forEach((attrName) => {\n                anchorNode.setAttribute(attrName, anchorAttrs[attrName]);\n            });\n        }\n    }\n    updateArea() {\n        const childNodes = this.childNodes;\n        if (!childNodes) {\n            return;\n        }\n        const areaNode = childNodes.area;\n        if (!areaNode) {\n            return;\n        }\n        const type = this.type;\n        const edgeView = this.cellView;\n        const terminalView = edgeView.getTerminalView(type);\n        if (terminalView) {\n            const terminalCell = terminalView.cell;\n            const magnet = edgeView.getTerminalMagnet(type);\n            let padding = this.options.areaPadding || 0;\n            if (!Number.isFinite(padding)) {\n                padding = 0;\n            }\n            let bbox;\n            let angle;\n            let center;\n            if (terminalView.isEdgeElement(magnet)) {\n                bbox = terminalView.getBBox();\n                angle = 0;\n                center = bbox.getCenter();\n            }\n            else {\n                bbox = terminalView.getUnrotatedBBoxOfElement(magnet);\n                angle = terminalCell.getAngle();\n                center = bbox.getCenter();\n                if (angle) {\n                    center.rotate(-angle, terminalCell.getBBox().getCenter());\n                }\n            }\n            bbox.inflate(padding);\n            Dom.attr(areaNode, {\n                x: -bbox.width / 2,\n                y: -bbox.height / 2,\n                width: bbox.width,\n                height: bbox.height,\n                transform: `translate(${center.x}, ${center.y}) rotate(${angle})`,\n            });\n        }\n    }\n    toggleArea(visible) {\n        if (this.childNodes) {\n            const elem = this.childNodes.area;\n            if (elem) {\n                elem.style.display = visible ? '' : 'none';\n            }\n        }\n    }\n    onMouseDown(evt) {\n        if (this.guard(evt)) {\n            return;\n        }\n        evt.stopPropagation();\n        evt.preventDefault();\n        this.graph.view.undelegateEvents();\n        if (this.options.documentEvents) {\n            this.delegateDocumentEvents(this.options.documentEvents);\n        }\n        this.focus();\n        this.toggleArea(this.options.restrictArea);\n        this.cell.startBatch('move-anchor', {\n            ui: true,\n            toolId: this.cid,\n        });\n    }\n    resetAnchor(anchor) {\n        const type = this.type;\n        const cell = this.cell;\n        if (anchor) {\n            cell.prop([type, 'anchor'], anchor, {\n                rewrite: true,\n                ui: true,\n                toolId: this.cid,\n            });\n        }\n        else {\n            cell.removeProp([type, 'anchor'], {\n                ui: true,\n                toolId: this.cid,\n            });\n        }\n    }\n    onMouseMove(evt) {\n        const terminalType = this.type;\n        const edgeView = this.cellView;\n        const terminalView = edgeView.getTerminalView(terminalType);\n        if (terminalView == null) {\n            return;\n        }\n        const e = this.normalizeEvent(evt);\n        const terminalCell = terminalView.cell;\n        const terminalMagnet = edgeView.getTerminalMagnet(terminalType);\n        let coords = this.graph.clientToLocal(e.clientX, e.clientY);\n        const snapFn = this.options.snap;\n        if (typeof snapFn === 'function') {\n            const tmp = FunctionExt.call(snapFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);\n            coords = Point.create(tmp);\n        }\n        if (this.options.restrictArea) {\n            if (terminalView.isEdgeElement(terminalMagnet)) {\n                const pointAtConnection = terminalView.getClosestPoint(coords);\n                if (pointAtConnection) {\n                    coords = pointAtConnection;\n                }\n            }\n            else {\n                const bbox = terminalView.getUnrotatedBBoxOfElement(terminalMagnet);\n                const angle = terminalCell.getAngle();\n                const origin = terminalCell.getBBox().getCenter();\n                const rotatedCoords = coords.clone().rotate(angle, origin);\n                if (!bbox.containsPoint(rotatedCoords)) {\n                    coords = bbox\n                        .getNearestPointToPoint(rotatedCoords)\n                        .rotate(-angle, origin);\n                }\n            }\n        }\n        let anchor;\n        const anchorFn = this.options.anchor;\n        if (typeof anchorFn === 'function') {\n            anchor = FunctionExt.call(anchorFn, edgeView, coords, terminalView, terminalMagnet, terminalType, edgeView, this);\n        }\n        this.resetAnchor(anchor);\n        this.update();\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    onMouseUp(evt) {\n        this.graph.view.delegateEvents();\n        this.undelegateDocumentEvents();\n        this.blur();\n        this.toggleArea(false);\n        const edgeView = this.cellView;\n        if (this.options.removeRedundancies) {\n            edgeView.removeRedundantLinearVertices({ ui: true, toolId: this.cid });\n        }\n        this.cell.stopBatch('move-anchor', { ui: true, toolId: this.cid });\n    }\n    onDblClick() {\n        const anchor = this.options.resetAnchor;\n        if (anchor) {\n            this.resetAnchor(anchor === true ? undefined : anchor);\n        }\n        this.update();\n    }\n}\n(function (Anchor) {\n    Anchor.config({\n        tagName: 'g',\n        markup: [\n            {\n                tagName: 'circle',\n                selector: 'anchor',\n                attrs: {\n                    cursor: 'pointer',\n                },\n            },\n            {\n                tagName: 'rect',\n                selector: 'area',\n                attrs: {\n                    'pointer-events': 'none',\n                    fill: 'none',\n                    stroke: '#33334F',\n                    'stroke-dasharray': '2,4',\n                    rx: 5,\n                    ry: 5,\n                },\n            },\n        ],\n        events: {\n            mousedown: 'onMouseDown',\n            touchstart: 'onMouseDown',\n            dblclick: 'onDblClick',\n        },\n        documentEvents: {\n            mousemove: 'onMouseMove',\n            touchmove: 'onMouseMove',\n            mouseup: 'onMouseUp',\n            touchend: 'onMouseUp',\n            touchcancel: 'onMouseUp',\n        },\n        customAnchorAttrs: {\n            'stroke-width': 4,\n            stroke: '#33334F',\n            fill: '#FFFFFF',\n            r: 5,\n        },\n        defaultAnchorAttrs: {\n            'stroke-width': 2,\n            stroke: '#FFFFFF',\n            fill: '#33334F',\n            r: 6,\n        },\n        areaPadding: 6,\n        snapRadius: 10,\n        resetAnchor: true,\n        restrictArea: true,\n        removeRedundancies: true,\n        anchor: Util.getAnchor,\n        snap(pos, terminalView, terminalMagnet, terminalType, edgeView, toolView) {\n            const snapRadius = toolView.options.snapRadius || 0;\n            const isSource = terminalType === 'source';\n            const refIndex = isSource ? 0 : -1;\n            const ref = this.cell.getVertexAt(refIndex) ||\n                this.getTerminalAnchor(isSource ? 'target' : 'source');\n            if (ref) {\n                if (Math.abs(ref.x - pos.x) < snapRadius)\n                    pos.x = ref.x;\n                if (Math.abs(ref.y - pos.y) < snapRadius)\n                    pos.y = ref.y;\n            }\n            return pos;\n        },\n    });\n})(Anchor || (Anchor = {}));\nexport const SourceAnchor = Anchor.define({\n    name: 'source-anchor',\n    type: 'source',\n});\nexport const TargetAnchor = Anchor.define({\n    name: 'target-anchor',\n    type: 'target',\n});\n//# sourceMappingURL=anchor.js.map"]},"metadata":{},"sourceType":"module"}