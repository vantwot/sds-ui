{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\n\nvar point_1 = require(\"./point\");\n\nvar Bounds =\n/** @class */\nfunction () {\n  function Bounds(topLeft, bottomRight) {\n    if (!topLeft) {\n      return;\n    }\n\n    var points = bottomRight ? [topLeft, bottomRight] : topLeft;\n\n    if (Array.isArray(points)) {\n      for (var i = 0, len = points.length; i < len; i += 1) {\n        // @ts-ignore\n        this.extend(points[i]);\n      }\n    }\n  }\n\n  Bounds.prototype.extend = function (point) {\n    var newPoint = point_1.toPoint(point);\n\n    if (!this.min && !this.max) {\n      this.min = newPoint.clone();\n      this.max = newPoint.clone();\n    } else {\n      this.min.x = Math.min(newPoint.x, this.min.x);\n      this.max.x = Math.max(newPoint.x, this.max.x);\n      this.min.y = Math.min(newPoint.y, this.min.y);\n      this.max.y = Math.max(newPoint.y, this.max.y);\n    }\n\n    return this;\n  };\n\n  Bounds.prototype.getCenter = function (round) {\n    return new point_1.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n  };\n\n  Bounds.prototype.getBottomLeft = function () {\n    return new point_1.Point(this.min.x, this.max.y);\n  };\n\n  Bounds.prototype.getTopRight = function () {\n    return new point_1.Point(this.max.x, this.min.y);\n  };\n\n  Bounds.prototype.getBottomRight = function () {\n    return this.max;\n  };\n\n  Bounds.prototype.getTopLeft = function () {\n    return this.min;\n  };\n\n  Bounds.prototype.getSize = function () {\n    return this.max.subtract(this.min);\n  };\n  /**\n   * 判断是否包含 输入 points 或者 bounds\n   * @param obj\n   */\n\n\n  Bounds.prototype.contains = function (obj) {\n    var min;\n    var max;\n    var newObj = obj; // @ts-ignore\n\n    if (newObj instanceof point_1.Point || typeof newObj[0] === 'number') {\n      newObj = point_1.toPoint(newObj);\n    } else {\n      newObj = toBounds(newObj);\n    }\n\n    if (newObj instanceof Bounds) {\n      min = newObj.min;\n      max = newObj.max;\n    } else {\n      min = max = obj;\n    }\n\n    return min.x >= this.min.x && max.x <= this.max.x && min.y >= this.min.y && max.y <= this.max.y;\n  };\n  /**\n   * 判断两个bounds是否相交 ,\n   * @param bounds\n   */\n\n\n  Bounds.prototype.intersect = function (bounds) {\n    var newBounds = toBounds(bounds);\n    var min = this.min;\n    var max = this.max;\n    var min2 = newBounds.min;\n    var max2 = newBounds.max;\n    var xIntersects = max2.x >= min.x && min2.x <= max.x;\n    var yIntersects = max2.y >= min.y && min2.y <= max.y;\n    return xIntersects && yIntersects;\n  };\n  /**\n   * 判断bounds是否相互覆盖\n   * @param bounds\n   */\n\n\n  Bounds.prototype.overlaps = function (bounds) {\n    var newBounds = toBounds(bounds);\n    var min = this.min;\n    var max = this.max;\n    var min2 = newBounds.min;\n    var max2 = newBounds.max;\n    var xOverlaps = max2.x > min.x && min2.x < max.x;\n    var yOverlaps = max2.y > min.y && min2.y < max.y;\n    return xOverlaps && yOverlaps;\n  };\n\n  Bounds.prototype.isValid = function () {\n    return !!(this.min && this.max);\n  };\n\n  return Bounds;\n}();\n\nexports.Bounds = Bounds;\n\nfunction toBounds(topLeft, bottomRight) {\n  if (!topLeft || topLeft instanceof Bounds) {\n    return topLeft;\n  }\n\n  return new Bounds(topLeft, bottomRight);\n}\n\nexports.toBounds = toBounds;","map":{"version":3,"sources":["../../../src/geo/geometry/bounds.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["\"use strict\";\nexports.__esModule = true;\nvar point_1 = require(\"./point\");\nvar Bounds = /** @class */ (function () {\n    function Bounds(topLeft, bottomRight) {\n        if (!topLeft) {\n            return;\n        }\n        var points = bottomRight ? [topLeft, bottomRight] : topLeft;\n        if (Array.isArray(points)) {\n            for (var i = 0, len = points.length; i < len; i += 1) {\n                // @ts-ignore\n                this.extend(points[i]);\n            }\n        }\n    }\n    Bounds.prototype.extend = function (point) {\n        var newPoint = point_1.toPoint(point);\n        if (!this.min && !this.max) {\n            this.min = newPoint.clone();\n            this.max = newPoint.clone();\n        }\n        else {\n            this.min.x = Math.min(newPoint.x, this.min.x);\n            this.max.x = Math.max(newPoint.x, this.max.x);\n            this.min.y = Math.min(newPoint.y, this.min.y);\n            this.max.y = Math.max(newPoint.y, this.max.y);\n        }\n        return this;\n    };\n    Bounds.prototype.getCenter = function (round) {\n        return new point_1.Point((this.min.x + this.max.x) / 2, (this.min.y + this.max.y) / 2, round);\n    };\n    Bounds.prototype.getBottomLeft = function () {\n        return new point_1.Point(this.min.x, this.max.y);\n    };\n    Bounds.prototype.getTopRight = function () {\n        return new point_1.Point(this.max.x, this.min.y);\n    };\n    Bounds.prototype.getBottomRight = function () {\n        return this.max;\n    };\n    Bounds.prototype.getTopLeft = function () {\n        return this.min;\n    };\n    Bounds.prototype.getSize = function () {\n        return this.max.subtract(this.min);\n    };\n    /**\n     * 判断是否包含 输入 points 或者 bounds\n     * @param obj\n     */\n    Bounds.prototype.contains = function (obj) {\n        var min;\n        var max;\n        var newObj = obj;\n        // @ts-ignore\n        if (newObj instanceof point_1.Point || typeof newObj[0] === 'number') {\n            newObj = point_1.toPoint(newObj);\n        }\n        else {\n            newObj = toBounds(newObj);\n        }\n        if (newObj instanceof Bounds) {\n            min = newObj.min;\n            max = newObj.max;\n        }\n        else {\n            min = max = obj;\n        }\n        return (min.x >= this.min.x &&\n            max.x <= this.max.x &&\n            min.y >= this.min.y &&\n            max.y <= this.max.y);\n    };\n    /**\n     * 判断两个bounds是否相交 ,\n     * @param bounds\n     */\n    Bounds.prototype.intersect = function (bounds) {\n        var newBounds = toBounds(bounds);\n        var min = this.min;\n        var max = this.max;\n        var min2 = newBounds.min;\n        var max2 = newBounds.max;\n        var xIntersects = (max2.x >= min.x) && (min2.x <= max.x);\n        var yIntersects = (max2.y >= min.y) && (min2.y <= max.y);\n        return xIntersects && yIntersects;\n    };\n    /**\n     * 判断bounds是否相互覆盖\n     * @param bounds\n     */\n    Bounds.prototype.overlaps = function (bounds) {\n        var newBounds = toBounds(bounds);\n        var min = this.min;\n        var max = this.max;\n        var min2 = newBounds.min;\n        var max2 = newBounds.max;\n        var xOverlaps = (max2.x > min.x) && (min2.x < max.x);\n        var yOverlaps = (max2.y > min.y) && (min2.y < max.y);\n        return xOverlaps && yOverlaps;\n    };\n    Bounds.prototype.isValid = function () {\n        return !!(this.min && this.max);\n    };\n    return Bounds;\n}());\nexports.Bounds = Bounds;\nfunction toBounds(topLeft, bottomRight) {\n    if (!topLeft || topLeft instanceof Bounds) {\n        return topLeft;\n    }\n    return new Bounds(topLeft, bottomRight);\n}\nexports.toBounds = toBounds;\n//# sourceMappingURL=bounds.js.map"]},"metadata":{},"sourceType":"script"}