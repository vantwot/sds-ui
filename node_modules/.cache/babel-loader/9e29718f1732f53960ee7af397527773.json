{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() : typeof define === 'function' && define.amd ? define(factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Supercluster = factory());\n})(this, function () {\n  'use strict';\n\n  function sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) {\n      return;\n    }\n\n    var m = left + right >> 1;\n    select(ids, coords, m, left, right, depth % 2);\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n  }\n\n  function select(ids, coords, k, left, right, inc) {\n    while (right > left) {\n      if (right - left > 600) {\n        var n = right - left + 1;\n        var m = k - left + 1;\n        var z = Math.log(n);\n        var s = 0.5 * Math.exp(2 * z / 3);\n        var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n        var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n        var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n        select(ids, coords, k, newLeft, newRight, inc);\n      }\n\n      var t = coords[2 * k + inc];\n      var i = left;\n      var j = right;\n      swapItem(ids, coords, left, k);\n\n      if (coords[2 * right + inc] > t) {\n        swapItem(ids, coords, left, right);\n      }\n\n      while (i < j) {\n        swapItem(ids, coords, i, j);\n        i++;\n        j--;\n\n        while (coords[2 * i + inc] < t) {\n          i++;\n        }\n\n        while (coords[2 * j + inc] > t) {\n          j--;\n        }\n      }\n\n      if (coords[2 * left + inc] === t) {\n        swapItem(ids, coords, left, j);\n      } else {\n        j++;\n        swapItem(ids, coords, j, right);\n      }\n\n      if (j <= k) {\n        left = j + 1;\n      }\n\n      if (k <= j) {\n        right = j - 1;\n      }\n    }\n  }\n\n  function swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n  }\n\n  function swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n  }\n\n  function range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var x, y;\n\n    while (stack.length) {\n      var axis = stack.pop();\n      var right = stack.pop();\n      var left = stack.pop();\n\n      if (right - left <= nodeSize) {\n        for (var i = left; i <= right; i++) {\n          x = coords[2 * i];\n          y = coords[2 * i + 1];\n\n          if (x >= minX && x <= maxX && y >= minY && y <= maxY) {\n            result.push(ids[i]);\n          }\n        }\n\n        continue;\n      }\n\n      var m = Math.floor((left + right) / 2);\n      x = coords[2 * m];\n      y = coords[2 * m + 1];\n\n      if (x >= minX && x <= maxX && y >= minY && y <= maxY) {\n        result.push(ids[m]);\n      }\n\n      var nextAxis = (axis + 1) % 2;\n\n      if (axis === 0 ? minX <= x : minY <= y) {\n        stack.push(left);\n        stack.push(m - 1);\n        stack.push(nextAxis);\n      }\n\n      if (axis === 0 ? maxX >= x : maxY >= y) {\n        stack.push(m + 1);\n        stack.push(right);\n        stack.push(nextAxis);\n      }\n    }\n\n    return result;\n  }\n\n  function within(ids, coords, qx, qy, r, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n\n    while (stack.length) {\n      var axis = stack.pop();\n      var right = stack.pop();\n      var left = stack.pop();\n\n      if (right - left <= nodeSize) {\n        for (var i = left; i <= right; i++) {\n          if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) {\n            result.push(ids[i]);\n          }\n        }\n\n        continue;\n      }\n\n      var m = Math.floor((left + right) / 2);\n      var x = coords[2 * m];\n      var y = coords[2 * m + 1];\n\n      if (sqDist(x, y, qx, qy) <= r2) {\n        result.push(ids[m]);\n      }\n\n      var nextAxis = (axis + 1) % 2;\n\n      if (axis === 0 ? qx - r <= x : qy - r <= y) {\n        stack.push(left);\n        stack.push(m - 1);\n        stack.push(nextAxis);\n      }\n\n      if (axis === 0 ? qx + r >= x : qy + r >= y) {\n        stack.push(m + 1);\n        stack.push(right);\n        stack.push(nextAxis);\n      }\n    }\n\n    return result;\n  }\n\n  function sqDist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n  }\n\n  var defaultGetX = function defaultGetX(p) {\n    return p[0];\n  };\n\n  var defaultGetY = function defaultGetY(p) {\n    return p[1];\n  };\n\n  var KDBush = function KDBush(points, getX, getY, nodeSize, ArrayType) {\n    if (getX === void 0) getX = defaultGetX;\n    if (getY === void 0) getY = defaultGetY;\n    if (nodeSize === void 0) nodeSize = 64;\n    if (ArrayType === void 0) ArrayType = Float64Array;\n    this.nodeSize = nodeSize;\n    this.points = points;\n    var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n    var ids = this.ids = new IndexArrayType(points.length);\n    var coords = this.coords = new ArrayType(points.length * 2);\n\n    for (var i = 0; i < points.length; i++) {\n      ids[i] = i;\n      coords[2 * i] = getX(points[i]);\n      coords[2 * i + 1] = getY(points[i]);\n    }\n\n    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);\n  };\n\n  KDBush.prototype.range = function range$1(minX, minY, maxX, maxY) {\n    return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n  };\n\n  KDBush.prototype.within = function within$1(x, y, r) {\n    return within(this.ids, this.coords, x, y, r, this.nodeSize);\n  };\n\n  var defaultOptions = {\n    minZoom: 0,\n    // min zoom to generate clusters on\n    maxZoom: 16,\n    // max zoom level to cluster the points on\n    minPoints: 2,\n    // minimum points to form a cluster\n    radius: 40,\n    // cluster radius in pixels\n    extent: 512,\n    // tile extent (radius is calculated relative to it)\n    nodeSize: 64,\n    // size of the KD-tree leaf node, affects performance\n    log: false,\n    // whether to log timing info\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n    // a reduce function for calculating custom cluster properties\n    reduce: null,\n    // (accumulated, props) => { accumulated.sum += props.sum; }\n    // properties to use for individual points when running the reducer\n    map: function map(props) {\n      return props;\n    } // props => ({sum: props.my_value})\n\n  };\n\n  var fround = Math.fround || function (tmp) {\n    return function (x) {\n      tmp[0] = +x;\n      return tmp[0];\n    };\n  }(new Float32Array(1));\n\n  var Supercluster = function Supercluster(options) {\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n  };\n\n  Supercluster.prototype.load = function load(points) {\n    var ref = this.options;\n    var log = ref.log;\n    var minZoom = ref.minZoom;\n    var maxZoom = ref.maxZoom;\n    var nodeSize = ref.nodeSize;\n\n    if (log) {\n      console.time('total time');\n    }\n\n    var timerId = \"prepare \" + points.length + \" points\";\n\n    if (log) {\n      console.time(timerId);\n    }\n\n    this.points = points; // generate a cluster object for each point and index input points into a KD-tree\n\n    var clusters = [];\n\n    for (var i = 0; i < points.length; i++) {\n      if (!points[i].geometry) {\n        continue;\n      }\n\n      clusters.push(createPointCluster(points[i], i));\n    }\n\n    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n    if (log) {\n      console.timeEnd(timerId);\n    } // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n\n\n    for (var z = maxZoom; z >= minZoom; z--) {\n      var now = +Date.now(); // create a new set of clusters for the zoom and index them with a KD-tree\n\n      clusters = this._cluster(clusters, z);\n      this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n      if (log) {\n        console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now);\n      }\n    }\n\n    if (log) {\n      console.timeEnd('total time');\n    }\n\n    return this;\n  };\n\n  Supercluster.prototype.getClusters = function getClusters(bbox, zoom) {\n    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    var minLat = Math.max(-90, Math.min(90, bbox[1]));\n    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n    if (bbox[2] - bbox[0] >= 360) {\n      minLng = -180;\n      maxLng = 180;\n    } else if (minLng > maxLng) {\n      var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n      var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n      return easternHem.concat(westernHem);\n    }\n\n    var tree = this.trees[this._limitZoom(zoom)];\n\n    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    var clusters = [];\n\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n      var id = list[i];\n      var c = tree.points[id];\n      clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n    }\n\n    return clusters;\n  };\n\n  Supercluster.prototype.getChildren = function getChildren(clusterId) {\n    var originId = this._getOriginId(clusterId);\n\n    var originZoom = this._getOriginZoom(clusterId);\n\n    var errorMsg = 'No cluster with the specified id.';\n    var index = this.trees[originZoom];\n\n    if (!index) {\n      throw new Error(errorMsg);\n    }\n\n    var origin = index.points[originId];\n\n    if (!origin) {\n      throw new Error(errorMsg);\n    }\n\n    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    var ids = index.within(origin.x, origin.y, r);\n    var children = [];\n\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n      var id = list[i];\n      var c = index.points[id];\n\n      if (c.parentId === clusterId) {\n        children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n      }\n    }\n\n    if (children.length === 0) {\n      throw new Error(errorMsg);\n    }\n\n    return children;\n  };\n\n  Supercluster.prototype.getLeaves = function getLeaves(clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n    var leaves = [];\n\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n    return leaves;\n  };\n\n  Supercluster.prototype.getTile = function getTile(z, x, y) {\n    var tree = this.trees[this._limitZoom(z)];\n\n    var z2 = Math.pow(2, z);\n    var ref = this.options;\n    var extent = ref.extent;\n    var radius = ref.radius;\n    var p = radius / extent;\n    var top = (y - p) / z2;\n    var bottom = (y + 1 + p) / z2;\n    var tile = {\n      features: []\n    };\n\n    this._addTileFeatures(tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom), tree.points, x, y, z2, tile);\n\n    if (x === 0) {\n      this._addTileFeatures(tree.range(1 - p / z2, top, 1, bottom), tree.points, z2, y, z2, tile);\n    }\n\n    if (x === z2 - 1) {\n      this._addTileFeatures(tree.range(0, top, p / z2, bottom), tree.points, -1, y, z2, tile);\n    }\n\n    return tile.features.length ? tile : null;\n  };\n\n  Supercluster.prototype.getClusterExpansionZoom = function getClusterExpansionZoom(clusterId) {\n    var expansionZoom = this._getOriginZoom(clusterId) - 1;\n\n    while (expansionZoom <= this.options.maxZoom) {\n      var children = this.getChildren(clusterId);\n      expansionZoom++;\n\n      if (children.length !== 1) {\n        break;\n      }\n\n      clusterId = children[0].properties.cluster_id;\n    }\n\n    return expansionZoom;\n  };\n\n  Supercluster.prototype._appendLeaves = function _appendLeaves(result, clusterId, limit, offset, skipped) {\n    var children = this.getChildren(clusterId);\n\n    for (var i = 0, list = children; i < list.length; i += 1) {\n      var child = list[i];\n      var props = child.properties;\n\n      if (props && props.cluster) {\n        if (skipped + props.point_count <= offset) {\n          // skip the whole cluster\n          skipped += props.point_count;\n        } else {\n          // enter the cluster\n          skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped); // exit the cluster\n        }\n      } else if (skipped < offset) {\n        // skip a single point\n        skipped++;\n      } else {\n        // add a single point\n        result.push(child);\n      }\n\n      if (result.length === limit) {\n        break;\n      }\n    }\n\n    return skipped;\n  };\n\n  Supercluster.prototype._addTileFeatures = function _addTileFeatures(ids, points, x, y, z2, tile) {\n    for (var i$1 = 0, list = ids; i$1 < list.length; i$1 += 1) {\n      var i = list[i$1];\n      var c = points[i];\n      var isCluster = c.numPoints;\n      var tags = void 0,\n          px = void 0,\n          py = void 0;\n\n      if (isCluster) {\n        tags = getClusterProperties(c);\n        px = c.x;\n        py = c.y;\n      } else {\n        var p = this.points[c.index];\n        tags = p.properties;\n        px = lngX(p.geometry.coordinates[0]);\n        py = latY(p.geometry.coordinates[1]);\n      }\n\n      var f = {\n        type: 1,\n        geometry: [[Math.round(this.options.extent * (px * z2 - x)), Math.round(this.options.extent * (py * z2 - y))]],\n        tags: tags\n      }; // assign id\n\n      var id = void 0;\n\n      if (isCluster) {\n        id = c.id;\n      } else if (this.options.generateId) {\n        // optionally generate id\n        id = c.index;\n      } else if (this.points[c.index].id) {\n        // keep id if already assigned\n        id = this.points[c.index].id;\n      }\n\n      if (id !== undefined) {\n        f.id = id;\n      }\n\n      tile.features.push(f);\n    }\n  };\n\n  Supercluster.prototype._limitZoom = function _limitZoom(z) {\n    return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n  };\n\n  Supercluster.prototype._cluster = function _cluster(points, zoom) {\n    var clusters = [];\n    var ref = this.options;\n    var radius = ref.radius;\n    var extent = ref.extent;\n    var reduce = ref.reduce;\n    var minPoints = ref.minPoints;\n    var r = radius / (extent * Math.pow(2, zoom)); // loop through each point\n\n    for (var i = 0; i < points.length; i++) {\n      var p = points[i]; // if we've already visited the point at this zoom level, skip it\n\n      if (p.zoom <= zoom) {\n        continue;\n      }\n\n      p.zoom = zoom; // find all nearby points\n\n      var tree = this.trees[zoom + 1];\n      var neighborIds = tree.within(p.x, p.y, r);\n      var numPointsOrigin = p.numPoints || 1;\n      var numPoints = numPointsOrigin; // count the number of points in a potential cluster\n\n      for (var i$1 = 0, list = neighborIds; i$1 < list.length; i$1 += 1) {\n        var neighborId = list[i$1];\n        var b = tree.points[neighborId]; // filter out neighbors that are already processed\n\n        if (b.zoom > zoom) {\n          numPoints += b.numPoints || 1;\n        }\n      } // if there were neighbors to merge, and there are enough points to form a cluster\n\n\n      if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n        var wx = p.x * numPointsOrigin;\n        var wy = p.y * numPointsOrigin;\n        var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null; // encode both zoom and point index on which the cluster originated -- offset by total length of features\n\n        var id = (i << 5) + (zoom + 1) + this.points.length;\n\n        for (var i$2 = 0, list$1 = neighborIds; i$2 < list$1.length; i$2 += 1) {\n          var neighborId$1 = list$1[i$2];\n          var b$1 = tree.points[neighborId$1];\n\n          if (b$1.zoom <= zoom) {\n            continue;\n          }\n\n          b$1.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n          var numPoints2 = b$1.numPoints || 1;\n          wx += b$1.x * numPoints2; // accumulate coordinates for calculating weighted center\n\n          wy += b$1.y * numPoints2;\n          b$1.parentId = id;\n\n          if (reduce) {\n            if (!clusterProperties) {\n              clusterProperties = this._map(p, true);\n            }\n\n            reduce(clusterProperties, this._map(b$1));\n          }\n        }\n\n        p.parentId = id;\n        clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n      } else {\n        // left points as unclustered\n        clusters.push(p);\n\n        if (numPoints > 1) {\n          for (var i$3 = 0, list$2 = neighborIds; i$3 < list$2.length; i$3 += 1) {\n            var neighborId$2 = list$2[i$3];\n            var b$2 = tree.points[neighborId$2];\n\n            if (b$2.zoom <= zoom) {\n              continue;\n            }\n\n            b$2.zoom = zoom;\n            clusters.push(b$2);\n          }\n        }\n      }\n    }\n\n    return clusters;\n  }; // get index of the point from which the cluster originated\n\n\n  Supercluster.prototype._getOriginId = function _getOriginId(clusterId) {\n    return clusterId - this.points.length >> 5;\n  }; // get zoom of the point from which the cluster originated\n\n\n  Supercluster.prototype._getOriginZoom = function _getOriginZoom(clusterId) {\n    return (clusterId - this.points.length) % 32;\n  };\n\n  Supercluster.prototype._map = function _map(point, clone) {\n    if (point.numPoints) {\n      return clone ? extend({}, point.properties) : point.properties;\n    }\n\n    var original = this.points[point.index].properties;\n    var result = this.options.map(original);\n    return clone && result === original ? extend({}, result) : result;\n  };\n\n  function createCluster(x, y, id, numPoints, properties) {\n    return {\n      x: fround(x),\n      // weighted cluster center; round for consistency with Float32Array index\n      y: fround(y),\n      zoom: Infinity,\n      // the last zoom the cluster was processed at\n      id: id,\n      // encodes index of the first child of the cluster and its zoom level\n      parentId: -1,\n      // parent cluster id\n      numPoints: numPoints,\n      properties: properties\n    };\n  }\n\n  function createPointCluster(p, id) {\n    var ref = p.geometry.coordinates;\n    var x = ref[0];\n    var y = ref[1];\n    return {\n      x: fround(lngX(x)),\n      // projected point coordinates\n      y: fround(latY(y)),\n      zoom: Infinity,\n      // the last zoom the point was processed at\n      index: id,\n      // index of the source feature in the original input array,\n      parentId: -1 // parent cluster id\n\n    };\n  }\n\n  function getClusterJSON(cluster) {\n    return {\n      type: 'Feature',\n      id: cluster.id,\n      properties: getClusterProperties(cluster),\n      geometry: {\n        type: 'Point',\n        coordinates: [xLng(cluster.x), yLat(cluster.y)]\n      }\n    };\n  }\n\n  function getClusterProperties(cluster) {\n    var count = cluster.numPoints;\n    var abbrev = count >= 10000 ? Math.round(count / 1000) + \"k\" : count >= 1000 ? Math.round(count / 100) / 10 + \"k\" : count;\n    return extend(extend({}, cluster.properties), {\n      cluster: true,\n      cluster_id: cluster.id,\n      point_count: count,\n      point_count_abbreviated: abbrev\n    });\n  } // longitude/latitude to spherical mercator in [0..1] range\n\n\n  function lngX(lng) {\n    return lng / 360 + 0.5;\n  }\n\n  function latY(lat) {\n    var sin = Math.sin(lat * Math.PI / 180);\n    var y = 0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI;\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n  } // spherical mercator to longitude/latitude\n\n\n  function xLng(x) {\n    return (x - 0.5) * 360;\n  }\n\n  function yLat(y) {\n    var y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n  }\n\n  function extend(dest, src) {\n    for (var id in src) {\n      dest[id] = src[id];\n    }\n\n    return dest;\n  }\n\n  function getX(p) {\n    return p.x;\n  }\n\n  function getY(p) {\n    return p.y;\n  }\n\n  return Supercluster;\n});","map":{"version":3,"sources":["/home/manolo/sds-ui/node_modules/supercluster/dist/supercluster.js"],"names":["global","factory","exports","module","define","amd","globalThis","self","Supercluster","sortKD","ids","coords","nodeSize","left","right","depth","m","select","k","inc","n","z","Math","log","s","exp","sd","sqrt","newLeft","max","floor","newRight","min","t","i","j","swapItem","swap","arr","tmp","range","minX","minY","maxX","maxY","stack","length","result","x","y","axis","pop","push","nextAxis","within","qx","qy","r","r2","sqDist","ax","ay","bx","by","dx","dy","defaultGetX","p","defaultGetY","KDBush","points","getX","getY","ArrayType","Float64Array","IndexArrayType","Uint16Array","Uint32Array","prototype","range$1","within$1","defaultOptions","minZoom","maxZoom","minPoints","radius","extent","generateId","reduce","map","props","fround","Float32Array","options","extend","Object","create","trees","Array","load","ref","console","time","timerId","clusters","geometry","createPointCluster","timeEnd","now","Date","_cluster","getClusters","bbox","zoom","minLng","minLat","maxLng","maxLat","easternHem","westernHem","concat","tree","_limitZoom","lngX","latY","list","id","c","numPoints","getClusterJSON","index","getChildren","clusterId","originId","_getOriginId","originZoom","_getOriginZoom","errorMsg","Error","origin","pow","children","parentId","getLeaves","limit","offset","leaves","_appendLeaves","getTile","z2","top","bottom","tile","features","_addTileFeatures","getClusterExpansionZoom","expansionZoom","properties","cluster_id","skipped","child","cluster","point_count","i$1","isCluster","tags","px","py","getClusterProperties","coordinates","f","type","round","undefined","neighborIds","numPointsOrigin","neighborId","b","wx","wy","clusterProperties","_map","i$2","list$1","neighborId$1","b$1","numPoints2","createCluster","i$3","list$2","neighborId$2","b$2","point","clone","original","Infinity","xLng","yLat","count","abbrev","point_count_abbreviated","lng","lat","sin","PI","y2","atan","dest","src"],"mappings":"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","sourcesContent":["(function (global, factory) {\ntypeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :\ntypeof define === 'function' && define.amd ? define(factory) :\n(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.Supercluster = factory());\n})(this, (function () { 'use strict';\n\nfunction sortKD(ids, coords, nodeSize, left, right, depth) {\n    if (right - left <= nodeSize) { return; }\n\n    var m = (left + right) >> 1;\n\n    select(ids, coords, m, left, right, depth % 2);\n\n    sortKD(ids, coords, nodeSize, left, m - 1, depth + 1);\n    sortKD(ids, coords, nodeSize, m + 1, right, depth + 1);\n}\n\nfunction select(ids, coords, k, left, right, inc) {\n\n    while (right > left) {\n        if (right - left > 600) {\n            var n = right - left + 1;\n            var m = k - left + 1;\n            var z = Math.log(n);\n            var s = 0.5 * Math.exp(2 * z / 3);\n            var sd = 0.5 * Math.sqrt(z * s * (n - s) / n) * (m - n / 2 < 0 ? -1 : 1);\n            var newLeft = Math.max(left, Math.floor(k - m * s / n + sd));\n            var newRight = Math.min(right, Math.floor(k + (n - m) * s / n + sd));\n            select(ids, coords, k, newLeft, newRight, inc);\n        }\n\n        var t = coords[2 * k + inc];\n        var i = left;\n        var j = right;\n\n        swapItem(ids, coords, left, k);\n        if (coords[2 * right + inc] > t) { swapItem(ids, coords, left, right); }\n\n        while (i < j) {\n            swapItem(ids, coords, i, j);\n            i++;\n            j--;\n            while (coords[2 * i + inc] < t) { i++; }\n            while (coords[2 * j + inc] > t) { j--; }\n        }\n\n        if (coords[2 * left + inc] === t) { swapItem(ids, coords, left, j); }\n        else {\n            j++;\n            swapItem(ids, coords, j, right);\n        }\n\n        if (j <= k) { left = j + 1; }\n        if (k <= j) { right = j - 1; }\n    }\n}\n\nfunction swapItem(ids, coords, i, j) {\n    swap(ids, i, j);\n    swap(coords, 2 * i, 2 * j);\n    swap(coords, 2 * i + 1, 2 * j + 1);\n}\n\nfunction swap(arr, i, j) {\n    var tmp = arr[i];\n    arr[i] = arr[j];\n    arr[j] = tmp;\n}\n\nfunction range(ids, coords, minX, minY, maxX, maxY, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var x, y;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                x = coords[2 * i];\n                y = coords[2 * i + 1];\n                if (x >= minX && x <= maxX && y >= minY && y <= maxY) { result.push(ids[i]); }\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        x = coords[2 * m];\n        y = coords[2 * m + 1];\n\n        if (x >= minX && x <= maxX && y >= minY && y <= maxY) { result.push(ids[m]); }\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? minX <= x : minY <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? maxX >= x : maxY >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction within(ids, coords, qx, qy, r, nodeSize) {\n    var stack = [0, ids.length - 1, 0];\n    var result = [];\n    var r2 = r * r;\n\n    while (stack.length) {\n        var axis = stack.pop();\n        var right = stack.pop();\n        var left = stack.pop();\n\n        if (right - left <= nodeSize) {\n            for (var i = left; i <= right; i++) {\n                if (sqDist(coords[2 * i], coords[2 * i + 1], qx, qy) <= r2) { result.push(ids[i]); }\n            }\n            continue;\n        }\n\n        var m = Math.floor((left + right) / 2);\n\n        var x = coords[2 * m];\n        var y = coords[2 * m + 1];\n\n        if (sqDist(x, y, qx, qy) <= r2) { result.push(ids[m]); }\n\n        var nextAxis = (axis + 1) % 2;\n\n        if (axis === 0 ? qx - r <= x : qy - r <= y) {\n            stack.push(left);\n            stack.push(m - 1);\n            stack.push(nextAxis);\n        }\n        if (axis === 0 ? qx + r >= x : qy + r >= y) {\n            stack.push(m + 1);\n            stack.push(right);\n            stack.push(nextAxis);\n        }\n    }\n\n    return result;\n}\n\nfunction sqDist(ax, ay, bx, by) {\n    var dx = ax - bx;\n    var dy = ay - by;\n    return dx * dx + dy * dy;\n}\n\nvar defaultGetX = function (p) { return p[0]; };\nvar defaultGetY = function (p) { return p[1]; };\n\nvar KDBush = function KDBush(points, getX, getY, nodeSize, ArrayType) {\n    if ( getX === void 0 ) getX = defaultGetX;\n    if ( getY === void 0 ) getY = defaultGetY;\n    if ( nodeSize === void 0 ) nodeSize = 64;\n    if ( ArrayType === void 0 ) ArrayType = Float64Array;\n\n    this.nodeSize = nodeSize;\n    this.points = points;\n\n    var IndexArrayType = points.length < 65536 ? Uint16Array : Uint32Array;\n\n    var ids = this.ids = new IndexArrayType(points.length);\n    var coords = this.coords = new ArrayType(points.length * 2);\n\n    for (var i = 0; i < points.length; i++) {\n        ids[i] = i;\n        coords[2 * i] = getX(points[i]);\n        coords[2 * i + 1] = getY(points[i]);\n    }\n\n    sortKD(ids, coords, nodeSize, 0, ids.length - 1, 0);\n};\n\nKDBush.prototype.range = function range$1 (minX, minY, maxX, maxY) {\n    return range(this.ids, this.coords, minX, minY, maxX, maxY, this.nodeSize);\n};\n\nKDBush.prototype.within = function within$1 (x, y, r) {\n    return within(this.ids, this.coords, x, y, r, this.nodeSize);\n};\n\nvar defaultOptions = {\n    minZoom: 0,   // min zoom to generate clusters on\n    maxZoom: 16,  // max zoom level to cluster the points on\n    minPoints: 2, // minimum points to form a cluster\n    radius: 40,   // cluster radius in pixels\n    extent: 512,  // tile extent (radius is calculated relative to it)\n    nodeSize: 64, // size of the KD-tree leaf node, affects performance\n    log: false,   // whether to log timing info\n\n    // whether to generate numeric ids for input features (in vector tiles)\n    generateId: false,\n\n    // a reduce function for calculating custom cluster properties\n    reduce: null, // (accumulated, props) => { accumulated.sum += props.sum; }\n\n    // properties to use for individual points when running the reducer\n    map: function (props) { return props; } // props => ({sum: props.my_value})\n};\n\nvar fround = Math.fround || (function (tmp) { return (function (x) { tmp[0] = +x; return tmp[0]; }); })(new Float32Array(1));\n\nvar Supercluster = function Supercluster(options) {\n    this.options = extend(Object.create(defaultOptions), options);\n    this.trees = new Array(this.options.maxZoom + 1);\n};\n\nSupercluster.prototype.load = function load (points) {\n    var ref = this.options;\n        var log = ref.log;\n        var minZoom = ref.minZoom;\n        var maxZoom = ref.maxZoom;\n        var nodeSize = ref.nodeSize;\n\n    if (log) { console.time('total time'); }\n\n    var timerId = \"prepare \" + (points.length) + \" points\";\n    if (log) { console.time(timerId); }\n\n    this.points = points;\n\n    // generate a cluster object for each point and index input points into a KD-tree\n    var clusters = [];\n    for (var i = 0; i < points.length; i++) {\n        if (!points[i].geometry) { continue; }\n        clusters.push(createPointCluster(points[i], i));\n    }\n    this.trees[maxZoom + 1] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n    if (log) { console.timeEnd(timerId); }\n\n    // cluster points on max zoom, then cluster the results on previous zoom, etc.;\n    // results in a cluster hierarchy across zoom levels\n    for (var z = maxZoom; z >= minZoom; z--) {\n        var now = +Date.now();\n\n        // create a new set of clusters for the zoom and index them with a KD-tree\n        clusters = this._cluster(clusters, z);\n        this.trees[z] = new KDBush(clusters, getX, getY, nodeSize, Float32Array);\n\n        if (log) { console.log('z%d: %d clusters in %dms', z, clusters.length, +Date.now() - now); }\n    }\n\n    if (log) { console.timeEnd('total time'); }\n\n    return this;\n};\n\nSupercluster.prototype.getClusters = function getClusters (bbox, zoom) {\n    var minLng = ((bbox[0] + 180) % 360 + 360) % 360 - 180;\n    var minLat = Math.max(-90, Math.min(90, bbox[1]));\n    var maxLng = bbox[2] === 180 ? 180 : ((bbox[2] + 180) % 360 + 360) % 360 - 180;\n    var maxLat = Math.max(-90, Math.min(90, bbox[3]));\n\n    if (bbox[2] - bbox[0] >= 360) {\n        minLng = -180;\n        maxLng = 180;\n    } else if (minLng > maxLng) {\n        var easternHem = this.getClusters([minLng, minLat, 180, maxLat], zoom);\n        var westernHem = this.getClusters([-180, minLat, maxLng, maxLat], zoom);\n        return easternHem.concat(westernHem);\n    }\n\n    var tree = this.trees[this._limitZoom(zoom)];\n    var ids = tree.range(lngX(minLng), latY(maxLat), lngX(maxLng), latY(minLat));\n    var clusters = [];\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n        var id = list[i];\n\n            var c = tree.points[id];\n        clusters.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n    }\n    return clusters;\n};\n\nSupercluster.prototype.getChildren = function getChildren (clusterId) {\n    var originId = this._getOriginId(clusterId);\n    var originZoom = this._getOriginZoom(clusterId);\n    var errorMsg = 'No cluster with the specified id.';\n\n    var index = this.trees[originZoom];\n    if (!index) { throw new Error(errorMsg); }\n\n    var origin = index.points[originId];\n    if (!origin) { throw new Error(errorMsg); }\n\n    var r = this.options.radius / (this.options.extent * Math.pow(2, originZoom - 1));\n    var ids = index.within(origin.x, origin.y, r);\n    var children = [];\n    for (var i = 0, list = ids; i < list.length; i += 1) {\n        var id = list[i];\n\n            var c = index.points[id];\n        if (c.parentId === clusterId) {\n            children.push(c.numPoints ? getClusterJSON(c) : this.points[c.index]);\n        }\n    }\n\n    if (children.length === 0) { throw new Error(errorMsg); }\n\n    return children;\n};\n\nSupercluster.prototype.getLeaves = function getLeaves (clusterId, limit, offset) {\n    limit = limit || 10;\n    offset = offset || 0;\n\n    var leaves = [];\n    this._appendLeaves(leaves, clusterId, limit, offset, 0);\n\n    return leaves;\n};\n\nSupercluster.prototype.getTile = function getTile (z, x, y) {\n    var tree = this.trees[this._limitZoom(z)];\n    var z2 = Math.pow(2, z);\n    var ref = this.options;\n        var extent = ref.extent;\n        var radius = ref.radius;\n    var p = radius / extent;\n    var top = (y - p) / z2;\n    var bottom = (y + 1 + p) / z2;\n\n    var tile = {\n        features: []\n    };\n\n    this._addTileFeatures(\n        tree.range((x - p) / z2, top, (x + 1 + p) / z2, bottom),\n        tree.points, x, y, z2, tile);\n\n    if (x === 0) {\n        this._addTileFeatures(\n            tree.range(1 - p / z2, top, 1, bottom),\n            tree.points, z2, y, z2, tile);\n    }\n    if (x === z2 - 1) {\n        this._addTileFeatures(\n            tree.range(0, top, p / z2, bottom),\n            tree.points, -1, y, z2, tile);\n    }\n\n    return tile.features.length ? tile : null;\n};\n\nSupercluster.prototype.getClusterExpansionZoom = function getClusterExpansionZoom (clusterId) {\n    var expansionZoom = this._getOriginZoom(clusterId) - 1;\n    while (expansionZoom <= this.options.maxZoom) {\n        var children = this.getChildren(clusterId);\n        expansionZoom++;\n        if (children.length !== 1) { break; }\n        clusterId = children[0].properties.cluster_id;\n    }\n    return expansionZoom;\n};\n\nSupercluster.prototype._appendLeaves = function _appendLeaves (result, clusterId, limit, offset, skipped) {\n    var children = this.getChildren(clusterId);\n\n    for (var i = 0, list = children; i < list.length; i += 1) {\n        var child = list[i];\n\n            var props = child.properties;\n\n        if (props && props.cluster) {\n            if (skipped + props.point_count <= offset) {\n                // skip the whole cluster\n                skipped += props.point_count;\n            } else {\n                // enter the cluster\n                skipped = this._appendLeaves(result, props.cluster_id, limit, offset, skipped);\n                // exit the cluster\n            }\n        } else if (skipped < offset) {\n            // skip a single point\n            skipped++;\n        } else {\n            // add a single point\n            result.push(child);\n        }\n        if (result.length === limit) { break; }\n    }\n\n    return skipped;\n};\n\nSupercluster.prototype._addTileFeatures = function _addTileFeatures (ids, points, x, y, z2, tile) {\n    for (var i$1 = 0, list = ids; i$1 < list.length; i$1 += 1) {\n        var i = list[i$1];\n\n            var c = points[i];\n        var isCluster = c.numPoints;\n\n        var tags = (void 0), px = (void 0), py = (void 0);\n        if (isCluster) {\n            tags = getClusterProperties(c);\n            px = c.x;\n            py = c.y;\n        } else {\n            var p = this.points[c.index];\n            tags = p.properties;\n            px = lngX(p.geometry.coordinates[0]);\n            py = latY(p.geometry.coordinates[1]);\n        }\n\n        var f = {\n            type: 1,\n            geometry: [[\n                Math.round(this.options.extent * (px * z2 - x)),\n                Math.round(this.options.extent * (py * z2 - y))\n            ]],\n            tags: tags\n        };\n\n        // assign id\n        var id = (void 0);\n        if (isCluster) {\n            id = c.id;\n        } else if (this.options.generateId) {\n            // optionally generate id\n            id = c.index;\n        } else if (this.points[c.index].id) {\n            // keep id if already assigned\n            id = this.points[c.index].id;\n        }\n\n        if (id !== undefined) { f.id = id; }\n\n        tile.features.push(f);\n    }\n};\n\nSupercluster.prototype._limitZoom = function _limitZoom (z) {\n    return Math.max(this.options.minZoom, Math.min(+z, this.options.maxZoom + 1));\n};\n\nSupercluster.prototype._cluster = function _cluster (points, zoom) {\n    var clusters = [];\n    var ref = this.options;\n        var radius = ref.radius;\n        var extent = ref.extent;\n        var reduce = ref.reduce;\n        var minPoints = ref.minPoints;\n    var r = radius / (extent * Math.pow(2, zoom));\n\n    // loop through each point\n    for (var i = 0; i < points.length; i++) {\n        var p = points[i];\n        // if we've already visited the point at this zoom level, skip it\n        if (p.zoom <= zoom) { continue; }\n        p.zoom = zoom;\n\n        // find all nearby points\n        var tree = this.trees[zoom + 1];\n        var neighborIds = tree.within(p.x, p.y, r);\n\n        var numPointsOrigin = p.numPoints || 1;\n        var numPoints = numPointsOrigin;\n\n        // count the number of points in a potential cluster\n        for (var i$1 = 0, list = neighborIds; i$1 < list.length; i$1 += 1) {\n            var neighborId = list[i$1];\n\n                var b = tree.points[neighborId];\n            // filter out neighbors that are already processed\n            if (b.zoom > zoom) { numPoints += b.numPoints || 1; }\n        }\n\n        // if there were neighbors to merge, and there are enough points to form a cluster\n        if (numPoints > numPointsOrigin && numPoints >= minPoints) {\n            var wx = p.x * numPointsOrigin;\n            var wy = p.y * numPointsOrigin;\n\n            var clusterProperties = reduce && numPointsOrigin > 1 ? this._map(p, true) : null;\n\n            // encode both zoom and point index on which the cluster originated -- offset by total length of features\n            var id = (i << 5) + (zoom + 1) + this.points.length;\n\n            for (var i$2 = 0, list$1 = neighborIds; i$2 < list$1.length; i$2 += 1) {\n                var neighborId$1 = list$1[i$2];\n\n                    var b$1 = tree.points[neighborId$1];\n\n                if (b$1.zoom <= zoom) { continue; }\n                b$1.zoom = zoom; // save the zoom (so it doesn't get processed twice)\n\n                var numPoints2 = b$1.numPoints || 1;\n                wx += b$1.x * numPoints2; // accumulate coordinates for calculating weighted center\n                wy += b$1.y * numPoints2;\n\n                b$1.parentId = id;\n\n                if (reduce) {\n                    if (!clusterProperties) { clusterProperties = this._map(p, true); }\n                    reduce(clusterProperties, this._map(b$1));\n                }\n            }\n\n            p.parentId = id;\n            clusters.push(createCluster(wx / numPoints, wy / numPoints, id, numPoints, clusterProperties));\n\n        } else { // left points as unclustered\n            clusters.push(p);\n\n            if (numPoints > 1) {\n                for (var i$3 = 0, list$2 = neighborIds; i$3 < list$2.length; i$3 += 1) {\n                    var neighborId$2 = list$2[i$3];\n\n                        var b$2 = tree.points[neighborId$2];\n                    if (b$2.zoom <= zoom) { continue; }\n                    b$2.zoom = zoom;\n                    clusters.push(b$2);\n                }\n            }\n        }\n    }\n\n    return clusters;\n};\n\n// get index of the point from which the cluster originated\nSupercluster.prototype._getOriginId = function _getOriginId (clusterId) {\n    return (clusterId - this.points.length) >> 5;\n};\n\n// get zoom of the point from which the cluster originated\nSupercluster.prototype._getOriginZoom = function _getOriginZoom (clusterId) {\n    return (clusterId - this.points.length) % 32;\n};\n\nSupercluster.prototype._map = function _map (point, clone) {\n    if (point.numPoints) {\n        return clone ? extend({}, point.properties) : point.properties;\n    }\n    var original = this.points[point.index].properties;\n    var result = this.options.map(original);\n    return clone && result === original ? extend({}, result) : result;\n};\n\nfunction createCluster(x, y, id, numPoints, properties) {\n    return {\n        x: fround(x), // weighted cluster center; round for consistency with Float32Array index\n        y: fround(y),\n        zoom: Infinity, // the last zoom the cluster was processed at\n        id: id, // encodes index of the first child of the cluster and its zoom level\n        parentId: -1, // parent cluster id\n        numPoints: numPoints,\n        properties: properties\n    };\n}\n\nfunction createPointCluster(p, id) {\n    var ref = p.geometry.coordinates;\n    var x = ref[0];\n    var y = ref[1];\n    return {\n        x: fround(lngX(x)), // projected point coordinates\n        y: fround(latY(y)),\n        zoom: Infinity, // the last zoom the point was processed at\n        index: id, // index of the source feature in the original input array,\n        parentId: -1 // parent cluster id\n    };\n}\n\nfunction getClusterJSON(cluster) {\n    return {\n        type: 'Feature',\n        id: cluster.id,\n        properties: getClusterProperties(cluster),\n        geometry: {\n            type: 'Point',\n            coordinates: [xLng(cluster.x), yLat(cluster.y)]\n        }\n    };\n}\n\nfunction getClusterProperties(cluster) {\n    var count = cluster.numPoints;\n    var abbrev =\n        count >= 10000 ? ((Math.round(count / 1000)) + \"k\") :\n        count >= 1000 ? ((Math.round(count / 100) / 10) + \"k\") : count;\n    return extend(extend({}, cluster.properties), {\n        cluster: true,\n        cluster_id: cluster.id,\n        point_count: count,\n        point_count_abbreviated: abbrev\n    });\n}\n\n// longitude/latitude to spherical mercator in [0..1] range\nfunction lngX(lng) {\n    return lng / 360 + 0.5;\n}\nfunction latY(lat) {\n    var sin = Math.sin(lat * Math.PI / 180);\n    var y = (0.5 - 0.25 * Math.log((1 + sin) / (1 - sin)) / Math.PI);\n    return y < 0 ? 0 : y > 1 ? 1 : y;\n}\n\n// spherical mercator to longitude/latitude\nfunction xLng(x) {\n    return (x - 0.5) * 360;\n}\nfunction yLat(y) {\n    var y2 = (180 - y * 360) * Math.PI / 180;\n    return 360 * Math.atan(Math.exp(y2)) / Math.PI - 90;\n}\n\nfunction extend(dest, src) {\n    for (var id in src) { dest[id] = src[id]; }\n    return dest;\n}\n\nfunction getX(p) {\n    return p.x;\n}\nfunction getY(p) {\n    return p.y;\n}\n\nreturn Supercluster;\n\n}));\n"]},"metadata":{},"sourceType":"script"}