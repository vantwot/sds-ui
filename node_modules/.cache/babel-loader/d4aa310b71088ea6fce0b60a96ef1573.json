{"ast":null,"code":"import _toConsumableArray from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _get from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/get\";\nimport _getPrototypeOf from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/getPrototypeOf\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { Registry } from '../registry';\nimport { Point, Rectangle, Angle } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt } from '../util';\nimport { Markup } from '../view/markup';\nimport { Cell } from './cell';\nimport { ShareRegistry } from './registry';\nimport { PortManager } from './port';\nimport { Interp } from '../common';\nexport var Node = /*#__PURE__*/function (_Cell, _Symbol$toStringTag) {\n  _inherits(Node, _Cell);\n\n  var _super = _createSuper(Node);\n\n  function Node() {\n    var _this;\n\n    var metadata = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    _classCallCheck(this, Node);\n\n    _this = _super.call(this, metadata);\n\n    _this.initPorts();\n\n    return _this;\n  }\n\n  _createClass(Node, [{\n    key: _Symbol$toStringTag,\n    get: function get() {\n      return Node.toStringTag;\n    }\n  }, {\n    key: \"preprocess\",\n    value: function preprocess(metadata, ignoreIdCheck) {\n      var x = metadata.x,\n          y = metadata.y,\n          width = metadata.width,\n          height = metadata.height,\n          others = __rest(metadata, [\"x\", \"y\", \"width\", \"height\"]);\n\n      if (x != null || y != null) {\n        var position = others.position;\n        others.position = Object.assign(Object.assign({}, position), {\n          x: x != null ? x : position ? position.x : 0,\n          y: y != null ? y : position ? position.y : 0\n        });\n      }\n\n      if (width != null || height != null) {\n        var size = others.size;\n        others.size = Object.assign(Object.assign({}, size), {\n          width: width != null ? width : size ? size.width : 0,\n          height: height != null ? height : size ? size.height : 0\n        });\n      }\n\n      return _get(_getPrototypeOf(Node.prototype), \"preprocess\", this).call(this, others, ignoreIdCheck);\n    }\n  }, {\n    key: \"isNode\",\n    value: function isNode() {\n      return true;\n    }\n  }, {\n    key: \"size\",\n    value: function size(width, height, options) {\n      if (width === undefined) {\n        return this.getSize();\n      }\n\n      if (typeof width === 'number') {\n        return this.setSize(width, height, options);\n      }\n\n      return this.setSize(width, height);\n    }\n  }, {\n    key: \"getSize\",\n    value: function getSize() {\n      var size = this.store.get('size');\n      return size ? Object.assign({}, size) : {\n        width: 1,\n        height: 1\n      };\n    }\n  }, {\n    key: \"setSize\",\n    value: function setSize(width, height, options) {\n      if (typeof width === 'object') {\n        this.resize(width.width, width.height, height);\n      } else {\n        this.resize(width, height, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"resize\",\n    value: function resize(width, height) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      this.startBatch('resize', options);\n      var direction = options.direction;\n\n      if (direction) {\n        var currentSize = this.getSize();\n\n        switch (direction) {\n          case 'left':\n          case 'right':\n            // Don't change height when resizing horizontally.\n            height = currentSize.height; // eslint-disable-line\n\n            break;\n\n          case 'top':\n          case 'bottom':\n            // Don't change width when resizing vertically.\n            width = currentSize.width; // eslint-disable-line\n\n            break;\n\n          default:\n            break;\n        }\n\n        var map = {\n          right: 0,\n          'top-right': 0,\n          top: 1,\n          'top-left': 1,\n          left: 2,\n          'bottom-left': 2,\n          bottom: 3,\n          'bottom-right': 3\n        };\n        var quadrant = map[direction];\n        var angle = Angle.normalize(this.getAngle() || 0);\n\n        if (options.absolute) {\n          // We are taking the node's rotation into account\n          quadrant += Math.floor((angle + 45) / 90);\n          quadrant %= 4;\n        } // This is a rectangle in size of the un-rotated node.\n\n\n        var bbox = this.getBBox(); // Pick the corner point on the node, which meant to stay on its\n        // place before and after the rotation.\n\n        var fixedPoint;\n\n        if (quadrant === 0) {\n          fixedPoint = bbox.getBottomLeft();\n        } else if (quadrant === 1) {\n          fixedPoint = bbox.getCorner();\n        } else if (quadrant === 2) {\n          fixedPoint = bbox.getTopRight();\n        } else {\n          fixedPoint = bbox.getOrigin();\n        } // Find an image of the previous indent point. This is the position,\n        // where is the point actually located on the screen.\n\n\n        var imageFixedPoint = fixedPoint.clone().rotate(-angle, bbox.getCenter()); // Every point on the element rotates around a circle with the centre of\n        // rotation in the middle of the element while the whole element is being\n        // rotated. That means that the distance from a point in the corner of\n        // the element (supposed its always rect) to the center of the element\n        // doesn't change during the rotation and therefore it equals to a\n        // distance on un-rotated element.\n        // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n\n        var radius = Math.sqrt(width * width + height * height) / 2; // Now we are looking for an angle between x-axis and the line starting\n        // at image of fixed point and ending at the center of the element.\n        // We call this angle `alpha`.\n        // The image of a fixed point is located in n-th quadrant. For each\n        // quadrant passed going anti-clockwise we have to add 90 degrees.\n        // Note that the first quadrant has index 0.\n        //\n        // 3 | 2\n        // --c-- Quadrant positions around the element's center `c`\n        // 0 | 1\n        //\n\n        var alpha = quadrant * Math.PI / 2; // Add an angle between the beginning of the current quadrant (line\n        // parallel with x-axis or y-axis going through the center of the\n        // element) and line crossing the indent of the fixed point and the\n        // center of the element. This is the angle we need but on the\n        // un-rotated element.\n\n        alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height); // Lastly we have to deduct the original angle the element was rotated\n        // by and that's it.\n\n        alpha -= Angle.toRad(angle); // With this angle and distance we can easily calculate the centre of\n        // the un-rotated element.\n        // Note that fromPolar constructor accepts an angle in radians.\n\n        var center = Point.fromPolar(radius, alpha, imageFixedPoint); // The top left corner on the un-rotated element has to be half a width\n        // on the left and half a height to the top from the center. This will\n        // be the origin of rectangle we were looking for.\n\n        var origin = center.clone().translate(width / -2, height / -2);\n        this.store.set('size', {\n          width: width,\n          height: height\n        }, options);\n        this.setPosition(origin.x, origin.y, options);\n      } else {\n        this.store.set('size', {\n          width: width,\n          height: height\n        }, options);\n      }\n\n      this.stopBatch('resize', options);\n      return this;\n    }\n  }, {\n    key: \"scale\",\n    value: function scale(sx, sy, origin) {\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      var scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);\n      this.startBatch('scale', options);\n      this.setPosition(scaledBBox.x, scaledBBox.y, options);\n      this.resize(scaledBBox.width, scaledBBox.height, options);\n      this.stopBatch('scale');\n      return this;\n    }\n  }, {\n    key: \"position\",\n    value: function position(arg0, arg1, arg2) {\n      if (typeof arg0 === 'number') {\n        return this.setPosition(arg0, arg1, arg2);\n      }\n\n      return this.getPosition(arg0);\n    }\n  }, {\n    key: \"getPosition\",\n    value: function getPosition() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.relative) {\n        var parent = this.getParent();\n\n        if (parent != null && parent.isNode()) {\n          var currentPosition = this.getPosition();\n          var parentPosition = parent.getPosition();\n          return {\n            x: currentPosition.x - parentPosition.x,\n            y: currentPosition.y - parentPosition.y\n          };\n        }\n      }\n\n      var pos = this.store.get('position');\n      return pos ? Object.assign({}, pos) : {\n        x: 0,\n        y: 0\n      };\n    }\n  }, {\n    key: \"setPosition\",\n    value: function setPosition(arg0, arg1) {\n      var arg2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n      var x;\n      var y;\n      var options;\n\n      if (typeof arg0 === 'object') {\n        x = arg0.x;\n        y = arg0.y;\n        options = arg1 || {};\n      } else {\n        x = arg0;\n        y = arg1;\n        options = arg2 || {};\n      }\n\n      if (options.relative) {\n        var parent = this.getParent();\n\n        if (parent != null && parent.isNode()) {\n          var parentPosition = parent.getPosition();\n          x += parentPosition.x;\n          y += parentPosition.y;\n        }\n      }\n\n      if (options.deep) {\n        var currentPosition = this.getPosition();\n        this.translate(x - currentPosition.x, y - currentPosition.y, options);\n      } else {\n        this.store.set('position', {\n          x: x,\n          y: y\n        }, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"translate\",\n    value: function translate() {\n      var tx = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var ty = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      if (tx === 0 && ty === 0) {\n        return this;\n      } // Pass the initiator of the translation.\n\n\n      options.translateBy = options.translateBy || this.id;\n      var position = this.getPosition();\n\n      if (options.restrict != null && options.translateBy === this.id) {\n        // We are restricting the translation for the element itself only. We get\n        // the bounding box of the element including all its embeds.\n        // All embeds have to be translated the exact same way as the element.\n        var bbox = this.getBBox({\n          deep: true\n        });\n        var ra = options.restrict; // - - - - - - - - - - - - -> ra.x + ra.width\n        // - - - -> position.x      |\n        // -> bbox.x\n        //                ▓▓▓▓▓▓▓   |\n        //         ░░░░░░░▓▓▓▓▓▓▓\n        //         ░░░░░░░░░        |\n        //   ▓▓▓▓▓▓▓▓░░░░░░░\n        //   ▓▓▓▓▓▓▓▓               |\n        //   <-dx->                     | restricted area right border\n        //         <-width->        |   ░ translated element\n        //   <- - bbox.width - ->       ▓ embedded element\n\n        var dx = position.x - bbox.x;\n        var dy = position.y - bbox.y; // Find the maximal/minimal coordinates that the element can be translated\n        // while complies the restrictions.\n\n        var x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n        var y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty)); // recalculate the translation taking the restrictions into account.\n\n        tx = x - position.x; // eslint-disable-line\n\n        ty = y - position.y; // eslint-disable-line\n      }\n\n      var translatedPosition = {\n        x: position.x + tx,\n        y: position.y + ty\n      }; // To find out by how much an element was translated in event\n      // 'change:position' handlers.\n\n      options.tx = tx;\n      options.ty = ty;\n\n      if (options.transition) {\n        if (typeof options.transition !== 'object') {\n          options.transition = {};\n        }\n\n        this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), {\n          interp: Interp.object\n        }));\n        this.eachChild(function (child) {\n          var _a;\n\n          var excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n\n          if (!excluded) {\n            child.translate(tx, ty, options);\n          }\n        });\n      } else {\n        this.startBatch('translate', options);\n        this.store.set('position', translatedPosition, options);\n        this.eachChild(function (child) {\n          var _a;\n\n          var excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n\n          if (!excluded) {\n            child.translate(tx, ty, options);\n          }\n        });\n        this.stopBatch('translate', options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"angle\",\n    value: function angle(val, options) {\n      if (val == null) {\n        return this.getAngle();\n      }\n\n      return this.rotate(val, options);\n    }\n  }, {\n    key: \"getAngle\",\n    value: function getAngle() {\n      return this.store.get('angle', 0);\n    }\n  }, {\n    key: \"rotate\",\n    value: function rotate(angle) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var currentAngle = this.getAngle();\n\n      if (options.center) {\n        var size = this.getSize();\n        var position = this.getPosition();\n        var center = this.getBBox().getCenter();\n        center.rotate(currentAngle - angle, options.center);\n        var dx = center.x - size.width / 2 - position.x;\n        var dy = center.y - size.height / 2 - position.y;\n        this.startBatch('rotate', {\n          angle: angle,\n          options: options\n        });\n        this.setPosition(position.x + dx, position.y + dy, options);\n        this.rotate(angle, Object.assign(Object.assign({}, options), {\n          center: null\n        }));\n        this.stopBatch('rotate');\n      } else {\n        this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);\n      }\n\n      return this;\n    } // #endregion\n    // #region common\n\n  }, {\n    key: \"getBBox\",\n    value: function getBBox() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (options.deep) {\n        var cells = this.getDescendants({\n          deep: true,\n          breadthFirst: true\n        });\n        cells.push(this);\n        return Cell.getCellsBBox(cells);\n      }\n\n      return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());\n    }\n  }, {\n    key: \"getConnectionPoint\",\n    value: function getConnectionPoint(edge, type) {\n      var bbox = this.getBBox();\n      var center = bbox.getCenter();\n      var terminal = edge.getTerminal(type);\n\n      if (terminal == null) {\n        return center;\n      }\n\n      var portId = terminal.port;\n\n      if (!portId || !this.hasPort(portId)) {\n        return center;\n      }\n\n      var port = this.getPort(portId);\n\n      if (!port || !port.group) {\n        return center;\n      }\n\n      var layouts = this.getPortsPosition(port.group);\n      var position = layouts[portId].position;\n      var portCenter = Point.create(position).translate(bbox.getOrigin());\n      var angle = this.getAngle();\n\n      if (angle) {\n        portCenter.rotate(-angle, center);\n      }\n\n      return portCenter;\n    }\n    /**\n     * Sets cell's size and position based on the children bbox and given padding.\n     */\n\n  }, {\n    key: \"fit\",\n    value: function fit() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      var children = this.getChildren() || [];\n      var embeds = children.filter(function (cell) {\n        return cell.isNode();\n      });\n\n      if (embeds.length === 0) {\n        return this;\n      }\n\n      this.startBatch('fit-embeds', options);\n\n      if (options.deep) {\n        embeds.forEach(function (cell) {\n          return cell.fit(options);\n        });\n      }\n\n      var _Cell$getCellsBBox = Cell.getCellsBBox(embeds),\n          x = _Cell$getCellsBBox.x,\n          y = _Cell$getCellsBBox.y,\n          width = _Cell$getCellsBBox.width,\n          height = _Cell$getCellsBBox.height;\n\n      var padding = NumberExt.normalizeSides(options.padding);\n      x -= padding.left;\n      y -= padding.top;\n      width += padding.left + padding.right;\n      height += padding.bottom + padding.top;\n      this.store.set({\n        position: {\n          x: x,\n          y: y\n        },\n        size: {\n          width: width,\n          height: height\n        }\n      }, options);\n      this.stopBatch('fit-embeds');\n      return this;\n    } // #endregion\n    // #region ports\n\n  }, {\n    key: \"portContainerMarkup\",\n    get: function get() {\n      return this.getPortContainerMarkup();\n    }\n  }, {\n    key: \"portContainerMarkup\",\n    set: function set(markup) {\n      this.setPortContainerMarkup(markup);\n    }\n  }, {\n    key: \"getDefaultPortContainerMarkup\",\n    value: function getDefaultPortContainerMarkup() {\n      return this.store.get('defaultPortContainerMarkup') || Markup.getPortContainerMarkup();\n    }\n  }, {\n    key: \"getPortContainerMarkup\",\n    value: function getPortContainerMarkup() {\n      return this.store.get('portContainerMarkup') || this.getDefaultPortContainerMarkup();\n    }\n  }, {\n    key: \"setPortContainerMarkup\",\n    value: function setPortContainerMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('portContainerMarkup', Markup.clone(markup), options);\n      return this;\n    }\n  }, {\n    key: \"portMarkup\",\n    get: function get() {\n      return this.getPortMarkup();\n    }\n  }, {\n    key: \"portMarkup\",\n    set: function set(markup) {\n      this.setPortMarkup(markup);\n    }\n  }, {\n    key: \"getDefaultPortMarkup\",\n    value: function getDefaultPortMarkup() {\n      return this.store.get('defaultPortMarkup') || Markup.getPortMarkup();\n    }\n  }, {\n    key: \"getPortMarkup\",\n    value: function getPortMarkup() {\n      return this.store.get('portMarkup') || this.getDefaultPortMarkup();\n    }\n  }, {\n    key: \"setPortMarkup\",\n    value: function setPortMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('portMarkup', Markup.clone(markup), options);\n      return this;\n    }\n  }, {\n    key: \"portLabelMarkup\",\n    get: function get() {\n      return this.getPortLabelMarkup();\n    }\n  }, {\n    key: \"portLabelMarkup\",\n    set: function set(markup) {\n      this.setPortLabelMarkup(markup);\n    }\n  }, {\n    key: \"getDefaultPortLabelMarkup\",\n    value: function getDefaultPortLabelMarkup() {\n      return this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup();\n    }\n  }, {\n    key: \"getPortLabelMarkup\",\n    value: function getPortLabelMarkup() {\n      return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();\n    }\n  }, {\n    key: \"setPortLabelMarkup\",\n    value: function setPortLabelMarkup(markup) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      this.store.set('portLabelMarkup', Markup.clone(markup), options);\n      return this;\n    }\n  }, {\n    key: \"ports\",\n    get: function get() {\n      var res = this.store.get('ports', {\n        items: []\n      });\n\n      if (res.items == null) {\n        res.items = [];\n      }\n\n      return res;\n    }\n  }, {\n    key: \"getPorts\",\n    value: function getPorts() {\n      return ObjectExt.cloneDeep(this.ports.items);\n    }\n  }, {\n    key: \"getPortsByGroup\",\n    value: function getPortsByGroup(groupName) {\n      return this.getPorts().filter(function (port) {\n        return port.group === groupName;\n      });\n    }\n  }, {\n    key: \"getPort\",\n    value: function getPort(portId) {\n      return ObjectExt.cloneDeep(this.ports.items.find(function (port) {\n        return port.id && port.id === portId;\n      }));\n    }\n  }, {\n    key: \"getPortAt\",\n    value: function getPortAt(index) {\n      return this.ports.items[index] || null;\n    }\n  }, {\n    key: \"hasPorts\",\n    value: function hasPorts() {\n      return this.ports.items.length > 0;\n    }\n  }, {\n    key: \"hasPort\",\n    value: function hasPort(portId) {\n      return this.getPortIndex(portId) !== -1;\n    }\n  }, {\n    key: \"getPortIndex\",\n    value: function getPortIndex(port) {\n      var portId = typeof port === 'string' ? port : port.id;\n      return portId != null ? this.ports.items.findIndex(function (item) {\n        return item.id === portId;\n      }) : -1;\n    }\n  }, {\n    key: \"getPortsPosition\",\n    value: function getPortsPosition(groupName) {\n      var size = this.getSize();\n      var layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size.width, size.height));\n      return layouts.reduce(function (memo, item) {\n        var layout = item.portLayout;\n        memo[item.portId] = {\n          position: Object.assign({}, layout.position),\n          angle: layout.angle || 0\n        };\n        return memo;\n      }, {});\n    }\n  }, {\n    key: \"getPortProp\",\n    value: function getPortProp(portId, path) {\n      return this.getPropByPath(this.prefixPortPath(portId, path));\n    }\n  }, {\n    key: \"setPortProp\",\n    value: function setPortProp(portId, arg1, arg2, arg3) {\n      if (typeof arg1 === 'string' || Array.isArray(arg1)) {\n        var _path = this.prefixPortPath(portId, arg1);\n\n        var _value = arg2;\n        return this.setPropByPath(_path, _value, arg3);\n      }\n\n      var path = this.prefixPortPath(portId);\n      var value = arg1;\n      return this.setPropByPath(path, value, arg2);\n    }\n  }, {\n    key: \"removePortProp\",\n    value: function removePortProp(portId, path, options) {\n      if (typeof path === 'string' || Array.isArray(path)) {\n        return this.removePropByPath(this.prefixPortPath(portId, path), options);\n      }\n\n      return this.removePropByPath(this.prefixPortPath(portId), path);\n    }\n  }, {\n    key: \"portProp\",\n    value: function portProp(portId, path, value, options) {\n      if (path == null) {\n        return this.getPortProp(portId);\n      }\n\n      if (typeof path === 'string' || Array.isArray(path)) {\n        if (arguments.length === 2) {\n          return this.getPortProp(portId, path);\n        }\n\n        if (value == null) {\n          return this.removePortProp(portId, path, options);\n        }\n\n        return this.setPortProp(portId, path, value, options);\n      }\n\n      return this.setPortProp(portId, path, value);\n    }\n  }, {\n    key: \"prefixPortPath\",\n    value: function prefixPortPath(portId, path) {\n      var index = this.getPortIndex(portId);\n\n      if (index === -1) {\n        throw new Error(\"Unable to find port with id: \\\"\".concat(portId, \"\\\"\"));\n      }\n\n      if (path == null || path === '') {\n        return ['ports', 'items', \"\".concat(index)];\n      }\n\n      if (Array.isArray(path)) {\n        return ['ports', 'items', \"\".concat(index)].concat(_toConsumableArray(path));\n      }\n\n      return \"ports/items/\".concat(index, \"/\").concat(path);\n    }\n  }, {\n    key: \"addPort\",\n    value: function addPort(port, options) {\n      var ports = _toConsumableArray(this.ports.items);\n\n      ports.push(port);\n      this.setPropByPath('ports/items', ports, options);\n      return this;\n    }\n  }, {\n    key: \"addPorts\",\n    value: function addPorts(ports, options) {\n      this.setPropByPath('ports/items', [].concat(_toConsumableArray(this.ports.items), _toConsumableArray(ports)), options);\n      return this;\n    }\n  }, {\n    key: \"removePort\",\n    value: function removePort(port) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      return this.removePortAt(this.getPortIndex(port), options);\n    }\n  }, {\n    key: \"removePortAt\",\n    value: function removePortAt(index) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      if (index >= 0) {\n        var ports = _toConsumableArray(this.ports.items);\n\n        ports.splice(index, 1);\n        options.rewrite = true;\n        this.setPropByPath('ports/items', ports, options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"removePorts\",\n    value: function removePorts(portsForRemoval, opt) {\n      var options;\n\n      if (Array.isArray(portsForRemoval)) {\n        options = opt || {};\n\n        if (portsForRemoval.length) {\n          options.rewrite = true;\n\n          var currentPorts = _toConsumableArray(this.ports.items);\n\n          var remainingPorts = currentPorts.filter(function (cp) {\n            return !portsForRemoval.some(function (p) {\n              var id = typeof p === 'string' ? p : p.id;\n              return cp.id === id;\n            });\n          });\n          this.setPropByPath('ports/items', remainingPorts, options);\n        }\n      } else {\n        options = portsForRemoval || {};\n        options.rewrite = true;\n        this.setPropByPath('ports/items', [], options);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"getParsedPorts\",\n    value: function getParsedPorts() {\n      return this.port.getPorts();\n    }\n  }, {\n    key: \"getParsedGroups\",\n    value: function getParsedGroups() {\n      return this.port.groups;\n    }\n  }, {\n    key: \"getPortsLayoutByGroup\",\n    value: function getPortsLayoutByGroup(groupName, bbox) {\n      return this.port.getPortsLayoutByGroup(groupName, bbox);\n    }\n  }, {\n    key: \"initPorts\",\n    value: function initPorts() {\n      var _this2 = this;\n\n      this.updatePortData();\n      this.on('change:ports', function () {\n        _this2.processRemovedPort();\n\n        _this2.updatePortData();\n      });\n    }\n  }, {\n    key: \"processRemovedPort\",\n    value: function processRemovedPort() {\n      var current = this.ports;\n      var currentItemsMap = {};\n      current.items.forEach(function (item) {\n        if (item.id) {\n          currentItemsMap[item.id] = true;\n        }\n      });\n      var removed = {};\n      var previous = this.store.getPrevious('ports') || {\n        items: []\n      };\n      previous.items.forEach(function (item) {\n        if (item.id && !currentItemsMap[item.id]) {\n          removed[item.id] = true;\n        }\n      });\n      var model = this.model;\n\n      if (model && !ObjectExt.isEmpty(removed)) {\n        var incomings = model.getConnectedEdges(this, {\n          incoming: true\n        });\n        incomings.forEach(function (edge) {\n          var portId = edge.getTargetPortId();\n\n          if (portId && removed[portId]) {\n            edge.remove();\n          }\n        });\n        var outgoings = model.getConnectedEdges(this, {\n          outgoing: true\n        });\n        outgoings.forEach(function (edge) {\n          var portId = edge.getSourcePortId();\n\n          if (portId && removed[portId]) {\n            edge.remove();\n          }\n        });\n      }\n    }\n  }, {\n    key: \"validatePorts\",\n    value: function validatePorts() {\n      var _this3 = this;\n\n      var ids = {};\n      var errors = [];\n      this.ports.items.forEach(function (p) {\n        if (typeof p !== 'object') {\n          errors.push(\"Invalid port \".concat(p, \".\"));\n        }\n\n        if (p.id == null) {\n          p.id = _this3.generatePortId();\n        }\n\n        if (ids[p.id]) {\n          errors.push('Duplicitied port id.');\n        }\n\n        ids[p.id] = true;\n      });\n      return errors;\n    }\n  }, {\n    key: \"generatePortId\",\n    value: function generatePortId() {\n      return StringExt.uuid();\n    }\n  }, {\n    key: \"updatePortData\",\n    value: function updatePortData() {\n      var err = this.validatePorts();\n\n      if (err.length > 0) {\n        this.store.set('ports', this.store.getPrevious('ports'));\n        throw new Error(err.join(' '));\n      }\n\n      var prev = this.port ? this.port.getPorts() : null;\n      this.port = new PortManager(this.ports);\n      var curr = this.port.getPorts();\n      var added = prev ? curr.filter(function (item) {\n        if (!prev.find(function (prevPort) {\n          return prevPort.id === item.id;\n        })) {\n          return item;\n        }\n\n        return null;\n      }) : _toConsumableArray(curr);\n      var removed = prev ? prev.filter(function (item) {\n        if (!curr.find(function (curPort) {\n          return curPort.id === item.id;\n        })) {\n          return item;\n        }\n\n        return null;\n      }) : [];\n\n      if (added.length > 0) {\n        this.notify('ports:added', {\n          added: added,\n          cell: this,\n          node: this\n        });\n      }\n\n      if (removed.length > 0) {\n        this.notify('ports:removed', {\n          removed: removed,\n          cell: this,\n          node: this\n        });\n      }\n    }\n  }]);\n\n  return Node;\n}(Cell, Symbol.toStringTag);\nNode.defaults = {\n  angle: 0,\n  position: {\n    x: 0,\n    y: 0\n  },\n  size: {\n    width: 1,\n    height: 1\n  }\n};\n\n(function (Node) {\n  Node.toStringTag = \"X6.\".concat(Node.name);\n\n  function isNode(instance) {\n    if (instance == null) {\n      return false;\n    }\n\n    if (instance instanceof Node) {\n      return true;\n    }\n\n    var tag = instance[Symbol.toStringTag];\n    var node = instance;\n\n    if ((tag == null || tag === Node.toStringTag) && typeof node.isNode === 'function' && typeof node.isEdge === 'function' && typeof node.prop === 'function' && typeof node.attr === 'function' && typeof node.size === 'function' && typeof node.position === 'function') {\n      return true;\n    }\n\n    return false;\n  }\n\n  Node.isNode = isNode;\n})(Node || (Node = {}));\n\n(function (Node) {\n  Node.config({\n    propHooks: function propHooks(_a) {\n      var ports = _a.ports,\n          metadata = __rest(_a, [\"ports\"]);\n\n      if (ports) {\n        metadata.ports = Array.isArray(ports) ? {\n          items: ports\n        } : ports;\n      }\n\n      return metadata;\n    }\n  });\n})(Node || (Node = {}));\n\n(function (Node) {\n  Node.registry = Registry.create({\n    type: 'node',\n    process: function process(shape, options) {\n      if (ShareRegistry.exist(shape, true)) {\n        throw new Error(\"Node with name '\".concat(shape, \"' was registered by anthor Edge\"));\n      }\n\n      if (typeof options === 'function') {\n        options.config({\n          shape: shape\n        });\n        return options;\n      }\n\n      var parent = Node;\n\n      var inherit = options.inherit,\n          config = __rest(options, [\"inherit\"]);\n\n      if (inherit) {\n        if (typeof inherit === 'string') {\n          var base = this.get(inherit);\n\n          if (base == null) {\n            this.onNotFound(inherit, 'inherited');\n          } else {\n            parent = base;\n          }\n        } else {\n          parent = inherit;\n        }\n      }\n\n      if (config.constructorName == null) {\n        config.constructorName = shape;\n      }\n\n      var ctor = parent.define.call(parent, config);\n      ctor.config({\n        shape: shape\n      });\n      return ctor;\n    }\n  });\n  ShareRegistry.setNodeRegistry(Node.registry);\n})(Node || (Node = {}));\n\n(function (Node) {\n  var counter = 0;\n\n  function getClassName(name) {\n    if (name) {\n      return StringExt.pascalCase(name);\n    }\n\n    counter += 1;\n    return \"CustomNode\".concat(counter);\n  }\n\n  function define(config) {\n    var constructorName = config.constructorName,\n        overwrite = config.overwrite,\n        others = __rest(config, [\"constructorName\", \"overwrite\"]);\n\n    var ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n    ctor.config(others);\n\n    if (others.shape) {\n      Node.registry.register(others.shape, ctor, overwrite);\n    }\n\n    return ctor;\n  }\n\n  Node.define = define;\n\n  function create(options) {\n    var shape = options.shape || 'rect';\n    var Ctor = Node.registry.get(shape);\n\n    if (Ctor) {\n      return new Ctor(options);\n    }\n\n    return Node.registry.onNotFound(shape);\n  }\n\n  Node.create = create;\n})(Node || (Node = {}));","map":{"version":3,"sources":["../../src/model/node.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;AAEA,SAAS,QAAT,QAAyB,aAAzB;AACA,SAAS,KAAT,EAAgB,SAAhB,EAA2B,KAA3B,QAAwC,aAAxC;AACA,SAAS,SAAT,EAAoB,SAApB,EAA+B,SAA/B,QAAgD,SAAhD;AACA,SAAS,MAAT,QAAuB,gBAAvB;AACA,SAAS,IAAT,QAAqB,QAArB;AAGA,SAAS,aAAT,QAA8B,YAA9B;AACA,SAAS,WAAT,QAA4B,QAA5B;AAEA,SAAS,MAAT,QAAuB,WAAvB;AAEA,WAAa,IAAb;AAAA;;AAAA;;AAeE,kBAAwC;AAAA;;AAAA,QAA5B,QAA4B,uEAAF,EAAE;;AAAA;;AACtC,8BAAM,QAAN;;AACA,UAAK,SAAL;;AAFsC;AAGvC;;AAlBH;AAAA;AAAA,SAWE,eAAkC;AAChC,aAAO,IAAI,CAAC,WAAZ;AACD;AAbH;AAAA;AAAA,WAoBY,oBACR,QADQ,EAER,aAFQ,EAEe;AAEvB,UAAQ,CAAR,GAA2C,QAA3C,CAAQ,CAAR;AAAA,UAAW,CAAX,GAA2C,QAA3C,CAAW,CAAX;AAAA,UAAc,KAAd,GAA2C,QAA3C,CAAc,KAAd;AAAA,UAAqB,MAArB,GAA2C,QAA3C,CAAqB,MAArB;AAAA,UAAgC,MAAhC,GAAsC,MAAA,CAAK,QAAL,EAAhC,CAAA,GAAA,EAAA,GAAA,EAAA,OAAA,EAAA,QAAA,CAAgC,CAAtC;;AAEA,UAAI,CAAC,IAAI,IAAL,IAAa,CAAC,IAAI,IAAtB,EAA4B;AAC1B,YAAM,QAAQ,GAAG,MAAM,CAAC,QAAxB;AACA,QAAA,MAAM,CAAC,QAAP,GAAe,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACV,QADU,CAAA,EACF;AACX,UAAA,CAAC,EAAE,CAAC,IAAI,IAAL,GAAY,CAAZ,GAAgB,QAAQ,GAAG,QAAQ,CAAC,CAAZ,GAAgB,CADhC;AAEX,UAAA,CAAC,EAAE,CAAC,IAAI,IAAL,GAAY,CAAZ,GAAgB,QAAQ,GAAG,QAAQ,CAAC,CAAZ,GAAgB;AAFhC,SADE,CAAf;AAKD;;AAED,UAAI,KAAK,IAAI,IAAT,IAAiB,MAAM,IAAI,IAA/B,EAAqC;AACnC,YAAM,IAAI,GAAG,MAAM,CAAC,IAApB;AACA,QAAA,MAAM,CAAC,IAAP,GAAW,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACN,IADM,CAAA,EACF;AACP,UAAA,KAAK,EAAE,KAAK,IAAI,IAAT,GAAgB,KAAhB,GAAwB,IAAI,GAAG,IAAI,CAAC,KAAR,GAAgB,CAD5C;AAEP,UAAA,MAAM,EAAE,MAAM,IAAI,IAAV,GAAiB,MAAjB,GAA0B,IAAI,GAAG,IAAI,CAAC,MAAR,GAAiB;AAFhD,SADE,CAAX;AAKD;;AAED,kFAAwB,MAAxB,EAAgC,aAAhC;AACD;AA7CH;AAAA;AAAA,WA+CE,kBAAM;AACJ,aAAO,IAAP;AACD;AAjDH;AAAA;AAAA,WAwDE,cACE,KADF,EAEE,MAFF,EAGE,OAHF,EAG8B;AAE5B,UAAI,KAAK,KAAK,SAAd,EAAyB;AACvB,eAAO,KAAK,OAAL,EAAP;AACD;;AAED,UAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,eAAO,KAAK,OAAL,CAAa,KAAb,EAAoB,MAApB,EAAsC,OAAtC,CAAP;AACD;;AAED,aAAO,KAAK,OAAL,CAAa,KAAb,EAAoB,MAApB,CAAP;AACD;AAtEH;AAAA;AAAA,WAwEE,mBAAO;AACL,UAAM,IAAI,GAAG,KAAK,KAAL,CAAW,GAAX,CAAe,MAAf,CAAb;AACA,aAAO,IAAI,GAAE,MAAA,CAAA,MAAA,CAAA,EAAA,EAAM,IAAN,CAAF,GAAiB;AAAE,QAAA,KAAK,EAAE,CAAT;AAAY,QAAA,MAAM,EAAE;AAApB,OAA5B;AACD;AA3EH;AAAA;AAAA,WA+EE,iBACE,KADF,EAEE,MAFF,EAGE,OAHF,EAG8B;AAE5B,UAAI,OAAO,KAAP,KAAiB,QAArB,EAA+B;AAC7B,aAAK,MAAL,CAAY,KAAK,CAAC,KAAlB,EAAyB,KAAK,CAAC,MAA/B,EAAuC,MAAvC;AACD,OAFD,MAEO;AACL,aAAK,MAAL,CAAY,KAAZ,EAAmB,MAAnB,EAAqC,OAArC;AACD;;AAED,aAAO,IAAP;AACD;AA3FH;AAAA;AAAA,WA6FE,gBAAO,KAAP,EAAsB,MAAtB,EAAsE;AAAA,UAAhC,OAAgC,uEAAF,EAAE;AACpE,WAAK,UAAL,CAAgB,QAAhB,EAA0B,OAA1B;AACA,UAAM,SAAS,GAAG,OAAO,CAAC,SAA1B;;AAEA,UAAI,SAAJ,EAAe;AACb,YAAM,WAAW,GAAG,KAAK,OAAL,EAApB;;AACA,gBAAQ,SAAR;AACE,eAAK,MAAL;AACA,eAAK,OAAL;AACE;AACA,YAAA,MAAM,GAAG,WAAW,CAAC,MAArB,CAFF,CAE8B;;AAC5B;;AACF,eAAK,KAAL;AACA,eAAK,QAAL;AACE;AACA,YAAA,KAAK,GAAG,WAAW,CAAC,KAApB,CAFF,CAE4B;;AAC1B;;AACF;AACE;AAZJ;;AAeA,YAAM,GAAG,GAAoC;AAC3C,UAAA,KAAK,EAAE,CADoC;AAE3C,uBAAa,CAF8B;AAG3C,UAAA,GAAG,EAAE,CAHsC;AAI3C,sBAAY,CAJ+B;AAK3C,UAAA,IAAI,EAAE,CALqC;AAM3C,yBAAe,CAN4B;AAO3C,UAAA,MAAM,EAAE,CAPmC;AAQ3C,0BAAgB;AAR2B,SAA7C;AAWA,YAAI,QAAQ,GAAG,GAAG,CAAC,SAAD,CAAlB;AACA,YAAM,KAAK,GAAG,KAAK,CAAC,SAAN,CAAgB,KAAK,QAAL,MAAmB,CAAnC,CAAd;;AACA,YAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB;AACA,UAAA,QAAQ,IAAI,IAAI,CAAC,KAAL,CAAW,CAAC,KAAK,GAAG,EAAT,IAAe,EAA1B,CAAZ;AACA,UAAA,QAAQ,IAAI,CAAZ;AACD,SAlCY,CAoCb;;;AACA,YAAM,IAAI,GAAG,KAAK,OAAL,EAAb,CArCa,CAuCb;AACA;;AACA,YAAI,UAAJ;;AACA,YAAI,QAAQ,KAAK,CAAjB,EAAoB;AAClB,UAAA,UAAU,GAAG,IAAI,CAAC,aAAL,EAAb;AACD,SAFD,MAEO,IAAI,QAAQ,KAAK,CAAjB,EAAoB;AACzB,UAAA,UAAU,GAAG,IAAI,CAAC,SAAL,EAAb;AACD,SAFM,MAEA,IAAI,QAAQ,KAAK,CAAjB,EAAoB;AACzB,UAAA,UAAU,GAAG,IAAI,CAAC,WAAL,EAAb;AACD,SAFM,MAEA;AACL,UAAA,UAAU,GAAG,IAAI,CAAC,SAAL,EAAb;AACD,SAlDY,CAoDb;AACA;;;AACA,YAAM,eAAe,GAAG,UAAU,CAC/B,KADqB,GAErB,MAFqB,CAEd,CAAC,KAFa,EAEN,IAAI,CAAC,SAAL,EAFM,CAAxB,CAtDa,CA0Db;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAM,MAAM,GAAG,IAAI,CAAC,IAAL,CAAU,KAAK,GAAG,KAAR,GAAgB,MAAM,GAAG,MAAnC,IAA6C,CAA5D,CAjEa,CAmEb;AACA;AACA;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAI,KAAK,GAAI,QAAQ,GAAG,IAAI,CAAC,EAAjB,GAAuB,CAAnC,CA/Ea,CAiFb;AACA;AACA;AACA;AACA;;AACA,QAAA,KAAK,IAAI,IAAI,CAAC,IAAL,CAAU,QAAQ,GAAG,CAAX,KAAiB,CAAjB,GAAqB,MAAM,GAAG,KAA9B,GAAsC,KAAK,GAAG,MAAxD,CAAT,CAtFa,CAwFb;AACA;;AACA,QAAA,KAAK,IAAI,KAAK,CAAC,KAAN,CAAY,KAAZ,CAAT,CA1Fa,CA4Fb;AACA;AACA;;AACA,YAAM,MAAM,GAAG,KAAK,CAAC,SAAN,CAAgB,MAAhB,EAAwB,KAAxB,EAA+B,eAA/B,CAAf,CA/Fa,CAiGb;AACA;AACA;;AACA,YAAM,MAAM,GAAG,MAAM,CAAC,KAAP,GAAe,SAAf,CAAyB,KAAK,GAAG,CAAC,CAAlC,EAAqC,MAAM,GAAG,CAAC,CAA/C,CAAf;AAEA,aAAK,KAAL,CAAW,GAAX,CAAe,MAAf,EAAuB;AAAE,UAAA,KAAK,EAAL,KAAF;AAAS,UAAA,MAAM,EAAN;AAAT,SAAvB,EAA0C,OAA1C;AACA,aAAK,WAAL,CAAiB,MAAM,CAAC,CAAxB,EAA2B,MAAM,CAAC,CAAlC,EAAqC,OAArC;AACD,OAxGD,MAwGO;AACL,aAAK,KAAL,CAAW,GAAX,CAAe,MAAf,EAAuB;AAAE,UAAA,KAAK,EAAL,KAAF;AAAS,UAAA,MAAM,EAAN;AAAT,SAAvB,EAA0C,OAA1C;AACD;;AAED,WAAK,SAAL,CAAe,QAAf,EAAyB,OAAzB;AAEA,aAAO,IAAP;AACD;AAhNH;AAAA;AAAA,WAkNE,eACE,EADF,EAEE,EAFF,EAGE,MAHF,EAI+B;AAAA,UAA7B,OAA6B,uEAAF,EAAE;AAE7B,UAAM,UAAU,GAAG,KAAK,OAAL,GAAe,KAAf,CACjB,EADiB,EAEjB,EAFiB,EAGjB,MAAM,IAAI,IAAV,GAAiB,SAAjB,GAA6B,MAHZ,CAAnB;AAMA,WAAK,UAAL,CAAgB,OAAhB,EAAyB,OAAzB;AACA,WAAK,WAAL,CAAiB,UAAU,CAAC,CAA5B,EAA+B,UAAU,CAAC,CAA1C,EAA6C,OAA7C;AACA,WAAK,MAAL,CAAY,UAAU,CAAC,KAAvB,EAA8B,UAAU,CAAC,MAAzC,EAAiD,OAAjD;AACA,WAAK,SAAL,CAAe,OAAf;AACA,aAAO,IAAP;AACD;AAnOH;AAAA;AAAA,WA2OE,kBACE,IADF,EAEE,IAFF,EAGE,IAHF,EAGgC;AAE9B,UAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,eAAO,KAAK,WAAL,CAAiB,IAAjB,EAAuB,IAAvB,EAAuC,IAAvC,CAAP;AACD;;AACD,aAAO,KAAK,WAAL,CAAiB,IAAjB,CAAP;AACD;AApPH;AAAA;AAAA,WAsPE,uBAAiD;AAAA,UAArC,OAAqC,uEAAF,EAAE;;AAC/C,UAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,YAAM,MAAM,GAAG,KAAK,SAAL,EAAf;;AACA,YAAI,MAAM,IAAI,IAAV,IAAkB,MAAM,CAAC,MAAP,EAAtB,EAAuC;AACrC,cAAM,eAAe,GAAG,KAAK,WAAL,EAAxB;AACA,cAAM,cAAc,GAAG,MAAM,CAAC,WAAP,EAAvB;AAEA,iBAAO;AACL,YAAA,CAAC,EAAE,eAAe,CAAC,CAAhB,GAAoB,cAAc,CAAC,CADjC;AAEL,YAAA,CAAC,EAAE,eAAe,CAAC,CAAhB,GAAoB,cAAc,CAAC;AAFjC,WAAP;AAID;AACF;;AAED,UAAM,GAAG,GAAG,KAAK,KAAL,CAAW,GAAX,CAAe,UAAf,CAAZ;AACA,aAAO,GAAG,GAAE,MAAA,CAAA,MAAA,CAAA,EAAA,EAAM,GAAN,CAAF,GAAgB;AAAE,QAAA,CAAC,EAAE,CAAL;AAAQ,QAAA,CAAC,EAAE;AAAX,OAA1B;AACD;AAtQH;AAAA;AAAA,WA6QE,qBACE,IADF,EAEE,IAFF,EAGoC;AAAA,UAAlC,IAAkC,uEAAF,EAAE;AAElC,UAAI,CAAJ;AACA,UAAI,CAAJ;AACA,UAAI,OAAJ;;AAEA,UAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,QAAA,CAAC,GAAG,IAAI,CAAC,CAAT;AACA,QAAA,CAAC,GAAG,IAAI,CAAC,CAAT;AACA,QAAA,OAAO,GAAI,IAAgC,IAAI,EAA/C;AACD,OAJD,MAIO;AACL,QAAA,CAAC,GAAG,IAAJ;AACA,QAAA,CAAC,GAAG,IAAJ;AACA,QAAA,OAAO,GAAG,IAAI,IAAI,EAAlB;AACD;;AAED,UAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,YAAM,MAAM,GAAG,KAAK,SAAL,EAAf;;AACA,YAAI,MAAM,IAAI,IAAV,IAAkB,MAAM,CAAC,MAAP,EAAtB,EAAuC;AACrC,cAAM,cAAc,GAAG,MAAM,CAAC,WAAP,EAAvB;AACA,UAAA,CAAC,IAAI,cAAc,CAAC,CAApB;AACA,UAAA,CAAC,IAAI,cAAc,CAAC,CAApB;AACD;AACF;;AAED,UAAI,OAAO,CAAC,IAAZ,EAAkB;AAChB,YAAM,eAAe,GAAG,KAAK,WAAL,EAAxB;AACA,aAAK,SAAL,CAAe,CAAC,GAAG,eAAe,CAAC,CAAnC,EAAsC,CAAC,GAAG,eAAe,CAAC,CAA1D,EAA6D,OAA7D;AACD,OAHD,MAGO;AACL,aAAK,KAAL,CAAW,GAAX,CAAe,UAAf,EAA2B;AAAE,UAAA,CAAC,EAAD,CAAF;AAAK,UAAA,CAAC,EAAD;AAAL,SAA3B,EAAqC,OAArC;AACD;;AAED,aAAO,IAAP;AACD;AAjTH;AAAA;AAAA,WAmTE,qBAA6D;AAAA,UAAnD,EAAmD,uEAA9C,CAA8C;AAAA,UAA3C,EAA2C,uEAAtC,CAAsC;AAAA,UAAnC,OAAmC,uEAAF,EAAE;;AAC3D,UAAI,EAAE,KAAK,CAAP,IAAY,EAAE,KAAK,CAAvB,EAA0B;AACxB,eAAO,IAAP;AACD,OAH0D,CAK3D;;;AACA,MAAA,OAAO,CAAC,WAAR,GAAsB,OAAO,CAAC,WAAR,IAAuB,KAAK,EAAlD;AAEA,UAAM,QAAQ,GAAG,KAAK,WAAL,EAAjB;;AAEA,UAAI,OAAO,CAAC,QAAR,IAAoB,IAApB,IAA4B,OAAO,CAAC,WAAR,KAAwB,KAAK,EAA7D,EAAiE;AAC/D;AACA;AACA;AACA,YAAM,IAAI,GAAG,KAAK,OAAL,CAAa;AAAE,UAAA,IAAI,EAAE;AAAR,SAAb,CAAb;AACA,YAAM,EAAE,GAAG,OAAO,CAAC,QAAnB,CAL+D,CAM/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,YAAM,EAAE,GAAG,QAAQ,CAAC,CAAT,GAAa,IAAI,CAAC,CAA7B;AACA,YAAM,EAAE,GAAG,QAAQ,CAAC,CAAT,GAAa,IAAI,CAAC,CAA7B,CAlB+D,CAmB/D;AACA;;AACA,YAAM,CAAC,GAAG,IAAI,CAAC,GAAL,CACR,EAAE,CAAC,CAAH,GAAO,EADC,EAER,IAAI,CAAC,GAAL,CAAS,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,KAAV,GAAkB,EAAlB,GAAuB,IAAI,CAAC,KAArC,EAA4C,QAAQ,CAAC,CAAT,GAAa,EAAzD,CAFQ,CAAV;AAIA,YAAM,CAAC,GAAG,IAAI,CAAC,GAAL,CACR,EAAE,CAAC,CAAH,GAAO,EADC,EAER,IAAI,CAAC,GAAL,CAAS,EAAE,CAAC,CAAH,GAAO,EAAE,CAAC,MAAV,GAAmB,EAAnB,GAAwB,IAAI,CAAC,MAAtC,EAA8C,QAAQ,CAAC,CAAT,GAAa,EAA3D,CAFQ,CAAV,CAzB+D,CA8B/D;;AACA,QAAA,EAAE,GAAG,CAAC,GAAG,QAAQ,CAAC,CAAlB,CA/B+D,CA+B3C;;AACpB,QAAA,EAAE,GAAG,CAAC,GAAG,QAAQ,CAAC,CAAlB,CAhC+D,CAgC3C;AACrB;;AAED,UAAM,kBAAkB,GAAG;AACzB,QAAA,CAAC,EAAE,QAAQ,CAAC,CAAT,GAAa,EADS;AAEzB,QAAA,CAAC,EAAE,QAAQ,CAAC,CAAT,GAAa;AAFS,OAA3B,CA7C2D,CAkD3D;AACA;;AACA,MAAA,OAAO,CAAC,EAAR,GAAa,EAAb;AACA,MAAA,OAAO,CAAC,EAAR,GAAa,EAAb;;AAEA,UAAI,OAAO,CAAC,UAAZ,EAAwB;AACtB,YAAI,OAAO,OAAO,CAAC,UAAf,KAA8B,QAAlC,EAA4C;AAC1C,UAAA,OAAO,CAAC,UAAR,GAAqB,EAArB;AACD;;AAED,aAAK,UAAL,CAAgB,UAAhB,EAA4B,kBAA5B,EAA8C,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACzC,OAAO,CAAC,UADiC,CAAA,EACvB;AACrB,UAAA,MAAM,EAAE,MAAM,CAAC;AADM,SADuB,CAA9C;AAIA,aAAK,SAAL,CAAe,UAAC,KAAD,EAAU;;;AACvB,cAAM,QAAQ,GAAG,CAAA,EAAA,GAAA,OAAO,CAAC,OAAR,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAE,QAAF,CAAW,KAAX,CAAhC;;AACA,cAAI,CAAC,QAAL,EAAe;AACb,YAAA,KAAK,CAAC,SAAN,CAAgB,EAAhB,EAAoB,EAApB,EAAwB,OAAxB;AACD;AACF,SALD;AAMD,OAfD,MAeO;AACL,aAAK,UAAL,CAAgB,WAAhB,EAA6B,OAA7B;AACA,aAAK,KAAL,CAAW,GAAX,CAAe,UAAf,EAA2B,kBAA3B,EAA+C,OAA/C;AACA,aAAK,SAAL,CAAe,UAAC,KAAD,EAAU;;;AACvB,cAAM,QAAQ,GAAG,CAAA,EAAA,GAAA,OAAO,CAAC,OAAR,MAAe,IAAf,IAAe,EAAA,KAAA,KAAA,CAAf,GAAe,KAAA,CAAf,GAAe,EAAA,CAAE,QAAF,CAAW,KAAX,CAAhC;;AACA,cAAI,CAAC,QAAL,EAAe;AACb,YAAA,KAAK,CAAC,SAAN,CAAgB,EAAhB,EAAoB,EAApB,EAAwB,OAAxB;AACD;AACF,SALD;AAMA,aAAK,SAAL,CAAe,WAAf,EAA4B,OAA5B;AACD;;AAED,aAAO,IAAP;AACD;AAtYH;AAAA;AAAA,WA8YE,eAAM,GAAN,EAAoB,OAApB,EAAgD;AAC9C,UAAI,GAAG,IAAI,IAAX,EAAiB;AACf,eAAO,KAAK,QAAL,EAAP;AACD;;AACD,aAAO,KAAK,MAAL,CAAY,GAAZ,EAAiB,OAAjB,CAAP;AACD;AAnZH;AAAA;AAAA,WAqZE,oBAAQ;AACN,aAAO,KAAK,KAAL,CAAW,GAAX,CAAe,OAAf,EAAwB,CAAxB,CAAP;AACD;AAvZH;AAAA;AAAA,WAyZE,gBAAO,KAAP,EAAsD;AAAA,UAAhC,OAAgC,uEAAF,EAAE;AACpD,UAAM,YAAY,GAAG,KAAK,QAAL,EAArB;;AACA,UAAI,OAAO,CAAC,MAAZ,EAAoB;AAClB,YAAM,IAAI,GAAG,KAAK,OAAL,EAAb;AACA,YAAM,QAAQ,GAAG,KAAK,WAAL,EAAjB;AACA,YAAM,MAAM,GAAG,KAAK,OAAL,GAAe,SAAf,EAAf;AACA,QAAA,MAAM,CAAC,MAAP,CAAc,YAAY,GAAG,KAA7B,EAAoC,OAAO,CAAC,MAA5C;AACA,YAAM,EAAE,GAAG,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,KAAL,GAAa,CAAxB,GAA4B,QAAQ,CAAC,CAAhD;AACA,YAAM,EAAE,GAAG,MAAM,CAAC,CAAP,GAAW,IAAI,CAAC,MAAL,GAAc,CAAzB,GAA6B,QAAQ,CAAC,CAAjD;AACA,aAAK,UAAL,CAAgB,QAAhB,EAA0B;AAAE,UAAA,KAAK,EAAL,KAAF;AAAS,UAAA,OAAO,EAAP;AAAT,SAA1B;AACA,aAAK,WAAL,CAAiB,QAAQ,CAAC,CAAT,GAAa,EAA9B,EAAkC,QAAQ,CAAC,CAAT,GAAa,EAA/C,EAAmD,OAAnD;AACA,aAAK,MAAL,CAAY,KAAZ,EAAiB,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,OAAP,CAAA,EAAc;AAAE,UAAA,MAAM,EAAE;AAAV,SAAd,CAAjB;AACA,aAAK,SAAL,CAAe,QAAf;AACD,OAXD,MAWO;AACL,aAAK,KAAL,CAAW,GAAX,CACE,OADF,EAEE,OAAO,CAAC,QAAR,GAAmB,KAAnB,GAA2B,CAAC,YAAY,GAAG,KAAhB,IAAyB,GAFtD,EAGE,OAHF;AAKD;;AAED,aAAO,IAAP;AACD,KA/aH,CAibE;AAEA;;AAnbF;AAAA;AAAA,WAqbE,mBAAwC;AAAA,UAAhC,OAAgC,uEAAF,EAAE;;AACtC,UAAI,OAAO,CAAC,IAAZ,EAAkB;AAChB,YAAM,KAAK,GAAG,KAAK,cAAL,CAAoB;AAAE,UAAA,IAAI,EAAE,IAAR;AAAc,UAAA,YAAY,EAAE;AAA5B,SAApB,CAAd;AACA,QAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,eAAO,IAAI,CAAC,YAAL,CAAkB,KAAlB,CAAP;AACD;;AAED,aAAO,SAAS,CAAC,mBAAV,CAA8B,KAAK,WAAL,EAA9B,EAAkD,KAAK,OAAL,EAAlD,CAAP;AACD;AA7bH;AAAA;AAAA,WA+bE,4BAAmB,IAAnB,EAA+B,IAA/B,EAAsD;AACpD,UAAM,IAAI,GAAG,KAAK,OAAL,EAAb;AACA,UAAM,MAAM,GAAG,IAAI,CAAC,SAAL,EAAf;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,WAAL,CAAiB,IAAjB,CAAjB;;AACA,UAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,eAAO,MAAP;AACD;;AAED,UAAM,MAAM,GAAG,QAAQ,CAAC,IAAxB;;AACA,UAAI,CAAC,MAAD,IAAW,CAAC,KAAK,OAAL,CAAa,MAAb,CAAhB,EAAsC;AACpC,eAAO,MAAP;AACD;;AAED,UAAM,IAAI,GAAG,KAAK,OAAL,CAAa,MAAb,CAAb;;AACA,UAAI,CAAC,IAAD,IAAS,CAAC,IAAI,CAAC,KAAnB,EAA0B;AACxB,eAAO,MAAP;AACD;;AAED,UAAM,OAAO,GAAG,KAAK,gBAAL,CAAsB,IAAI,CAAC,KAA3B,CAAhB;AACA,UAAM,QAAQ,GAAG,OAAO,CAAC,MAAD,CAAP,CAAgB,QAAjC;AACA,UAAM,UAAU,GAAG,KAAK,CAAC,MAAN,CAAa,QAAb,EAAuB,SAAvB,CAAiC,IAAI,CAAC,SAAL,EAAjC,CAAnB;AAEA,UAAM,KAAK,GAAG,KAAK,QAAL,EAAd;;AACA,UAAI,KAAJ,EAAW;AACT,QAAA,UAAU,CAAC,MAAX,CAAkB,CAAC,KAAnB,EAA0B,MAA1B;AACD;;AAED,aAAO,UAAP;AACD;AAED;;AAEG;;AA/dL;AAAA;AAAA,WAgeE,eAAuC;AAAA,UAAnC,OAAmC,uEAAF,EAAE;AACrC,UAAM,QAAQ,GAAG,KAAK,WAAL,MAAsB,EAAvC;AACA,UAAM,MAAM,GAAG,QAAQ,CAAC,MAAT,CAAgB,UAAC,IAAD;AAAA,eAAU,IAAI,CAAC,MAAL,EAAV;AAAA,OAAhB,CAAf;;AACA,UAAI,MAAM,CAAC,MAAP,KAAkB,CAAtB,EAAyB;AACvB,eAAO,IAAP;AACD;;AAED,WAAK,UAAL,CAAgB,YAAhB,EAA8B,OAA9B;;AAEA,UAAI,OAAO,CAAC,IAAZ,EAAkB;AAChB,QAAA,MAAM,CAAC,OAAP,CAAe,UAAC,IAAD;AAAA,iBAAU,IAAI,CAAC,GAAL,CAAS,OAAT,CAAV;AAAA,SAAf;AACD;;AAED,+BAA8B,IAAI,CAAC,YAAL,CAAkB,MAAlB,CAA9B;AAAA,UAAM,CAAN,sBAAM,CAAN;AAAA,UAAS,CAAT,sBAAS,CAAT;AAAA,UAAY,KAAZ,sBAAY,KAAZ;AAAA,UAAmB,MAAnB,sBAAmB,MAAnB;;AACA,UAAM,OAAO,GAAG,SAAS,CAAC,cAAV,CAAyB,OAAO,CAAC,OAAjC,CAAhB;AAEA,MAAA,CAAC,IAAI,OAAO,CAAC,IAAb;AACA,MAAA,CAAC,IAAI,OAAO,CAAC,GAAb;AACA,MAAA,KAAK,IAAI,OAAO,CAAC,IAAR,GAAe,OAAO,CAAC,KAAhC;AACA,MAAA,MAAM,IAAI,OAAO,CAAC,MAAR,GAAiB,OAAO,CAAC,GAAnC;AAEA,WAAK,KAAL,CAAW,GAAX,CACE;AACE,QAAA,QAAQ,EAAE;AAAE,UAAA,CAAC,EAAD,CAAF;AAAK,UAAA,CAAC,EAAD;AAAL,SADZ;AAEE,QAAA,IAAI,EAAE;AAAE,UAAA,KAAK,EAAL,KAAF;AAAS,UAAA,MAAM,EAAN;AAAT;AAFR,OADF,EAKE,OALF;AAQA,WAAK,SAAL,CAAe,YAAf;AAEA,aAAO,IAAP;AACD,KAhgBH,CAkgBE;AAEA;;AApgBF;AAAA;AAAA,SAsgBE,eAAuB;AACrB,aAAO,KAAK,sBAAL,EAAP;AACD;AAxgBH;AAAA;AAAA,SA0gBE,aAAwB,MAAxB,EAAsC;AACpC,WAAK,sBAAL,CAA4B,MAA5B;AACD;AA5gBH;AAAA;AAAA,WA8gBE,yCAA6B;AAC3B,aACE,KAAK,KAAL,CAAW,GAAX,CAAe,4BAAf,KACA,MAAM,CAAC,sBAAP,EAFF;AAID;AAnhBH;AAAA;AAAA,WAqhBE,kCAAsB;AACpB,aACE,KAAK,KAAL,CAAW,GAAX,CAAe,qBAAf,KACA,KAAK,6BAAL,EAFF;AAID;AA1hBH;AAAA;AAAA,WA4hBE,gCAAuB,MAAvB,EAAqE;AAAA,UAA7B,OAA6B,uEAAF,EAAE;AACnE,WAAK,KAAL,CAAW,GAAX,CAAe,qBAAf,EAAsC,MAAM,CAAC,KAAP,CAAa,MAAb,CAAtC,EAA4D,OAA5D;AACA,aAAO,IAAP;AACD;AA/hBH;AAAA;AAAA,SAiiBE,eAAc;AACZ,aAAO,KAAK,aAAL,EAAP;AACD;AAniBH;AAAA;AAAA,SAqiBE,aAAe,MAAf,EAA6B;AAC3B,WAAK,aAAL,CAAmB,MAAnB;AACD;AAviBH;AAAA;AAAA,WAyiBE,gCAAoB;AAClB,aAAO,KAAK,KAAL,CAAW,GAAX,CAAe,mBAAf,KAAuC,MAAM,CAAC,aAAP,EAA9C;AACD;AA3iBH;AAAA;AAAA,WA6iBE,yBAAa;AACX,aAAO,KAAK,KAAL,CAAW,GAAX,CAAe,YAAf,KAAgC,KAAK,oBAAL,EAAvC;AACD;AA/iBH;AAAA;AAAA,WAijBE,uBAAc,MAAd,EAA4D;AAAA,UAA7B,OAA6B,uEAAF,EAAE;AAC1D,WAAK,KAAL,CAAW,GAAX,CAAe,YAAf,EAA6B,MAAM,CAAC,KAAP,CAAa,MAAb,CAA7B,EAAmD,OAAnD;AACA,aAAO,IAAP;AACD;AApjBH;AAAA;AAAA,SAsjBE,eAAmB;AACjB,aAAO,KAAK,kBAAL,EAAP;AACD;AAxjBH;AAAA;AAAA,SA0jBE,aAAoB,MAApB,EAAkC;AAChC,WAAK,kBAAL,CAAwB,MAAxB;AACD;AA5jBH;AAAA;AAAA,WA8jBE,qCAAyB;AACvB,aACE,KAAK,KAAL,CAAW,GAAX,CAAe,wBAAf,KAA4C,MAAM,CAAC,kBAAP,EAD9C;AAGD;AAlkBH;AAAA;AAAA,WAokBE,8BAAkB;AAChB,aAAO,KAAK,KAAL,CAAW,GAAX,CAAe,iBAAf,KAAqC,KAAK,yBAAL,EAA5C;AACD;AAtkBH;AAAA;AAAA,WAwkBE,4BAAmB,MAAnB,EAAiE;AAAA,UAA7B,OAA6B,uEAAF,EAAE;AAC/D,WAAK,KAAL,CAAW,GAAX,CAAe,iBAAf,EAAkC,MAAM,CAAC,KAAP,CAAa,MAAb,CAAlC,EAAwD,OAAxD;AACA,aAAO,IAAP;AACD;AA3kBH;AAAA;AAAA,SA6kBE,eAAS;AACP,UAAM,GAAG,GAAG,KAAK,KAAL,CAAW,GAAX,CAAqC,OAArC,EAA8C;AAAE,QAAA,KAAK,EAAE;AAAT,OAA9C,CAAZ;;AACA,UAAI,GAAG,CAAC,KAAJ,IAAa,IAAjB,EAAuB;AACrB,QAAA,GAAG,CAAC,KAAJ,GAAY,EAAZ;AACD;;AACD,aAAO,GAAP;AACD;AAnlBH;AAAA;AAAA,WAqlBE,oBAAQ;AACN,aAAO,SAAS,CAAC,SAAV,CAAoB,KAAK,KAAL,CAAW,KAA/B,CAAP;AACD;AAvlBH;AAAA;AAAA,WAylBE,yBAAgB,SAAhB,EAAiC;AAC/B,aAAO,KAAK,QAAL,GAAgB,MAAhB,CAAuB,UAAC,IAAD;AAAA,eAAU,IAAI,CAAC,KAAL,KAAe,SAAzB;AAAA,OAAvB,CAAP;AACD;AA3lBH;AAAA;AAAA,WA6lBE,iBAAQ,MAAR,EAAsB;AACpB,aAAO,SAAS,CAAC,SAAV,CACL,KAAK,KAAL,CAAW,KAAX,CAAiB,IAAjB,CAAsB,UAAC,IAAD;AAAA,eAAU,IAAI,CAAC,EAAL,IAAW,IAAI,CAAC,EAAL,KAAY,MAAjC;AAAA,OAAtB,CADK,CAAP;AAGD;AAjmBH;AAAA;AAAA,WAmmBE,mBAAU,KAAV,EAAuB;AACrB,aAAO,KAAK,KAAL,CAAW,KAAX,CAAiB,KAAjB,KAA2B,IAAlC;AACD;AArmBH;AAAA;AAAA,WAumBE,oBAAQ;AACN,aAAO,KAAK,KAAL,CAAW,KAAX,CAAiB,MAAjB,GAA0B,CAAjC;AACD;AAzmBH;AAAA;AAAA,WA2mBE,iBAAQ,MAAR,EAAsB;AACpB,aAAO,KAAK,YAAL,CAAkB,MAAlB,MAA8B,CAAC,CAAtC;AACD;AA7mBH;AAAA;AAAA,WA+mBE,sBAAa,IAAb,EAAoD;AAClD,UAAM,MAAM,GAAG,OAAO,IAAP,KAAgB,QAAhB,GAA2B,IAA3B,GAAkC,IAAI,CAAC,EAAtD;AACA,aAAO,MAAM,IAAI,IAAV,GACH,KAAK,KAAL,CAAW,KAAX,CAAiB,SAAjB,CAA2B,UAAC,IAAD;AAAA,eAAU,IAAI,CAAC,EAAL,KAAY,MAAtB;AAAA,OAA3B,CADG,GAEH,CAAC,CAFL;AAGD;AApnBH;AAAA;AAAA,WAsnBE,0BAAiB,SAAjB,EAAkC;AAChC,UAAM,IAAI,GAAG,KAAK,OAAL,EAAb;AACA,UAAM,OAAO,GAAG,KAAK,IAAL,CAAU,qBAAV,CACd,SADc,EAEd,IAAI,SAAJ,CAAc,CAAd,EAAiB,CAAjB,EAAoB,IAAI,CAAC,KAAzB,EAAgC,IAAI,CAAC,MAArC,CAFc,CAAhB;AAKA,aAAO,OAAO,CAAC,MAAR,CAKL,UAAC,IAAD,EAAO,IAAP,EAAe;AACf,YAAM,MAAM,GAAG,IAAI,CAAC,UAApB;AACA,QAAA,IAAI,CAAC,IAAI,CAAC,MAAN,CAAJ,GAAoB;AAClB,UAAA,QAAQ,EAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAO,MAAM,CAAC,QAAd,CADU;AAElB,UAAA,KAAK,EAAE,MAAM,CAAC,KAAP,IAAgB;AAFL,SAApB;AAIA,eAAO,IAAP;AACD,OAZM,EAYJ,EAZI,CAAP;AAaD;AA1oBH;AAAA;AAAA,WA8oBE,qBAAY,MAAZ,EAA4B,IAA5B,EAAoD;AAClD,aAAO,KAAK,aAAL,CAAmB,KAAK,cAAL,CAAoB,MAApB,EAA4B,IAA5B,CAAnB,CAAP;AACD;AAhpBH;AAAA;AAAA,WA6pBE,qBACE,MADF,EAEE,IAFF,EAGE,IAHF,EAIE,IAJF,EAIwB;AAEtB,UAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,KAAK,CAAC,OAAN,CAAc,IAAd,CAAhC,EAAqD;AACnD,YAAM,KAAI,GAAG,KAAK,cAAL,CAAoB,MAApB,EAA4B,IAA5B,CAAb;;AACA,YAAM,MAAK,GAAG,IAAd;AACA,eAAO,KAAK,aAAL,CAAmB,KAAnB,EAAyB,MAAzB,EAAgC,IAAhC,CAAP;AACD;;AAED,UAAM,IAAI,GAAG,KAAK,cAAL,CAAoB,MAApB,CAAb;AACA,UAAM,KAAK,GAAG,IAAd;AACA,aAAO,KAAK,aAAL,CAAmB,IAAnB,EAAyB,KAAzB,EAAgC,IAAhC,CAAP;AACD;AA5qBH;AAAA;AAAA,WAorBE,wBACE,MADF,EAEE,IAFF,EAGE,OAHF,EAG2B;AAEzB,UAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,KAAK,CAAC,OAAN,CAAc,IAAd,CAAhC,EAAqD;AACnD,eAAO,KAAK,gBAAL,CAAsB,KAAK,cAAL,CAAoB,MAApB,EAA4B,IAA5B,CAAtB,EAAyD,OAAzD,CAAP;AACD;;AACD,aAAO,KAAK,gBAAL,CAAsB,KAAK,cAAL,CAAoB,MAApB,CAAtB,EAAmD,IAAnD,CAAP;AACD;AA7rBH;AAAA;AAAA,WA4sBE,kBACE,MADF,EAEE,IAFF,EAGE,KAHF,EAIE,OAJF,EAI2B;AAEzB,UAAI,IAAI,IAAI,IAAZ,EAAkB;AAChB,eAAO,KAAK,WAAL,CAAiB,MAAjB,CAAP;AACD;;AACD,UAAI,OAAO,IAAP,KAAgB,QAAhB,IAA4B,KAAK,CAAC,OAAN,CAAc,IAAd,CAAhC,EAAqD;AACnD,YAAI,SAAS,CAAC,MAAV,KAAqB,CAAzB,EAA4B;AAC1B,iBAAO,KAAK,WAAL,CAAiB,MAAjB,EAAyB,IAAzB,CAAP;AACD;;AACD,YAAI,KAAK,IAAI,IAAb,EAAmB;AACjB,iBAAO,KAAK,cAAL,CAAoB,MAApB,EAA4B,IAA5B,EAAkC,OAAlC,CAAP;AACD;;AACD,eAAO,KAAK,WAAL,CACL,MADK,EAEL,IAFK,EAGL,KAHK,EAIL,OAJK,CAAP;AAMD;;AACD,aAAO,KAAK,WAAL,CACL,MADK,EAEL,IAFK,EAGL,KAHK,CAAP;AAKD;AAxuBH;AAAA;AAAA,WA0uBY,wBAAe,MAAf,EAA+B,IAA/B,EAAuD;AAC/D,UAAM,KAAK,GAAG,KAAK,YAAL,CAAkB,MAAlB,CAAd;;AACA,UAAI,KAAK,KAAK,CAAC,CAAf,EAAkB;AAChB,cAAM,IAAI,KAAJ,0CAA2C,MAA3C,QAAN;AACD;;AAED,UAAI,IAAI,IAAI,IAAR,IAAgB,IAAI,KAAK,EAA7B,EAAiC;AAC/B,eAAO,CAAC,OAAD,EAAU,OAAV,YAAsB,KAAtB,EAAP;AACD;;AAED,UAAI,KAAK,CAAC,OAAN,CAAc,IAAd,CAAJ,EAAyB;AACvB,gBAAQ,OAAR,EAAiB,OAAjB,YAA6B,KAA7B,6BAAyC,IAAzC;AACD;;AAED,mCAAsB,KAAtB,cAA+B,IAA/B;AACD;AAzvBH;AAAA;AAAA,WA2vBE,iBAAQ,IAAR,EAAwC,OAAxC,EAAiE;AAC/D,UAAM,KAAK,sBAAO,KAAK,KAAL,CAAW,KAAlB,CAAX;;AACA,MAAA,KAAK,CAAC,IAAN,CAAW,IAAX;AACA,WAAK,aAAL,CAAmB,aAAnB,EAAkC,KAAlC,EAAyC,OAAzC;AACA,aAAO,IAAP;AACD;AAhwBH;AAAA;AAAA,WAkwBE,kBAAS,KAAT,EAA4C,OAA5C,EAAqE;AACnE,WAAK,aAAL,CAAmB,aAAnB,+BAAsC,KAAK,KAAL,CAAW,KAAjD,sBAA2D,KAA3D,IAAmE,OAAnE;AACA,aAAO,IAAP;AACD;AArwBH;AAAA;AAAA,WAuwBE,oBACE,IADF,EAE+B;AAAA,UAA7B,OAA6B,uEAAF,EAAE;AAE7B,aAAO,KAAK,YAAL,CAAkB,KAAK,YAAL,CAAkB,IAAlB,CAAlB,EAA2C,OAA3C,CAAP;AACD;AA5wBH;AAAA;AAAA,WA8wBE,sBAAa,KAAb,EAAyD;AAAA,UAA7B,OAA6B,uEAAF,EAAE;;AACvD,UAAI,KAAK,IAAI,CAAb,EAAgB;AACd,YAAM,KAAK,sBAAO,KAAK,KAAL,CAAW,KAAlB,CAAX;;AACA,QAAA,KAAK,CAAC,MAAN,CAAa,KAAb,EAAoB,CAApB;AACA,QAAA,OAAO,CAAC,OAAR,GAAkB,IAAlB;AACA,aAAK,aAAL,CAAmB,aAAnB,EAAkC,KAAlC,EAAyC,OAAzC;AACD;;AACD,aAAO,IAAP;AACD;AAtxBH;AAAA;AAAA,WA6xBE,qBACE,eADF,EAEE,GAFF,EAEuB;AAErB,UAAI,OAAJ;;AAEA,UAAI,KAAK,CAAC,OAAN,CAAc,eAAd,CAAJ,EAAoC;AAClC,QAAA,OAAO,GAAG,GAAG,IAAI,EAAjB;;AACA,YAAI,eAAe,CAAC,MAApB,EAA4B;AAC1B,UAAA,OAAO,CAAC,OAAR,GAAkB,IAAlB;;AACA,cAAM,YAAY,sBAAO,KAAK,KAAL,CAAW,KAAlB,CAAlB;;AACA,cAAM,cAAc,GAAG,YAAY,CAAC,MAAb,CACrB,UAAC,EAAD;AAAA,mBACE,CAAC,eAAe,CAAC,IAAhB,CAAqB,UAAC,CAAD,EAAM;AAC1B,kBAAM,EAAE,GAAG,OAAO,CAAP,KAAa,QAAb,GAAwB,CAAxB,GAA4B,CAAC,CAAC,EAAzC;AACA,qBAAO,EAAE,CAAC,EAAH,KAAU,EAAjB;AACD,aAHA,CADH;AAAA,WADqB,CAAvB;AAOA,eAAK,aAAL,CAAmB,aAAnB,EAAkC,cAAlC,EAAkD,OAAlD;AACD;AACF,OAdD,MAcO;AACL,QAAA,OAAO,GAAG,eAAe,IAAI,EAA7B;AACA,QAAA,OAAO,CAAC,OAAR,GAAkB,IAAlB;AACA,aAAK,aAAL,CAAmB,aAAnB,EAAkC,EAAlC,EAAsC,OAAtC;AACD;;AAED,aAAO,IAAP;AACD;AAxzBH;AAAA;AAAA,WA0zBE,0BAAc;AACZ,aAAO,KAAK,IAAL,CAAU,QAAV,EAAP;AACD;AA5zBH;AAAA;AAAA,WA8zBE,2BAAe;AACb,aAAO,KAAK,IAAL,CAAU,MAAjB;AACD;AAh0BH;AAAA;AAAA,WAk0BE,+BAAsB,SAAtB,EAAqD,IAArD,EAAoE;AAClE,aAAO,KAAK,IAAL,CAAU,qBAAV,CAAgC,SAAhC,EAA2C,IAA3C,CAAP;AACD;AAp0BH;AAAA;AAAA,WAs0BY,qBAAS;AAAA;;AACjB,WAAK,cAAL;AACA,WAAK,EAAL,CAAQ,cAAR,EAAwB,YAAK;AAC3B,QAAA,MAAI,CAAC,kBAAL;;AACA,QAAA,MAAI,CAAC,cAAL;AACD,OAHD;AAID;AA50BH;AAAA;AAAA,WA80BY,8BAAkB;AAC1B,UAAM,OAAO,GAAG,KAAK,KAArB;AACA,UAAM,eAAe,GAA8B,EAAnD;AAEA,MAAA,OAAO,CAAC,KAAR,CAAc,OAAd,CAAsB,UAAC,IAAD,EAAS;AAC7B,YAAI,IAAI,CAAC,EAAT,EAAa;AACX,UAAA,eAAe,CAAC,IAAI,CAAC,EAAN,CAAf,GAA2B,IAA3B;AACD;AACF,OAJD;AAMA,UAAM,OAAO,GAA8B,EAA3C;AACA,UAAM,QAAQ,GAAG,KAAK,KAAL,CAAW,WAAX,CAA6C,OAA7C,KAAyD;AACxE,QAAA,KAAK,EAAE;AADiE,OAA1E;AAIA,MAAA,QAAQ,CAAC,KAAT,CAAe,OAAf,CAAuB,UAAC,IAAD,EAAS;AAC9B,YAAI,IAAI,CAAC,EAAL,IAAW,CAAC,eAAe,CAAC,IAAI,CAAC,EAAN,CAA/B,EAA0C;AACxC,UAAA,OAAO,CAAC,IAAI,CAAC,EAAN,CAAP,GAAmB,IAAnB;AACD;AACF,OAJD;AAMA,UAAM,KAAK,GAAG,KAAK,KAAnB;;AACA,UAAI,KAAK,IAAI,CAAC,SAAS,CAAC,OAAV,CAAkB,OAAlB,CAAd,EAA0C;AACxC,YAAM,SAAS,GAAG,KAAK,CAAC,iBAAN,CAAwB,IAAxB,EAA8B;AAAE,UAAA,QAAQ,EAAE;AAAZ,SAA9B,CAAlB;AACA,QAAA,SAAS,CAAC,OAAV,CAAkB,UAAC,IAAD,EAAS;AACzB,cAAM,MAAM,GAAG,IAAI,CAAC,eAAL,EAAf;;AACA,cAAI,MAAM,IAAI,OAAO,CAAC,MAAD,CAArB,EAA+B;AAC7B,YAAA,IAAI,CAAC,MAAL;AACD;AACF,SALD;AAMA,YAAM,SAAS,GAAG,KAAK,CAAC,iBAAN,CAAwB,IAAxB,EAA8B;AAAE,UAAA,QAAQ,EAAE;AAAZ,SAA9B,CAAlB;AACA,QAAA,SAAS,CAAC,OAAV,CAAkB,UAAC,IAAD,EAAS;AACzB,cAAM,MAAM,GAAG,IAAI,CAAC,eAAL,EAAf;;AACA,cAAI,MAAM,IAAI,OAAO,CAAC,MAAD,CAArB,EAA+B;AAC7B,YAAA,IAAI,CAAC,MAAL;AACD;AACF,SALD;AAMD;AACF;AAp3BH;AAAA;AAAA,WAs3BY,yBAAa;AAAA;;AACrB,UAAM,GAAG,GAA8B,EAAvC;AACA,UAAM,MAAM,GAAa,EAAzB;AACA,WAAK,KAAL,CAAW,KAAX,CAAiB,OAAjB,CAAyB,UAAC,CAAD,EAAM;AAC7B,YAAI,OAAO,CAAP,KAAa,QAAjB,EAA2B;AACzB,UAAA,MAAM,CAAC,IAAP,wBAA4B,CAA5B;AACD;;AAED,YAAI,CAAC,CAAC,EAAF,IAAQ,IAAZ,EAAkB;AAChB,UAAA,CAAC,CAAC,EAAF,GAAO,MAAI,CAAC,cAAL,EAAP;AACD;;AAED,YAAI,GAAG,CAAC,CAAC,CAAC,EAAH,CAAP,EAAe;AACb,UAAA,MAAM,CAAC,IAAP,CAAY,sBAAZ;AACD;;AAED,QAAA,GAAG,CAAC,CAAC,CAAC,EAAH,CAAH,GAAY,IAAZ;AACD,OAdD;AAgBA,aAAO,MAAP;AACD;AA14BH;AAAA;AAAA,WA44BY,0BAAc;AACtB,aAAO,SAAS,CAAC,IAAV,EAAP;AACD;AA94BH;AAAA;AAAA,WAg5BY,0BAAc;AACtB,UAAM,GAAG,GAAG,KAAK,aAAL,EAAZ;;AAEA,UAAI,GAAG,CAAC,MAAJ,GAAa,CAAjB,EAAoB;AAClB,aAAK,KAAL,CAAW,GAAX,CACE,OADF,EAEE,KAAK,KAAL,CAAW,WAAX,CAA6C,OAA7C,CAFF;AAIA,cAAM,IAAI,KAAJ,CAAU,GAAG,CAAC,IAAJ,CAAS,GAAT,CAAV,CAAN;AACD;;AAED,UAAM,IAAI,GAAG,KAAK,IAAL,GAAY,KAAK,IAAL,CAAU,QAAV,EAAZ,GAAmC,IAAhD;AACA,WAAK,IAAL,GAAY,IAAI,WAAJ,CAAgB,KAAK,KAArB,CAAZ;AACA,UAAM,IAAI,GAAG,KAAK,IAAL,CAAU,QAAV,EAAb;AAEA,UAAM,KAAK,GAAG,IAAI,GACd,IAAI,CAAC,MAAL,CAAY,UAAC,IAAD,EAAS;AACnB,YAAI,CAAC,IAAI,CAAC,IAAL,CAAU,UAAC,QAAD;AAAA,iBAAc,QAAQ,CAAC,EAAT,KAAgB,IAAI,CAAC,EAAnC;AAAA,SAAV,CAAL,EAAuD;AACrD,iBAAO,IAAP;AACD;;AACD,eAAO,IAAP;AACD,OALD,CADc,sBAOV,IAPU,CAAlB;AASA,UAAM,OAAO,GAAG,IAAI,GAChB,IAAI,CAAC,MAAL,CAAY,UAAC,IAAD,EAAS;AACnB,YAAI,CAAC,IAAI,CAAC,IAAL,CAAU,UAAC,OAAD;AAAA,iBAAa,OAAO,CAAC,EAAR,KAAe,IAAI,CAAC,EAAjC;AAAA,SAAV,CAAL,EAAqD;AACnD,iBAAO,IAAP;AACD;;AACD,eAAO,IAAP;AACD,OALD,CADgB,GAOhB,EAPJ;;AASA,UAAI,KAAK,CAAC,MAAN,GAAe,CAAnB,EAAsB;AACpB,aAAK,MAAL,CAAY,aAAZ,EAA2B;AAAE,UAAA,KAAK,EAAL,KAAF;AAAS,UAAA,IAAI,EAAE,IAAf;AAAqB,UAAA,IAAI,EAAE;AAA3B,SAA3B;AACD;;AAED,UAAI,OAAO,CAAC,MAAR,GAAiB,CAArB,EAAwB;AACtB,aAAK,MAAL,CAAY,eAAZ,EAA6B;AAAE,UAAA,OAAO,EAAP,OAAF;AAAW,UAAA,IAAI,EAAE,IAAjB;AAAuB,UAAA,IAAI,EAAE;AAA7B,SAA7B;AACD;AACF;AAx7BH;;AAAA;AAAA,EAEU,IAFV,EAWiB,MAAM,CAAC,WAXxB;AAGmB,IAAA,CAAA,QAAA,GAA0B;AACzC,EAAA,KAAK,EAAE,CADkC;AAEzC,EAAA,QAAQ,EAAE;AAAE,IAAA,CAAC,EAAE,CAAL;AAAQ,IAAA,CAAC,EAAE;AAAX,GAF+B;AAGzC,EAAA,IAAI,EAAE;AAAE,IAAA,KAAK,EAAE,CAAT;AAAY,IAAA,MAAM,EAAE;AAApB;AAHmC,CAA1B;;AA0gCnB,CAAA,UAAiB,IAAjB,EAAqB;AACN,EAAA,IAAA,CAAA,WAAA,gBAAoB,IAAI,CAAC,IAAzB;;AAEb,WAAgB,MAAhB,CAAuB,QAAvB,EAAoC;AAClC,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,aAAO,KAAP;AACD;;AAED,QAAI,QAAQ,YAAY,IAAxB,EAA8B;AAC5B,aAAO,IAAP;AACD;;AAED,QAAM,GAAG,GAAG,QAAQ,CAAC,MAAM,CAAC,WAAR,CAApB;AACA,QAAM,IAAI,GAAG,QAAb;;AAEA,QACE,CAAC,GAAG,IAAI,IAAP,IAAe,GAAG,KAAK,IAAA,CAAA,WAAxB,KACA,OAAO,IAAI,CAAC,MAAZ,KAAuB,UADvB,IAEA,OAAO,IAAI,CAAC,MAAZ,KAAuB,UAFvB,IAGA,OAAO,IAAI,CAAC,IAAZ,KAAqB,UAHrB,IAIA,OAAO,IAAI,CAAC,IAAZ,KAAqB,UAJrB,IAKA,OAAO,IAAI,CAAC,IAAZ,KAAqB,UALrB,IAMA,OAAO,IAAI,CAAC,QAAZ,KAAyB,UAP3B,EAQE;AACA,aAAO,IAAP;AACD;;AAED,WAAO,KAAP;AACD;;AAzBe,EAAA,IAAA,CAAA,MAAA,GAAM,MAAN;AA0BjB,CA7BD,EAAiB,IAAI,KAAJ,IAAI,GAAA,EAAA,CAArB;;AA+BA,CAAA,UAAiB,IAAjB,EAAqB;AACnB,EAAA,IAAI,CAAC,MAAL,CAAyB;AACvB,IAAA,SADuB,qBACb,EADa,EACS;AAAtB,UAAE,KAAF,GAAO,EAAP,CAAE,KAAF;AAAA,UAAY,QAAZ,GAAoB,MAAA,CAAA,EAAA,EAApB,CAAA,OAAA,CAAoB,CAApB;;AACR,UAAI,KAAJ,EAAW;AACT,QAAA,QAAQ,CAAC,KAAT,GAAiB,KAAK,CAAC,OAAN,CAAc,KAAd,IAAuB;AAAE,UAAA,KAAK,EAAE;AAAT,SAAvB,GAA0C,KAA3D;AACD;;AACD,aAAO,QAAP;AACD;AANsB,GAAzB;AAQD,CATD,EAAiB,IAAI,KAAJ,IAAI,GAAA,EAAA,CAArB;;AAWA,CAAA,UAAiB,IAAjB,EAAqB;AACN,EAAA,IAAA,CAAA,QAAA,GAAW,QAAQ,CAAC,MAAT,CAItB;AACA,IAAA,IAAI,EAAE,MADN;AAEA,IAAA,OAFA,mBAEQ,KAFR,EAEe,OAFf,EAEsB;AACpB,UAAI,aAAa,CAAC,KAAd,CAAoB,KAApB,EAA2B,IAA3B,CAAJ,EAAsC;AACpC,cAAM,IAAI,KAAJ,2BACe,KADf,qCAAN;AAGD;;AAED,UAAI,OAAO,OAAP,KAAmB,UAAvB,EAAmC;AACjC,QAAA,OAAO,CAAC,MAAR,CAAe;AAAE,UAAA,KAAK,EAAL;AAAF,SAAf;AACA,eAAO,OAAP;AACD;;AAED,UAAI,MAAM,GAAG,IAAb;;AACM,UAAE,OAAF,GAAyB,OAAzB,CAAE,OAAF;AAAA,UAAc,MAAd,GAAoB,MAAA,CAAK,OAAL,EAApB,CAAA,SAAA,CAAoB,CAApB;;AACN,UAAI,OAAJ,EAAa;AACX,YAAI,OAAO,OAAP,KAAmB,QAAvB,EAAiC;AAC/B,cAAM,IAAI,GAAG,KAAK,GAAL,CAAS,OAAT,CAAb;;AACA,cAAI,IAAI,IAAI,IAAZ,EAAkB;AAChB,iBAAK,UAAL,CAAgB,OAAhB,EAAyB,WAAzB;AACD,WAFD,MAEO;AACL,YAAA,MAAM,GAAG,IAAT;AACD;AACF,SAPD,MAOO;AACL,UAAA,MAAM,GAAG,OAAT;AACD;AACF;;AAED,UAAI,MAAM,CAAC,eAAP,IAA0B,IAA9B,EAAoC;AAClC,QAAA,MAAM,CAAC,eAAP,GAAyB,KAAzB;AACD;;AAED,UAAM,IAAI,GAAe,MAAM,CAAC,MAAP,CAAc,IAAd,CAAmB,MAAnB,EAA2B,MAA3B,CAAzB;AACA,MAAA,IAAI,CAAC,MAAL,CAAY;AAAE,QAAA,KAAK,EAAL;AAAF,OAAZ;AACA,aAAO,IAAP;AACD;AApCD,GAJsB,CAAX;AA2Cb,EAAA,aAAa,CAAC,eAAd,CAA8B,IAAA,CAAA,QAA9B;AACD,CA7CD,EAAiB,IAAI,KAAJ,IAAI,GAAA,EAAA,CAArB;;AA+CA,CAAA,UAAiB,IAAjB,EAAqB;AAOnB,MAAI,OAAO,GAAG,CAAd;;AACA,WAAS,YAAT,CAAsB,IAAtB,EAAmC;AACjC,QAAI,IAAJ,EAAU;AACR,aAAO,SAAS,CAAC,UAAV,CAAqB,IAArB,CAAP;AACD;;AACD,IAAA,OAAO,IAAI,CAAX;AACA,+BAAoB,OAApB;AACD;;AAED,WAAgB,MAAhB,CAAuB,MAAvB,EAAqC;AACnC,QAAQ,eAAR,GAAkD,MAAlD,CAAQ,eAAR;AAAA,QAAyB,SAAzB,GAAkD,MAAlD,CAAyB,SAAzB;AAAA,QAAuC,MAAvC,GAA6C,MAAA,CAAK,MAAL,EAAvC,CAAA,iBAAA,EAAA,WAAA,CAAuC,CAA7C;;AACA,QAAM,IAAI,GAAG,SAAS,CAAC,WAAV,CACX,YAAY,CAAC,eAAe,IAAI,MAAM,CAAC,KAA3B,CADD,EAEX,IAFW,CAAb;AAKA,IAAA,IAAI,CAAC,MAAL,CAAY,MAAZ;;AAEA,QAAI,MAAM,CAAC,KAAX,EAAkB;AAChB,MAAA,IAAA,CAAA,QAAA,CAAS,QAAT,CAAkB,MAAM,CAAC,KAAzB,EAAgC,IAAhC,EAAsC,SAAtC;AACD;;AAED,WAAO,IAAP;AACD;;AAde,EAAA,IAAA,CAAA,MAAA,GAAM,MAAN;;AAgBhB,WAAgB,MAAhB,CAAuB,OAAvB,EAAwC;AACtC,QAAM,KAAK,GAAG,OAAO,CAAC,KAAR,IAAiB,MAA/B;AACA,QAAM,IAAI,GAAG,IAAA,CAAA,QAAA,CAAS,GAAT,CAAa,KAAb,CAAb;;AACA,QAAI,IAAJ,EAAU;AACR,aAAO,IAAI,IAAJ,CAAS,OAAT,CAAP;AACD;;AACD,WAAO,IAAA,CAAA,QAAA,CAAS,UAAT,CAAoB,KAApB,CAAP;AACD;;AAPe,EAAA,IAAA,CAAA,MAAA,GAAM,MAAN;AAQjB,CAxCD,EAAiB,IAAI,KAAJ,IAAI,GAAA,EAAA,CAArB","sourceRoot":"","sourcesContent":["var __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { Registry } from '../registry';\nimport { Point, Rectangle, Angle } from '../geometry';\nimport { StringExt, ObjectExt, NumberExt } from '../util';\nimport { Markup } from '../view/markup';\nimport { Cell } from './cell';\nimport { ShareRegistry } from './registry';\nimport { PortManager } from './port';\nimport { Interp } from '../common';\nexport class Node extends Cell {\n    constructor(metadata = {}) {\n        super(metadata);\n        this.initPorts();\n    }\n    get [Symbol.toStringTag]() {\n        return Node.toStringTag;\n    }\n    preprocess(metadata, ignoreIdCheck) {\n        const { x, y, width, height } = metadata, others = __rest(metadata, [\"x\", \"y\", \"width\", \"height\"]);\n        if (x != null || y != null) {\n            const position = others.position;\n            others.position = Object.assign(Object.assign({}, position), { x: x != null ? x : position ? position.x : 0, y: y != null ? y : position ? position.y : 0 });\n        }\n        if (width != null || height != null) {\n            const size = others.size;\n            others.size = Object.assign(Object.assign({}, size), { width: width != null ? width : size ? size.width : 0, height: height != null ? height : size ? size.height : 0 });\n        }\n        return super.preprocess(others, ignoreIdCheck);\n    }\n    isNode() {\n        return true;\n    }\n    size(width, height, options) {\n        if (width === undefined) {\n            return this.getSize();\n        }\n        if (typeof width === 'number') {\n            return this.setSize(width, height, options);\n        }\n        return this.setSize(width, height);\n    }\n    getSize() {\n        const size = this.store.get('size');\n        return size ? Object.assign({}, size) : { width: 1, height: 1 };\n    }\n    setSize(width, height, options) {\n        if (typeof width === 'object') {\n            this.resize(width.width, width.height, height);\n        }\n        else {\n            this.resize(width, height, options);\n        }\n        return this;\n    }\n    resize(width, height, options = {}) {\n        this.startBatch('resize', options);\n        const direction = options.direction;\n        if (direction) {\n            const currentSize = this.getSize();\n            switch (direction) {\n                case 'left':\n                case 'right':\n                    // Don't change height when resizing horizontally.\n                    height = currentSize.height; // eslint-disable-line\n                    break;\n                case 'top':\n                case 'bottom':\n                    // Don't change width when resizing vertically.\n                    width = currentSize.width; // eslint-disable-line\n                    break;\n                default:\n                    break;\n            }\n            const map = {\n                right: 0,\n                'top-right': 0,\n                top: 1,\n                'top-left': 1,\n                left: 2,\n                'bottom-left': 2,\n                bottom: 3,\n                'bottom-right': 3,\n            };\n            let quadrant = map[direction];\n            const angle = Angle.normalize(this.getAngle() || 0);\n            if (options.absolute) {\n                // We are taking the node's rotation into account\n                quadrant += Math.floor((angle + 45) / 90);\n                quadrant %= 4;\n            }\n            // This is a rectangle in size of the un-rotated node.\n            const bbox = this.getBBox();\n            // Pick the corner point on the node, which meant to stay on its\n            // place before and after the rotation.\n            let fixedPoint;\n            if (quadrant === 0) {\n                fixedPoint = bbox.getBottomLeft();\n            }\n            else if (quadrant === 1) {\n                fixedPoint = bbox.getCorner();\n            }\n            else if (quadrant === 2) {\n                fixedPoint = bbox.getTopRight();\n            }\n            else {\n                fixedPoint = bbox.getOrigin();\n            }\n            // Find an image of the previous indent point. This is the position,\n            // where is the point actually located on the screen.\n            const imageFixedPoint = fixedPoint\n                .clone()\n                .rotate(-angle, bbox.getCenter());\n            // Every point on the element rotates around a circle with the centre of\n            // rotation in the middle of the element while the whole element is being\n            // rotated. That means that the distance from a point in the corner of\n            // the element (supposed its always rect) to the center of the element\n            // doesn't change during the rotation and therefore it equals to a\n            // distance on un-rotated element.\n            // We can find the distance as DISTANCE = (ELEMENTWIDTH/2)^2 + (ELEMENTHEIGHT/2)^2)^0.5.\n            const radius = Math.sqrt(width * width + height * height) / 2;\n            // Now we are looking for an angle between x-axis and the line starting\n            // at image of fixed point and ending at the center of the element.\n            // We call this angle `alpha`.\n            // The image of a fixed point is located in n-th quadrant. For each\n            // quadrant passed going anti-clockwise we have to add 90 degrees.\n            // Note that the first quadrant has index 0.\n            //\n            // 3 | 2\n            // --c-- Quadrant positions around the element's center `c`\n            // 0 | 1\n            //\n            let alpha = (quadrant * Math.PI) / 2;\n            // Add an angle between the beginning of the current quadrant (line\n            // parallel with x-axis or y-axis going through the center of the\n            // element) and line crossing the indent of the fixed point and the\n            // center of the element. This is the angle we need but on the\n            // un-rotated element.\n            alpha += Math.atan(quadrant % 2 === 0 ? height / width : width / height);\n            // Lastly we have to deduct the original angle the element was rotated\n            // by and that's it.\n            alpha -= Angle.toRad(angle);\n            // With this angle and distance we can easily calculate the centre of\n            // the un-rotated element.\n            // Note that fromPolar constructor accepts an angle in radians.\n            const center = Point.fromPolar(radius, alpha, imageFixedPoint);\n            // The top left corner on the un-rotated element has to be half a width\n            // on the left and half a height to the top from the center. This will\n            // be the origin of rectangle we were looking for.\n            const origin = center.clone().translate(width / -2, height / -2);\n            this.store.set('size', { width, height }, options);\n            this.setPosition(origin.x, origin.y, options);\n        }\n        else {\n            this.store.set('size', { width, height }, options);\n        }\n        this.stopBatch('resize', options);\n        return this;\n    }\n    scale(sx, sy, origin, options = {}) {\n        const scaledBBox = this.getBBox().scale(sx, sy, origin == null ? undefined : origin);\n        this.startBatch('scale', options);\n        this.setPosition(scaledBBox.x, scaledBBox.y, options);\n        this.resize(scaledBBox.width, scaledBBox.height, options);\n        this.stopBatch('scale');\n        return this;\n    }\n    position(arg0, arg1, arg2) {\n        if (typeof arg0 === 'number') {\n            return this.setPosition(arg0, arg1, arg2);\n        }\n        return this.getPosition(arg0);\n    }\n    getPosition(options = {}) {\n        if (options.relative) {\n            const parent = this.getParent();\n            if (parent != null && parent.isNode()) {\n                const currentPosition = this.getPosition();\n                const parentPosition = parent.getPosition();\n                return {\n                    x: currentPosition.x - parentPosition.x,\n                    y: currentPosition.y - parentPosition.y,\n                };\n            }\n        }\n        const pos = this.store.get('position');\n        return pos ? Object.assign({}, pos) : { x: 0, y: 0 };\n    }\n    setPosition(arg0, arg1, arg2 = {}) {\n        let x;\n        let y;\n        let options;\n        if (typeof arg0 === 'object') {\n            x = arg0.x;\n            y = arg0.y;\n            options = arg1 || {};\n        }\n        else {\n            x = arg0;\n            y = arg1;\n            options = arg2 || {};\n        }\n        if (options.relative) {\n            const parent = this.getParent();\n            if (parent != null && parent.isNode()) {\n                const parentPosition = parent.getPosition();\n                x += parentPosition.x;\n                y += parentPosition.y;\n            }\n        }\n        if (options.deep) {\n            const currentPosition = this.getPosition();\n            this.translate(x - currentPosition.x, y - currentPosition.y, options);\n        }\n        else {\n            this.store.set('position', { x, y }, options);\n        }\n        return this;\n    }\n    translate(tx = 0, ty = 0, options = {}) {\n        if (tx === 0 && ty === 0) {\n            return this;\n        }\n        // Pass the initiator of the translation.\n        options.translateBy = options.translateBy || this.id;\n        const position = this.getPosition();\n        if (options.restrict != null && options.translateBy === this.id) {\n            // We are restricting the translation for the element itself only. We get\n            // the bounding box of the element including all its embeds.\n            // All embeds have to be translated the exact same way as the element.\n            const bbox = this.getBBox({ deep: true });\n            const ra = options.restrict;\n            // - - - - - - - - - - - - -> ra.x + ra.width\n            // - - - -> position.x      |\n            // -> bbox.x\n            //                ▓▓▓▓▓▓▓   |\n            //         ░░░░░░░▓▓▓▓▓▓▓\n            //         ░░░░░░░░░        |\n            //   ▓▓▓▓▓▓▓▓░░░░░░░\n            //   ▓▓▓▓▓▓▓▓               |\n            //   <-dx->                     | restricted area right border\n            //         <-width->        |   ░ translated element\n            //   <- - bbox.width - ->       ▓ embedded element\n            const dx = position.x - bbox.x;\n            const dy = position.y - bbox.y;\n            // Find the maximal/minimal coordinates that the element can be translated\n            // while complies the restrictions.\n            const x = Math.max(ra.x + dx, Math.min(ra.x + ra.width + dx - bbox.width, position.x + tx));\n            const y = Math.max(ra.y + dy, Math.min(ra.y + ra.height + dy - bbox.height, position.y + ty));\n            // recalculate the translation taking the restrictions into account.\n            tx = x - position.x; // eslint-disable-line\n            ty = y - position.y; // eslint-disable-line\n        }\n        const translatedPosition = {\n            x: position.x + tx,\n            y: position.y + ty,\n        };\n        // To find out by how much an element was translated in event\n        // 'change:position' handlers.\n        options.tx = tx;\n        options.ty = ty;\n        if (options.transition) {\n            if (typeof options.transition !== 'object') {\n                options.transition = {};\n            }\n            this.transition('position', translatedPosition, Object.assign(Object.assign({}, options.transition), { interp: Interp.object }));\n            this.eachChild((child) => {\n                var _a;\n                const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n                if (!excluded) {\n                    child.translate(tx, ty, options);\n                }\n            });\n        }\n        else {\n            this.startBatch('translate', options);\n            this.store.set('position', translatedPosition, options);\n            this.eachChild((child) => {\n                var _a;\n                const excluded = (_a = options.exclude) === null || _a === void 0 ? void 0 : _a.includes(child);\n                if (!excluded) {\n                    child.translate(tx, ty, options);\n                }\n            });\n            this.stopBatch('translate', options);\n        }\n        return this;\n    }\n    angle(val, options) {\n        if (val == null) {\n            return this.getAngle();\n        }\n        return this.rotate(val, options);\n    }\n    getAngle() {\n        return this.store.get('angle', 0);\n    }\n    rotate(angle, options = {}) {\n        const currentAngle = this.getAngle();\n        if (options.center) {\n            const size = this.getSize();\n            const position = this.getPosition();\n            const center = this.getBBox().getCenter();\n            center.rotate(currentAngle - angle, options.center);\n            const dx = center.x - size.width / 2 - position.x;\n            const dy = center.y - size.height / 2 - position.y;\n            this.startBatch('rotate', { angle, options });\n            this.setPosition(position.x + dx, position.y + dy, options);\n            this.rotate(angle, Object.assign(Object.assign({}, options), { center: null }));\n            this.stopBatch('rotate');\n        }\n        else {\n            this.store.set('angle', options.absolute ? angle : (currentAngle + angle) % 360, options);\n        }\n        return this;\n    }\n    // #endregion\n    // #region common\n    getBBox(options = {}) {\n        if (options.deep) {\n            const cells = this.getDescendants({ deep: true, breadthFirst: true });\n            cells.push(this);\n            return Cell.getCellsBBox(cells);\n        }\n        return Rectangle.fromPositionAndSize(this.getPosition(), this.getSize());\n    }\n    getConnectionPoint(edge, type) {\n        const bbox = this.getBBox();\n        const center = bbox.getCenter();\n        const terminal = edge.getTerminal(type);\n        if (terminal == null) {\n            return center;\n        }\n        const portId = terminal.port;\n        if (!portId || !this.hasPort(portId)) {\n            return center;\n        }\n        const port = this.getPort(portId);\n        if (!port || !port.group) {\n            return center;\n        }\n        const layouts = this.getPortsPosition(port.group);\n        const position = layouts[portId].position;\n        const portCenter = Point.create(position).translate(bbox.getOrigin());\n        const angle = this.getAngle();\n        if (angle) {\n            portCenter.rotate(-angle, center);\n        }\n        return portCenter;\n    }\n    /**\n     * Sets cell's size and position based on the children bbox and given padding.\n     */\n    fit(options = {}) {\n        const children = this.getChildren() || [];\n        const embeds = children.filter((cell) => cell.isNode());\n        if (embeds.length === 0) {\n            return this;\n        }\n        this.startBatch('fit-embeds', options);\n        if (options.deep) {\n            embeds.forEach((cell) => cell.fit(options));\n        }\n        let { x, y, width, height } = Cell.getCellsBBox(embeds);\n        const padding = NumberExt.normalizeSides(options.padding);\n        x -= padding.left;\n        y -= padding.top;\n        width += padding.left + padding.right;\n        height += padding.bottom + padding.top;\n        this.store.set({\n            position: { x, y },\n            size: { width, height },\n        }, options);\n        this.stopBatch('fit-embeds');\n        return this;\n    }\n    // #endregion\n    // #region ports\n    get portContainerMarkup() {\n        return this.getPortContainerMarkup();\n    }\n    set portContainerMarkup(markup) {\n        this.setPortContainerMarkup(markup);\n    }\n    getDefaultPortContainerMarkup() {\n        return (this.store.get('defaultPortContainerMarkup') ||\n            Markup.getPortContainerMarkup());\n    }\n    getPortContainerMarkup() {\n        return (this.store.get('portContainerMarkup') ||\n            this.getDefaultPortContainerMarkup());\n    }\n    setPortContainerMarkup(markup, options = {}) {\n        this.store.set('portContainerMarkup', Markup.clone(markup), options);\n        return this;\n    }\n    get portMarkup() {\n        return this.getPortMarkup();\n    }\n    set portMarkup(markup) {\n        this.setPortMarkup(markup);\n    }\n    getDefaultPortMarkup() {\n        return this.store.get('defaultPortMarkup') || Markup.getPortMarkup();\n    }\n    getPortMarkup() {\n        return this.store.get('portMarkup') || this.getDefaultPortMarkup();\n    }\n    setPortMarkup(markup, options = {}) {\n        this.store.set('portMarkup', Markup.clone(markup), options);\n        return this;\n    }\n    get portLabelMarkup() {\n        return this.getPortLabelMarkup();\n    }\n    set portLabelMarkup(markup) {\n        this.setPortLabelMarkup(markup);\n    }\n    getDefaultPortLabelMarkup() {\n        return (this.store.get('defaultPortLabelMarkup') || Markup.getPortLabelMarkup());\n    }\n    getPortLabelMarkup() {\n        return this.store.get('portLabelMarkup') || this.getDefaultPortLabelMarkup();\n    }\n    setPortLabelMarkup(markup, options = {}) {\n        this.store.set('portLabelMarkup', Markup.clone(markup), options);\n        return this;\n    }\n    get ports() {\n        const res = this.store.get('ports', { items: [] });\n        if (res.items == null) {\n            res.items = [];\n        }\n        return res;\n    }\n    getPorts() {\n        return ObjectExt.cloneDeep(this.ports.items);\n    }\n    getPortsByGroup(groupName) {\n        return this.getPorts().filter((port) => port.group === groupName);\n    }\n    getPort(portId) {\n        return ObjectExt.cloneDeep(this.ports.items.find((port) => port.id && port.id === portId));\n    }\n    getPortAt(index) {\n        return this.ports.items[index] || null;\n    }\n    hasPorts() {\n        return this.ports.items.length > 0;\n    }\n    hasPort(portId) {\n        return this.getPortIndex(portId) !== -1;\n    }\n    getPortIndex(port) {\n        const portId = typeof port === 'string' ? port : port.id;\n        return portId != null\n            ? this.ports.items.findIndex((item) => item.id === portId)\n            : -1;\n    }\n    getPortsPosition(groupName) {\n        const size = this.getSize();\n        const layouts = this.port.getPortsLayoutByGroup(groupName, new Rectangle(0, 0, size.width, size.height));\n        return layouts.reduce((memo, item) => {\n            const layout = item.portLayout;\n            memo[item.portId] = {\n                position: Object.assign({}, layout.position),\n                angle: layout.angle || 0,\n            };\n            return memo;\n        }, {});\n    }\n    getPortProp(portId, path) {\n        return this.getPropByPath(this.prefixPortPath(portId, path));\n    }\n    setPortProp(portId, arg1, arg2, arg3) {\n        if (typeof arg1 === 'string' || Array.isArray(arg1)) {\n            const path = this.prefixPortPath(portId, arg1);\n            const value = arg2;\n            return this.setPropByPath(path, value, arg3);\n        }\n        const path = this.prefixPortPath(portId);\n        const value = arg1;\n        return this.setPropByPath(path, value, arg2);\n    }\n    removePortProp(portId, path, options) {\n        if (typeof path === 'string' || Array.isArray(path)) {\n            return this.removePropByPath(this.prefixPortPath(portId, path), options);\n        }\n        return this.removePropByPath(this.prefixPortPath(portId), path);\n    }\n    portProp(portId, path, value, options) {\n        if (path == null) {\n            return this.getPortProp(portId);\n        }\n        if (typeof path === 'string' || Array.isArray(path)) {\n            if (arguments.length === 2) {\n                return this.getPortProp(portId, path);\n            }\n            if (value == null) {\n                return this.removePortProp(portId, path, options);\n            }\n            return this.setPortProp(portId, path, value, options);\n        }\n        return this.setPortProp(portId, path, value);\n    }\n    prefixPortPath(portId, path) {\n        const index = this.getPortIndex(portId);\n        if (index === -1) {\n            throw new Error(`Unable to find port with id: \"${portId}\"`);\n        }\n        if (path == null || path === '') {\n            return ['ports', 'items', `${index}`];\n        }\n        if (Array.isArray(path)) {\n            return ['ports', 'items', `${index}`, ...path];\n        }\n        return `ports/items/${index}/${path}`;\n    }\n    addPort(port, options) {\n        const ports = [...this.ports.items];\n        ports.push(port);\n        this.setPropByPath('ports/items', ports, options);\n        return this;\n    }\n    addPorts(ports, options) {\n        this.setPropByPath('ports/items', [...this.ports.items, ...ports], options);\n        return this;\n    }\n    removePort(port, options = {}) {\n        return this.removePortAt(this.getPortIndex(port), options);\n    }\n    removePortAt(index, options = {}) {\n        if (index >= 0) {\n            const ports = [...this.ports.items];\n            ports.splice(index, 1);\n            options.rewrite = true;\n            this.setPropByPath('ports/items', ports, options);\n        }\n        return this;\n    }\n    removePorts(portsForRemoval, opt) {\n        let options;\n        if (Array.isArray(portsForRemoval)) {\n            options = opt || {};\n            if (portsForRemoval.length) {\n                options.rewrite = true;\n                const currentPorts = [...this.ports.items];\n                const remainingPorts = currentPorts.filter((cp) => !portsForRemoval.some((p) => {\n                    const id = typeof p === 'string' ? p : p.id;\n                    return cp.id === id;\n                }));\n                this.setPropByPath('ports/items', remainingPorts, options);\n            }\n        }\n        else {\n            options = portsForRemoval || {};\n            options.rewrite = true;\n            this.setPropByPath('ports/items', [], options);\n        }\n        return this;\n    }\n    getParsedPorts() {\n        return this.port.getPorts();\n    }\n    getParsedGroups() {\n        return this.port.groups;\n    }\n    getPortsLayoutByGroup(groupName, bbox) {\n        return this.port.getPortsLayoutByGroup(groupName, bbox);\n    }\n    initPorts() {\n        this.updatePortData();\n        this.on('change:ports', () => {\n            this.processRemovedPort();\n            this.updatePortData();\n        });\n    }\n    processRemovedPort() {\n        const current = this.ports;\n        const currentItemsMap = {};\n        current.items.forEach((item) => {\n            if (item.id) {\n                currentItemsMap[item.id] = true;\n            }\n        });\n        const removed = {};\n        const previous = this.store.getPrevious('ports') || {\n            items: [],\n        };\n        previous.items.forEach((item) => {\n            if (item.id && !currentItemsMap[item.id]) {\n                removed[item.id] = true;\n            }\n        });\n        const model = this.model;\n        if (model && !ObjectExt.isEmpty(removed)) {\n            const incomings = model.getConnectedEdges(this, { incoming: true });\n            incomings.forEach((edge) => {\n                const portId = edge.getTargetPortId();\n                if (portId && removed[portId]) {\n                    edge.remove();\n                }\n            });\n            const outgoings = model.getConnectedEdges(this, { outgoing: true });\n            outgoings.forEach((edge) => {\n                const portId = edge.getSourcePortId();\n                if (portId && removed[portId]) {\n                    edge.remove();\n                }\n            });\n        }\n    }\n    validatePorts() {\n        const ids = {};\n        const errors = [];\n        this.ports.items.forEach((p) => {\n            if (typeof p !== 'object') {\n                errors.push(`Invalid port ${p}.`);\n            }\n            if (p.id == null) {\n                p.id = this.generatePortId();\n            }\n            if (ids[p.id]) {\n                errors.push('Duplicitied port id.');\n            }\n            ids[p.id] = true;\n        });\n        return errors;\n    }\n    generatePortId() {\n        return StringExt.uuid();\n    }\n    updatePortData() {\n        const err = this.validatePorts();\n        if (err.length > 0) {\n            this.store.set('ports', this.store.getPrevious('ports'));\n            throw new Error(err.join(' '));\n        }\n        const prev = this.port ? this.port.getPorts() : null;\n        this.port = new PortManager(this.ports);\n        const curr = this.port.getPorts();\n        const added = prev\n            ? curr.filter((item) => {\n                if (!prev.find((prevPort) => prevPort.id === item.id)) {\n                    return item;\n                }\n                return null;\n            })\n            : [...curr];\n        const removed = prev\n            ? prev.filter((item) => {\n                if (!curr.find((curPort) => curPort.id === item.id)) {\n                    return item;\n                }\n                return null;\n            })\n            : [];\n        if (added.length > 0) {\n            this.notify('ports:added', { added, cell: this, node: this });\n        }\n        if (removed.length > 0) {\n            this.notify('ports:removed', { removed, cell: this, node: this });\n        }\n    }\n}\nNode.defaults = {\n    angle: 0,\n    position: { x: 0, y: 0 },\n    size: { width: 1, height: 1 },\n};\n(function (Node) {\n    Node.toStringTag = `X6.${Node.name}`;\n    function isNode(instance) {\n        if (instance == null) {\n            return false;\n        }\n        if (instance instanceof Node) {\n            return true;\n        }\n        const tag = instance[Symbol.toStringTag];\n        const node = instance;\n        if ((tag == null || tag === Node.toStringTag) &&\n            typeof node.isNode === 'function' &&\n            typeof node.isEdge === 'function' &&\n            typeof node.prop === 'function' &&\n            typeof node.attr === 'function' &&\n            typeof node.size === 'function' &&\n            typeof node.position === 'function') {\n            return true;\n        }\n        return false;\n    }\n    Node.isNode = isNode;\n})(Node || (Node = {}));\n(function (Node) {\n    Node.config({\n        propHooks(_a) {\n            var { ports } = _a, metadata = __rest(_a, [\"ports\"]);\n            if (ports) {\n                metadata.ports = Array.isArray(ports) ? { items: ports } : ports;\n            }\n            return metadata;\n        },\n    });\n})(Node || (Node = {}));\n(function (Node) {\n    Node.registry = Registry.create({\n        type: 'node',\n        process(shape, options) {\n            if (ShareRegistry.exist(shape, true)) {\n                throw new Error(`Node with name '${shape}' was registered by anthor Edge`);\n            }\n            if (typeof options === 'function') {\n                options.config({ shape });\n                return options;\n            }\n            let parent = Node;\n            const { inherit } = options, config = __rest(options, [\"inherit\"]);\n            if (inherit) {\n                if (typeof inherit === 'string') {\n                    const base = this.get(inherit);\n                    if (base == null) {\n                        this.onNotFound(inherit, 'inherited');\n                    }\n                    else {\n                        parent = base;\n                    }\n                }\n                else {\n                    parent = inherit;\n                }\n            }\n            if (config.constructorName == null) {\n                config.constructorName = shape;\n            }\n            const ctor = parent.define.call(parent, config);\n            ctor.config({ shape });\n            return ctor;\n        },\n    });\n    ShareRegistry.setNodeRegistry(Node.registry);\n})(Node || (Node = {}));\n(function (Node) {\n    let counter = 0;\n    function getClassName(name) {\n        if (name) {\n            return StringExt.pascalCase(name);\n        }\n        counter += 1;\n        return `CustomNode${counter}`;\n    }\n    function define(config) {\n        const { constructorName, overwrite } = config, others = __rest(config, [\"constructorName\", \"overwrite\"]);\n        const ctor = ObjectExt.createClass(getClassName(constructorName || others.shape), this);\n        ctor.config(others);\n        if (others.shape) {\n            Node.registry.register(others.shape, ctor, overwrite);\n        }\n        return ctor;\n    }\n    Node.define = define;\n    function create(options) {\n        const shape = options.shape || 'rect';\n        const Ctor = Node.registry.get(shape);\n        if (Ctor) {\n            return new Ctor(options);\n        }\n        return Node.registry.onNotFound(shape);\n    }\n    Node.create = create;\n})(Node || (Node = {}));\n//# sourceMappingURL=node.js.map"]},"metadata":{},"sourceType":"module"}