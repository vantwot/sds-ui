{"ast":null,"code":"import { PortLayout, PortLabelLayout } from '../registry';\nimport { ObjectExt } from '../util';\nimport { Point } from '../geometry';\nexport class PortManager {\n  constructor(data) {\n    this.ports = [];\n    this.groups = {};\n    this.init(ObjectExt.cloneDeep(data));\n  }\n\n  getPorts() {\n    return this.ports;\n  }\n\n  getGroup(groupName) {\n    return groupName != null ? this.groups[groupName] : null;\n  }\n\n  getPortsByGroup(groupName) {\n    return this.ports.filter(p => p.group === groupName || p.group == null && groupName == null);\n  }\n\n  getPortsLayoutByGroup(groupName, elemBBox) {\n    const ports = this.getPortsByGroup(groupName);\n    const group = groupName ? this.getGroup(groupName) : null;\n    const groupPosition = group ? group.position : null;\n    const groupPositionName = groupPosition ? groupPosition.name : null;\n    let layoutFn;\n\n    if (groupPositionName != null) {\n      const fn = PortLayout.registry.get(groupPositionName);\n\n      if (fn == null) {\n        return PortLayout.registry.onNotFound(groupPositionName);\n      }\n\n      layoutFn = fn;\n    } else {\n      layoutFn = PortLayout.presets.left;\n    }\n\n    const portsArgs = ports.map(port => port && port.position && port.position.args || {});\n    const groupArgs = groupPosition && groupPosition.args || {};\n    const layouts = layoutFn(portsArgs, elemBBox, groupArgs);\n    return layouts.map((portLayout, index) => {\n      const port = ports[index];\n      return {\n        portLayout,\n        portId: port.id,\n        portSize: port.size,\n        portAttrs: port.attrs,\n        labelSize: port.label.size,\n        labelLayout: this.getPortLabelLayout(port, Point.create(portLayout.position), elemBBox)\n      };\n    });\n  }\n\n  init(data) {\n    const {\n      groups,\n      items\n    } = data;\n\n    if (groups != null) {\n      Object.keys(groups).forEach(key => {\n        this.groups[key] = this.parseGroup(groups[key]);\n      });\n    }\n\n    if (Array.isArray(items)) {\n      items.forEach(item => {\n        this.ports.push(this.parsePort(item));\n      });\n    }\n  }\n\n  parseGroup(group) {\n    return Object.assign(Object.assign({}, group), {\n      label: this.getLabel(group, true),\n      position: this.getPortPosition(group.position, true)\n    });\n  }\n\n  parsePort(port) {\n    const result = Object.assign({}, port);\n    const group = this.getGroup(port.group) || {};\n    result.markup = result.markup || group.markup;\n    result.attrs = ObjectExt.merge({}, group.attrs, result.attrs);\n    result.position = this.createPosition(group, result);\n    result.label = ObjectExt.merge({}, group.label, this.getLabel(result));\n    result.zIndex = this.getZIndex(group, result);\n    result.size = Object.assign(Object.assign({}, group.size), result.size);\n    return result;\n  }\n\n  getZIndex(group, port) {\n    if (typeof port.zIndex === 'number') {\n      return port.zIndex;\n    }\n\n    if (typeof group.zIndex === 'number' || group.zIndex === 'auto') {\n      return group.zIndex;\n    }\n\n    return 'auto';\n  }\n\n  createPosition(group, port) {\n    return ObjectExt.merge({\n      name: 'left',\n      args: {}\n    }, group.position, {\n      args: port.args\n    });\n  }\n\n  getPortPosition(position) {\n    let setDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (position == null) {\n      if (setDefault) {\n        return {\n          name: 'left',\n          args: {}\n        };\n      }\n    } else {\n      if (typeof position === 'string') {\n        return {\n          name: position,\n          args: {}\n        };\n      }\n\n      if (Array.isArray(position)) {\n        return {\n          name: 'absolute',\n          args: {\n            x: position[0],\n            y: position[1]\n          }\n        };\n      }\n\n      if (typeof position === 'object') {\n        return position;\n      }\n    }\n\n    return {\n      args: {}\n    };\n  }\n\n  getPortLabelPosition(position) {\n    let setDefault = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n    if (position == null) {\n      if (setDefault) {\n        return {\n          name: 'left',\n          args: {}\n        };\n      }\n    } else {\n      if (typeof position === 'string') {\n        return {\n          name: position,\n          args: {}\n        };\n      }\n\n      if (typeof position === 'object') {\n        return position;\n      }\n    }\n\n    return {\n      args: {}\n    };\n  }\n\n  getLabel(item) {\n    let setDefaults = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    const label = item.label || {};\n    label.position = this.getPortLabelPosition(label.position, setDefaults);\n    return label;\n  }\n\n  getPortLabelLayout(port, portPosition, elemBBox) {\n    const name = port.label.position.name || 'left';\n    const args = port.label.position.args || {};\n    const layoutFn = PortLabelLayout.registry.get(name) || PortLabelLayout.presets.left;\n\n    if (layoutFn) {\n      return layoutFn(portPosition, elemBBox, args);\n    }\n\n    return null;\n  }\n\n}","map":{"version":3,"sources":["../../src/model/port.ts"],"names":[],"mappings":"AAAA,SAAe,UAAf,EAA2B,eAA3B,QAAkD,aAAlD;AACA,SAAqB,SAArB,QAAsC,SAAtC;AACA,SAAS,KAAT,QAAiC,aAAjC;AAIA,OAAM,MAAO,WAAP,CAAkB;AAItB,EAAA,WAAA,CAAY,IAAZ,EAAsC;AACpC,SAAK,KAAL,GAAa,EAAb;AACA,SAAK,MAAL,GAAc,EAAd;AACA,SAAK,IAAL,CAAU,SAAS,CAAC,SAAV,CAAoB,IAApB,CAAV;AACD;;AAED,EAAA,QAAQ,GAAA;AACN,WAAO,KAAK,KAAZ;AACD;;AAED,EAAA,QAAQ,CAAC,SAAD,EAA0B;AAChC,WAAO,SAAS,IAAI,IAAb,GAAoB,KAAK,MAAL,CAAY,SAAZ,CAApB,GAA6C,IAApD;AACD;;AAED,EAAA,eAAe,CAAC,SAAD,EAAmB;AAChC,WAAO,KAAK,KAAL,CAAW,MAAX,CACJ,CAAD,IAAO,CAAC,CAAC,KAAF,KAAY,SAAZ,IAA0B,CAAC,CAAC,KAAF,IAAW,IAAX,IAAmB,SAAS,IAAI,IAD5D,CAAP;AAGD;;AAED,EAAA,qBAAqB,CAAC,SAAD,EAAgC,QAAhC,EAAmD;AACtE,UAAM,KAAK,GAAG,KAAK,eAAL,CAAqB,SAArB,CAAd;AACA,UAAM,KAAK,GAAG,SAAS,GAAG,KAAK,QAAL,CAAc,SAAd,CAAH,GAA8B,IAArD;AACA,UAAM,aAAa,GAAG,KAAK,GAAG,KAAK,CAAC,QAAT,GAAoB,IAA/C;AACA,UAAM,iBAAiB,GAAG,aAAa,GAAG,aAAa,CAAC,IAAjB,GAAwB,IAA/D;AAEA,QAAI,QAAJ;;AAEA,QAAI,iBAAiB,IAAI,IAAzB,EAA+B;AAC7B,YAAM,EAAE,GAAG,UAAU,CAAC,QAAX,CAAoB,GAApB,CAAwB,iBAAxB,CAAX;;AACA,UAAI,EAAE,IAAI,IAAV,EAAgB;AACd,eAAO,UAAU,CAAC,QAAX,CAAoB,UAApB,CAA+B,iBAA/B,CAAP;AACD;;AACD,MAAA,QAAQ,GAAG,EAAX;AACD,KAND,MAMO;AACL,MAAA,QAAQ,GAAG,UAAU,CAAC,OAAX,CAAmB,IAA9B;AACD;;AAED,UAAM,SAAS,GAAG,KAAK,CAAC,GAAN,CACf,IAAD,IAAW,IAAI,IAAI,IAAI,CAAC,QAAb,IAAyB,IAAI,CAAC,QAAL,CAAc,IAAxC,IAAiD,EAD3C,CAAlB;AAGA,UAAM,SAAS,GAAI,aAAa,IAAI,aAAa,CAAC,IAAhC,IAAyC,EAA3D;AACA,UAAM,OAAO,GAAG,QAAQ,CAAC,SAAD,EAAY,QAAZ,EAAsB,SAAtB,CAAxB;AACA,WAAO,OAAO,CAAC,GAAR,CAAsC,CAAC,UAAD,EAAa,KAAb,KAAsB;AACjE,YAAM,IAAI,GAAG,KAAK,CAAC,KAAD,CAAlB;AACA,aAAO;AACL,QAAA,UADK;AAEL,QAAA,MAAM,EAAE,IAAI,CAAC,EAFR;AAGL,QAAA,QAAQ,EAAE,IAAI,CAAC,IAHV;AAIL,QAAA,SAAS,EAAE,IAAI,CAAC,KAJX;AAKL,QAAA,SAAS,EAAE,IAAI,CAAC,KAAL,CAAW,IALjB;AAML,QAAA,WAAW,EAAE,KAAK,kBAAL,CACX,IADW,EAEX,KAAK,CAAC,MAAN,CAAa,UAAU,CAAC,QAAxB,CAFW,EAGX,QAHW;AANR,OAAP;AAYD,KAdM,CAAP;AAeD;;AAES,EAAA,IAAI,CAAC,IAAD,EAA2B;AACvC,UAAM;AAAE,MAAA,MAAF;AAAU,MAAA;AAAV,QAAoB,IAA1B;;AAEA,QAAI,MAAM,IAAI,IAAd,EAAoB;AAClB,MAAA,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,OAApB,CAA6B,GAAD,IAAQ;AAClC,aAAK,MAAL,CAAY,GAAZ,IAAmB,KAAK,UAAL,CAAgB,MAAM,CAAC,GAAD,CAAtB,CAAnB;AACD,OAFD;AAGD;;AAED,QAAI,KAAK,CAAC,OAAN,CAAc,KAAd,CAAJ,EAA0B;AACxB,MAAA,KAAK,CAAC,OAAN,CAAe,IAAD,IAAS;AACrB,aAAK,KAAL,CAAW,IAAX,CAAgB,KAAK,SAAL,CAAe,IAAf,CAAhB;AACD,OAFD;AAGD;AACF;;AAES,EAAA,UAAU,CAAC,KAAD,EAAiC;AACnD,WAAO,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EACF,KADE,CAAA,EACG;AACR,MAAA,KAAK,EAAE,KAAK,QAAL,CAAc,KAAd,EAAqB,IAArB,CADC;AAER,MAAA,QAAQ,EAAE,KAAK,eAAL,CAAqB,KAAK,CAAC,QAA3B,EAAqC,IAArC;AAFF,KADH,CAAP;AAKD;;AAES,EAAA,SAAS,CAAC,IAAD,EAA+B;AAChD,UAAM,MAAM,GAAG,MAAA,CAAA,MAAA,CAAA,EAAA,EAAK,IAAL,CAAf;AACA,UAAM,KAAK,GAAG,KAAK,QAAL,CAAc,IAAI,CAAC,KAAnB,KAA8B,EAA5C;AAEA,IAAA,MAAM,CAAC,MAAP,GAAgB,MAAM,CAAC,MAAP,IAAiB,KAAK,CAAC,MAAvC;AACA,IAAA,MAAM,CAAC,KAAP,GAAe,SAAS,CAAC,KAAV,CAAgB,EAAhB,EAAoB,KAAK,CAAC,KAA1B,EAAiC,MAAM,CAAC,KAAxC,CAAf;AACA,IAAA,MAAM,CAAC,QAAP,GAAkB,KAAK,cAAL,CAAoB,KAApB,EAA2B,MAA3B,CAAlB;AACA,IAAA,MAAM,CAAC,KAAP,GAAe,SAAS,CAAC,KAAV,CAAgB,EAAhB,EAAoB,KAAK,CAAC,KAA1B,EAAiC,KAAK,QAAL,CAAc,MAAd,CAAjC,CAAf;AACA,IAAA,MAAM,CAAC,MAAP,GAAgB,KAAK,SAAL,CAAe,KAAf,EAAsB,MAAtB,CAAhB;AACA,IAAA,MAAM,CAAC,IAAP,GAAc,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,MAAA,CAAA,EAAA,EAAK,KAAK,CAAC,IAAX,CAAA,EAAoB,MAAM,CAAC,IAA3B,CAAd;AAEA,WAAO,MAAP;AACD;;AAES,EAAA,SAAS,CACjB,KADiB,EAEjB,IAFiB,EAEa;AAE9B,QAAI,OAAO,IAAI,CAAC,MAAZ,KAAuB,QAA3B,EAAqC;AACnC,aAAO,IAAI,CAAC,MAAZ;AACD;;AAED,QAAI,OAAO,KAAK,CAAC,MAAb,KAAwB,QAAxB,IAAoC,KAAK,CAAC,MAAN,KAAiB,MAAzD,EAAiE;AAC/D,aAAO,KAAK,CAAC,MAAb;AACD;;AAED,WAAO,MAAP;AACD;;AAES,EAAA,cAAc,CACtB,KADsB,EAEtB,IAFsB,EAEQ;AAE9B,WAAO,SAAS,CAAC,KAAV,CACL;AACE,MAAA,IAAI,EAAE,MADR;AAEE,MAAA,IAAI,EAAE;AAFR,KADK,EAKL,KAAK,CAAC,QALD,EAML;AAAE,MAAA,IAAI,EAAE,IAAI,CAAC;AAAb,KANK,CAAP;AAQD;;AAES,EAAA,eAAe,CACvB,QADuB,EAEL;AAAA,QAAlB,UAAkB,uEAAL,KAAK;;AAElB,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,UAAI,UAAJ,EAAgB;AACd,eAAO;AAAE,UAAA,IAAI,EAAE,MAAR;AAAgB,UAAA,IAAI,EAAE;AAAtB,SAAP;AACD;AACF,KAJD,MAIO;AACL,UAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,eAAO;AACL,UAAA,IAAI,EAAE,QADD;AAEL,UAAA,IAAI,EAAE;AAFD,SAAP;AAID;;AAED,UAAI,KAAK,CAAC,OAAN,CAAc,QAAd,CAAJ,EAA6B;AAC3B,eAAO;AACL,UAAA,IAAI,EAAE,UADD;AAEL,UAAA,IAAI,EAAE;AAAE,YAAA,CAAC,EAAE,QAAQ,CAAC,CAAD,CAAb;AAAkB,YAAA,CAAC,EAAE,QAAQ,CAAC,CAAD;AAA7B;AAFD,SAAP;AAID;;AAED,UAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,eAAO,QAAP;AACD;AACF;;AAED,WAAO;AAAE,MAAA,IAAI,EAAE;AAAR,KAAP;AACD;;AAES,EAAA,oBAAoB,CAC5B,QAD4B,EAEV;AAAA,QAAlB,UAAkB,uEAAL,KAAK;;AAElB,QAAI,QAAQ,IAAI,IAAhB,EAAsB;AACpB,UAAI,UAAJ,EAAgB;AACd,eAAO;AAAE,UAAA,IAAI,EAAE,MAAR;AAAgB,UAAA,IAAI,EAAE;AAAtB,SAAP;AACD;AACF,KAJD,MAIO;AACL,UAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,eAAO;AACL,UAAA,IAAI,EAAE,QADD;AAEL,UAAA,IAAI,EAAE;AAFD,SAAP;AAID;;AAED,UAAI,OAAO,QAAP,KAAoB,QAAxB,EAAkC;AAChC,eAAO,QAAP;AACD;AACF;;AAED,WAAO;AAAE,MAAA,IAAI,EAAE;AAAR,KAAP;AACD;;AAES,EAAA,QAAQ,CAAC,IAAD,EAAqD;AAAA,QAAnB,WAAmB,uEAAL,KAAK;AACrE,UAAM,KAAK,GAAG,IAAI,CAAC,KAAL,IAAc,EAA5B;AACA,IAAA,KAAK,CAAC,QAAN,GAAiB,KAAK,oBAAL,CAA0B,KAAK,CAAC,QAAhC,EAA0C,WAA1C,CAAjB;AACA,WAAO,KAAP;AACD;;AAES,EAAA,kBAAkB,CAC1B,IAD0B,EAE1B,YAF0B,EAG1B,QAH0B,EAGP;AAEnB,UAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,QAAX,CAAoB,IAApB,IAA4B,MAAzC;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,KAAL,CAAW,QAAX,CAAoB,IAApB,IAA4B,EAAzC;AACA,UAAM,QAAQ,GACZ,eAAe,CAAC,QAAhB,CAAyB,GAAzB,CAA6B,IAA7B,KAAsC,eAAe,CAAC,OAAhB,CAAwB,IADhE;;AAEA,QAAI,QAAJ,EAAc;AACZ,aAAO,QAAQ,CAAC,YAAD,EAAe,QAAf,EAAyB,IAAzB,CAAf;AACD;;AAED,WAAO,IAAP;AACD;;AA9MqB","sourceRoot":"","sourcesContent":["import { PortLayout, PortLabelLayout } from '../registry';\nimport { ObjectExt } from '../util';\nimport { Point } from '../geometry';\nexport class PortManager {\n    constructor(data) {\n        this.ports = [];\n        this.groups = {};\n        this.init(ObjectExt.cloneDeep(data));\n    }\n    getPorts() {\n        return this.ports;\n    }\n    getGroup(groupName) {\n        return groupName != null ? this.groups[groupName] : null;\n    }\n    getPortsByGroup(groupName) {\n        return this.ports.filter((p) => p.group === groupName || (p.group == null && groupName == null));\n    }\n    getPortsLayoutByGroup(groupName, elemBBox) {\n        const ports = this.getPortsByGroup(groupName);\n        const group = groupName ? this.getGroup(groupName) : null;\n        const groupPosition = group ? group.position : null;\n        const groupPositionName = groupPosition ? groupPosition.name : null;\n        let layoutFn;\n        if (groupPositionName != null) {\n            const fn = PortLayout.registry.get(groupPositionName);\n            if (fn == null) {\n                return PortLayout.registry.onNotFound(groupPositionName);\n            }\n            layoutFn = fn;\n        }\n        else {\n            layoutFn = PortLayout.presets.left;\n        }\n        const portsArgs = ports.map((port) => (port && port.position && port.position.args) || {});\n        const groupArgs = (groupPosition && groupPosition.args) || {};\n        const layouts = layoutFn(portsArgs, elemBBox, groupArgs);\n        return layouts.map((portLayout, index) => {\n            const port = ports[index];\n            return {\n                portLayout,\n                portId: port.id,\n                portSize: port.size,\n                portAttrs: port.attrs,\n                labelSize: port.label.size,\n                labelLayout: this.getPortLabelLayout(port, Point.create(portLayout.position), elemBBox),\n            };\n        });\n    }\n    init(data) {\n        const { groups, items } = data;\n        if (groups != null) {\n            Object.keys(groups).forEach((key) => {\n                this.groups[key] = this.parseGroup(groups[key]);\n            });\n        }\n        if (Array.isArray(items)) {\n            items.forEach((item) => {\n                this.ports.push(this.parsePort(item));\n            });\n        }\n    }\n    parseGroup(group) {\n        return Object.assign(Object.assign({}, group), { label: this.getLabel(group, true), position: this.getPortPosition(group.position, true) });\n    }\n    parsePort(port) {\n        const result = Object.assign({}, port);\n        const group = this.getGroup(port.group) || {};\n        result.markup = result.markup || group.markup;\n        result.attrs = ObjectExt.merge({}, group.attrs, result.attrs);\n        result.position = this.createPosition(group, result);\n        result.label = ObjectExt.merge({}, group.label, this.getLabel(result));\n        result.zIndex = this.getZIndex(group, result);\n        result.size = Object.assign(Object.assign({}, group.size), result.size);\n        return result;\n    }\n    getZIndex(group, port) {\n        if (typeof port.zIndex === 'number') {\n            return port.zIndex;\n        }\n        if (typeof group.zIndex === 'number' || group.zIndex === 'auto') {\n            return group.zIndex;\n        }\n        return 'auto';\n    }\n    createPosition(group, port) {\n        return ObjectExt.merge({\n            name: 'left',\n            args: {},\n        }, group.position, { args: port.args });\n    }\n    getPortPosition(position, setDefault = false) {\n        if (position == null) {\n            if (setDefault) {\n                return { name: 'left', args: {} };\n            }\n        }\n        else {\n            if (typeof position === 'string') {\n                return {\n                    name: position,\n                    args: {},\n                };\n            }\n            if (Array.isArray(position)) {\n                return {\n                    name: 'absolute',\n                    args: { x: position[0], y: position[1] },\n                };\n            }\n            if (typeof position === 'object') {\n                return position;\n            }\n        }\n        return { args: {} };\n    }\n    getPortLabelPosition(position, setDefault = false) {\n        if (position == null) {\n            if (setDefault) {\n                return { name: 'left', args: {} };\n            }\n        }\n        else {\n            if (typeof position === 'string') {\n                return {\n                    name: position,\n                    args: {},\n                };\n            }\n            if (typeof position === 'object') {\n                return position;\n            }\n        }\n        return { args: {} };\n    }\n    getLabel(item, setDefaults = false) {\n        const label = item.label || {};\n        label.position = this.getPortLabelPosition(label.position, setDefaults);\n        return label;\n    }\n    getPortLabelLayout(port, portPosition, elemBBox) {\n        const name = port.label.position.name || 'left';\n        const args = port.label.position.args || {};\n        const layoutFn = PortLabelLayout.registry.get(name) || PortLabelLayout.presets.left;\n        if (layoutFn) {\n            return layoutFn(portPosition, elemBBox, args);\n        }\n        return null;\n    }\n}\n//# sourceMappingURL=port.js.map"]},"metadata":{},"sourceType":"module"}