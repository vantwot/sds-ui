{"ast":null,"code":"var __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nimport { Dom, FunctionExt } from '../util';\nimport { Rectangle } from '../geometry';\nimport { Cell } from '../model';\nimport { View, CellView } from '../view';\nimport { Base } from './base';\nexport class Renderer extends Base {\n  init() {\n    this.resetUpdates();\n    this.startListening(); // Renders existing cells in the model.\n\n    this.resetViews(this.model.getCells()); // Starts rendering loop.\n\n    if (!this.isFrozen() && this.isAsync()) {\n      this.updateViewsAsync();\n    }\n  }\n\n  startListening() {\n    this.model.on('sorted', this.onSortModel, this);\n    this.model.on('reseted', this.onModelReseted, this);\n    this.model.on('batch:stop', this.onBatchStop, this);\n    this.model.on('cell:added', this.onCellAdded, this);\n    this.model.on('cell:removed', this.onCellRemoved, this);\n    this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);\n    this.model.on('cell:change:visible', this.onCellVisibleChanged, this);\n  }\n\n  stopListening() {\n    this.model.off('sorted', this.onSortModel, this);\n    this.model.off('reseted', this.onModelReseted, this);\n    this.model.off('batch:stop', this.onBatchStop, this);\n    this.model.off('cell:added', this.onCellAdded, this);\n    this.model.off('cell:removed', this.onCellRemoved, this);\n    this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);\n    this.model.off('cell:change:visible', this.onCellVisibleChanged, this);\n  }\n\n  resetUpdates() {\n    this.updates = {\n      priorities: [{}, {}, {}],\n      mounted: {},\n      mountedCids: [],\n      unmounted: {},\n      unmountedCids: [],\n      count: 0,\n      sort: false,\n      frozen: false,\n      freezeKey: null,\n      animationId: null\n    };\n  }\n\n  onSortModel() {\n    if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {\n      return;\n    }\n\n    this.sortViews();\n  }\n\n  onModelReseted(_ref) {\n    let {\n      options\n    } = _ref;\n    this.removeZPivots();\n    this.resetViews(this.model.getCells(), options);\n  }\n\n  onBatchStop(_ref2) {\n    let {\n      name,\n      data\n    } = _ref2;\n\n    if (this.isFrozen()) {\n      return;\n    }\n\n    const model = this.model;\n\n    if (!this.isAsync()) {\n      const updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES;\n\n      if (updateDelayingBatches.includes(name) && !model.hasActiveBatch(updateDelayingBatches)) {\n        this.updateViews(data);\n      }\n    }\n\n    const sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES;\n\n    if (sortDelayingBatches.includes(name) && !model.hasActiveBatch(sortDelayingBatches)) {\n      this.sortViews();\n    }\n  }\n\n  onCellAdded(_ref3) {\n    let {\n      cell,\n      options\n    } = _ref3;\n    const position = options.position;\n\n    if (this.isAsync() || typeof position !== 'number') {\n      this.renderView(cell, options);\n    } else {\n      if (options.maxPosition === position) {\n        this.freeze({\n          key: 'addCells'\n        });\n      }\n\n      this.renderView(cell, options);\n\n      if (position === 0) {\n        this.unfreeze({\n          key: 'addCells'\n        });\n      }\n    }\n  }\n\n  onCellRemoved(_ref4) {\n    let {\n      cell,\n      options\n    } = _ref4;\n    const view = this.findViewByCell(cell);\n\n    if (view) {\n      this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options);\n    }\n  }\n\n  onCellZIndexChanged(_ref5) {\n    let {\n      cell,\n      options\n    } = _ref5;\n\n    if (this.options.sorting === 'approx') {\n      const view = this.findViewByCell(cell);\n\n      if (view) {\n        this.requestViewUpdate(view, Renderer.FLAG_INSERT, view.priority, options);\n      }\n    }\n  }\n\n  onCellVisibleChanged(_ref6) {\n    let {\n      cell,\n      current: visible,\n      options\n    } = _ref6;\n\n    // Hide connected edges before cell\n    if (!visible) {\n      this.processEdgeOnTerminalVisibleChanged(cell, false);\n    }\n\n    const view = this.findViewByCell(cell);\n\n    if (!visible && view) {\n      this.removeView(cell);\n    } else if (visible && view == null) {\n      this.renderView(cell, options);\n    } // Show connected edges after cell rendered\n\n\n    if (visible) {\n      this.processEdgeOnTerminalVisibleChanged(cell, true);\n    }\n  }\n\n  processEdgeOnTerminalVisibleChanged(node, visible) {\n    const getOpposite = (edge, currentTerminal) => {\n      const sourceId = edge.getSourceCellId();\n\n      if (sourceId !== currentTerminal.id) {\n        return edge.getSourceCell();\n      }\n\n      const targetId = edge.getTargetCellId();\n\n      if (targetId !== currentTerminal.id) {\n        return edge.getTargetCell();\n      }\n\n      return null;\n    };\n\n    this.model.getConnectedEdges(node).forEach(edge => {\n      const opposite = getOpposite(edge, node);\n\n      if (opposite == null || opposite.isVisible()) {\n        visible ? edge.show() : edge.hide();\n      }\n    });\n  }\n\n  isEdgeTerminalVisible(edge, terminal) {\n    const cellId = terminal === 'source' ? edge.getSourceCellId() : edge.getTargetCellId();\n    const cell = cellId ? this.model.getCell(cellId) : null;\n\n    if (cell && !cell.isVisible()) {\n      return false;\n    }\n\n    return true;\n  }\n\n  requestConnectedEdgesUpdate(view) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (CellView.isCellView(view)) {\n      const cell = view.cell;\n      const edges = this.model.getConnectedEdges(cell);\n\n      for (let j = 0, n = edges.length; j < n; j += 1) {\n        const edge = edges[j];\n        const edgeView = this.findViewByCell(edge);\n\n        if (!edgeView) {\n          continue;\n        }\n\n        const flagLabels = ['update'];\n\n        if (edge.getTargetCell() === cell) {\n          flagLabels.push('target');\n        }\n\n        if (edge.getSourceCell() === cell) {\n          flagLabels.push('source');\n        }\n\n        this.scheduleViewUpdate(edgeView, edgeView.getFlag(flagLabels), edgeView.priority, options);\n      }\n    }\n  }\n\n  forcePostponedViewUpdate(view, flag) {\n    if (!view || !CellView.isCellView(view)) {\n      return false;\n    }\n\n    const cell = view.cell;\n\n    if (cell.isNode()) {\n      return false;\n    }\n\n    const edgeView = view;\n\n    if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {\n      // EdgeView is waiting for the source/target cellView to be rendered.\n      // This can happen when the cells are not in the viewport.\n      let sourceFlag = 0;\n      const sourceView = this.findViewByCell(cell.getSourceCell());\n\n      if (sourceView && !this.isViewMounted(sourceView)) {\n        sourceFlag = this.dumpView(sourceView);\n        edgeView.updateTerminalMagnet('source');\n      }\n\n      let targetFlag = 0;\n      const targetView = this.findViewByCell(cell.getTargetCell());\n\n      if (targetView && !this.isViewMounted(targetView)) {\n        targetFlag = this.dumpView(targetView);\n        edgeView.updateTerminalMagnet('target');\n      }\n\n      if (sourceFlag === 0 && targetFlag === 0) {\n        // If leftover flag is 0, all view updates were done.\n        return !this.dumpView(edgeView);\n      }\n    }\n\n    return false;\n  }\n\n  scheduleViewUpdate(view, flag, priority) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    const cid = view.cid;\n    const updates = this.updates;\n    let cache = updates.priorities[priority];\n\n    if (!cache) {\n      cache = updates.priorities[priority] = {};\n    }\n\n    const currentFlag = cache[cid] || 0;\n\n    if ((currentFlag & flag) === flag) {\n      return;\n    }\n\n    if (!currentFlag) {\n      updates.count += 1;\n    }\n\n    if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {\n      // When a view is removed we need to remove the\n      // insert flag as this is a reinsert.\n      cache[cid] ^= Renderer.FLAG_INSERT;\n    } else if (flag & Renderer.FLAG_INSERT && currentFlag & Renderer.FLAG_REMOVE) {\n      // When a view is added we need to remove the remove\n      // flag as this is view was previously removed.\n      cache[cid] ^= Renderer.FLAG_REMOVE;\n    }\n\n    cache[cid] |= flag;\n    this.graph.hook.onViewUpdated(view, flag, options);\n  }\n\n  requestViewUpdate(view, flag, priority) {\n    let options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n    this.scheduleViewUpdate(view, flag, priority, options);\n    const isAsync = this.isAsync();\n\n    if (this.isFrozen() || isAsync && options.async !== false || this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)) {\n      return;\n    }\n\n    const stats = this.updateViews(options);\n\n    if (isAsync) {\n      this.graph.trigger('render:done', {\n        stats,\n        options\n      });\n    }\n  }\n  /**\n   * Adds view into the DOM and update it.\n   */\n\n\n  dumpView(view) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    if (view == null) {\n      return 0;\n    }\n\n    const cid = view.cid;\n    const updates = this.updates;\n    const cache = updates.priorities[view.priority];\n    const flag = this.registerMountedView(view) | cache[cid];\n    delete cache[cid];\n\n    if (!flag) {\n      return 0;\n    }\n\n    return this.updateView(view, flag, options);\n  }\n  /**\n   * Adds all views into the DOM and update them.\n   */\n\n\n  dumpViews() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.checkView(options);\n    this.updateViews(options);\n  }\n  /**\n   * Ensure the view associated with the cell is attached\n   * to the DOM and updated.\n   */\n\n\n  requireView(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const view = this.findViewByCell(cell);\n\n    if (view == null) {\n      return null;\n    }\n\n    this.dumpView(view, options);\n    return view;\n  }\n\n  updateView(view, flag) {\n    let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n    if (view == null) {\n      return 0;\n    }\n\n    if (CellView.isCellView(view)) {\n      if (flag & Renderer.FLAG_REMOVE) {\n        this.removeView(view.cell);\n        return 0;\n      }\n\n      if (flag & Renderer.FLAG_INSERT) {\n        this.insertView(view);\n        flag ^= Renderer.FLAG_INSERT; // eslint-disable-line\n      }\n    }\n\n    if (!flag) {\n      return 0;\n    }\n\n    return view.confirmUpdate(flag, options);\n  }\n\n  updateViews() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let result;\n    let batchCount = 0;\n    let updatedCount = 0;\n    let priority = Renderer.MIN_PRIORITY;\n\n    do {\n      result = this.updateViewsBatch(options);\n      batchCount += 1;\n      updatedCount += result.updatedCount;\n      priority = Math.min(result.priority, priority);\n    } while (!result.empty);\n\n    return {\n      priority,\n      batchCount,\n      updatedCount\n    };\n  }\n\n  updateViewsBatch() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const updates = this.updates;\n    const priorities = updates.priorities;\n    const batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE;\n    let empty = true;\n    let priority = Renderer.MIN_PRIORITY;\n    let mountedCount = 0;\n    let unmountedCount = 0;\n    let updatedCount = 0;\n    let postponedCount = 0;\n    let checkView = options.checkView || this.options.checkView;\n\n    if (typeof checkView !== 'function') {\n      checkView = null;\n    } // eslint-disable-next-line\n\n\n    main: for (let p = 0, n = priorities.length; p < n; p += 1) {\n      const cache = priorities[p]; // eslint-disable-next-line\n\n      for (const cid in cache) {\n        if (updatedCount >= batchSize) {\n          empty = false; // goto next batch\n\n          break main; // eslint-disable-line no-labels\n        }\n\n        const view = View.views[cid];\n\n        if (!view) {\n          delete cache[cid];\n          continue;\n        }\n\n        let currentFlag = cache[cid]; // Do not check a view for viewport if we are about to remove the view.\n\n        if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {\n          const isUnmounted = (cid in updates.unmounted);\n\n          if (checkView && !FunctionExt.call(checkView, this.graph, {\n            view: view,\n            unmounted: isUnmounted\n          })) {\n            // Unmount view\n            if (!isUnmounted) {\n              this.registerUnmountedView(view);\n              view.unmount();\n            }\n\n            updates.unmounted[cid] |= currentFlag;\n            delete cache[cid];\n            unmountedCount += 1;\n            continue;\n          } // Mount view\n\n\n          if (isUnmounted) {\n            currentFlag |= Renderer.FLAG_INSERT;\n            mountedCount += 1;\n          }\n\n          currentFlag |= this.registerMountedView(view);\n        }\n\n        const cellView = view;\n        let leftoverFlag = this.updateView(view, currentFlag, options);\n\n        if (leftoverFlag > 0) {\n          const cell = cellView.cell;\n\n          if (cell && cell.isEdge()) {\n            // remove edge view when source cell is invisible\n            if (cellView.hasAction(leftoverFlag, 'source') && !this.isEdgeTerminalVisible(cell, 'source')) {\n              leftoverFlag = cellView.removeAction(leftoverFlag, 'source');\n              leftoverFlag |= Renderer.FLAG_REMOVE;\n            } // remove edge view when target cell is invisible\n\n\n            if (cellView.hasAction(leftoverFlag, 'target') && !this.isEdgeTerminalVisible(cell, 'target')) {\n              leftoverFlag = cellView.removeAction(leftoverFlag, 'target');\n              leftoverFlag |= Renderer.FLAG_REMOVE;\n            }\n          }\n        }\n\n        if (leftoverFlag > 0) {\n          // update has not finished\n          cache[cid] = leftoverFlag;\n\n          if (!this.graph.hook.onViewPostponed(cellView, leftoverFlag, options) || cache[cid]) {\n            postponedCount += 1;\n            empty = false;\n            continue;\n          }\n        }\n\n        if (priority > p) {\n          priority = p;\n        }\n\n        updatedCount += 1;\n        delete cache[cid];\n      }\n    }\n\n    return {\n      empty,\n      priority,\n      mountedCount,\n      unmountedCount,\n      updatedCount,\n      postponedCount\n    };\n  }\n\n  updateViewsAsync() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      processed: 0,\n      priority: Renderer.MIN_PRIORITY\n    };\n    const updates = this.updates;\n    const animationId = updates.animationId;\n\n    if (animationId) {\n      Dom.cancelAnimationFrame(animationId);\n\n      if (data.processed === 0) {\n        const beforeFn = options.before;\n\n        if (typeof beforeFn === 'function') {\n          FunctionExt.call(beforeFn, this.graph, this.graph);\n        }\n      }\n\n      const stats = this.updateViewsBatch(options);\n      const checkout = this.checkViewImpl({\n        checkView: options.checkView,\n        mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,\n        unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount\n      });\n      let processed = data.processed;\n      const total = updates.count;\n      const mountedCount = checkout.mountedCount;\n      const unmountedCount = checkout.unmountedCount;\n\n      if (stats.updatedCount > 0) {\n        // Some updates have been just processed\n        processed += stats.updatedCount + stats.unmountedCount;\n        data.priority = Math.min(stats.priority, data.priority);\n\n        if (stats.empty && mountedCount === 0) {\n          stats.priority = data.priority;\n          stats.mountedCount += mountedCount;\n          stats.unmountedCount += unmountedCount;\n          this.graph.trigger('render:done', {\n            stats,\n            options\n          });\n          data.processed = 0;\n          updates.count = 0;\n        } else {\n          data.processed = processed;\n        }\n      } // Progress callback\n\n\n      const progressFn = options.progress;\n\n      if (total && typeof progressFn === 'function') {\n        FunctionExt.call(progressFn, this.graph, {\n          total,\n          done: stats.empty,\n          current: processed\n        });\n      } // The current frame could have been canceled in a callback\n\n\n      if (updates.animationId !== animationId) {\n        return;\n      }\n    }\n\n    updates.animationId = Dom.requestAnimationFrame(() => {\n      this.updateViewsAsync(options, data);\n    });\n  }\n\n  registerMountedView(view) {\n    const cid = view.cid;\n    const updates = this.updates;\n\n    if (cid in updates.mounted) {\n      return 0;\n    }\n\n    updates.mounted[cid] = true;\n    updates.mountedCids.push(cid);\n    const flag = updates.unmounted[cid] || 0;\n    delete updates.unmounted[cid];\n    return flag;\n  }\n\n  registerUnmountedView(view) {\n    const cid = view.cid;\n    const updates = this.updates;\n\n    if (cid in updates.unmounted) {\n      return 0;\n    }\n\n    updates.unmounted[cid] |= Renderer.FLAG_INSERT;\n    const flag = updates.unmounted[cid];\n    updates.unmountedCids.push(cid);\n    delete updates.mounted[cid];\n    return flag;\n  }\n\n  isViewMounted(view) {\n    if (view == null) {\n      return false;\n    }\n\n    const cid = view.cid;\n    return cid in this.updates.mounted;\n  }\n\n  getMountedViews() {\n    return Object.keys(this.updates.mounted).map(cid => CellView.views[cid]);\n  }\n\n  getUnmountedViews() {\n    return Object.keys(this.updates.unmounted).map(cid => CellView.views[cid]);\n  }\n\n  checkMountedViews(viewportFn, batchSize) {\n    let unmountCount = 0;\n\n    if (typeof viewportFn !== 'function') {\n      return unmountCount;\n    }\n\n    const updates = this.updates;\n    const mounted = updates.mounted;\n    const mountedCids = updates.mountedCids;\n    const size = batchSize == null ? mountedCids.length : Math.min(mountedCids.length, batchSize);\n\n    for (let i = 0; i < size; i += 1) {\n      const cid = mountedCids[i];\n\n      if (!(cid in mounted)) {\n        continue;\n      }\n\n      const view = CellView.views[cid];\n\n      if (view == null) {\n        continue;\n      }\n\n      const shouldMount = FunctionExt.call(viewportFn, this.graph, {\n        view: view,\n        unmounted: true\n      });\n\n      if (shouldMount) {\n        // Push at the end of all mounted ids\n        mountedCids.push(cid);\n        continue;\n      }\n\n      unmountCount += 1;\n      const flag = this.registerUnmountedView(view);\n\n      if (flag) {\n        view.unmount();\n      }\n    } // Get rid of views, that have been unmounted\n\n\n    mountedCids.splice(0, size);\n    return unmountCount;\n  }\n\n  checkUnmountedViews(checkView, batchSize) {\n    let mountCount = 0;\n\n    if (typeof checkView !== 'function') {\n      checkView = null; // eslint-disable-line\n    }\n\n    const updates = this.updates;\n    const unmounted = updates.unmounted;\n    const unmountedCids = updates.unmountedCids;\n    const size = batchSize == null ? unmountedCids.length : Math.min(unmountedCids.length, batchSize);\n\n    for (let i = 0; i < size; i += 1) {\n      const cid = unmountedCids[i];\n\n      if (!(cid in unmounted)) {\n        continue;\n      }\n\n      const view = CellView.views[cid];\n\n      if (view == null) {\n        continue;\n      }\n\n      if (checkView && !FunctionExt.call(checkView, this.graph, {\n        view,\n        unmounted: false\n      })) {\n        unmountedCids.push(cid);\n        continue;\n      }\n\n      mountCount += 1;\n      const flag = this.registerMountedView(view);\n\n      if (flag) {\n        this.scheduleViewUpdate(view, flag, view.priority, {\n          mounting: true\n        });\n      }\n    } // Get rid of views, that have been mounted\n\n\n    unmountedCids.splice(0, size);\n    return mountCount;\n  }\n\n  checkViewImpl() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      mountedBatchSize: Number.MAX_SAFE_INTEGER,\n      unmountedBatchSize: Number.MAX_SAFE_INTEGER\n    };\n    const checkView = options.checkView || this.options.checkView;\n    const unmountedCount = this.checkMountedViews(checkView, options.unmountedBatchSize);\n    const mountedCount = this.checkUnmountedViews(checkView, // Do not check views, that have been just unmounted\n    // and pushed at the end of the cids array\n    unmountedCount > 0 ? Math.min(this.updates.unmountedCids.length - unmountedCount, options.mountedBatchSize) : options.mountedBatchSize);\n    return {\n      mountedCount,\n      unmountedCount\n    };\n  }\n  /**\n   * Determine every view in the graph should be attached/detached.\n   */\n\n\n  checkView() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return this.checkViewImpl(options);\n  }\n\n  isFrozen() {\n    return !!this.options.frozen;\n  }\n  /**\n   * Freeze the graph then the graph does not automatically re-render upon\n   * changes in the graph. This is useful when adding large numbers of cells.\n   */\n\n\n  freeze() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const key = options.key;\n    const updates = this.updates;\n    const frozen = this.options.frozen;\n    const freezeKey = updates.freezeKey;\n\n    if (key && key !== freezeKey) {\n      if (frozen && freezeKey) {\n        // key passed, but the graph is already freezed with another key\n        return;\n      }\n\n      updates.frozen = frozen;\n      updates.freezeKey = key;\n    }\n\n    this.options.frozen = true;\n    const animationId = updates.animationId;\n    updates.animationId = null;\n\n    if (this.isAsync() && animationId != null) {\n      Dom.cancelAnimationFrame(animationId);\n    }\n\n    this.graph.trigger('freeze', {\n      key\n    });\n  }\n\n  unfreeze() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const key = options.key;\n    const updates = this.updates;\n    const freezeKey = updates.freezeKey; // key passed, but the graph is already freezed with another key\n\n    if (key && freezeKey && key !== freezeKey) {\n      return;\n    }\n\n    updates.freezeKey = null; // key passed, but the graph is already freezed\n\n    if (key && key === freezeKey && updates.frozen) {\n      return;\n    }\n\n    const callback = () => {\n      this.options.frozen = updates.frozen = false;\n\n      if (updates.sort) {\n        this.sortViews();\n        updates.sort = false;\n      }\n\n      const afterFn = options.after;\n\n      if (afterFn) {\n        FunctionExt.call(afterFn, this.graph, this.graph);\n      }\n\n      this.graph.trigger('unfreeze', {\n        key\n      });\n    };\n\n    if (this.isAsync()) {\n      this.freeze();\n      const onProgress = options.progress;\n      this.updateViewsAsync(Object.assign(Object.assign({}, options), {\n        progress: _ref7 => {\n          let {\n            done,\n            current,\n            total\n          } = _ref7;\n\n          if (onProgress) {\n            FunctionExt.call(onProgress, this.graph, {\n              done,\n              current,\n              total\n            });\n          } // sort views after async render\n\n\n          if (done) {\n            callback();\n          }\n        }\n      }));\n    } else {\n      this.updateViews(options);\n      callback();\n    }\n  }\n\n  isAsync() {\n    return !!this.options.async;\n  }\n\n  setAsync(async) {\n    this.options.async = async;\n  }\n\n  onRemove() {\n    this.freeze();\n    this.removeViews();\n  }\n\n  resetViews() {\n    let cells = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.resetUpdates();\n    this.removeViews();\n    this.freeze({\n      key: 'reset'\n    });\n\n    for (let i = 0, n = cells.length; i < n; i += 1) {\n      this.renderView(cells[i], options);\n    }\n\n    this.unfreeze({\n      key: 'reset'\n    });\n    this.sortViews();\n  }\n\n  removeView(cell) {\n    const view = this.views[cell.id];\n\n    if (view) {\n      const cid = view.cid;\n      const updates = this.updates;\n      const mounted = updates.mounted;\n      const unmounted = updates.unmounted;\n      view.remove();\n      delete this.views[cell.id];\n      delete mounted[cid];\n      delete unmounted[cid];\n    }\n\n    return view;\n  }\n\n  removeViews() {\n    if (this.views) {\n      Object.keys(this.views).forEach(id => {\n        const view = this.views[id];\n\n        if (view) {\n          this.removeView(view.cell);\n        }\n      });\n    }\n\n    this.views = {};\n  }\n\n  renderView(cell) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const id = cell.id;\n    const views = this.views;\n    let flag = 0;\n    let view = views[id];\n\n    if (!cell.isVisible()) {\n      return;\n    }\n\n    if (cell.isEdge()) {\n      if (!this.isEdgeTerminalVisible(cell, 'source') || !this.isEdgeTerminalVisible(cell, 'target')) {\n        return;\n      }\n    }\n\n    if (view) {\n      flag = Renderer.FLAG_INSERT;\n    } else {\n      const tmp = this.graph.hook.createCellView(cell);\n\n      if (tmp) {\n        view = views[cell.id] = tmp;\n        view.graph = this.graph;\n        flag = this.registerUnmountedView(view) | view.getBootstrapFlag();\n      }\n    }\n\n    if (view) {\n      this.requestViewUpdate(view, flag, view.priority, options);\n    }\n  }\n\n  isExactSorting() {\n    return this.options.sorting === 'exact';\n  }\n\n  sortViews() {\n    if (!this.isExactSorting()) {\n      return;\n    }\n\n    if (this.isFrozen()) {\n      // sort views once unfrozen\n      this.updates.sort = true;\n      return;\n    }\n\n    this.sortViewsExact();\n  }\n\n  sortElements(elems, comparator) {\n    // Highly inspired by the jquery.sortElements plugin by Padolsey.\n    // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n    const placements = elems.map(elem => {\n      const parentNode = elem.parentNode; // Since the element itself will change position, we have\n      // to have some way of storing it's original position in\n      // the DOM. The easiest way is to have a 'flag' node:\n\n      const nextSibling = parentNode.insertBefore(document.createTextNode(''), elem.nextSibling);\n      return targetNode => {\n        if (parentNode === targetNode) {\n          throw new Error(\"You can't sort elements if any one is a descendant of another.\");\n        } // Insert before flag\n\n\n        parentNode.insertBefore(targetNode, nextSibling); // Remove flag\n\n        parentNode.removeChild(nextSibling);\n      };\n    });\n    elems.sort(comparator).forEach((elem, index) => placements[index](elem));\n  }\n\n  sortViewsExact() {\n    // const elems = this.view.stage.querySelectorAll('[data-cell-id]')\n    // const length = elems.length\n    // const cells = []\n    // for (let i = 0; i < length; i++) {\n    //   const cell = this.model.getCell(elems[i].getAttribute('data-cell-id') || '')\n    //   cells.push({\n    //     id: cell.id,\n    //     zIndex: cell.getZIndex() || 0,\n    //     elem: elems[i],\n    //   })\n    // }\n    // const sortedCells = [...cells].sort((cell1, cell2) => cell1.zIndex - cell2.zIndex)\n    // const moves = ArrayExt.diff(cells, sortedCells, 'zIndex').moves\n    // if (moves && moves.length) {\n    //   moves.forEach((move) => {\n    //     if (move.type) {\n    //       const elem = move.item.elem as Element\n    //       const parentNode = elem.parentNode\n    //       const index = move.index\n    //       if (parentNode) {\n    //         if (index === length - 1) {\n    //           parentNode.appendChild(elem)\n    //         } else if (index < length - 1) {\n    //           parentNode.insertBefore(elem, elems[index + 1])\n    //         }\n    //       }\n    //     }\n    //   })\n    // }\n    // Run insertion sort algorithm in order to efficiently sort DOM\n    // elements according to their associated cell `zIndex` attribute.\n    const elems = this.view.$(this.view.stage).children('[data-cell-id]').toArray();\n    const model = this.model;\n    this.sortElements(elems, (a, b) => {\n      const cellA = model.getCell(a.getAttribute('data-cell-id') || '');\n      const cellB = model.getCell(b.getAttribute('data-cell-id') || '');\n      const z1 = cellA.getZIndex() || 0;\n      const z2 = cellB.getZIndex() || 0;\n      return z1 === z2 ? 0 : z1 < z2 ? -1 : 1;\n    });\n  }\n\n  addZPivot() {\n    let zIndex = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n    if (this.zPivots == null) {\n      this.zPivots = {};\n    }\n\n    const pivots = this.zPivots;\n    let pivot = pivots[zIndex];\n\n    if (pivot) {\n      return pivot;\n    }\n\n    pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);\n    let neighborZ = -Infinity; // eslint-disable-next-line\n\n    for (const key in pivots) {\n      const currentZ = +key;\n\n      if (currentZ < zIndex && currentZ > neighborZ) {\n        neighborZ = currentZ;\n\n        if (neighborZ === zIndex - 1) {\n          continue;\n        }\n      }\n    }\n\n    const layer = this.view.stage;\n\n    if (neighborZ !== -Infinity) {\n      const neighborPivot = pivots[neighborZ];\n      layer.insertBefore(pivot, neighborPivot.nextSibling);\n    } else {\n      layer.insertBefore(pivot, layer.firstChild);\n    }\n\n    return pivot;\n  }\n\n  removeZPivots() {\n    if (this.zPivots) {\n      Object.keys(this.zPivots).forEach(z => {\n        const elem = this.zPivots[z];\n\n        if (elem && elem.parentNode) {\n          elem.parentNode.removeChild(elem);\n        }\n      });\n    }\n\n    this.zPivots = {};\n  }\n\n  insertView(view) {\n    const stage = this.view.stage;\n\n    switch (this.options.sorting) {\n      case 'approx':\n        {\n          const zIndex = view.cell.getZIndex();\n          const pivot = this.addZPivot(zIndex);\n          stage.insertBefore(view.container, pivot);\n          break;\n        }\n\n      case 'exact':\n      default:\n        stage.appendChild(view.container);\n        break;\n    }\n  }\n\n  findViewByCell(cell) {\n    if (cell == null) {\n      return null;\n    }\n\n    const id = Cell.isCell(cell) ? cell.id : cell;\n    return this.views[id];\n  }\n\n  findViewByElem(elem) {\n    if (elem == null) {\n      return null;\n    }\n\n    const target = typeof elem === 'string' ? this.view.stage.querySelector(elem) : elem instanceof Element ? elem : elem[0];\n\n    if (target) {\n      const id = this.view.findAttr('data-cell-id', target);\n\n      if (id) {\n        return this.views[id];\n      }\n    }\n\n    return null;\n  }\n\n  findViewsFromPoint(p) {\n    const ref = {\n      x: p.x,\n      y: p.y\n    };\n    return this.model.getCells().map(cell => this.findViewByCell(cell)).filter(view => {\n      if (view != null) {\n        return Dom.getBBox(view.container, {\n          target: this.view.stage\n        }).containsPoint(ref);\n      }\n\n      return false;\n    });\n  }\n\n  findEdgeViewsInArea(rect) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const area = Rectangle.create(rect);\n    return this.model.getEdges().map(edge => this.findViewByCell(edge)).filter(view => {\n      if (view) {\n        const bbox = Dom.getBBox(view.container, {\n          target: this.view.stage\n        });\n\n        if (bbox.width === 0) {\n          bbox.inflate(1, 0);\n        } else if (bbox.height === 0) {\n          bbox.inflate(0, 1);\n        }\n\n        return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n      }\n\n      return false;\n    });\n  }\n\n  findViewsInArea(rect) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    const area = Rectangle.create(rect);\n    return this.model.getNodes().map(node => this.findViewByCell(node)).filter(view => {\n      if (view) {\n        const bbox = Dom.getBBox(view.container, {\n          target: this.view.stage\n        });\n        return options.strict ? area.containsRect(bbox) : area.isIntersectWithRect(bbox);\n      }\n\n      return false;\n    });\n  }\n\n  dispose() {\n    this.resetUpdates();\n    this.stopListening();\n  }\n\n}\n\n__decorate([Base.dispose()], Renderer.prototype, \"dispose\", null);\n\n(function (Renderer) {\n  Renderer.FLAG_INSERT = 1 << 30;\n  Renderer.FLAG_REMOVE = 1 << 29;\n  Renderer.MOUNT_BATCH_SIZE = 1000;\n  Renderer.UPDATE_BATCH_SIZE = 1000;\n  Renderer.MIN_PRIORITY = 2;\n  Renderer.SORT_DELAYING_BATCHES = ['add', 'to-front', 'to-back'];\n  Renderer.UPDATE_DELAYING_BATCHES = ['translate'];\n})(Renderer || (Renderer = {}));","map":{"version":3,"sources":["../../src/graph/renderer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nimport { Dom, FunctionExt } from '../util';\nimport { Rectangle } from '../geometry';\nimport { Cell } from '../model';\nimport { View, CellView } from '../view';\nimport { Base } from './base';\nexport class Renderer extends Base {\n    init() {\n        this.resetUpdates();\n        this.startListening();\n        // Renders existing cells in the model.\n        this.resetViews(this.model.getCells());\n        // Starts rendering loop.\n        if (!this.isFrozen() && this.isAsync()) {\n            this.updateViewsAsync();\n        }\n    }\n    startListening() {\n        this.model.on('sorted', this.onSortModel, this);\n        this.model.on('reseted', this.onModelReseted, this);\n        this.model.on('batch:stop', this.onBatchStop, this);\n        this.model.on('cell:added', this.onCellAdded, this);\n        this.model.on('cell:removed', this.onCellRemoved, this);\n        this.model.on('cell:change:zIndex', this.onCellZIndexChanged, this);\n        this.model.on('cell:change:visible', this.onCellVisibleChanged, this);\n    }\n    stopListening() {\n        this.model.off('sorted', this.onSortModel, this);\n        this.model.off('reseted', this.onModelReseted, this);\n        this.model.off('batch:stop', this.onBatchStop, this);\n        this.model.off('cell:added', this.onCellAdded, this);\n        this.model.off('cell:removed', this.onCellRemoved, this);\n        this.model.off('cell:change:zIndex', this.onCellZIndexChanged, this);\n        this.model.off('cell:change:visible', this.onCellVisibleChanged, this);\n    }\n    resetUpdates() {\n        this.updates = {\n            priorities: [{}, {}, {}],\n            mounted: {},\n            mountedCids: [],\n            unmounted: {},\n            unmountedCids: [],\n            count: 0,\n            sort: false,\n            frozen: false,\n            freezeKey: null,\n            animationId: null,\n        };\n    }\n    onSortModel() {\n        if (this.model.hasActiveBatch(Renderer.SORT_DELAYING_BATCHES)) {\n            return;\n        }\n        this.sortViews();\n    }\n    onModelReseted({ options }) {\n        this.removeZPivots();\n        this.resetViews(this.model.getCells(), options);\n    }\n    onBatchStop({ name, data }) {\n        if (this.isFrozen()) {\n            return;\n        }\n        const model = this.model;\n        if (!this.isAsync()) {\n            const updateDelayingBatches = Renderer.UPDATE_DELAYING_BATCHES;\n            if (updateDelayingBatches.includes(name) &&\n                !model.hasActiveBatch(updateDelayingBatches)) {\n                this.updateViews(data);\n            }\n        }\n        const sortDelayingBatches = Renderer.SORT_DELAYING_BATCHES;\n        if (sortDelayingBatches.includes(name) &&\n            !model.hasActiveBatch(sortDelayingBatches)) {\n            this.sortViews();\n        }\n    }\n    onCellAdded({ cell, options }) {\n        const position = options.position;\n        if (this.isAsync() || typeof position !== 'number') {\n            this.renderView(cell, options);\n        }\n        else {\n            if (options.maxPosition === position) {\n                this.freeze({ key: 'addCells' });\n            }\n            this.renderView(cell, options);\n            if (position === 0) {\n                this.unfreeze({ key: 'addCells' });\n            }\n        }\n    }\n    onCellRemoved({ cell, options }) {\n        const view = this.findViewByCell(cell);\n        if (view) {\n            this.requestViewUpdate(view, Renderer.FLAG_REMOVE, view.priority, options);\n        }\n    }\n    onCellZIndexChanged({ cell, options, }) {\n        if (this.options.sorting === 'approx') {\n            const view = this.findViewByCell(cell);\n            if (view) {\n                this.requestViewUpdate(view, Renderer.FLAG_INSERT, view.priority, options);\n            }\n        }\n    }\n    onCellVisibleChanged({ cell, current: visible, options, }) {\n        // Hide connected edges before cell\n        if (!visible) {\n            this.processEdgeOnTerminalVisibleChanged(cell, false);\n        }\n        const view = this.findViewByCell(cell);\n        if (!visible && view) {\n            this.removeView(cell);\n        }\n        else if (visible && view == null) {\n            this.renderView(cell, options);\n        }\n        // Show connected edges after cell rendered\n        if (visible) {\n            this.processEdgeOnTerminalVisibleChanged(cell, true);\n        }\n    }\n    processEdgeOnTerminalVisibleChanged(node, visible) {\n        const getOpposite = (edge, currentTerminal) => {\n            const sourceId = edge.getSourceCellId();\n            if (sourceId !== currentTerminal.id) {\n                return edge.getSourceCell();\n            }\n            const targetId = edge.getTargetCellId();\n            if (targetId !== currentTerminal.id) {\n                return edge.getTargetCell();\n            }\n            return null;\n        };\n        this.model.getConnectedEdges(node).forEach((edge) => {\n            const opposite = getOpposite(edge, node);\n            if (opposite == null || opposite.isVisible()) {\n                visible ? edge.show() : edge.hide();\n            }\n        });\n    }\n    isEdgeTerminalVisible(edge, terminal) {\n        const cellId = terminal === 'source' ? edge.getSourceCellId() : edge.getTargetCellId();\n        const cell = cellId ? this.model.getCell(cellId) : null;\n        if (cell && !cell.isVisible()) {\n            return false;\n        }\n        return true;\n    }\n    requestConnectedEdgesUpdate(view, options = {}) {\n        if (CellView.isCellView(view)) {\n            const cell = view.cell;\n            const edges = this.model.getConnectedEdges(cell);\n            for (let j = 0, n = edges.length; j < n; j += 1) {\n                const edge = edges[j];\n                const edgeView = this.findViewByCell(edge);\n                if (!edgeView) {\n                    continue;\n                }\n                const flagLabels = ['update'];\n                if (edge.getTargetCell() === cell) {\n                    flagLabels.push('target');\n                }\n                if (edge.getSourceCell() === cell) {\n                    flagLabels.push('source');\n                }\n                this.scheduleViewUpdate(edgeView, edgeView.getFlag(flagLabels), edgeView.priority, options);\n            }\n        }\n    }\n    forcePostponedViewUpdate(view, flag) {\n        if (!view || !CellView.isCellView(view)) {\n            return false;\n        }\n        const cell = view.cell;\n        if (cell.isNode()) {\n            return false;\n        }\n        const edgeView = view;\n        if (cell.isEdge() && (flag & view.getFlag(['source', 'target'])) === 0) {\n            // EdgeView is waiting for the source/target cellView to be rendered.\n            // This can happen when the cells are not in the viewport.\n            let sourceFlag = 0;\n            const sourceView = this.findViewByCell(cell.getSourceCell());\n            if (sourceView && !this.isViewMounted(sourceView)) {\n                sourceFlag = this.dumpView(sourceView);\n                edgeView.updateTerminalMagnet('source');\n            }\n            let targetFlag = 0;\n            const targetView = this.findViewByCell(cell.getTargetCell());\n            if (targetView && !this.isViewMounted(targetView)) {\n                targetFlag = this.dumpView(targetView);\n                edgeView.updateTerminalMagnet('target');\n            }\n            if (sourceFlag === 0 && targetFlag === 0) {\n                // If leftover flag is 0, all view updates were done.\n                return !this.dumpView(edgeView);\n            }\n        }\n        return false;\n    }\n    scheduleViewUpdate(view, flag, priority, options = {}) {\n        const cid = view.cid;\n        const updates = this.updates;\n        let cache = updates.priorities[priority];\n        if (!cache) {\n            cache = updates.priorities[priority] = {};\n        }\n        const currentFlag = cache[cid] || 0;\n        if ((currentFlag & flag) === flag) {\n            return;\n        }\n        if (!currentFlag) {\n            updates.count += 1;\n        }\n        if (flag & Renderer.FLAG_REMOVE && currentFlag & Renderer.FLAG_INSERT) {\n            // When a view is removed we need to remove the\n            // insert flag as this is a reinsert.\n            cache[cid] ^= Renderer.FLAG_INSERT;\n        }\n        else if (flag & Renderer.FLAG_INSERT &&\n            currentFlag & Renderer.FLAG_REMOVE) {\n            // When a view is added we need to remove the remove\n            // flag as this is view was previously removed.\n            cache[cid] ^= Renderer.FLAG_REMOVE;\n        }\n        cache[cid] |= flag;\n        this.graph.hook.onViewUpdated(view, flag, options);\n    }\n    requestViewUpdate(view, flag, priority, options = {}) {\n        this.scheduleViewUpdate(view, flag, priority, options);\n        const isAsync = this.isAsync();\n        if (this.isFrozen() ||\n            (isAsync && options.async !== false) ||\n            this.model.hasActiveBatch(Renderer.UPDATE_DELAYING_BATCHES)) {\n            return;\n        }\n        const stats = this.updateViews(options);\n        if (isAsync) {\n            this.graph.trigger('render:done', { stats, options });\n        }\n    }\n    /**\n     * Adds view into the DOM and update it.\n     */\n    dumpView(view, options = {}) {\n        if (view == null) {\n            return 0;\n        }\n        const cid = view.cid;\n        const updates = this.updates;\n        const cache = updates.priorities[view.priority];\n        const flag = this.registerMountedView(view) | cache[cid];\n        delete cache[cid];\n        if (!flag) {\n            return 0;\n        }\n        return this.updateView(view, flag, options);\n    }\n    /**\n     * Adds all views into the DOM and update them.\n     */\n    dumpViews(options = {}) {\n        this.checkView(options);\n        this.updateViews(options);\n    }\n    /**\n     * Ensure the view associated with the cell is attached\n     * to the DOM and updated.\n     */\n    requireView(cell, options = {}) {\n        const view = this.findViewByCell(cell);\n        if (view == null) {\n            return null;\n        }\n        this.dumpView(view, options);\n        return view;\n    }\n    updateView(view, flag, options = {}) {\n        if (view == null) {\n            return 0;\n        }\n        if (CellView.isCellView(view)) {\n            if (flag & Renderer.FLAG_REMOVE) {\n                this.removeView(view.cell);\n                return 0;\n            }\n            if (flag & Renderer.FLAG_INSERT) {\n                this.insertView(view);\n                flag ^= Renderer.FLAG_INSERT; // eslint-disable-line\n            }\n        }\n        if (!flag) {\n            return 0;\n        }\n        return view.confirmUpdate(flag, options);\n    }\n    updateViews(options = {}) {\n        let result;\n        let batchCount = 0;\n        let updatedCount = 0;\n        let priority = Renderer.MIN_PRIORITY;\n        do {\n            result = this.updateViewsBatch(options);\n            batchCount += 1;\n            updatedCount += result.updatedCount;\n            priority = Math.min(result.priority, priority);\n        } while (!result.empty);\n        return {\n            priority,\n            batchCount,\n            updatedCount,\n        };\n    }\n    updateViewsBatch(options = {}) {\n        const updates = this.updates;\n        const priorities = updates.priorities;\n        const batchSize = options.batchSize || Renderer.UPDATE_BATCH_SIZE;\n        let empty = true;\n        let priority = Renderer.MIN_PRIORITY;\n        let mountedCount = 0;\n        let unmountedCount = 0;\n        let updatedCount = 0;\n        let postponedCount = 0;\n        let checkView = options.checkView || this.options.checkView;\n        if (typeof checkView !== 'function') {\n            checkView = null;\n        }\n        // eslint-disable-next-line\n        main: for (let p = 0, n = priorities.length; p < n; p += 1) {\n            const cache = priorities[p];\n            // eslint-disable-next-line\n            for (const cid in cache) {\n                if (updatedCount >= batchSize) {\n                    empty = false; // goto next batch\n                    break main; // eslint-disable-line no-labels\n                }\n                const view = View.views[cid];\n                if (!view) {\n                    delete cache[cid];\n                    continue;\n                }\n                let currentFlag = cache[cid];\n                // Do not check a view for viewport if we are about to remove the view.\n                if ((currentFlag & Renderer.FLAG_REMOVE) === 0) {\n                    const isUnmounted = cid in updates.unmounted;\n                    if (checkView &&\n                        !FunctionExt.call(checkView, this.graph, {\n                            view: view,\n                            unmounted: isUnmounted,\n                        })) {\n                        // Unmount view\n                        if (!isUnmounted) {\n                            this.registerUnmountedView(view);\n                            view.unmount();\n                        }\n                        updates.unmounted[cid] |= currentFlag;\n                        delete cache[cid];\n                        unmountedCount += 1;\n                        continue;\n                    }\n                    // Mount view\n                    if (isUnmounted) {\n                        currentFlag |= Renderer.FLAG_INSERT;\n                        mountedCount += 1;\n                    }\n                    currentFlag |= this.registerMountedView(view);\n                }\n                const cellView = view;\n                let leftoverFlag = this.updateView(view, currentFlag, options);\n                if (leftoverFlag > 0) {\n                    const cell = cellView.cell;\n                    if (cell && cell.isEdge()) {\n                        // remove edge view when source cell is invisible\n                        if (cellView.hasAction(leftoverFlag, 'source') &&\n                            !this.isEdgeTerminalVisible(cell, 'source')) {\n                            leftoverFlag = cellView.removeAction(leftoverFlag, 'source');\n                            leftoverFlag |= Renderer.FLAG_REMOVE;\n                        }\n                        // remove edge view when target cell is invisible\n                        if (cellView.hasAction(leftoverFlag, 'target') &&\n                            !this.isEdgeTerminalVisible(cell, 'target')) {\n                            leftoverFlag = cellView.removeAction(leftoverFlag, 'target');\n                            leftoverFlag |= Renderer.FLAG_REMOVE;\n                        }\n                    }\n                }\n                if (leftoverFlag > 0) {\n                    // update has not finished\n                    cache[cid] = leftoverFlag;\n                    if (!this.graph.hook.onViewPostponed(cellView, leftoverFlag, options) ||\n                        cache[cid]) {\n                        postponedCount += 1;\n                        empty = false;\n                        continue;\n                    }\n                }\n                if (priority > p) {\n                    priority = p;\n                }\n                updatedCount += 1;\n                delete cache[cid];\n            }\n        }\n        return {\n            empty,\n            priority,\n            mountedCount,\n            unmountedCount,\n            updatedCount,\n            postponedCount,\n        };\n    }\n    updateViewsAsync(options = {}, data = {\n        processed: 0,\n        priority: Renderer.MIN_PRIORITY,\n    }) {\n        const updates = this.updates;\n        const animationId = updates.animationId;\n        if (animationId) {\n            Dom.cancelAnimationFrame(animationId);\n            if (data.processed === 0) {\n                const beforeFn = options.before;\n                if (typeof beforeFn === 'function') {\n                    FunctionExt.call(beforeFn, this.graph, this.graph);\n                }\n            }\n            const stats = this.updateViewsBatch(options);\n            const checkout = this.checkViewImpl({\n                checkView: options.checkView,\n                mountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.mountedCount,\n                unmountedBatchSize: Renderer.MOUNT_BATCH_SIZE - stats.unmountedCount,\n            });\n            let processed = data.processed;\n            const total = updates.count;\n            const mountedCount = checkout.mountedCount;\n            const unmountedCount = checkout.unmountedCount;\n            if (stats.updatedCount > 0) {\n                // Some updates have been just processed\n                processed += stats.updatedCount + stats.unmountedCount;\n                data.priority = Math.min(stats.priority, data.priority);\n                if (stats.empty && mountedCount === 0) {\n                    stats.priority = data.priority;\n                    stats.mountedCount += mountedCount;\n                    stats.unmountedCount += unmountedCount;\n                    this.graph.trigger('render:done', { stats, options });\n                    data.processed = 0;\n                    updates.count = 0;\n                }\n                else {\n                    data.processed = processed;\n                }\n            }\n            // Progress callback\n            const progressFn = options.progress;\n            if (total && typeof progressFn === 'function') {\n                FunctionExt.call(progressFn, this.graph, {\n                    total,\n                    done: stats.empty,\n                    current: processed,\n                });\n            }\n            // The current frame could have been canceled in a callback\n            if (updates.animationId !== animationId) {\n                return;\n            }\n        }\n        updates.animationId = Dom.requestAnimationFrame(() => {\n            this.updateViewsAsync(options, data);\n        });\n    }\n    registerMountedView(view) {\n        const cid = view.cid;\n        const updates = this.updates;\n        if (cid in updates.mounted) {\n            return 0;\n        }\n        updates.mounted[cid] = true;\n        updates.mountedCids.push(cid);\n        const flag = updates.unmounted[cid] || 0;\n        delete updates.unmounted[cid];\n        return flag;\n    }\n    registerUnmountedView(view) {\n        const cid = view.cid;\n        const updates = this.updates;\n        if (cid in updates.unmounted) {\n            return 0;\n        }\n        updates.unmounted[cid] |= Renderer.FLAG_INSERT;\n        const flag = updates.unmounted[cid];\n        updates.unmountedCids.push(cid);\n        delete updates.mounted[cid];\n        return flag;\n    }\n    isViewMounted(view) {\n        if (view == null) {\n            return false;\n        }\n        const cid = view.cid;\n        return cid in this.updates.mounted;\n    }\n    getMountedViews() {\n        return Object.keys(this.updates.mounted).map((cid) => CellView.views[cid]);\n    }\n    getUnmountedViews() {\n        return Object.keys(this.updates.unmounted).map((cid) => CellView.views[cid]);\n    }\n    checkMountedViews(viewportFn, batchSize) {\n        let unmountCount = 0;\n        if (typeof viewportFn !== 'function') {\n            return unmountCount;\n        }\n        const updates = this.updates;\n        const mounted = updates.mounted;\n        const mountedCids = updates.mountedCids;\n        const size = batchSize == null\n            ? mountedCids.length\n            : Math.min(mountedCids.length, batchSize);\n        for (let i = 0; i < size; i += 1) {\n            const cid = mountedCids[i];\n            if (!(cid in mounted)) {\n                continue;\n            }\n            const view = CellView.views[cid];\n            if (view == null) {\n                continue;\n            }\n            const shouldMount = FunctionExt.call(viewportFn, this.graph, {\n                view: view,\n                unmounted: true,\n            });\n            if (shouldMount) {\n                // Push at the end of all mounted ids\n                mountedCids.push(cid);\n                continue;\n            }\n            unmountCount += 1;\n            const flag = this.registerUnmountedView(view);\n            if (flag) {\n                view.unmount();\n            }\n        }\n        // Get rid of views, that have been unmounted\n        mountedCids.splice(0, size);\n        return unmountCount;\n    }\n    checkUnmountedViews(checkView, batchSize) {\n        let mountCount = 0;\n        if (typeof checkView !== 'function') {\n            checkView = null; // eslint-disable-line\n        }\n        const updates = this.updates;\n        const unmounted = updates.unmounted;\n        const unmountedCids = updates.unmountedCids;\n        const size = batchSize == null\n            ? unmountedCids.length\n            : Math.min(unmountedCids.length, batchSize);\n        for (let i = 0; i < size; i += 1) {\n            const cid = unmountedCids[i];\n            if (!(cid in unmounted)) {\n                continue;\n            }\n            const view = CellView.views[cid];\n            if (view == null) {\n                continue;\n            }\n            if (checkView &&\n                !FunctionExt.call(checkView, this.graph, { view, unmounted: false })) {\n                unmountedCids.push(cid);\n                continue;\n            }\n            mountCount += 1;\n            const flag = this.registerMountedView(view);\n            if (flag) {\n                this.scheduleViewUpdate(view, flag, view.priority, {\n                    mounting: true,\n                });\n            }\n        }\n        // Get rid of views, that have been mounted\n        unmountedCids.splice(0, size);\n        return mountCount;\n    }\n    checkViewImpl(options = {\n        mountedBatchSize: Number.MAX_SAFE_INTEGER,\n        unmountedBatchSize: Number.MAX_SAFE_INTEGER,\n    }) {\n        const checkView = options.checkView || this.options.checkView;\n        const unmountedCount = this.checkMountedViews(checkView, options.unmountedBatchSize);\n        const mountedCount = this.checkUnmountedViews(checkView, \n        // Do not check views, that have been just unmounted\n        // and pushed at the end of the cids array\n        unmountedCount > 0\n            ? Math.min(this.updates.unmountedCids.length - unmountedCount, options.mountedBatchSize)\n            : options.mountedBatchSize);\n        return { mountedCount, unmountedCount };\n    }\n    /**\n     * Determine every view in the graph should be attached/detached.\n     */\n    checkView(options = {}) {\n        return this.checkViewImpl(options);\n    }\n    isFrozen() {\n        return !!this.options.frozen;\n    }\n    /**\n     * Freeze the graph then the graph does not automatically re-render upon\n     * changes in the graph. This is useful when adding large numbers of cells.\n     */\n    freeze(options = {}) {\n        const key = options.key;\n        const updates = this.updates;\n        const frozen = this.options.frozen;\n        const freezeKey = updates.freezeKey;\n        if (key && key !== freezeKey) {\n            if (frozen && freezeKey) {\n                // key passed, but the graph is already freezed with another key\n                return;\n            }\n            updates.frozen = frozen;\n            updates.freezeKey = key;\n        }\n        this.options.frozen = true;\n        const animationId = updates.animationId;\n        updates.animationId = null;\n        if (this.isAsync() && animationId != null) {\n            Dom.cancelAnimationFrame(animationId);\n        }\n        this.graph.trigger('freeze', { key });\n    }\n    unfreeze(options = {}) {\n        const key = options.key;\n        const updates = this.updates;\n        const freezeKey = updates.freezeKey;\n        // key passed, but the graph is already freezed with another key\n        if (key && freezeKey && key !== freezeKey) {\n            return;\n        }\n        updates.freezeKey = null;\n        // key passed, but the graph is already freezed\n        if (key && key === freezeKey && updates.frozen) {\n            return;\n        }\n        const callback = () => {\n            this.options.frozen = updates.frozen = false;\n            if (updates.sort) {\n                this.sortViews();\n                updates.sort = false;\n            }\n            const afterFn = options.after;\n            if (afterFn) {\n                FunctionExt.call(afterFn, this.graph, this.graph);\n            }\n            this.graph.trigger('unfreeze', { key });\n        };\n        if (this.isAsync()) {\n            this.freeze();\n            const onProgress = options.progress;\n            this.updateViewsAsync(Object.assign(Object.assign({}, options), { progress: ({ done, current, total }) => {\n                    if (onProgress) {\n                        FunctionExt.call(onProgress, this.graph, { done, current, total });\n                    }\n                    // sort views after async render\n                    if (done) {\n                        callback();\n                    }\n                } }));\n        }\n        else {\n            this.updateViews(options);\n            callback();\n        }\n    }\n    isAsync() {\n        return !!this.options.async;\n    }\n    setAsync(async) {\n        this.options.async = async;\n    }\n    onRemove() {\n        this.freeze();\n        this.removeViews();\n    }\n    resetViews(cells = [], options = {}) {\n        this.resetUpdates();\n        this.removeViews();\n        this.freeze({ key: 'reset' });\n        for (let i = 0, n = cells.length; i < n; i += 1) {\n            this.renderView(cells[i], options);\n        }\n        this.unfreeze({ key: 'reset' });\n        this.sortViews();\n    }\n    removeView(cell) {\n        const view = this.views[cell.id];\n        if (view) {\n            const cid = view.cid;\n            const updates = this.updates;\n            const mounted = updates.mounted;\n            const unmounted = updates.unmounted;\n            view.remove();\n            delete this.views[cell.id];\n            delete mounted[cid];\n            delete unmounted[cid];\n        }\n        return view;\n    }\n    removeViews() {\n        if (this.views) {\n            Object.keys(this.views).forEach((id) => {\n                const view = this.views[id];\n                if (view) {\n                    this.removeView(view.cell);\n                }\n            });\n        }\n        this.views = {};\n    }\n    renderView(cell, options = {}) {\n        const id = cell.id;\n        const views = this.views;\n        let flag = 0;\n        let view = views[id];\n        if (!cell.isVisible()) {\n            return;\n        }\n        if (cell.isEdge()) {\n            if (!this.isEdgeTerminalVisible(cell, 'source') ||\n                !this.isEdgeTerminalVisible(cell, 'target')) {\n                return;\n            }\n        }\n        if (view) {\n            flag = Renderer.FLAG_INSERT;\n        }\n        else {\n            const tmp = this.graph.hook.createCellView(cell);\n            if (tmp) {\n                view = views[cell.id] = tmp;\n                view.graph = this.graph;\n                flag = this.registerUnmountedView(view) | view.getBootstrapFlag();\n            }\n        }\n        if (view) {\n            this.requestViewUpdate(view, flag, view.priority, options);\n        }\n    }\n    isExactSorting() {\n        return this.options.sorting === 'exact';\n    }\n    sortViews() {\n        if (!this.isExactSorting()) {\n            return;\n        }\n        if (this.isFrozen()) {\n            // sort views once unfrozen\n            this.updates.sort = true;\n            return;\n        }\n        this.sortViewsExact();\n    }\n    sortElements(elems, comparator) {\n        // Highly inspired by the jquery.sortElements plugin by Padolsey.\n        // See http://james.padolsey.com/javascript/sorting-elements-with-jquery/.\n        const placements = elems.map((elem) => {\n            const parentNode = elem.parentNode;\n            // Since the element itself will change position, we have\n            // to have some way of storing it's original position in\n            // the DOM. The easiest way is to have a 'flag' node:\n            const nextSibling = parentNode.insertBefore(document.createTextNode(''), elem.nextSibling);\n            return (targetNode) => {\n                if (parentNode === targetNode) {\n                    throw new Error(\"You can't sort elements if any one is a descendant of another.\");\n                }\n                // Insert before flag\n                parentNode.insertBefore(targetNode, nextSibling);\n                // Remove flag\n                parentNode.removeChild(nextSibling);\n            };\n        });\n        elems.sort(comparator).forEach((elem, index) => placements[index](elem));\n    }\n    sortViewsExact() {\n        // const elems = this.view.stage.querySelectorAll('[data-cell-id]')\n        // const length = elems.length\n        // const cells = []\n        // for (let i = 0; i < length; i++) {\n        //   const cell = this.model.getCell(elems[i].getAttribute('data-cell-id') || '')\n        //   cells.push({\n        //     id: cell.id,\n        //     zIndex: cell.getZIndex() || 0,\n        //     elem: elems[i],\n        //   })\n        // }\n        // const sortedCells = [...cells].sort((cell1, cell2) => cell1.zIndex - cell2.zIndex)\n        // const moves = ArrayExt.diff(cells, sortedCells, 'zIndex').moves\n        // if (moves && moves.length) {\n        //   moves.forEach((move) => {\n        //     if (move.type) {\n        //       const elem = move.item.elem as Element\n        //       const parentNode = elem.parentNode\n        //       const index = move.index\n        //       if (parentNode) {\n        //         if (index === length - 1) {\n        //           parentNode.appendChild(elem)\n        //         } else if (index < length - 1) {\n        //           parentNode.insertBefore(elem, elems[index + 1])\n        //         }\n        //       }\n        //     }\n        //   })\n        // }\n        // Run insertion sort algorithm in order to efficiently sort DOM\n        // elements according to their associated cell `zIndex` attribute.\n        const elems = this.view\n            .$(this.view.stage)\n            .children('[data-cell-id]')\n            .toArray();\n        const model = this.model;\n        this.sortElements(elems, (a, b) => {\n            const cellA = model.getCell(a.getAttribute('data-cell-id') || '');\n            const cellB = model.getCell(b.getAttribute('data-cell-id') || '');\n            const z1 = cellA.getZIndex() || 0;\n            const z2 = cellB.getZIndex() || 0;\n            return z1 === z2 ? 0 : z1 < z2 ? -1 : 1;\n        });\n    }\n    addZPivot(zIndex = 0) {\n        if (this.zPivots == null) {\n            this.zPivots = {};\n        }\n        const pivots = this.zPivots;\n        let pivot = pivots[zIndex];\n        if (pivot) {\n            return pivot;\n        }\n        pivot = pivots[zIndex] = document.createComment(`z-index:${zIndex + 1}`);\n        let neighborZ = -Infinity;\n        // eslint-disable-next-line\n        for (const key in pivots) {\n            const currentZ = +key;\n            if (currentZ < zIndex && currentZ > neighborZ) {\n                neighborZ = currentZ;\n                if (neighborZ === zIndex - 1) {\n                    continue;\n                }\n            }\n        }\n        const layer = this.view.stage;\n        if (neighborZ !== -Infinity) {\n            const neighborPivot = pivots[neighborZ];\n            layer.insertBefore(pivot, neighborPivot.nextSibling);\n        }\n        else {\n            layer.insertBefore(pivot, layer.firstChild);\n        }\n        return pivot;\n    }\n    removeZPivots() {\n        if (this.zPivots) {\n            Object.keys(this.zPivots).forEach((z) => {\n                const elem = this.zPivots[z];\n                if (elem && elem.parentNode) {\n                    elem.parentNode.removeChild(elem);\n                }\n            });\n        }\n        this.zPivots = {};\n    }\n    insertView(view) {\n        const stage = this.view.stage;\n        switch (this.options.sorting) {\n            case 'approx': {\n                const zIndex = view.cell.getZIndex();\n                const pivot = this.addZPivot(zIndex);\n                stage.insertBefore(view.container, pivot);\n                break;\n            }\n            case 'exact':\n            default:\n                stage.appendChild(view.container);\n                break;\n        }\n    }\n    findViewByCell(cell) {\n        if (cell == null) {\n            return null;\n        }\n        const id = Cell.isCell(cell) ? cell.id : cell;\n        return this.views[id];\n    }\n    findViewByElem(elem) {\n        if (elem == null) {\n            return null;\n        }\n        const target = typeof elem === 'string'\n            ? this.view.stage.querySelector(elem)\n            : elem instanceof Element\n                ? elem\n                : elem[0];\n        if (target) {\n            const id = this.view.findAttr('data-cell-id', target);\n            if (id) {\n                return this.views[id];\n            }\n        }\n        return null;\n    }\n    findViewsFromPoint(p) {\n        const ref = { x: p.x, y: p.y };\n        return this.model\n            .getCells()\n            .map((cell) => this.findViewByCell(cell))\n            .filter((view) => {\n            if (view != null) {\n                return Dom.getBBox(view.container, {\n                    target: this.view.stage,\n                }).containsPoint(ref);\n            }\n            return false;\n        });\n    }\n    findEdgeViewsInArea(rect, options = {}) {\n        const area = Rectangle.create(rect);\n        return this.model\n            .getEdges()\n            .map((edge) => this.findViewByCell(edge))\n            .filter((view) => {\n            if (view) {\n                const bbox = Dom.getBBox(view.container, {\n                    target: this.view.stage,\n                });\n                if (bbox.width === 0) {\n                    bbox.inflate(1, 0);\n                }\n                else if (bbox.height === 0) {\n                    bbox.inflate(0, 1);\n                }\n                return options.strict\n                    ? area.containsRect(bbox)\n                    : area.isIntersectWithRect(bbox);\n            }\n            return false;\n        });\n    }\n    findViewsInArea(rect, options = {}) {\n        const area = Rectangle.create(rect);\n        return this.model\n            .getNodes()\n            .map((node) => this.findViewByCell(node))\n            .filter((view) => {\n            if (view) {\n                const bbox = Dom.getBBox(view.container, {\n                    target: this.view.stage,\n                });\n                return options.strict\n                    ? area.containsRect(bbox)\n                    : area.isIntersectWithRect(bbox);\n            }\n            return false;\n        });\n    }\n    dispose() {\n        this.resetUpdates();\n        this.stopListening();\n    }\n}\n__decorate([\n    Base.dispose()\n], Renderer.prototype, \"dispose\", null);\n(function (Renderer) {\n    Renderer.FLAG_INSERT = 1 << 30;\n    Renderer.FLAG_REMOVE = 1 << 29;\n    Renderer.MOUNT_BATCH_SIZE = 1000;\n    Renderer.UPDATE_BATCH_SIZE = 1000;\n    Renderer.MIN_PRIORITY = 2;\n    Renderer.SORT_DELAYING_BATCHES = [\n        'add',\n        'to-front',\n        'to-back',\n    ];\n    Renderer.UPDATE_DELAYING_BATCHES = ['translate'];\n})(Renderer || (Renderer = {}));\n//# sourceMappingURL=renderer.js.map"]},"metadata":{},"sourceType":"module"}