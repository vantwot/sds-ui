{"ast":null,"code":"import _initializerDefineProperty from \"@babel/runtime/helpers/initializerDefineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _assertThisInitialized from \"@babel/runtime/helpers/assertThisInitialized\";\nimport _get from \"@babel/runtime/helpers/get\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _applyDecoratedDescriptor from \"@babel/runtime/helpers/applyDecoratedDescriptor\";\nimport _initializerWarningHelper from \"@babel/runtime/helpers/initializerWarningHelper\";\n\nvar _dec, _dec2, _class, _class2, _descriptor;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { $window } from '@antv/l7-utils';\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\nvar blendFS = \"uniform float u_opacity : 1.0;\\nuniform float u_MixRatio : 0.5;\\n\\nuniform sampler2D u_Diffuse1;\\nuniform sampler2D u_Diffuse2;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  vec4 texel1 = texture2D(u_Diffuse1, v_UV);\\n  vec4 texel2 = texture2D(u_Diffuse2, v_UV);\\n  gl_FragColor = u_opacity * mix(texel1, texel2, u_MixRatio);\\n}\\n\";\nvar copyFS = \"varying vec2 v_UV;\\n\\nuniform sampler2D u_Texture;\\n\\nvoid main() {\\n  gl_FragColor = vec4(texture2D(u_Texture, v_UV));\\n}\";\nvar quadVS = \"attribute vec2 a_Position;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\nimport { TYPES } from '../../../types';\nimport { gl } from '../gl';\nimport { PassType } from '../IMultiPassRenderer';\nimport BaseNormalPass from './BaseNormalPass';\n\nfunction halton(index, base) {\n  var result = 0;\n  var f = 1 / base;\n  var i = index;\n\n  while (i > 0) {\n    result = result + f * (i % base);\n    i = Math.floor(i / base);\n    f = f / base;\n  }\n\n  return result;\n}\n\nvar accumulatingId = 1;\nvar TAAPass = (_dec = injectable(), _dec2 = inject(TYPES.IShaderModuleService), _dec(_class = (_class2 = function (_BaseNormalPass) {\n  _inherits(TAAPass, _BaseNormalPass);\n\n  var _super = _createSuper(TAAPass);\n\n  function TAAPass() {\n    var _this;\n\n    _classCallCheck(this, TAAPass);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n\n    _initializerDefineProperty(_assertThisInitialized(_this), \"shaderModuleService\", _descriptor, _assertThisInitialized(_this));\n\n    _defineProperty(_assertThisInitialized(_this), \"haltonSequence\", []);\n\n    _defineProperty(_assertThisInitialized(_this), \"accumulatingId\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"frame\", 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"timer\", undefined);\n\n    _defineProperty(_assertThisInitialized(_this), \"sampleRenderTarget\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"prevRenderTarget\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"outputRenderTarget\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"copyRenderTarget\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"blendModel\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"outputModel\", void 0);\n\n    _defineProperty(_assertThisInitialized(_this), \"copyModel\", void 0);\n\n    return _this;\n  }\n\n  _createClass(TAAPass, [{\n    key: \"getType\",\n    value: function getType() {\n      return PassType.Normal;\n    }\n  }, {\n    key: \"getName\",\n    value: function getName() {\n      return 'taa';\n    }\n  }, {\n    key: \"init\",\n    value: function init(layer, config) {\n      _get(_getPrototypeOf(TAAPass.prototype), \"init\", this).call(this, layer, config);\n\n      var _this$rendererService = this.rendererService,\n          createFramebuffer = _this$rendererService.createFramebuffer,\n          createTexture2D = _this$rendererService.createTexture2D;\n      this.sampleRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n      this.prevRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n      this.outputRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n      this.copyRenderTarget = createFramebuffer({\n        color: createTexture2D({\n          width: 1,\n          height: 1,\n          wrapS: gl.CLAMP_TO_EDGE,\n          wrapT: gl.CLAMP_TO_EDGE\n        })\n      });\n\n      for (var i = 0; i < 30; i++) {\n        this.haltonSequence.push([halton(i, 2), halton(i, 3)]);\n      }\n\n      this.blendModel = this.createTriangleModel('blend-pass', blendFS);\n      this.outputModel = this.createTriangleModel('copy-pass', copyFS, {\n        blend: {\n          enable: true,\n          func: {\n            srcRGB: gl.ONE,\n            dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n            srcAlpha: gl.ONE,\n            dstAlpha: gl.ONE_MINUS_SRC_ALPHA\n          },\n          equation: {\n            rgb: gl.FUNC_ADD,\n            alpha: gl.FUNC_ADD\n          }\n        }\n      });\n      this.copyModel = this.createTriangleModel('copy-pass', copyFS);\n    }\n  }, {\n    key: \"render\",\n    value: function render(layer) {\n      var _this2 = this;\n\n      var _this$rendererService2 = this.rendererService,\n          clear = _this$rendererService2.clear,\n          getViewportSize = _this$rendererService2.getViewportSize,\n          useFramebuffer = _this$rendererService2.useFramebuffer;\n\n      var _getViewportSize = getViewportSize(),\n          width = _getViewportSize.width,\n          height = _getViewportSize.height;\n\n      this.sampleRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.prevRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.outputRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.copyRenderTarget.resize({\n        width: width,\n        height: height\n      });\n      this.resetFrame();\n      this.stopAccumulating();\n      var readFBO = layer.multiPassRenderer.getPostProcessor().getReadFBO();\n      useFramebuffer(readFBO, function () {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: readFBO\n        });\n        layer.multiPassRenderer.setRenderFlag(false);\n        layer.render();\n        layer.multiPassRenderer.setRenderFlag(true);\n      });\n\n      var accumulate = function accumulate(id) {\n        if (!_this2.accumulatingId || id !== _this2.accumulatingId) {\n          return;\n        }\n\n        if (!_this2.isFinished()) {\n          _this2.doRender(layer);\n\n          $window.requestAnimationFrame(function () {\n            accumulate(id);\n          });\n        }\n      };\n\n      this.accumulatingId = accumulatingId++;\n      this.timer = $window.setTimeout(function () {\n        accumulate(_this2.accumulatingId);\n      }, 50);\n    }\n  }, {\n    key: \"doRender\",\n    value: function doRender(layer) {\n      var _this3 = this;\n\n      var _this$rendererService3 = this.rendererService,\n          clear = _this$rendererService3.clear,\n          getViewportSize = _this$rendererService3.getViewportSize,\n          useFramebuffer = _this$rendererService3.useFramebuffer;\n\n      var _getViewportSize2 = getViewportSize(),\n          width = _getViewportSize2.width,\n          height = _getViewportSize2.height;\n\n      var _layer$getLayerConfig = layer.getLayerConfig(),\n          _layer$getLayerConfig2 = _layer$getLayerConfig.jitterScale,\n          jitterScale = _layer$getLayerConfig2 === void 0 ? 1 : _layer$getLayerConfig2;\n\n      var offset = this.haltonSequence[this.frame % this.haltonSequence.length];\n      this.cameraService.jitterProjectionMatrix((offset[0] * 2.0 - 1.0) / width * jitterScale, (offset[1] * 2.0 - 1.0) / height * jitterScale);\n      layer.multiPassRenderer.setRenderFlag(false);\n      layer.hooks.beforeRender.call();\n      useFramebuffer(this.sampleRenderTarget, function () {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: _this3.sampleRenderTarget\n        });\n        layer.render();\n      });\n      layer.hooks.afterRender.call();\n      layer.multiPassRenderer.setRenderFlag(true);\n      var layerStyleOptions = layer.getLayerConfig();\n      useFramebuffer(this.outputRenderTarget, function () {\n        _this3.blendModel.draw({\n          uniforms: {\n            u_opacity: layerStyleOptions.opacity || 1,\n            u_MixRatio: _this3.frame === 0 ? 1 : 0.9,\n            u_Diffuse1: _this3.sampleRenderTarget,\n            u_Diffuse2: _this3.frame === 0 ? layer.multiPassRenderer.getPostProcessor().getReadFBO() : _this3.prevRenderTarget\n          }\n        });\n      });\n\n      if (this.frame === 0) {\n        clear({\n          color: [0, 0, 0, 0],\n          depth: 1,\n          stencil: 0,\n          framebuffer: this.copyRenderTarget\n        });\n      }\n\n      if (this.frame >= 1) {\n        useFramebuffer(this.copyRenderTarget, function () {\n          _this3.outputModel.draw({\n            uniforms: {\n              u_Texture: _this3.outputRenderTarget\n            }\n          });\n        });\n        useFramebuffer(layer.multiPassRenderer.getPostProcessor().getReadFBO(), function () {\n          _this3.copyModel.draw({\n            uniforms: {\n              u_Texture: _this3.copyRenderTarget\n            }\n          });\n        });\n        layer.multiPassRenderer.getPostProcessor().render(layer);\n      }\n\n      var tmp = this.prevRenderTarget;\n      this.prevRenderTarget = this.outputRenderTarget;\n      this.outputRenderTarget = tmp;\n      this.frame++;\n      this.cameraService.clearJitterProjectionMatrix();\n    }\n  }, {\n    key: \"isFinished\",\n    value: function isFinished() {\n      return this.frame >= this.haltonSequence.length;\n    }\n  }, {\n    key: \"resetFrame\",\n    value: function resetFrame() {\n      this.frame = 0;\n    }\n  }, {\n    key: \"stopAccumulating\",\n    value: function stopAccumulating() {\n      this.accumulatingId = 0;\n      $window.clearTimeout(this.timer);\n    }\n  }, {\n    key: \"createTriangleModel\",\n    value: function createTriangleModel(shaderModuleName, fragmentShader, options) {\n      this.shaderModuleService.registerModule(shaderModuleName, {\n        vs: quadVS,\n        fs: fragmentShader\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule(shaderModuleName),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          uniforms = _this$shaderModuleSer.uniforms;\n\n      var _this$rendererService4 = this.rendererService,\n          createAttribute = _this$rendererService4.createAttribute,\n          createBuffer = _this$rendererService4.createBuffer,\n          createModel = _this$rendererService4.createModel;\n      return createModel(_objectSpread({\n        vs: vs,\n        fs: fs,\n        attributes: {\n          a_Position: createAttribute({\n            buffer: createBuffer({\n              data: [-4, -4, 4, -4, 0, 4],\n              type: gl.FLOAT\n            }),\n            size: 2\n          })\n        },\n        uniforms: _objectSpread({}, uniforms),\n        depth: {\n          enable: false\n        },\n        count: 3\n      }, options));\n    }\n  }]);\n\n  return TAAPass;\n}(BaseNormalPass), _descriptor = _applyDecoratedDescriptor(_class2.prototype, \"shaderModuleService\", [_dec2], {\n  configurable: true,\n  enumerable: true,\n  writable: true,\n  initializer: null\n}), _class2)) || _class);\nexport { TAAPass as default };","map":{"version":3,"sources":["../../../../src/services/renderer/passes/TAAPass.ts"],"names":["result","f","i","Math","accumulatingId","injectable","TAAPass","BaseNormalPass","inject","TYPES","undefined","PassType","createFramebuffer","createTexture2D","color","width","height","wrapS","gl","wrapT","CLAMP_TO_EDGE","halton","blend","enable","func","srcRGB","dstRGB","srcAlpha","dstAlpha","ONE_MINUS_SRC_ALPHA","equation","rgb","alpha","FUNC_ADD","clear","getViewportSize","useFramebuffer","readFBO","layer","depth","stencil","framebuffer","accumulate","id","$window","jitterScale","offset","sampleRenderTarget","layerStyleOptions","uniforms","u_opacity","u_MixRatio","u_Diffuse1","u_Diffuse2","prevRenderTarget","copyRenderTarget","u_Texture","outputRenderTarget","tmp","vs","fs","fragmentShader","createAttribute","createBuffer","createModel","attributes","a_Position","buffer","data","type","FLOAT","size","count"],"mappings":"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","sourcesContent":["import { $window } from '@antv/l7-utils';\nimport { inject, injectable } from 'inversify';\nimport 'reflect-metadata';\nimport blendFS from '../../../shaders/post-processing/blend.glsl';\nimport copyFS from '../../../shaders/post-processing/copy.glsl';\nimport quadVS from '../../../shaders/post-processing/quad.glsl';\nimport { TYPES } from '../../../types';\nimport { ILayer } from '../../layer/ILayerService';\nimport { IShaderModuleService } from '../../shader/IShaderModuleService';\nimport { gl } from '../gl';\nimport { IFramebuffer } from '../IFramebuffer';\nimport { IModel, IModelInitializationOptions } from '../IModel';\nimport { PassType } from '../IMultiPassRenderer';\nimport BaseNormalPass from './BaseNormalPass';\n\n// Generate halton sequence\n// https://en.wikipedia.org/wiki/Halton_sequence\nfunction halton(index: number, base: number) {\n  let result = 0;\n  let f = 1 / base;\n  let i = index;\n  while (i > 0) {\n    result = result + f * (i % base);\n    i = Math.floor(i / base);\n    f = f / base;\n  }\n  return result;\n}\n\n// 累加计数器\nlet accumulatingId = 1;\n\n/**\n * TAA（Temporal Anti-Aliasing）\n * 在需要后处理的场景中（例如 L7 的热力图需要 blur pass、PBR 中的 SSAO 环境光遮蔽），无法使用浏览器内置的 MSAA，\n * 只能使用 TAA\n * @see https://yuque.antfin-inc.com/yuqi.pyq/fgetpa/ri52hv\n */\n@injectable()\nexport default class TAAPass<InitializationOptions = {}> extends BaseNormalPass<\n  InitializationOptions\n> {\n  @inject(TYPES.IShaderModuleService)\n  protected readonly shaderModuleService: IShaderModuleService;\n\n  /**\n   * 低差异序列\n   */\n  private haltonSequence: Array<[number, number]> = [];\n\n  /**\n   * 当前累加任务 ID，例如用户连续拖拽时上一次累加很有可能没有结束，此时在开启新一轮累加之前需要结束掉之前未完成的\n   */\n  private accumulatingId: number = 0;\n\n  /**\n   * 每一轮累加中的 frameID\n   */\n  private frame: number = 0;\n\n  /**\n   * 每一轮累加中的 frame 定时器\n   */\n  private timer: number | undefined = undefined;\n\n  private sampleRenderTarget: IFramebuffer;\n  private prevRenderTarget: IFramebuffer;\n  private outputRenderTarget: IFramebuffer;\n  private copyRenderTarget: IFramebuffer;\n\n  private blendModel: IModel;\n  private outputModel: IModel;\n  private copyModel: IModel;\n\n  public getType() {\n    return PassType.Normal;\n  }\n\n  public getName() {\n    return 'taa';\n  }\n\n  public init(layer: ILayer, config?: Partial<InitializationOptions>) {\n    super.init(layer, config);\n\n    const { createFramebuffer, createTexture2D } = this.rendererService;\n    this.sampleRenderTarget = createFramebuffer({\n      color: createTexture2D({\n        width: 1,\n        height: 1,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n      }),\n    });\n    this.prevRenderTarget = createFramebuffer({\n      color: createTexture2D({\n        width: 1,\n        height: 1,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n      }),\n    });\n    this.outputRenderTarget = createFramebuffer({\n      color: createTexture2D({\n        width: 1,\n        height: 1,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n      }),\n    });\n    this.copyRenderTarget = createFramebuffer({\n      color: createTexture2D({\n        width: 1,\n        height: 1,\n        wrapS: gl.CLAMP_TO_EDGE,\n        wrapT: gl.CLAMP_TO_EDGE,\n      }),\n    });\n\n    for (let i = 0; i < 30; i++) {\n      this.haltonSequence.push([halton(i, 2), halton(i, 3)]);\n    }\n\n    this.blendModel = this.createTriangleModel('blend-pass', blendFS);\n    this.outputModel = this.createTriangleModel('copy-pass', copyFS, {\n      blend: {\n        enable: true,\n        func: {\n          srcRGB: gl.ONE,\n          dstRGB: gl.ONE_MINUS_SRC_ALPHA,\n          srcAlpha: gl.ONE,\n          dstAlpha: gl.ONE_MINUS_SRC_ALPHA,\n        },\n        equation: {\n          rgb: gl.FUNC_ADD,\n          alpha: gl.FUNC_ADD,\n        },\n      },\n    });\n    this.copyModel = this.createTriangleModel('copy-pass', copyFS);\n  }\n\n  public render(layer: ILayer) {\n    const { clear, getViewportSize, useFramebuffer } = this.rendererService;\n    const { width, height } = getViewportSize();\n    this.sampleRenderTarget.resize({ width, height });\n    this.prevRenderTarget.resize({ width, height });\n    this.outputRenderTarget.resize({ width, height });\n    this.copyRenderTarget.resize({ width, height });\n\n    this.resetFrame();\n    // 首先停止上一次的累加\n    this.stopAccumulating();\n\n    // 先输出到 PostProcessor\n    const readFBO = layer.multiPassRenderer.getPostProcessor().getReadFBO();\n    useFramebuffer(readFBO, () => {\n      clear({\n        color: [0, 0, 0, 0],\n        depth: 1,\n        stencil: 0,\n        framebuffer: readFBO,\n      });\n\n      // render to post processor\n      layer.multiPassRenderer.setRenderFlag(false);\n      layer.render();\n      layer.multiPassRenderer.setRenderFlag(true);\n    });\n\n    const accumulate = (id: number) => {\n      // 在开启新一轮累加之前，需要先结束掉之前的累加\n      if (!this.accumulatingId || id !== this.accumulatingId) {\n        return;\n      }\n\n      if (!this.isFinished()) {\n        this.doRender(layer);\n\n        $window.requestAnimationFrame(() => {\n          accumulate(id);\n        });\n      }\n    };\n\n    this.accumulatingId = accumulatingId++;\n    // @ts-ignore\n    this.timer = $window.setTimeout(() => {\n      accumulate(this.accumulatingId);\n    }, 50);\n  }\n\n  private doRender(layer: ILayer) {\n    const { clear, getViewportSize, useFramebuffer } = this.rendererService;\n    const { width, height } = getViewportSize();\n    const { jitterScale = 1 } = layer.getLayerConfig();\n\n    // 使用 Halton 序列抖动投影矩阵\n    const offset = this.haltonSequence[this.frame % this.haltonSequence.length];\n    this.cameraService.jitterProjectionMatrix(\n      ((offset[0] * 2.0 - 1.0) / width) * jitterScale,\n      ((offset[1] * 2.0 - 1.0) / height) * jitterScale,\n    );\n\n    // 按抖动后的投影矩阵渲染\n    layer.multiPassRenderer.setRenderFlag(false);\n    layer.hooks.beforeRender.call();\n    useFramebuffer(this.sampleRenderTarget, () => {\n      clear({\n        color: [0, 0, 0, 0],\n        depth: 1,\n        stencil: 0,\n        framebuffer: this.sampleRenderTarget,\n      });\n\n      layer.render();\n    });\n    layer.hooks.afterRender.call();\n    layer.multiPassRenderer.setRenderFlag(true);\n\n    // 混合\n    const layerStyleOptions = layer.getLayerConfig();\n    useFramebuffer(this.outputRenderTarget, () => {\n      this.blendModel.draw({\n        uniforms: {\n          // @ts-ignore\n          u_opacity: layerStyleOptions.opacity || 1,\n          u_MixRatio: this.frame === 0 ? 1 : 0.9,\n          u_Diffuse1: this.sampleRenderTarget,\n          u_Diffuse2:\n            this.frame === 0\n              ? layer.multiPassRenderer.getPostProcessor().getReadFBO()\n              : this.prevRenderTarget,\n        },\n      });\n    });\n\n    // 输出累加结果\n    if (this.frame === 0) {\n      clear({\n        color: [0, 0, 0, 0],\n        depth: 1,\n        stencil: 0,\n        framebuffer: this.copyRenderTarget,\n      });\n    }\n\n    if (this.frame >= 1) {\n      useFramebuffer(this.copyRenderTarget, () => {\n        this.outputModel.draw({\n          uniforms: {\n            u_Texture: this.outputRenderTarget,\n          },\n        });\n      });\n\n      useFramebuffer(\n        layer.multiPassRenderer.getPostProcessor().getReadFBO(),\n        () => {\n          this.copyModel.draw({\n            uniforms: {\n              u_Texture: this.copyRenderTarget,\n            },\n          });\n        },\n      );\n      layer.multiPassRenderer.getPostProcessor().render(layer);\n    }\n\n    // 保存前序帧结果\n    const tmp = this.prevRenderTarget;\n    this.prevRenderTarget = this.outputRenderTarget;\n    this.outputRenderTarget = tmp;\n\n    this.frame++;\n\n    // 恢复 jitter 后的相机\n    this.cameraService.clearJitterProjectionMatrix();\n  }\n\n  /**\n   * 是否已经完成累加\n   * @return {boolean} isFinished\n   */\n  private isFinished() {\n    return this.frame >= this.haltonSequence.length;\n  }\n\n  private resetFrame() {\n    this.frame = 0;\n  }\n\n  private stopAccumulating() {\n    this.accumulatingId = 0;\n    $window.clearTimeout(this.timer);\n  }\n\n  private createTriangleModel(\n    shaderModuleName: string,\n    fragmentShader: string,\n    options?: Partial<IModelInitializationOptions>,\n  ) {\n    this.shaderModuleService.registerModule(shaderModuleName, {\n      vs: quadVS,\n      fs: fragmentShader,\n    });\n\n    const { vs, fs, uniforms } = this.shaderModuleService.getModule(\n      shaderModuleName,\n    );\n    const { createAttribute, createBuffer, createModel } = this.rendererService;\n    return createModel({\n      vs,\n      fs,\n      attributes: {\n        // 使用一个全屏三角形，相比 Quad 顶点数目更少\n        a_Position: createAttribute({\n          buffer: createBuffer({\n            data: [-4, -4, 4, -4, 0, 4],\n            type: gl.FLOAT,\n          }),\n          size: 2,\n        }),\n      },\n      uniforms: {\n        ...uniforms,\n      },\n      depth: {\n        enable: false,\n      },\n      count: 3,\n      ...options,\n    });\n  }\n}\n"]},"metadata":{},"sourceType":"module"}