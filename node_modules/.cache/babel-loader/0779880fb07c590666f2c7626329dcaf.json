{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _assertThisInitialized from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/assertThisInitialized\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ObjectExt, FunctionExt } from '../util';\nimport { Basecoat } from '../common';\nimport { Model } from '../model/model';\nexport var HistoryManager = /*#__PURE__*/function (_Basecoat) {\n  _inherits(HistoryManager, _Basecoat);\n\n  var _super = _createSuper(HistoryManager);\n\n  function HistoryManager(options) {\n    var _this;\n\n    _classCallCheck(this, HistoryManager);\n\n    _this = _super.call(this);\n    _this.batchCommands = null;\n    _this.batchLevel = 0;\n    _this.lastBatchIndex = -1;\n    _this.freezed = false;\n    _this.handlers = [];\n    _this.graph = options.graph;\n    _this.model = options.graph.model;\n    _this.options = Util.getOptions(options);\n    _this.validator = new HistoryManager.Validator({\n      history: _assertThisInitialized(_this),\n      cancelInvalid: _this.options.cancelInvalid\n    });\n\n    _this.clean();\n\n    _this.startListening();\n\n    return _this;\n  }\n\n  _createClass(HistoryManager, [{\n    key: \"disabled\",\n    get: function get() {\n      return this.options.enabled !== true;\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      if (this.disabled) {\n        this.options.enabled = true;\n      }\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      if (!this.disabled) {\n        this.options.enabled = false;\n      }\n    }\n  }, {\n    key: \"undo\",\n    value: function undo() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.disabled) {\n        var cmd = this.undoStack.pop();\n\n        if (cmd) {\n          this.revertCommand(cmd, options);\n          this.redoStack.push(cmd);\n          this.notify('undo', cmd, options);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"redo\",\n    value: function redo() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.disabled) {\n        var cmd = this.redoStack.pop();\n\n        if (cmd) {\n          this.applyCommand(cmd, options);\n          this.undoStack.push(cmd);\n          this.notify('redo', cmd, options);\n        }\n      }\n\n      return this;\n    }\n    /**\n     * Same as `undo()` but does not store the undo-ed command to the\n     * `redoStack`. Canceled command therefore cannot be redo-ed.\n     */\n\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n      if (!this.disabled) {\n        var cmd = this.undoStack.pop();\n\n        if (cmd) {\n          this.revertCommand(cmd, options);\n          this.redoStack = [];\n          this.notify('cancel', cmd, options);\n        }\n      }\n\n      return this;\n    }\n  }, {\n    key: \"clean\",\n    value: function clean() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      this.undoStack = [];\n      this.redoStack = [];\n      this.notify('clean', null, options);\n      return this;\n    }\n  }, {\n    key: \"canUndo\",\n    value: function canUndo() {\n      return !this.disabled && this.undoStack.length > 0;\n    }\n  }, {\n    key: \"canRedo\",\n    value: function canRedo() {\n      return !this.disabled && this.redoStack.length > 0;\n    }\n  }, {\n    key: \"validate\",\n    value: function validate(events) {\n      var _this$validator;\n\n      for (var _len = arguments.length, callbacks = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n        callbacks[_key - 1] = arguments[_key];\n      }\n\n      (_this$validator = this.validator).validate.apply(_this$validator, [events].concat(callbacks));\n\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.validator.dispose();\n      this.clean();\n      this.stopListening();\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      var _this2 = this;\n\n      this.model.on('batch:start', this.initBatchCommand, this);\n      this.model.on('batch:stop', this.storeBatchCommand, this);\n\n      if (this.options.eventNames) {\n        this.options.eventNames.forEach(function (name, index) {\n          _this2.handlers[index] = _this2.addCommand.bind(_this2, name);\n\n          _this2.model.on(name, _this2.handlers[index]);\n        });\n      }\n\n      this.validator.on('invalid', function (args) {\n        return _this2.trigger('invalid', args);\n      });\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      var _this3 = this;\n\n      this.model.off('batch:start', this.initBatchCommand, this);\n      this.model.off('batch:stop', this.storeBatchCommand, this);\n\n      if (this.options.eventNames) {\n        this.options.eventNames.forEach(function (name, index) {\n          _this3.model.off(name, _this3.handlers[index]);\n        });\n        this.handlers.length = 0;\n      }\n\n      this.validator.off('invalid');\n    }\n  }, {\n    key: \"createCommand\",\n    value: function createCommand(options) {\n      return {\n        batch: options ? options.batch : false,\n        data: {}\n      };\n    }\n  }, {\n    key: \"revertCommand\",\n    value: function revertCommand(cmd, options) {\n      this.freezed = true;\n      var cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n\n      for (var i = cmds.length - 1; i >= 0; i -= 1) {\n        var _cmd = cmds[i];\n        var localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(_cmd.options, this.options.revertOptionsList || []));\n        this.executeCommand(_cmd, true, localOptions);\n      }\n\n      this.freezed = false;\n    }\n  }, {\n    key: \"applyCommand\",\n    value: function applyCommand(cmd, options) {\n      this.freezed = true;\n      var cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n\n      for (var i = 0; i < cmds.length; i += 1) {\n        var _cmd2 = cmds[i];\n        var localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(_cmd2.options, this.options.applyOptionsList || []));\n        this.executeCommand(_cmd2, false, localOptions);\n      }\n\n      this.freezed = false;\n    }\n  }, {\n    key: \"executeCommand\",\n    value: function executeCommand(cmd, revert, options) {\n      var model = this.model; // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)\n\n      var cell = model.getCell(cmd.data.id);\n      var event = cmd.event;\n\n      if (Util.isAddEvent(event) && revert || Util.isRemoveEvent(event) && !revert) {\n        cell.remove(options);\n      } else if (Util.isAddEvent(event) && !revert || Util.isRemoveEvent(event) && revert) {\n        var data = cmd.data;\n\n        if (data.node) {\n          model.addNode(data.props, options);\n        } else if (data.edge) {\n          model.addEdge(data.props, options);\n        }\n      } else if (Util.isChangeEvent(event)) {\n        var _data = cmd.data;\n        var key = _data.key;\n\n        if (key) {\n          var value = revert ? _data.prev[key] : _data.next[key];\n          cell.prop(key, value, options);\n        }\n      } else {\n        var executeCommand = this.options.executeCommand;\n\n        if (executeCommand) {\n          FunctionExt.call(executeCommand, this, cmd, revert, options);\n        }\n      }\n    }\n  }, {\n    key: \"addCommand\",\n    value: function addCommand(event, args) {\n      if (this.freezed || this.disabled) {\n        return;\n      }\n\n      var eventArgs = args;\n      var options = eventArgs.options || {};\n\n      if (options.dryrun) {\n        return;\n      }\n\n      if (Util.isAddEvent(event) && this.options.ignoreAdd || Util.isRemoveEvent(event) && this.options.ignoreRemove || Util.isChangeEvent(event) && this.options.ignoreChange) {\n        return;\n      } // before\n      // ------\n\n\n      var before = this.options.beforeAddCommand;\n\n      if (before != null && FunctionExt.call(before, this, event, args) === false) {\n        return;\n      }\n\n      if (event === 'cell:change:*') {\n        // eslint-disable-next-line\n        event = \"cell:change:\".concat(eventArgs.key);\n      }\n\n      var cell = eventArgs.cell;\n      var isModelChange = Model.isModel(cell);\n      var cmd;\n\n      if (this.batchCommands) {\n        // In most cases we are working with same object, doing\n        // same action etc. translate an object piece by piece.\n        cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)]; // Check if we are start working with new object or performing different\n        // action with it. Note, that command is uninitialized when lastCmdIndex\n        // equals -1. In that case we are done, command we were looking for is\n        // already set\n\n        var diffId = isModelChange && !cmd.modelChange || cmd.data.id !== cell.id;\n        var diffName = cmd.event !== event;\n\n        if (this.lastBatchIndex >= 0 && (diffId || diffName)) {\n          // Trying to find command first, which was performing same\n          // action with the object as we are doing now with cell.\n          var index = this.batchCommands.findIndex(function (cmd) {\n            return (isModelChange && cmd.modelChange || cmd.data.id === cell.id) && cmd.event === event;\n          });\n\n          if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n            cmd = this.createCommand({\n              batch: true\n            });\n          } else {\n            cmd = this.batchCommands[index];\n            this.batchCommands.splice(index, 1);\n          }\n\n          this.batchCommands.push(cmd);\n          this.lastBatchIndex = this.batchCommands.length - 1;\n        }\n      } else {\n        cmd = this.createCommand({\n          batch: false\n        });\n      } // add & remove\n      // ------------\n\n\n      if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n        var data = cmd.data;\n        cmd.event = event;\n        cmd.options = options;\n        data.id = cell.id;\n        data.props = ObjectExt.cloneDeep(cell.toJSON());\n\n        if (cell.isEdge()) {\n          data.edge = true;\n        } else if (cell.isNode()) {\n          data.node = true;\n        }\n\n        return this.push(cmd, options);\n      } // change:*\n      // --------\n\n\n      if (Util.isChangeEvent(event)) {\n        var key = args.key;\n        var _data2 = cmd.data;\n\n        if (!cmd.batch || !cmd.event) {\n          // Do this only once. Set previous data and action (also\n          // serves as a flag so that we don't repeat this branche).\n          cmd.event = event;\n          cmd.options = options;\n          _data2.key = key;\n\n          if (_data2.prev == null) {\n            _data2.prev = {};\n          }\n\n          _data2.prev[key] = ObjectExt.clone(cell.previous(key));\n\n          if (isModelChange) {\n            cmd.modelChange = true;\n          } else {\n            _data2.id = cell.id;\n          }\n        }\n\n        if (_data2.next == null) {\n          _data2.next = {};\n        }\n\n        _data2.next[key] = ObjectExt.clone(cell.prop(key));\n        return this.push(cmd, options);\n      } // others\n      // ------\n\n\n      var afterAddCommand = this.options.afterAddCommand;\n\n      if (afterAddCommand) {\n        FunctionExt.call(afterAddCommand, this, event, args, cmd);\n      }\n\n      this.push(cmd, options);\n    }\n    /**\n     * Gather multiple changes into a single command. These commands could\n     * be reverted with single `undo()` call. From the moment the function\n     * is called every change made on model is not stored into the undoStack.\n     * Changes are temporarily kept until `storeBatchCommand()` is called.\n     */\n    // eslint-disable-next-line\n\n  }, {\n    key: \"initBatchCommand\",\n    value: function initBatchCommand(options) {\n      if (this.freezed) {\n        return;\n      }\n\n      if (this.batchCommands) {\n        this.batchLevel += 1;\n      } else {\n        this.batchCommands = [this.createCommand({\n          batch: true\n        })];\n        this.batchLevel = 0;\n        this.lastBatchIndex = -1;\n      }\n    }\n    /**\n     * Store changes temporarily kept in the undoStack. You have to call this\n     * function as many times as `initBatchCommand()` been called.\n     */\n\n  }, {\n    key: \"storeBatchCommand\",\n    value: function storeBatchCommand(options) {\n      if (this.freezed) {\n        return;\n      }\n\n      if (this.batchCommands && this.batchLevel <= 0) {\n        var cmds = this.filterBatchCommand(this.batchCommands);\n\n        if (cmds.length > 0) {\n          this.redoStack = [];\n          this.undoStack.push(cmds);\n          this.notify('add', cmds, options);\n        }\n\n        this.batchCommands = null;\n        this.lastBatchIndex = -1;\n        this.batchLevel = 0;\n      } else if (this.batchCommands && this.batchLevel > 0) {\n        this.batchLevel -= 1;\n      }\n    }\n  }, {\n    key: \"filterBatchCommand\",\n    value: function filterBatchCommand(batchCommands) {\n      var cmds = batchCommands.slice();\n      var result = [];\n\n      var _loop = function _loop() {\n        var cmd = cmds.shift();\n        var evt = cmd.event;\n        var id = cmd.data.id;\n\n        if (evt != null && (id != null || cmd.modelChange)) {\n          if (Util.isAddEvent(evt)) {\n            var index = cmds.findIndex(function (c) {\n              return Util.isRemoveEvent(c.event) && c.data.id === id;\n            });\n\n            if (index >= 0) {\n              cmds = cmds.filter(function (c, i) {\n                return index < i || c.data.id !== id;\n              });\n              return \"continue\";\n            }\n          } else if (Util.isRemoveEvent(evt)) {\n            var _index = cmds.findIndex(function (c) {\n              return Util.isAddEvent(c.event) && c.data.id === id;\n            });\n\n            if (_index >= 0) {\n              cmds.splice(_index, 1);\n              return \"continue\";\n            }\n          } else if (Util.isChangeEvent(evt)) {\n            var data = cmd.data;\n\n            if (ObjectExt.isEqual(data.prev, data.next)) {\n              return \"continue\";\n            }\n          } else {// pass\n          }\n\n          result.push(cmd);\n        }\n      };\n\n      while (cmds.length > 0) {\n        var _ret = _loop();\n\n        if (_ret === \"continue\") continue;\n      }\n\n      return result;\n    }\n  }, {\n    key: \"notify\",\n    value: function notify(event, cmd, options) {\n      var cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];\n      this.emit(event, {\n        cmds: cmds,\n        options: options\n      });\n      this.emit('change', {\n        cmds: cmds,\n        options: options\n      });\n    }\n  }, {\n    key: \"push\",\n    value: function push(cmd, options) {\n      this.redoStack = [];\n\n      if (cmd.batch) {\n        this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);\n        this.emit('batch', {\n          cmd: cmd,\n          options: options\n        });\n      } else {\n        this.undoStack.push(cmd);\n        this.notify('add', cmd, options);\n      }\n    }\n  }]);\n\n  return HistoryManager;\n}(Basecoat);\n\n__decorate([Basecoat.dispose()], HistoryManager.prototype, \"dispose\", null);\n\n(function (HistoryManager) {\n  /**\n   * Runs a set of callbacks to determine if a command is valid. This is\n   * useful for checking if a certain action in your application does\n   * lead to an invalid state of the graph.\n   */\n  var Validator = /*#__PURE__*/function (_Basecoat2) {\n    _inherits(Validator, _Basecoat2);\n\n    var _super2 = _createSuper(Validator);\n\n    function Validator(options) {\n      var _this4;\n\n      _classCallCheck(this, Validator);\n\n      _this4 = _super2.call(this);\n      _this4.map = {};\n      _this4.command = options.history;\n      _this4.cancelInvalid = options.cancelInvalid !== false;\n\n      _this4.command.on('add', _this4.onCommandAdded, _assertThisInitialized(_this4));\n\n      return _this4;\n    }\n\n    _createClass(Validator, [{\n      key: \"onCommandAdded\",\n      value: function onCommandAdded(_ref) {\n        var _this5 = this;\n\n        var cmds = _ref.cmds;\n        return Array.isArray(cmds) ? cmds.every(function (cmd) {\n          return _this5.isValidCommand(cmd);\n        }) : this.isValidCommand(cmds);\n      }\n    }, {\n      key: \"isValidCommand\",\n      value: function isValidCommand(cmd) {\n        if (cmd.options && cmd.options.validation === false) {\n          return true;\n        }\n\n        var callbacks = cmd.event && this.map[cmd.event] || [];\n        var handoverErr = null;\n        callbacks.forEach(function (routes) {\n          var i = 0;\n\n          var rollup = function rollup(err) {\n            var fn = routes[i];\n            i += 1;\n\n            try {\n              if (fn) {\n                fn(err, cmd, rollup);\n              } else {\n                handoverErr = err;\n                return;\n              }\n            } catch (err) {\n              rollup(err);\n            }\n          };\n\n          rollup(handoverErr);\n        });\n\n        if (handoverErr) {\n          if (this.cancelInvalid) {\n            this.command.cancel();\n          }\n\n          this.emit('invalid', {\n            err: handoverErr\n          });\n          return false;\n        }\n\n        return true;\n      }\n    }, {\n      key: \"validate\",\n      value: function validate(events) {\n        var _this6 = this;\n\n        for (var _len2 = arguments.length, callbacks = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n          callbacks[_key2 - 1] = arguments[_key2];\n        }\n\n        var evts = Array.isArray(events) ? events : events.split(/\\s+/);\n        callbacks.forEach(function (callback) {\n          if (typeof callback !== 'function') {\n            throw new Error(\"\".concat(evts.join(' '), \" requires callback functions.\"));\n          }\n        });\n        evts.forEach(function (event) {\n          if (_this6.map[event] == null) {\n            _this6.map[event] = [];\n          }\n\n          _this6.map[event].push(callbacks);\n        });\n        return this;\n      }\n    }, {\n      key: \"dispose\",\n      value: function dispose() {\n        this.command.off('add', this.onCommandAdded, this);\n      }\n    }]);\n\n    return Validator;\n  }(Basecoat);\n\n  __decorate([Basecoat.dispose()], Validator.prototype, \"dispose\", null);\n\n  HistoryManager.Validator = Validator;\n})(HistoryManager || (HistoryManager = {}));\n\nvar Util;\n\n(function (Util) {\n  function isAddEvent(event) {\n    return event === 'cell:added';\n  }\n\n  Util.isAddEvent = isAddEvent;\n\n  function isRemoveEvent(event) {\n    return event === 'cell:removed';\n  }\n\n  Util.isRemoveEvent = isRemoveEvent;\n\n  function isChangeEvent(event) {\n    return event != null && event.startsWith('cell:change:');\n  }\n\n  Util.isChangeEvent = isChangeEvent;\n\n  function getOptions(options) {\n    var graph = options.graph,\n        others = __rest(options, [\"graph\"]);\n\n    var reservedNames = ['cell:added', 'cell:removed', 'cell:change:*'];\n    var batchEvents = ['batch:start', 'batch:stop'];\n    var eventNames = options.eventNames ? options.eventNames.filter(function (event) {\n      return !(Util.isChangeEvent(event) || reservedNames.includes(event) || batchEvents.includes(event));\n    }) : reservedNames;\n    return Object.assign(Object.assign({}, others), {\n      eventNames: eventNames,\n      applyOptionsList: options.applyOptionsList || ['propertyPath'],\n      revertOptionsList: options.revertOptionsList || ['propertyPath']\n    });\n  }\n\n  Util.getOptions = getOptions;\n\n  function sortBatchCommands(cmds) {\n    var results = [];\n\n    for (var i = 0, ii = cmds.length; i < ii; i += 1) {\n      var cmd = cmds[i];\n      var index = null;\n\n      if (Util.isAddEvent(cmd.event)) {\n        var id = cmd.data.id;\n\n        for (var j = 0; j < i; j += 1) {\n          if (cmds[j].data.id === id) {\n            index = j;\n            break;\n          }\n        }\n      }\n\n      if (index !== null) {\n        results.splice(index, 0, cmd);\n      } else {\n        results.push(cmd);\n      }\n    }\n\n    return results;\n  }\n\n  Util.sortBatchCommands = sortBatchCommands;\n})(Util || (Util = {}));","map":{"version":3,"sources":["../../src/graph/history.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ObjectExt, FunctionExt } from '../util';\nimport { Basecoat } from '../common';\nimport { Model } from '../model/model';\nexport class HistoryManager extends Basecoat {\n    constructor(options) {\n        super();\n        this.batchCommands = null;\n        this.batchLevel = 0;\n        this.lastBatchIndex = -1;\n        this.freezed = false;\n        this.handlers = [];\n        this.graph = options.graph;\n        this.model = options.graph.model;\n        this.options = Util.getOptions(options);\n        this.validator = new HistoryManager.Validator({\n            history: this,\n            cancelInvalid: this.options.cancelInvalid,\n        });\n        this.clean();\n        this.startListening();\n    }\n    get disabled() {\n        return this.options.enabled !== true;\n    }\n    enable() {\n        if (this.disabled) {\n            this.options.enabled = true;\n        }\n    }\n    disable() {\n        if (!this.disabled) {\n            this.options.enabled = false;\n        }\n    }\n    undo(options = {}) {\n        if (!this.disabled) {\n            const cmd = this.undoStack.pop();\n            if (cmd) {\n                this.revertCommand(cmd, options);\n                this.redoStack.push(cmd);\n                this.notify('undo', cmd, options);\n            }\n        }\n        return this;\n    }\n    redo(options = {}) {\n        if (!this.disabled) {\n            const cmd = this.redoStack.pop();\n            if (cmd) {\n                this.applyCommand(cmd, options);\n                this.undoStack.push(cmd);\n                this.notify('redo', cmd, options);\n            }\n        }\n        return this;\n    }\n    /**\n     * Same as `undo()` but does not store the undo-ed command to the\n     * `redoStack`. Canceled command therefore cannot be redo-ed.\n     */\n    cancel(options = {}) {\n        if (!this.disabled) {\n            const cmd = this.undoStack.pop();\n            if (cmd) {\n                this.revertCommand(cmd, options);\n                this.redoStack = [];\n                this.notify('cancel', cmd, options);\n            }\n        }\n        return this;\n    }\n    clean(options = {}) {\n        this.undoStack = [];\n        this.redoStack = [];\n        this.notify('clean', null, options);\n        return this;\n    }\n    canUndo() {\n        return !this.disabled && this.undoStack.length > 0;\n    }\n    canRedo() {\n        return !this.disabled && this.redoStack.length > 0;\n    }\n    validate(events, ...callbacks) {\n        this.validator.validate(events, ...callbacks);\n        return this;\n    }\n    dispose() {\n        this.validator.dispose();\n        this.clean();\n        this.stopListening();\n    }\n    startListening() {\n        this.model.on('batch:start', this.initBatchCommand, this);\n        this.model.on('batch:stop', this.storeBatchCommand, this);\n        if (this.options.eventNames) {\n            this.options.eventNames.forEach((name, index) => {\n                this.handlers[index] = this.addCommand.bind(this, name);\n                this.model.on(name, this.handlers[index]);\n            });\n        }\n        this.validator.on('invalid', (args) => this.trigger('invalid', args));\n    }\n    stopListening() {\n        this.model.off('batch:start', this.initBatchCommand, this);\n        this.model.off('batch:stop', this.storeBatchCommand, this);\n        if (this.options.eventNames) {\n            this.options.eventNames.forEach((name, index) => {\n                this.model.off(name, this.handlers[index]);\n            });\n            this.handlers.length = 0;\n        }\n        this.validator.off('invalid');\n    }\n    createCommand(options) {\n        return {\n            batch: options ? options.batch : false,\n            data: {},\n        };\n    }\n    revertCommand(cmd, options) {\n        this.freezed = true;\n        const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n        for (let i = cmds.length - 1; i >= 0; i -= 1) {\n            const cmd = cmds[i];\n            const localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(cmd.options, this.options.revertOptionsList || []));\n            this.executeCommand(cmd, true, localOptions);\n        }\n        this.freezed = false;\n    }\n    applyCommand(cmd, options) {\n        this.freezed = true;\n        const cmds = Array.isArray(cmd) ? Util.sortBatchCommands(cmd) : [cmd];\n        for (let i = 0; i < cmds.length; i += 1) {\n            const cmd = cmds[i];\n            const localOptions = Object.assign(Object.assign({}, options), ObjectExt.pick(cmd.options, this.options.applyOptionsList || []));\n            this.executeCommand(cmd, false, localOptions);\n        }\n        this.freezed = false;\n    }\n    executeCommand(cmd, revert, options) {\n        const model = this.model;\n        // const cell = cmd.modelChange ? model : model.getCell(cmd.data.id!)\n        const cell = model.getCell(cmd.data.id);\n        const event = cmd.event;\n        if ((Util.isAddEvent(event) && revert) ||\n            (Util.isRemoveEvent(event) && !revert)) {\n            cell.remove(options);\n        }\n        else if ((Util.isAddEvent(event) && !revert) ||\n            (Util.isRemoveEvent(event) && revert)) {\n            const data = cmd.data;\n            if (data.node) {\n                model.addNode(data.props, options);\n            }\n            else if (data.edge) {\n                model.addEdge(data.props, options);\n            }\n        }\n        else if (Util.isChangeEvent(event)) {\n            const data = cmd.data;\n            const key = data.key;\n            if (key) {\n                const value = revert ? data.prev[key] : data.next[key];\n                cell.prop(key, value, options);\n            }\n        }\n        else {\n            const executeCommand = this.options.executeCommand;\n            if (executeCommand) {\n                FunctionExt.call(executeCommand, this, cmd, revert, options);\n            }\n        }\n    }\n    addCommand(event, args) {\n        if (this.freezed || this.disabled) {\n            return;\n        }\n        const eventArgs = args;\n        const options = eventArgs.options || {};\n        if (options.dryrun) {\n            return;\n        }\n        if ((Util.isAddEvent(event) && this.options.ignoreAdd) ||\n            (Util.isRemoveEvent(event) && this.options.ignoreRemove) ||\n            (Util.isChangeEvent(event) && this.options.ignoreChange)) {\n            return;\n        }\n        // before\n        // ------\n        const before = this.options.beforeAddCommand;\n        if (before != null &&\n            FunctionExt.call(before, this, event, args) === false) {\n            return;\n        }\n        if (event === 'cell:change:*') {\n            // eslint-disable-next-line\n            event = `cell:change:${eventArgs.key}`;\n        }\n        const cell = eventArgs.cell;\n        const isModelChange = Model.isModel(cell);\n        let cmd;\n        if (this.batchCommands) {\n            // In most cases we are working with same object, doing\n            // same action etc. translate an object piece by piece.\n            cmd = this.batchCommands[Math.max(this.lastBatchIndex, 0)];\n            // Check if we are start working with new object or performing different\n            // action with it. Note, that command is uninitialized when lastCmdIndex\n            // equals -1. In that case we are done, command we were looking for is\n            // already set\n            const diffId = (isModelChange && !cmd.modelChange) || cmd.data.id !== cell.id;\n            const diffName = cmd.event !== event;\n            if (this.lastBatchIndex >= 0 && (diffId || diffName)) {\n                // Trying to find command first, which was performing same\n                // action with the object as we are doing now with cell.\n                const index = this.batchCommands.findIndex((cmd) => ((isModelChange && cmd.modelChange) || cmd.data.id === cell.id) &&\n                    cmd.event === event);\n                if (index < 0 || Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n                    cmd = this.createCommand({ batch: true });\n                }\n                else {\n                    cmd = this.batchCommands[index];\n                    this.batchCommands.splice(index, 1);\n                }\n                this.batchCommands.push(cmd);\n                this.lastBatchIndex = this.batchCommands.length - 1;\n            }\n        }\n        else {\n            cmd = this.createCommand({ batch: false });\n        }\n        // add & remove\n        // ------------\n        if (Util.isAddEvent(event) || Util.isRemoveEvent(event)) {\n            const data = cmd.data;\n            cmd.event = event;\n            cmd.options = options;\n            data.id = cell.id;\n            data.props = ObjectExt.cloneDeep(cell.toJSON());\n            if (cell.isEdge()) {\n                data.edge = true;\n            }\n            else if (cell.isNode()) {\n                data.node = true;\n            }\n            return this.push(cmd, options);\n        }\n        // change:*\n        // --------\n        if (Util.isChangeEvent(event)) {\n            const key = args.key;\n            const data = cmd.data;\n            if (!cmd.batch || !cmd.event) {\n                // Do this only once. Set previous data and action (also\n                // serves as a flag so that we don't repeat this branche).\n                cmd.event = event;\n                cmd.options = options;\n                data.key = key;\n                if (data.prev == null) {\n                    data.prev = {};\n                }\n                data.prev[key] = ObjectExt.clone(cell.previous(key));\n                if (isModelChange) {\n                    cmd.modelChange = true;\n                }\n                else {\n                    data.id = cell.id;\n                }\n            }\n            if (data.next == null) {\n                data.next = {};\n            }\n            data.next[key] = ObjectExt.clone(cell.prop(key));\n            return this.push(cmd, options);\n        }\n        // others\n        // ------\n        const afterAddCommand = this.options.afterAddCommand;\n        if (afterAddCommand) {\n            FunctionExt.call(afterAddCommand, this, event, args, cmd);\n        }\n        this.push(cmd, options);\n    }\n    /**\n     * Gather multiple changes into a single command. These commands could\n     * be reverted with single `undo()` call. From the moment the function\n     * is called every change made on model is not stored into the undoStack.\n     * Changes are temporarily kept until `storeBatchCommand()` is called.\n     */\n    // eslint-disable-next-line\n    initBatchCommand(options) {\n        if (this.freezed) {\n            return;\n        }\n        if (this.batchCommands) {\n            this.batchLevel += 1;\n        }\n        else {\n            this.batchCommands = [this.createCommand({ batch: true })];\n            this.batchLevel = 0;\n            this.lastBatchIndex = -1;\n        }\n    }\n    /**\n     * Store changes temporarily kept in the undoStack. You have to call this\n     * function as many times as `initBatchCommand()` been called.\n     */\n    storeBatchCommand(options) {\n        if (this.freezed) {\n            return;\n        }\n        if (this.batchCommands && this.batchLevel <= 0) {\n            const cmds = this.filterBatchCommand(this.batchCommands);\n            if (cmds.length > 0) {\n                this.redoStack = [];\n                this.undoStack.push(cmds);\n                this.notify('add', cmds, options);\n            }\n            this.batchCommands = null;\n            this.lastBatchIndex = -1;\n            this.batchLevel = 0;\n        }\n        else if (this.batchCommands && this.batchLevel > 0) {\n            this.batchLevel -= 1;\n        }\n    }\n    filterBatchCommand(batchCommands) {\n        let cmds = batchCommands.slice();\n        const result = [];\n        while (cmds.length > 0) {\n            const cmd = cmds.shift();\n            const evt = cmd.event;\n            const id = cmd.data.id;\n            if (evt != null && (id != null || cmd.modelChange)) {\n                if (Util.isAddEvent(evt)) {\n                    const index = cmds.findIndex((c) => Util.isRemoveEvent(c.event) && c.data.id === id);\n                    if (index >= 0) {\n                        cmds = cmds.filter((c, i) => index < i || c.data.id !== id);\n                        continue;\n                    }\n                }\n                else if (Util.isRemoveEvent(evt)) {\n                    const index = cmds.findIndex((c) => Util.isAddEvent(c.event) && c.data.id === id);\n                    if (index >= 0) {\n                        cmds.splice(index, 1);\n                        continue;\n                    }\n                }\n                else if (Util.isChangeEvent(evt)) {\n                    const data = cmd.data;\n                    if (ObjectExt.isEqual(data.prev, data.next)) {\n                        continue;\n                    }\n                }\n                else {\n                    // pass\n                }\n                result.push(cmd);\n            }\n        }\n        return result;\n    }\n    notify(event, cmd, options) {\n        const cmds = cmd == null ? null : Array.isArray(cmd) ? cmd : [cmd];\n        this.emit(event, { cmds, options });\n        this.emit('change', { cmds, options });\n    }\n    push(cmd, options) {\n        this.redoStack = [];\n        if (cmd.batch) {\n            this.lastBatchIndex = Math.max(this.lastBatchIndex, 0);\n            this.emit('batch', { cmd, options });\n        }\n        else {\n            this.undoStack.push(cmd);\n            this.notify('add', cmd, options);\n        }\n    }\n}\n__decorate([\n    Basecoat.dispose()\n], HistoryManager.prototype, \"dispose\", null);\n(function (HistoryManager) {\n    /**\n     * Runs a set of callbacks to determine if a command is valid. This is\n     * useful for checking if a certain action in your application does\n     * lead to an invalid state of the graph.\n     */\n    class Validator extends Basecoat {\n        constructor(options) {\n            super();\n            this.map = {};\n            this.command = options.history;\n            this.cancelInvalid = options.cancelInvalid !== false;\n            this.command.on('add', this.onCommandAdded, this);\n        }\n        onCommandAdded({ cmds }) {\n            return Array.isArray(cmds)\n                ? cmds.every((cmd) => this.isValidCommand(cmd))\n                : this.isValidCommand(cmds);\n        }\n        isValidCommand(cmd) {\n            if (cmd.options && cmd.options.validation === false) {\n                return true;\n            }\n            const callbacks = (cmd.event && this.map[cmd.event]) || [];\n            let handoverErr = null;\n            callbacks.forEach((routes) => {\n                let i = 0;\n                const rollup = (err) => {\n                    const fn = routes[i];\n                    i += 1;\n                    try {\n                        if (fn) {\n                            fn(err, cmd, rollup);\n                        }\n                        else {\n                            handoverErr = err;\n                            return;\n                        }\n                    }\n                    catch (err) {\n                        rollup(err);\n                    }\n                };\n                rollup(handoverErr);\n            });\n            if (handoverErr) {\n                if (this.cancelInvalid) {\n                    this.command.cancel();\n                }\n                this.emit('invalid', { err: handoverErr });\n                return false;\n            }\n            return true;\n        }\n        validate(events, ...callbacks) {\n            const evts = Array.isArray(events) ? events : events.split(/\\s+/);\n            callbacks.forEach((callback) => {\n                if (typeof callback !== 'function') {\n                    throw new Error(`${evts.join(' ')} requires callback functions.`);\n                }\n            });\n            evts.forEach((event) => {\n                if (this.map[event] == null) {\n                    this.map[event] = [];\n                }\n                this.map[event].push(callbacks);\n            });\n            return this;\n        }\n        dispose() {\n            this.command.off('add', this.onCommandAdded, this);\n        }\n    }\n    __decorate([\n        Basecoat.dispose()\n    ], Validator.prototype, \"dispose\", null);\n    HistoryManager.Validator = Validator;\n})(HistoryManager || (HistoryManager = {}));\nvar Util;\n(function (Util) {\n    function isAddEvent(event) {\n        return event === 'cell:added';\n    }\n    Util.isAddEvent = isAddEvent;\n    function isRemoveEvent(event) {\n        return event === 'cell:removed';\n    }\n    Util.isRemoveEvent = isRemoveEvent;\n    function isChangeEvent(event) {\n        return event != null && event.startsWith('cell:change:');\n    }\n    Util.isChangeEvent = isChangeEvent;\n    function getOptions(options) {\n        const { graph } = options, others = __rest(options, [\"graph\"]);\n        const reservedNames = [\n            'cell:added',\n            'cell:removed',\n            'cell:change:*',\n        ];\n        const batchEvents = [\n            'batch:start',\n            'batch:stop',\n        ];\n        const eventNames = options.eventNames\n            ? options.eventNames.filter((event) => !(Util.isChangeEvent(event) ||\n                reservedNames.includes(event) ||\n                batchEvents.includes(event)))\n            : reservedNames;\n        return Object.assign(Object.assign({}, others), { eventNames, applyOptionsList: options.applyOptionsList || ['propertyPath'], revertOptionsList: options.revertOptionsList || ['propertyPath'] });\n    }\n    Util.getOptions = getOptions;\n    function sortBatchCommands(cmds) {\n        const results = [];\n        for (let i = 0, ii = cmds.length; i < ii; i += 1) {\n            const cmd = cmds[i];\n            let index = null;\n            if (Util.isAddEvent(cmd.event)) {\n                const id = cmd.data.id;\n                for (let j = 0; j < i; j += 1) {\n                    if (cmds[j].data.id === id) {\n                        index = j;\n                        break;\n                    }\n                }\n            }\n            if (index !== null) {\n                results.splice(index, 0, cmd);\n            }\n            else {\n                results.push(cmd);\n            }\n        }\n        return results;\n    }\n    Util.sortBatchCommands = sortBatchCommands;\n})(Util || (Util = {}));\n//# sourceMappingURL=history.js.map"]},"metadata":{},"sourceType":"module"}