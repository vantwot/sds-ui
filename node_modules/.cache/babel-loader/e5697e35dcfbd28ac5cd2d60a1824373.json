{"ast":null,"code":"import { Line } from '../line';\nimport { Curve } from '../curve';\nimport { Point } from '../point';\nimport { LineTo } from './lineto';\nimport { Segment } from './segment';\nexport class MoveTo extends Segment {\n  constructor(x, y) {\n    super();\n    this.isVisible = false;\n    this.isSubpathStart = true;\n\n    if (Line.isLine(x) || Curve.isCurve(x)) {\n      this.endPoint = x.end.clone().round(2);\n    } else {\n      this.endPoint = Point.create(x, y).round(2);\n    }\n  }\n\n  get start() {\n    throw new Error('Illegal access. Moveto segments should not need a start property.');\n  }\n\n  get type() {\n    return 'M';\n  }\n\n  bbox() {\n    return null;\n  }\n\n  closestPoint() {\n    return this.end.clone();\n  }\n\n  closestPointLength() {\n    return 0;\n  }\n\n  closestPointNormalizedLength() {\n    return 0;\n  }\n\n  closestPointT() {\n    return 1;\n  }\n\n  closestPointTangent() {\n    return null;\n  }\n\n  length() {\n    return 0;\n  }\n\n  lengthAtT() {\n    return 0;\n  }\n\n  divideAt() {\n    return [this.clone(), this.clone()];\n  }\n\n  divideAtLength() {\n    return [this.clone(), this.clone()];\n  }\n\n  getSubdivisions() {\n    return [];\n  }\n\n  pointAt() {\n    return this.end.clone();\n  }\n\n  pointAtLength() {\n    return this.end.clone();\n  }\n\n  pointAtT() {\n    return this.end.clone();\n  }\n\n  tangentAt() {\n    return null;\n  }\n\n  tangentAtLength() {\n    return null;\n  }\n\n  tangentAtT() {\n    return null;\n  }\n\n  isDifferentiable() {\n    return false;\n  }\n\n  scale(sx, sy, origin) {\n    this.end.scale(sx, sy, origin);\n    return this;\n  }\n\n  rotate(angle, origin) {\n    this.end.rotate(angle, origin);\n    return this;\n  }\n\n  translate(tx, ty) {\n    if (typeof tx === 'number') {\n      this.end.translate(tx, ty);\n    } else {\n      this.end.translate(tx);\n    }\n\n    return this;\n  }\n\n  clone() {\n    return new MoveTo(this.end);\n  }\n\n  equals(s) {\n    return this.type === s.type && this.end.equals(s.end);\n  }\n\n  toJSON() {\n    return {\n      type: this.type,\n      end: this.end.toJSON()\n    };\n  }\n\n  serialize() {\n    const end = this.end;\n    return `${this.type} ${end.x} ${end.y}`;\n  }\n\n}\n\n(function (MoveTo) {\n  function create() {\n    const len = arguments.length;\n    const arg0 = arguments.length <= 0 ? undefined : arguments[0]; // line provided\n\n    if (Line.isLine(arg0)) {\n      return new MoveTo(arg0);\n    } // curve provided\n\n\n    if (Curve.isCurve(arg0)) {\n      return new MoveTo(arg0);\n    } // points provided\n\n\n    if (Point.isPointLike(arg0)) {\n      if (len === 1) {\n        return new MoveTo(arg0);\n      } // this is a moveto-with-subsequent-poly-line segment\n\n\n      const segments = []; // points come one by one\n\n      for (let i = 0; i < len; i += 1) {\n        if (i === 0) {\n          segments.push(new MoveTo(i < 0 || arguments.length <= i ? undefined : arguments[i]));\n        } else {\n          segments.push(new LineTo(i < 0 || arguments.length <= i ? undefined : arguments[i]));\n        }\n      }\n\n      return segments;\n    } // coordinates provided\n\n\n    if (len === 2) {\n      return new MoveTo(+(arguments.length <= 0 ? undefined : arguments[0]), +(arguments.length <= 1 ? undefined : arguments[1]));\n    } // this is a moveto-with-subsequent-poly-line segment\n\n\n    const segments = [];\n\n    for (let i = 0; i < len; i += 2) {\n      const x = +(i < 0 || arguments.length <= i ? undefined : arguments[i]);\n      const y = +(i + 1 < 0 || arguments.length <= i + 1 ? undefined : arguments[i + 1]);\n\n      if (i === 0) {\n        segments.push(new MoveTo(x, y));\n      } else {\n        segments.push(new LineTo(x, y));\n      }\n    }\n\n    return segments;\n  }\n\n  MoveTo.create = create;\n})(MoveTo || (MoveTo = {}));","map":{"version":3,"sources":["../../../src/geometry/path/moveto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { Line } from '../line';\nimport { Curve } from '../curve';\nimport { Point } from '../point';\nimport { LineTo } from './lineto';\nimport { Segment } from './segment';\nexport class MoveTo extends Segment {\n    constructor(x, y) {\n        super();\n        this.isVisible = false;\n        this.isSubpathStart = true;\n        if (Line.isLine(x) || Curve.isCurve(x)) {\n            this.endPoint = x.end.clone().round(2);\n        }\n        else {\n            this.endPoint = Point.create(x, y).round(2);\n        }\n    }\n    get start() {\n        throw new Error('Illegal access. Moveto segments should not need a start property.');\n    }\n    get type() {\n        return 'M';\n    }\n    bbox() {\n        return null;\n    }\n    closestPoint() {\n        return this.end.clone();\n    }\n    closestPointLength() {\n        return 0;\n    }\n    closestPointNormalizedLength() {\n        return 0;\n    }\n    closestPointT() {\n        return 1;\n    }\n    closestPointTangent() {\n        return null;\n    }\n    length() {\n        return 0;\n    }\n    lengthAtT() {\n        return 0;\n    }\n    divideAt() {\n        return [this.clone(), this.clone()];\n    }\n    divideAtLength() {\n        return [this.clone(), this.clone()];\n    }\n    getSubdivisions() {\n        return [];\n    }\n    pointAt() {\n        return this.end.clone();\n    }\n    pointAtLength() {\n        return this.end.clone();\n    }\n    pointAtT() {\n        return this.end.clone();\n    }\n    tangentAt() {\n        return null;\n    }\n    tangentAtLength() {\n        return null;\n    }\n    tangentAtT() {\n        return null;\n    }\n    isDifferentiable() {\n        return false;\n    }\n    scale(sx, sy, origin) {\n        this.end.scale(sx, sy, origin);\n        return this;\n    }\n    rotate(angle, origin) {\n        this.end.rotate(angle, origin);\n        return this;\n    }\n    translate(tx, ty) {\n        if (typeof tx === 'number') {\n            this.end.translate(tx, ty);\n        }\n        else {\n            this.end.translate(tx);\n        }\n        return this;\n    }\n    clone() {\n        return new MoveTo(this.end);\n    }\n    equals(s) {\n        return this.type === s.type && this.end.equals(s.end);\n    }\n    toJSON() {\n        return {\n            type: this.type,\n            end: this.end.toJSON(),\n        };\n    }\n    serialize() {\n        const end = this.end;\n        return `${this.type} ${end.x} ${end.y}`;\n    }\n}\n(function (MoveTo) {\n    function create(...args) {\n        const len = args.length;\n        const arg0 = args[0];\n        // line provided\n        if (Line.isLine(arg0)) {\n            return new MoveTo(arg0);\n        }\n        // curve provided\n        if (Curve.isCurve(arg0)) {\n            return new MoveTo(arg0);\n        }\n        // points provided\n        if (Point.isPointLike(arg0)) {\n            if (len === 1) {\n                return new MoveTo(arg0);\n            }\n            // this is a moveto-with-subsequent-poly-line segment\n            const segments = [];\n            // points come one by one\n            for (let i = 0; i < len; i += 1) {\n                if (i === 0) {\n                    segments.push(new MoveTo(args[i]));\n                }\n                else {\n                    segments.push(new LineTo(args[i]));\n                }\n            }\n            return segments;\n        }\n        // coordinates provided\n        if (len === 2) {\n            return new MoveTo(+args[0], +args[1]);\n        }\n        // this is a moveto-with-subsequent-poly-line segment\n        const segments = [];\n        for (let i = 0; i < len; i += 2) {\n            const x = +args[i];\n            const y = +args[i + 1];\n            if (i === 0) {\n                segments.push(new MoveTo(x, y));\n            }\n            else {\n                segments.push(new LineTo(x, y));\n            }\n        }\n        return segments;\n    }\n    MoveTo.create = create;\n})(MoveTo || (MoveTo = {}));\n//# sourceMappingURL=moveto.js.map"]},"metadata":{},"sourceType":"module"}