{"ast":null,"code":"import _classCallCheck from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _inherits from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"/home/manolo/sds-ui/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";\n\nvar __decorate = this && this.__decorate || function (decorators, target, key, desc) {\n  var c = arguments.length,\n      r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc,\n      d;\n  if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);else for (var i = decorators.length - 1; i >= 0; i--) {\n    if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n  }\n  return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\n\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n\n  for (var p in s) {\n    if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  }\n\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\n\nimport { ArrayExt, FunctionExt } from '../../util';\nimport { Rectangle, Angle } from '../../geometry';\nimport { View } from '../../view/view';\nexport var Snapline = /*#__PURE__*/function (_View) {\n  _inherits(Snapline, _View);\n\n  var _super = _createSuper(Snapline);\n\n  function Snapline(options) {\n    var _this;\n\n    _classCallCheck(this, Snapline);\n\n    _this = _super.call(this);\n\n    var graph = options.graph,\n        others = __rest(options, [\"graph\"]);\n\n    _this.graph = graph;\n    _this.options = Object.assign({\n      tolerance: 10\n    }, others);\n\n    _this.render();\n\n    _this.parseFilter();\n\n    if (!_this.disabled) {\n      _this.startListening();\n    }\n\n    return _this;\n  }\n\n  _createClass(Snapline, [{\n    key: \"model\",\n    get: function get() {\n      return this.graph.model;\n    }\n  }, {\n    key: \"containerClassName\",\n    get: function get() {\n      return this.prefixClassName('widget-snapline');\n    }\n  }, {\n    key: \"verticalClassName\",\n    get: function get() {\n      return \"\".concat(this.containerClassName, \"-vertical\");\n    }\n  }, {\n    key: \"horizontalClassName\",\n    get: function get() {\n      return \"\".concat(this.containerClassName, \"-horizontal\");\n    }\n  }, {\n    key: \"disabled\",\n    get: function get() {\n      return this.options.enabled !== true || this.graph.options.snapline.enabled !== true;\n    }\n  }, {\n    key: \"enable\",\n    value: function enable() {\n      if (this.disabled) {\n        this.options.enabled = true;\n        this.graph.options.snapline.enabled = true;\n        this.startListening();\n      }\n    }\n  }, {\n    key: \"disable\",\n    value: function disable() {\n      if (!this.disabled) {\n        this.options.enabled = false;\n        this.graph.options.snapline.enabled = false;\n        this.stopListening();\n      }\n    }\n  }, {\n    key: \"setFilter\",\n    value: function setFilter(filter) {\n      this.options.filter = filter;\n      this.parseFilter();\n    }\n  }, {\n    key: \"render\",\n    value: function render() {\n      this.container = document.createElement('div');\n      this.$container = this.$(this.container);\n      this.$horizontal = this.$(document.createElement('div')).addClass(this.horizontalClassName);\n      this.$vertical = this.$(document.createElement('div')).addClass(this.verticalClassName);\n      this.$container.hide().addClass(this.containerClassName).append([this.$horizontal, this.$vertical]);\n\n      if (this.options.className) {\n        this.$container.addClass(this.options.className);\n      }\n    }\n  }, {\n    key: \"startListening\",\n    value: function startListening() {\n      this.stopListening();\n      this.graph.on('node:mousedown', this.captureCursorOffset, this);\n      this.graph.on('node:mousemove', this.snapOnMoving, this);\n      this.model.on('batch:stop', this.onBatchStop, this);\n      this.delegateDocumentEvents({\n        mouseup: 'hide',\n        touchend: 'hide'\n      });\n    }\n  }, {\n    key: \"stopListening\",\n    value: function stopListening() {\n      this.graph.off('node:mousedown', this.captureCursorOffset, this);\n      this.graph.off('node:mousemove', this.snapOnMoving, this);\n      this.model.off('batch:stop', this.onBatchStop, this);\n      this.undelegateDocumentEvents();\n    }\n  }, {\n    key: \"parseFilter\",\n    value: function parseFilter() {\n      var _this2 = this;\n\n      this.filterShapes = {};\n      this.filterCells = {};\n      this.filterFunction = null;\n      var filter = this.options.filter;\n\n      if (Array.isArray(filter)) {\n        filter.forEach(function (item) {\n          if (typeof item === 'string') {\n            _this2.filterShapes[item] = true;\n          } else {\n            _this2.filterCells[item.id] = true;\n          }\n        });\n      } else if (typeof filter === 'function') {\n        this.filterFunction = filter;\n      }\n    }\n  }, {\n    key: \"onBatchStop\",\n    value: function onBatchStop(_ref) {\n      var name = _ref.name,\n          data = _ref.data;\n\n      if (name === 'resize') {\n        this.snapOnResizing(data.cell, data);\n      }\n    }\n  }, {\n    key: \"captureCursorOffset\",\n    value: function captureCursorOffset(_ref2) {\n      var view = _ref2.view,\n          x = _ref2.x,\n          y = _ref2.y;\n      var targetView = view.getDelegatedView();\n\n      if (targetView && this.isNodeMovable(targetView)) {\n        var pos = view.cell.getPosition();\n        this.offset = {\n          x: x - pos.x,\n          y: y - pos.y\n        };\n      }\n    }\n  }, {\n    key: \"isNodeMovable\",\n    value: function isNodeMovable(view) {\n      return view && view.cell.isNode() && view.can('nodeMovable');\n    }\n  }, {\n    key: \"snapOnResizing\",\n    value: function snapOnResizing(node, options) {\n      var _this3 = this;\n\n      if (this.options.resizing && !options.snapped && options.ui && options.direction && options.trueDirection) {\n        var view = this.graph.renderer.findViewByCell(node);\n\n        if (view && view.cell.isNode()) {\n          var nodeBbox = node.getBBox();\n          var nodeBBoxRotated = nodeBbox.bbox(node.getAngle());\n          var nodeTopLeft = nodeBBoxRotated.getTopLeft();\n          var nodeBottomRight = nodeBBoxRotated.getBottomRight();\n          var angle = Angle.normalize(node.getAngle());\n          var tolerance = this.options.tolerance || 0;\n          var verticalLeft;\n          var verticalTop;\n          var verticalHeight;\n          var horizontalTop;\n          var horizontalLeft;\n          var horizontalWidth;\n          var snapOrigin = {\n            vertical: 0,\n            horizontal: 0\n          };\n          var direction = options.direction;\n          var trueDirection = options.trueDirection;\n          var relativeDirection = options.relativeDirection;\n\n          if (trueDirection.indexOf('right') !== -1) {\n            snapOrigin.vertical = nodeBottomRight.x;\n          } else {\n            snapOrigin.vertical = nodeTopLeft.x;\n          }\n\n          if (trueDirection.indexOf('bottom') !== -1) {\n            snapOrigin.horizontal = nodeBottomRight.y;\n          } else {\n            snapOrigin.horizontal = nodeTopLeft.y;\n          }\n\n          this.model.getNodes().some(function (cell) {\n            if (_this3.isIgnored(node, cell)) {\n              return false;\n            }\n\n            var snapBBox = cell.getBBox().bbox(cell.getAngle());\n            var snapTopLeft = snapBBox.getTopLeft();\n            var snapBottomRight = snapBBox.getBottomRight();\n            var groups = {\n              vertical: [snapTopLeft.x, snapBottomRight.x],\n              horizontal: [snapTopLeft.y, snapBottomRight.y]\n            };\n            var distances = {};\n            Object.keys(groups).forEach(function (k) {\n              var key = k;\n              var list = groups[key].map(function (value) {\n                return {\n                  position: value,\n                  distance: Math.abs(value - snapOrigin[key])\n                };\n              }).filter(function (item) {\n                return item.distance <= tolerance;\n              });\n              distances[key] = ArrayExt.sortBy(list, function (item) {\n                return item.distance;\n              });\n            });\n\n            if (verticalLeft == null && distances.vertical.length > 0) {\n              verticalLeft = distances.vertical[0].position;\n              verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n              verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n            }\n\n            if (horizontalTop == null && distances.horizontal.length > 0) {\n              horizontalTop = distances.horizontal[0].position;\n              horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n              horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n            }\n\n            return verticalLeft != null && horizontalTop != null;\n          });\n          this.hide();\n          var dx = 0;\n          var dy = 0;\n\n          if (horizontalTop != null || verticalLeft != null) {\n            if (verticalLeft != null) {\n              dx = trueDirection.indexOf('right') !== -1 ? verticalLeft - nodeBottomRight.x : nodeTopLeft.x - verticalLeft;\n            }\n\n            if (horizontalTop != null) {\n              dy = trueDirection.indexOf('bottom') !== -1 ? horizontalTop - nodeBottomRight.y : nodeTopLeft.y - horizontalTop;\n            }\n          }\n\n          var dWidth = 0;\n          var dHeight = 0;\n\n          if (angle % 90 === 0) {\n            if (angle === 90 || angle === 270) {\n              dWidth = dy;\n              dHeight = dx;\n            } else {\n              dWidth = dx;\n              dHeight = dy;\n            }\n          } else {\n            var quadrant = angle >= 0 && angle < 90 ? 1 : angle >= 90 && angle < 180 ? 4 : angle >= 180 && angle < 270 ? 3 : 2;\n\n            if (horizontalTop != null && verticalLeft != null) {\n              if (dx < dy) {\n                dy = 0;\n                horizontalTop = undefined;\n              } else {\n                dx = 0;\n                verticalLeft = undefined;\n              }\n            }\n\n            var rad = Angle.toRad(angle % 90);\n\n            if (dx) {\n              dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);\n            }\n\n            if (dy) {\n              dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);\n            }\n\n            var quadrant13 = quadrant === 1 || quadrant === 3;\n\n            switch (relativeDirection) {\n              case 'top':\n              case 'bottom':\n                dHeight = dy ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n                break;\n\n              case 'left':\n              case 'right':\n                dWidth = dx ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad)) : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n                break;\n\n              default:\n                break;\n            }\n          }\n\n          switch (relativeDirection) {\n            case 'top':\n            case 'bottom':\n              dWidth = 0;\n              break;\n\n            case 'left':\n            case 'right':\n              dHeight = 0;\n              break;\n\n            default:\n              break;\n          }\n\n          var gridSize = this.graph.getGridSize();\n          var newWidth = Math.max(nodeBbox.width + dWidth, gridSize);\n          var newHeight = Math.max(nodeBbox.height + dHeight, gridSize);\n\n          if (options.minWidth && options.minWidth > gridSize) {\n            newWidth = Math.max(newWidth, options.minWidth);\n          }\n\n          if (options.minHeight && options.minHeight > gridSize) {\n            newHeight = Math.max(newHeight, options.minHeight);\n          }\n\n          if (options.maxWidth) {\n            newWidth = Math.min(newWidth, options.maxWidth);\n          }\n\n          if (options.maxHeight) {\n            newHeight = Math.min(newHeight, options.maxHeight);\n          }\n\n          if (options.preserveAspectRatio) {\n            if (dHeight < dWidth) {\n              newHeight = newWidth * (nodeBbox.height / nodeBbox.width);\n            } else {\n              newWidth = newHeight * (nodeBbox.width / nodeBbox.height);\n            }\n          }\n\n          if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {\n            node.resize(newWidth, newHeight, {\n              direction: direction,\n              relativeDirection: relativeDirection,\n              trueDirection: trueDirection,\n              snapped: true,\n              snaplines: this.cid,\n              restrict: this.graph.hook.getRestrictArea(view)\n            });\n\n            if (verticalHeight) {\n              verticalHeight += newHeight - nodeBbox.height;\n            }\n\n            if (horizontalWidth) {\n              horizontalWidth += newWidth - nodeBbox.width;\n            }\n          }\n\n          var newRotatedBBox = node.getBBox().bbox(angle);\n\n          if (verticalLeft && Math.abs(newRotatedBBox.x - verticalLeft) > 1 && Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {\n            verticalLeft = undefined;\n          }\n\n          if (horizontalTop && Math.abs(newRotatedBBox.y - horizontalTop) > 1 && Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {\n            horizontalTop = undefined;\n          }\n\n          this.update({\n            verticalLeft: verticalLeft,\n            verticalTop: verticalTop,\n            verticalHeight: verticalHeight,\n            horizontalTop: horizontalTop,\n            horizontalLeft: horizontalLeft,\n            horizontalWidth: horizontalWidth\n          });\n        }\n      }\n    }\n  }, {\n    key: \"snapOnMoving\",\n    value: function snapOnMoving(_ref3) {\n      var _this4 = this;\n\n      var view = _ref3.view,\n          e = _ref3.e,\n          x = _ref3.x,\n          y = _ref3.y;\n      var targetView = view.getEventData(e).delegatedView || view;\n\n      if (!this.isNodeMovable(targetView)) {\n        return;\n      }\n\n      var node = targetView.cell;\n      var size = node.getSize();\n      var position = node.getPosition();\n      var cellBBox = new Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);\n      var angle = node.getAngle();\n      var nodeCenter = cellBBox.getCenter();\n      var nodeBBoxRotated = cellBBox.bbox(angle);\n      var nodeTopLeft = nodeBBoxRotated.getTopLeft();\n      var nodeBottomRight = nodeBBoxRotated.getBottomRight();\n      var distance = this.options.tolerance || 0;\n      var verticalLeft;\n      var verticalTop;\n      var verticalHeight;\n      var horizontalTop;\n      var horizontalLeft;\n      var horizontalWidth;\n      var verticalFix = 0;\n      var horizontalFix = 0;\n      this.model.getNodes().some(function (targetNode) {\n        if (_this4.isIgnored(node, targetNode)) {\n          return false;\n        }\n\n        var snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());\n        var snapCenter = snapBBox.getCenter();\n        var snapTopLeft = snapBBox.getTopLeft();\n        var snapBottomRight = snapBBox.getBottomRight();\n\n        if (verticalLeft == null) {\n          if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {\n            verticalLeft = snapCenter.x;\n            verticalFix = 0.5;\n          } else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {\n            verticalLeft = snapTopLeft.x;\n            verticalFix = 0;\n          } else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {\n            verticalLeft = snapTopLeft.x;\n            verticalFix = 1;\n          } else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {\n            verticalLeft = snapBottomRight.x;\n            verticalFix = 1;\n          } else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {\n            verticalLeft = snapBottomRight.x;\n          }\n\n          if (verticalLeft != null) {\n            verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n            verticalHeight = Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n          }\n        }\n\n        if (horizontalTop == null) {\n          if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {\n            horizontalTop = snapCenter.y;\n            horizontalFix = 0.5;\n          } else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {\n            horizontalTop = snapTopLeft.y;\n          } else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {\n            horizontalTop = snapTopLeft.y;\n            horizontalFix = 1;\n          } else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {\n            horizontalTop = snapBottomRight.y;\n            horizontalFix = 1;\n          } else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {\n            horizontalTop = snapBottomRight.y;\n          }\n\n          if (horizontalTop != null) {\n            horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n            horizontalWidth = Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n          }\n        }\n\n        return verticalLeft != null && horizontalTop != null;\n      });\n      this.hide();\n\n      if (horizontalTop != null || verticalLeft != null) {\n        if (horizontalTop != null) {\n          nodeBBoxRotated.y = horizontalTop - horizontalFix * nodeBBoxRotated.height;\n        }\n\n        if (verticalLeft != null) {\n          nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;\n        }\n\n        var newCenter = nodeBBoxRotated.getCenter();\n        var newX = newCenter.x - cellBBox.width / 2;\n        var newY = newCenter.y - cellBBox.height / 2;\n        var dx = newX - position.x;\n        var dy = newY - position.y;\n\n        if (dx !== 0 || dy !== 0) {\n          node.translate(dx, dy, {\n            snapped: true,\n            restrict: this.graph.hook.getRestrictArea(targetView)\n          });\n\n          if (horizontalWidth) {\n            horizontalWidth += dx;\n          }\n\n          if (verticalHeight) {\n            verticalHeight += dy;\n          }\n        }\n\n        this.update({\n          verticalLeft: verticalLeft,\n          verticalTop: verticalTop,\n          verticalHeight: verticalHeight,\n          horizontalTop: horizontalTop,\n          horizontalLeft: horizontalLeft,\n          horizontalWidth: horizontalWidth\n        });\n      }\n    }\n  }, {\n    key: \"isIgnored\",\n    value: function isIgnored(snapNode, targetNode) {\n      return targetNode.id === snapNode.id || targetNode.isDescendantOf(snapNode) || this.filterShapes[targetNode.shape] || this.filterCells[targetNode.id] || this.filterFunction && FunctionExt.call(this.filterFunction, this.graph, targetNode);\n    }\n  }, {\n    key: \"update\",\n    value: function update(metadata) {\n      var ctm = this.graph.matrix();\n      var sx = ctm.a;\n      var sy = ctm.d;\n      var tx = ctm.e;\n      var ty = ctm.f;\n      var sharp = this.options.sharp;\n      var hasScroller = this.graph.scroller.widget != null;\n\n      if (metadata.horizontalTop) {\n        this.$horizontal.css({\n          top: metadata.horizontalTop * sy + ty,\n          left: sharp ? metadata.horizontalLeft * sx + tx : hasScroller ? '-300%' : 0,\n          width: sharp ? metadata.horizontalWidth * sx : hasScroller ? '700%' : '100%'\n        }).show();\n      } else {\n        this.$horizontal.hide();\n      }\n\n      if (metadata.verticalLeft) {\n        this.$vertical.css({\n          left: metadata.verticalLeft * sx + tx,\n          top: sharp ? metadata.verticalTop * sy + ty : hasScroller ? '-300%' : 0,\n          height: sharp ? metadata.verticalHeight * sy : hasScroller ? '700%' : '100%'\n        }).show();\n      } else {\n        this.$vertical.hide();\n      }\n\n      this.show();\n    }\n  }, {\n    key: \"resetTimer\",\n    value: function resetTimer() {\n      if (this.timer) {\n        clearTimeout(this.timer);\n        this.timer = null;\n      }\n    }\n  }, {\n    key: \"show\",\n    value: function show() {\n      this.$container.show();\n      this.resetTimer();\n\n      if (this.container.parentNode == null) {\n        this.graph.container.appendChild(this.container);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"hide\",\n    value: function hide() {\n      var _this5 = this;\n\n      this.$container.hide();\n      this.resetTimer();\n      var clean = this.options.clean;\n      var delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;\n\n      if (delay > 0) {\n        this.timer = window.setTimeout(function () {\n          _this5.unmount();\n        }, delay);\n      }\n\n      return this;\n    }\n  }, {\n    key: \"onRemove\",\n    value: function onRemove() {\n      this.stopListening();\n      this.hide();\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.remove();\n    }\n  }]);\n\n  return Snapline;\n}(View);\n\n__decorate([View.dispose()], Snapline.prototype, \"dispose\", null);","map":{"version":3,"sources":["../../../src/addon/snapline/index.ts"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAS,QAAT,EAAmB,WAAnB,QAAsC,YAAtC;AAEA,SAAgB,SAAhB,EAA2B,KAA3B,QAAwC,gBAAxC;AAGA,SAAS,IAAT,QAAqB,iBAArB;AAMA,WAAa,QAAb;AAAA;;AAAA;;AA4BE,oBAAY,OAAZ,EAAwD;AAAA;;AAAA;;AACtD;;AAEM,QAAE,KAAF,GAAuB,OAAvB,CAAE,KAAF;AAAA,QAAY,MAAZ,GAAkB,MAAA,CAAK,OAAL,EAAlB,CAAA,OAAA,CAAkB,CAAlB;;AACN,UAAK,KAAL,GAAa,KAAb;AACA,UAAK,OAAL,GAAY,MAAA,CAAA,MAAA,CAAA;AAAK,MAAA,SAAS,EAAE;AAAhB,KAAA,EAAuB,MAAvB,CAAZ;;AACA,UAAK,MAAL;;AACA,UAAK,WAAL;;AACA,QAAI,CAAC,MAAK,QAAV,EAAoB;AAClB,YAAK,cAAL;AACD;;AAVqD;AAWvD;;AAvCH;AAAA;AAAA,SAYE,eAAmB;AACjB,aAAO,KAAK,KAAL,CAAW,KAAlB;AACD;AAdH;AAAA;AAAA,SAgBE,eAAgC;AAC9B,aAAO,KAAK,eAAL,CAAqB,iBAArB,CAAP;AACD;AAlBH;AAAA;AAAA,SAoBE,eAA+B;AAC7B,uBAAU,KAAK,kBAAf;AACD;AAtBH;AAAA;AAAA,SAwBE,eAAiC;AAC/B,uBAAU,KAAK,kBAAf;AACD;AA1BH;AAAA;AAAA,SAyCE,eAAmB;AACjB,aACE,KAAK,OAAL,CAAa,OAAb,KAAyB,IAAzB,IACA,KAAK,KAAL,CAAW,OAAX,CAAmB,QAAnB,CAA4B,OAA5B,KAAwC,IAF1C;AAID;AA9CH;AAAA;AAAA,WAgDE,kBAAM;AACJ,UAAI,KAAK,QAAT,EAAmB;AACjB,aAAK,OAAL,CAAa,OAAb,GAAuB,IAAvB;AACA,aAAK,KAAL,CAAW,OAAX,CAAmB,QAAnB,CAA4B,OAA5B,GAAsC,IAAtC;AACA,aAAK,cAAL;AACD;AACF;AAtDH;AAAA;AAAA,WAwDE,mBAAO;AACL,UAAI,CAAC,KAAK,QAAV,EAAoB;AAClB,aAAK,OAAL,CAAa,OAAb,GAAuB,KAAvB;AACA,aAAK,KAAL,CAAW,OAAX,CAAmB,QAAnB,CAA4B,OAA5B,GAAsC,KAAtC;AACA,aAAK,aAAL;AACD;AACF;AA9DH;AAAA;AAAA,WAgEE,mBAAU,MAAV,EAAkC;AAChC,WAAK,OAAL,CAAa,MAAb,GAAsB,MAAtB;AACA,WAAK,WAAL;AACD;AAnEH;AAAA;AAAA,WAqEY,kBAAM;AACd,WAAK,SAAL,GAAiB,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAjB;AACA,WAAK,UAAL,GAAkB,KAAK,CAAL,CAAO,KAAK,SAAZ,CAAlB;AACA,WAAK,WAAL,GAAmB,KAAK,CAAL,CAAO,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAP,EAAsC,QAAtC,CACjB,KAAK,mBADY,CAAnB;AAGA,WAAK,SAAL,GAAiB,KAAK,CAAL,CAAO,QAAQ,CAAC,aAAT,CAAuB,KAAvB,CAAP,EAAsC,QAAtC,CACf,KAAK,iBADU,CAAjB;AAIA,WAAK,UAAL,CACG,IADH,GAEG,QAFH,CAEY,KAAK,kBAFjB,EAGG,MAHH,CAGU,CAAC,KAAK,WAAN,EAAmB,KAAK,SAAxB,CAHV;;AAKA,UAAI,KAAK,OAAL,CAAa,SAAjB,EAA4B;AAC1B,aAAK,UAAL,CAAgB,QAAhB,CAAyB,KAAK,OAAL,CAAa,SAAtC;AACD;AACF;AAvFH;AAAA;AAAA,WAyFY,0BAAc;AACtB,WAAK,aAAL;AACA,WAAK,KAAL,CAAW,EAAX,CAAc,gBAAd,EAAgC,KAAK,mBAArC,EAA0D,IAA1D;AACA,WAAK,KAAL,CAAW,EAAX,CAAc,gBAAd,EAAgC,KAAK,YAArC,EAAmD,IAAnD;AACA,WAAK,KAAL,CAAW,EAAX,CAAc,YAAd,EAA4B,KAAK,WAAjC,EAA8C,IAA9C;AACA,WAAK,sBAAL,CAA4B;AAC1B,QAAA,OAAO,EAAE,MADiB;AAE1B,QAAA,QAAQ,EAAE;AAFgB,OAA5B;AAID;AAlGH;AAAA;AAAA,WAoGY,yBAAa;AACrB,WAAK,KAAL,CAAW,GAAX,CAAe,gBAAf,EAAiC,KAAK,mBAAtC,EAA2D,IAA3D;AACA,WAAK,KAAL,CAAW,GAAX,CAAe,gBAAf,EAAiC,KAAK,YAAtC,EAAoD,IAApD;AACA,WAAK,KAAL,CAAW,GAAX,CAAe,YAAf,EAA6B,KAAK,WAAlC,EAA+C,IAA/C;AACA,WAAK,wBAAL;AACD;AAzGH;AAAA;AAAA,WA2GY,uBAAW;AAAA;;AACnB,WAAK,YAAL,GAAoB,EAApB;AACA,WAAK,WAAL,GAAmB,EAAnB;AACA,WAAK,cAAL,GAAsB,IAAtB;AACA,UAAM,MAAM,GAAG,KAAK,OAAL,CAAa,MAA5B;;AACA,UAAI,KAAK,CAAC,OAAN,CAAc,MAAd,CAAJ,EAA2B;AACzB,QAAA,MAAM,CAAC,OAAP,CAAe,UAAC,IAAD,EAAS;AACtB,cAAI,OAAO,IAAP,KAAgB,QAApB,EAA8B;AAC5B,YAAA,MAAI,CAAC,YAAL,CAAkB,IAAlB,IAA0B,IAA1B;AACD,WAFD,MAEO;AACL,YAAA,MAAI,CAAC,WAAL,CAAiB,IAAI,CAAC,EAAtB,IAA4B,IAA5B;AACD;AACF,SAND;AAOD,OARD,MAQO,IAAI,OAAO,MAAP,KAAkB,UAAtB,EAAkC;AACvC,aAAK,cAAL,GAAsB,MAAtB;AACD;AACF;AA3HH;AAAA;AAAA,WA6HY,2BAAyD;AAAA,UAA3C,IAA2C,QAA3C,IAA2C;AAAA,UAArC,IAAqC,QAArC,IAAqC;;AACjE,UAAI,IAAI,KAAK,QAAb,EAAuB;AACrB,aAAK,cAAL,CAAoB,IAAI,CAAC,IAAzB,EAA+B,IAA/B;AACD;AACF;AAjIH;AAAA;AAAA,WAmIE,oCAA+D;AAAA,UAAzC,IAAyC,SAAzC,IAAyC;AAAA,UAAnC,CAAmC,SAAnC,CAAmC;AAAA,UAAhC,CAAgC,SAAhC,CAAgC;AAC7D,UAAM,UAAU,GAAG,IAAI,CAAC,gBAAL,EAAnB;;AACA,UAAI,UAAU,IAAI,KAAK,aAAL,CAAmB,UAAnB,CAAlB,EAAkD;AAChD,YAAM,GAAG,GAAG,IAAI,CAAC,IAAL,CAAU,WAAV,EAAZ;AACA,aAAK,MAAL,GAAc;AACZ,UAAA,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC,CADC;AAEZ,UAAA,CAAC,EAAE,CAAC,GAAG,GAAG,CAAC;AAFC,SAAd;AAID;AACF;AA5IH;AAAA;AAAA,WA8IY,uBAAc,IAAd,EAA4B;AACpC,aAAO,IAAI,IAAI,IAAI,CAAC,IAAL,CAAU,MAAV,EAAR,IAA8B,IAAI,CAAC,GAAL,CAAS,aAAT,CAArC;AACD;AAhJH;AAAA;AAAA,WAkJY,wBAAe,IAAf,EAA2B,OAA3B,EAAsD;AAAA;;AAC9D,UACE,KAAK,OAAL,CAAa,QAAb,IACA,CAAC,OAAO,CAAC,OADT,IAEA,OAAO,CAAC,EAFR,IAGA,OAAO,CAAC,SAHR,IAIA,OAAO,CAAC,aALV,EAME;AACA,YAAM,IAAI,GAAG,KAAK,KAAL,CAAW,QAAX,CAAoB,cAApB,CAAmC,IAAnC,CAAb;;AACA,YAAI,IAAI,IAAI,IAAI,CAAC,IAAL,CAAU,MAAV,EAAZ,EAAgC;AAC9B,cAAM,QAAQ,GAAG,IAAI,CAAC,OAAL,EAAjB;AACA,cAAM,eAAe,GAAG,QAAQ,CAAC,IAAT,CAAc,IAAI,CAAC,QAAL,EAAd,CAAxB;AACA,cAAM,WAAW,GAAG,eAAe,CAAC,UAAhB,EAApB;AACA,cAAM,eAAe,GAAG,eAAe,CAAC,cAAhB,EAAxB;AACA,cAAM,KAAK,GAAG,KAAK,CAAC,SAAN,CAAgB,IAAI,CAAC,QAAL,EAAhB,CAAd;AACA,cAAM,SAAS,GAAG,KAAK,OAAL,CAAa,SAAb,IAA0B,CAA5C;AACA,cAAI,YAAJ;AACA,cAAI,WAAJ;AACA,cAAI,cAAJ;AACA,cAAI,aAAJ;AACA,cAAI,cAAJ;AACA,cAAI,eAAJ;AAEA,cAAM,UAAU,GAAG;AACjB,YAAA,QAAQ,EAAE,CADO;AAEjB,YAAA,UAAU,EAAE;AAFK,WAAnB;AAKA,cAAM,SAAS,GAAG,OAAO,CAAC,SAA1B;AACA,cAAM,aAAa,GAAG,OAAO,CAAC,aAA9B;AACA,cAAM,iBAAiB,GAAG,OAAO,CAAC,iBAAlC;;AAEA,cAAI,aAAa,CAAC,OAAd,CAAsB,OAAtB,MAAmC,CAAC,CAAxC,EAA2C;AACzC,YAAA,UAAU,CAAC,QAAX,GAAsB,eAAe,CAAC,CAAtC;AACD,WAFD,MAEO;AACL,YAAA,UAAU,CAAC,QAAX,GAAsB,WAAW,CAAC,CAAlC;AACD;;AAED,cAAI,aAAa,CAAC,OAAd,CAAsB,QAAtB,MAAoC,CAAC,CAAzC,EAA4C;AAC1C,YAAA,UAAU,CAAC,UAAX,GAAwB,eAAe,CAAC,CAAxC;AACD,WAFD,MAEO;AACL,YAAA,UAAU,CAAC,UAAX,GAAwB,WAAW,CAAC,CAApC;AACD;;AAED,eAAK,KAAL,CAAW,QAAX,GAAsB,IAAtB,CAA2B,UAAC,IAAD,EAAS;AAClC,gBAAI,MAAI,CAAC,SAAL,CAAe,IAAf,EAAqB,IAArB,CAAJ,EAAgC;AAC9B,qBAAO,KAAP;AACD;;AAED,gBAAM,QAAQ,GAAG,IAAI,CAAC,OAAL,GAAe,IAAf,CAAoB,IAAI,CAAC,QAAL,EAApB,CAAjB;AACA,gBAAM,WAAW,GAAG,QAAQ,CAAC,UAAT,EAApB;AACA,gBAAM,eAAe,GAAG,QAAQ,CAAC,cAAT,EAAxB;AACA,gBAAM,MAAM,GAAG;AACb,cAAA,QAAQ,EAAE,CAAC,WAAW,CAAC,CAAb,EAAgB,eAAe,CAAC,CAAhC,CADG;AAEb,cAAA,UAAU,EAAE,CAAC,WAAW,CAAC,CAAb,EAAgB,eAAe,CAAC,CAAhC;AAFC,aAAf;AAKA,gBAAM,SAAS,GAAG,EAAlB;AAKA,YAAA,MAAM,CAAC,IAAP,CAAY,MAAZ,EAAoB,OAApB,CAA4B,UAAC,CAAD,EAAM;AAChC,kBAAM,GAAG,GAAG,CAAZ;AACA,kBAAM,IAAI,GAAG,MAAM,CAAC,GAAD,CAAN,CACV,GADU,CACN,UAAC,KAAD;AAAA,uBAAY;AACf,kBAAA,QAAQ,EAAE,KADK;AAEf,kBAAA,QAAQ,EAAE,IAAI,CAAC,GAAL,CAAS,KAAK,GAAG,UAAU,CAAC,GAAD,CAA3B;AAFK,iBAAZ;AAAA,eADM,EAKV,MALU,CAKH,UAAC,IAAD;AAAA,uBAAU,IAAI,CAAC,QAAL,IAAiB,SAA3B;AAAA,eALG,CAAb;AAOA,cAAA,SAAS,CAAC,GAAD,CAAT,GAAiB,QAAQ,CAAC,MAAT,CAAgB,IAAhB,EAAsB,UAAC,IAAD;AAAA,uBAAU,IAAI,CAAC,QAAf;AAAA,eAAtB,CAAjB;AACD,aAVD;;AAYA,gBAAI,YAAY,IAAI,IAAhB,IAAwB,SAAS,CAAC,QAAV,CAAmB,MAAnB,GAA4B,CAAxD,EAA2D;AACzD,cAAA,YAAY,GAAG,SAAS,CAAC,QAAV,CAAmB,CAAnB,EAAsB,QAArC;AACA,cAAA,WAAW,GAAG,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAzB,EAA4B,QAAQ,CAAC,CAArC,CAAd;AACA,cAAA,cAAc,GACZ,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAzB,EAA4B,eAAe,CAAC,CAA5C,IAAiD,WADnD;AAED;;AAED,gBAAI,aAAa,IAAI,IAAjB,IAAyB,SAAS,CAAC,UAAV,CAAqB,MAArB,GAA8B,CAA3D,EAA8D;AAC5D,cAAA,aAAa,GAAG,SAAS,CAAC,UAAV,CAAqB,CAArB,EAAwB,QAAxC;AACA,cAAA,cAAc,GAAG,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAzB,EAA4B,QAAQ,CAAC,CAArC,CAAjB;AACA,cAAA,eAAe,GACb,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAzB,EAA4B,eAAe,CAAC,CAA5C,IAAiD,cADnD;AAED;;AAED,mBAAO,YAAY,IAAI,IAAhB,IAAwB,aAAa,IAAI,IAAhD;AACD,WA7CD;AA+CA,eAAK,IAAL;AAEA,cAAI,EAAE,GAAG,CAAT;AACA,cAAI,EAAE,GAAG,CAAT;;AACA,cAAI,aAAa,IAAI,IAAjB,IAAyB,YAAY,IAAI,IAA7C,EAAmD;AACjD,gBAAI,YAAY,IAAI,IAApB,EAA0B;AACxB,cAAA,EAAE,GACA,aAAa,CAAC,OAAd,CAAsB,OAAtB,MAAmC,CAAC,CAApC,GACI,YAAY,GAAG,eAAe,CAAC,CADnC,GAEI,WAAW,CAAC,CAAZ,GAAgB,YAHtB;AAID;;AAED,gBAAI,aAAa,IAAI,IAArB,EAA2B;AACzB,cAAA,EAAE,GACA,aAAa,CAAC,OAAd,CAAsB,QAAtB,MAAoC,CAAC,CAArC,GACI,aAAa,GAAG,eAAe,CAAC,CADpC,GAEI,WAAW,CAAC,CAAZ,GAAgB,aAHtB;AAID;AACF;;AAED,cAAI,MAAM,GAAG,CAAb;AACA,cAAI,OAAO,GAAG,CAAd;;AACA,cAAI,KAAK,GAAG,EAAR,KAAe,CAAnB,EAAsB;AACpB,gBAAI,KAAK,KAAK,EAAV,IAAgB,KAAK,KAAK,GAA9B,EAAmC;AACjC,cAAA,MAAM,GAAG,EAAT;AACA,cAAA,OAAO,GAAG,EAAV;AACD,aAHD,MAGO;AACL,cAAA,MAAM,GAAG,EAAT;AACA,cAAA,OAAO,GAAG,EAAV;AACD;AACF,WARD,MAQO;AACL,gBAAM,QAAQ,GACZ,KAAK,IAAI,CAAT,IAAc,KAAK,GAAG,EAAtB,GACI,CADJ,GAEI,KAAK,IAAI,EAAT,IAAe,KAAK,GAAG,GAAvB,GACA,CADA,GAEA,KAAK,IAAI,GAAT,IAAgB,KAAK,GAAG,GAAxB,GACA,CADA,GAEA,CAPN;;AASA,gBAAI,aAAa,IAAI,IAAjB,IAAyB,YAAY,IAAI,IAA7C,EAAmD;AACjD,kBAAI,EAAE,GAAG,EAAT,EAAa;AACX,gBAAA,EAAE,GAAG,CAAL;AACA,gBAAA,aAAa,GAAG,SAAhB;AACD,eAHD,MAGO;AACL,gBAAA,EAAE,GAAG,CAAL;AACA,gBAAA,YAAY,GAAG,SAAf;AACD;AACF;;AAED,gBAAM,GAAG,GAAG,KAAK,CAAC,KAAN,CAAY,KAAK,GAAG,EAApB,CAAZ;;AACA,gBAAI,EAAJ,EAAQ;AACN,cAAA,MAAM,GAAG,QAAQ,KAAK,CAAb,GAAiB,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,CAAtB,GAAsC,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,CAApD;AACD;;AACD,gBAAI,EAAJ,EAAQ;AACN,cAAA,OAAO,GAAG,QAAQ,KAAK,CAAb,GAAiB,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,CAAtB,GAAsC,EAAE,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,CAArD;AACD;;AAED,gBAAM,UAAU,GAAG,QAAQ,KAAK,CAAb,IAAkB,QAAQ,KAAK,CAAlD;;AACA,oBAAQ,iBAAR;AACE,mBAAK,KAAL;AACA,mBAAK,QAAL;AACE,gBAAA,OAAO,GAAG,EAAE,GACR,EAAE,IAAI,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,CAAH,GAAmB,IAAI,CAAC,GAAL,CAAS,GAAT,CAAjC,CADM,GAER,EAAE,IAAI,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,CAAH,GAAmB,IAAI,CAAC,GAAL,CAAS,GAAT,CAAjC,CAFN;AAGA;;AACF,mBAAK,MAAL;AACA,mBAAK,OAAL;AACE,gBAAA,MAAM,GAAG,EAAE,GACP,EAAE,IAAI,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,CAAH,GAAmB,IAAI,CAAC,GAAL,CAAS,GAAT,CAAjC,CADK,GAEP,EAAE,IAAI,UAAU,GAAG,IAAI,CAAC,GAAL,CAAS,GAAT,CAAH,GAAmB,IAAI,CAAC,GAAL,CAAS,GAAT,CAAjC,CAFN;AAGA;;AACF;AACE;AAdJ;AAgBD;;AAED,kBAAQ,iBAAR;AACE,iBAAK,KAAL;AACA,iBAAK,QAAL;AACE,cAAA,MAAM,GAAG,CAAT;AACA;;AACF,iBAAK,MAAL;AACA,iBAAK,OAAL;AACE,cAAA,OAAO,GAAG,CAAV;AACA;;AACF;AACE;AAVJ;;AAaA,cAAM,QAAQ,GAAG,KAAK,KAAL,CAAW,WAAX,EAAjB;AACA,cAAI,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,QAAQ,CAAC,KAAT,GAAiB,MAA1B,EAAkC,QAAlC,CAAf;AACA,cAAI,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,QAAQ,CAAC,MAAT,GAAkB,OAA3B,EAAoC,QAApC,CAAhB;;AAEA,cAAI,OAAO,CAAC,QAAR,IAAoB,OAAO,CAAC,QAAR,GAAmB,QAA3C,EAAqD;AACnD,YAAA,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,QAAT,EAAmB,OAAO,CAAC,QAA3B,CAAX;AACD;;AAED,cAAI,OAAO,CAAC,SAAR,IAAqB,OAAO,CAAC,SAAR,GAAoB,QAA7C,EAAuD;AACrD,YAAA,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,EAAoB,OAAO,CAAC,SAA5B,CAAZ;AACD;;AAED,cAAI,OAAO,CAAC,QAAZ,EAAsB;AACpB,YAAA,QAAQ,GAAG,IAAI,CAAC,GAAL,CAAS,QAAT,EAAmB,OAAO,CAAC,QAA3B,CAAX;AACD;;AAED,cAAI,OAAO,CAAC,SAAZ,EAAuB;AACrB,YAAA,SAAS,GAAG,IAAI,CAAC,GAAL,CAAS,SAAT,EAAoB,OAAO,CAAC,SAA5B,CAAZ;AACD;;AAED,cAAI,OAAO,CAAC,mBAAZ,EAAiC;AAC/B,gBAAI,OAAO,GAAG,MAAd,EAAsB;AACpB,cAAA,SAAS,GAAG,QAAQ,IAAI,QAAQ,CAAC,MAAT,GAAkB,QAAQ,CAAC,KAA/B,CAApB;AACD,aAFD,MAEO;AACL,cAAA,QAAQ,GAAG,SAAS,IAAI,QAAQ,CAAC,KAAT,GAAiB,QAAQ,CAAC,MAA9B,CAApB;AACD;AACF;;AAED,cAAI,QAAQ,KAAK,QAAQ,CAAC,KAAtB,IAA+B,SAAS,KAAK,QAAQ,CAAC,MAA1D,EAAkE;AAChE,YAAA,IAAI,CAAC,MAAL,CAAY,QAAZ,EAAsB,SAAtB,EAAiC;AAC/B,cAAA,SAAS,EAAT,SAD+B;AAE/B,cAAA,iBAAiB,EAAjB,iBAF+B;AAG/B,cAAA,aAAa,EAAb,aAH+B;AAI/B,cAAA,OAAO,EAAE,IAJsB;AAK/B,cAAA,SAAS,EAAE,KAAK,GALe;AAM/B,cAAA,QAAQ,EAAE,KAAK,KAAL,CAAW,IAAX,CAAgB,eAAhB,CAAgC,IAAhC;AANqB,aAAjC;;AASA,gBAAI,cAAJ,EAAoB;AAClB,cAAA,cAAc,IAAI,SAAS,GAAG,QAAQ,CAAC,MAAvC;AACD;;AAED,gBAAI,eAAJ,EAAqB;AACnB,cAAA,eAAe,IAAI,QAAQ,GAAG,QAAQ,CAAC,KAAvC;AACD;AACF;;AAED,cAAM,cAAc,GAAG,IAAI,CAAC,OAAL,GAAe,IAAf,CAAoB,KAApB,CAAvB;;AACA,cACE,YAAY,IACZ,IAAI,CAAC,GAAL,CAAS,cAAc,CAAC,CAAf,GAAmB,YAA5B,IAA4C,CAD5C,IAEA,IAAI,CAAC,GAAL,CAAS,cAAc,CAAC,KAAf,GAAuB,cAAc,CAAC,CAAtC,GAA0C,YAAnD,IAAmE,CAHrE,EAIE;AACA,YAAA,YAAY,GAAG,SAAf;AACD;;AAED,cACE,aAAa,IACb,IAAI,CAAC,GAAL,CAAS,cAAc,CAAC,CAAf,GAAmB,aAA5B,IAA6C,CAD7C,IAEA,IAAI,CAAC,GAAL,CAAS,cAAc,CAAC,MAAf,GAAwB,cAAc,CAAC,CAAvC,GAA2C,aAApD,IAAqE,CAHvE,EAIE;AACA,YAAA,aAAa,GAAG,SAAhB;AACD;;AAED,eAAK,MAAL,CAAY;AACV,YAAA,YAAY,EAAZ,YADU;AAEV,YAAA,WAAW,EAAX,WAFU;AAGV,YAAA,cAAc,EAAd,cAHU;AAIV,YAAA,aAAa,EAAb,aAJU;AAKV,YAAA,cAAc,EAAd,cALU;AAMV,YAAA,eAAe,EAAf;AANU,WAAZ;AAQD;AACF;AACF;AAjZH;AAAA;AAAA,WAmZE,6BAA2D;AAAA;;AAAA,UAA5C,IAA4C,SAA5C,IAA4C;AAAA,UAAtC,CAAsC,SAAtC,CAAsC;AAAA,UAAnC,CAAmC,SAAnC,CAAmC;AAAA,UAAhC,CAAgC,SAAhC,CAAgC;AACzD,UAAM,UAAU,GAAa,IAAI,CAAC,YAAL,CAAkB,CAAlB,EAAqB,aAArB,IAAsC,IAAnE;;AACA,UAAI,CAAC,KAAK,aAAL,CAAmB,UAAnB,CAAL,EAAqC;AACnC;AACD;;AAED,UAAM,IAAI,GAAG,UAAU,CAAC,IAAxB;AACA,UAAM,IAAI,GAAG,IAAI,CAAC,OAAL,EAAb;AACA,UAAM,QAAQ,GAAG,IAAI,CAAC,WAAL,EAAjB;AACA,UAAM,QAAQ,GAAG,IAAI,SAAJ,CACf,CAAC,GAAG,KAAK,MAAL,CAAY,CADD,EAEf,CAAC,GAAG,KAAK,MAAL,CAAY,CAFD,EAGf,IAAI,CAAC,KAHU,EAIf,IAAI,CAAC,MAJU,CAAjB;AAMA,UAAM,KAAK,GAAG,IAAI,CAAC,QAAL,EAAd;AACA,UAAM,UAAU,GAAG,QAAQ,CAAC,SAAT,EAAnB;AACA,UAAM,eAAe,GAAG,QAAQ,CAAC,IAAT,CAAc,KAAd,CAAxB;AACA,UAAM,WAAW,GAAG,eAAe,CAAC,UAAhB,EAApB;AACA,UAAM,eAAe,GAAG,eAAe,CAAC,cAAhB,EAAxB;AAEA,UAAM,QAAQ,GAAG,KAAK,OAAL,CAAa,SAAb,IAA0B,CAA3C;AACA,UAAI,YAAJ;AACA,UAAI,WAAJ;AACA,UAAI,cAAJ;AACA,UAAI,aAAJ;AACA,UAAI,cAAJ;AACA,UAAI,eAAJ;AACA,UAAI,WAAW,GAAG,CAAlB;AACA,UAAI,aAAa,GAAG,CAApB;AAEA,WAAK,KAAL,CAAW,QAAX,GAAsB,IAAtB,CAA2B,UAAC,UAAD,EAAe;AACxC,YAAI,MAAI,CAAC,SAAL,CAAe,IAAf,EAAqB,UAArB,CAAJ,EAAsC;AACpC,iBAAO,KAAP;AACD;;AAED,YAAM,QAAQ,GAAG,UAAU,CAAC,OAAX,GAAqB,IAArB,CAA0B,UAAU,CAAC,QAAX,EAA1B,CAAjB;AACA,YAAM,UAAU,GAAG,QAAQ,CAAC,SAAT,EAAnB;AACA,YAAM,WAAW,GAAG,QAAQ,CAAC,UAAT,EAApB;AACA,YAAM,eAAe,GAAG,QAAQ,CAAC,cAAT,EAAxB;;AAEA,YAAI,YAAY,IAAI,IAApB,EAA0B;AACxB,cAAI,IAAI,CAAC,GAAL,CAAS,UAAU,CAAC,CAAX,GAAe,UAAU,CAAC,CAAnC,IAAwC,QAA5C,EAAsD;AACpD,YAAA,YAAY,GAAG,UAAU,CAAC,CAA1B;AACA,YAAA,WAAW,GAAG,GAAd;AACD,WAHD,MAGO,IAAI,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,CAAZ,GAAgB,WAAW,CAAC,CAArC,IAA0C,QAA9C,EAAwD;AAC7D,YAAA,YAAY,GAAG,WAAW,CAAC,CAA3B;AACA,YAAA,WAAW,GAAG,CAAd;AACD,WAHM,MAGA,IAAI,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,CAAZ,GAAgB,eAAe,CAAC,CAAzC,IAA8C,QAAlD,EAA4D;AACjE,YAAA,YAAY,GAAG,WAAW,CAAC,CAA3B;AACA,YAAA,WAAW,GAAG,CAAd;AACD,WAHM,MAGA,IAAI,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAhB,GAAoB,eAAe,CAAC,CAA7C,IAAkD,QAAtD,EAAgE;AACrE,YAAA,YAAY,GAAG,eAAe,CAAC,CAA/B;AACA,YAAA,WAAW,GAAG,CAAd;AACD,WAHM,MAGA,IAAI,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAhB,GAAoB,WAAW,CAAC,CAAzC,IAA8C,QAAlD,EAA4D;AACjE,YAAA,YAAY,GAAG,eAAe,CAAC,CAA/B;AACD;;AAED,cAAI,YAAY,IAAI,IAApB,EAA0B;AACxB,YAAA,WAAW,GAAG,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAzB,EAA4B,QAAQ,CAAC,CAArC,CAAd;AACA,YAAA,cAAc,GACZ,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAzB,EAA4B,eAAe,CAAC,CAA5C,IAAiD,WADnD;AAED;AACF;;AAED,YAAI,aAAa,IAAI,IAArB,EAA2B;AACzB,cAAI,IAAI,CAAC,GAAL,CAAS,UAAU,CAAC,CAAX,GAAe,UAAU,CAAC,CAAnC,IAAwC,QAA5C,EAAsD;AACpD,YAAA,aAAa,GAAG,UAAU,CAAC,CAA3B;AACA,YAAA,aAAa,GAAG,GAAhB;AACD,WAHD,MAGO,IAAI,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,CAAZ,GAAgB,WAAW,CAAC,CAArC,IAA0C,QAA9C,EAAwD;AAC7D,YAAA,aAAa,GAAG,WAAW,CAAC,CAA5B;AACD,WAFM,MAEA,IAAI,IAAI,CAAC,GAAL,CAAS,WAAW,CAAC,CAAZ,GAAgB,eAAe,CAAC,CAAzC,IAA8C,QAAlD,EAA4D;AACjE,YAAA,aAAa,GAAG,WAAW,CAAC,CAA5B;AACA,YAAA,aAAa,GAAG,CAAhB;AACD,WAHM,MAGA,IAAI,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAhB,GAAoB,eAAe,CAAC,CAA7C,IAAkD,QAAtD,EAAgE;AACrE,YAAA,aAAa,GAAG,eAAe,CAAC,CAAhC;AACA,YAAA,aAAa,GAAG,CAAhB;AACD,WAHM,MAGA,IAAI,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAhB,GAAoB,WAAW,CAAC,CAAzC,IAA8C,QAAlD,EAA4D;AACjE,YAAA,aAAa,GAAG,eAAe,CAAC,CAAhC;AACD;;AAED,cAAI,aAAa,IAAI,IAArB,EAA2B;AACzB,YAAA,cAAc,GAAG,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAzB,EAA4B,QAAQ,CAAC,CAArC,CAAjB;AACA,YAAA,eAAe,GACb,IAAI,CAAC,GAAL,CAAS,eAAe,CAAC,CAAzB,EAA4B,eAAe,CAAC,CAA5C,IAAiD,cADnD;AAED;AACF;;AAED,eAAO,YAAY,IAAI,IAAhB,IAAwB,aAAa,IAAI,IAAhD;AACD,OA1DD;AA4DA,WAAK,IAAL;;AAEA,UAAI,aAAa,IAAI,IAAjB,IAAyB,YAAY,IAAI,IAA7C,EAAmD;AACjD,YAAI,aAAa,IAAI,IAArB,EAA2B;AACzB,UAAA,eAAe,CAAC,CAAhB,GACE,aAAa,GAAG,aAAa,GAAG,eAAe,CAAC,MADlD;AAED;;AAED,YAAI,YAAY,IAAI,IAApB,EAA0B;AACxB,UAAA,eAAe,CAAC,CAAhB,GAAoB,YAAY,GAAG,WAAW,GAAG,eAAe,CAAC,KAAjE;AACD;;AAED,YAAM,SAAS,GAAG,eAAe,CAAC,SAAhB,EAAlB;AACA,YAAM,IAAI,GAAG,SAAS,CAAC,CAAV,GAAc,QAAQ,CAAC,KAAT,GAAiB,CAA5C;AACA,YAAM,IAAI,GAAG,SAAS,CAAC,CAAV,GAAc,QAAQ,CAAC,MAAT,GAAkB,CAA7C;AACA,YAAM,EAAE,GAAG,IAAI,GAAG,QAAQ,CAAC,CAA3B;AACA,YAAM,EAAE,GAAG,IAAI,GAAG,QAAQ,CAAC,CAA3B;;AAEA,YAAI,EAAE,KAAK,CAAP,IAAY,EAAE,KAAK,CAAvB,EAA0B;AACxB,UAAA,IAAI,CAAC,SAAL,CAAe,EAAf,EAAmB,EAAnB,EAAuB;AACrB,YAAA,OAAO,EAAE,IADY;AAErB,YAAA,QAAQ,EAAE,KAAK,KAAL,CAAW,IAAX,CAAgB,eAAhB,CAAgC,UAAhC;AAFW,WAAvB;;AAKA,cAAI,eAAJ,EAAqB;AACnB,YAAA,eAAe,IAAI,EAAnB;AACD;;AAED,cAAI,cAAJ,EAAoB;AAClB,YAAA,cAAc,IAAI,EAAlB;AACD;AACF;;AAED,aAAK,MAAL,CAAY;AACV,UAAA,YAAY,EAAZ,YADU;AAEV,UAAA,WAAW,EAAX,WAFU;AAGV,UAAA,cAAc,EAAd,cAHU;AAIV,UAAA,aAAa,EAAb,aAJU;AAKV,UAAA,cAAc,EAAd,cALU;AAMV,UAAA,eAAe,EAAf;AANU,SAAZ;AAQD;AACF;AAxhBH;AAAA;AAAA,WA0hBY,mBAAU,QAAV,EAA0B,UAA1B,EAA0C;AAClD,aACE,UAAU,CAAC,EAAX,KAAkB,QAAQ,CAAC,EAA3B,IACA,UAAU,CAAC,cAAX,CAA0B,QAA1B,CADA,IAEA,KAAK,YAAL,CAAkB,UAAU,CAAC,KAA7B,CAFA,IAGA,KAAK,WAAL,CAAiB,UAAU,CAAC,EAA5B,CAHA,IAIC,KAAK,cAAL,IACC,WAAW,CAAC,IAAZ,CAAiB,KAAK,cAAtB,EAAsC,KAAK,KAA3C,EAAkD,UAAlD,CANJ;AAQD;AAniBH;AAAA;AAAA,WAqiBY,gBAAO,QAAP,EAOT;AACC,UAAM,GAAG,GAAG,KAAK,KAAL,CAAW,MAAX,EAAZ;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAf;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAf;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAf;AACA,UAAM,EAAE,GAAG,GAAG,CAAC,CAAf;AAEA,UAAM,KAAK,GAAG,KAAK,OAAL,CAAa,KAA3B;AACA,UAAM,WAAW,GAAG,KAAK,KAAL,CAAW,QAAX,CAAoB,MAApB,IAA8B,IAAlD;;AAEA,UAAI,QAAQ,CAAC,aAAb,EAA4B;AAC1B,aAAK,WAAL,CACG,GADH,CACO;AACH,UAAA,GAAG,EAAE,QAAQ,CAAC,aAAT,GAAyB,EAAzB,GAA8B,EADhC;AAEH,UAAA,IAAI,EAAE,KAAK,GACP,QAAQ,CAAC,cAAT,GAA2B,EAA3B,GAAgC,EADzB,GAEP,WAAW,GACX,OADW,GAEX,CAND;AAOH,UAAA,KAAK,EAAE,KAAK,GACR,QAAQ,CAAC,eAAT,GAA4B,EADpB,GAER,WAAW,GACX,MADW,GAEX;AAXD,SADP,EAcG,IAdH;AAeD,OAhBD,MAgBO;AACL,aAAK,WAAL,CAAiB,IAAjB;AACD;;AAED,UAAI,QAAQ,CAAC,YAAb,EAA2B;AACzB,aAAK,SAAL,CACG,GADH,CACO;AACH,UAAA,IAAI,EAAE,QAAQ,CAAC,YAAT,GAAwB,EAAxB,GAA6B,EADhC;AAEH,UAAA,GAAG,EAAE,KAAK,GACN,QAAQ,CAAC,WAAT,GAAwB,EAAxB,GAA6B,EADvB,GAEN,WAAW,GACX,OADW,GAEX,CAND;AAOH,UAAA,MAAM,EAAE,KAAK,GACT,QAAQ,CAAC,cAAT,GAA2B,EADlB,GAET,WAAW,GACX,MADW,GAEX;AAXD,SADP,EAcG,IAdH;AAeD,OAhBD,MAgBO;AACL,aAAK,SAAL,CAAe,IAAf;AACD;;AAED,WAAK,IAAL;AACD;AA/lBH;AAAA;AAAA,WAimBY,sBAAU;AAClB,UAAI,KAAK,KAAT,EAAgB;AACd,QAAA,YAAY,CAAC,KAAK,KAAN,CAAZ;AACA,aAAK,KAAL,GAAa,IAAb;AACD;AACF;AAtmBH;AAAA;AAAA,WAwmBE,gBAAI;AACF,WAAK,UAAL,CAAgB,IAAhB;AACA,WAAK,UAAL;;AACA,UAAI,KAAK,SAAL,CAAe,UAAf,IAA6B,IAAjC,EAAuC;AACrC,aAAK,KAAL,CAAW,SAAX,CAAqB,WAArB,CAAiC,KAAK,SAAtC;AACD;;AACD,aAAO,IAAP;AACD;AA/mBH;AAAA;AAAA,WAinBE,gBAAI;AAAA;;AACF,WAAK,UAAL,CAAgB,IAAhB;AACA,WAAK,UAAL;AACA,UAAM,KAAK,GAAG,KAAK,OAAL,CAAa,KAA3B;AACA,UAAM,KAAK,GAAG,OAAO,KAAP,KAAiB,QAAjB,GAA4B,KAA5B,GAAoC,KAAK,KAAK,KAAV,GAAkB,IAAlB,GAAyB,CAA3E;;AACA,UAAI,KAAK,GAAG,CAAZ,EAAe;AACb,aAAK,KAAL,GAAa,MAAM,CAAC,UAAP,CAAkB,YAAK;AAClC,UAAA,MAAI,CAAC,OAAL;AACD,SAFY,EAEV,KAFU,CAAb;AAGD;;AAED,aAAO,IAAP;AACD;AA7nBH;AAAA;AAAA,WA+nBY,oBAAQ;AAChB,WAAK,aAAL;AACA,WAAK,IAAL;AACD;AAloBH;AAAA;AAAA,WAqoBE,mBAAO;AACL,WAAK,MAAL;AACD;AAvoBH;;AAAA;AAAA,EAA8B,IAA9B;;AAqoBE,UAAA,CAAA,CADC,IAAI,CAAC,OAAL,EACD,CAAA,E,kBAAA,E,SAAA,EAEC,IAFD,CAAA","sourceRoot":"","sourcesContent":["var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\n};\nvar __rest = (this && this.__rest) || function (s, e) {\n    var t = {};\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\n        t[p] = s[p];\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\n                t[p[i]] = s[p[i]];\n        }\n    return t;\n};\nimport { ArrayExt, FunctionExt } from '../../util';\nimport { Rectangle, Angle } from '../../geometry';\nimport { View } from '../../view/view';\nexport class Snapline extends View {\n    constructor(options) {\n        super();\n        const { graph } = options, others = __rest(options, [\"graph\"]);\n        this.graph = graph;\n        this.options = Object.assign({ tolerance: 10 }, others);\n        this.render();\n        this.parseFilter();\n        if (!this.disabled) {\n            this.startListening();\n        }\n    }\n    get model() {\n        return this.graph.model;\n    }\n    get containerClassName() {\n        return this.prefixClassName('widget-snapline');\n    }\n    get verticalClassName() {\n        return `${this.containerClassName}-vertical`;\n    }\n    get horizontalClassName() {\n        return `${this.containerClassName}-horizontal`;\n    }\n    get disabled() {\n        return (this.options.enabled !== true ||\n            this.graph.options.snapline.enabled !== true);\n    }\n    enable() {\n        if (this.disabled) {\n            this.options.enabled = true;\n            this.graph.options.snapline.enabled = true;\n            this.startListening();\n        }\n    }\n    disable() {\n        if (!this.disabled) {\n            this.options.enabled = false;\n            this.graph.options.snapline.enabled = false;\n            this.stopListening();\n        }\n    }\n    setFilter(filter) {\n        this.options.filter = filter;\n        this.parseFilter();\n    }\n    render() {\n        this.container = document.createElement('div');\n        this.$container = this.$(this.container);\n        this.$horizontal = this.$(document.createElement('div')).addClass(this.horizontalClassName);\n        this.$vertical = this.$(document.createElement('div')).addClass(this.verticalClassName);\n        this.$container\n            .hide()\n            .addClass(this.containerClassName)\n            .append([this.$horizontal, this.$vertical]);\n        if (this.options.className) {\n            this.$container.addClass(this.options.className);\n        }\n    }\n    startListening() {\n        this.stopListening();\n        this.graph.on('node:mousedown', this.captureCursorOffset, this);\n        this.graph.on('node:mousemove', this.snapOnMoving, this);\n        this.model.on('batch:stop', this.onBatchStop, this);\n        this.delegateDocumentEvents({\n            mouseup: 'hide',\n            touchend: 'hide',\n        });\n    }\n    stopListening() {\n        this.graph.off('node:mousedown', this.captureCursorOffset, this);\n        this.graph.off('node:mousemove', this.snapOnMoving, this);\n        this.model.off('batch:stop', this.onBatchStop, this);\n        this.undelegateDocumentEvents();\n    }\n    parseFilter() {\n        this.filterShapes = {};\n        this.filterCells = {};\n        this.filterFunction = null;\n        const filter = this.options.filter;\n        if (Array.isArray(filter)) {\n            filter.forEach((item) => {\n                if (typeof item === 'string') {\n                    this.filterShapes[item] = true;\n                }\n                else {\n                    this.filterCells[item.id] = true;\n                }\n            });\n        }\n        else if (typeof filter === 'function') {\n            this.filterFunction = filter;\n        }\n    }\n    onBatchStop({ name, data }) {\n        if (name === 'resize') {\n            this.snapOnResizing(data.cell, data);\n        }\n    }\n    captureCursorOffset({ view, x, y }) {\n        const targetView = view.getDelegatedView();\n        if (targetView && this.isNodeMovable(targetView)) {\n            const pos = view.cell.getPosition();\n            this.offset = {\n                x: x - pos.x,\n                y: y - pos.y,\n            };\n        }\n    }\n    isNodeMovable(view) {\n        return view && view.cell.isNode() && view.can('nodeMovable');\n    }\n    snapOnResizing(node, options) {\n        if (this.options.resizing &&\n            !options.snapped &&\n            options.ui &&\n            options.direction &&\n            options.trueDirection) {\n            const view = this.graph.renderer.findViewByCell(node);\n            if (view && view.cell.isNode()) {\n                const nodeBbox = node.getBBox();\n                const nodeBBoxRotated = nodeBbox.bbox(node.getAngle());\n                const nodeTopLeft = nodeBBoxRotated.getTopLeft();\n                const nodeBottomRight = nodeBBoxRotated.getBottomRight();\n                const angle = Angle.normalize(node.getAngle());\n                const tolerance = this.options.tolerance || 0;\n                let verticalLeft;\n                let verticalTop;\n                let verticalHeight;\n                let horizontalTop;\n                let horizontalLeft;\n                let horizontalWidth;\n                const snapOrigin = {\n                    vertical: 0,\n                    horizontal: 0,\n                };\n                const direction = options.direction;\n                const trueDirection = options.trueDirection;\n                const relativeDirection = options.relativeDirection;\n                if (trueDirection.indexOf('right') !== -1) {\n                    snapOrigin.vertical = nodeBottomRight.x;\n                }\n                else {\n                    snapOrigin.vertical = nodeTopLeft.x;\n                }\n                if (trueDirection.indexOf('bottom') !== -1) {\n                    snapOrigin.horizontal = nodeBottomRight.y;\n                }\n                else {\n                    snapOrigin.horizontal = nodeTopLeft.y;\n                }\n                this.model.getNodes().some((cell) => {\n                    if (this.isIgnored(node, cell)) {\n                        return false;\n                    }\n                    const snapBBox = cell.getBBox().bbox(cell.getAngle());\n                    const snapTopLeft = snapBBox.getTopLeft();\n                    const snapBottomRight = snapBBox.getBottomRight();\n                    const groups = {\n                        vertical: [snapTopLeft.x, snapBottomRight.x],\n                        horizontal: [snapTopLeft.y, snapBottomRight.y],\n                    };\n                    const distances = {};\n                    Object.keys(groups).forEach((k) => {\n                        const key = k;\n                        const list = groups[key]\n                            .map((value) => ({\n                            position: value,\n                            distance: Math.abs(value - snapOrigin[key]),\n                        }))\n                            .filter((item) => item.distance <= tolerance);\n                        distances[key] = ArrayExt.sortBy(list, (item) => item.distance);\n                    });\n                    if (verticalLeft == null && distances.vertical.length > 0) {\n                        verticalLeft = distances.vertical[0].position;\n                        verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n                        verticalHeight =\n                            Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n                    }\n                    if (horizontalTop == null && distances.horizontal.length > 0) {\n                        horizontalTop = distances.horizontal[0].position;\n                        horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n                        horizontalWidth =\n                            Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n                    }\n                    return verticalLeft != null && horizontalTop != null;\n                });\n                this.hide();\n                let dx = 0;\n                let dy = 0;\n                if (horizontalTop != null || verticalLeft != null) {\n                    if (verticalLeft != null) {\n                        dx =\n                            trueDirection.indexOf('right') !== -1\n                                ? verticalLeft - nodeBottomRight.x\n                                : nodeTopLeft.x - verticalLeft;\n                    }\n                    if (horizontalTop != null) {\n                        dy =\n                            trueDirection.indexOf('bottom') !== -1\n                                ? horizontalTop - nodeBottomRight.y\n                                : nodeTopLeft.y - horizontalTop;\n                    }\n                }\n                let dWidth = 0;\n                let dHeight = 0;\n                if (angle % 90 === 0) {\n                    if (angle === 90 || angle === 270) {\n                        dWidth = dy;\n                        dHeight = dx;\n                    }\n                    else {\n                        dWidth = dx;\n                        dHeight = dy;\n                    }\n                }\n                else {\n                    const quadrant = angle >= 0 && angle < 90\n                        ? 1\n                        : angle >= 90 && angle < 180\n                            ? 4\n                            : angle >= 180 && angle < 270\n                                ? 3\n                                : 2;\n                    if (horizontalTop != null && verticalLeft != null) {\n                        if (dx < dy) {\n                            dy = 0;\n                            horizontalTop = undefined;\n                        }\n                        else {\n                            dx = 0;\n                            verticalLeft = undefined;\n                        }\n                    }\n                    const rad = Angle.toRad(angle % 90);\n                    if (dx) {\n                        dWidth = quadrant === 3 ? dx / Math.cos(rad) : dx / Math.sin(rad);\n                    }\n                    if (dy) {\n                        dHeight = quadrant === 3 ? dy / Math.cos(rad) : dy / Math.sin(rad);\n                    }\n                    const quadrant13 = quadrant === 1 || quadrant === 3;\n                    switch (relativeDirection) {\n                        case 'top':\n                        case 'bottom':\n                            dHeight = dy\n                                ? dy / (quadrant13 ? Math.cos(rad) : Math.sin(rad))\n                                : dx / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n                            break;\n                        case 'left':\n                        case 'right':\n                            dWidth = dx\n                                ? dx / (quadrant13 ? Math.cos(rad) : Math.sin(rad))\n                                : dy / (quadrant13 ? Math.sin(rad) : Math.cos(rad));\n                            break;\n                        default:\n                            break;\n                    }\n                }\n                switch (relativeDirection) {\n                    case 'top':\n                    case 'bottom':\n                        dWidth = 0;\n                        break;\n                    case 'left':\n                    case 'right':\n                        dHeight = 0;\n                        break;\n                    default:\n                        break;\n                }\n                const gridSize = this.graph.getGridSize();\n                let newWidth = Math.max(nodeBbox.width + dWidth, gridSize);\n                let newHeight = Math.max(nodeBbox.height + dHeight, gridSize);\n                if (options.minWidth && options.minWidth > gridSize) {\n                    newWidth = Math.max(newWidth, options.minWidth);\n                }\n                if (options.minHeight && options.minHeight > gridSize) {\n                    newHeight = Math.max(newHeight, options.minHeight);\n                }\n                if (options.maxWidth) {\n                    newWidth = Math.min(newWidth, options.maxWidth);\n                }\n                if (options.maxHeight) {\n                    newHeight = Math.min(newHeight, options.maxHeight);\n                }\n                if (options.preserveAspectRatio) {\n                    if (dHeight < dWidth) {\n                        newHeight = newWidth * (nodeBbox.height / nodeBbox.width);\n                    }\n                    else {\n                        newWidth = newHeight * (nodeBbox.width / nodeBbox.height);\n                    }\n                }\n                if (newWidth !== nodeBbox.width || newHeight !== nodeBbox.height) {\n                    node.resize(newWidth, newHeight, {\n                        direction,\n                        relativeDirection,\n                        trueDirection,\n                        snapped: true,\n                        snaplines: this.cid,\n                        restrict: this.graph.hook.getRestrictArea(view),\n                    });\n                    if (verticalHeight) {\n                        verticalHeight += newHeight - nodeBbox.height;\n                    }\n                    if (horizontalWidth) {\n                        horizontalWidth += newWidth - nodeBbox.width;\n                    }\n                }\n                const newRotatedBBox = node.getBBox().bbox(angle);\n                if (verticalLeft &&\n                    Math.abs(newRotatedBBox.x - verticalLeft) > 1 &&\n                    Math.abs(newRotatedBBox.width + newRotatedBBox.x - verticalLeft) > 1) {\n                    verticalLeft = undefined;\n                }\n                if (horizontalTop &&\n                    Math.abs(newRotatedBBox.y - horizontalTop) > 1 &&\n                    Math.abs(newRotatedBBox.height + newRotatedBBox.y - horizontalTop) > 1) {\n                    horizontalTop = undefined;\n                }\n                this.update({\n                    verticalLeft,\n                    verticalTop,\n                    verticalHeight,\n                    horizontalTop,\n                    horizontalLeft,\n                    horizontalWidth,\n                });\n            }\n        }\n    }\n    snapOnMoving({ view, e, x, y }) {\n        const targetView = view.getEventData(e).delegatedView || view;\n        if (!this.isNodeMovable(targetView)) {\n            return;\n        }\n        const node = targetView.cell;\n        const size = node.getSize();\n        const position = node.getPosition();\n        const cellBBox = new Rectangle(x - this.offset.x, y - this.offset.y, size.width, size.height);\n        const angle = node.getAngle();\n        const nodeCenter = cellBBox.getCenter();\n        const nodeBBoxRotated = cellBBox.bbox(angle);\n        const nodeTopLeft = nodeBBoxRotated.getTopLeft();\n        const nodeBottomRight = nodeBBoxRotated.getBottomRight();\n        const distance = this.options.tolerance || 0;\n        let verticalLeft;\n        let verticalTop;\n        let verticalHeight;\n        let horizontalTop;\n        let horizontalLeft;\n        let horizontalWidth;\n        let verticalFix = 0;\n        let horizontalFix = 0;\n        this.model.getNodes().some((targetNode) => {\n            if (this.isIgnored(node, targetNode)) {\n                return false;\n            }\n            const snapBBox = targetNode.getBBox().bbox(targetNode.getAngle());\n            const snapCenter = snapBBox.getCenter();\n            const snapTopLeft = snapBBox.getTopLeft();\n            const snapBottomRight = snapBBox.getBottomRight();\n            if (verticalLeft == null) {\n                if (Math.abs(snapCenter.x - nodeCenter.x) < distance) {\n                    verticalLeft = snapCenter.x;\n                    verticalFix = 0.5;\n                }\n                else if (Math.abs(snapTopLeft.x - nodeTopLeft.x) < distance) {\n                    verticalLeft = snapTopLeft.x;\n                    verticalFix = 0;\n                }\n                else if (Math.abs(snapTopLeft.x - nodeBottomRight.x) < distance) {\n                    verticalLeft = snapTopLeft.x;\n                    verticalFix = 1;\n                }\n                else if (Math.abs(snapBottomRight.x - nodeBottomRight.x) < distance) {\n                    verticalLeft = snapBottomRight.x;\n                    verticalFix = 1;\n                }\n                else if (Math.abs(snapBottomRight.x - nodeTopLeft.x) < distance) {\n                    verticalLeft = snapBottomRight.x;\n                }\n                if (verticalLeft != null) {\n                    verticalTop = Math.min(nodeBBoxRotated.y, snapBBox.y);\n                    verticalHeight =\n                        Math.max(nodeBottomRight.y, snapBottomRight.y) - verticalTop;\n                }\n            }\n            if (horizontalTop == null) {\n                if (Math.abs(snapCenter.y - nodeCenter.y) < distance) {\n                    horizontalTop = snapCenter.y;\n                    horizontalFix = 0.5;\n                }\n                else if (Math.abs(snapTopLeft.y - nodeTopLeft.y) < distance) {\n                    horizontalTop = snapTopLeft.y;\n                }\n                else if (Math.abs(snapTopLeft.y - nodeBottomRight.y) < distance) {\n                    horizontalTop = snapTopLeft.y;\n                    horizontalFix = 1;\n                }\n                else if (Math.abs(snapBottomRight.y - nodeBottomRight.y) < distance) {\n                    horizontalTop = snapBottomRight.y;\n                    horizontalFix = 1;\n                }\n                else if (Math.abs(snapBottomRight.y - nodeTopLeft.y) < distance) {\n                    horizontalTop = snapBottomRight.y;\n                }\n                if (horizontalTop != null) {\n                    horizontalLeft = Math.min(nodeBBoxRotated.x, snapBBox.x);\n                    horizontalWidth =\n                        Math.max(nodeBottomRight.x, snapBottomRight.x) - horizontalLeft;\n                }\n            }\n            return verticalLeft != null && horizontalTop != null;\n        });\n        this.hide();\n        if (horizontalTop != null || verticalLeft != null) {\n            if (horizontalTop != null) {\n                nodeBBoxRotated.y =\n                    horizontalTop - horizontalFix * nodeBBoxRotated.height;\n            }\n            if (verticalLeft != null) {\n                nodeBBoxRotated.x = verticalLeft - verticalFix * nodeBBoxRotated.width;\n            }\n            const newCenter = nodeBBoxRotated.getCenter();\n            const newX = newCenter.x - cellBBox.width / 2;\n            const newY = newCenter.y - cellBBox.height / 2;\n            const dx = newX - position.x;\n            const dy = newY - position.y;\n            if (dx !== 0 || dy !== 0) {\n                node.translate(dx, dy, {\n                    snapped: true,\n                    restrict: this.graph.hook.getRestrictArea(targetView),\n                });\n                if (horizontalWidth) {\n                    horizontalWidth += dx;\n                }\n                if (verticalHeight) {\n                    verticalHeight += dy;\n                }\n            }\n            this.update({\n                verticalLeft,\n                verticalTop,\n                verticalHeight,\n                horizontalTop,\n                horizontalLeft,\n                horizontalWidth,\n            });\n        }\n    }\n    isIgnored(snapNode, targetNode) {\n        return (targetNode.id === snapNode.id ||\n            targetNode.isDescendantOf(snapNode) ||\n            this.filterShapes[targetNode.shape] ||\n            this.filterCells[targetNode.id] ||\n            (this.filterFunction &&\n                FunctionExt.call(this.filterFunction, this.graph, targetNode)));\n    }\n    update(metadata) {\n        const ctm = this.graph.matrix();\n        const sx = ctm.a;\n        const sy = ctm.d;\n        const tx = ctm.e;\n        const ty = ctm.f;\n        const sharp = this.options.sharp;\n        const hasScroller = this.graph.scroller.widget != null;\n        if (metadata.horizontalTop) {\n            this.$horizontal\n                .css({\n                top: metadata.horizontalTop * sy + ty,\n                left: sharp\n                    ? metadata.horizontalLeft * sx + tx\n                    : hasScroller\n                        ? '-300%'\n                        : 0,\n                width: sharp\n                    ? metadata.horizontalWidth * sx\n                    : hasScroller\n                        ? '700%'\n                        : '100%',\n            })\n                .show();\n        }\n        else {\n            this.$horizontal.hide();\n        }\n        if (metadata.verticalLeft) {\n            this.$vertical\n                .css({\n                left: metadata.verticalLeft * sx + tx,\n                top: sharp\n                    ? metadata.verticalTop * sy + ty\n                    : hasScroller\n                        ? '-300%'\n                        : 0,\n                height: sharp\n                    ? metadata.verticalHeight * sy\n                    : hasScroller\n                        ? '700%'\n                        : '100%',\n            })\n                .show();\n        }\n        else {\n            this.$vertical.hide();\n        }\n        this.show();\n    }\n    resetTimer() {\n        if (this.timer) {\n            clearTimeout(this.timer);\n            this.timer = null;\n        }\n    }\n    show() {\n        this.$container.show();\n        this.resetTimer();\n        if (this.container.parentNode == null) {\n            this.graph.container.appendChild(this.container);\n        }\n        return this;\n    }\n    hide() {\n        this.$container.hide();\n        this.resetTimer();\n        const clean = this.options.clean;\n        const delay = typeof clean === 'number' ? clean : clean !== false ? 3000 : 0;\n        if (delay > 0) {\n            this.timer = window.setTimeout(() => {\n                this.unmount();\n            }, delay);\n        }\n        return this;\n    }\n    onRemove() {\n        this.stopListening();\n        this.hide();\n    }\n    dispose() {\n        this.remove();\n    }\n}\n__decorate([\n    View.dispose()\n], Snapline.prototype, \"dispose\", null);\n//# sourceMappingURL=index.js.map"]},"metadata":{},"sourceType":"module"}