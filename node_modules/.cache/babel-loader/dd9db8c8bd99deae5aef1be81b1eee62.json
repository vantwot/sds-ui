{"ast":null,"code":"import _defineProperty from \"@babel/runtime/helpers/defineProperty\";\nimport _classCallCheck from \"@babel/runtime/helpers/classCallCheck\";\nimport _createClass from \"@babel/runtime/helpers/createClass\";\nimport _inherits from \"@babel/runtime/helpers/inherits\";\nimport _possibleConstructorReturn from \"@babel/runtime/helpers/possibleConstructorReturn\";\nimport _getPrototypeOf from \"@babel/runtime/helpers/getPrototypeOf\";\nimport _isNil from \"lodash/isNil\";\n\nvar _dec, _class;\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n\n    if (enumerableOnly) {\n      symbols = symbols.filter(function (sym) {\n        return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n      });\n    }\n\n    keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = arguments[i] != null ? arguments[i] : {};\n\n    if (i % 2) {\n      ownKeys(Object(source), true).forEach(function (key) {\n        _defineProperty(target, key, source[key]);\n      });\n    } else if (Object.getOwnPropertyDescriptors) {\n      Object.defineProperties(target, Object.getOwnPropertyDescriptors(source));\n    } else {\n      ownKeys(Object(source)).forEach(function (key) {\n        Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n      });\n    }\n  }\n\n  return target;\n}\n\nfunction _createSuper(Derived) {\n  var hasNativeReflectConstruct = _isNativeReflectConstruct();\n\n  return function _createSuperInternal() {\n    var Super = _getPrototypeOf(Derived),\n        result;\n\n    if (hasNativeReflectConstruct) {\n      var NewTarget = _getPrototypeOf(this).constructor;\n\n      result = Reflect.construct(Super, arguments, NewTarget);\n    } else {\n      result = Super.apply(this, arguments);\n    }\n\n    return _possibleConstructorReturn(this, result);\n  };\n}\n\nfunction _isNativeReflectConstruct() {\n  if (typeof Reflect === \"undefined\" || !Reflect.construct) return false;\n  if (Reflect.construct.sham) return false;\n  if (typeof Proxy === \"function\") return true;\n\n  try {\n    Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {}));\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\n\nimport { injectable } from 'inversify';\nvar blur = \"varying vec2 v_UV;\\n\\nuniform sampler2D u_Texture;\\n\\nuniform vec2 u_ViewportSize: [1.0, 1.0];\\nuniform vec2 u_BlurDir: [1.0, 0.0];\\n\\n// https://github.com/Jam3/glsl-fast-gaussian-blur/blob/master/9.glsl\\nvec4 blur9(sampler2D image, vec2 uv, vec2 resolution, vec2 direction) {\\n  vec4 color = vec4(0.0);\\n  vec2 off1 = vec2(1.3846153846) * direction;\\n  vec2 off2 = vec2(3.2307692308) * direction;\\n  color += texture2D(image, uv) * 0.2270270270;\\n  color += texture2D(image, uv + (off1 / resolution)) * 0.3162162162;\\n  color += texture2D(image, uv - (off1 / resolution)) * 0.3162162162;\\n  color += texture2D(image, uv + (off2 / resolution)) * 0.0702702703;\\n  color += texture2D(image, uv - (off2 / resolution)) * 0.0702702703;\\n  return color;\\n}\\n\\nvoid main() {\\n  gl_FragColor = blur9(u_Texture, v_UV, u_ViewportSize, u_BlurDir);\\n}\";\nvar quad = \"attribute vec2 a_Position;\\n\\nvarying vec2 v_UV;\\n\\nvoid main() {\\n  v_UV = 0.5 * (a_Position + 1.0);\\n  gl_Position = vec4(a_Position, 0., 1.);\\n}\";\nimport BasePostProcessingPass from '../BasePostProcessingPass';\nvar BlurVPass = (_dec = injectable(), _dec(_class = function (_BasePostProcessingPa) {\n  _inherits(BlurVPass, _BasePostProcessingPa);\n\n  var _super = _createSuper(BlurVPass);\n\n  function BlurVPass() {\n    _classCallCheck(this, BlurVPass);\n\n    return _super.apply(this, arguments);\n  }\n\n  _createClass(BlurVPass, [{\n    key: \"setupShaders\",\n    value: function setupShaders() {\n      this.shaderModuleService.registerModule('blur-pass', {\n        vs: quad,\n        fs: blur\n      });\n\n      var _this$shaderModuleSer = this.shaderModuleService.getModule('blur-pass'),\n          vs = _this$shaderModuleSer.vs,\n          fs = _this$shaderModuleSer.fs,\n          uniforms = _this$shaderModuleSer.uniforms;\n\n      var _this$rendererService = this.rendererService.getViewportSize(),\n          width = _this$rendererService.width,\n          height = _this$rendererService.height;\n\n      return {\n        vs: vs,\n        fs: fs,\n        uniforms: _objectSpread(_objectSpread({}, uniforms), {}, {\n          u_ViewportSize: [width, height]\n        })\n      };\n    }\n  }, {\n    key: \"convertOptionsToUniforms\",\n    value: function convertOptionsToUniforms(options) {\n      var uniforms = {};\n\n      if (!_isNil(options.blurRadius)) {\n        uniforms.u_BlurDir = [0, options.blurRadius];\n      }\n\n      return uniforms;\n    }\n  }]);\n\n  return BlurVPass;\n}(BasePostProcessingPass)) || _class);\nexport { BlurVPass as default };","map":{"version":3,"sources":["../../../../../src/services/renderer/passes/post-processing/BlurVPass.ts"],"names":["injectable","BlurVPass","BasePostProcessingPass","vs","fs","blur","uniforms","width","height","u_ViewportSize","options"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA,SAAA,UAAA,QAAA,WAAA;;;AAKA,OAAA,sBAAA,MAAA,2BAAA;IAOqBC,S,WADpBD,UAAU,E;;;;;;;;;;;;;WAIT,SAAA,YAAA,GAAsB;AACpB,WAAA,mBAAA,CAAA,cAAA,CAAA,WAAA,EAAqD;AACnDG,QAAAA,EAAE,EADiD,IAAA;AAEnDC,QAAAA,EAAE,EAAEC;AAF+C,OAArD;;AAKA,UAAA,qBAAA,GAA6B,KAAA,mBAAA,CAAA,SAAA,CAA7B,WAA6B,CAA7B;AAAA,UAAQF,EAAR,GAAA,qBAAA,CAAA,EAAA;AAAA,UAAYC,EAAZ,GAAA,qBAAA,CAAA,EAAA;AAAA,UAAgBE,QAAhB,GAAA,qBAAA,CAAA,QAAA;;AAGA,UAAA,qBAAA,GAA0B,KAAA,eAAA,CAA1B,eAA0B,EAA1B;AAAA,UAAQC,KAAR,GAAA,qBAAA,CAAA,KAAA;AAAA,UAAeC,MAAf,GAAA,qBAAA,CAAA,MAAA;;AAEA,aAAO;AACLL,QAAAA,EAAE,EADG,EAAA;AAELC,QAAAA,EAAE,EAFG,EAAA;AAGLE,QAAAA,QAAQ,EAAA,aAAA,CAAA,aAAA,CAAA,EAAA,EAAA,QAAA,CAAA,EAAA,EAAA,EAAA;AAENG,UAAAA,cAAc,EAAE,CAAA,KAAA,EAAA,MAAA;AAFV,SAAA;AAHH,OAAP;AAQD;;;WAED,SAAA,wBAAA,CAAA,OAAA,EAIS;AACP,UAAMH,QAEL,GAFD,EAAA;;AAIA,UAAI,CAAC,MAAA,CAAMI,OAAO,CAAlB,UAAK,CAAL,EAAgC;AAC9BJ,QAAAA,QAAQ,CAARA,SAAAA,GAAqB,CAAA,CAAA,EAAII,OAAO,CAAhCJ,UAAqB,CAArBA;AACD;;AAED,aAAA,QAAA;AACD;;;;EAtCoCJ,sB;SAAlBD,S","sourcesContent":["import { injectable } from 'inversify';\nimport { isNil } from 'lodash';\nimport blur from '../../../../shaders/post-processing/blur.glsl';\nimport quad from '../../../../shaders/post-processing/quad.glsl';\nimport { IUniform } from '../../IUniform';\nimport BasePostProcessingPass from '../BasePostProcessingPass';\n\nexport interface IBlurVPassConfig {\n  blurRadius: number;\n}\n\n@injectable()\nexport default class BlurVPass extends BasePostProcessingPass<\n  IBlurVPassConfig\n> {\n  public setupShaders() {\n    this.shaderModuleService.registerModule('blur-pass', {\n      vs: quad,\n      fs: blur,\n    });\n\n    const { vs, fs, uniforms } = this.shaderModuleService.getModule(\n      'blur-pass',\n    );\n    const { width, height } = this.rendererService.getViewportSize();\n\n    return {\n      vs,\n      fs,\n      uniforms: {\n        ...uniforms,\n        u_ViewportSize: [width, height],\n      },\n    };\n  }\n\n  protected convertOptionsToUniforms(\n    options: Partial<IBlurVPassConfig>,\n  ): {\n    [uniformName: string]: IUniform;\n  } | void {\n    const uniforms: {\n      [key: string]: IUniform;\n    } = {};\n\n    if (!isNil(options.blurRadius)) {\n      uniforms.u_BlurDir = [0, options.blurRadius];\n    }\n\n    return uniforms;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}