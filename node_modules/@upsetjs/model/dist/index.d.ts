/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
interface IBaseSet<T = any> {
    /**
     * name of the set
     */
    readonly name: string;
    /**
     * optional set color
     */
    readonly color?: string;
    /**
     * elements in this set
     */
    readonly elems: readonly T[];
    /**
     * number of elements in the set
     */
    readonly cardinality: number;
    /**
     * custom overlap computation function
     * @param o to compare with
     */
    overlap?(o: ISetLike<T> | readonly T[]): number;
}
interface ISet<T = any> extends IBaseSet<T> {
    /**
     * a fixed set type to separate between sets and set combinations
     */
    readonly type: 'set';
}
interface IBaseSetCombination<T> extends IBaseSet<T> {
    /**
     * sets this set intersection is composed of
     */
    readonly sets: ReadonlySet<ISet<T>>;
    /**
     * number of set in this set intersection
     */
    readonly degree: number;
}
interface ISetIntersection<T = any> extends IBaseSetCombination<T> {
    /**
     * whether it is a set or an intersection
     */
    readonly type: 'intersection';
}
interface IDistinctSetIntersection<T = any> extends IBaseSetCombination<T> {
    /**
     * whether it is a set or an intersection
     */
    readonly type: 'distinctIntersection';
}
interface ISetUnion<T = any> extends IBaseSetCombination<T> {
    /**
     * whether it is a set or an intersection
     */
    readonly type: 'union';
}
interface ISetComposite<T = any> extends IBaseSetCombination<T> {
    /**
     * whether it is a set or an intersection
     */
    readonly type: 'composite';
}
/**
 * union of all set combination types
 */
declare type ISetCombination<T = any> = ISetIntersection<T> | ISetUnion<T> | ISetComposite<T> | IDistinctSetIntersection<T>;
declare type SetCombinationType = 'intersection' | 'union' | 'composite' | 'distinctIntersection';
/**
 * union of a set or a set combination
 */
declare type ISetLike<T = any> = ISet<T> | ISetCombination<T>;
/**
 * readonly array of sets
 */
declare type ISets<T = any> = readonly ISet<T>[];
/**
 * readonly array of set combinations
 */
declare type ISetCombinations<T = any> = readonly ISetCombination<T>[];
/**
 * readonly array of set like objects
 */
declare type ISetLikes<T = any> = readonly ISetLike<T>[];
/**
 * helper method to generate a key for a given set
 * @param s the set to compute the key for
 */
declare function toKey(s: ISetLike<any>): string;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

/**
 * helper method to create proper UpSet.js structures by adding extra properties
 * @param set the set to complete
 */
declare function asSet<T, S extends {
    name: string;
    elems: readonly T[];
}>(set: S): S & ISet<T>;
/**
 * possible set sort orders
 */
declare type SortSetOrder = 'cardinality' | 'name' | 'cardinality:desc' | 'name:asc' | 'cardinality:asc' | 'name:desc';
interface PostprocessSetOptions {
    /**
     * order the set by the given criteria
     */
    order?: SortSetOrder;
    /**
     * limit to the top N sets after sorting
     */
    limit?: number;
}
/**
 * helper to create a proper data structures for UpSet.js sets by adding extra properties
 * @param sets set like structures
 * @param options additional postprocessing options
 */
declare function asSets<T, S extends {
    name: string;
    elems: readonly T[];
}>(sets: readonly S[], options?: PostprocessSetOptions): (S & ISet<T>)[];

/**
 * helper method to extract the sets in a set combination from its name, e.g. S1&S2 => S1,S2
 * @param sets the list of possible sets
 * @param symbol the regex to split a name
 */
declare function fromSetName<T>(sets: ISets<T>, symbol?: RegExp): (s: {
    name: string;
}) => ISet<T>[];
/**
 * sort orders for set combinations
 */
declare type SortCombinationOrder = SortSetOrder | 'group' | 'degree' | 'group:asc' | 'group:desc' | 'degree:asc' | 'degree:desc';
declare type SortCombinationOrders = readonly SortCombinationOrder[];
interface PostprocessCombinationsOptions {
    /**
     * order the sets combinations by the given criteria
     */
    order?: SortCombinationOrder | SortCombinationOrders;
    /**
     * limit to the top N after sorting
     */
    limit?: number;
}
/**
 * helper to create a proper data structures for UpSet.js sets by adding extra properties
 * @param sets set like structures
 */
declare function asCombination<T, S extends {
    name: string;
    elems: readonly T[];
}>(set: S, type: SetCombinationType, toSets: (s: S) => ISets<T>): S & ISetCombination<T>;
/**
 * helper to create a proper data structures for UpSet.js sets by adding extra properties
 * @param sets set like structures
 * @param type hint for the type of combinations
 * @param toSets resolver of the contained sets
 */
declare function asCombinations<T, S extends {
    name: string;
    elems: readonly T[];
}>(sets: readonly S[], type: SetCombinationType, toSets: (s: S) => ISets<T>): (S & ISetCombination<T>)[];

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

interface GenerateSetCombinationsOptions<T = any> extends PostprocessCombinationsOptions {
    /**
     * type of set combination
     * @default intersection
     */
    type?: SetCombinationType;
    /**
     * minimum number of intersecting sets
     * @default 0
     */
    min?: number;
    /**
     * maximum number of intersecting sets
     * @default Infinity
     */
    max?: number;
    /**
     * include empty intersections
     * @default false
     */
    empty?: boolean;
    /**
     * list of all elements used to compute the elements which aren't part of any given set
     */
    elems?: readonly T[];
    /**
     * alternative to `.elems` by directly specifying the elements that are not part of any set
     * just makes sense with min=0
     */
    notPartOfAnySet?: readonly T[] | number;
    /**
     * optional elem key function
     * @param v
     */
    toElemKey?(v: T): string;
    /**
     * optional color merger
     **/
    mergeColors?: (colors: readonly (string | undefined)[]) => string | undefined;
}
/**
 * generate set intersection/unions for a given list of sets
 * @param sets the sets with their elements
 * @param options additional customization options
 */
declare function generateCombinations<T = any>(sets: ISets<T>, options?: GenerateSetCombinationsOptions<T>): ISetCombinations<T>;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

interface ExtractFromExpressionOptions {
    type?: SetCombinationType;
    setOrder?: SortSetOrder;
    combinationOrder?: SortCombinationOrder | SortCombinationOrders;
    joiner?: string;
    /**
     * optional function to identify the same sets
     * @param set the set to generate a key for
     */
    toKey?: (set: ISetLike<unknown>) => string;
}
/**
 * extract sets and combinations out of a given list of static combination information.
 * In addition an accessor is used to specify the set names
 * @param combinations list of combinations
 * @param accessor accessor to get the list of sets the combination belong to
 * @param options hints about the given combinations
 */
declare function extractFromExpression<T extends {
    cardinality: number;
}>(combinations: readonly T[], accessor: (elem: T) => string[], options?: ExtractFromExpressionOptions): {
    sets: ISets<unknown>;
    combinations: readonly (T & ISetCombination<unknown>)[];
};
/**
 * extract sets out of a given element array which have a `.sets` property
 * @param combinations
 * @param options hints about the given combinations
 */
declare function extractFromExpression<T extends {
    sets: string[];
    cardinality: number;
}>(combinations: readonly T[], options?: ExtractFromExpressionOptions): {
    sets: ISets<unknown>;
    combinations: readonly (T & ISetCombination<unknown>)[];
};

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

interface ExtractCombinationsOptions<T> {
    type?: SetCombinationType;
    setOrder?: SortSetOrder;
    setLimit?: number;
    combinationOrder?: SortCombinationOrder | SortCombinationOrders;
    combinationLimit?: number;
    sets?: ISets<T>;
    joiner?: string;
}
/**
 * extract sets out of a given element array, where an accessor is used to specify the set names
 * @param elements list of elements
 * @param acc accessor to get the list of sets the element belong to
 * @param options postprocess options
 */
declare function extractCombinations<T>(elements: readonly T[], acc: (elem: T) => string[], options?: ExtractCombinationsOptions<T>): {
    sets: ISets<T>;
    combinations: ISetCombinations<T>;
};
/**
 * extract sets out of a given element array which have a `.sets` property
 * @param elements
 * @param options postprocess options
 */
declare function extractCombinations<T extends {
    sets: string[];
}>(elements: readonly T[], options?: ExtractCombinationsOptions<T>): {
    sets: ISets<T>;
    combinations: ISetCombinations<T>;
};

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

/**
 * extract sets out of a given element array, where an accessor is used to specify the set names
 * @param elements list of elements
 * @param acc accessor to get the list of sets the element belong to
 * @param options postprocess options
 */
declare function extractSets<T>(elements: readonly T[], acc: (elem: T) => string[], options?: PostprocessSetOptions): ISets<T>;
/**
 * extract sets out of a given element array which have a `.sets` property
 * @param elements
 * @param options postprocess options
 */
declare function extractSets<T extends {
    sets: string[];
}>(elements: readonly T[], options?: PostprocessSetOptions): ISets<T>;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

interface ISetOverlapFunction<T> {
    (a: ISetLike<T>, b: ISetLike<T>): number;
}
interface SetOverlap {
    setA: number;
    setB: number;
    union: number;
    intersection: number;
}
interface SetElemOverlap<T> {
    setA: readonly T[];
    setB: readonly T[];
    union: readonly T[];
    intersection: readonly T[];
}
declare function setOverlapFactory<T>(a: Set<T> | readonly T[], toElemKey?: (e: T) => string): (b: Set<T> | readonly T[]) => SetOverlap;
declare function setOverlap<T>(a: Set<T> | readonly T[], b: Set<T> | readonly T[], toElemKey?: (e: T) => string): SetOverlap;
declare function setElemOverlapFactory<T>(a: Set<T> | readonly T[], toElemKey?: (e: T) => string): (b: Set<T> | readonly T[]) => SetElemOverlap<T>;
declare function setElemOverlap<T>(a: Set<T> | readonly T[], b: Set<T> | readonly T[], toElemKey?: (e: T) => string): SetElemOverlap<T>;
declare function setElemIntersectionFactory<T>(a: Set<T> | readonly T[], toElemKey?: (e: T) => string): (b: Set<T> | readonly T[]) => readonly T[];

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

declare function generateDistinctOverlapFunction<T>(combinations: ISetCombinations<T>, fallback: ISetOverlapFunction<T>, toKey?: (s: ISetLike<T>) => string): ISetOverlapFunction<T>;
declare function generateIntersectionOverlapFunction<T>(combinations: ISetCombinations<T>, fallback: ISetOverlapFunction<T>, toKey?: (s: ISetLike<T>) => string): ISetOverlapFunction<T>;
declare function generateUnionOverlapFunction<T>(combinations: ISetCombinations<T>, fallback: ISetOverlapFunction<T>, toKey?: (s: ISetLike<T>) => string): ISetOverlapFunction<T>;
declare function generateOverlapFunction<T>(combinations: ISetCombinations<T>, fallback: ISetOverlapFunction<T>, toKey?: (s: ISetLike<T>) => string): ISetOverlapFunction<T>;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

interface GenerateOverlapLookupOptions<T> {
    toElemKey?(v: T): string;
    what?: keyof SetOverlap;
    compress?: 'no' | 'yes' | 'auto';
}
/**
 * generate a (compressed) overlap lookup matrix that can be dumped and later used to lookup overlaps
 * @param sets the sets of the plot
 * @param combinations the set combinations of the plot
 * @param options additional options
 */
declare function generateOverlapLookup<T>(sets: ISets<T>, combinations: ISetCombinations<T>, { toElemKey, what, compress }?: GenerateOverlapLookupOptions<T>): readonly (readonly number[])[] | string;
/**
 * uses the given overlap lookup function to generate a compute and indices functions
 * @param matrix the compressed overlap matrix
 * @param sets the sets of the plot
 * @param combinations the set combinations of the plot
 * @param toKey
 */
declare function generateOverlapLookupFunction<T>(matrix: readonly (readonly number[])[] | string, sets: ISets<T>, combinations: ISetCombinations<T>, toKey?: (v: ISetLike<T>) => string): {
    setIndex: Map<string, number>;
    compute: ISetOverlapFunction<T>;
    combinationIndex: Map<string, number>;
};

interface UpSetElemQuery<T = any> {
    /**
     * name of this query for the tooltip
     */
    readonly name: string;
    /**
     * color for highlighting
     */
    readonly color: string;
    /**
     * elements within this query
     */
    readonly elems: readonly T[] | Set<T>;
}
interface UpSetSetQuery<T = any> {
    /**
     * name of this query for the tooltip
     */
    readonly name: string;
    /**
     * color for highlighting
     */
    readonly color: string;
    /**
     * set to highlight
     */
    readonly set: ISetLike<T>;
}
interface UpSetCalcQuery<T = any> {
    /**
     * name of this query for the tooltip
     */
    readonly name: string;
    /**
     * color for highlighting
     */
    readonly color: string;
    /**
     * computes the overlap of the given set to this query
     * @param s the current set to evaluate
     * @return at most `s.cardinality`
     */
    overlap(s: ISetLike<T> | readonly T[]): number;
}
declare type UpSetQuery<T = any> = UpSetElemQuery<T> | UpSetCalcQuery<T> | UpSetSetQuery<T>;
declare type UpSetQueries<T = any> = readonly UpSetQuery<T>[];
declare function isElemQuery<T>(q: UpSetQuery<T>): q is UpSetElemQuery<T>;
declare function isCalcQuery<T>(q: UpSetQuery<T>): q is UpSetCalcQuery<T>;
declare function isSetQuery<T>(q: UpSetQuery<T>): q is UpSetSetQuery<T>;
/**
 * helper method to create an overlap function for a given query
 * @param query the query
 * @param what type of overlap
 * @param toElemKey optional key function
 */
declare function queryOverlap<T>(query: UpSetQuery<T>, what: keyof SetOverlap, toElemKey?: (e: T) => string): (s: ISet<T> | ISetIntersection<T> | ISetUnion<T> | ISetComposite<T> | IDistinctSetIntersection<T> | readonly T[]) => number;
/**
 * helper method to create an overlap function of elements for a given query
 * @param query the query
 * @param what type of overlap
 * @param toElemKey optional key function
 */
declare function queryElemOverlap<T>(query: UpSetQuery<T>, what: keyof SetElemOverlap<T>, toElemKey?: (e: T) => string): (s: ISetLike<T>) => readonly T[] | null;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

declare function isSet(v: any): v is ISet<any>;
declare function isSetCombination(v: any): v is ISetCombination<any>;
declare function isSetLike(v: any): v is ISetLike<any>;
declare function isGenerateSetCombinationOptions(v: any): v is GenerateSetCombinationsOptions<any>;
declare function isUpSetQuery(v: any): v is UpSetQuery<any>;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
interface BandScaleLike {
    (v: string): number | undefined;
    bandwidth(): number;
}
interface BandScaleFactory {
    (domain: string[], size: number, padding: number): BandScaleLike;
}
declare const bandScale: BandScaleFactory;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
interface TickOptions {
    orientation: 'horizontal' | 'vertical';
    fontSizeHint: number;
}
declare type NumericScaleTick = {
    value: number;
    label?: string;
};
interface NumericScaleLike {
    (v: number): number;
    ticks(count?: number): readonly (NumericScaleTick | number)[];
    tickFormat(): (v: number) => string;
}
interface NumericScaleFactory {
    (max: number, range: [number, number], options: TickOptions): NumericScaleLike;
}

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

declare const linearScale: NumericScaleFactory;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

declare const logScale: NumericScaleFactory;

/**
 * creates an (compressed) indices array for the given array of elements
 * @param arr the array to compress
 * @param toIndex the element to index function
 */
declare function toIndicesArray<T>(arr: readonly T[], toIndex: (v: T) => number, { sortAble, compress }?: {
    sortAble?: boolean;
    compress?: 'no' | 'yes' | 'auto';
}): string | readonly number[];
/**
 * reverse operation of `toIndicesArray` by supporting compressed indices notation
 * @param indices the (compressed) indices
 * @param elements the elements to refer by index
 */
declare function fromIndicesArray<T>(indices: string | readonly number[], elements: readonly T[]): readonly T[];

interface IUpSetDumpRef {
    type: 'set' | SetCombinationType;
    index: number;
}

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

interface IUpSetFromDumpConfig<T> {
    toElemKey?(set: T): string;
}
declare function fromDump<T>(dump: IUpSetDump, elems: readonly T[], options?: IUpSetFromDumpConfig<T>): {
    sets: ISets<T>;
    combinations: ISetCombinations<T>;
    selection?: ISetLike<T> | readonly T[];
    queries: ReadonlyArray<UpSetElemQuery<T> | UpSetSetQuery<T>>;
};
declare type UpSetCompressedIndices = readonly number[] | string;
interface IUpSetDump {
    sets: ReadonlyArray<{
        name: string;
        color?: string;
        cardinality: number;
        elems: UpSetCompressedIndices;
    }>;
    combinations?: ReadonlyArray<{
        name: string;
        color?: string;
        type: SetCombinationType;
        sets: readonly number[];
        degree: number;
        cardinality: number;
        elems: UpSetCompressedIndices;
    }>;
    combinationOptions?: Omit<GenerateSetCombinationsOptions, 'elems'>;
    selection?: IUpSetDumpRef | UpSetCompressedIndices;
    queries: ReadonlyArray<{
        name: string;
        color: string;
        set?: IUpSetDumpRef;
        elems?: UpSetCompressedIndices;
    }>;
}
interface IUpSetDumpData<T> {
    toElemIndex(v: T): number;
    sets: ISets<T>;
    combinations: ISetCombinations<T>;
    combinationOptions?: GenerateSetCombinationsOptions<T>;
    selection?: ISetLike<T> | readonly T[];
    queries: ReadonlyArray<UpSetElemQuery<T> | UpSetSetQuery<T>>;
}
interface IUpSetToDumpConfig<T> {
    compress?: 'no' | 'yes' | 'auto';
    toKey?(set: ISetLike<T>): string;
}
declare function toDump<T>(data: IUpSetDumpData<T>, config?: IUpSetToDumpConfig<T>): IUpSetDump;

/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

interface UpSetFromStaticDumpFullCombination {
    name: string;
    type: SetCombinationType;
    sets: readonly number[];
    cardinality: number;
}
interface UpSetFromStaticDumpCompressedCombination {
    n?: string;
    cc?: string;
    c: number;
    type?: 'c' | 'i' | 'u' | 'd';
    s: number;
}
interface IUpSetStaticDump {
    sets: ReadonlyArray<{
        name: string;
        color?: string;
        cardinality: number;
    } | {
        n: string;
        cc?: string;
        c: number;
    }>;
    combinations: ReadonlyArray<UpSetFromStaticDumpFullCombination | UpSetFromStaticDumpCompressedCombination>;
    selection?: IUpSetDumpRef | readonly number[];
    queries: ReadonlyArray<{
        name: string;
        color: string;
        set?: IUpSetDumpRef;
        overlaps?: readonly number[];
    }>;
    overlaps: readonly (readonly number[])[] | string;
}
interface IUpSetStaticDumpData<T> {
    sets: ISets<T>;
    combinations: ISetCombinations<T>;
    selection?: ISetLike<T> | readonly T[];
    queries: ReadonlyArray<UpSetElemQuery<T> | UpSetSetQuery<T>>;
}
interface IUpSetToStaticDumpConfig<T> {
    compress?: 'no' | 'yes' | 'auto';
    toKey?(set: ISetLike<T>): string;
    toElemKey?(set: T): string;
}
declare function toStaticDump<T>(data: IUpSetStaticDumpData<T>, config?: IUpSetToStaticDumpConfig<T>): IUpSetStaticDump;
interface IUpSetFromStaticDumpConfig<T> {
    toKey?(set: ISetLike<T>): string;
}
declare function fromStaticDump(dump: IUpSetStaticDump, config?: IUpSetFromStaticDumpConfig<never>): {
    sets: ISets<never>;
    combinations: ISetCombinations<never>;
    selection?: ISetLike<never> | ((v: ISetLike<never>) => number);
    queries: ReadonlyArray<UpSetCalcQuery<never> | UpSetSetQuery<never>>;
};

declare function parseColor(color?: string): [number, number, number];
declare function mergeColors(colors: readonly (string | undefined)[]): string | undefined;

export { BandScaleFactory, BandScaleLike, ExtractCombinationsOptions, ExtractFromExpressionOptions, GenerateOverlapLookupOptions, GenerateSetCombinationsOptions, IBaseSet, IDistinctSetIntersection, ISet, ISetCombination, ISetCombinations, ISetComposite, ISetIntersection, ISetLike, ISetLikes, ISetOverlapFunction, ISetUnion, ISets, IUpSetDump, IUpSetDumpData, IUpSetDumpRef, IUpSetFromDumpConfig, IUpSetFromStaticDumpConfig, IUpSetStaticDump, IUpSetStaticDumpData, IUpSetToDumpConfig, IUpSetToStaticDumpConfig, NumericScaleFactory, NumericScaleLike, NumericScaleTick, PostprocessCombinationsOptions, PostprocessSetOptions, SetCombinationType, SetElemOverlap, SetOverlap, TickOptions, UpSetCalcQuery, UpSetCompressedIndices, UpSetElemQuery, UpSetFromStaticDumpCompressedCombination, UpSetFromStaticDumpFullCombination, UpSetQueries, UpSetQuery, UpSetSetQuery, asCombination, asCombinations, asSet, asSets, bandScale, extractCombinations, extractFromExpression, extractSets, fromDump, fromIndicesArray, fromSetName, fromStaticDump, generateCombinations, generateDistinctOverlapFunction, generateIntersectionOverlapFunction, generateOverlapFunction, generateOverlapLookup, generateOverlapLookupFunction, generateUnionOverlapFunction, isCalcQuery, isElemQuery, isGenerateSetCombinationOptions, isSet, isSetCombination, isSetLike, isSetQuery, isUpSetQuery, linearScale, logScale, mergeColors, parseColor, queryElemOverlap, queryOverlap, setElemIntersectionFactory, setElemOverlap, setElemOverlapFactory, setOverlap, setOverlapFactory, toDump, toIndicesArray, toKey, toStaticDump };
//# sourceMappingURL=index.d.ts.map
