/**
 * @upsetjs/model
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

function len(a) {
    return a instanceof Set ? a.size : a.length;
}
function setOverlapFactory(a, toElemKey) {
    const elems = !toElemKey
        ? a instanceof Set
            ? a
            : new Set(a)
        : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));
    const setA = elems.size;
    const same = {
        setA,
        setB: setA,
        union: setA,
        intersection: setA,
    };
    return (b) => {
        if (b === a) {
            return same;
        }
        let intersection = 0;
        b.forEach((e) => {
            if ((toElemKey && elems.has(toElemKey(e))) || (!toElemKey && elems.has(e))) {
                intersection++;
            }
        });
        const setB = len(b);
        return {
            setA,
            setB,
            intersection,
            union: setA + setB - intersection,
        };
    };
}
function setOverlap(a, b, toElemKey) {
    if (len(a) < len(b) || a instanceof Set) {
        return setOverlapFactory(a, toElemKey)(b);
    }
    const r = setOverlapFactory(b, toElemKey)(a);
    return Object.assign({}, r, {
        setA: r.setB,
        setB: r.setA,
    });
}
function setElemOverlapFactory(a, toElemKey) {
    const elems = !toElemKey
        ? a instanceof Set
            ? a
            : new Set(a)
        : new Set((a instanceof Set ? Array.from(a) : a).map(toElemKey));
    const setA = Array.isArray(a) ? a : Array.from(a);
    const same = {
        setA,
        setB: setA,
        union: setA,
        intersection: setA,
    };
    return (b) => {
        if (b === a) {
            return same;
        }
        const intersection = [];
        const union = setA.slice();
        b.forEach((e) => {
            if ((toElemKey && elems.has(toElemKey(e))) || (!toElemKey && elems.has(e))) {
                intersection.push(e);
            }
            else {
                union.push(e);
            }
        });
        return {
            setA: setA,
            setB: Array.isArray(b) ? b : Array.from(b),
            intersection,
            union,
        };
    };
}
function setElemOverlap(a, b, toElemKey) {
    if (len(a) < len(b) || a instanceof Set) {
        return setElemOverlapFactory(a, toElemKey)(b);
    }
    const r = setElemOverlapFactory(b, toElemKey)(a);
    return Object.assign({}, r, {
        setA: r.setB,
        setB: r.setA,
    });
}
function setElemIntersectionFactory(a, toElemKey) {
    const arr = a instanceof Set ? Array.from(a) : a;
    const elems = !toElemKey ? (a instanceof Set ? a : new Set(a)) : new Set(arr.map(toElemKey));
    return (b) => {
        if (b === a) {
            return arr;
        }
        const intersection = [];
        b.forEach((e) => {
            if ((toElemKey && elems.has(toElemKey(e))) || (!toElemKey && elems.has(e))) {
                intersection.push(e);
            }
        });
        return intersection;
    };
}

function isElemQuery(q) {
    return Array.isArray(q.elems);
}
function isCalcQuery(q) {
    return typeof q.overlap === 'function';
}
function isSetQuery(q) {
    return q.set != null;
}
function queryOverlap(query, what, toElemKey) {
    if (isCalcQuery(query)) {
        return query.overlap;
    }
    if (isSetQuery(query) && query.set.overlap) {
        return query.set.overlap;
    }
    const f = setOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);
    return (s) => {
        if (s.overlap && isElemQuery(query) && Array.isArray(query.elems)) {
            return s.overlap(query.elems);
        }
        if (s.overlap && isSetQuery(query)) {
            return s.overlap(query.set);
        }
        return f(s.elems)[what];
    };
}
function queryElemOverlap(query, what, toElemKey) {
    if (isCalcQuery(query)) {
        return () => null;
    }
    if (what === 'intersection') {
        const f = setElemIntersectionFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);
        return (s) => f(s.elems);
    }
    const f = setElemOverlapFactory(isElemQuery(query) ? query.elems : query.set.elems, toElemKey);
    return (s) => {
        return f(s.elems)[what];
    };
}

function isBaseSet(v) {
    const vt = v;
    return v != null && typeof vt.cardinality === 'number' && typeof v.name === 'string' && Array.isArray(v.elems);
}
function isSet(v) {
    return isBaseSet(v) && v.type === 'set';
}
function isSetCombination(v) {
    const vt = v;
    return (isBaseSet(v) &&
        ['composite', 'union', 'intersection', 'distinctIntersection'].includes(vt.type) &&
        vt.sets instanceof Set &&
        typeof vt.degree === 'number');
}
function isSetLike(v) {
    return isSet(v) || isSetCombination(v);
}
function isGenerateSetCombinationOptions(v) {
    const vt = v;
    return v != null && (vt.type == null || ['intersection', 'union'].includes(vt.type));
}
function isUpSetQuery(v) {
    const vt = v;
    return (v != null &&
        typeof vt.name === 'string' &&
        typeof vt.color === 'string' &&
        (isElemQuery(vt) || isSetQuery(vt) || isCalcQuery(vt)));
}

function byName(a, b) {
    return a.name.localeCompare(b.name);
}
function byCardinality(a, b) {
    return b.cardinality - a.cardinality;
}
function byDegree(a, b) {
    return a.degree - b.degree;
}
function byComposite(func) {
    return (a, b) => {
        return func.reduce((acc, f) => (acc === 0 ? f(a, b) : acc), 0);
    };
}
function negate(func) {
    return (a, b) => -func(a, b);
}
function byGroup(sets) {
    return (a, b) => {
        const fixNotFound = (v) => (v < 0 ? Number.POSITIVE_INFINITY : v);
        const aIndex = fixNotFound(sets.findIndex((s) => a.sets.has(s)));
        const bIndex = fixNotFound(sets.findIndex((s) => b.sets.has(s)));
        return aIndex - bIndex;
    };
}

function fromSetName(sets, symbol = /[∩∪&|]/) {
    const byName = new Map(sets.map((s) => [s.name, s]));
    return (s) => {
        return s.name.split(symbol).map((setName) => byName.get(setName.trim()));
    };
}
function toOrder(sets, order) {
    if (!order) {
        return byName;
    }
    const arr = (Array.isArray(order) ? order : [order]);
    if (arr.length === 0) {
        return byName;
    }
    return byComposite(arr.map((o) => {
        switch (o) {
            case 'cardinality':
            case 'cardinality:desc':
                return byCardinality;
            case 'cardinality:asc':
                return negate(byCardinality);
            case 'name:desc':
                return negate(byName);
            case 'degree':
            case 'degree:asc':
                return byDegree;
            case 'degree:desc':
                return negate(byDegree);
            case 'group':
            case 'group:asc':
                return byGroup(sets);
            case 'group:desc':
                return negate(byGroup(sets));
            default:
                return byName;
        }
    }));
}
function postprocessCombinations(sets, combinations, options = {}) {
    let r = combinations;
    if (options.order) {
        r = r.sort(toOrder(sets, options.order));
    }
    if (options.limit != null) {
        return r.slice(0, options.limit);
    }
    return r;
}
function asCombination(set, type, toSets) {
    const sets = toSets(set);
    return Object.assign({
        type,
        cardinality: set.elems.length,
        sets: new Set(sets),
        degree: sets.length,
    }, set);
}
function asCombinations(sets, type, toSets) {
    return sets.map((set) => asCombination(set, type, toSets));
}

const SET_JOINERS = {
    distinctIntersection: ' ∩ ',
    intersection: ' ∩ ',
    union: ' ∪ ',
    composite: ',',
};

function parseColor(color) {
    if (!color) {
        return [255, 255, 255];
    }
    const hex = color.match(/#([\da-f]{2})([\da-f]{2})([\da-f]{2})/i);
    if (hex) {
        return [Number.parseInt(hex[1], 16), Number.parseInt(hex[2], 16), Number.parseInt(hex[3], 16)];
    }
    const rgb = color.match(/\(([\d]+)[, ]([\d]+)[, ]([\d]+)\)/i);
    if (rgb) {
        return [Number.parseInt(rgb[1], 10), Number.parseInt(rgb[2], 10), Number.parseInt(rgb[3], 10)];
    }
    return [255, 255, 255];
}
function mergeColors(colors) {
    if (colors.length === 1) {
        return colors[0];
    }
    if (colors.every((d) => d == null)) {
        return undefined;
    }
    const rgb = colors.map(parseColor);
    const r = Math.floor(rgb.reduce((acc, v) => acc + v[0], 0) / rgb.length);
    const g = Math.floor(rgb.reduce((acc, v) => acc + v[1], 0) / rgb.length);
    const b = Math.floor(rgb.reduce((acc, v) => acc + v[2], 0) / rgb.length);
    return `#${r.toString(16)}${g.toString(16)}${b.toString(16)}`;
}

function generateName(combo, setIndex, joiner) {
    const sorted = Array.from(combo).sort((a, b) => setIndex.get(a) - setIndex.get(b));
    return sorted.length === 1 ? sorted[0].name : `(${sorted.map((d) => d.name).join(joiner)})`;
}
function generateSet(type, name, combo, elems, mergeColors) {
    return {
        type: combo.size === 0 ? 'composite' : type,
        elems,
        color: mergeColors(Array.from(combo).map((s) => s.color)),
        sets: combo,
        name,
        cardinality: elems.length,
        degree: combo.size,
    };
}
function mergeIntersection(a, b, lookup, toKey, setIndex, type, mergeColors) {
    const merged = new Set(a.sets);
    b.sets.forEach((s) => merged.add(s));
    const name = generateName(merged, setIndex, SET_JOINERS[type]);
    if (a.cardinality === 0 || b.cardinality === 0) {
        return generateSet(type, name, merged, [], mergeColors);
    }
    let small = a;
    let big = b;
    if (a.cardinality > b.cardinality) {
        small = b;
        big = a;
    }
    const keySet = new Set();
    const bigLookup = lookup.get(big);
    const elems = [];
    const l = small.elems.length;
    for (let i = 0; i < l; i++) {
        const e = small.elems[i];
        const key = toKey(e);
        if (!bigLookup.has(key)) {
            continue;
        }
        keySet.add(key);
        elems.push(e);
    }
    const r = generateSet(type, name, merged, elems, mergeColors);
    lookup.set(r, keySet);
    return r;
}
function mergeUnion(a, b, lookup, toKey, setIndex, type, mergeColors) {
    const merged = new Set(a.sets);
    b.sets.forEach((s) => merged.add(s));
    const name = generateName(merged, setIndex, SET_JOINERS[type]);
    if (a.cardinality === 0) {
        const r = generateSet(type, name, merged, b.elems, mergeColors);
        lookup.set(r, lookup.get(b));
        return r;
    }
    if (b.cardinality === 0) {
        const r = generateSet(type, name, merged, a.elems, mergeColors);
        lookup.set(r, lookup.get(a));
        return r;
    }
    let small = a;
    let big = b;
    if (a.cardinality > b.cardinality) {
        small = b;
        big = a;
    }
    const keySet = new Set(lookup.get(big));
    const bigLookup = lookup.get(big);
    const elems = big.elems.slice();
    small.elems.forEach((e) => {
        const key = toKey(e);
        if (bigLookup.has(key)) {
            return;
        }
        keySet.add(key);
        elems.push(e);
    });
    const r = generateSet(type, name, merged, elems, mergeColors);
    lookup.set(r, keySet);
    return r;
}
function generateEmptySet(type, notPartOfAnySet, allElements, lookup, toKey, mergeColors) {
    if (typeof notPartOfAnySet === 'number') {
        return {
            type: 'composite',
            elems: [],
            color: mergeColors ? mergeColors([]) : undefined,
            sets: new Set(),
            name: '()',
            cardinality: notPartOfAnySet,
            overlap(s) {
                return s === this || (isSetLike(s) && s.name === this.name && s.cardinality === this.cardinality)
                    ? this.cardinality
                    : 0;
            },
            degree: 0,
        };
    }
    if (Array.isArray(notPartOfAnySet)) {
        return generateSet(type, '()', new Set(), notPartOfAnySet, mergeColors);
    }
    const lookupArr = Array.from(lookup.values());
    const elems = allElements.filter((e) => {
        const k = toKey(e);
        return lookupArr.every((s) => !s.has(k));
    });
    return generateSet(type, '()', new Set(), elems, mergeColors);
}
function generateCombinations(sets, options = {}) {
    const { type = 'intersection', min = 0, max = Infinity, empty = false, elems: allElements = [], notPartOfAnySet, toElemKey, mergeColors: mergeColors$1 = mergeColors, } = options;
    const combinations = [];
    const setIndex = new Map(sets.map((s, i) => [s, i]));
    const setElems = new Map(sets.map((s) => [s, toElemKey ? new Set(s.elems.map(toElemKey)) : new Set(s.elems)]));
    const setDirectElems = toElemKey ? null : setElems;
    const setKeyElems = toElemKey ? setElems : null;
    const calc = type === 'union' ? mergeUnion : mergeIntersection;
    function push(s) {
        if (s.degree < min || s.degree > max || (s.cardinality === 0 && !empty)) {
            return;
        }
        if (type !== 'distinctIntersection') {
            combinations.push(s);
            return;
        }
        const others = sets.filter((d) => !s.sets.has(d));
        let elems = [];
        if (toElemKey) {
            const othersSets = others.map((o) => setKeyElems.get(o));
            elems = s.elems.filter((e) => {
                const key = toElemKey(e);
                return othersSets.every((o) => !o.has(key));
            });
        }
        else {
            const othersSets = others.map((o) => setDirectElems.get(o));
            elems = s.elems.filter((e) => othersSets.every((o) => !o.has(e)));
        }
        if (elems.length === s.cardinality) {
            combinations.push(s);
            return;
        }
        const sDistinct = generateSet(type, s.name, s.sets, elems, mergeColors$1);
        if (sDistinct.cardinality === 0 && !empty) {
            return;
        }
        combinations.push(sDistinct);
    }
    function generateLevel(arr, degree, lookup, toKey) {
        if (degree > max) {
            return;
        }
        const l = arr.length;
        for (let i = 0; i < l; i++) {
            const a = arr[i];
            const sub = [];
            for (let j = i + 1; j < l; j++) {
                const b = arr[j];
                const ab = calc(a, b, lookup, toKey, setIndex, type, mergeColors$1);
                push(ab);
                if (type === 'union' || ab.cardinality > 0 || empty) {
                    sub.push(ab);
                }
            }
            if (sub.length > 1) {
                generateLevel(sub, degree + 1, lookup, toKey);
            }
        }
    }
    if (min <= 0) {
        if (toElemKey) {
            push(generateEmptySet(type, notPartOfAnySet, allElements, setKeyElems, toElemKey, mergeColors$1));
        }
        else {
            push(generateEmptySet(type, notPartOfAnySet, allElements, setDirectElems, (v) => v, mergeColors$1));
        }
    }
    const degree1 = sets.map((s) => {
        const r = generateSet(type, s.name, new Set([s]), s.elems, mergeColors$1);
        setElems.set(r, setElems.get(s));
        push(r);
        return r;
    });
    if (toElemKey) {
        generateLevel(degree1, 2, setKeyElems, toElemKey);
    }
    else {
        generateLevel(degree1, 2, setDirectElems, (v) => v);
    }
    return postprocessCombinations(sets, combinations, options);
}

function asSet(set) {
    return Object.assign({
        type: 'set',
        cardinality: set.elems.length,
    }, set);
}
function toOrder$1(order) {
    if (!order) {
        return byName;
    }
    switch (order) {
        case 'cardinality':
        case 'cardinality:desc':
            return byComposite([byCardinality, byName]);
        case 'cardinality:asc':
            return byComposite([negate(byCardinality), byName]);
        case 'name:desc':
            return negate(byName);
        default:
            return byName;
    }
}
function postprocessSets(sets, options = {}) {
    let r = sets;
    if (options.order) {
        const order = toOrder$1(options.order);
        r = r.slice().sort(order);
    }
    if (options.limit != null) {
        return r.slice(0, options.limit);
    }
    return r;
}
function asSets(sets, options = {}) {
    return postprocessSets(sets.map(asSet), options);
}

function extractFromExpression(combinations, accOrOptions, o = {}) {
    var _a, _b, _c;
    const acc = typeof accOrOptions === 'function' ? accOrOptions : (e) => e.sets;
    const options = (_a = (typeof accOrOptions !== 'function' ? accOrOptions : o)) !== null && _a !== void 0 ? _a : {};
    const type = (_b = options.type) !== null && _b !== void 0 ? _b : 'intersection';
    const joiner = (_c = options.joiner) !== null && _c !== void 0 ? _c : SET_JOINERS[type];
    const sets = [];
    const setLookup = new Map();
    const cs = combinations.map((c) => {
        const containedSets = acc(c);
        const containedSetsObjects = containedSets.map((s) => {
            if (setLookup.has(s)) {
                return setLookup.get(s);
            }
            const set = {
                cardinality: 0,
                elems: [],
                name: s,
                type: 'set',
            };
            sets.push(set);
            setLookup.set(set.name, set);
            return set;
        });
        if (type === 'distinctIntersection') {
            for (const s of containedSetsObjects) {
                s.cardinality += c.cardinality;
            }
        }
        else if (containedSets.length === 1) {
            Object.assign(containedSetsObjects[0], {
                cardinality: c.cardinality,
            }, c);
        }
        else if (type === 'intersection') {
            for (const s of containedSetsObjects) {
                s.cardinality = Math.max(s.cardinality, c.cardinality);
            }
        }
        else if (type === 'union') {
            for (const s of containedSetsObjects) {
                s.cardinality = Math.min(s.cardinality, c.cardinality);
            }
        }
        const name = containedSets.join(joiner);
        return Object.assign({
            type,
            elems: [],
            name,
        }, c, {
            cardinality: c.cardinality,
            degree: containedSets.length,
            sets: new Set(containedSetsObjects),
        });
    });
    const sortedSets = postprocessSets(sets, {
        order: options.setOrder,
    });
    const sortedCombinations = postprocessCombinations(sortedSets, cs, {
        order: options.combinationOrder,
    });
    return {
        sets: sortedSets,
        combinations: sortedCombinations,
    };
}

function extractSets(elements, accOrOptions, o = {}) {
    var _a;
    const acc = typeof accOrOptions === 'function' ? accOrOptions : (e) => e.sets;
    const options = (_a = (typeof accOrOptions !== 'function' ? accOrOptions : o)) !== null && _a !== void 0 ? _a : {};
    const sets = Object.create(null);
    elements.forEach((elem) => {
        acc(elem).forEach((set) => {
            const s = typeof set === 'string' ? set : String(set);
            const r = sets[s];
            if (r == null) {
                sets[s] = [elem];
            }
            else {
                r.push(elem);
            }
        });
    });
    return postprocessSets(Object.entries(sets).map(([set, elems]) => {
        const r = {
            type: 'set',
            elems,
            name: String(set),
            cardinality: elems.length,
        };
        return r;
    }), options);
}

function createTree(byDegree, getOrCreateCombination) {
    const children = new Map();
    byDegree
        .slice()
        .reverse()
        .forEach((csOfDegree) => {
        if (csOfDegree.length === 0 || csOfDegree[0].degree === 1) {
            return;
        }
        csOfDegree.forEach((c) => {
            const sets = Array.from(c.sets).map((d) => d.name);
            for (let i = 0; i < sets.length; i++) {
                const subSet = sets.slice();
                subSet.splice(i, 1);
                const parent = getOrCreateCombination(subSet);
                if (children.has(parent)) {
                    children.get(parent).push(c);
                }
                else {
                    children.set(parent, [c]);
                }
            }
        });
    });
    return children;
}
function extractCombinations(elements, accOrOptions, o = {}) {
    var _a, _b, _c, _d;
    const acc = typeof accOrOptions === 'function' ? accOrOptions : (e) => e.sets;
    const options = (_a = (typeof accOrOptions !== 'function' ? accOrOptions : o)) !== null && _a !== void 0 ? _a : {};
    const type = (_b = options.type) !== null && _b !== void 0 ? _b : 'intersection';
    const sets = (_c = options.sets) !== null && _c !== void 0 ? _c : extractSets(elements, acc, {
        limit: options.setLimit,
        order: options.setOrder,
    });
    if (type === 'union') {
        return {
            sets,
            combinations: generateCombinations(sets, {
                type: 'union',
                limit: options.combinationLimit,
                order: options.combinationOrder,
            }),
        };
    }
    const setLookup = Object.create(null);
    sets.forEach((set, i) => {
        setLookup[set.name] = [set, i];
    });
    const isSortedAlphabetically = sets
        .map((d) => d.name)
        .sort()
        .every((d, i) => sets[i].name === d);
    const bySet = isSortedAlphabetically
        ? undefined
        : (a, b) => {
            var _a, _b, _c, _d;
            const ai = (_b = (_a = setLookup[a]) === null || _a === void 0 ? void 0 : _a[1]) !== null && _b !== void 0 ? _b : -1;
            const bi = (_d = (_c = setLookup[b]) === null || _c === void 0 ? void 0 : _c[1]) !== null && _d !== void 0 ? _d : -1;
            return ai - bi;
        };
    const validSet = options.sets == null && options.setLimit == null ? null : new Set(sets.map((d) => d.name));
    const joiner = (_d = options.joiner) !== null && _d !== void 0 ? _d : SET_JOINERS[type];
    const cs = [];
    const csLookup = Object.create(null);
    const byDegree = Array(sets.length + 1)
        .fill(0)
        .map((_) => []);
    function genName(setsOfElem) {
        switch (setsOfElem.length) {
            case 0:
                return '()';
            case 1:
                return setsOfElem[0];
            default:
                const sorted = setsOfElem.slice().sort(bySet);
                const joined = sorted.join(joiner);
                return '(' + joined + ')';
        }
    }
    function genKey(setsOfElem) {
        switch (setsOfElem.length) {
            case 0:
                return '';
            case 1:
                return setsOfElem[0];
            case 2: {
                if ((bySet != null && bySet(setsOfElem[0], setsOfElem[1]) > 0) ||
                    (bySet == null && setsOfElem[1] > setsOfElem[0])) {
                    return setsOfElem[1] + '&' + setsOfElem[0];
                }
                return setsOfElem[0] + '&' + setsOfElem[1];
            }
            default:
                const sorted = setsOfElem.slice().sort(bySet);
                return sorted.join('&');
        }
    }
    function getOrCreateCombination(setsOfElem) {
        const key = genKey(setsOfElem);
        let entry = csLookup[key];
        if (entry) {
            return entry;
        }
        const newEntry = {
            type,
            name: genName(setsOfElem),
            degree: setsOfElem.length,
            sets: new Set(setsOfElem.map((s) => setLookup[s][0])),
            cardinality: 0,
            elems: [],
        };
        csLookup[key] = newEntry;
        cs.push(newEntry);
        byDegree[newEntry.degree].push(newEntry);
        return newEntry;
    }
    elements.forEach((elem) => {
        let setsOfElem = acc(elem);
        if (validSet) {
            setsOfElem = setsOfElem.filter((d) => validSet.has(d));
        }
        const c = getOrCreateCombination(setsOfElem);
        c.elems.push(elem);
        c.cardinality++;
    });
    const finalize = () => {
        return {
            sets,
            combinations: postprocessCombinations(sets, cs, {
                order: options.combinationOrder,
                limit: options.combinationLimit,
            }),
        };
    };
    if (type === 'distinctIntersection') {
        return finalize();
    }
    const children = createTree(byDegree, getOrCreateCombination);
    function visit(node, visited, agg) {
        var _a;
        if (visited.has(node)) {
            return;
        }
        visited.add(node);
        if (node.elems.length < 1000) {
            agg[0].push(...node.elems);
        }
        else {
            agg.push(node.elems);
        }
        ((_a = children.get(node)) !== null && _a !== void 0 ? _a : []).forEach((child) => visit(child, visited, agg));
    }
    byDegree.slice(1).forEach((level) => {
        level.forEach((node) => {
            var _a;
            const visited = new Set();
            const agg = [node.elems];
            ((_a = children.get(node)) !== null && _a !== void 0 ? _a : []).forEach((child) => {
                visit(child, visited, agg);
            });
            const elems = agg.length === 1 ? agg[0] : agg.flat();
            Object.assign(node, { elems, cardinality: elems.length });
        });
    });
    return finalize();
}

function toKey(s) {
    return `${s.name}:${s.type}#${s.cardinality}`;
}

function isUniverse(s) {
    return s.sets.size === 0;
}
function common(a, b, toKey$1 = toKey) {
    const r = {
        done: null,
        aKey: '',
        bKey: '',
        aIsSet: false,
        bIsSet: false,
        toKey: toKey$1,
    };
    if (a === b) {
        r.done = a.cardinality;
        return r;
    }
    if (a.cardinality === 0 || b.cardinality === 0) {
        r.done = 0;
        return r;
    }
    r.aKey = toKey$1(a);
    r.bKey = toKey$1(b);
    if (r.aKey === r.bKey) {
        r.done = a.cardinality;
        return r;
    }
    r.aIsSet = isSet(a);
    r.bIsSet = isSet(b);
    if ((!r.aIsSet && isUniverse(a)) || (!r.bIsSet && isUniverse(b))) {
        r.done = 0;
        return r;
    }
    return r;
}
function aInB(b, r) {
    if (r.bIsSet || !r.aIsSet) {
        return false;
    }
    return Array.from(b.sets)
        .map(r.toKey)
        .includes(r.aKey);
}
function bInA(a, r) {
    if (!r.bIsSet || r.aIsSet) {
        return false;
    }
    return Array.from(a.sets)
        .map(r.toKey)
        .includes(r.bKey);
}
function keyedCombinations(combinations, toKey$1 = toKey) {
    return combinations.map((c) => {
        const s = Array.from(c.sets).map(toKey$1).sort();
        return {
            key: s.join('&'),
            s,
            sets: new Set(s),
            degree: c.degree,
            cardinality: c.cardinality,
        };
    });
}
function combinedKey(a, b, r) {
    const sets = new Set();
    if (r.aIsSet) {
        sets.add(r.aKey);
    }
    else {
        for (const s of Array.from(a.sets)) {
            sets.add(r.toKey(s));
        }
    }
    if (r.bIsSet) {
        sets.add(r.bKey);
    }
    else {
        for (const s of Array.from(b.sets)) {
            sets.add(r.toKey(s));
        }
    }
    return Array.from(sets).sort().join('&');
}
function generateDistinctOverlapFunction(combinations, fallback, toKey$1 = toKey) {
    const combinationsBySet = new Map();
    for (const c of keyedCombinations(combinations, toKey$1)) {
        for (const s of c.s) {
            if (combinationsBySet.has(s)) {
                combinationsBySet.get(s).push(c);
            }
            else {
                combinationsBySet.set(s, [c]);
            }
        }
    }
    return (a, b) => {
        const r = common(a, b, toKey$1);
        if (r.done != null) {
            return r.done;
        }
        if (!r.aIsSet && !r.bIsSet) {
            return 0;
        }
        if (r.aIsSet && !r.bIsSet) {
            return aInB(b, r) ? b.cardinality : 0;
        }
        if (!r.aIsSet && r.bIsSet) {
            return bInA(a, r) ? a.cardinality : 0;
        }
        const hasA = combinationsBySet.get(r.aKey);
        const hasB = combinationsBySet.get(r.bKey);
        if (!hasA || !hasB) {
            return fallback(a, b);
        }
        if (hasA.length < hasB.length) {
            return hasA.reduce((acc, c) => acc + (c.sets.has(r.bKey) ? c.cardinality : 0), 0);
        }
        return hasB.reduce((acc, c) => acc + (c.sets.has(r.aKey) ? c.cardinality : 0), 0);
    };
}
function generateIntersectionOverlapFunction(combinations, fallback, toKey$1 = toKey) {
    const combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map((d) => [d.key, d.cardinality]));
    return (a, b) => {
        const r = common(a, b, toKey$1);
        if (r.done != null) {
            return r.done;
        }
        if (r.aIsSet && !r.bIsSet && aInB(b, r)) {
            return b.cardinality;
        }
        if (!r.aIsSet && r.bIsSet && bInA(a, r)) {
            return a.cardinality;
        }
        const key = combinedKey(a, b, r);
        if (!combinationsByKey.has(key)) {
            return fallback(a, b);
        }
        return combinationsByKey.get(key);
    };
}
function generateUnionOverlapFunction(combinations, fallback, toKey$1 = toKey) {
    const combinationsByKey = new Map(keyedCombinations(combinations, toKey$1).map((d) => [d.key, d.cardinality]));
    return (a, b) => {
        const r = common(a, b, toKey$1);
        if (r.done != null) {
            return r.done;
        }
        if (r.aIsSet && !r.bIsSet && aInB(b, r)) {
            return a.cardinality;
        }
        if (!r.aIsSet && r.bIsSet && bInA(a, r)) {
            return b.cardinality;
        }
        const key = combinedKey(a, b, r);
        if (!combinationsByKey.has(key)) {
            return fallback(a, b);
        }
        return a.cardinality + b.cardinality - combinationsByKey.get(key);
    };
}
function generateOverlapFunction(combinations, fallback, toKey$1 = toKey) {
    if (combinations.length === 0) {
        return fallback;
    }
    const firstType = combinations[0].type;
    if (combinations.some((s) => s.type !== firstType)) {
        return fallback;
    }
    switch (firstType) {
        case 'union':
            return generateUnionOverlapFunction(combinations, fallback, toKey$1);
        case 'intersection':
            return generateIntersectionOverlapFunction(combinations, fallback, toKey$1);
        case 'distinctIntersection':
            return generateDistinctOverlapFunction(combinations, fallback, toKey$1);
    }
    return fallback;
}

function compressLine(line) {
    if (line.length === 0) {
        return '';
    }
    const r = [];
    let start = line[0];
    let len = 1;
    for (let i = 1; i < line.length; i++) {
        const v = line[i];
        if (v === start) {
            len++;
        }
        else {
            if (len > 1) {
                r.push(`${start}=${len - 1}`);
            }
            else if (start === 0) {
                r.push('');
            }
            else {
                r.push(start.toString());
            }
            start = v;
            len = 1;
        }
    }
    if (len > 1) {
        r.push(`${start}=${len}`);
    }
    else if (start === 0) {
        r.push('');
    }
    else {
        r.push(start.toString());
    }
    return r.join(',');
}
function decompressLine(line) {
    if (line.length === 0) {
        return [];
    }
    return line
        .split(',')
        .map((v) => {
        if (v === '') {
            return 0;
        }
        if (v.includes('=')) {
            const [value, length] = v.split('=').map((v) => Number.parseInt(v, 10));
            return Array(length + 1).fill(value);
        }
        return Number.parseInt(v, 10);
    })
        .flat();
}
function compressMatrix(matrix) {
    if (matrix.length === 0) {
        return '';
    }
    const rows = matrix.length;
    const flat = matrix.flat();
    return `${rows};${compressLine(flat)}`;
}
function decompressMatrix(matrix) {
    if (matrix.length === 0) {
        return [];
    }
    const [rowsInfo, data] = matrix.split(';');
    const rows = Number.parseInt(rowsInfo, 10);
    const values = decompressLine(data);
    const r = [];
    let acc = 0;
    for (let i = rows; i > 0; i--) {
        r.push(values.slice(acc, acc + i));
        acc += i;
    }
    return r;
}
function generateOverlapLookup(sets, combinations, { toElemKey, what = 'intersection', compress = 'auto' } = {}) {
    const data = sets.concat(combinations);
    function overlapF(set) {
        if (set.overlap) {
            return set.overlap;
        }
        const f = setOverlapFactory(set.elems, toElemKey);
        return (v) => {
            if (v.overlap) {
                return v.overlap(set);
            }
            return f(v.elems)[what];
        };
    }
    const matrix = data.map((set, i) => {
        const overlap = overlapF(set);
        const r = [];
        for (let j = i + 1; j < data.length; j++) {
            r.push(overlap(data[j]));
        }
        return r;
    });
    matrix.pop();
    if (compress === 'no') {
        return matrix;
    }
    const compressed = compressMatrix(matrix);
    if (compress === 'yes') {
        return compressed;
    }
    const encodedLength = JSON.stringify(matrix).length;
    const compressedLength = compressed.length + 2;
    return compressedLength < encodedLength * 0.6 ? compressed : matrix;
}
function generateOverlapLookupFunction(matrix, sets, combinations, toKey$1 = toKey) {
    const lookup = typeof matrix == 'string' ? decompressMatrix(matrix) : matrix;
    const setIndex = new Map(sets.map((set, i) => [toKey$1(set), i]));
    const combinationIndex = new Map(combinations.map((set, i) => [toKey$1(set), i + sets.length]));
    const compute = (a, b) => {
        if (a === b) {
            return a.cardinality;
        }
        const aKey = toKey$1(a);
        const bKey = toKey$1(b);
        const aIndex = setIndex.has(aKey) ? setIndex.get(aKey) : combinationIndex.get(aKey);
        const bIndex = setIndex.has(bKey) ? setIndex.get(bKey) : combinationIndex.get(bKey);
        if (aIndex === bIndex) {
            return a.cardinality;
        }
        const row = Math.min(aIndex, bIndex);
        const col = Math.max(aIndex, bIndex) - row - 1;
        if (row < 0 || row >= lookup.length || col < 0 || col >= lookup[row].length) {
            return 0;
        }
        return lookup[row][col];
    };
    return {
        setIndex,
        compute,
        combinationIndex,
    };
}

const bandScale = (domain, size, padding) => {
    const blocks = domain.length + padding;
    const step = size / Math.max(1, blocks);
    const start = size - step * domain.length;
    const lookup = new Map(domain.map((d, i) => [d, i]));
    const bandwidth = step / (1 + padding);
    const scale = (v) => {
        const index = lookup.get(v);
        if (index == null) {
            return undefined;
        }
        return start + step * index;
    };
    scale.bandwidth = () => bandwidth;
    return scale;
};

function hasOverlap(positions, heights, stride = 1) {
    for (let i = 0; i < positions.length - stride; i += stride) {
        const pos_i = positions[i];
        const pos_n = positions[i + 1];
        if (pos_i < pos_n) {
            const right = pos_i + heights[i] / 2;
            const left = pos_n - heights[i + 1] / 2;
            if (right > left) {
                return true;
            }
        }
        else {
            const left = pos_i - heights[i] / 2;
            const right = pos_n + heights[i + 1] / 2;
            if (right > left) {
                return true;
            }
        }
    }
    return false;
}
function ensureLast(ticks, max, scale, heightPerTick, toStr) {
    let last = ticks[ticks.length - 1];
    if (!last.label) {
        for (let j = ticks.length - 2; j > 0; --j) {
            if (ticks[j].label) {
                last = ticks[j];
                break;
            }
        }
    }
    if (last.value < max) {
        const pos_l = scale(last.value);
        const pos_max = scale(max);
        if (pos_l < pos_max) {
            const right = pos_l + heightPerTick(last.value) / 2;
            const left = pos_max - heightPerTick(max) / 2;
            if (right < left) {
                ticks.push({ value: max, label: toStr(max) });
            }
        }
        else {
            const left = pos_l - heightPerTick(last.value) / 2;
            const right = pos_max + heightPerTick(max) / 2;
            if (right < left) {
                ticks.push({ value: max, label: toStr(max) });
            }
        }
    }
    return ticks;
}
function genTicks(values, toStr = String, stride = 1) {
    return values.map((v, i) => ({
        value: v,
        label: stride === 1 || i % stride === 0 ? toStr(v) : undefined,
    }));
}
function checkValues(values, scale, heightPerTick, max, toStr) {
    const positions = values.map((v) => scale(v));
    const heights = values.map((v) => heightPerTick(v));
    if (!hasOverlap(positions, heights)) {
        return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);
    }
    if (!hasOverlap(positions, heights, 2)) {
        return ensureLast(genTicks(values, toStr), max, scale, heightPerTick, toStr);
    }
    return null;
}

function toStr(v) {
    return v.toLocaleString();
}
function niceFactors(max, maxCount = 11) {
    const digits = Math.max(0, Math.floor(Math.log10(max) - 0.5));
    const factor = Math.pow(10, digits);
    const factors = [1, 2, 5];
    const r = factors.map((f) => f * factor);
    if (digits > 0) {
        r.unshift(factors[factors.length - 1] * Math.pow(10, digits - 1));
    }
    r.push(factors[0] * Math.pow(10, digits + 1));
    const lower = Math.ceil(max / maxCount);
    return r.filter((d) => d >= lower && d <= max);
}
function range(max, inc = 1) {
    const values = [];
    for (let v = 0; v <= max; v += inc) {
        values.push(v);
    }
    return values;
}
function distributeTicks(max, maxCount, scale, heightPerTick) {
    if (maxCount <= 0) {
        return [];
    }
    const factors = niceFactors(max, maxCount);
    for (let i = 0; i < factors.length; i++) {
        const values = range(max, factors[i]);
        const r = checkValues(values, scale, heightPerTick, max, toStr);
        if (r) {
            return r;
        }
    }
    return genTicks([0, max], toStr);
}
const linearScale = (max, range, options) => {
    const size = range[1] - range[0];
    const domain = max;
    const scale = (v) => {
        const cv = Math.max(0, Math.min(v, domain));
        const n = cv / domain;
        return range[0] + n * size;
    };
    scale.ticks = (count = 10) => {
        if (options.orientation === 'vertical') {
            const heightPerTick = Math.ceil(options.fontSizeHint * 1.4);
            return distributeTicks(max, count + 1, scale, () => heightPerTick);
        }
        const widthPerChar = options.fontSizeHint / 1.4;
        return distributeTicks(max, count + 1, scale, (v) => Math.ceil(toStr(v).length * widthPerChar));
    };
    scale.tickFormat = () => toStr;
    return scale;
};

function toStr$1(v) {
    const orders = ['', 'k', 'M', 'G'];
    const order = Math.max(0, Math.min(Math.floor(Math.log10(v) / 3), orders.length - 1));
    const vi = Math.round(v / Math.pow(10, order * 3 - 1)) / 10;
    return `${vi.toLocaleString()}${orders[order]}`;
}
function range$1(max, factor) {
    const values = [];
    const inc = Math.pow(10, factor);
    for (let v = 1; v <= max; v *= inc) {
        values.push(v);
    }
    return values;
}
function generateInnerTicks(max, factor) {
    const values = [];
    const inc = 10;
    for (let v = 1, i = 0; v <= max; v *= inc, i++) {
        values.push({
            value: v,
            label: factor === 1 || i % factor === 0 ? toStr$1(v) : undefined,
        });
        for (let vv = v + v; vv < v * inc && vv < max; vv += v * factor) {
            values.push({ value: vv });
        }
    }
    return values;
}
function distributeTicks$1(max, maxCount, scale, heightPerTick) {
    if (maxCount <= 0) {
        return [];
    }
    for (const factor of [1, 2, 5]) {
        const values = range$1(max, factor);
        const r = checkValues(values, scale, heightPerTick, max, toStr$1);
        if (r) {
            return ensureLast(generateInnerTicks(max, factor), max, scale, heightPerTick, toStr$1);
        }
    }
    return genTicks([0, max], toStr$1);
}
const logScale = (max, range, options) => {
    const size = range[1] - range[0];
    const domain = max < 1 ? 1 : Math.log10(max);
    const scale = (v) => {
        const cv = Math.max(0, Math.min(v, domain));
        const n = cv <= 1 ? 0 : Math.log10(cv) / domain;
        return range[0] + n * size;
    };
    scale.ticks = (count = 10) => {
        if (options.orientation === 'vertical') {
            const heightPerTick = Math.ceil(options.fontSizeHint * 1.4);
            return distributeTicks$1(max, count + 1, scale, () => heightPerTick);
        }
        const widthPerChar = options.fontSizeHint / 1.4;
        return distributeTicks$1(max, count + 1, scale, (v) => Math.ceil(toStr$1(v).length * widthPerChar));
    };
    scale.tickFormat = () => toStr$1;
    return scale;
};

function compressIndicesArray(arr) {
    if (arr.length === 0) {
        return '';
    }
    const encoded = [];
    let startIndex = 0;
    const push = (i) => {
        if (i === startIndex + 1) {
            encoded.push(arr[startIndex].toString());
        }
        else if (i === startIndex + 2 && i < 10) {
            encoded.push(`${arr[startIndex]},${arr[startIndex + 1]}`);
        }
        else {
            encoded.push(`${arr[startIndex]}+${i - startIndex - 1}`);
        }
        return i;
    };
    for (let i = 1; i < arr.length; i++) {
        const expected = arr[i - 1] + 1;
        const v = arr[i];
        if (v !== expected) {
            startIndex = push(i);
            startIndex = i;
        }
    }
    push(arr.length);
    return encoded.join(',');
}
function toIndicesArray(arr, toIndex, { sortAble, compress = 'auto' } = {}) {
    if (arr.length === 0) {
        return [];
    }
    const base = arr.map((v) => toIndex(v));
    if (compress === 'no') {
        return base;
    }
    if (sortAble) {
        base.sort((a, b) => a - b);
    }
    const encoded = compressIndicesArray(base);
    const baseLength = JSON.stringify(base).length;
    const encodedLength = encoded.length + 2;
    if (encodedLength < baseLength * 0.6 ||
        baseLength - encodedLength > 50 ||
        (compress === 'yes' && encodedLength < baseLength)) {
        return encoded;
    }
    return base;
}
function fromIndicesArray(indices, elements) {
    if (typeof indices === 'string') {
        if (indices.length === 0) {
            return [];
        }
        return indices
            .split(',')
            .map((s) => {
            if (s.includes('+')) {
                const [start, length] = s.split('+').map((si) => Number.parseInt(si, 10));
                return elements.slice(start, start + length + 1);
            }
            return elements[Number.parseInt(s, 10)];
        })
            .flat();
    }
    return indices.map((i) => elements[i]);
}

function withColor(v, s) {
    if (s.color) {
        v.color = s.color;
    }
    return v;
}

function fromDump(dump, elems, options = {}) {
    const sets = dump.sets.map((set) => asSet(Object.assign(Object.assign({}, set), { elems: fromIndicesArray(set.elems, elems) })));
    const gen = () => {
        var _a;
        return generateCombinations(sets, Object.assign({ type: 'intersection', elems, toElemKey: options.toElemKey }, (_a = dump.combinationOptions) !== null && _a !== void 0 ? _a : {}));
    };
    const combinations = dump.combinations
        ? dump.combinations.map((c) => asCombination(Object.assign(Object.assign({}, c), { elems: fromIndicesArray(c.elems, elems) }), c.type, (v) => v.sets.map((i) => sets[i])))
        : gen();
    function fromSetRef(ref) {
        if (ref.type === 'set') {
            return sets[ref.index];
        }
        return combinations[ref.index];
    }
    return {
        sets,
        combinations,
        selection: dump.selection
            ? typeof dump.selection === 'string' || Array.isArray(dump.selection)
                ? fromIndicesArray(dump.selection, elems)
                : fromSetRef(dump.selection)
            : undefined,
        queries: dump.queries.map((query) => {
            if (query.set) {
                return {
                    name: query.name,
                    color: query.color,
                    set: fromSetRef(query.set),
                };
            }
            return {
                name: query.name,
                color: query.color,
                elems: fromIndicesArray(query.elems, elems),
            };
        }),
    };
}
function toDump(data, config = {}) {
    var _a;
    const indicesOptions = Object.assign({ sortAble: true }, config);
    const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;
    const bySetKey = new Map(data.sets.map((s, i) => [toKey$1(s), i]));
    const byCombinationKey = new Map(data.combinations.map((s, i) => [toKey$1(s), i]));
    const toSetRef = (s) => {
        if (s.type === 'set') {
            return {
                type: s.type,
                index: bySetKey.get(toKey$1(s)),
            };
        }
        const index = byCombinationKey.get(toKey$1(s));
        if (index == null || index < 0) {
            return toIndicesArray(s.elems, data.toElemIndex, indicesOptions);
        }
        return {
            type: s.type,
            index,
        };
    };
    const setLookup = data.sets.map((s, i) => ({
        key: toKey$1(s),
        i,
    }));
    return {
        sets: data.sets.map((set) => withColor({
            name: set.name,
            cardinality: set.cardinality,
            elems: toIndicesArray(set.elems, data.toElemIndex, indicesOptions),
        }, set)),
        combinations: config.compress === 'no'
            ? data.combinations.map((c) => {
                const setKeys = new Set(Array.from(c.sets).map(toKey$1));
                return withColor({
                    name: c.name,
                    type: c.type,
                    cardinality: c.cardinality,
                    degree: c.degree,
                    sets: setLookup.filter(({ key }) => setKeys.has(key)).map(({ i }) => i),
                    elems: toIndicesArray(c.elems, data.toElemIndex, indicesOptions),
                }, c);
            })
            : undefined,
        combinationOptions: data.combinationOptions,
        selection: data.selection
            ? Array.isArray(data.selection)
                ? toIndicesArray(data.selection, data.toElemIndex, indicesOptions)
                : toSetRef(data.selection)
            : undefined,
        queries: data.queries.map((query) => {
            const elems = isSetQuery(query)
                ? toSetRef(query.set)
                : toIndicesArray(Array.from(query.elems), data.toElemIndex, indicesOptions);
            return {
                name: query.name,
                color: query.color,
                set: typeof elems === 'string' || Array.isArray(elems) ? undefined : elems,
                elems: typeof elems === 'string' || Array.isArray(elems) ? elems : undefined,
            };
        }),
    };
}

function generateName$1(sets, type) {
    if (sets.length === 1) {
        return sets[0].name;
    }
    return `(${sets.map((set) => set.name).join(SET_JOINERS[type])})`;
}
function toStaticDump(data, config = {}) {
    var _a;
    const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;
    const bySetKey = new Map(data.sets.map((s, i) => [toKey$1(s), i]));
    const byCombinationKey = new Map(data.combinations.map((s, i) => [toKey$1(s), i]));
    const toSelectionSetRef = (s) => {
        if (isSetLike(s)) {
            if (s.type === 'set') {
                return {
                    type: s.type,
                    index: bySetKey.get(toKey$1(s)),
                };
            }
            const index = byCombinationKey.get(toKey$1(s));
            if (index != null && index >= 0) {
                return {
                    type: s.type,
                    index,
                };
            }
        }
        const overlapF = setOverlapFactory(isSetLike(s) ? s.elems : s);
        return data.sets
            .map((set) => overlapF(set.elems).intersection)
            .concat(data.combinations.map((set) => overlapF(set.elems).intersection));
    };
    const setIndex = new Map(data.sets.map((set, i) => [toKey$1(set), i]));
    const overlaps = generateOverlapLookup(data.sets, data.combinations, config);
    const shortNames = config.compress === 'yes';
    const compressCombination = (set) => {
        const partOf = Array.from(set.sets)
            .map((s) => setIndex.get(toKey$1(s)))
            .sort((a, b) => a - b);
        const r = {
            c: set.cardinality,
            s: partOf.reduce((acc, i) => acc + Math.pow(2, i), 0),
        };
        if (set.name !==
            generateName$1(partOf.map((i) => data.sets[i]), set.type)) {
            r.n = set.name;
        }
        if (set.type !== 'intersection') {
            r.type = set.type[0];
        }
        if (set.color) {
            r.cc = set.color;
        }
        return r;
    };
    return {
        sets: shortNames
            ? data.sets.map((set) => ({ n: set.name, cc: set.color, c: set.cardinality }))
            : data.sets.map((set) => withColor({ name: set.name, cardinality: set.cardinality }, set)),
        combinations: shortNames
            ? data.combinations.map(compressCombination)
            : data.combinations.map((set) => withColor({
                name: set.name,
                cardinality: set.cardinality,
                type: set.type,
                sets: Array.from(set.sets)
                    .map((s) => setIndex.get(toKey$1(s)))
                    .sort((a, b) => a - b),
            }, set)),
        overlaps,
        selection: data.selection ? toSelectionSetRef(data.selection) : undefined,
        queries: data.queries.map((query) => {
            if (isSetQuery(query)) {
                const ref = toSelectionSetRef(query.set);
                if (Array.isArray(ref)) {
                    return {
                        name: query.name,
                        color: query.color,
                        overlaps: ref,
                    };
                }
                return {
                    name: query.name,
                    color: query.color,
                    set: ref,
                };
            }
            const overlapF = setOverlapFactory(query.elems);
            const overlaps = data.sets
                .map((set) => overlapF(set.elems).intersection)
                .concat(data.combinations.map((set) => overlapF(set.elems).intersection));
            return {
                name: query.name,
                color: query.color,
                overlaps,
            };
        }),
    };
}
function isCompressed(s) {
    return typeof s.c === 'number';
}
function isCompressedSet(s) {
    return typeof s.c === 'number';
}
function fromStaticDump(dump, config = {}) {
    var _a;
    const toKey$1 = (_a = config.toKey) !== null && _a !== void 0 ? _a : toKey;
    let computeF = () => 0;
    function withOverlap(s) {
        s.overlap = (b) => computeF(s, b);
        return s;
    }
    const sets = dump.sets.map((set) => withOverlap({
        name: isCompressedSet(set) ? set.n : set.name,
        cardinality: isCompressedSet(set) ? set.c : set.cardinality,
        type: 'set',
        elems: [],
    }));
    const fromBit = (v) => {
        return sets.filter((_, i) => {
            const position = Math.pow(2, i);
            return (v & position) === position;
        });
    };
    const combinations = dump.combinations.map((set) => {
        var _a, _b;
        const partOf = isCompressed(set) ? fromBit(set.s) : set.sets.map((i) => sets[i]);
        const lookup = {
            i: 'intersection',
            u: 'union',
            c: 'composite',
            d: 'distinctIntersection',
        };
        const type = lookup[((_a = set.type) !== null && _a !== void 0 ? _a : 'i')[0]];
        return withOverlap({
            name: isCompressed(set) ? (_b = set.n) !== null && _b !== void 0 ? _b : generateName$1(partOf, type) : set.name,
            cardinality: isCompressed(set) ? set.c : set.cardinality,
            type,
            degree: partOf.length,
            sets: new Set(partOf),
            elems: [],
        });
    });
    const { setIndex, combinationIndex, compute } = generateOverlapLookupFunction(dump.overlaps, sets, combinations, toKey$1);
    computeF = compute;
    function fromSetRef(ref) {
        if (ref.type === 'set') {
            return sets[ref.index];
        }
        return combinations[ref.index];
    }
    function generateOverlap(lookup) {
        return (v) => {
            const key = toKey$1(v);
            const index = setIndex.has(key) ? setIndex.get(key) : combinationIndex.get(key);
            return index == null || index < 0 || index >= lookup.length ? 0 : lookup[index];
        };
    }
    return {
        sets,
        combinations,
        selection: dump.selection
            ? Array.isArray(dump.selection)
                ? generateOverlap(dump.selection)
                : fromSetRef(dump.selection)
            : undefined,
        queries: dump.queries.map((query) => {
            if (query.set) {
                return {
                    name: query.name,
                    color: query.color,
                    set: fromSetRef(query.set),
                };
            }
            return {
                name: query.name,
                color: query.color,
                overlap: generateOverlap(query.overlaps),
            };
        }),
    };
}

exports.asCombination = asCombination;
exports.asCombinations = asCombinations;
exports.asSet = asSet;
exports.asSets = asSets;
exports.bandScale = bandScale;
exports.extractCombinations = extractCombinations;
exports.extractFromExpression = extractFromExpression;
exports.extractSets = extractSets;
exports.fromDump = fromDump;
exports.fromIndicesArray = fromIndicesArray;
exports.fromSetName = fromSetName;
exports.fromStaticDump = fromStaticDump;
exports.generateCombinations = generateCombinations;
exports.generateDistinctOverlapFunction = generateDistinctOverlapFunction;
exports.generateIntersectionOverlapFunction = generateIntersectionOverlapFunction;
exports.generateOverlapFunction = generateOverlapFunction;
exports.generateOverlapLookup = generateOverlapLookup;
exports.generateOverlapLookupFunction = generateOverlapLookupFunction;
exports.generateUnionOverlapFunction = generateUnionOverlapFunction;
exports.isCalcQuery = isCalcQuery;
exports.isElemQuery = isElemQuery;
exports.isGenerateSetCombinationOptions = isGenerateSetCombinationOptions;
exports.isSet = isSet;
exports.isSetCombination = isSetCombination;
exports.isSetLike = isSetLike;
exports.isSetQuery = isSetQuery;
exports.isUpSetQuery = isUpSetQuery;
exports.linearScale = linearScale;
exports.logScale = logScale;
exports.mergeColors = mergeColors;
exports.parseColor = parseColor;
exports.queryElemOverlap = queryElemOverlap;
exports.queryOverlap = queryOverlap;
exports.setElemIntersectionFactory = setElemIntersectionFactory;
exports.setElemOverlap = setElemOverlap;
exports.setElemOverlapFactory = setElemOverlapFactory;
exports.setOverlap = setOverlap;
exports.setOverlapFactory = setOverlapFactory;
exports.toDump = toDump;
exports.toIndicesArray = toIndicesArray;
exports.toKey = toKey;
exports.toStaticDump = toStaticDump;
//# sourceMappingURL=index.cjs.js.map
