/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */

import React, { useRef, useState, useLayoutEffect, useMemo, useCallback } from 'react';
import { toKey, toDump, isElemQuery, isSetQuery, isSetLike as isSetLike$1, toStaticDump, setElemOverlapFactory, setOverlapFactory, generateCombinations, generateOverlapFunction, bandScale as bandScale$1, linearScale, logScale, queryOverlap, queryElemOverlap, generateDistinctOverlapFunction, isSet, isSetCombination, isGenerateSetCombinationOptions, isUpSetQuery } from '@upsetjs/model';
export * from '@upsetjs/model';
import LZString from 'lz-string';

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function extractStyleId(node) {
    return Array.from(node.classList)
        .find((d) => d.startsWith('root-'))
        .slice('root-'.length);
}
function extractTitle(node, styleId) {
    var _a, _b;
    return (_b = (_a = node.querySelector(`titleTextStyle-${styleId}`)) === null || _a === void 0 ? void 0 : _a.textContent) !== null && _b !== void 0 ? _b : 'UpSetJS';
}
function extractDescription(node, styleId) {
    var _a, _b;
    return (_b = (_a = node.querySelector(`descTextStyle-${styleId}`)) === null || _a === void 0 ? void 0 : _a.textContent) !== null && _b !== void 0 ? _b : '';
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const EMPTY_OBJECT = {};
const EMPTY_ARRAY = [];
const DEFAULT_FONT_SIZES = {
    setLabel: '16px',
    axisTick: '10px',
    chartLabel: '16px',
    barLabel: '10px',
    legend: '10px',
    description: '16px',
    title: '24px',
    valueLabel: '12px',
    exportLabel: '10px',
};
const DEFAULT_WIDTH_RATIO = [0.18, 0.12, 0.7];
const DEFAULT_HEIGHT_RATIO = [0.6, 0.4];
const DEFAULT_COMBINATIONS = {
    type: 'intersection',
    order: ['cardinality:desc', 'name:asc'],
};
const FONT_SIZES_KEYS = /* #__PURE__ */ Object.keys(DEFAULT_FONT_SIZES);
const MULTI_STYLE_KEYS = [
    'axisTick',
    'bar',
    'barLabel',
    'chartLabel',
    'dot',
    'legend',
    'title',
    'description',
    'setLabel',
    'set',
    'valueLabel',
];
const EXPORT_OPTION_KEYS = ['dump', 'png', 'share', 'svg', 'vega'];
const OVERFLOW_OPACITY_FACTOR = [0.7, 0.4];
const OVERFLOW_PADDING_FACTOR = [0.15, 0.3];

var sets = [
];
var intersections = [
];
var bb = {
	x: 0,
	y: 0,
	width: 10,
	height: 10
};
var venn0 = {
	sets: sets,
	intersections: intersections,
	bb: bb
};

var sets$1 = [
	{
		cx: 0,
		cy: 0,
		r: 5,
		text: {
			x: 3.5,
			y: -4
		},
		align: "start",
		verticalAlign: "bottom"
	}
];
var intersections$1 = [
	{
		sets: [
			0
		],
		x1: 0,
		y1: 5,
		arcs: [
			{
				mode: "i",
				ref: 0,
				x2: 0,
				y2: -5,
				sweep: false,
				large: false
			},
			{
				mode: "i",
				ref: 0,
				x2: 0,
				y2: 5,
				sweep: false,
				large: false
			}
		],
		text: {
			x: 0,
			y: 0
		}
	}
];
var bb$1 = {
	x: -5,
	y: -5,
	width: 10,
	height: 10
};
var venn1 = {
	sets: sets$1,
	intersections: intersections$1,
	bb: bb$1
};

var sets$2 = [
	{
		cx: -4,
		cy: 0,
		r: 5,
		text: {
			x: -7.5,
			y: 4
		},
		align: "end",
		verticalAlign: "top"
	},
	{
		cx: 4,
		cy: 0,
		r: 5,
		text: {
			x: 7.5,
			y: -4
		},
		align: "start",
		verticalAlign: "bottom"
	}
];
var intersections$2 = [
	{
		sets: [
			0
		],
		x1: 0,
		y1: -3,
		arcs: [
			{
				mode: "i",
				ref: 0,
				x2: 0,
				y2: 3,
				sweep: false,
				large: true
			},
			{
				mode: "o",
				ref: 1,
				x2: 0,
				y2: -3,
				sweep: true,
				large: false
			}
		],
		text: {
			x: -4,
			y: 0
		}
	},
	{
		sets: [
			1
		],
		x1: 0,
		y1: 3,
		arcs: [
			{
				mode: "i",
				ref: 1,
				x2: 0,
				y2: -3,
				sweep: false,
				large: true
			},
			{
				mode: "o",
				ref: 0,
				x2: 0,
				y2: 3,
				sweep: true,
				large: false
			}
		],
		text: {
			x: 4,
			y: 0
		}
	},
	{
		sets: [
			0,
			1
		],
		x1: 0,
		y1: 3,
		arcs: [
			{
				mode: "i",
				ref: 0,
				x2: 0,
				y2: -3,
				sweep: false,
				large: false
			},
			{
				mode: "i",
				ref: 1,
				x2: 0,
				y2: 3,
				sweep: false,
				large: false
			}
		],
		text: {
			x: 0,
			y: 0
		}
	}
];
var bb$2 = {
	x: -9,
	y: -5,
	width: 18,
	height: 10
};
var venn2 = {
	sets: sets$2,
	intersections: intersections$2,
	bb: bb$2
};

var sets$3 = [
	{
		cx: -3.464,
		cy: -2,
		r: 5,
		text: {
			x: -7,
			y: -6
		},
		align: "end"
	},
	{
		cx: 3.464,
		cy: -2,
		r: 5,
		text: {
			x: 7,
			y: -6
		},
		align: "start"
	},
	{
		cx: 0,
		cy: 4,
		r: 5,
		text: {
			x: 4,
			y: 7.5
		},
		align: "start",
		verticalAlign: "top"
	}
];
var intersections$3 = [
	{
		sets: [
			0
		],
		x1: -4.855,
		y1: 2.803,
		arcs: [
			{
				mode: "o",
				ref: 2,
				x2: -1.39,
				y2: -0.803,
				sweep: true,
				large: false
			},
			{
				mode: "o",
				ref: 1,
				x2: 0,
				y2: -5.606,
				sweep: true,
				large: false
			},
			{
				mode: "i",
				ref: 0,
				x2: -4.855,
				y2: 2.803,
				sweep: false,
				large: true
			}
		],
		text: {
			x: -4.216,
			y: -2.434
		}
	},
	{
		sets: [
			1
		],
		x1: 0,
		y1: -5.606,
		arcs: [
			{
				mode: "o",
				ref: 0,
				x2: 1.39,
				y2: -0.803,
				sweep: true,
				large: false
			},
			{
				mode: "o",
				ref: 2,
				x2: 4.855,
				y2: 2.803,
				sweep: true,
				large: false
			},
			{
				mode: "i",
				ref: 1,
				x2: 0,
				y2: -5.606,
				sweep: false,
				large: true
			}
		],
		text: {
			x: 4.216,
			y: -2.434
		}
	},
	{
		sets: [
			2
		],
		x1: -4.855,
		y1: 2.803,
		arcs: [
			{
				mode: "o",
				ref: 0,
				x2: 0,
				y2: 1.606,
				sweep: false,
				large: false
			},
			{
				mode: "o",
				ref: 1,
				x2: 4.855,
				y2: 2.803,
				sweep: false,
				large: false
			},
			{
				mode: "i",
				ref: 2,
				x2: -4.855,
				y2: 2.803,
				sweep: true,
				large: true
			}
		],
		text: {
			x: 0,
			y: 4.869
		}
	},
	{
		sets: [
			0,
			1
		],
		x1: 0,
		y1: -5.606,
		arcs: [
			{
				mode: "i",
				ref: 1,
				x2: -1.39,
				y2: -0.803,
				sweep: false,
				large: false
			},
			{
				mode: "o",
				ref: 2,
				x2: 1.39,
				y2: -0.803,
				sweep: true,
				large: false
			},
			{
				mode: "i",
				ref: 0,
				x2: 0,
				y2: -5.606,
				sweep: false,
				large: false
			}
		],
		text: {
			x: 0,
			y: -2.404
		}
	},
	{
		sets: [
			0,
			2
		],
		x1: -4.855,
		y1: 2.803,
		arcs: [
			{
				mode: "i",
				ref: 2,
				x2: -1.39,
				y2: -0.803,
				sweep: true,
				large: false
			},
			{
				mode: "o",
				ref: 1,
				x2: 0,
				y2: 1.606,
				sweep: false,
				large: false
			},
			{
				mode: "i",
				ref: 0,
				x2: -4.855,
				y2: 2.803,
				sweep: true,
				large: false
			}
		],
		text: {
			x: -2.082,
			y: 1.202
		}
	},
	{
		sets: [
			1,
			2
		],
		x1: 4.855,
		y1: 2.803,
		arcs: [
			{
				mode: "i",
				ref: 2,
				x2: 1.39,
				y2: -0.803,
				sweep: false,
				large: false
			},
			{
				mode: "o",
				ref: 0,
				x2: 0,
				y2: 1.606,
				sweep: true,
				large: false
			},
			{
				mode: "i",
				ref: 1,
				x2: 4.855,
				y2: 2.803,
				sweep: false,
				large: false
			}
		],
		text: {
			x: 2.082,
			y: 1.202
		}
	},
	{
		sets: [
			0,
			1,
			2
		],
		x1: 1.39,
		y1: -0.803,
		arcs: [
			{
				mode: "i",
				ref: 0,
				x2: 0,
				y2: 1.606,
				sweep: true,
				large: false
			},
			{
				mode: "i",
				ref: 1,
				x2: -1.39,
				y2: -0.803,
				sweep: true,
				large: false
			},
			{
				mode: "i",
				ref: 2,
				x2: 1.39,
				y2: -0.803,
				sweep: true,
				large: false
			}
		],
		text: {
			x: 0,
			y: 0
		}
	}
];
var bb$3 = {
	x: -8.464,
	y: -7,
	width: 16.928,
	height: 16
};
var venn3 = {
	sets: sets$3,
	intersections: intersections$3,
	bb: bb$3
};

var sets$4 = [
	{
		cx: 0.439,
		cy: -1.061,
		rx: 2.5,
		ry: 5,
		rotation: 45,
		text: {
			x: 4.5,
			y: -4.5
		},
		align: "start",
		verticalAlign: "bottom"
	},
	{
		cx: 2.561,
		cy: 1.061,
		rx: 2.5,
		ry: 5,
		rotation: 45,
		text: {
			x: 4,
			y: 3.75
		},
		align: "start",
		verticalAlign: "top"
	},
	{
		cx: -2.561,
		cy: 1.061,
		rx: 2.5,
		ry: 5,
		rotation: -45,
		text: {
			x: -4,
			y: 3.7
		},
		align: "end",
		verticalAlign: "top"
	},
	{
		cx: -0.439,
		cy: -1.061,
		rx: 2.5,
		ry: 5,
		rotation: -45,
		text: {
			x: -4.5,
			y: -4.5
		},
		align: "end",
		verticalAlign: "bottom"
	}
];
var intersections$4 = [
	{
		sets: [
			0
		],
		x1: 0,
		y1: -3.94,
		arcs: [
			{
				ref: 0,
				mode: "i",
				x2: 4.328,
				y2: -2.828,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: 2.179,
				y2: -1.858,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: 0,
				y2: -3.94,
				large: false
			}
		],
		text: {
			x: 2.914,
			y: -3.536
		}
	},
	{
		sets: [
			1
		],
		x1: 4.328,
		y1: -2.828,
		arcs: [
			{
				ref: 1,
				mode: "i",
				x2: 0,
				y2: 5.006,
				sweep: true,
				large: true
			},
			{
				ref: 2,
				mode: "o",
				x2: 1.328,
				y2: 2.828
			},
			{
				ref: 3,
				mode: "o",
				x2: 3.108,
				y2: -0.328
			},
			{
				ref: 0,
				mode: "o",
				x2: 4.328,
				y2: -2.828
			}
		],
		text: {
			x: 5.036,
			y: -1.414
		}
	},
	{
		sets: [
			2
		],
		x1: 0,
		y1: 5.006,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: -4.328,
				y2: -2.828,
				sweep: true,
				large: true
			},
			{
				ref: 3,
				mode: "o",
				x2: -3.108,
				y2: -0.328
			},
			{
				ref: 0,
				mode: "o",
				x2: -1.328,
				y2: 2.828
			},
			{
				ref: 1,
				mode: "o",
				x2: 0,
				y2: 5.006
			}
		],
		text: {
			x: -5.036,
			y: -1.414
		}
	},
	{
		sets: [
			3
		],
		x1: -4.328,
		y1: -2.828,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: 0,
				y2: -3.94,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: -2.179,
				y2: -1.858,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: -4.328,
				y2: -2.828,
				large: false
			}
		],
		text: {
			x: -2.914,
			y: -3.536
		}
	},
	{
		sets: [
			0,
			1
		],
		x1: 4.328,
		y1: -2.828,
		arcs: [
			{
				ref: 1,
				mode: "i",
				x2: 3.108,
				y2: -0.328,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: 2.179,
				y2: -1.858,
				sweep: false,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: 4.328,
				y2: -2.828,
				sweep: true,
				large: false
			}
		],
		text: {
			x: 3.205,
			y: -1.672
		}
	},
	{
		sets: [
			0,
			2
		],
		x1: -1.328,
		y1: 2.828,
		arcs: [
			{
				ref: 0,
				mode: "i",
				x2: -3.108,
				y2: -0.328,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: -0.969,
				y2: 1.755,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: -1.328,
				y2: 2.828,
				large: false
			}
		],
		text: {
			x: -2.212,
			y: 1.591
		}
	},
	{
		sets: [
			0,
			3
		],
		x1: 0,
		y1: -3.94,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: 2.179,
				y2: -1.858,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: 0,
				y2: 0.188,
				sweep: false,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: -2.179,
				y2: -1.858,
				sweep: false,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: 0,
				y2: -3.94,
				sweep: true
			}
		],
		text: {
			x: 0,
			y: -1.87
		}
	},
	{
		sets: [
			1,
			2
		],
		x1: 1.328,
		y1: 2.828,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: 0,
				y2: 5.006,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: -1.328,
				y2: 2.828,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: 0,
				y2: 2.346,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: 1.328,
				y2: 2.828
			}
		],
		text: {
			x: 0,
			y: 3.393
		}
	},
	{
		sets: [
			1,
			3
		],
		x1: 3.108,
		y1: -0.328,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: 1.328,
				y2: 2.828,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: 0.969,
				y2: 1.755,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: 3.108,
				y2: -0.328,
				large: false
			}
		],
		text: {
			x: 2.212,
			y: 1.591
		}
	},
	{
		sets: [
			2,
			3
		],
		x1: -3.108,
		y1: -0.328,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: -4.328,
				y2: -2.828,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "i",
				x2: -2.179,
				y2: -1.858,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: -3.108,
				y2: -0.328,
				large: false
			}
		],
		text: {
			x: -3.205,
			y: -1.672
		}
	},
	{
		sets: [
			0,
			1,
			2
		],
		x1: 0,
		y1: 2.346,
		arcs: [
			{
				ref: 0,
				mode: "i",
				x2: -1.328,
				y2: 2.828,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: -0.969,
				y2: 1.755,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: 0,
				y2: 2.346,
				large: false
			}
		],
		text: {
			x: -0.766,
			y: 2.31
		}
	},
	{
		sets: [
			0,
			1,
			3
		],
		x1: 2.179,
		y1: -1.858,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: 3.108,
				y2: -0.328,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: 0.969,
				y2: 1.755,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: 0,
				y2: 0.188,
				sweep: false,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: 2.179,
				y2: -1.858,
				sweep: true
			}
		],
		text: {
			x: 1.558,
			y: -0.056
		}
	},
	{
		sets: [
			0,
			2,
			3
		],
		x1: -0.969,
		y1: 1.755,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: -3.108,
				y2: -0.328,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: -2.179,
				y2: -1.858,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "i",
				x2: 0,
				y2: 0.188,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: -0.969,
				y2: 1.755
			}
		],
		text: {
			x: -1.558,
			y: -0.056
		}
	},
	{
		sets: [
			1,
			2,
			3
		],
		x1: 1.328,
		y1: 2.828,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: 0,
				y2: 2.346,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: 0.969,
				y2: 1.755,
				sweep: false,
				large: false
			},
			{
				ref: 2,
				mode: "i",
				x2: 1.328,
				y2: 2.828,
				sweep: true,
				large: false
			}
		],
		text: {
			x: 0.766,
			y: 2.31
		}
	},
	{
		sets: [
			0,
			1,
			2,
			3
		],
		x1: 0,
		y1: 0.188,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: 0.969,
				y2: 1.755,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: 0,
				y2: 2.346,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "i",
				x2: -0.969,
				y2: 1.755,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: 0,
				y2: 0.188,
				sweep: true
			}
		],
		text: {
			x: 0,
			y: 1.43
		}
	}
];
var bb$4 = {
	x: -6.5,
	y: -5,
	width: 13,
	height: 10
};
var venn4 = {
	sets: sets$4,
	intersections: intersections$4,
	bb: bb$4
};

var sets$5 = [
	{
		cx: 0.5,
		cy: -1,
		rx: 2.5,
		ry: 5,
		rotation: 0,
		text: {
			x: 2.25,
			y: -5
		},
		align: "start",
		verticalAlign: "bottom"
	},
	{
		cx: 1.106,
		cy: 0.167,
		rx: 2.5,
		ry: 5,
		rotation: 72,
		text: {
			x: 4.5,
			y: 1.5
		},
		align: "start",
		verticalAlign: "top"
	},
	{
		cx: 0.183,
		cy: 1.103,
		rx: 2.5,
		ry: 5,
		rotation: 144,
		text: {
			x: 4,
			y: 4
		},
		align: "start",
		verticalAlign: "bottom"
	},
	{
		cx: -0.992,
		cy: 0.515,
		rx: 2.5,
		ry: 5,
		rotation: 216,
		text: {
			x: -4.7,
			y: 2
		},
		align: "end",
		verticalAlign: "bottom"
	},
	{
		cx: -0.797,
		cy: -0.785,
		rx: 2.5,
		ry: 5,
		rotation: 288,
		text: {
			x: -4,
			y: -3.6
		},
		align: "end",
		verticalAlign: "bottom"
	}
];
var intersections$5 = [
	{
		sets: [
			0
		],
		x1: -1.653,
		y1: -3.541,
		arcs: [
			{
				ref: 0,
				mode: "i",
				x2: 2.857,
				y2: -2.666,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: 2.5,
				y2: -2.648,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: -0.495,
				y2: -3.303,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: -1.653,
				y2: -3.541
			}
		],
		text: {
			x: 0.5,
			y: -5
		}
	},
	{
		sets: [
			1
		],
		x1: 2.857,
		y1: -2.666,
		arcs: [
			{
				ref: 1,
				mode: "i",
				x2: 3.419,
				y2: 1.893,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: 3.291,
				y2: 1.559,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: 2.988,
				y2: -1.492,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: 2.857,
				y2: -2.666
			}
		],
		text: {
			x: 4.91,
			y: -1.07
		}
	},
	{
		sets: [
			2
		],
		x1: 3.419,
		y1: 1.893,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: -0.744,
				y2: 3.837,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: -0.466,
				y2: 3.612,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: 2.342,
				y2: 2.381,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: 3.419,
				y2: 1.893
			}
		],
		text: {
			x: 2.534,
			y: 4.339
		}
	},
	{
		sets: [
			3
		],
		x1: -0.744,
		y1: 3.837,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: -3.879,
				y2: 0.478,
				sweep: true,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: -3.579,
				y2: 0.673,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: -1.54,
				y2: 2.963,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: -0.744,
				y2: 3.837
			}
		],
		text: {
			x: -3.343,
			y: 3.751
		}
	},
	{
		sets: [
			4
		],
		x1: -3.879,
		y1: 0.478,
		arcs: [
			{
				ref: 4,
				mode: "i",
				x2: -1.653,
				y2: -3.541,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: -1.746,
				y2: -3.196,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: -3.294,
				y2: -0.549,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: -3.879,
				y2: 0.478
			}
		],
		text: {
			x: -4.601,
			y: -2.021
		}
	},
	{
		sets: [
			0,
			1
		],
		x1: 2.5,
		y1: -2.648,
		arcs: [
			{
				ref: 1,
				mode: "i",
				x2: 2.857,
				y2: -2.666,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: 2.988,
				y2: -1.492,
				sweep: true,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: 2.572,
				y2: -1.839,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: 2.5,
				y2: -2.648
			}
		],
		text: {
			x: 2.741,
			y: -2.152
		}
	},
	{
		sets: [
			0,
			2
		],
		x1: 2.342,
		y1: 2.381,
		arcs: [
			{
				ref: 0,
				mode: "i",
				x2: -0.466,
				y2: 3.612,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: 0.257,
				y2: 2.922,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: 2.342,
				y2: 2.381,
				large: false
			}
		],
		text: {
			x: 0.5,
			y: 3.5
		}
	},
	{
		sets: [
			0,
			3
		],
		x1: -0.495,
		y1: -3.303,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: 2.5,
				y2: -2.648,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: 1.51,
				y2: -2.515,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: -0.495,
				y2: -3.303,
				large: false
			}
		],
		text: {
			x: 1.653,
			y: -3.125
		}
	},
	{
		sets: [
			0,
			4
		],
		x1: -1.653,
		y1: -3.541,
		arcs: [
			{
				ref: 4,
				mode: "i",
				x2: -0.495,
				y2: -3.303,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: -0.954,
				y2: -3.015,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: -1.746,
				y2: -3.196,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: -1.653,
				y2: -3.541
			}
		],
		text: {
			x: -1.199,
			y: -3.272
		}
	},
	{
		sets: [
			1,
			2
		],
		x1: 3.291,
		y1: 1.559,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: 3.419,
				y2: 1.893,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: 2.342,
				y2: 2.381,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: 2.544,
				y2: 1.878,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: 3.291,
				y2: 1.559
			}
		],
		text: {
			x: 2.894,
			y: 1.942
		}
	},
	{
		sets: [
			1,
			3
		],
		x1: -1.54,
		y1: 2.963,
		arcs: [
			{
				ref: 1,
				mode: "i",
				x2: -3.579,
				y2: 0.673,
				sweep: true,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: -2.7,
				y2: 1.147,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: -1.54,
				y2: 2.963,
				large: false
			}
		],
		text: {
			x: -3.174,
			y: 1.557
		}
	},
	{
		sets: [
			1,
			4
		],
		x1: 2.988,
		y1: -1.492,
		arcs: [
			{
				ref: 4,
				mode: "i",
				x2: 3.291,
				y2: 1.559,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: 2.858,
				y2: 0.659,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: 2.988,
				y2: -1.492,
				large: false
			}
		],
		text: {
			x: 3.483,
			y: 0.606
		}
	},
	{
		sets: [
			2,
			3
		],
		x1: -0.466,
		y1: 3.612,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: -0.744,
				y2: 3.837,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "i",
				x2: -1.54,
				y2: 2.963,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: -1,
				y2: 3,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: -0.466,
				y2: 3.612
			}
		],
		text: {
			x: -0.953,
			y: 3.352
		}
	},
	{
		sets: [
			2,
			4
		],
		x1: -3.294,
		y1: -0.549,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: -1.746,
				y2: -3.196,
				sweep: true
			},
			{
				ref: 0,
				mode: "o",
				x2: -1.925,
				y2: -2.213
			},
			{
				ref: 3,
				mode: "o",
				x2: -3.294,
				y2: -0.549
			}
		],
		text: {
			x: -2.462,
			y: -2.538
		}
	},
	{
		sets: [
			3,
			4
		],
		x1: -3.579,
		y1: 0.673,
		arcs: [
			{
				ref: 4,
				mode: "i",
				x2: -3.879,
				y2: 0.478,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "i",
				x2: -3.294,
				y2: -0.549,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: -3.162,
				y2: -0.024,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: -3.579,
				y2: 0.673
			}
		],
		text: {
			x: -3.483,
			y: 0.13
		}
	},
	{
		sets: [
			0,
			1,
			2
		],
		x1: 2.544,
		y1: 1.878,
		arcs: [
			{
				ref: 0,
				mode: "i",
				x2: 2.342,
				y2: 2.381,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: 0.257,
				y2: 2.922,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: 0.983,
				y2: 2.049,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: 2.544,
				y2: 1.878
			}
		],
		text: {
			x: 1.457,
			y: 2.331
		}
	},
	{
		sets: [
			0,
			1,
			3
		],
		x1: 1.51,
		y1: -2.515,
		arcs: [
			{
				ref: 1,
				mode: "i",
				x2: 2.5,
				y2: -2.648,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "i",
				x2: 2.572,
				y2: -1.839,
				sweep: true,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: 1.51,
				y2: -2.515,
				large: false
			}
		],
		text: {
			x: 2.194,
			y: -2.334
		}
	},
	{
		sets: [
			0,
			1,
			4
		],
		x1: 2.572,
		y1: -1.839,
		arcs: [
			{
				ref: 4,
				mode: "i",
				x2: 2.988,
				y2: -1.492,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: 2.858,
				y2: 0.659,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: 2.253,
				y2: -0.302,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: 2.572,
				y2: -1.839
			}
		],
		text: {
			x: 2.667,
			y: -0.665
		}
	},
	{
		sets: [
			0,
			2,
			3
		],
		x1: 0.257,
		y1: 2.922,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: -0.466,
				y2: 3.612,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: -1,
				y2: 3,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: 0.257,
				y2: 2.922,
				large: false
			}
		],
		text: {
			x: -0.403,
			y: 3.178
		}
	},
	{
		sets: [
			0,
			2,
			4
		],
		x1: -1.746,
		y1: -3.196,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: -0.954,
				y2: -3.015,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: -1.925,
				y2: -2.213,
				sweep: false,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: -1.746,
				y2: -3.196,
				sweep: true,
				large: false
			}
		],
		text: {
			x: -1.542,
			y: -2.808
		}
	},
	{
		sets: [
			0,
			3,
			4
		],
		x1: -0.495,
		y1: -3.303,
		arcs: [
			{
				ref: 4,
				mode: "i",
				x2: 1.51,
				y2: -2.515,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: 0.409,
				y2: -2.236,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: -0.954,
				y2: -3.015,
				large: false
			},
			{
				ref: 3,
				mode: "i",
				x2: -0.495,
				y2: -3.303
			}
		],
		text: {
			x: 0.192,
			y: -2.742
		}
	},
	{
		sets: [
			1,
			2,
			3
		],
		x1: -1.54,
		y1: 2.963,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: -2.7,
				y2: 1.147,
				sweep: true,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: -1.645,
				y2: 1.568,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: -1,
				y2: 3,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: -1.54,
				y2: 2.963
			}
		],
		text: {
			x: -1.767,
			y: 2.106
		}
	},
	{
		sets: [
			1,
			2,
			4
		],
		x1: 2.858,
		y1: 0.659,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: 3.291,
				y2: 1.559,
				sweep: true,
				large: false
			},
			{
				ref: 4,
				mode: "i",
				x2: 2.544,
				y2: 1.878,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: 2.858,
				y2: 0.659,
				large: false
			}
		],
		text: {
			x: 2.898,
			y: 1.365
		}
	},
	{
		sets: [
			1,
			3,
			4
		],
		x1: -2.7,
		y1: 1.147,
		arcs: [
			{
				ref: 4,
				mode: "i",
				x2: -3.579,
				y2: 0.673,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: -3.162,
				y2: -0.024,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: -2.7,
				y2: 1.147,
				large: false
			}
		],
		text: {
			x: -3.147,
			y: 0.599
		}
	},
	{
		sets: [
			2,
			3,
			4
		],
		x1: -3.294,
		y1: -0.549,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: -1.925,
				y2: -2.213,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: -2,
				y2: -1.08,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: -3.162,
				y2: -0.024,
				large: false
			},
			{
				ref: 2,
				mode: "i",
				x2: -3.294,
				y2: -0.549
			}
		],
		text: {
			x: -2.548,
			y: -1.029
		}
	},
	{
		sets: [
			0,
			1,
			2,
			3
		],
		x1: 0.983,
		y1: 2.049,
		arcs: [
			{
				ref: 3,
				mode: "i",
				x2: 0.257,
				y2: 2.922,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: -1,
				y2: 3,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: -1.645,
				y2: 1.568,
				sweep: true,
				large: false
			},
			{
				ref: 4,
				mode: "o",
				x2: 0.983,
				y2: 2.049
			}
		],
		text: {
			x: -0.407,
			y: 2.31
		}
	},
	{
		sets: [
			0,
			1,
			2,
			4
		],
		x1: 2.253,
		y1: -0.302,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: 2.858,
				y2: 0.659,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: 2.544,
				y2: 1.878,
				sweep: true,
				large: false
			},
			{
				ref: 4,
				mode: "i",
				x2: 0.983,
				y2: 2.049,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "o",
				x2: 2.253,
				y2: -0.302
			}
		],
		text: {
			x: 2.071,
			y: 1.101
		}
	},
	{
		sets: [
			0,
			1,
			3,
			4
		],
		x1: 1.51,
		y1: -2.515,
		arcs: [
			{
				ref: 4,
				mode: "i",
				x2: 2.572,
				y2: -1.839,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "i",
				x2: 2.253,
				y2: -0.302,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "o",
				x2: 0.409,
				y2: -2.236,
				sweep: false,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: 1.51,
				y2: -2.515,
				sweep: true
			}
		],
		text: {
			x: 1.687,
			y: -1.63
		}
	},
	{
		sets: [
			0,
			2,
			3,
			4
		],
		x1: -2,
		y1: -1.08,
		arcs: [
			{
				ref: 0,
				mode: "i",
				x2: -1.925,
				y2: -2.213,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "i",
				x2: -0.954,
				y2: -3.015,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "i",
				x2: 0.409,
				y2: -2.236,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "o",
				x2: -2,
				y2: -1.08
			}
		],
		text: {
			x: -1.028,
			y: -2.108
		}
	},
	{
		sets: [
			1,
			2,
			3,
			4
		],
		x1: -1.645,
		y1: 1.568,
		arcs: [
			{
				ref: 4,
				mode: "i",
				x2: -2.7,
				y2: 1.147,
				sweep: true,
				large: false
			},
			{
				ref: 2,
				mode: "i",
				x2: -3.162,
				y2: -0.024,
				sweep: true,
				large: false
			},
			{
				ref: 1,
				mode: "i",
				x2: -2,
				y2: -1.08,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "o",
				x2: -1.645,
				y2: 1.568
			}
		],
		text: {
			x: -2.323,
			y: 0.327
		}
	},
	{
		sets: [
			0,
			1,
			2,
			3,
			4
		],
		x1: 0.409,
		y1: -2.236,
		arcs: [
			{
				ref: 2,
				mode: "i",
				x2: 2.253,
				y2: -0.302,
				sweep: true,
				large: false
			},
			{
				ref: 3,
				mode: "i",
				x2: 0.983,
				y2: 2.049,
				sweep: true,
				large: false
			},
			{
				ref: 4,
				mode: "i",
				x2: -1.645,
				y2: 1.568,
				sweep: true,
				large: false
			},
			{
				ref: 0,
				mode: "i",
				x2: -2,
				y2: -1.08,
				sweep: true
			},
			{
				ref: 1,
				mode: "i",
				x2: 0.409,
				y2: -2.236,
				sweep: true
			}
		],
		text: {
			x: 0,
			y: 0
		}
	}
];
var bb$5 = {
	x: -5.5,
	y: -6,
	width: 11.6,
	height: 11.8
};
var venn5 = {
	sets: sets$5,
	intersections: intersections$5,
	bb: bb$5
};

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function isEllipse(d) {
    return typeof d.rx === 'number';
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const vennDiagramLayout = {
    maxSets: 5,
    compute(sets, _combinations, width, height) {
        return layoutImpl(sets.length, width, height);
    },
};
function layoutImpl(sets, width, height) {
    const lookup = [venn0, venn1, venn2, venn3, venn4, venn5];
    const r = lookup[Math.min(lookup.length - 1, sets)];
    const f = Math.min(width / r.bb.width, height / r.bb.height);
    const x = f * -r.bb.x + (width - f * r.bb.width) / 2;
    const y = f * -r.bb.y + (height - f * r.bb.height) / 2;
    const mx = (v) => x + f * v;
    const my = (v) => y + f * v;
    return {
        sets: r.sets.map((c) => Object.assign({}, c, {
            cx: mx(c.cx),
            cy: my(c.cy),
            text: {
                x: mx(c.text.x),
                y: my(c.text.y),
            },
        }, isEllipse(c)
            ? {
                rx: c.rx * f,
                ry: c.ry * f,
            }
            : {
                r: c.r * f,
            })),
        intersections: r.intersections.map((c) => ({
            text: {
                x: mx(c.text.x),
                y: my(c.text.y),
            },
            x1: mx(c.x1),
            y1: my(c.y1),
            sets: c.sets,
            arcs: c.arcs.map((a) => Object.assign({}, a, {
                x2: mx(a.x2),
                y2: my(a.y2),
            })),
        })),
    };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const lightTheme = {
    selectionColor: '#ffa500',
    color: '#000000',
    hasSelectionColor: '',
    opacity: 1,
    hasSelectionOpacity: -1,
    textColor: '#000000',
    hoverHintColor: '#cccccc',
    notMemberColor: '#d3d3d3',
    alternatingBackgroundColor: 'rgba(0,0,0,0.05)',
    valueTextColor: '#000000',
    strokeColor: '#000000',
    backgroundColor: '#ffffff',
    filled: false,
};
const darkTheme = {
    selectionColor: '#ffa500',
    color: '#cccccc',
    hasSelectionColor: '',
    opacity: 1,
    hasSelectionOpacity: -1,
    textColor: '#ffffff',
    hoverHintColor: '#d9d9d9',
    notMemberColor: '#666666',
    alternatingBackgroundColor: 'rgba(255, 255, 255, 0.2)',
    valueTextColor: '#ffffff',
    strokeColor: '#ffffff',
    backgroundColor: '#303030',
    filled: false,
};
const vegaTheme = {
    selectionColor: '#4c78a8',
    color: '#4c78a8',
    hasSelectionColor: '#c9d6e5',
    opacity: 1,
    hasSelectionOpacity: -1,
    textColor: '#000000',
    hoverHintColor: '#cccccc',
    notMemberColor: '#d3d3d3',
    alternatingBackgroundColor: 'rgba(0,0,0,0.05)',
    valueTextColor: '#000000',
    strokeColor: '#000000',
    backgroundColor: '#ffffff',
    filled: true,
};
function getDefaultTheme(theme) {
    return theme === 'vega' ? vegaTheme : theme === 'dark' ? darkTheme : lightTheme;
}
function areCombinations(combinations) {
    return Array.isArray(combinations);
}
function fillGeneric(base, props, others = {}) {
    const theme = getDefaultTheme(props.theme);
    return Object.assign(base, {
        queryLegend: props.queries != null && props.queries.length > 0,
        theme: 'light',
        padding: 20,
        selection: null,
        title: '',
        description: '',
        fontFamily: 'sans-serif',
        queries: EMPTY_ARRAY,
        exportButtons: true,
        className: '',
        fontSizes: DEFAULT_FONT_SIZES,
        classNames: EMPTY_OBJECT,
        style: EMPTY_OBJECT,
        styles: EMPTY_OBJECT,
        toKey,
        tooltips: true,
    }, theme, props, others, props.fontSizes
        ? {
            fontSizes: Object.assign({}, DEFAULT_FONT_SIZES, props.fontSizes),
        }
        : EMPTY_OBJECT);
}
/**
 * helper methods to fill up partial UpSet.js properties with their default values
 */
function fillDefaultsG(props) {
    return fillGeneric({
        barPadding: 0.3,
        dotPadding: 0.7,
        combinations: DEFAULT_COMBINATIONS,
        combinationName: props.combinations != null && !areCombinations(props.combinations) && props.combinations.type === 'union'
            ? 'Union Size'
            : 'Intersection Size',
        barLabelOffset: 2,
        setNameAxisOffset: 'auto',
        combinationNameAxisOffset: 'auto',
        setName: 'Set Size',
        widthRatios: DEFAULT_WIDTH_RATIO,
        heightRatios: DEFAULT_HEIGHT_RATIO,
        setLabelAlignment: 'center',
        numericScale: 'linear',
        bandScale: 'band',
        childrenFactories: EMPTY_OBJECT,
        setAddons: EMPTY_ARRAY,
        combinationAddons: EMPTY_ARRAY,
        setAddonPadding: 1,
        combinationAddonPadding: 1,
        emptySelection: true,
    }, props);
}
function valueFormat(v) {
    return v.toLocaleString();
}
function fillDefaults(props) {
    return fillDefaultsG(props);
}
/**
 * helper methods to fill up partial UpSet.js properties with their default values
 */
function fillVennDiagramDefaultsG(props) {
    return fillGeneric({
        valueFormat,
        layout: vennDiagramLayout,
    }, props, {
        exportButtons: props.exportButtons === false
            ? false
            : Object.assign({}, props.exportButtons === true ? {} : props.exportButtons, { vega: false }),
    });
}
function fillVennDiagramDefaults(props) {
    return fillVennDiagramDefaultsG(props);
}
/**
 * helper methods to fill up partial UpSet.js properties with their default values
 */
function fillKarnaughMapDefaultsG(props) {
    return fillGeneric({
        numericScale: 'linear',
        barPadding: 0.3,
        barLabelOffset: 2,
        combinationName: 'Intersection Size',
        combinationNameAxisOffset: 'auto',
    }, props, {
        exportButtons: props.exportButtons === false
            ? false
            : Object.assign({}, props.exportButtons === true ? {} : props.exportButtons, { vega: false }),
    });
}
function fillKarnaughMapDefaults(props) {
    return fillKarnaughMapDefaultsG(props);
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function createSVG(node, toRemove) {
    const clone = node.cloneNode(true);
    clone.style.backgroundColor = getDefaultTheme(node.dataset.theme).backgroundColor;
    if (toRemove) {
        Array.from(clone.querySelectorAll(toRemove)).forEach((d) => d.remove());
    }
    return new XMLSerializer().serializeToString(clone);
}
/**
 * helper method to export an download an SVG image
 * @param node the SVG element to download
 * @param options additional options
 */
function exportSVG(node, { type = 'png', title, toRemove }) {
    const b = new Blob([createSVG(node, toRemove)], {
        type: 'image/svg+xml;charset=utf-8',
    });
    const styleId = extractStyleId(node);
    const chartTitle = title !== null && title !== void 0 ? title : extractTitle(node, styleId);
    const url = URL.createObjectURL(b);
    if (type === 'svg') {
        downloadUrl(url, `${chartTitle}.${type}`, node.ownerDocument);
        URL.revokeObjectURL(url);
        return Promise.resolve();
    }
    return toPNG(url, node).then((purl) => {
        downloadUrl(purl, `${chartTitle}.${type}`, node.ownerDocument);
        URL.revokeObjectURL(url);
    });
}
function toPNG(url, node) {
    const canvas = node.ownerDocument.createElement('canvas');
    const bb = node.getBoundingClientRect();
    canvas.width = bb.width;
    canvas.height = bb.height;
    const ctx = canvas.getContext('2d');
    const img = new Image(canvas.width, canvas.height);
    return new Promise((resolve) => {
        img.onload = () => {
            ctx.drawImage(img, 0, 0);
            const png = canvas.toDataURL('image/png');
            resolve(png);
        };
        img.src = url;
    });
}
/**
 * helper method to download a given url in the browser
 * @param url the url to download
 * @param title the desired file name
 * @param doc the root document
 */
function downloadUrl(url, title, doc) {
    const a = doc.createElement('a');
    a.href = url;
    a.style.position = 'absolute';
    a.style.left = '-10000px';
    a.style.top = '-10000px';
    a.download = title;
    doc.body.appendChild(a);
    a.click();
    a.remove();
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function createVegaSpec(svg, title) {
    var _a, _b, _c, _d, _e;
    const resolveStyle = (_c = (svg.getComputedStyle || ((_b = (_a = svg.ownerDocument) === null || _a === void 0 ? void 0 : _a.defaultView) === null || _b === void 0 ? void 0 : _b.getComputedStyle))) !== null && _c !== void 0 ? _c : window.getComputedStyle;
    const styleId = extractStyleId(svg);
    const chartTitle = title !== null && title !== void 0 ? title : extractTitle(svg, styleId);
    const sets = Array.from(svg.querySelectorAll('[data-upset=sets] [data-cardinality]'))
        .map((set) => {
        return {
            name: set.querySelector(`text.setTextStyle-${styleId}`).textContent,
            cardinality: Number.parseInt(set.dataset.cardinality, 10),
        };
    })
        .reverse();
    const barLabelOffset = -Number.parseFloat(svg.querySelector(`.sBarTextStyle-${styleId}`).getAttribute('dx'));
    const color = resolveStyle(svg.querySelector(`.fillPrimary-${styleId}`)).fill;
    const fillNotMember = resolveStyle(svg.querySelector(`.fillNotMember-${styleId}`)).fill;
    const textColor = resolveStyle(svg.querySelector('text')).fill;
    const csName = svg.querySelector(`.cChartTextStyle-${styleId}`).textContent;
    const setName = svg.querySelector(`.sChartTextStyle-${styleId}`).textContent;
    const combinations = Array.from(svg.querySelectorAll('[data-upset=cs] [data-cardinality]')).map((set) => {
        return {
            name: set.querySelector(`text.hoverBarTextStyle-${styleId}`).textContent,
            cardinality: Number.parseInt(set.dataset.cardinality, 10),
            sets: Array.from(set.querySelectorAll(`.fillPrimary-${styleId} > title`)).map((n) => n.textContent),
        };
    });
    const translateX = (v) => Number.parseFloat(v.getAttribute('transform').match(/([\d.]+),/)[1]);
    const translateY = (v) => Number.parseFloat(v.getAttribute('transform').match(/,([\d.]+)/)[1]);
    const base = svg.querySelector('[data-upset=base]');
    const padding = translateX(base);
    // combination axis block
    const setWidth = translateX(svg.querySelector('[data-upset=csaxis]'));
    // axisline
    const csWidth = Number.parseFloat(base.querySelector('g').firstElementChild.children[1].getAttribute('x2'));
    // set axis block
    const csHeight = translateY(svg.querySelector('[data-upset=setaxis]'));
    // set label clip path
    const labelWidth = Number.parseFloat(svg.querySelector('defs rect').getAttribute('width'));
    const setHeight = Number.parseFloat(svg.querySelector('defs rect').getAttribute('height'));
    const radius = Number.parseFloat(svg.querySelector(`[data-cardinality] circle.fillPrimary-${styleId}`).getAttribute('r'));
    const hasPrimarySelection = svg.querySelector('[data-upset=sets-s] [data-cardinality]') != null;
    const hasQuery = svg.querySelector('[data-upset=sets-q] [data-cardinality]') != null;
    const hasSelection = hasPrimarySelection || hasQuery;
    let selectionColor = 'orange';
    if (hasSelection) {
        // inject the selection data
        Array.from(svg.querySelectorAll(`[data-upset=sets-${hasPrimarySelection ? 's]' : 'q]:first-of-type'} [data-cardinality]`)).forEach((elem) => {
            // since artificially reversed
            const i = sets.length - Number.parseInt(elem.dataset.i, 10) - 1;
            sets[i].selection = Number.parseInt(elem.dataset.cardinality, 10);
        });
        Array.from(svg.querySelectorAll(`[data-upset=cs-${hasPrimarySelection ? 's]' : 'q]:first-of-type'} [data-cardinality]`)).forEach((elem) => {
            const i = Number.parseInt(elem.dataset.i, 10);
            combinations[i].selection = Number.parseInt(elem.dataset.cardinality, 10);
        });
        selectionColor = resolveStyle(svg.querySelector(`[data-upset=sets-${hasPrimarySelection ? 's' : 'q'}] [data-cardinality]`)).fill;
    }
    const highlightedCombination = Number.parseInt((_e = (_d = svg.querySelector('[data-upset=cs-ss]')) === null || _d === void 0 ? void 0 : _d.dataset.i) !== null && _e !== void 0 ? _e : '-1', 10);
    const filter = highlightedCombination >= 0
        ? {
            field: 'partOf',
            oneOf: [1, 2],
        }
        : {
            field: 'partOf',
            equal: 1,
        };
    // part of: 0 ... negative list, 1 ... positive set list, 2, ... positive and selected
    return {
        $schema: 'https://vega.github.io/schema/vega-lite/v4.json',
        title: chartTitle,
        description: extractDescription(svg, styleId),
        datasets: {
            sets,
            combinations: combinations
                .map((c, i) => Object.assign({}, c, {
                partOf: highlightedCombination === i ? 2 : 1,
                nsets: [''],
            }))
                .concat(combinations.map((c) => ({
                name: c.name,
                cardinality: c.cardinality,
                // no selection!
                partOf: 0,
                sets: [''],
                nsets: sets.filter((s) => !c.sets.includes(s.name)).map((s) => s.name),
            }))),
        },
        vconcat: [
            {
                hconcat: [
                    {
                        mark: 'bar',
                        width: setWidth + labelWidth - 40,
                        height: csHeight,
                    },
                    {
                        width: csWidth,
                        height: csHeight,
                        data: {
                            name: 'combinations',
                        },
                        transform: [
                            {
                                filter,
                            },
                        ],
                        layer: [
                            {
                                mark: {
                                    type: 'bar',
                                    tooltip: true,
                                },
                            },
                            {
                                mark: {
                                    type: 'text',
                                    align: 'center',
                                    baseline: 'bottom',
                                    dy: -barLabelOffset,
                                },
                                encoding: {
                                    text: { field: 'cardinality', type: 'quantitative' },
                                },
                            },
                            hasSelection && {
                                mark: {
                                    type: 'bar',
                                    fill: selectionColor,
                                    tooltip: true,
                                },
                                encoding: {
                                    y: {
                                        field: 'selection',
                                        type: 'quantitative',
                                    },
                                },
                            },
                        ].filter(Boolean),
                        encoding: {
                            x: { field: 'name', type: 'ordinal', axis: null, sort: null },
                            y: {
                                field: 'cardinality',
                                type: 'quantitative',
                                axis: {
                                    grid: false,
                                },
                                title: csName,
                            },
                        },
                    },
                ],
            },
            {
                hconcat: [
                    {
                        width: setWidth,
                        height: setHeight,
                        data: {
                            name: 'sets',
                        },
                        layer: [
                            {
                                mark: {
                                    type: 'bar',
                                    tooltip: true,
                                },
                            },
                            {
                                mark: {
                                    type: 'text',
                                    align: 'right',
                                    baseline: 'middle',
                                    dx: -barLabelOffset,
                                },
                                encoding: {
                                    text: { field: 'cardinality', type: 'quantitative' },
                                },
                            },
                            hasSelection && {
                                mark: {
                                    type: 'bar',
                                    fill: selectionColor,
                                    tooltip: true,
                                },
                                encoding: {
                                    x: {
                                        field: 'selection',
                                        type: 'quantitative',
                                    },
                                },
                            },
                        ].filter(Boolean),
                        encoding: {
                            y: { field: 'name', type: 'ordinal', axis: null, sort: null },
                            x: {
                                field: 'cardinality',
                                type: 'quantitative',
                                title: setName,
                                sort: 'descending',
                                axis: {
                                    grid: false,
                                },
                            },
                        },
                    },
                    {
                        data: {
                            name: 'sets',
                        },
                        width: labelWidth,
                        height: setHeight,
                        mark: {
                            type: 'text',
                            align: 'center',
                            baseline: 'middle',
                            fontSize: Number.parseInt(resolveStyle(svg.querySelector(`.setTextStyle-${styleId}`)).fontSize, 10),
                        },
                        encoding: {
                            y: { field: 'name', type: 'ordinal', axis: null, sort: null },
                            text: { field: 'name', type: 'ordinal' },
                        },
                    },
                    {
                        width: csWidth,
                        height: setHeight,
                        data: {
                            name: 'combinations',
                        },
                        transform: [
                            {
                                flatten: ['sets'],
                                as: ['has_set'],
                            },
                            {
                                flatten: ['nsets'],
                                as: ['has_not_set'],
                            },
                            {
                                calculate: 'datum.has_set+datum.has_not_set',
                                as: 'set',
                            },
                        ],
                        layer: [
                            {
                                mark: {
                                    type: 'circle',
                                    size: radius * radius * Math.PI,
                                    tooltip: true,
                                },
                                encoding: {
                                    color: {
                                        field: 'partOf',
                                        type: 'nominal',
                                        legend: null,
                                        scale: {
                                            range: [fillNotMember, color].concat(highlightedCombination >= 0 ? [selectionColor] : []),
                                        },
                                    },
                                    y: {
                                        field: 'set',
                                        type: 'ordinal',
                                        axis: null,
                                        sort: null,
                                        scale: {
                                            domain: sets.map((s) => s.name),
                                        },
                                    },
                                },
                            },
                            {
                                mark: 'rule',
                                transform: [
                                    {
                                        filter,
                                    },
                                    {
                                        calculate: 'datum.sets[datum.sets.length -1]',
                                        as: 'set_end',
                                    },
                                ],
                                encoding: Object.assign({ y: { field: 'sets[0]', type: 'ordinal', axis: null, sort: null }, y2: { field: 'set_end' } }, (highlightedCombination < 0
                                    ? {}
                                    : {
                                        color: {
                                            field: 'partOf',
                                            type: 'nominal',
                                            legend: null,
                                            scale: {
                                                range: [color, selectionColor],
                                            },
                                        },
                                    })),
                            },
                        ],
                        encoding: {
                            x: { field: 'name', type: 'ordinal', axis: null, sort: null },
                        },
                    },
                ],
            },
        ],
        config: {
            padding,
            background: getDefaultTheme(svg.dataset.theme).backgroundColor,
            concat: {
                spacing: 0,
            },
            view: {
                stroke: null,
            },
            // scale: {
            //   bandPaddingInner: props.barPadding,
            //   bandPaddingOuter: props.barPadding,
            //   pointPadding: props.barPadding,
            // },
            bar: {
                fill: color,
            },
            circle: {
                opacity: 1,
            },
            rule: {
                stroke: color,
                strokeWidth: Number.parseInt(resolveStyle(svg.querySelector(`[data-upset=cs] [data-cardinality] line`)).strokeWidth, 10),
            },
            axis: {
                labelColor: textColor,
                labelFontSize: Number.parseInt(resolveStyle(svg.querySelector(`.axisTextStyle-${styleId}`)).fontSize, 10),
                titleColor: textColor,
                titleFontSize: Number.parseInt(resolveStyle(svg.querySelector(`.cChartTextStyle-${styleId}`)).fontSize, 10),
            },
            title: {
                color: textColor,
            },
            text: {
                fill: textColor,
                fontSize: Number.parseInt(resolveStyle(svg.querySelector(`.sBarTextStyle-${styleId}`)).fontSize, 10),
            },
        },
    };
}
function exportVegaLite(svg, { title } = {}) {
    const spec = createVegaSpec(svg, title);
    const url = URL.createObjectURL(new Blob([JSON.stringify(spec, null, 2)], {
        type: 'application/json',
    }));
    downloadUrl(url, `${spec.title}.json`, svg.ownerDocument);
    URL.revokeObjectURL(url);
}

const THEME_KEYS = [
    'selectionColor',
    'color',
    'textColor',
    'hoverHintColor',
    'notMemberColor',
    'alternatingBackgroundColor',
    'hasSelectionColor',
    'hasSelectionOpacity',
    'opacity',
    'strokeColor',
    'valueTextColor',
];
const LAYOUT_KEYS = [
    'padding',
    'barPadding',
    'dotPadding',
    'widthRatios',
    'heightRatios',
];
const STYLE_KEYS = [
    'fontSizes',
    'combinationName',
    'setName',
    'barLabelOffset',
    'setNameAxisOffset',
    'combinationNameAxisOffset',
    'theme',
    'fontFamily',
    'emptySelection',
    'exportButtons',
    'queryLegend',
];
const DUMP_KEYS = ['bandScale', 'numericScale'].concat(THEME_KEYS, LAYOUT_KEYS, STYLE_KEYS);
function toDumpProps(props) {
    var _a;
    const full = fillDefaults({
        width: 0,
        height: 0,
        sets: (_a = props.sets) !== null && _a !== void 0 ? _a : [],
        combinations: props.combinations,
        theme: props.theme,
    });
    const r = {};
    DUMP_KEYS.forEach((key) => {
        const value = props[key];
        const defaultValue = full[key];
        if (key === 'theme' && value !== 'light') {
            // keep dark theme flag
            r[key] = value;
            return;
        }
        if (value == null || value === defaultValue) {
            return;
        }
        if (key === 'fontSizes') {
            // nested check
            let empty = true;
            const sub = {};
            FONT_SIZES_KEYS.forEach((fKey) => {
                const fValue = value[fKey];
                const fDefaultValue = defaultValue[fKey];
                if (fValue !== fDefaultValue) {
                    sub[fKey] = fValue;
                    empty = false;
                }
            });
            if (!empty) {
                r[key] = sub;
            }
        }
        else {
            r[key] = value;
        }
    });
    return r;
}
function toUpSetJSDump(dump, elements, props, author, mode) {
    return Object.assign({
        $schema: 'https://upset.js.org/schema.1.0.0.json',
        name: typeof props.title === 'string' ? props.title : 'UpSetJS',
        description: typeof props.description === 'string' ? props.description : '',
        mode,
        author,
        elements,
        attrs: [],
        props: toDumpProps(props),
    }, dump);
}
function toUpSetJSStaticDump(dump, props, author, mode) {
    return Object.assign({
        $schema: 'https://upset.js.org/schema-static.1.0.0.json',
        name: typeof props.title === 'string' ? props.title : 'UpSetJS',
        description: typeof props.description === 'string' ? props.description : '',
        mode,
        author,
        props: toDumpProps(props),
    }, dump);
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function exportDumpData(props, data, compress = false, mode) {
    var _a, _b;
    const elems = [];
    const lookup = new Map();
    const toElemIndex = (elem) => {
        if (lookup.has(elem)) {
            return lookup.get(elem);
        }
        lookup.set(elem, elems.length);
        elems.push(elem);
        return elems.length - 1;
    };
    const dump = toDump({
        sets: props.sets,
        queries: (_b = (_a = props.queries) === null || _a === void 0 ? void 0 : _a.filter((d) => isElemQuery(d) || isSetQuery(d))) !== null && _b !== void 0 ? _b : [],
        toElemIndex,
        selection: props.selection && isSetLike$1(props.selection) ? props.selection : undefined,
        combinations: data.cs.v,
        combinationOptions: Array.isArray(props.combinations)
            ? {}
            : props.combinations,
    }, {
        compress: compress ? 'yes' : 'no',
    });
    return toUpSetJSDump(dump, elems, props, undefined, mode);
}
function exportStaticDumpData(props, data, compress = false, mode) {
    var _a, _b;
    const dump = toStaticDump({
        sets: props.sets,
        queries: (_b = (_a = props.queries) === null || _a === void 0 ? void 0 : _a.filter((d) => isElemQuery(d) || isSetQuery(d))) !== null && _b !== void 0 ? _b : [],
        selection: props.selection && isSetLike$1(props.selection) ? props.selection : undefined,
        combinations: data.cs.v,
    }, {
        compress: compress ? 'yes' : 'no',
    });
    return toUpSetJSStaticDump(dump, props, undefined, mode);
}
function exportDump(svg, props, data, mode) {
    const dump = exportDumpData(props, data, false, mode);
    const url = URL.createObjectURL(new Blob([JSON.stringify(dump, null, 2)], {
        type: 'application/json',
    }));
    downloadUrl(url, `${dump.name}.json`, svg.ownerDocument);
    URL.revokeObjectURL(url);
}
const MAX_URL_LENGTH = 2048 * 2;
function exportSharedLink(props, data, mode) {
    const r = exportDumpData(props, data, true, mode);
    delete r.$schema;
    const arg = LZString.compressToEncodedURIComponent(JSON.stringify(r));
    const url = new URL('https://upset.js.org/app/embed.html');
    url.searchParams.set('p', arg);
    if (url.toString().length < MAX_URL_LENGTH) {
        window.open(url.toString(), '_blank');
        return true;
    }
    // try other compression
    const r2 = exportStaticDumpData(props, data, true, mode);
    delete r2.$schema;
    const arg2 = LZString.compressToEncodedURIComponent(JSON.stringify(r2));
    url.searchParams.set('p', arg2);
    if (url.toString().length < MAX_URL_LENGTH) {
        window.open(url.toString(), '_blank');
        return true;
    }
    // send via frame message
    url.searchParams.delete('p');
    const w = window.open(url.toString(), '_blank');
    w === null || w === void 0 ? void 0 : w.addEventListener('load', () => {
        w === null || w === void 0 ? void 0 : w.postMessage(r, url.origin);
    });
    return false;
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function clsx(...classNames) {
    return classNames.filter(Boolean).join(' ');
}
function generateId(_args) {
    return `upset-${Math.random().toString(36).slice(4)}`;
}
function isSetLike(s) {
    return s != null && !Array.isArray(s);
}
function elemOverlapOf(query, toElemKey) {
    const f = setOverlapFactory(query, toElemKey);
    return (s) => {
        return f(s.elems).intersection;
    };
}
function noGuessPossible() {
    return -1;
}
function generateSelectionOverlap(selection, overlapGuesser, toElemKey) {
    if (!selection) {
        return noOverlap;
    }
    if (typeof selection === 'function') {
        return selection;
    }
    if (Array.isArray(selection)) {
        return elemOverlapOf(selection, toElemKey);
    }
    const ss = selection;
    if (ss.overlap) {
        return ss.overlap.bind(ss);
    }
    let f = null;
    return (s) => {
        if (s.overlap) {
            return s.overlap(ss);
        }
        const guess = overlapGuesser(s, ss);
        if (guess >= 0) {
            return guess;
        }
        if (!f) {
            f = elemOverlapOf(ss.elems, toElemKey);
        }
        return f(s);
    };
}
function generateSelectionName(selection) {
    var _a;
    return Array.isArray(selection)
        ? `Array(${selection.length})`
        : typeof selection === 'function'
            ? '?'
            : (_a = selection) === null || _a === void 0 ? void 0 : _a.name;
}
function elemElemOverlapOf(query, toElemKey) {
    const f = setElemOverlapFactory(query, toElemKey);
    return (s) => {
        return f(s.elems).intersection;
    };
}
function noOverlap() {
    return 0;
}
function parseFontSize(v) {
    if (v == null) {
        return 10;
    }
    if (v.endsWith('pt')) {
        return Math.floor((4 / 3) * Number.parseInt(v, 10));
    }
    return Number.parseInt(v, 10);
}
function toAnchor(alignment) {
    var _a;
    const alignments = {
        left: 'start',
        center: 'middle',
        right: 'end',
    };
    return (_a = alignments[alignment]) !== null && _a !== void 0 ? _a : 'middle';
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function resolveNumericScale(factory) {
    if (factory === 'linear') {
        return linearScale;
    }
    if (factory === 'log') {
        return logScale;
    }
    return factory;
}
function resolveBandScale(factory) {
    return factory === 'band' ? bandScale$1 : factory;
}
function areCombinations$1(combinations) {
    return Array.isArray(combinations);
}
function deriveDataDependent(sets, combinations, sizes, numericScale, bandScale, barLabelFontSize, dotPadding, barPadding, tickFontSize, combinationAddons, toKey, toElemKey, id, setMaxScale, combinationMaxScale) {
    var _a;
    const numericScaleFactory = resolveNumericScale(numericScale);
    const bandScaleFactory = resolveBandScale(bandScale);
    const cs = areCombinations$1(combinations)
        ? combinations
        : generateCombinations(sets, Object.assign({ toElemKey }, DEFAULT_COMBINATIONS, combinations));
    const csKeys = cs.map(toKey);
    const combinationX = bandScaleFactory(csKeys, sizes.cs.w, sizes.padding);
    const dataCSCardinality = cs.reduce((acc, d) => Math.max(acc, d.cardinality), 0);
    const maxCSCardinality = combinationMaxScale !== null && combinationMaxScale !== void 0 ? combinationMaxScale : dataCSCardinality;
    const combinationYEnd = maxCSCardinality > dataCSCardinality ? 0 : barLabelFontSize;
    const combinationY = numericScaleFactory(maxCSCardinality, [sizes.cs.h, combinationYEnd], {
        orientation: 'vertical',
        fontSizeHint: tickFontSize,
    });
    const labelSize = (text) => Math.floor((barLabelFontSize / 1.4) * 0.7 * text.length);
    const guessLabelWidth = (v) => labelSize(combinationY.tickFormat()(v));
    const dataSetCardinality = sets.reduce((acc, d) => Math.max(acc, d.cardinality), 0);
    const maxSetCardinality = setMaxScale !== null && setMaxScale !== void 0 ? setMaxScale : dataSetCardinality;
    const largestSetLabelWidth = guessLabelWidth(maxSetCardinality);
    let largestCSLabelWidth = guessLabelWidth(maxCSCardinality);
    for (const addon of combinationAddons) {
        if (!addon.scale) {
            continue;
        }
        const ticks = addon.scale.ticks(3);
        const f = addon.scale.tickFormat();
        for (const tick of ticks) {
            const l = typeof tick === 'number' ? f(tick) : (_a = tick.label) !== null && _a !== void 0 ? _a : f(tick.value);
            const size = labelSize(l);
            if (size > largestCSLabelWidth) {
                largestCSLabelWidth = size;
            }
        }
    }
    const setShift = maxSetCardinality > dataSetCardinality ? 0 : largestSetLabelWidth;
    const setX = numericScaleFactory(maxSetCardinality, [sizes.sets.w, setShift], {
        orientation: 'horizontal',
        fontSizeHint: tickFontSize,
    });
    const setKeys = sets.map(toKey);
    const setY = bandScaleFactory(setKeys.slice().reverse(), // reverse order
    sizes.sets.h, sizes.padding);
    const r = (Math.min(setY.bandwidth(), combinationX.bandwidth()) / 2) * dotPadding;
    const triangleSize = Math.max(2, (Math.min(setY.bandwidth(), combinationX.bandwidth()) / 2) * barPadding);
    return {
        id: id ? id : generateId(),
        r,
        triangleSize,
        sets: {
            v: sets,
            keys: setKeys,
            rv: sets.slice().reverse(),
            x: setX,
            xAxisWidth: sizes.sets.w - setShift,
            y: (s) => setY(toKey(s)),
            max: maxSetCardinality,
            bandWidth: setY.bandwidth(),
            cy: setY.bandwidth() / 2 + sizes.cs.h,
            format: setX.tickFormat(),
            labelOffset: barLabelFontSize + 9 + 2,
        },
        cs: {
            v: cs,
            keys: cs.map(toKey),
            x: (s) => combinationX(toKey(s)),
            max: maxCSCardinality,
            y: combinationY,
            yAxisWidth: sizes.cs.h - combinationYEnd,
            cx: combinationX.bandwidth() / 2,
            bandWidth: combinationX.bandwidth(),
            format: combinationY.tickFormat(),
            has: (v, s) => {
                const sk = toKey(s);
                return Array.from(v.sets).some((ss) => toKey(ss) === sk);
            },
            labelOffset: largestCSLabelWidth + 9 + 6,
        },
        toKey,
        toElemKey,
        overlapGuesser: generateOverlapFunction(cs, noGuessPossible, toKey),
    };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function deriveSizeDependent(width, height, margin, barPadding, widthRatios, heightRatios, setAddons, combinationAddons, id, setAddonPadding, combinationAddonPadding) {
    const setAddonsBefore = setAddons.reduce((acc, a) => acc + (a.position === 'before' ? a.size + setAddonPadding : 0), 0);
    const setAddonsAfter = setAddons.reduce((acc, a) => acc + (a.position !== 'before' ? a.size + setAddonPadding : 0), 0);
    const combinationAddonsBefore = combinationAddons.reduce((acc, a) => acc + (a.position === 'before' ? a.size + setAddonPadding : 0), 0);
    const combinationAddonsAfter = combinationAddons.reduce((acc, a) => acc + (a.position !== 'before' ? a.size + setAddonPadding : 0), 0);
    const h = height - 2 * margin - 20 - combinationAddonsAfter - combinationAddonsBefore;
    const w = width - 2 * margin - setAddonsBefore - setAddonsAfter;
    const setWidth = widthRatios[0] > 1 ? widthRatios[0] : w * widthRatios[0];
    const labelsWidth = widthRatios[1] > 1 ? widthRatios[1] : w * widthRatios[1];
    const combinationHeight = heightRatios[0] > 1 ? heightRatios[0] : h * heightRatios[0];
    return {
        id: id ? id : generateId(),
        cs: {
            before: combinationAddonsBefore,
            after: combinationAddonsAfter,
            x: setAddonsBefore + setWidth + labelsWidth,
            y: combinationAddonsBefore,
            w: w - setWidth - labelsWidth,
            h: combinationHeight,
            addons: combinationAddons,
            addonPadding: combinationAddonPadding,
        },
        labels: {
            x: setAddonsBefore + setWidth,
            y: combinationAddonsBefore + combinationHeight,
            w: labelsWidth,
            h: h - combinationHeight,
        },
        sets: {
            before: setAddonsBefore,
            after: setAddonsAfter,
            x: setAddonsBefore,
            y: combinationAddonsBefore + combinationHeight,
            w: setWidth,
            h: h - combinationHeight,
            addons: setAddons,
            addonPadding: setAddonPadding,
        },
        padding: barPadding,
        legend: {
            x: width / 2,
        },
        margin: margin,
        w: width,
        h: height,
    };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function deriveStyleDependent(theme, styles, classNames, combinationName, combinationNameAxisOffset, setName, setNameAxisOffset, styleId, barLabelOffset, selectionColor, emptySelection, title, description, tooltips, setLabelAlignment) {
    return {
        theme,
        styles,
        classNames: classNames,
        cs: {
            name: combinationName,
            offset: combinationNameAxisOffset,
        },
        sets: {
            name: setName,
            offset: setNameAxisOffset,
        },
        emptySelection,
        id: styleId,
        barLabelOffset,
        selectionColor,
        title,
        description,
        tooltips,
        setLabelAlignment,
    };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function ExportButtons({ transform, styleId, exportButtons, exportChart, }) {
    if (!exportButtons) {
        return null;
    }
    const svgWidth = 26;
    const pngWidth = 26;
    const vegaWidth = 34;
    const dumpWidth = 34;
    const shareWidth = 42;
    const space = 2;
    let acc = 0;
    const buttons = [];
    if (exportButtons === true || exportButtons.svg !== false) {
        acc += svgWidth;
        buttons.push(React.createElement("g", { key: "svg", className: `exportButton-${styleId}`, onClick: exportChart, "data-type": "svg", transform: `translate(-${acc}, 0)` },
            React.createElement("title", null, "Download SVG Image"),
            React.createElement("rect", { y: -9, width: svgWidth, height: 11, rx: 2, ry: 2 }),
            React.createElement("text", { className: `exportTextStyle-${styleId}`, x: svgWidth / 2 }, "SVG")));
        acc += space;
    }
    if (exportButtons === true || exportButtons.png !== false) {
        acc += pngWidth;
        buttons.push(React.createElement("g", { key: "png", className: `exportButton-${styleId}`, onClick: exportChart, "data-type": "png", transform: `translate(-${acc}, 0)` },
            React.createElement("title", null, "Download PNG Image"),
            React.createElement("rect", { y: -9, width: pngWidth, height: 11, rx: 2, ry: 2 }),
            React.createElement("text", { className: `exportTextStyle-${styleId}`, x: pngWidth / 2 }, "PNG")));
        acc += space;
    }
    if (exportButtons === true || exportButtons.vega !== false) {
        acc += vegaWidth;
        buttons.push(React.createElement("g", { key: "vega", className: `exportButton-${styleId}`, onClick: exportChart, "data-type": "vega", transform: `translate(-${acc}, 0)` },
            React.createElement("title", null, "Download VEGA-Lite Specification"),
            React.createElement("rect", { y: -9, width: vegaWidth, height: 11, rx: 2, ry: 2 }),
            React.createElement("text", { className: `exportTextStyle-${styleId}`, x: vegaWidth / 2 }, "VEGA")));
        acc += space;
    }
    if (exportButtons === true || exportButtons.dump !== false) {
        acc += dumpWidth;
        buttons.push(React.createElement("g", { key: "dump", className: `exportButton-${styleId}`, onClick: exportChart, "data-type": "dump", transform: `translate(-${acc}, 0)` },
            React.createElement("title", null, "Download UpSet.js JSON Dump"),
            React.createElement("rect", { y: -9, width: dumpWidth, height: 11, rx: 2, ry: 2 }),
            React.createElement("text", { className: `exportTextStyle-${styleId}`, x: dumpWidth / 2 }, "DUMP")));
        acc += space;
    }
    if (exportButtons === true || exportButtons.share !== false) {
        acc += shareWidth;
        buttons.push(React.createElement("g", { key: "share", className: `exportButton-${styleId}`, onClick: exportChart, "data-type": "share", transform: `translate(-${acc}, 0)` },
            React.createElement("title", null, "Open a shareable URL"),
            React.createElement("rect", { y: -9, width: shareWidth, height: 11, rx: 2, ry: 2 }),
            React.createElement("text", { className: `exportTextStyle-${styleId}`, x: shareWidth / 2 }, "SHARE")));
        acc += space;
    }
    return (React.createElement("g", { className: `exportButtons-${styleId}`, transform: transform }, buttons));
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const QueryLegend = /*!#__PURE__*/ React.memo(function QueryLegend({ queries, x, style, data, }) {
    return (React.createElement("text", { transform: `translate(${x},4)`, style: style.styles.legend, className: clsx(`legendTextStyle-${style.id}`, style.classNames.legend) }, queries.map((q, i) => {
        let count = null;
        if (isSetQuery(q)) {
            count = q.set.cardinality;
        }
        else if (isElemQuery(q)) {
            count = q.elems instanceof Set ? q.elems.size : q.elems.length;
        }
        return (React.createElement(React.Fragment, { key: q.name },
            React.createElement("tspan", { className: `fillQ${i}-${data.id}` }, '   '),
            React.createElement("tspan", null,
                q.name,
                count != null ? `: ${data.sets.format(count)}` : '')));
    })));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const HorizontalTick = /*!#__PURE__*/ React.memo(function HorizontalTick({ pos, spacing, tickSizeInner, orient, name, style, }) {
    const k = orient === 'top' || orient === 'left' ? -1 : 1;
    return (React.createElement("g", { transform: `translate(0, ${pos + 0.5})` },
        name && (React.createElement("text", { x: k * spacing, dy: '0.32em', className: clsx(`axisTextStyle-${style.id}`, orient === 'right' ? `startText-${style.id}` : `endText-${style.id}`, style.classNames.axisTick), style: style.styles.axisTick }, name)),
        React.createElement("line", { x2: k * tickSizeInner, className: `axisLine-${style.id}` })));
});
const VerticalTick = /*!#__PURE__*/ React.memo(function VerticalTick({ pos, name, spacing, orient, tickSizeInner, style, }) {
    const k = orient === 'top' || orient === 'left' ? -1 : 1;
    return (React.createElement("g", { transform: `translate(${pos + 0.5}, 0)` },
        name && (React.createElement("text", { y: k * spacing, dy: orient === 'top' ? '0em' : '0.71em', className: clsx(`axisTextStyle-${style.id}`, style.classNames.axisTick), style: style.styles.axisTick }, name)),
        React.createElement("line", { y2: k * tickSizeInner, className: `axisLine-${style.id}` })));
});
function Axis({ scale, orient, tickSizeInner = 6, tickSizeOuter = 6, tickPadding = 3, size, start, style, transform, }) {
    const spacing = Math.max(tickSizeInner, 0) + tickPadding;
    const range0 = start;
    const range1 = size;
    const k = orient === 'top' || orient === 'left' ? -1 : 1;
    const Tick = orient === 'left' || orient === 'right' ? HorizontalTick : VerticalTick;
    const values = scale
        .ticks()
        .map((d) => (typeof d === 'number' ? { value: d, label: String(d) } : d));
    return (React.createElement("g", { transform: transform },
        values.map((d) => (React.createElement(Tick, { key: d.value, pos: scale(d.value), name: d.label, spacing: spacing, tickSizeInner: tickSizeInner, orient: orient, style: style }))),
        React.createElement("path", { className: `axisLine-${style.id}`, d: orient === 'left' || orient === 'right'
                ? tickSizeOuter
                    ? `M${k * tickSizeOuter},${range0}H0.5V${range1}H${k * tickSizeOuter}`
                    : `M0.5,${range0}V${range1}`
                : tickSizeOuter
                    ? `M${range0},${k * tickSizeOuter}V0.5H${range1}V${k * tickSizeOuter}`
                    : `M${range0},0.5H${range1}` })));
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const MultilineText = /*!#__PURE__*/ React.memo(function MultilineText({ width, text, dy, x, style, className, }) {
    const ref = useRef(null);
    const [lines, setLines] = useState(typeof text === 'string' ? [text] : []);
    // update state upon text update
    useLayoutEffect(() => {
        if (typeof text === 'string') {
            setLines([text]);
        }
        else {
            setLines([]);
        }
    }, [text]);
    useLayoutEffect(() => {
        if (!ref.current ||
            ref.current.childElementCount > 0 ||
            typeof text !== 'string' ||
            typeof ref.current.getComputedTextLength !== 'function') {
            // already multi lines
            return;
        }
        const len = ref.current.getComputedTextLength();
        const lines = [];
        let lineWidth = width;
        let start = 0;
        // compute line splits
        const p = ref.current.getStartPositionOfChar(0);
        while (len > lineWidth) {
            p.x = lineWidth;
            const num = ref.current.getCharNumAtPosition(p);
            const space = text.lastIndexOf(' ', num);
            if (space < start) {
                break;
            }
            lines.push(text.slice(start, space + 1));
            const used = ref.current.getEndPositionOfChar(space + 1).x;
            start = space + 1;
            // new line with in the used part + a new line
            lineWidth = used + width;
        }
        lines.push(text.slice(start));
        setLines(lines);
    }, [ref, text, width]);
    if (!text) {
        return null;
    }
    return (React.createElement("tspan", { ref: ref, dy: dy, style: style, x: x, className: className }, lines.length > 1
        ? lines.map((l, i) => (React.createElement("tspan", { key: l, x: 0, dy: i > 0 ? '1.2em' : dy }, l)))
        : text));
});
var UpSetTitle = /*!#__PURE__*/ React.memo(function UpSetTitle({ width, descriptionWidth = width, style, }) {
    if (!style.title && !style.description) {
        return null;
    }
    return (React.createElement("text", null,
        React.createElement(MultilineText, { text: style.title, width: width, dy: "10px", className: clsx(`titleTextStyle-${style.id}`, style.classNames.title), style: style.styles.title }),
        React.createElement(MultilineText, { x: 0, width: descriptionWidth, dy: style.title ? '2em' : '10px', text: style.description, className: clsx(`descTextStyle-${style.id}`, style.classNames.description), style: style.styles.description })));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function noop() {
    return undefined;
}
function wrap(f) {
    if (!f) {
        return noop;
    }
    return (set, addons) => {
        return function (evt) {
            return f.call(this, set, evt.nativeEvent, addons.map((a) => (a.createOnHandlerData ? a.createOnHandlerData(set) : null)));
        };
    };
}
function addonPositionGenerator(total, padding) {
    let beforeAcc = 0;
    let afterAcc = 0;
    return (addon) => {
        let x = 0;
        if (addon.position === 'before') {
            beforeAcc += addon.size + padding;
            x = -beforeAcc;
        }
        else {
            x = total + afterAcc + padding;
            afterAcc += addon.size + padding;
        }
        return x;
    };
}
function mergeColor(style, color, prop = 'fill') {
    if (!color) {
        return style;
    }
    if (!style) {
        return !color ? undefined : { [prop]: color };
    }
    return Object.assign({ [prop]: color }, style);
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const UpSetAxis = /*!#__PURE__*/ React.memo(function UpSetAxis({ size, style, data }) {
    const setPosGen = addonPositionGenerator(size.sets.w + size.labels.w + size.cs.w, size.sets.addonPadding);
    const combinationPosGen = addonPositionGenerator(size.cs.h + size.sets.h, size.cs.addonPadding);
    const csNameOffset = style.cs.offset === 'auto' ? data.cs.labelOffset : style.cs.offset;
    const setNameOffset = style.sets.offset === 'auto' ? data.sets.labelOffset : style.sets.offset;
    return (React.createElement("g", null,
        React.createElement(UpSetTitle, { style: style, width: size.cs.x - csNameOffset - 20 }),
        React.createElement("g", { transform: `translate(${size.cs.x},${size.cs.y})`, "data-upset": "csaxis" },
            React.createElement(Axis, { scale: data.cs.y, orient: "left", size: size.cs.h, start: size.cs.h - data.cs.yAxisWidth, style: style }),
            React.createElement("line", { x1: 0, x2: size.cs.w, y1: size.cs.h + 1, y2: size.cs.h + 1, className: `axisLine-${style.id}` }),
            React.createElement("text", { className: clsx(`cChartTextStyle-${style.id}`, style.classNames.chartLabel), style: style.styles.chartLabel, transform: `translate(${-csNameOffset}, ${size.cs.h / 2})rotate(-90)` }, style.cs.name),
            size.cs.addons.map((addon) => {
                const pos = combinationPosGen(addon);
                const title = (React.createElement("text", { key: addon.name, className: clsx(`cChartTextStyle-${style.id}`, style.classNames.chartLabel), style: style.styles.chartLabel, transform: `translate(${-csNameOffset}, ${pos + addon.size / 2})rotate(-90)` }, addon.name));
                if (!addon.scale) {
                    return title;
                }
                return (React.createElement(React.Fragment, { key: addon.name },
                    React.createElement(Axis, { scale: addon.scale, orient: "left", size: addon.size, start: 0, style: style, transform: `translate(0,${pos})` }),
                    title));
            })),
        React.createElement("g", { transform: `translate(${size.sets.x},${size.sets.y})`, "data-upset": "setaxis" },
            React.createElement(Axis, { scale: data.sets.x, orient: "bottom", size: size.sets.w, start: size.sets.w - data.sets.xAxisWidth, transform: `translate(0, ${size.sets.h})`, style: style }),
            React.createElement("text", { className: clsx(`sChartTextStyle-${style.id}`, style.classNames.chartLabel), style: style.styles.chartLabel, transform: `translate(${size.sets.w / 2}, ${size.sets.h + setNameOffset})` }, style.sets.name),
            size.sets.addons.map((addon) => {
                const pos = setPosGen(addon);
                const title = (React.createElement("text", { key: addon.name, className: clsx(`sChartTextStyle-${style.id}`, style.classNames.chartLabel), style: style.styles.chartLabel, transform: `translate(${pos + addon.size / 2}, ${size.sets.h + setNameOffset})` }, addon.name));
                if (!addon.scale) {
                    return title;
                }
                return (React.createElement(React.Fragment, { key: addon.name },
                    React.createElement(Axis, { scale: addon.scale, orient: "bottom", size: addon.size, start: 0, transform: `translate(${pos}, ${size.sets.h})`, style: style }),
                    title));
            }))));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const UpSetDot = /*!#__PURE__*/ React.memo(function UpSetDot({ cx, r, cy, name, className, style, fill, }) {
    return (React.createElement("circle", { r: r, cx: cx, cy: cy, className: className, style: mergeColor(style, fill) }, name && React.createElement("title", null, name)));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function computeOverflowValues(value, max, scale) {
    const scaled = [scale(value)];
    for (let i = 0; i < OVERFLOW_PADDING_FACTOR.length && value > max; i++) {
        value -= max;
        scaled.push(scale(value));
    }
    return scaled;
}
const CombinationChart = /*!#__PURE__*/ React.memo(function CombinationChart({ d, h, className, data, size, style, children, }) {
    const yValues = computeOverflowValues(d.cardinality, data.cs.max, data.cs.y);
    const genPosition = addonPositionGenerator(size.cs.h + size.sets.h, size.cs.addonPadding);
    return (React.createElement("g", { transform: `translate(${data.cs.x(d)}, 0)`, onMouseEnter: h.onMouseEnter(d, size.cs.addons), onMouseLeave: h.onMouseLeave, onClick: h.onClick(d, size.cs.addons), onContextMenu: h.onContextMenu(d, size.cs.addons), onMouseMove: h.onMouseMove(d, size.cs.addons), className: className, "data-cardinality": d.cardinality },
        style.tooltips && (React.createElement("title", null,
            d.name,
            ": ",
            data.cs.format(d.cardinality))),
        React.createElement("rect", { y: -size.cs.before, width: data.cs.bandWidth, height: size.sets.h + size.cs.h + size.cs.before + size.cs.after, className: `hoverBar-${style.id}` }),
        yValues.map((y, i) => {
            const offset = i > 0 ? Math.floor(data.cs.bandWidth * OVERFLOW_PADDING_FACTOR[i - 1]) : 0;
            return (React.createElement("rect", { key: i, x: offset, y: y, height: size.cs.h - y, width: data.cs.bandWidth - offset * 2, className: clsx(`fillPrimary-${style.id}`, i < yValues.length - 1 && `fillOverflow${yValues.length - 1 - i}-${style.id}`, style.classNames.bar), style: mergeColor(style.styles.bar, d.color) }));
        }),
        React.createElement("text", { y: yValues[0] - style.barLabelOffset, x: data.cs.bandWidth / 2, style: style.styles.barLabel, className: clsx(`cBarTextStyle-${style.id}`, style.classNames.barLabel) }, data.cs.format(d.cardinality)),
        React.createElement("text", { y: -style.barLabelOffset - size.cs.before, x: data.cs.bandWidth / 2, style: style.styles.barLabel, className: clsx(`hoverBarTextStyle-${style.id}`, style.classNames.barLabel) }, d.name),
        data.sets.v.map((s, i) => {
            if (data.cs.has(d, s)) {
                // only not
                return null;
            }
            return (React.createElement(UpSetDot, { key: data.sets.keys[i], r: data.r, cx: data.cs.cx, cy: data.sets.y(s) + data.sets.cy, name: style.tooltips ? d.name : '', style: style.styles.dot, fill: undefined, className: clsx(`fillNotMember-${style.id}`, style.classNames.dot) }));
        }),
        d.sets.size > 1 && (React.createElement("line", { x1: data.cs.cx, y1: data.sets.y(data.sets.v.find((p) => data.cs.has(d, p))) + data.sets.cy - (data.r - 1), x2: data.cs.cx, y2: data.sets.y(data.sets.rv.find((p) => data.cs.has(d, p))) + data.sets.cy + (data.r - 1), style: d.color ? { stroke: d.color } : undefined, className: `upsetLine-${data.id}` })),
        data.sets.v.map((s, i) => {
            var _a;
            if (!data.cs.has(d, s)) {
                // only has
                return null;
            }
            return (React.createElement(UpSetDot, { key: data.sets.keys[i], r: data.r, cx: data.cs.cx, cy: data.sets.y(s) + data.sets.cy, name: style.tooltips ? s.name : '', style: style.styles.dot, fill: (_a = s.color) !== null && _a !== void 0 ? _a : d.color, className: clsx(`fillPrimary-${style.id}`, style.classNames.dot) }));
        }),
        size.cs.addons.map((addon) => (React.createElement("g", { key: addon.name, transform: `translate(0,${genPosition(addon)})` }, addon.render({ set: d, width: data.cs.bandWidth, height: addon.size, theme: style.theme })))),
        children));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const SetChart = /*!#__PURE__*/ React.memo(function SetChart({ d, i, h, className, size, data, style, children, }) {
    const xValues = computeOverflowValues(d.cardinality, data.sets.max, data.sets.x);
    const genPosition = addonPositionGenerator(size.sets.w + size.labels.w + size.cs.w, size.sets.addonPadding);
    const anchorOffset = style.setLabelAlignment === 'center'
        ? size.labels.w / 2
        : style.setLabelAlignment === 'left'
            ? 2
            : size.labels.w - 2;
    return (React.createElement("g", { transform: `translate(0, ${data.sets.y(d)})`, onMouseEnter: h.onMouseEnter(d, size.sets.addons), onMouseLeave: h.onMouseLeave, onClick: h.onClick(d, size.sets.addons), onContextMenu: h.onContextMenu(d, size.sets.addons), onMouseMove: h.onMouseMove(d, size.sets.addons), className: className, "data-cardinality": d.cardinality },
        style.tooltips && (React.createElement("title", null,
            d.name,
            ": ",
            data.sets.format(d.cardinality))),
        React.createElement("rect", { x: -size.sets.before, width: size.sets.w + size.labels.w + size.cs.w + size.sets.after, height: data.sets.bandWidth, className: `hoverBar-${style.id}` }),
        i % 2 === 1 && (React.createElement("rect", { x: size.sets.w, width: size.labels.w + size.cs.w + size.sets.after, height: data.sets.bandWidth, className: `fillAlternating-${style.id}` })),
        xValues.map((x, i) => {
            const offset = i > 0 ? Math.floor(data.sets.bandWidth * OVERFLOW_PADDING_FACTOR[i - 1]) : 0;
            return (React.createElement("rect", { key: i, x: x, y: offset, width: size.sets.w - x, height: data.sets.bandWidth - offset * 2, className: clsx(`fillPrimary-${style.id}`, i < xValues.length - 1 && `fillOverflow${xValues.length - 1 - i}-${style.id}`, style.classNames.bar), style: mergeColor(style.styles.bar, d.color) }));
        }),
        React.createElement("text", { x: xValues[0], dx: -style.barLabelOffset, y: data.sets.bandWidth / 2, style: style.styles.barLabel, className: clsx(`sBarTextStyle-${style.id}`, style.classNames.barLabel) }, data.sets.format(d.cardinality)),
        React.createElement("text", { x: size.sets.w + anchorOffset, y: data.sets.bandWidth / 2, className: clsx(`setTextStyle-${style.id}`, style.classNames.setLabel), style: style.styles.setLabel, clipPath: `url(#clip-${size.id})` }, d.name),
        size.sets.addons.map((addon) => (React.createElement("g", { key: addon.name, transform: `translate(${genPosition(addon)},0)` }, addon.render({ set: d, width: addon.size, height: data.sets.bandWidth, theme: style.theme })))),
        children));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const UpSetChart = /*!#__PURE__*/ React.memo(function UpSetChart({ data, size, style, h, setChildrenFactory, combinationChildrenFactory, }) {
    return (React.createElement("g", { className: h.hasClick ? `clickAble-${style.id}` : undefined },
        React.createElement("g", { transform: `translate(${size.sets.x},${size.sets.y})`, "data-upset": "sets" }, data.sets.v.map((d, i) => (React.createElement(SetChart, { key: data.sets.keys[i], d: d, i: i, h: h, className: h.hasClick || h.hasHover ? `interactive-${style.id}` : undefined, data: data, style: style, size: size }, setChildrenFactory && setChildrenFactory(d))))),
        React.createElement("g", { transform: `translate(${size.cs.x},${size.cs.y})`, "data-upset": "cs" }, data.cs.v.map((d, i) => (React.createElement(CombinationChart, { key: data.cs.keys[i], d: d, h: h, className: h.hasClick || h.hasHover ? `interactive-${style.id}` : undefined, data: data, style: style, size: size }, combinationChildrenFactory && combinationChildrenFactory(d)))))));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function CombinationSelectionChart({ data, size, style, elemOverlap, secondary, tooltip, suffix, transform, empty, combinationAddons, }) {
    const width = data.cs.bandWidth;
    const totalHeight = size.cs.h + size.sets.h;
    const height = size.cs.h;
    const className = clsx(`fill${suffix}`, !tooltip && `pnone-${style.id}`, style.classNames.bar);
    return (React.createElement("g", { transform: transform, "data-upset": secondary ? 'cs-q' : 'cs-s' }, data.cs.v.map((d, i) => {
        const x = data.cs.x(d);
        const key = data.cs.keys[i];
        if (empty && !secondary) {
            return (React.createElement("rect", { key: key, x: x, y: height, height: 0, width: width, className: className, style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, tooltip && React.createElement("title", null)));
        }
        const o = elemOverlap(d);
        if (o === 0) {
            return null;
        }
        const yValues = computeOverflowValues(o, data.cs.max, data.cs.y);
        const title = tooltip && React.createElement("title", null, `${d.name}  ${tooltip}: ${o}`);
        const content = secondary ? (React.createElement("path", { key: key, transform: `translate(${x}, ${yValues[0]})`, d: `M0,-1 l${width},0 l0,2 l${-width},0 L-${data.triangleSize},-${data.triangleSize} L-${data.triangleSize},${data.triangleSize} Z`, className: className, "data-i": i, "data-cardinality": o, style: mergeColor(undefined, !style.selectionColor ? d.color : undefined) }, title)) : (yValues.map((y, j) => {
            const offset = j > 0 ? Math.floor(data.cs.bandWidth * OVERFLOW_PADDING_FACTOR[j - 1]) : 0;
            return (React.createElement("rect", { key: j, x: x + offset, y: y, height: height - y, width: width - offset * 2, "data-i": j > 0 ? null : i, "data-cardinality": j > 0 ? null : o, className: clsx(className, j < yValues.length - 1 && `fillOverflow${yValues.length - 1 - j}-${style.id}`), style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, title));
        }));
        const genPosition = addonPositionGenerator(totalHeight, size.cs.addonPadding);
        const addons = combinationAddons
            .map((addon) => {
            const v = genPosition(addon);
            const content = addon.render({ set: d, width, height: addon.size, theme: style.theme });
            if (!content) {
                return null;
            }
            return (React.createElement("g", { key: addon.name, transform: `translate(${x},${v})` }, content));
        })
            .filter(Boolean);
        if (addons.length === 0) {
            return content;
        }
        return (React.createElement("g", { key: key },
            content,
            addons));
    })));
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function SetSelectionChart({ data, size, style, elemOverlap, suffix, secondary, empty, tooltip, setAddons, transform, }) {
    const width = size.sets.w;
    const totalWidth = size.sets.w + size.labels.w + size.cs.w;
    const height = data.sets.bandWidth;
    const className = clsx(`fill${suffix}`, !tooltip && ` pnone-${style.id}`, style.classNames.bar);
    return (React.createElement("g", { transform: transform, "data-upset": secondary ? 'sets-q' : 'sets-s' }, data.sets.v.map((d, i) => {
        const y = data.sets.y(d);
        const key = data.sets.keys[i];
        if (empty && !secondary) {
            return (React.createElement("rect", { key: key, x: width, y: y, width: 0, height: height, className: className, style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, style.tooltips && tooltip && React.createElement("title", null)));
        }
        const o = elemOverlap(d);
        if (o === 0) {
            return null;
        }
        const xValues = computeOverflowValues(o, data.sets.max, data.sets.x);
        const title = style.tooltips && tooltip && React.createElement("title", null, `${d.name}  ${tooltip}: ${o}`);
        const content = secondary ? (React.createElement("path", { key: key, transform: `translate(${xValues[0]}, ${y + height})`, d: `M1,0 l0,${-height} l-2,0 l0,${height} L-${data.triangleSize},${data.triangleSize} L${data.triangleSize},${data.triangleSize} Z`, "data-i": i, "data-cardinality": o, className: className, style: mergeColor(undefined, !style.selectionColor ? d.color : undefined) }, title)) : (xValues.map((x, j) => {
            const offset = j > 0 ? Math.floor(data.sets.bandWidth * OVERFLOW_PADDING_FACTOR[j - 1]) : 0;
            return (React.createElement("rect", { key: j, "data-i": j > 0 ? null : i, "data-cardinality": j > 0 ? null : o, x: x, y: y + offset, width: width - x, height: height - offset * 2, className: clsx(className, j < xValues.length - 1 && `fillOverflow${xValues.length - 1 - j}-${style.id}`), style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, title));
        }));
        const genPosition = addonPositionGenerator(totalWidth, size.sets.addonPadding);
        const addons = setAddons
            .map((addon) => {
            const v = genPosition(addon);
            const content = addon.render({ set: d, width: addon.size, height, theme: style.theme });
            if (!content) {
                return null;
            }
            return (React.createElement("g", { key: addon.name, transform: `translate(${v},${y})` }, content));
        })
            .filter(Boolean);
        if (addons.length === 0) {
            return content;
        }
        return (React.createElement("g", { key: key },
            content,
            addons));
    })));
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const EMPTY_ARRAY$1 = [];
const UpSetQueries = /*!#__PURE__*/ React.memo(function UpSetQueries({ size, data, style, hasHover, secondary, queries, }) {
    const someAddon = size.sets.addons.some((s) => s.renderQuery != null) || size.cs.addons.some((s) => s.renderQuery != null);
    const qs = useMemo(() => queries.map((q) => (Object.assign(Object.assign({}, q), { overlap: queryOverlap(q, 'intersection', data.toElemKey), elemOverlap: someAddon ? queryElemOverlap(q, 'intersection', data.toElemKey) : null }))), [queries, someAddon, data.toElemKey]);
    function wrapAddon(addon, query, index, overlapper, secondary) {
        return Object.assign(Object.assign({}, addon), { render: (props) => {
                const overlap = overlapper(props.set);
                return addon.renderQuery ? addon.renderQuery(Object.assign({ query, overlap, index, secondary }, props)) : null;
            } });
    }
    return (React.createElement("g", { className: hasHover && !secondary ? `pnone-${style.id}` : undefined },
        React.createElement("g", { transform: `translate(${size.sets.x},${size.sets.y})` }, qs.map((q, i) => (React.createElement(SetSelectionChart, { key: q.name, data: data, size: size, style: style, elemOverlap: q.overlap, suffix: `Q${i}-${data.id}`, secondary: secondary || i > 0, tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name, setAddons: size.sets.addons.length === 0
                ? EMPTY_ARRAY$1
                : size.sets.addons.map((a, i) => wrapAddon(a, q, i, q.elemOverlap, secondary || i > 0)) })))),
        React.createElement("g", { transform: `translate(${size.cs.x},${size.cs.y})` }, qs.map((q, i) => (React.createElement(CombinationSelectionChart, { key: q.name, data: data, size: size, style: style, elemOverlap: q.overlap, suffix: `Q${i}-${data.id}`, secondary: secondary || i > 0, tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name, combinationAddons: size.cs.addons.length === 0
                ? EMPTY_ARRAY$1
                : size.cs.addons.map((a, i) => wrapAddon(a, q, i, q.elemOverlap, secondary || i > 0)) }))))));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function LabelsSelection({ data, size, style, selection, }) {
    if (!selection || selection.type !== 'set' || !data.sets.keys.includes(data.toKey(selection))) {
        return null;
    }
    const d = selection;
    return (React.createElement("rect", { y: data.sets.y(d), width: size.labels.w + size.cs.w + size.sets.after, height: data.sets.bandWidth, className: `selectionHint-${style.id}` }));
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function UpSetSelectionChart({ data, size, style, selection, }) {
    const cy = data.sets.bandWidth / 2;
    const cx = data.cs.cx;
    const r = data.r;
    const height = size.sets.h + size.sets.after;
    const width = data.cs.bandWidth;
    if (!selection || selection.type === 'set' || !data.cs) {
        return null;
    }
    const d = selection;
    const index = data.cs.keys.indexOf(data.toKey(d));
    if (index < 0) {
        return null;
    }
    return (React.createElement("g", { transform: `translate(${size.labels.w + data.cs.x(d)}, 0)`, "data-upset": "cs-ss", "data-i": index },
        React.createElement("rect", { width: width, height: height, className: `selectionHint-${style.id}` }),
        d.sets.size > 1 && (React.createElement("line", { x1: cx, y1: data.sets.y(data.sets.v.find((p) => data.cs.has(d, p))) + cy - (data.r - 1), x2: cx, y2: data.sets.y(data.sets.rv.find((p) => data.cs.has(d, p))) + cy + (data.r - 1), className: `upsetSelectionLine-${data.id}`, style: mergeColor(undefined, !style.selectionColor ? d.color : undefined, 'stroke') })),
        data.sets.v
            .filter((s) => data.cs.has(d, s))
            .map((s) => (React.createElement(UpSetDot, { key: data.toKey(s), r: r * 1.1, cx: cx, cy: data.sets.y(s) + cy, name: style.tooltips ? s.name : '', className: clsx(`fillSelection-${style.id}`, `pnone-${style.id}`, style.classNames.dot), style: mergeColor(style.styles.dot, !style.selectionColor ? s.color : undefined) })))));
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const EMPTY_ARRAY$2 = [];
function UpSetSelection({ size, data, style, selection, hasHover, }) {
    const empty = style.emptySelection;
    const selectionOverlap = generateSelectionOverlap(selection, data.overlapGuesser, data.toElemKey);
    const selectionName = generateSelectionName(selection);
    const someAddon = size.sets.addons.some((s) => s.renderSelection != null) || size.cs.addons.some((s) => s.renderSelection != null);
    const selectionElemOverlap = selection && typeof selection !== 'function' && someAddon
        ? elemElemOverlapOf(Array.isArray(selection) ? selection : selection.elems, data.toElemKey)
        : null;
    function wrapAddon(addon) {
        return Object.assign(Object.assign({}, addon), { render: (props) => {
                const overlap = selectionElemOverlap ? selectionElemOverlap(props.set) : null;
                return addon.renderSelection
                    ? addon.renderSelection(Object.assign({ selection, selectionColor: style.selectionColor || props.set.color || 'orange', overlap }, props))
                    : null;
            } });
    }
    return (React.createElement("g", { className: hasHover ? `pnone-${style.id}` : undefined },
        (selection || empty) && (React.createElement(CombinationSelectionChart, { data: data, size: size, style: style, transform: `translate(${size.cs.x},${size.cs.y})`, empty: empty && !selection, elemOverlap: selectionOverlap, suffix: `Selection-${style.id}`, tooltip: hasHover ? undefined : selectionName, combinationAddons: size.cs.addons.length === 0 ? EMPTY_ARRAY$2 : size.cs.addons.map(wrapAddon) })),
        (selection || empty) && (React.createElement(SetSelectionChart, { data: data, size: size, style: style, transform: `translate(${size.sets.x},${size.sets.y})`, empty: empty && !selection, elemOverlap: selectionOverlap, suffix: `Selection-${style.id}`, tooltip: hasHover ? undefined : selectionName, setAddons: size.sets.addons.length === 0 ? EMPTY_ARRAY$2 : size.sets.addons.map(wrapAddon) })),
        React.createElement("g", { transform: `translate(${size.labels.x},${size.labels.y})` },
            isSetLike(selection) && React.createElement(LabelsSelection, { data: data, size: size, style: style, selection: selection }),
            isSetLike(selection) && React.createElement(UpSetSelectionChart, { data: data, size: size, style: style, selection: selection }))));
}

function propRule(value, prop = 'font-size') {
    return value ? `${prop}: ${value};` : '';
}
function baseRules(styleId, theme, fontFamily, fontSizes) {
    const hasS = [];
    if (theme.hasSelectionColor) {
        hasS.push(`fill: ${theme.hasSelectionColor};`);
    }
    const hasSelectionOpacity = theme.hasSelectionOpacity != null && theme.hasSelectionOpacity >= 0;
    if (hasSelectionOpacity) {
        hasS.push(`fill-opacity: ${theme.hasSelectionOpacity};`);
    }
    return {
        p: propRule,
        root: `
  .root-${styleId} {
    ${propRule(fontFamily, 'font-family')}
  }
  `,
        text: `
  .titleTextStyle-${styleId} {
    fill: ${theme.textColor};
    ${propRule(fontSizes.title)}
  }
  .descTextStyle-${styleId} {
    fill: ${theme.textColor};
    ${propRule(fontSizes.description)}
  }

  .legendTextStyle-${styleId} {
    fill: ${theme.textColor};
    ${propRule(fontSizes.legend)}
    text-anchor: middle;
    dominant-baseline: hanging;
    pointer-events: none;
  }
  `,
        hasSFill: hasS.join(' '),
        hasSStroke: hasS.join(' ').replace('fill:', 'stroke:').replace('fill-', 'stroke-'),
        fill: `
  .fillPrimary-${styleId} { fill: ${theme.color}; fill-opacity: ${theme.opacity}; }
  .fillOverflow1-${styleId} { fill-opacity: ${theme.opacity * OVERFLOW_OPACITY_FACTOR[0]}; }
  .fillOverflow2-${styleId} { fill-opacity: ${theme.opacity * OVERFLOW_OPACITY_FACTOR[1]}; }
  ${hasS.length > 0 ? `.root-${styleId}[data-selection] .fillPrimary-${styleId} { ${hasS.join(' ')} }` : ''}
  ${hasSelectionOpacity
            ? `
      .root-${styleId}[data-selection] .fillOverflow1-${styleId} { fill-opacity: ${theme.opacity * OVERFLOW_OPACITY_FACTOR[0]}; }
      .root-${styleId}[data-selection] .fillOverflow2-${styleId} { fill-opacity: ${theme.opacity * OVERFLOW_OPACITY_FACTOR[1]}; }`
            : ''}
  ${theme.selectionColor ? `.fillSelection-${styleId} { fill: ${theme.selectionColor}; }` : ''}
  .fillTransparent-${styleId} { fill: transparent; }

  .selectionHint-${styleId} {
    fill: transparent;
    pointer-events: none;
    ${propRule(theme.selectionColor, 'stroke')}
  }
  .clickAble-${styleId} {
    cursor: pointer;
  }

  .startText-${styleId} {
    text-anchor: start;
  }
  .endText-${styleId} {
    text-anchor: end;
  }
  .pnone-${styleId} {
    pointer-events: none;
  }`,
        export: `
  .exportTextStyle-${styleId} {
    fill: ${theme.textColor};
    ${propRule(fontSizes.exportLabel)}
  }
  .exportButtons-${styleId} {
    text-anchor: middle;
  }
  .exportButton-${styleId} {
    cursor: pointer;
    opacity: 0.5;
  }
  .exportButton-${styleId}:hover {
    opacity: 1;
  }
  .exportButton-${styleId} > rect {
    fill: none;
    stroke: ${theme.textColor};
  }
  `,
    };
}

function useHandler(p) {
    const onClick = p.onClick;
    return useMemo(() => ({
        hasClick: onClick != null,
        hasHover: p.onHover != null,
        onClick: wrap(onClick),
        onMouseEnter: wrap(p.onHover),
        onContextMenu: wrap(p.onContextMenu),
        onMouseLeave: p.onHover ? (evt) => p.onHover(null, evt.nativeEvent, []) : undefined,
        onMouseMove: wrap(p.onMouseMove),
        reset: (evt) => (onClick ? onClick(null, evt.nativeEvent, []) : null),
    }), [onClick, p.onHover, p.onContextMenu, p.onMouseMove]);
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
/**
 * UpSetJS main pure functional stateless React component, the generic argument T refers to the type of the elements
 *
 * with React.forwardRef support to specify a reference to the SVG element
 */
const UpSetJS = /*!#__PURE__*/ React.forwardRef(function UpSetJS(props, ref) {
    var _a;
    const p = fillDefaults(props);
    const { selection = null, queries = [], fontSizes } = p;
    // generate a "random" but attribute stable id to avoid styling conflicts
    const styleId = useMemo(() => p.id
        ? p.id
        : generateId([
            p.fontFamily,
            fontSizes.axisTick,
            fontSizes.barLabel,
            fontSizes.chartLabel,
            fontSizes.legend,
            fontSizes.setLabel,
            fontSizes.title,
            fontSizes.exportLabel,
            fontSizes.description,
            p.textColor,
            p.hoverHintColor,
            p.color,
            p.hasSelectionColor,
            p.selectionColor,
            p.notMemberColor,
            p.alternatingBackgroundColor,
            p.opacity,
            p.hasSelectionOpacity,
        ]), [
        p.id,
        p.fontFamily,
        fontSizes.axisTick,
        fontSizes.barLabel,
        fontSizes.chartLabel,
        fontSizes.legend,
        fontSizes.setLabel,
        fontSizes.title,
        fontSizes.exportLabel,
        fontSizes.description,
        p.textColor,
        p.hoverHintColor,
        p.color,
        p.hasSelectionColor,
        p.selectionColor,
        p.notMemberColor,
        p.alternatingBackgroundColor,
        p.opacity,
        p.hasSelectionOpacity,
    ]);
    const styleInfo = useMemo(() => deriveStyleDependent(p.theme, p.styles, p.classNames, p.combinationName, p.combinationNameAxisOffset, p.setName, p.setNameAxisOffset, styleId, p.barLabelOffset, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips, p.setLabelAlignment), [
        p.theme,
        p.styles,
        p.classNames,
        p.barLabelOffset,
        p.combinationName,
        p.combinationNameAxisOffset,
        p.setName,
        p.setNameAxisOffset,
        styleId,
        p.selectionColor,
        p.emptySelection,
        p.title,
        p.description,
        p.tooltips,
        p.setLabelAlignment,
    ]);
    const sizeInfo = useMemo(() => deriveSizeDependent(p.width, p.height, p.padding, p.barPadding, p.widthRatios, p.heightRatios, p.setAddons, p.combinationAddons, p.id, p.setAddonPadding, p.combinationAddonPadding), [
        p.width,
        p.height,
        p.padding,
        p.barPadding,
        p.widthRatios,
        p.heightRatios,
        p.setAddons,
        p.combinationAddons,
        p.id,
        p.setAddonPadding,
        p.combinationAddonPadding,
    ]);
    const dataInfo = useMemo(() => deriveDataDependent(p.sets, p.combinations, sizeInfo, p.numericScale, p.bandScale, p.barLabelOffset + parseFontSize(fontSizes.barLabel), p.dotPadding, p.barPadding, parseFontSize(fontSizes.axisTick), p.combinationAddons, p.toKey, p.toElemKey, p.id, p.setMaxScale, p.combinationMaxScale), [
        p.sets,
        p.combinations,
        sizeInfo,
        p.numericScale,
        p.bandScale,
        p.barLabelOffset,
        fontSizes.barLabel,
        p.dotPadding,
        p.barPadding,
        fontSizes.axisTick,
        p.combinationAddons,
        p.toKey,
        p.toElemKey,
        p.id,
        p.setMaxScale,
        p.combinationMaxScale,
    ]);
    const rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);
    const h = useHandler(p);
    const rules = `
  ${rulesHelper.root}
  ${rulesHelper.text}

  .axisTextStyle-${styleId} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.axisTick)}
    text-anchor: middle;
  }
  .barTextStyle-${styleId} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.barLabel)}
  }
  .cBarTextStyle-${styleId} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.barLabel)}
    text-anchor: middle;
  }
  .sBarTextStyle-${styleId} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.barLabel)}
    text-anchor: end;
    dominant-baseline: central;
  }
  .hoverBarTextStyle-${styleId} {
    ${rulesHelper.p(fontSizes.barLabel)}
    fill: ${p.hoverHintColor};
    display: none;
    text-anchor: middle;
  }
  .setTextStyle-${styleId} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.setLabel)}
    text-anchor: ${toAnchor(p.setLabelAlignment)};
    dominant-baseline: central;
  }
  .cChartTextStyle-${styleId} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.chartLabel)}
    text-anchor: middle;
  }
  .sChartTextStyle-${styleId} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.chartLabel)}
    text-anchor: middle;
    dominant-baseline: hanging;
  }

  ${rulesHelper.fill}
  .fillNotMember-${styleId} { fill: ${p.notMemberColor}; }
  .fillAlternating-${styleId} { fill: ${p.alternatingBackgroundColor || 'transparent'}; }

  .axisLine-${styleId} {
    fill: none;
    stroke: ${p.textColor};
  }
  .hoverBar-${styleId} {
    fill: transparent;
  }

  .interactive-${styleId}:hover > .hoverBar-${styleId} {
    stroke: ${p.hoverHintColor};
  }
  .interactive-${styleId}:hover > .hoverBarTextStyle-${styleId} {
    display: unset;
  }

  ${rulesHelper.export}

  .upsetLine-${dataInfo.id} {
    stroke-width: ${dataInfo.r * 0.6};
    stroke: ${p.color};
    stroke-opacity: ${p.opacity};
  }
  ${rulesHelper.hasSStroke
        ? `.root-${styleId}[data-selection] .upsetLine-${dataInfo.id} { ${rulesHelper.hasSStroke} }`
        : ''}

  .upsetSelectionLine-${dataInfo.id} {
    stroke-width: ${dataInfo.r * 0.6 * 1.1};
    ${rulesHelper.p(p.selectionColor, 'stroke')}
    pointer-events: none;
  }

  ${queries
        .map((q, i) => `.fillQ${i}-${dataInfo.id} {
    fill: ${q.color};
  }`)
        .join('\n')}
  `;
    const exportChart = useCallback((evt) => {
        const svg = evt.currentTarget.closest('svg');
        const type = (evt.currentTarget.dataset.type || 'png');
        switch (type) {
            case 'vega':
                exportVegaLite(svg);
                break;
            case 'dump':
                exportDump(svg, props, dataInfo);
                break;
            case 'share':
                exportSharedLink(props, dataInfo);
                break;
            case 'svg':
            case 'png':
                exportSVG(svg, {
                    type,
                    toRemove: `.${evt.currentTarget.getAttribute('class')}`,
                });
        }
    }, [dataInfo, props]);
    const selectionName = generateSelectionName(selection);
    return (React.createElement("svg", { id: p.id, className: clsx(`root-${styleId}`, p.className), style: p.style, width: p.width, height: p.height, ref: ref, viewBox: `0 0 ${p.width} ${p.height}`, "data-theme": (_a = p.theme) !== null && _a !== void 0 ? _a : 'light', "data-selection": selectionName ? selectionName : undefined },
        React.createElement("style", null, rules),
        React.createElement("defs", null,
            React.createElement("clipPath", { id: `clip-${sizeInfo.id}` },
                React.createElement("rect", { x: sizeInfo.sets.w, y: 0, width: sizeInfo.labels.w, height: sizeInfo.sets.h }))),
        p.queryLegend && React.createElement(QueryLegend, { queries: queries, x: sizeInfo.legend.x, style: styleInfo, data: dataInfo }),
        React.createElement(ExportButtons, { transform: `translate(${sizeInfo.w - 2},${sizeInfo.h - 3})`, styleId: styleId, exportButtons: p.exportButtons, exportChart: exportChart }),
        React.createElement("g", { transform: `translate(${p.padding},${p.padding})`, "data-upset": "base" },
            p.onClick && (React.createElement("rect", { width: sizeInfo.cs.x, height: sizeInfo.sets.y, onClick: h.reset, className: `fillTransparent-${styleId}` })),
            React.createElement(UpSetAxis, { size: sizeInfo, style: styleInfo, data: dataInfo }),
            React.createElement(UpSetChart, { size: sizeInfo, style: styleInfo, data: dataInfo, h: h, setChildrenFactory: p.setChildrenFactory, combinationChildrenFactory: p.combinationChildrenFactory }),
            React.createElement(UpSetSelection, { size: sizeInfo, style: styleInfo, data: dataInfo, hasHover: h.hasHover, selection: selection }),
            React.createElement(UpSetQueries, { size: sizeInfo, style: styleInfo, data: dataInfo, hasHover: h.hasHover, queries: queries, secondary: p.onHover != null || selection != null })),
        props.children));
});

function SVGWrapper({ rules, style, size, p, data, tRef, children, exportChart, selectionName, h, }) {
    var _a, _b;
    return (React.createElement("svg", { id: p.id, className: clsx(`root-${style.id}`, p.className), style: p.style, width: p.width, height: p.height, ref: tRef, viewBox: `0 0 ${p.width} ${p.height}`, "data-theme": (_a = p.theme) !== null && _a !== void 0 ? _a : 'light', "data-selection": selectionName ? selectionName : undefined },
        React.createElement("style", null, rules),
        p.onClick && React.createElement("rect", { width: size.w, height: size.h, onClick: h.reset, className: `fillTransparent-${style.id}` }),
        p.queryLegend && React.createElement(QueryLegend, { queries: (_b = p.queries) !== null && _b !== void 0 ? _b : [], x: size.legend.x, style: style, data: data }),
        React.createElement(ExportButtons, { transform: `translate(${size.w - 2},${size.h - 3})`, styleId: style.id, exportButtons: p.exportButtons, exportChart: exportChart }),
        React.createElement("g", { transform: `translate(${p.padding},${p.padding})`, "data-upset": "base" }, children),
        p.children));
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function generateArcSlicePath(s, refs, p = 0) {
    if (s.path) {
        return s.path;
    }
    return `M ${s.x1 - p},${s.y1 - p} ${s.arcs
        .map((arc) => {
        const ref = refs[arc.ref].l;
        const rx = isEllipse(ref) ? ref.rx : ref.r;
        const ry = isEllipse(ref) ? ref.ry : ref.r;
        const rot = isEllipse(ref) ? ref.rotation : 0;
        return `A ${rx - p} ${ry - p} ${rot} ${arc.large ? 1 : 0} ${arc.sweep ? 1 : 0} ${arc.x2 - p} ${arc.y2 - p}`;
    })
        .join(' ')}`;
}

function SelectionPattern(p) {
    var _a;
    if (p.v >= 1 || p.v <= 0) {
        return null;
    }
    const ratio = Math.round(p.v * 10.0) / 100;
    return (React.createElement("defs", null,
        React.createElement("pattern", { id: p.id, width: "1", height: "0.1", patternContentUnits: "objectBoundingBox", patternTransform: `rotate(${(_a = p.rotate) !== null && _a !== void 0 ? _a : 0})` },
            p.bgFilled && (React.createElement("rect", { x: "0", y: "0", width: "1", height: "0.1", style: { fill: p.bgFill }, className: `fillPrimary-${p.styleId}` })),
            React.createElement("rect", { x: "0", y: "0", width: "1", height: ratio, className: `fill${p.suffix}`, style: p.fill ? { fill: p.fill } : undefined }))));
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function sliceRotate(slice, center) {
    if (slice.text.x === center.cx) {
        return 0;
    }
    if (slice.text.x > center.cx) {
        return slice.text.y <= center.cy ? 60 : -60;
    }
    return slice.text.y <= center.cy ? -60 : 60;
}
function generateTitle(d, s, sName, secondary, qs, queries, data, cx) {
    const dc = data.format(d.cardinality);
    const baseName = !sName ? d.name : `${d.name}  ${sName}`;
    const baseCardinality = !sName ? dc : `${data.format(s)}/${dc}`;
    if (qs.length === 0) {
        return {
            tooltip: `${baseName}: ${baseCardinality}`,
            title: d.type === 'set' ? (React.createElement(React.Fragment, null,
                React.createElement("tspan", { dy: "-0.6em" }, d.name),
                React.createElement("tspan", { x: cx, dy: "1.2em" }, baseCardinality))) : (baseCardinality),
        };
    }
    if (qs.length === 1 && !secondary && !sName) {
        return {
            tooltip: `${d.name}  ${queries[0].name}: ${data.format(qs[0])}/${dc}`,
            title: d.type === 'set' ? (React.createElement(React.Fragment, null,
                React.createElement("tspan", { dy: "-0.6em" }, d.name),
                React.createElement("tspan", { x: cx, dy: "1.2em" }, `${data.format(qs[0])}/${dc}`))) : (`${data.format(qs[0])}/${dc}`),
        };
    }
    const queryLine = (React.createElement("tspan", { x: cx, dy: "1.2em" }, queries.map((q, i) => (React.createElement(React.Fragment, { key: q.name },
        React.createElement("tspan", { className: `fillQ${i}-${data.id}` }, ''),
        React.createElement("tspan", null, ` ${data.format(qs[i])}/${dc}${i < queries.length - 1 ? ' ' : ''}`))))));
    return {
        tooltip: `${baseName}: ${baseCardinality}\n${queries
            .map((q, i) => `${d.name}  ${q.name}: ${data.format(qs[i])}/${dc}`)
            .join('\n')}`,
        title: d.type === 'set' ? (React.createElement(React.Fragment, null,
            React.createElement("tspan", { dy: "-1.2em" }, d.name),
            React.createElement("tspan", { x: cx, dy: "1.2em" }, baseCardinality),
            queryLine)) : (React.createElement(React.Fragment, null,
            React.createElement("tspan", { dy: "-0.6em" }, baseCardinality),
            queryLine)),
    };
}
function VennArcSliceSelection({ slice, d, i, data, style, elemOverlap, selected, selectionName, h, queries, size, fill, qs, }) {
    const p = generateArcSlicePath(slice, data.sets.d);
    const rotate = sliceRotate(slice, size.area);
    const o = elemOverlap ? elemOverlap(d) : 0;
    const fillFullSelection = (o === d.cardinality && d.cardinality > 0) || selected;
    const className = clsx(`arc-${style.id}`, o === 0 && !selected && `${fill ? 'fillPrimary' : 'arcP'}-${style.id}`, fillFullSelection && `fillSelection-${style.id}`, style.classNames.set);
    const id = `upset-${style.id}-${i}`;
    const secondary = elemOverlap != null || h.onMouseLeave != null;
    const qsOverlaps = qs.map((q) => q(d));
    const { title, tooltip } = generateTitle(d, o, selectionName, secondary, qsOverlaps, queries, data, slice.text.x);
    return (React.createElement("g", null,
        React.createElement(SelectionPattern, { id: id, v: o === 0 ? 0 : o / d.cardinality, suffix: `Selection-${style.id}`, rotate: rotate, bgFill: d.color, bgFilled: d.color != null || fill, fill: !style.selectionColor ? d.color : undefined, styleId: style.id }),
        React.createElement("path", { onMouseEnter: h.onMouseEnter(d, []), onMouseLeave: h.onMouseLeave, onClick: h.onClick(d, []), onContextMenu: h.onContextMenu(d, []), onMouseMove: h.onMouseMove(d, []), d: p, className: className, style: mergeColor(style.styles.set, o > 0 && o < d.cardinality ? `url(#${id})` : !fillFullSelection || !style.selectionColor ? d.color : undefined) }, style.tooltips && React.createElement("title", null, tooltip)),
        React.createElement("text", { x: slice.text.x, y: slice.text.y, className: clsx(`${d.type === 'set' ? 'set' : 'value'}TextStyle-${style.id}`, `pnone-${style.id}`
            // circle.align === 'left' && `startText-${style.id}`,
            // circle.align === 'right' && `endText-${style.id}`
            ) }, title)));
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function deriveVennDataDependent(sets, combinations, size, layout, format, toKey, toElemKey, id) {
    const ss = sets.length > layout.maxSets ? sets.slice(0, layout.maxSets) : sets;
    const { cs, setKeys, csKeys } = calculateCombinations(ss, toKey, combinations);
    const l = layout.compute(ss, cs, size.area.w, size.area.h);
    return {
        id: id ? id : generateId(),
        sets: {
            d: l.sets.map((l, i) => ({ v: ss[i], l, key: setKeys[i] })),
            v: ss,
            format,
        },
        format,
        cs: {
            d: l.intersections.map((l, i) => ({ v: cs[i], l, key: csKeys[i] })),
            v: cs,
            has: (v, s) => {
                const sk = toKey(s);
                return Array.from(v.sets).some((ss) => toKey(ss) === sk);
            },
        },
        toKey,
        toElemKey,
        overlapGuesser: generateDistinctOverlapFunction(cs, noGuessPossible, toKey),
    };
}
function calculateCombinations(ss, toKey, combinations, options = { min: 1 }) {
    const setKeys = ss.map(toKey);
    let cs = [];
    if (areCombinations$1(combinations)) {
        const given = new Map(combinations.map((c) => [Array.from(c.sets).map(toKey).sort().join('#'), c]));
        const helperSets = ss.map((s) => ({
            type: 'set',
            cardinality: 0,
            elems: [],
            name: s.name,
            s,
        }));
        // generate dummy ones and map to given data
        cs = generateCombinations(helperSets, Object.assign({
            type: 'distinctIntersection',
            empty: true,
            order: ['degree:asc', 'group:asc'],
        }, options)).map((c) => {
            const key = Array.from(c.sets)
                .map((s) => toKey(s.s))
                .sort()
                .join('#');
            if (given.has(key)) {
                return given.get(key);
            }
            // generate a dummy one
            return {
                name: c.name,
                cardinality: 0,
                degree: c.degree,
                elems: [],
                sets: new Set(Array.from(c.sets).map((s) => s.s)),
                type: 'distinctIntersection',
            };
        });
    }
    else {
        cs = generateCombinations(ss, Object.assign({
            type: 'distinctIntersection',
            empty: true,
            order: ['degree:asc', 'group:asc'],
        }, options, combinations !== null && combinations !== void 0 ? combinations : {}));
    }
    const csKeys = cs.map(toKey);
    return { cs, setKeys, csKeys };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function deriveVennSizeDependent(width, height, margin, id) {
    const h = height - 2 * margin;
    const w = width - 2 * margin;
    const r = Math.min(w, h) / 2;
    return {
        id: id ? id : generateId(),
        legend: {
            x: width / 2,
        },
        area: {
            w,
            h,
            cx: w / 2,
            cy: h / 2,
            r,
        },
        margin: margin,
        w: width,
        h: height,
    };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function deriveVennStyleDependent(theme, styles, classNames, styleId, selectionColor, title, description, tooltips) {
    return {
        theme,
        styles,
        classNames: classNames,
        id: styleId,
        selectionColor,
        title,
        description,
        tooltips,
    };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function useCreateCommon(p) {
    const { queries = [], fontSizes } = p;
    // generate a "random" but attribute stable id to avoid styling conflicts
    const styleId = useMemo(() => p.id
        ? p.id
        : generateId([
            p.fontFamily,
            fontSizes.valueLabel,
            fontSizes.legend,
            fontSizes.setLabel,
            fontSizes.title,
            fontSizes.exportLabel,
            fontSizes.description,
            p.textColor,
            p.color,
            p.hasSelectionColor,
            p.strokeColor,
            p.valueTextColor,
            p.selectionColor,
            p.opacity,
            p.hasSelectionOpacity,
        ]), [
        p.id,
        p.fontFamily,
        fontSizes.valueLabel,
        fontSizes.legend,
        fontSizes.setLabel,
        fontSizes.title,
        fontSizes.exportLabel,
        fontSizes.description,
        p.textColor,
        p.color,
        p.hasSelectionColor,
        p.strokeColor,
        p.valueTextColor,
        p.selectionColor,
        p.opacity,
        p.hasSelectionOpacity,
    ]);
    const styleInfo = useMemo(() => deriveVennStyleDependent(p.theme, p.styles, p.classNames, styleId, p.selectionColor, p.title, p.description, p.tooltips), [p.theme, p.styles, p.classNames, styleId, p.selectionColor, p.title, p.description, p.tooltips]);
    const sizeInfo = useMemo(() => deriveVennSizeDependent(p.width, p.height, p.padding, p.id), [
        p.width,
        p.height,
        p.padding,
        p.id,
    ]);
    const h = useHandler(p);
    const qs = React.useMemo(() => queries.map((q) => queryOverlap(q, 'intersection', p.toElemKey)), [
        queries,
        p.toElemKey,
    ]);
    const rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);
    return {
        styleId,
        size: sizeInfo,
        style: styleInfo,
        h,
        qs,
        rulesHelper,
    };
}
function useExportChart(dataInfo, props, mode) {
    return useCallback((evt) => {
        const svg = evt.currentTarget.closest('svg');
        const type = (evt.currentTarget.dataset.type || 'png');
        switch (type) {
            case 'dump':
                exportDump(svg, props, dataInfo, mode);
                break;
            case 'share':
                exportSharedLink(props, dataInfo, mode);
                break;
            case 'svg':
            case 'png':
                exportSVG(svg, {
                    type,
                    toRemove: `.${evt.currentTarget.getAttribute('class')}`,
                });
        }
    }, [dataInfo, props, mode]);
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const VennDiagram = /*!#__PURE__*/ React.forwardRef(function VennDiagram(props, ref) {
    const p = fillVennDiagramDefaults(props);
    const { selection = null, queries = [], fontSizes } = p;
    const v = useCreateCommon(p);
    const { size, style, rulesHelper } = v;
    const dataInfo = useMemo(() => deriveVennDataDependent(p.sets, p.combinations, size, p.layout, p.valueFormat, p.toKey, p.toElemKey, p.id), [p.sets, p.combinations, size, p.valueFormat, p.toKey, p.toElemKey, p.id, p.layout]);
    const selectionKey = selection != null && isSetLike$1(selection) ? p.toKey(selection) : null;
    const selectionOverlap = selection == null ? null : generateSelectionOverlap(selection, dataInfo.overlapGuesser, dataInfo.toElemKey);
    const selectionName = generateSelectionName(selection);
    const rules = `
  ${rulesHelper.root}
  ${rulesHelper.text}

  .valueTextStyle-${style.id} {
    fill: ${p.valueTextColor};
    ${rulesHelper.p(fontSizes.valueLabel)}
    text-anchor: middle;
    dominant-baseline: central;
  }
  .setTextStyle-${style.id} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.setLabel)}
    text-anchor: middle;
  }

  .topText-${style.id} {
    dominant-baseline: hanging;
  }

  .stroke-circle-${style.id} {
    fill: none;
    stroke: ${p.strokeColor};
  }

  .arc-${style.id} {
    fill-rule: evenodd;
  }
  .arcP-${style.id} {
    fill: transparent;
    fill-opacity: ${p.opacity};
  }
  ${rulesHelper.fill}
  ${rulesHelper.export}

  ${rulesHelper.hasSFill ? `.root-${style.id}[data-selection] .arcP-${style.id} { ${rulesHelper.hasSFill} }` : ''}

  ${queries
        .map((q, i) => `.fillQ${i}-${dataInfo.id} {
    fill: ${q.color};
  }`)
        .join('\n')}
  `;
    const exportChart = useExportChart(dataInfo, p, 'venn');
    const maxWidth = dataInfo.sets.d.reduce((acc, d) => Math.min(acc, d.l.cx - (isEllipse(d.l) ? d.l.rx : d.l.r)), size.area.w);
    return (React.createElement(SVGWrapper, { rules: rules, style: style, selectionName: selectionName, size: size, p: p, data: dataInfo, tRef: ref, h: v.h, exportChart: exportChart },
        React.createElement(UpSetTitle, { style: style, width: maxWidth }),
        React.createElement("g", { className: clsx(p.onClick && `clickAble-${style.id}`) }, dataInfo.sets.d.map((d, i) => (React.createElement("text", { key: d.key, x: d.l.text.x, y: d.l.text.y, onClick: v.h.onClick(dataInfo.sets.v[i], []), onMouseEnter: v.h.onMouseEnter(dataInfo.sets.v[i], []), onMouseLeave: v.h.onMouseLeave, onContextMenu: v.h.onContextMenu(dataInfo.sets.v[i], []), onMouseMove: v.h.onMouseMove(dataInfo.sets.v[i], []), className: clsx(`setTextStyle-${style.id}`, `${d.l.align}Text-${style.id}`, `${d.l.verticalAlign}Text-${style.id}`) }, dataInfo.sets.v[i].name)))),
        React.createElement("g", { className: clsx(p.onClick && `clickAble-${style.id}`) }, dataInfo.cs.d.map((l, i) => (React.createElement(VennArcSliceSelection, { key: l.key, d: l.v, i: i, slice: l.l, size: size, style: style, data: dataInfo, fill: p.filled, h: v.h, selectionName: selectionName, selected: selectionKey === l.key || (isSet(selection) && dataInfo.cs.has(l.v, selection)), elemOverlap: selectionOverlap, queries: queries, qs: v.qs })))),
        React.createElement("g", null, dataInfo.sets.d.map((l) => isEllipse(l.l) ? (React.createElement("ellipse", { key: l.key, rx: l.l.rx, ry: l.l.ry, transform: `translate(${l.l.cx},${l.l.cy})rotate(${l.l.rotation})`, className: clsx(`stroke-circle-${style.id}`, style.classNames.set), style: style.styles.set })) : (React.createElement("circle", { key: l.key, cx: l.l.cx, cy: l.l.cy, r: l.l.r, className: clsx(`stroke-circle-${style.id}`, style.classNames.set), style: style.styles.set }))))));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const KMapCell = /*!#__PURE__*/ React.memo(function KMapCell({ d, i, h, className, data, style }) {
    const l = data.cs.l[i];
    const y = data.cs.scale(d.cardinality);
    const x = (data.cell - data.cs.bandWidth) / 2;
    return (React.createElement("g", { transform: `translate(${l.x}, ${l.y})`, onMouseEnter: h.onMouseEnter(d, []), onMouseLeave: h.onMouseLeave, onClick: h.onClick(d, []), onContextMenu: h.onContextMenu(d, []), onMouseMove: h.onMouseMove(d, []), className: className, "data-cardinality": d.cardinality },
        style.tooltips && (React.createElement("title", null,
            d.name,
            ": ",
            data.sets.format(d.cardinality))),
        React.createElement("rect", { width: data.cell, height: data.cell, className: `fillTransparent-${style.id}` }),
        React.createElement("rect", { x: x, y: y, height: data.cell - y, width: data.cs.bandWidth, className: clsx(`fillPrimary-${style.id}`, style.classNames.bar), style: mergeColor(style.styles.bar, d.color) }),
        React.createElement("text", { y: y - style.barLabelOffset, x: data.cell / 2, style: style.styles.barLabel, className: clsx(`barTextStyle-${style.id}`, style.classNames.barLabel) }, data.sets.format(d.cardinality))));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function generateGridPath(cell, vCells, hCells, level) {
    const h = cell * vCells;
    const w = cell * hCells;
    return [level.x.map((x) => `M ${x * cell},0 l0,${h}`), level.y.map((y) => `M 0,${y * cell} l${w},0`)]
        .flat()
        .join(' ');
}
const KMapChart = /*!#__PURE__*/ React.memo(function KMapChart({ data, style, size, h }) {
    const csNameOffset = style.cs.offset === 'auto' ? data.cs.labelOffset : style.cs.offset;
    return (React.createElement("g", null,
        React.createElement("g", { transform: `translate(${size.w - csNameOffset - 2}, ${size.h - data.cell - 50})` },
            React.createElement(Axis, { scale: data.cs.scale, orient: "left", size: data.cell, start: data.cs.barLabelFontSize, style: style }),
            React.createElement("text", { className: clsx(`cChartTextStyle-${style.id}`, style.classNames.chartLabel), style: style.styles.chartLabel, transform: `translate(${-csNameOffset}, ${data.cell})rotate(-90)` }, style.cs.name)),
        React.createElement("g", null,
            data.sets.l.map((l, i) => {
                const s = data.sets.v[i];
                const name = s.name;
                return (React.createElement("g", { key: name, onClick: h.onClick(s, []), onMouseEnter: h.onMouseEnter(s, []), onMouseLeave: h.onMouseLeave, onContextMenu: h.onContextMenu(s, []), onMouseMove: h.onMouseMove(s, []), className: clsx(h.hasClick && `clickAble-${style.id}`) }, l.text.map((p, i) => (React.createElement("text", { key: i, transform: `translate(${p.x},${p.y})${!l.hor ? 'rotate(-90)' : ''}`, className: clsx(`setTextStyle-${style.id}`) }, name)))));
            }),
            data.sets.l.map((l, i) => {
                const name = data.sets.v[i].name;
                return (React.createElement(React.Fragment, { key: name }, l.notText.map((p, i) => (React.createElement("text", { key: i, transform: `translate(${p.x},${p.y})${!l.hor ? 'rotate(-90)' : ''}`, className: clsx(`setTextStyle-${style.id}`, `not-${style.id}`) }, name)))));
            })),
        React.createElement("g", { className: clsx(h.hasClick && `clickAble-${style.id}`) }, data.cs.v.map((c, i) => {
            return React.createElement(KMapCell, { key: data.cs.keys[i], d: c, i: i, h: h, style: style, data: data });
        })),
        React.createElement("g", { transform: `translate(${data.grid.x}, ${data.grid.y})` }, data.grid.levels.map((l, i) => (React.createElement("path", { key: i, d: generateGridPath(data.cell, data.grid.vCells, data.grid.hCells, l), className: `gridStyle-${style.id} gridStyle-${style.id}-${i}` }))))));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function KMapQueries({ data, style, elemOverlap, secondary, tooltip, suffix, empty, }) {
    const width = data.cs.bandWidth;
    const offset = (data.cell - width) / 2;
    const className = clsx(`fill${suffix}`, !tooltip && `pnone-${style.id}`, style.classNames.bar);
    return (React.createElement("g", { "data-upset": secondary ? 'cs-q' : 'cs-s' }, data.cs.v.map((d, i) => {
        const l = data.cs.l[i];
        const key = data.cs.keys[i];
        if (empty && !secondary) {
            return (React.createElement("rect", { key: key, x: l.x + offset, y: l.y + data.cell, height: 0, width: width, className: className, style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, tooltip && React.createElement("title", null)));
        }
        const o = elemOverlap(d);
        if (o === 0) {
            return null;
        }
        const y = data.cs.scale(o);
        const title = tooltip && React.createElement("title", null, `${d.name}  ${tooltip}: ${o}`);
        return secondary ? (React.createElement("path", { key: key, transform: `translate(${l.x + offset}, ${l.y + y})`, d: `M0,-1 l${width},0 l0,2 l${-width},0 L-${data.triangleSize},-${data.triangleSize} L-${data.triangleSize},${data.triangleSize} Z`, className: className, "data-i": i, "data-cardinality": o, style: mergeColor(undefined, !style.selectionColor ? d.color : undefined) }, title)) : (React.createElement("rect", { key: key, x: l.x + offset, y: l.y + y, height: data.cell - y, "data-i": i, "data-cardinality": o, width: width, className: className, style: mergeColor(style.styles.bar, !style.selectionColor ? d.color : undefined) }, title));
    })));
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const KMapQueries$1 = /*!#__PURE__*/ React.memo(function KMapQueries$1({ data, style, hasHover, secondary, queries, }) {
    const qs = useMemo(() => queries.map((q) => (Object.assign(Object.assign({}, q), { overlap: queryOverlap(q, 'intersection', data.toElemKey) }))), [queries, data.toElemKey]);
    return (React.createElement("g", { className: hasHover && !secondary ? `pnone-${style.id}` : undefined }, qs.map((q, i) => (React.createElement(KMapQueries, { key: q.name, data: data, style: style, elemOverlap: q.overlap, suffix: `Q${i}-${data.id}`, secondary: secondary || i > 0, tooltip: hasHover && !(secondary || i > 0) ? undefined : q.name })))));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function KMapSelection({ data, style, selection, hasHover, }) {
    const empty = style.emptySelection;
    const selectionOverlap = generateSelectionOverlap(selection, data.overlapGuesser, data.toElemKey);
    const selectionName = generateSelectionName(selection);
    return (React.createElement("g", { className: hasHover ? `pnone-${style.id}` : undefined }, (selection || empty) && (React.createElement(KMapQueries, { data: data, style: style, empty: empty && !selection, elemOverlap: selectionOverlap, suffix: `Selection-${style.id}`, tooltip: hasHover ? undefined : selectionName }))));
}

function ranged(count, cb) {
    return Array(count)
        .fill(0)
        .map((_, i) => cb(i));
}
function generateLevels(numSets) {
    // all lines and the value is the thickness
    const lines = Array(Math.pow(2, numSets)).fill(0);
    ranged(numSets, (i) => {
        const shift = Math.pow(2, i);
        for (let i = 0; i < lines.length; i += shift) {
            lines[i]++;
        }
    });
    const levels = ranged(Math.max(numSets, 1), () => []);
    lines.forEach((l, i) => {
        const level = Math.max(0, l - 1);
        // l -1 cause l is at least 1
        levels[level].push(i);
    });
    // push the last index to the last level
    levels[levels.length - 1].push(lines.length);
    return levels;
}
function generate(sets, cs, has, options) {
    const { xBefore, yBefore, cell, hCells, vCells, horizontalSets, verticalSets } = bounds(sets.length, options);
    const s = setLabels(sets.length, options);
    const shifts = generateShiftLookup(sets, hCells, vCells, has);
    const c = cs.map((c) => {
        const [i, j] = shifts.reduceRight((acc, s) => s(c, acc), [0, 0]);
        return {
            x: xBefore + i * cell,
            y: yBefore + j * cell,
        };
    });
    const hLevels = generateLevels(horizontalSets);
    const vLevels = generateLevels(verticalSets);
    return {
        s,
        c,
        cell,
        grid: {
            x: xBefore,
            y: yBefore,
            hCells,
            vCells,
            levels: hLevels.map((l, i) => ({
                x: l,
                y: i < vLevels.length ? vLevels[i] : [],
            })),
        },
    };
}
function generateShiftLookup(sets, hCells, vCells, has) {
    return sets.map((s, k) => {
        const index = Math.floor(k / 2);
        const hor = k % 2 === 0;
        const numLabels = Math.pow(2, index);
        const span = (hor ? hCells : vCells) / numLabels / 2;
        return (cs, [i, j]) => {
            if (has(cs, s)) {
                return [i, j];
            }
            if (span > 1) {
                // flip previous and shift
                if (hor) {
                    return [span - 1 - i + span, j];
                }
                return [i, span - 1 - j + span];
            }
            // shift only
            if (hor) {
                return [i + span, j];
            }
            return [i, j + span];
        };
    });
}
function setLabels(sets, options) {
    const { xOffset, yOffset, cell, xBefore, yBefore, hCells, vCells } = bounds(sets, options);
    const xAfterEnd = options.width - xOffset;
    const yAfterEnd = options.height - yOffset;
    return ranged(sets, (k) => {
        const index = Math.floor(k / 2);
        const hor = k % 2 === 0;
        const numLabels = Math.pow(2, index);
        const span = (hor ? hCells : vCells) / numLabels / 2;
        const xPos = hor ? xBefore : yBefore;
        const labels = [
            {
                v: true,
                x: xPos + span * cell * 0.5,
            },
            {
                v: false,
                x: xPos + span * cell * 1.5,
            },
        ];
        for (let i = 1; i <= index; i++) {
            // duplicate and mirror
            const offset = span * Math.pow(2, i) * cell;
            const l = labels.length - 1;
            labels.push(...labels.map((li, i) => ({
                v: labels[l - i].v,
                x: li.x + offset,
            })));
        }
        const inAfterGroup = index % 2 === 1;
        const withinGroupIndex = Math.floor(index / 2);
        let yPos = 0;
        if (inAfterGroup) {
            const end = hor ? yAfterEnd : xAfterEnd;
            yPos = end - options.labelHeight * (0.5 + withinGroupIndex);
        }
        else {
            const start = hor ? yOffset : xOffset;
            yPos = start + options.labelHeight * (0.5 + withinGroupIndex);
        }
        if (hor) {
            return {
                hor: true,
                span,
                text: labels.filter((d) => d.v).map((l) => ({ x: l.x, y: yPos })),
                notText: labels.filter((d) => !d.v).map((l) => ({ x: l.x, y: yPos })),
            };
        }
        return {
            hor: false,
            span,
            text: labels.filter((d) => d.v).map((l) => ({ x: yPos, y: l.x })),
            notText: labels.filter((d) => !d.v).map((l) => ({ x: yPos, y: l.x })),
        };
    });
}
function bounds(sets, options) {
    const horizontalSets = Math.ceil(sets / 2);
    const verticalSets = Math.floor(sets / 2);
    const hCells = Math.pow(2, horizontalSets);
    const vCells = Math.pow(2, verticalSets);
    const cell = Math.floor(Math.min((options.width - options.labelHeight * verticalSets) / hCells, (options.height - options.labelHeight * horizontalSets) / vCells));
    const xOffset = (options.width - hCells * cell - options.labelHeight * verticalSets) / 2;
    const yOffset = (options.height - vCells * cell - options.labelHeight * horizontalSets) / 2;
    const xBefore = xOffset + Math.ceil(verticalSets / 2) * options.labelHeight;
    const yBefore = yOffset + Math.ceil(horizontalSets / 2) * options.labelHeight;
    return { xOffset, horizontalSets, yOffset, verticalSets, cell, xBefore, yBefore, hCells, vCells };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function deriveKarnaughDataDependent(sets, combinations, size, numericScale, barLabelFontSize, barPadding, setLabelFontSize, tickFontSize, toKey, toElemKey, id, combinationMaxScale) {
    const numericScaleFactory = resolveNumericScale(numericScale);
    const setKeys = sets.map(toKey);
    const cs = areCombinations$1(combinations)
        ? combinations
        : generateCombinations(sets, Object.assign({
            type: 'distinctIntersection',
        }, combinations !== null && combinations !== void 0 ? combinations : {}));
    const csKeys = cs.map(toKey);
    const has = (v, s) => {
        const sk = toKey(s);
        return Array.from(v.sets).some((ss) => toKey(ss) === sk);
    };
    const labelHeight = Math.ceil(setLabelFontSize * 1.2);
    const l = generate(sets, cs, has, {
        width: size.area.w,
        height: size.area.h,
        labelHeight,
    });
    const maxCSCardinality = combinationMaxScale !== null && combinationMaxScale !== void 0 ? combinationMaxScale : cs.reduce((acc, d) => Math.max(acc, d.cardinality), 0);
    const scale = numericScaleFactory(maxCSCardinality, [l.cell, barLabelFontSize], {
        orientation: 'vertical',
        fontSizeHint: tickFontSize,
    });
    const bandWidth = Math.round(l.cell * (1 - barPadding));
    const triangleSize = Math.min(Math.max(2, (bandWidth / 2) * barPadding), 5);
    const guessLabelWidth = (v) => Math.floor((barLabelFontSize / 1.4) * 0.7 * scale.tickFormat()(v).length);
    const largestCSLabelWidth = guessLabelWidth(maxCSCardinality);
    return {
        id: id ? id : generateId(),
        grid: l.grid,
        sets: {
            keys: setKeys,
            l: l.s,
            v: sets,
            labelHeight,
            format: scale.tickFormat(),
        },
        triangleSize,
        cell: l.cell,
        cs: {
            keys: csKeys,
            l: l.c,
            v: cs,
            barLabelFontSize,
            has,
            scale,
            bandWidth,
            labelOffset: largestCSLabelWidth + 9 + 6,
        },
        toKey,
        toElemKey,
        overlapGuesser: generateOverlapFunction(cs, noGuessPossible, toKey),
    };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function deriveStyleDependent$1(theme, styles, classNames, combinationName, combinationNameAxisOffset, styleId, barLabelOffset, selectionColor, emptySelection, title, description, tooltips) {
    return {
        theme,
        styles,
        classNames: classNames,
        emptySelection,
        id: styleId,
        barLabelOffset,
        selectionColor,
        title,
        description,
        tooltips,
        cs: {
            name: combinationName,
            offset: combinationNameAxisOffset,
        },
    };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const KarnaughMap = /*!#__PURE__*/ React.forwardRef(function KarnaughMap(props, ref) {
    const p = fillKarnaughMapDefaults(props);
    const { queries = [], fontSizes, selection = null } = p;
    // generate a "random" but attribute stable id to avoid styling conflicts
    const styleId = useMemo(() => p.id
        ? p.id
        : generateId([
            p.fontFamily,
            fontSizes.axisTick,
            fontSizes.barLabel,
            fontSizes.legend,
            fontSizes.setLabel,
            fontSizes.title,
            fontSizes.exportLabel,
            fontSizes.description,
            p.textColor,
            p.color,
            p.hasSelectionColor,
            p.strokeColor,
            p.selectionColor,
            p.opacity,
            p.hasSelectionOpacity,
        ]), [
        p.id,
        p.fontFamily,
        fontSizes.axisTick,
        fontSizes.barLabel,
        fontSizes.legend,
        fontSizes.setLabel,
        fontSizes.title,
        fontSizes.exportLabel,
        fontSizes.description,
        p.textColor,
        p.color,
        p.hasSelectionColor,
        p.strokeColor,
        p.selectionColor,
        p.opacity,
        p.hasSelectionOpacity,
    ]);
    const style = useMemo(() => deriveStyleDependent$1(p.theme, p.styles, p.classNames, p.combinationName, p.combinationNameAxisOffset, styleId, p.barLabelOffset, p.selectionColor, p.emptySelection, p.title, p.description, p.tooltips), [
        p.theme,
        p.styles,
        p.classNames,
        p.combinationName,
        p.combinationNameAxisOffset,
        styleId,
        p.barLabelOffset,
        p.selectionColor,
        p.emptySelection,
        p.title,
        p.description,
        p.tooltips,
    ]);
    const size = useMemo(() => deriveVennSizeDependent(p.width, p.height, p.padding, p.id), [
        p.width,
        p.height,
        p.padding,
        p.id,
    ]);
    const data = useMemo(() => deriveKarnaughDataDependent(p.sets, p.combinations, size, p.numericScale, p.barLabelOffset + parseFontSize(fontSizes.barLabel), p.barPadding, parseFontSize(fontSizes.setLabel), parseFontSize(fontSizes.axisTick), p.toKey, p.toElemKey, p.id, p.combinationMaxScale), [
        p.sets,
        p.combinations,
        size,
        p.numericScale,
        p.barLabelOffset,
        fontSizes.barLabel,
        p.barPadding,
        fontSizes.axisTick,
        fontSizes.setLabel,
        p.toKey,
        p.toElemKey,
        p.id,
        p.combinationMaxScale,
    ]);
    const h = useHandler(p);
    const selectionName = generateSelectionName(selection);
    const rulesHelper = baseRules(styleId, p, p.fontFamily, fontSizes);
    const rules = `
  ${rulesHelper.root}
  ${rulesHelper.text}

  .axisTextStyle-${styleId} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.axisTick)}
    text-anchor: end;
  }
  .barTextStyle-${styleId} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.barLabel)}
    text-anchor: middle;
  }
  .setTextStyle-${style.id} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.setLabel)}
    text-anchor: middle;
    dominant-baseline: central;
  }
  .cChartTextStyle-${styleId} {
    fill: ${p.textColor};
    ${rulesHelper.p(fontSizes.chartLabel)}
  }

  .not-${style.id} {
    text-decoration: overline;
  }

  .axisLine-${styleId} {
    fill: none;
    stroke: ${p.textColor};
  }

  .gridStyle-${style.id} {
    fill: none;
    stroke: ${p.strokeColor};
    stroke-linecap: round;
  }
  .gridStyle-${style.id}-1 {
    stroke-width: 2;
  }
  .gridStyle-${style.id}-2 {
    stroke-width: 3;
  }

  ${rulesHelper.fill}
  ${rulesHelper.export}

  ${queries
        .map((q, i) => `.fillQ${i}-${data.id} {
    fill: ${q.color};
  }`)
        .join('\n')}
  `;
    const exportChart = useExportChart(data, p, 'kmap');
    const maxWidth = data.sets.l.reduce((acc, d) => Math.min(acc, d.text[0].x - data.sets.labelHeight), size.area.w);
    return (React.createElement(SVGWrapper, { rules: rules, style: style, size: size, p: p, data: data, tRef: ref, selectionName: selectionName, h: h, exportChart: exportChart },
        React.createElement(UpSetTitle, { style: style, width: maxWidth }),
        React.createElement(KMapChart, { style: style, data: data, h: h, size: size }),
        React.createElement(KMapSelection, { style: style, data: data, hasHover: h.hasHover, selection: selection }),
        React.createElement(KMapQueries$1, { style: style, data: data, hasHover: h.hasHover, queries: queries, secondary: h.hasHover || selection != null })));
});

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const defaults = {
    background: '#F4F4F4',
    color: '#A6A8AB',
    secondaryColor: '#E1E2E3',
};
function prepare(props) {
    var _a, _b, _c, _d;
    const color = (_a = props.color) !== null && _a !== void 0 ? _a : defaults.color;
    const secondary = (_b = props.secondaryColor) !== null && _b !== void 0 ? _b : defaults.secondaryColor;
    const rest = Object.assign({}, props);
    const background = (_c = props.background) !== null && _c !== void 0 ? _c : defaults.background;
    delete rest.color;
    delete rest.secondaryColor;
    delete rest.background;
    if (background) {
        rest.style = Object.assign({ background }, (_d = rest.style) !== null && _d !== void 0 ? _d : {});
    }
    return { color, secondary, rest };
}
/**
 * UpSetJS Skeleton a simple UpSetJS skeleton
 *
 * with React.forwardRef support to specify a reference to the SVG element
 */
const UpSetJSSkeleton = /*!#__PURE__*/ React.memo(
/*!#__PURE__*/ React.forwardRef(function UpSetJSSkeleton(props, ref) {
    const { color, secondary, rest } = prepare(props);
    const wi = 20;
    const padding = 10;
    const sWidth = 75;
    const sY = 110;
    const cHeight = 100;
    const csX = 85;
    const cOffsets = [10, 20, 35, 60, 65, 80, 90];
    const sOffsets = [50, 30, 15];
    return (React.createElement("svg", Object.assign({ viewBox: "0 0 300 200", ref: ref }, rest),
        cOffsets.map((offset, i) => (React.createElement("rect", { key: i, x: csX + i * (wi + padding), y: offset, width: wi, height: cHeight - offset, fill: color }))),
        sOffsets.map((offset, i) => (React.createElement("rect", { key: i, x: offset, y: sY + i * (wi + padding), width: sWidth - offset, height: wi, fill: color }))),
        cOffsets.map((_, i) => sOffsets.map((_, j) => {
            const filled = j === 2 - i || (i === 3 && j > 0) || (i === 4 && j !== 1) || (i === 5 && j < 2) || i === 6;
            return (React.createElement("circle", { key: `${i}x${j}`, cx: csX + i * (wi + padding) + wi / 2, cy: sY + j * (wi + padding) + wi / 2, r: wi / 2, fill: filled ? color : secondary }));
        })),
        React.createElement("rect", { x: "182", y: "150", width: "6", height: "30", fill: color }),
        React.createElement("rect", { x: "212", y: "120", width: "6", height: "60", fill: color }),
        React.createElement("rect", { x: "242", y: "120", width: "6", height: "30", fill: color }),
        React.createElement("rect", { x: "272", y: "120", width: "6", height: "60", fill: color })));
}));

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
/**
 * VennDiagram Skeleton a simple VennDiagram skeleton
 *
 * with React.forwardRef support to specify a reference to the SVG element
 */
const VennDiagramSkeleton = /*!#__PURE__*/ React.memo(
/*!#__PURE__*/ React.forwardRef(function VennDiagramSkeleton(props, ref) {
    const { color, secondary, rest } = prepare(props);
    const padding = 10;
    const l = layoutImpl(3, 300 - padding * 2, 3200 - padding * 2);
    return (React.createElement("svg", Object.assign({ viewBox: "0 0 300 200", ref: ref }, rest),
        l.sets.map((set, i) => (React.createElement("circle", { key: i, cx: set.cx, cy: set.cy + padding, r: set.r, fill: secondary }))),
        l.sets.map((set, i) => (React.createElement("circle", { key: i, cx: set.cx, cy: set.cy + padding, r: set.r, stroke: color, fill: "none" })))));
}));

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
/**
 * KV Diagram Skeleton a simple KarnaughMap skeleton
 *
 * with React.forwardRef support to specify a reference to the SVG element
 */
const KarnaughMapSkeleton = /*!#__PURE__*/ React.memo(
/*!#__PURE__*/ React.forwardRef(function KarnaughMapSkeleton(props, ref) {
    const { rest, color, secondary } = prepare(props);
    // const padding = 10;
    const { xBefore, yBefore, cell, hCells, vCells } = bounds(2, {
        width: 270,
        height: 170,
        labelHeight: 20,
    });
    const gw = hCells * cell;
    const gh = vCells * cell;
    const v1 = 0.9;
    const v2 = 0.5;
    const v3 = 0.26;
    const v4 = 0.75;
    return (React.createElement("svg", Object.assign({ viewBox: "0 0 300 200", ref: ref, fontFamily: "sans-serif" }, rest),
        React.createElement("g", { transform: `translate(${xBefore + 10},${yBefore + 10})` },
            React.createElement("text", { x: cell * 0.5, y: -3, fill: color, textAnchor: "middle" }, "A"),
            React.createElement("text", { x: cell * 1.5, y: -3, fill: color, textAnchor: "middle", style: { textDecoration: 'overline' } }, "A"),
            React.createElement("text", { x: -3, y: cell * 0.5, fill: color, textAnchor: "end", dominantBaseline: "central" }, "B"),
            React.createElement("text", { x: -3, y: cell * 1.5, fill: color, textAnchor: "end", dominantBaseline: "central", style: { textDecoration: 'overline' } }, "B"),
            React.createElement("rect", { x: cell * 0.1, y: cell * (1 - v1), height: cell * v1, width: cell * 0.8, fill: secondary }),
            React.createElement("rect", { x: cell * 1.1, y: cell * (1 - v2), height: cell * v2, width: cell * 0.8, fill: secondary }),
            React.createElement("rect", { x: cell * 0.1, y: cell * (1 - v3 + 1), height: cell * v3, width: cell * 0.8, fill: secondary }),
            React.createElement("rect", { x: cell * 1.1, y: cell * (1 - v4 + 1), height: cell * v4, width: cell * 0.8, fill: secondary }),
            React.createElement("path", { d: `M0,0 l${gw},0 l0,${gh} l${-gw},0 l0,${-gh} M${gw / 2},0 l0,${gh} M0,${gh / 2} l${gw},0`, fill: "none", stroke: color }))));
}));

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
const DEG2RAD = (1 / 180) * Math.PI;
function pointAtCircle(cx, cy, radius, angle) {
    return {
        x: cx + Math.cos(angle * DEG2RAD) * radius,
        y: cy + Math.sin(angle * DEG2RAD) * radius,
    };
}

/**
 * @upsetjs/react
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function center(circles) {
    const sumX = circles.reduce((acc, a) => acc + a.x, 0);
    const sumY = circles.reduce((acc, a) => acc + a.y, 0);
    return {
        x: sumX / circles.length,
        y: sumY / circles.length,
    };
}
function angleAtCircle(p, c) {
    const x = p.x - c.x;
    const y = p.y - c.y;
    return Math.atan2(y, x) / DEG2RAD;
}
function createVennJSAdapter(layout, options) {
    return {
        maxSets: Infinity,
        compute(sets, combinations, width, height) {
            const overlaps = combinations.map((c) => ({ sets: Array.from(c.sets).map((s) => s.name), size: c.cardinality }));
            const r = layout(overlaps, Object.assign({}, {
                width,
                height,
                distinct: true,
            }, options !== null && options !== void 0 ? options : {}));
            const singleSets = r.filter((d) => d.data.sets.length === 1);
            const setNames = new Map(sets.map((d, i) => [d.name, i]));
            const setCircles = singleSets.map((d) => d.circles[0]);
            const eulerCenter = center(setCircles);
            const asArc = (a) => ({
                x2: a.p1.x,
                y2: a.p1.y,
                cx: a.circle.x,
                cy: a.circle.y,
                sweep: true,
                large: a.width > a.circle.radius,
                ref: setCircles.findIndex((d) => Math.abs(d.x - a.circle.x) < 0.05 && Math.abs(d.y - a.circle.y) < 0.05),
                mode: 'i',
            });
            return {
                sets: singleSets.map((d) => {
                    const c = d.circles[0];
                    const angle = angleAtCircle(c, eulerCenter);
                    return {
                        cx: c.x,
                        cy: c.y,
                        r: c.radius,
                        align: angle > 90 ? 'end' : 'start',
                        verticalAlign: 'bottom',
                        text: pointAtCircle(c.x, c.y, c.radius * 1.1, angle),
                    };
                }),
                intersections: r.map((d) => {
                    const arcs = d.arcs;
                    const text = {
                        x: d.text.x,
                        y: d.text.y,
                    };
                    if (arcs.length === 0) {
                        return {
                            sets: d.data.sets.map((s) => setNames.get(s)),
                            text,
                            x1: 0,
                            y1: 0,
                            arcs: [],
                        };
                    }
                    if (arcs.length === 1) {
                        const c = d.arcs[0].circle;
                        return {
                            sets: d.data.sets.map((s) => setNames.get(s)),
                            text,
                            x1: d.arcs[0].p2.x,
                            y1: c.y - c.radius,
                            arcs: [asArc(d.arcs[0]), Object.assign(asArc(d.arcs[0]), { y2: c.y - c.radius })],
                            path: d.distinctPath || d.path,
                        };
                    }
                    return {
                        sets: d.data.sets.map((s) => setNames.get(s)),
                        text,
                        x1: d.arcs[0].p2.x,
                        y1: d.arcs[0].p2.y,
                        arcs: d.arcs.map((e) => asArc(e)),
                        path: d.distinctPath || d.path,
                    };
                }),
            };
        },
    };
}

/**
 * @upsetjs/bundle
 * https://github.com/upsetjs/upsetjs
 *
 * Copyright (c) 2021 Samuel Gratzl <sam@sgratzl.com>
 */
function widthRatios(value) {
    return value == null || (Array.isArray(value) && value.length >= 2 && value.every((v) => typeof v === 'number'));
}
function heightRatios(value) {
    return value == null || (Array.isArray(value) && value.length >= 1 && value.every((v) => typeof v === 'number'));
}
function setLabelAlignment(value) {
    return value == null || value === 'left' || value === 'center' || value === 'right';
}
function sets$6(value) {
    return Array.isArray(value) && value.every(isSet);
}
function combinations(value) {
    return (value == null || (Array.isArray(value) && value.every(isSetCombination)) || isGenerateSetCombinationOptions(value));
}
function selection(value) {
    return value == null || Array.isArray(value) || isSetLike$1(value);
}
function onHover(value) {
    return value == null || typeof value === 'function';
}
function onClick(value) {
    return value == null || typeof value === 'function';
}
function onContextMenu(value) {
    return value == null || typeof value === 'function';
}
function onMouseMove(value) {
    return value == null || typeof value === 'function';
}
function queries(value) {
    return !value || (Array.isArray(value) && value.every(isUpSetQuery));
}
function stringOrFalse(value) {
    return value == null || typeof value === 'string' || value === false;
}
function theme(value) {
    return value == null || value === 'light' || value === 'dark' || value === 'vega';
}
function classNames(value) {
    return (value == null ||
        Object.keys(value).every((k) => MULTI_STYLE_KEYS.includes(k) && typeof value[k] === 'string'));
}
function fontSizes(value) {
    return (value == null ||
        Object.keys(value).every((k) => FONT_SIZES_KEYS.includes(k) && typeof value[k] === 'string'));
}
function numericScale(value) {
    return value == null || value === 'linear' || value === 'log' || typeof value === 'function';
}
function bandScale(value) {
    return value == null || value === 'band' || typeof value === 'function';
}
function axisOffset(value) {
    return value == null || value === 'auto' || typeof value === 'number';
}
function style(value) {
    return value == null || typeof value === 'object';
}
function styles(value) {
    return (value == null ||
        Object.keys(value).every((k) => MULTI_STYLE_KEYS.includes(k)));
}
function exportButtons(value) {
    return (value == null ||
        typeof value === 'boolean' ||
        Object.keys(value).every((k) => EXPORT_OPTION_KEYS.includes(k) && typeof value[k] === 'boolean'));
}

var validators = /*#__PURE__*/Object.freeze({
    __proto__: null,
    widthRatios: widthRatios,
    heightRatios: heightRatios,
    setLabelAlignment: setLabelAlignment,
    sets: sets$6,
    combinations: combinations,
    selection: selection,
    onHover: onHover,
    onClick: onClick,
    onContextMenu: onContextMenu,
    onMouseMove: onMouseMove,
    queries: queries,
    stringOrFalse: stringOrFalse,
    theme: theme,
    classNames: classNames,
    fontSizes: fontSizes,
    numericScale: numericScale,
    bandScale: bandScale,
    axisOffset: axisOffset,
    style: style,
    styles: styles,
    exportButtons: exportButtons
});

export default UpSetJS;
export { KarnaughMap, KarnaughMapSkeleton, UpSetJS, UpSetJSSkeleton, VennDiagram, VennDiagramSkeleton, createVennJSAdapter, downloadUrl, exportSVG, exportVegaLite, fillDefaults, fillDefaultsG, fillKarnaughMapDefaults, fillKarnaughMapDefaultsG, fillVennDiagramDefaults, fillVennDiagramDefaultsG, getDefaultTheme, isEllipse, validators as propValidators, toUpSetJSDump, toUpSetJSStaticDump };
//# sourceMappingURL=index.js.map
